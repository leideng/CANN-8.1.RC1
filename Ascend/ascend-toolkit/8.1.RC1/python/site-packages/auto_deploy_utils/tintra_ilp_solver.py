#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2023. Huawei Technologies Co., Ltd. All rights reserved.

tintra ilp solver implement
"""
import sys
import time
import traceback
from typing import Any
import numpy as np
try:
    import pulp
    from pulp import LpVariable, LpProblem, LpMinimize, lpSum, lpDot, LpStatus
except ImportError as e:
    raise ImportError({"errCode": 'EF1005', "reason": "Failed to import the pulp module."}) from e

from .tintra_ilp_solver_log import LOG_INSTANCE
from .tintra_ilp_solver_return_code import ReturnCodeEnum

MEMORY_BUDGET_LOC = 0
SCOPE_STRATEGY_LEN_LOC = 1
FOLLOW_LIST_LOC = 2
COMPUTE_COST_LOC = 3
COMMUNICATION_COST_LOC = 4
EDGE_TUPLE_LIST_LOC = 5
RESHARD_COST_LOC = 6
LIVENESS_TUPLE_LIST_LOC = 7
MEMORY_COST_LOC = 8
VAILED_ARGS_LEN = 9
INFINITY_COST = 1e13 / 1.0
TIME_LIMIT = 1800
NEGATIVE_ONE = -1
COMMUNICATION_RATE = 1


def pulp_check() -> bool:
    return "pulp" in sys.modules


def coin_or_cbc_check() -> bool:
    return "COIN_CMD" in pulp.listSolvers(onlyAvailable=True)


def call_solver(*args : Any) -> (list, float):
    """
    The external interface of the ILP solver, called by the cpython side
    """
    if not pulp_check():
        return [], INFINITY_COST, ReturnCodeEnum.PULP_IMPORT_ERR.code # return pulp import error code to cpython

    if not coin_or_cbc_check():
        LOG_INSTANCE.error("Please install ILP solvers: coinor-cbc.")
        return [], INFINITY_COST, ReturnCodeEnum.COIN_OR_CBC_ERR.code # return coin-or-cbc error code to cpython

    if len(args) != VAILED_ARGS_LEN:
        LOG_INSTANCE.error("Invalied length[%d] of input args.", len(args))
        return [], INFINITY_COST, ReturnCodeEnum.FAILED.code

    LOG_INSTANCE.debug("Pre-check success, run ilp solver.")
    ilp_solver = ILPSolver(*args)
    return ilp_solver.call_solver()


class ILPSolver:
    """
    ILP solver
    """
    def __init__(self, *args : Any):
        """
        Initialize input parameters, serialize python lists to flatten numpy arraies
        """
        self.memory_budget = args[MEMORY_BUDGET_LOC]
        self.scope_strategy_len = args[SCOPE_STRATEGY_LEN_LOC]
        self.follow_list = args[FOLLOW_LIST_LOC]
        self.scope_num = len(self.follow_list)
        self.compute_cost = [np.array(x, dtype=np.float64) for x in args[COMPUTE_COST_LOC]]
        self.communication_cost = [np.array(x, dtype=np.float64) for x in args[COMMUNICATION_COST_LOC]]
        self.edge_tuple_list = args[EDGE_TUPLE_LIST_LOC]
        self.reshard_cost = [np.array(x, dtype=np.float64) for x in args[RESHARD_COST_LOC]]
        self.liveness_tuple_list = args[LIVENESS_TUPLE_LIST_LOC]
        self.memory_cost = [np.array(x, dtype=np.float64) for x in args[MEMORY_COST_LOC]]

    @staticmethod
    def get_non_zero_index(binary_vector: list) -> int:
        """
        Get the index of non-zero item in a vector.
        """
        not_zero_num = 0
        index = NEGATIVE_ONE
        for idx, item in enumerate(binary_vector):
            if pulp.value(item):
                index = idx
                not_zero_num += 1

        if not_zero_num != 1:
            LOG_INSTANCE.error("The number of non-zero values is greater than 1.")
            return NEGATIVE_ONE
        return index

    @staticmethod
    def call_ilp_solver(ilp_problem: object, start_time: float) -> float:
        """
        Call solver for ILP objective
        """
        solver = pulp.COIN_CMD(mip=True, msg=False, timeLimit=TIME_LIMIT, options=["passPresolve 1", "maxSolutions 3"])
        ilp_problem.solve(solver)
        status = ilp_problem.status
        objective = pulp.value(ilp_problem.objective)
        objective = float(objective) if objective is not None else NEGATIVE_ONE / 1.0
        LOG_INSTANCE.event("Information ilp status: %s, objective: %f, duration: %ds.", str(LpStatus[status]),
            objective, time.time() - start_time)

        if ilp_problem.status in [pulp.LpStatusInfeasible]:
            LOG_INSTANCE.error("No valid solution, please increase the memory budget and retry.")
            return INFINITY_COST
        LOG_INSTANCE.debug("call_ilp_solver finished.")
        return objective

    def create_variables(self) -> (list, list):
        """
        Create ILP solver variables
        """
        strategy_matrix = []
        edge_matrix = []
        reverse_follow_backpatch = []
        num_nodes = 0
        for scope_idx in range(self.scope_num):
            if self.follow_list[scope_idx] < 0:
                if self.scope_strategy_len[scope_idx] == 1:
                    strategy_matrix.append([1])
                else:
                    num_nodes += 1
                    strategy_matrix.append(LpVariable.matrix(f"s[{scope_idx}]",
                                                            (range(self.scope_strategy_len[scope_idx]),),
                                                            cat="Binary"))
            else:
                if self.follow_list[scope_idx] < len(strategy_matrix):
                    strategy_matrix.append(strategy_matrix[self.follow_list[scope_idx]])
                else:
                    strategy_matrix.append(None)
                    reverse_follow_backpatch.append(scope_idx)

        for idx in reverse_follow_backpatch:
            strategy_matrix[idx] = strategy_matrix[self.follow_list[idx]]

        num_edges = 0
        for idx, (src_id, dst_id) in enumerate(self.edge_tuple_list):
            if len(strategy_matrix[src_id]) == 1:
                edge_matrix.append(strategy_matrix[dst_id])
            elif len(strategy_matrix[dst_id]) == 1:
                edge_matrix.append(strategy_matrix[src_id])
            else:
                num_edges += 1
                edge_matrix.append(LpVariable.matrix(f"e[{src_id},{dst_id}]",
                                  (range(len(strategy_matrix[src_id]) * len(strategy_matrix[dst_id])),),
                                  cat="Binary"))
            if len(edge_matrix[idx]) != len(self.reshard_cost[idx]):
                LOG_INSTANCE.error("The lengths of edge matrix[%d] and reshard cost[%d] are different.",
                                    len(edge_matrix[idx]), len(self.reshard_cost[idx]))
                return [], []
        LOG_INSTANCE.info("nodes: %d, edges: %d.", num_nodes, num_edges)
        return strategy_matrix, edge_matrix

    def build_objective(self, strategy_matrix: list, edge_matrix: list) -> object:
        """
        Build ILP objective
        """
        ilp_problem = LpProblem("TPProblem", LpMinimize)
        self.scope_num = len(self.compute_cost)
        obj = 0
        for idx in range(self.scope_num):
            obj += lpDot(strategy_matrix[idx], self.compute_cost[idx]) + \
                COMMUNICATION_RATE * lpDot(strategy_matrix[idx], self.communication_cost[idx])
        for idx in range(len(self.edge_tuple_list)):
            obj += COMMUNICATION_RATE * lpDot(edge_matrix[idx], self.reshard_cost[idx])
        ilp_problem += obj
        return ilp_problem

    def add_memory_constraint(self, strategy_matrix: list, ilp_problem: object) -> None:
        """
        Add memory cost constfor ILP objective
        """
        if self.memory_budget <= 0:
            return

        for idx in range(len(self.memory_cost)):
            memory_use = 0
            if self.liveness_tuple_list[idx]:
                for scope_node_id in self.liveness_tuple_list[idx]:
                    memory_use += lpSum(strategy_matrix[scope_node_id[0]][stra] * \
                        self.memory_cost[scope_node_id[1]][stra] \
                        for stra in range(len(strategy_matrix[scope_node_id[0]])))
            if memory_use != 0:
                ilp_problem += memory_use <= self.memory_budget
        LOG_INSTANCE.debug("add_memory_constraint finished.")

    def add_edge_matrix_constraint(self, edge_matrix: list, strategy_matrix: list, ilp_problem: object) -> None:
        """
        Add edge matrix constraint for ILP objective
        """
        for idx, (src_id, dst_id) in enumerate(self.edge_tuple_list):
            if self.scope_strategy_len[src_id] == 1 or self.scope_strategy_len[dst_id] == 1:
                continue

            ilp_problem += lpSum(edge_matrix[idx]) == 1

            row_num = len(strategy_matrix[src_id])
            col_num = len(strategy_matrix[dst_id])
            for row in range(row_num):
                ilp_problem += lpSum(edge_matrix[idx][row * col_num + col] for col in range(0, col_num)) <= \
                    strategy_matrix[src_id][row]

            for col in range(col_num):
                ilp_problem += lpSum(edge_matrix[idx][row * col_num + col] for row in range(0, row_num)) <= \
                    strategy_matrix[dst_id][col]

    def get_strategy_val(self, strategy_matrix: list, edge_matrix: list) -> list:
        """
        Get selected strategy value from ILP solver
        """
        strategy_val = np.full((self.scope_num,), NEGATIVE_ONE, dtype=np.int64)
        for idx in range(self.scope_num):
            strategy_val[idx] = self.get_non_zero_index(strategy_matrix[idx])
            if strategy_val[idx] == NEGATIVE_ONE:
                LOG_INSTANCE.error("The resulting strategy is an illegal value for scope %d.", idx)
                return []

        edge_val = np.full((len(self.edge_tuple_list),), NEGATIVE_ONE, dtype=np.int64)
        for idx, (src_id, dst_id) in enumerate(self.edge_tuple_list):
            edge_val[idx] = self.get_non_zero_index(edge_matrix[idx])
            if edge_val[idx] == NEGATIVE_ONE:
                LOG_INSTANCE.error("The resulting edge tuple is an illegal value for scope %d.", idx)
                return []

            src_spec_index = edge_val[idx] // len(strategy_matrix[dst_id])
            dst_spec_index = edge_val[idx] % len(strategy_matrix[dst_id])
            if src_spec_index == strategy_val[src_id] or dst_spec_index == strategy_val[dst_id]:
                LOG_INSTANCE.debug("Src_id: %d, dst_id: %d, edge_val[%d]: %d", src_id, dst_id, idx, edge_val[idx])
            if self.reshard_cost[idx][edge_val[idx]] > 0:
                LOG_INSTANCE.debug("Src_id: %d, dst_id: %d, edge_cost[%d][%d]: %d", src_id, dst_id, idx, edge_val[idx],
                    self.reshard_cost[idx][edge_val[idx]])
        LOG_INSTANCE.debug("Strategy_val len %d, edge_val len %d.", len(strategy_val), len(edge_val))
        return strategy_val.tolist()

    def call_solver(self) -> (list, float):
        """
        The external interface of the ILP solver, called by the cpython side
        """
        start_time = time.time()
        LOG_INSTANCE.debug("Start to create variables.")
        strategy_matrix, edge_matrix = self.create_variables()
        if strategy_matrix == []:
            return [], INFINITY_COST, ReturnCodeEnum.FAILED.code

        LOG_INSTANCE.debug("Start to build objective.")
        ilp_problem = self.build_objective(strategy_matrix, edge_matrix)

        LOG_INSTANCE.debug("Start to add constraints.")
        # (a) Add strategy matrix constraint
        for idx in range(self.scope_num):
            if self.follow_list[idx] < 0:
                ilp_problem += lpSum(strategy_matrix[idx]) == 1
        # (b) Add memory cost constraint
        self.add_memory_constraint(strategy_matrix, ilp_problem)
        # (c) Add edge matrix constraint
        self.add_edge_matrix_constraint(edge_matrix, strategy_matrix, ilp_problem)

        try:
            LOG_INSTANCE.debug("Start to call ILP slover.")
            objective = self.call_ilp_solver(ilp_problem, start_time)
        except OSError as exception:
            LOG_INSTANCE.error("Failed to solve the ilp problem, please check the coin_cbc is usable.")
            LOG_INSTANCE.error("Traceback info: %s.", traceback.format_exc())
            return [], INFINITY_COST, ReturnCodeEnum.COIN_OR_CBC_ERR.code
        finally:
            pass
        if objective >= INFINITY_COST:
            LOG_INSTANCE.error("Failed to call ilp solver.")
            return [], INFINITY_COST, ReturnCodeEnum.FAILED.code

        LOG_INSTANCE.debug("Start to get strategy_val and check results.")
        strategy_val = self.get_strategy_val(strategy_matrix, edge_matrix)
        if strategy_val is None:
            LOG_INSTANCE.error("Failed to get strategy value from ilp solver result.")
            return [], INFINITY_COST, ReturnCodeEnum.FAILED.code

        return strategy_val, objective, ReturnCodeEnum.SUCCESS.code
