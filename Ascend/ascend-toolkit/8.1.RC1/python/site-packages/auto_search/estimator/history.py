#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
rl schedule search, tss
"""
import hashlib
import json
import os
from auto_search.utils import logger
from auto_search.utils import util
from auto_search.utils.util import ErrorCode

HIT_SUCC_NUM = 1
MISS_SUCC_NUM = 2
HIT_FAIL_NUM = -1
MISS_FAIL_NUM = -2


def _generate_sampler_key(op_md5, option, cheque_list):
    """

    :param op_md5:
    :param cheque_list:
    :return:
    """
    md5_obj = hashlib.sha256()
    key_str = str(option) + str(cheque_list)
    md5_obj.update(key_str.encode())
    cheque_md5 = md5_obj.hexdigest()[:util.HASH_LEN]
    return op_md5 + "@" + cheque_md5


def get_history_result(op_schedule_info, cheque_list, history_dict):
    """

    :param op_schedule_info:
    :param cheque_list:
    :param history_dict:
    :return:
    """
    op_md5 = op_schedule_info.op_md5
    option = op_schedule_info.option
    try:
        k = _generate_sampler_key(op_md5, option, cheque_list)
        return history_dict.get(k, ("", None))
    except Exception:  # pylint: disable=broad-except
        logger.warn('can not get history result.')
        return "", None


def update_history_result(op_schedule_info, cheque_list, ret, tick,
                          history_dict):
    """

    :param op_schedule_info:
    :param cheque_list:
    :param ret:
    :param tick:
    :param history_dict:
    """
    op_md5 = op_schedule_info.op_md5
    option = op_schedule_info.option
    try:
        k = _generate_sampler_key(op_md5, option, cheque_list)
        history_dict[k] = (ret, tick)
    except Exception:
        logger.warn('can not update history result.')


def update_hit_history(shape_list_str, hit, ret, hit_history_dict):
    """
    minus means failure: -1: HIT_FAIL_NUM; -2: MISS_FAIL_NUM
    negative mens success: 1: hit_succ; 2: MISS_SUCC_NUM
    :param shape_list_str:
    :param hit:
    :param ret:
    :param hit_history_dict:
    :return:
    """
    hit_history_dict.setdefault(shape_list_str, [])
    hit_history_dict.setdefault("all", [])
    if not hit:
        if ret == ErrorCode.RUN_SUCC:
            hit_history_dict[shape_list_str] += [MISS_SUCC_NUM]
            hit_history_dict["all"] += [MISS_SUCC_NUM]
        else:
            hit_history_dict[shape_list_str] += [MISS_FAIL_NUM]
            hit_history_dict["all"] += [MISS_FAIL_NUM]
    elif ret != ErrorCode.RUN_SUCC:
        logger.debug('history hit, ret is invaild.')
        hit_history_dict[shape_list_str] += [HIT_FAIL_NUM]
        hit_history_dict["all"] += [HIT_FAIL_NUM]
    else:
        logger.debug('history hit, succ!')
        hit_history_dict[shape_list_str] += [HIT_SUCC_NUM]
        hit_history_dict["all"] += [HIT_SUCC_NUM]


def dump_hit_history(shape_list_str, store_dir, hit_history_dict):
    """

    :param shape_list_str:
    :param store_dir:
    :param hit_history_dict:
    :return:
    """
    if not os.path.exists(store_dir):
        logger.warn("store_dir:%s not exists!", store_dir)
        return

    replay_shape_cnt = len(hit_history_dict[shape_list_str])
    if replay_shape_cnt % 100 != 0:
        hit_history_file_shape = os.path.join(store_dir, 'hit_history.json')
        with os.fdopen(os.open(hit_history_file_shape, util.WRITE_FILE_FLAGS, util.OPEN_FILE_MODES_640), "w") \
                as file_handler:
            json.dump(hit_history_dict[shape_list_str], file_handler)
