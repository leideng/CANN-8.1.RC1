#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import json
import os
import time
import numpy as np
from auto_search.utils import logger
from auto_search.utils import util
from auto_search.config import global_manager
from auto_search.estimator import estimate
from auto_search.utils.util import ErrorCode
from auto_search.estimator.history import dump_hit_history
from auto_search.estimator.history import get_history_result
from auto_search.estimator.history import update_history_result
from auto_search.estimator.history import update_hit_history
from auto_search.utils.util import SchInfo
from auto_search.utils.util import KernelInfo


def _actions_oom_proc(op_schedule_info, action_tensors):
    """
    action_tensors -> schedule -> build, generate .o, schedule obj, schedule code, cleaned_actions
    if oom, decrease factor, try again
    """
    single_op_schedule_info = op_schedule_info
    err_code, _ = get_history_result(single_op_schedule_info,
                                     op_schedule_info.cheque_list, global_manager.HISTORY_DICT)
    if not err_code:
        output = estimate.actions_to_kernel_bin(action_tensors,
                                                op_schedule_info,
                                                print_output=False)
        if isinstance(output, list):
            error_code = output[0].error_code
        else:
            error_code = output.error_code
        if error_code != ErrorCode.BUILD_SUCC_:
            # update hit history
            update_history_result(single_op_schedule_info,
                                  op_schedule_info.cheque_list,
                                  error_code, 0, global_manager.HISTORY_DICT)
    else:
        sch_info = SchInfo(None, "", None, {}, None)
        output = [KernelInfo(err_code, None, sch_info)]
        logger.debug("can not build, hit once!")

    return output


def _evb_run_tick(op_schedule_info, kernel_info, print_output):
    """
    :param op_schedule_info:
    :param kernel_info:
    :param print_output:
    :return:
    """
    if isinstance(op_schedule_info, list):
        single_op_schedule_info = op_schedule_info[0]
        single_kernel_info = kernel_info[0]
    else:
        single_op_schedule_info = op_schedule_info
        single_kernel_info = kernel_info

    # 1、can use dict cache
    shape_list_str = single_op_schedule_info.shape_list_str
    err_code, tick = get_history_result(single_op_schedule_info, single_kernel_info.sch_info.cheque_list,
                                        global_manager.HISTORY_DICT)

    hit = True
    # 3、not hit, try run
    if not err_code:
        logger.debug('cache miss!')
        new_err_code, new_tick = estimate.proc(op_schedule_info, kernel_info)

        # maybe has updated because of multi batch running
        err_code, tick = get_history_result(single_op_schedule_info, single_kernel_info.sch_info.cheque_list,
                                            global_manager.HISTORY_DICT)
        if not err_code:
            # update history
            update_history_result(single_op_schedule_info,
                                  single_kernel_info.sch_info.cheque_list,
                                  new_err_code, new_tick, global_manager.HISTORY_DICT)
            err_code = new_err_code
            tick = new_tick
            hit = False

    # update hit history
    update_hit_history(shape_list_str, hit, err_code, global_manager.HIT_HISTORY_DICT)
    dump_hit_history(shape_list_str, single_op_schedule_info.store_dir,
                     global_manager.HIT_HISTORY_DICT)

    return err_code, tick


def _get_tick(action_tensors,
              op_schedule_info,
              print_output=False,
              moves=None):
    """
    :param action_tensors:
    :param op_schedule_info:
    :param print_output:
    :param moves:
    :return:
    """
    # 1、record moves
    if moves and not isinstance(op_schedule_info, list):
        op_schedule_info.update_moves(moves)

    # 2、actions_oom_proc
    kernel_info = _actions_oom_proc(op_schedule_info, action_tensors)

    # 3、get tick
    if isinstance(kernel_info, list):
        single_kernel_info = kernel_info[0]
    else:
        single_kernel_info = kernel_info
    # if build failed then do no need get tick
    if single_kernel_info.error_code != ErrorCode.BUILD_SUCC_:
        result_list = [False, 0, single_kernel_info.sch_info.cleaned_actions, single_kernel_info.error_code,
                       single_kernel_info.sch_info.retry_t2c_rules]
        return result_list

    err_code, tick = _evb_run_tick(op_schedule_info, kernel_info, print_output)

    ret = err_code == ErrorCode.RUN_SUCC
    result_list = [ret, tick, single_kernel_info.sch_info.cleaned_actions, err_code,
                   single_kernel_info.sch_info.retry_t2c_rules]
    return result_list


def get_tick(action_tensors,
             op_schedule_info,
             print_output=False,
             moves=None):
    """
    :param action_tensors:
    :param op_schedule_info:
    :param print_output:
    :param moves:
    :return:
    """
    def gen_excp_info(op_sch_obj, action_tensor):
        content = "# compute_at_dict:"
        content += json.dumps(op_sch_obj.ori_at_dict, ensure_ascii=False)
        content += "\n" + str(action_tensor) + "\n"
        return content

    if isinstance(op_schedule_info, list):
        new_action_tensors = []
        for action_tensor in action_tensors:
            if isinstance(action_tensor, np.ndarray):
                action_tensor = action_tensor.tolist()
            new_action_tensors.append(action_tensor)
        action_tensors = new_action_tensors
    else:
        if isinstance(action_tensors, np.ndarray):
            action_tensors = action_tensors.tolist()

    try:
        ret, tick, cleaned_actions, err_code, retry_t2c_rules = _get_tick(
            action_tensors,
            op_schedule_info,
            print_output=print_output,
            moves=moves)
        return tick
    except (KeyboardInterrupt, BrokenPipeError):
        return None
    except Exception as exception:
        # save action tensor to store tmp
        import traceback
        logger.warn('exception occur!\n%s', str(traceback.format_exc()))
        ret, tick, cleaned_actions, err_code = False, 0, action_tensors, ErrorCode.ENV_EXCEPTION
        content = ""
        if isinstance(op_schedule_info, list):
            store_dir = op_schedule_info[0].store_dir
            for i, op_sch_obj in enumerate(op_schedule_info):
                content += gen_excp_info(op_sch_obj, action_tensors[i])
        else:
            store_dir = op_schedule_info.store_dir
            content += gen_excp_info(op_schedule_info, action_tensors)
        content += str(exception)
        store_tmp_dir = os.path.join(store_dir, err_code)
        unique_id = str(os.getpid()) + "_" + str(int(time.time() * 1000))
        except_record = os.path.join(store_tmp_dir, "action_%s.txt" % unique_id)
        util.write_to_file(except_record, content=content)
        return tick
