#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2022. All rights reserved.

om runner
"""
import datetime
import os
import sys
import time

from auto_search.utils import logger
from auto_search.utils import util
from auto_search.config.config import BASE_RUN_TIMEOUT
from auto_search.config.config import RUN_TIMEOUT
from auto_search.config import global_manager
from auto_search.utils.util import ErrorCode
from auto_search.utils.util import store_tmp_proc
from auto_search.bank.add_cheque import get_outputs
from tbe.common.rl_bank.search_bank import get_rl_bank_key

CB_TASK_QUEUE = None
CB_RES_DICT = None
CB_RELEASE_QUEUE = None
DEFAULT_OM_RUN_THRESHOLD = 18446744073709551615
BASE_RUN_TIME_FACTOR = 20


class OMRunner:
    """
    OMRunner
    """
    def __init__(self, op_schedule_info, kernel_info, run_base=False, datacmp_args_dict: dict = None):
        self.op_schedule_info = op_schedule_info
        self.compute_code = op_schedule_info.compute_code.split("\n")
        self.is_store_cheque = op_schedule_info.option.get("is_store_cheque", False)
        self.save_best_flag = op_schedule_info.option.get("save_best_flag", False)

        # not_store_sch indicates that store py files or not
        if op_schedule_info.option.get("not_store_sch", False):
            self.store_tmp_sch = False
        else:
            self.store_tmp_sch = not run_base

        self.cb_struct_key = self.op_schedule_info.option.get('op_config').get('cb_struct_key')
        self.cheque_list = []

        self.cb_task_queue = CB_TASK_QUEUE
        self.cb_res_dict = CB_RES_DICT
        self.cb_release_queue = CB_RELEASE_QUEUE
        self.run_base_flag = run_base
        self.need_datacmp = False
        self.re_run_base = False
        if datacmp_args_dict is not None:
            self.need_datacmp = datacmp_args_dict.get("need_datacmp", False)
            self.re_run_base = datacmp_args_dict.get("re_runbase", False)
        self.run_task_queue = self.cb_task_queue
        self.run_res_dict = self.cb_res_dict
        self.kernel_name = self.op_schedule_info.option.get('op_config').get("kernel_name", "default")

        if self.run_base_flag:
            if self.re_run_base:
                self.run_task_queue = datacmp_args_dict.get("rerun_task_q", None)
                self.run_res_dict = datacmp_args_dict.get("rerun_res_d", None)
                self.cb_release_queue = datacmp_args_dict.get("rerun_release_q", None)
            self.run_time_baseline = DEFAULT_OM_RUN_THRESHOLD
            self.is_store_cheque = False
            self.cheque_str_list = [str({"rl_cheque": {"fake_key": []}, "kernel_name": self.kernel_name})]
            self.run_timeout = self.op_schedule_info.option.get("base_run_timeout", BASE_RUN_TIMEOUT)
        else:
            self.run_time_baseline = self.op_schedule_info.base_totaltime
            self.kernel_run_obj = kernel_info.kernel_run_obj
            self.block_dim = self.kernel_run_obj.block_dim if self.kernel_run_obj is not None else None
            self.schedule_code = kernel_info.sch_info.code
            self.cheque_list = kernel_info.sch_info.cheque_list
            bank_key = op_schedule_info.option.get('op_config', {}).get("bank_key", [])
            self.bank_key = bank_key if bank_key else self._gen_bank_key()
            if self.need_datacmp:
                self.run_task_queue = datacmp_args_dict.get("datacmp_task_q", None)
                self.run_res_dict = datacmp_args_dict.get("datacmp_res_d", None)
                self.cheque_str_list = []
                for cheque in self.cheque_list:
                    tmp_cheque_str = str({"rl_cheque": {self.bank_key: cheque}, "kernel_name": self.kernel_name})
                    self.cheque_str_list.append(tmp_cheque_str)
                # retrieve run om timeout same as base run om timeout
                self.run_timeout = max(self.op_schedule_info.base_run_time * BASE_RUN_TIME_FACTOR,
                                       self.op_schedule_info.option.get("base_run_timeout", BASE_RUN_TIMEOUT))
            else:
                self.cheque_str_list = \
                    [str({"rl_cheque": {self.bank_key: self.cheque_list}, "kernel_name": self.kernel_name})]
                self.run_timeout = max(self.op_schedule_info.base_run_time * BASE_RUN_TIME_FACTOR,
                                       self.op_schedule_info.option.get("run_timeout", RUN_TIMEOUT))

    @staticmethod
    def get_tick_from_cb(callback_ret_dict):
        """
        get_tick_from_cb
        :param callback_ret_dict:
        :return:
        """
        tick = int(callback_ret_dict["aiCoreCostTime"].get(callback_ret_dict["opName"], 0))

        if not tick:
            tick = int(callback_ret_dict["opCostTime"].get(callback_ret_dict["opName"], 0))
        # the unit of callback is ns
        if tick == 0:
            return tick
        return int(tick / 1000)

    @staticmethod
    def get_global_best() -> int:
        """
        get global best tick from best_cheque_dict
        """
        best_cheque_dict_values = global_manager.BEST_CHEQUE_DICT.values()
        total_saved_cheque_list = []
        for saved_cheque_list in best_cheque_dict_values:
            total_saved_cheque_list.extend(saved_cheque_list)
        global_best_tick = min(total_saved_cheque_list,
                               key=lambda item: item.get("best_tick", sys.maxsize)).get("best_tick", sys.maxsize)
        return global_best_tick

    def run(self):
        """
        run during tuning process without precision calibration
        :return:
        """
        task_id = '{}_pid{}_{}'.format(self.op_schedule_info.option.get('op_config').get("kernel_name", "default"),
                                       os.getpid(), datetime.datetime.utcnow().strftime('%Y%m%d_%H%M%S_%f'))
        main_pid = self.op_schedule_info.option.get('main_pid')
        if not util.pid_exists(main_pid):
            logger.info("om runner info: main process %s ends, current process is %s.", main_pid, os.getpid())
            return False, 0, ErrorCode.RUN_CRASH

        # put run task to task_queue
        logger.info("om runner info: put task %s (cb_struct_key: %s) to %s.",
                    task_id, self.cb_struct_key, self.run_task_queue)
        self.run_task_queue.put({
            task_id: {
                "cb_struct_key": self.cb_struct_key,
                "strategy_list": self.cheque_str_list,
                "need_integrate": False,
                "tune_mode": "AS",  # auto search
                "costtime_baseline": self.run_time_baseline
                }
        })

        base_task_start_time = time.time()

        # get run result from res_queue
        callback_ret = []
        cb_begin = time.time()

        logger.debug("om runner info: %s wait run result with timeout %s.", task_id, self.run_timeout)
        while time.time() - cb_begin <= self.run_timeout:
            if not util.pid_exists(main_pid):
                logger.warn("om runner info: main process %s is dead, stop current om runner subprocess %s.",
                            main_pid, os.getpid())
                return False, 0, ErrorCode.RUN_CRASH
            if self.run_res_dict.get(task_id, None) is not None:
                callback_ret = self.run_res_dict.get(task_id)
                if not self.need_datacmp:
                    self.cb_release_queue.put(task_id)
                logger.info("om runner info: get %s callback_ret: %s.", task_id, callback_ret)
                break
            time.sleep(0.5)

        base_task_end_time = time.time()
        if self.run_base_flag:
            self.op_schedule_info.base_run_time = base_task_end_time - base_task_start_time

        return self._get_ret_from_cb(callback_ret, task_id)

    def _get_ret_from_cb(self, callback_ret: list, task_id: str):
        """
        get tick and err_code for single callbackret_dict
        :param callback_ret:
        :param task_id:
        :return: ret, tick, err_code
        """
        if not callback_ret:
            logger.warn("om runner info: callback task %s cannot get result, callback_ret is %s.",
                        task_id, callback_ret)
            return False, 0, ErrorCode.RUN_CRASH

        callback_parsed_rets = []
        callback_ticks = []
        callback_errcodes = []
        for callback_ret_dict in callback_ret:
            if not bool(callback_ret_dict):
                logger.warn("om runner info: callback task: %s cannot get single result.", task_id)

            if not callback_ret_dict.get("aiCoreCostTime", None) or not callback_ret_dict.get("opName", None):
                logger.warn("om runner info: task: %s has no aiCoreCostTime or opName, callback_ret_dict: %s.",
                            task_id, callback_ret_dict)
                self._post_proc(0, ErrorCode.RUN_CRASH)
                callback_parsed_rets.append(False)
                callback_ticks.append(0)
                callback_errcodes.append(ErrorCode.RUN_CRASH)
                continue

            # parse for tick
            tick = self.get_tick_from_cb(callback_ret_dict)
            if self.run_base_flag:
                self.op_schedule_info.base_totaltime = int(callback_ret_dict.get("profE2ECostTime", 0))
            err_code = ErrorCode.RUN_CRASH
            if tick > 0:
                if str(callback_ret_dict.get("verify", False)).lower() == "true":
                    err_code = ErrorCode.RUN_SUCC
                else:
                    err_code = ErrorCode.RUN_FAIL
            self._post_proc(tick, err_code)
            callback_parsed_rets.append(True)
            callback_ticks.append(tick)
            callback_errcodes.append(err_code)
            logger.debug("om runner info: get_single_ret_from_cb end, res: %s, tick: %d, task_id: %s, "
                         "cheque_list: %s.", err_code, tick, task_id, self.cheque_list)

        if not self.need_datacmp:
            return callback_parsed_rets[0], callback_ticks[0], callback_errcodes[0]

        if sum(callback_parsed_rets) > 0:
            return True, callback_ticks, callback_errcodes
        return False, callback_ticks, callback_errcodes

    def _post_proc(self, tick: int, err_code: str) -> None:
        """
        post_proc
        :param tick:
        :return:
        """
        if self.need_datacmp:
            return

        if self.is_store_cheque:
            self._update_best_cheque(tick, err_code)
            if self.save_best_flag and err_code == ErrorCode.RUN_SUCC:
                self._save_best_py(tick, err_code)

        if self.store_tmp_sch:
            store_path = store_tmp_proc(self.op_schedule_info,
                                        self.schedule_code,
                                        err_code,
                                        self.kernel_run_obj.kernel_name,
                                        tick=tick if tick > 0 else None)
            logger.debug("om runner info: sch store path: %s.", store_path)

    def _update_best_cheque(self, current_tick: int, err_code: str) -> None:
        """
        compare and update best tick with current_tick
        :param current_tick:
        :param err_code:
        :return:
        """
        kernel_name = self.op_schedule_info.option.get('op_config').get("kernel_name", "default")
        if err_code != ErrorCode.RUN_SUCC:
            logger.info("om runner info: unable to update best_cheque, op: %s, tick: %s, err_code: %s.",
                        kernel_name, current_tick, err_code)
            return

        best_cheque_info = {
            "base_tick": self.op_schedule_info.base_tick,
            "best_tick": current_tick,
            "bank_key": self.bank_key,
            "block_dim": self.block_dim,
            "cheque": self.cheque_list
        }

        pid = os.getpid()
        if not global_manager.BEST_CHEQUE_DICT.get(pid, {}):
            global_manager.BEST_CHEQUE_DICT[pid] = [best_cheque_info]
        else:
            saved_cheque_list = global_manager.BEST_CHEQUE_DICT.get(pid)
            saved_cheque_list.extend([best_cheque_info])
            global_manager.BEST_CHEQUE_DICT[pid] = saved_cheque_list
        logger.debug("om runner info: update_best_cheque finished, op: %s, pid: %s, tick: %s, err_code: %s.",
                     kernel_name, pid, current_tick, err_code)

    def _save_best_py(self, current_tick: int, err_code: str) -> None:
        """
        save sch py if current tick is better than global best_tick
        :param current_tick:
        :param err_code:
        :return:
        """
        global_best_tick = self.get_global_best()
        logger.debug("om runner info: current_tick: %s, global_best_tick: %s.", current_tick, global_best_tick)

        if current_tick <= global_best_tick:
            store_dir = os.path.join(self.op_schedule_info.store_dir, err_code)
            py_files = []
            if os.path.exists(store_dir):
                py_files = os.listdir(store_dir)

            # rm py from the same pid
            remove_tag = "_".join(self.kernel_run_obj.kernel_name.split("_")[:-1]) + "_"
            files_to_remove = (file for file in py_files if remove_tag in file)
            for file in files_to_remove:
                os.remove(os.path.join(store_dir, file))
                logger.debug("om runner info: remove sch path: %s.", os.path.join(store_dir, file))

            store_path = store_tmp_proc(self.op_schedule_info,
                                        self.schedule_code,
                                        err_code,
                                        self.kernel_run_obj.kernel_name,
                                        tick=current_tick if current_tick > 0 else None)
            logger.debug("om runner info: best sch path updated: %s.", store_path)

    def _gen_bank_key(self):
        """
        gen_bank_key
        :return:
        """
        output_tensors, _ = get_outputs(self.compute_code)
        if not output_tensors:
            logger.warn("can not get outputs:%s", output_tensors)
            return ""
        bank_key = get_rl_bank_key(output_tensors)
        if not bank_key:
            logger.warn("can not get bank key:%s", bank_key)
            return ""

        return bank_key
