#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
norm pattern parser
"""

from typing import Dict
from typing import List
from typing import Union

from tbe.tvm import Tensor
from tbe.dsl.unify_schedule import util

from auto_search.compute_analysis.compute_pattern import ComputeType
from auto_search.compute_analysis.compute_pattern import ComputePattern
from auto_search.compute_analysis.pattern_manager import PatternParser


class NormPatternParser(PatternParser):
    """
    NormPatternParser
    """
    def __init__(self, outs, compute_type_size_map, compute_type_tensor_map):
        # type: (Union[Tensor, List[Tensor]], Dict[ComputeType, int], Dict[ComputeType, List[Tensor]]) -> None
        super().__init__(outs, compute_type_size_map, compute_type_tensor_map)

    def match(self):
        """
        check whether compute graph matches the current pattern
        """

        # norm
        # 1. support multi outs but out shape is before reduce shape or after reduce shape
        # 2. exist before reduce output
        # 3. exist reduce and broadcast at the same time
        # 4. the axis of all reduce is same
        # 5. before reduce shape is equal to after broadcast shape

        def __judge_tvm_shape_equal(_shape_a, _shape_b):
            _length_a = len(_shape_a)
            _length_b = len(_shape_b)
            if _length_a != _length_b:
                return False
            for _idx in range(_length_a):
                if not util.expr_equal(_shape_a[_idx], _shape_b[_idx]):
                    return False

            return True

        def __judge_legal_output_shape(output_shape):
            if __judge_tvm_shape_equal(before_reduce_shape, output_shape) or \
                    __judge_tvm_shape_equal(after_reduce_shape, output_shape):
                return True

            return False

        placeholder_size = self.compute_type_size_map.get(ComputeType.PLACEHOLDER, 0)
        elewise_size = self.compute_type_size_map.get(ComputeType.ELEWISE, 0)
        broadcast_size = self.compute_type_size_map.get(ComputeType.BROADCAST, 0)
        cast_size = self.compute_type_size_map.get(ComputeType.CAST, 0)
        reduce_size = self.compute_type_size_map.get(ComputeType.REDUCE, 0)
        set_value_size = self.compute_type_size_map.get(ComputeType.SET_VALUE, 0)
        total = self.compute_type_size_map.get(ComputeType.ANY, 0)

        illegal_type_size = (reduce_size == 0 or broadcast_size == 0) or \
                            (placeholder_size + elewise_size + reduce_size + cast_size +
                             broadcast_size + set_value_size != total)
        if illegal_type_size:
            return False

        reduce_tensor_list = self.compute_type_tensor_map[ComputeType.REDUCE]
        broadcast_tensor_list = self.compute_type_tensor_map[ComputeType.BROADCAST]

        before_reduce_shape = reduce_tensor_list[0].op.input_tensors[0].shape
        after_reduce_shape = reduce_tensor_list[0].shape
        after_broadcast_shape = broadcast_tensor_list[0].shape

        count_before_reduce = 0
        local_outs = self.outs if isinstance(self.outs, (list, tuple)) else [self.outs]
        for single_out in local_outs:
            if not __judge_legal_output_shape(single_out.shape):
                return False
            if __judge_tvm_shape_equal(before_reduce_shape, single_out.shape):
                count_before_reduce += 1
        # must exist before reduce output
        if count_before_reduce == 0:
            return False

        if not __judge_tvm_shape_equal(before_reduce_shape, after_broadcast_shape):
            return False

        if reduce_size > 1:
            for i in range(1, reduce_size):
                illegal_condition = \
                    not (__judge_tvm_shape_equal(before_reduce_shape,
                                                 reduce_tensor_list[i].op.input_tensors[0].shape) and
                         __judge_tvm_shape_equal(after_reduce_shape, reduce_tensor_list[i].shape))
                if illegal_condition:
                    return False

        return True

    def get_pattern(self):
        """
        return the current pattern
        """
        return ComputePattern.NORM
