#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
rl schedule search, tss
"""
import json
import os

from auto_search.utils import logger
from auto_search.config.cce_intrin_map import OP_INTRIN_KEY_TAG
from tbe import tvm
from tbe.common.rl_bank.search_bank import check_bank_hit
from tbe.common.rl_bank.search_bank import get_rl_bank_key


TUNE_TIME_PER_TASK = 300

DEPEND_LEN = 50  # num of depend
DEPEND_BITS = 8  # bits of one depend

MAX_ORIGIN_STAGE_CNT = DEPEND_LEN * DEPEND_BITS // 2

TAG_BLACK_LIST = [
    "segment_sum", "load2d", "im2col", "conv_mad", "matmul_v2", "matmul_gemv",
    "matmul_v2_gemv", "pooling2d_avg", "pooling2d_max", "pooling2d_gap",
    "pooling2d_gmp", "convolution_C", "convolution_C_UB", "convolution_c_col",
    "convolution_im2col_row_major", "convolution_im2col_fractal",
    "conv_vector_bias_add"
]

SUPPORT_TAG_LIST = [
    op_intrin.ori_tag for op_intrin in OP_INTRIN_KEY_TAG.values()
    if op_intrin.ori_tag not in TAG_BLACK_LIST
]


def _parse_tune_res(best_path):
    """
    :param best_path:
    :return: best_tick, best_path, base_tick
    """
    if not best_path:
        return None
    best_tick, base_tick = os.path.basename(best_path).split("_")[:2]
    return int(best_tick), best_path, int(base_tick)


def _get_curr_res(stage: object, curr_res: list) -> None:
    """
    get curr_res
    """
    for idx in range(stage.op.num_outputs):
        if stage.op.output(idx) in curr_res:
            continue
        curr_res.append(stage.op.output(idx))


def get_res_by_output_name(sch, output_name_list):
    """
    :param sch:
    :param output_name_list:
    :return:
    """
    curr_res = []
    for output_name in output_name_list:
        for stage in sch.stages:
            if stage.op.name != output_name:
                continue
            _get_curr_res(stage, curr_res)
            break
    return curr_res


def _stage_check(sch, op_type):
    """
    check stage
    :param sch:
    :param op_type:
    :return:
    """
    for stage in sch.stages:
        if stage.op.tag and stage.op.tag.split("|")[0] not in SUPPORT_TAG_LIST:
            logger.warn("auto search not support %s tag, skip!", stage.op.tag)
            return False
        if isinstance(stage.op, tvm.ExternOp):
            logger.warn("auto search not support %s extern op, skip!", op_type)
            return False

    if len(sch.stages) > MAX_ORIGIN_STAGE_CNT:
        logger.warn("current op stage_num:%d, rl_tune supported max stage_num is %d, skip!",
                    len(sch.stages), MAX_ORIGIN_STAGE_CNT)
        return False

    return True


def rl_check_sch(sch: object, op_type: str) -> bool:
    """
    check schedule
    :param sch: default schedule object
    :param op_type: op type, fused op is joined by "__"
    :return: bool
    """
    if sch is None:
        logger.warn("can not get default schedule of %s, skip it.", op_type)
        return False

    if not _stage_check(sch, op_type):
        logger.warn("%s stage check meet problem, skip it.", op_type)
        return False
    return True


def check_repeat_tune(res_tensor: list, kernel_name: str, op_mode: str = "static") -> (bool, bool):
    """
    check_repeat_tune
    :param res_tensor:
    :param kernel_name:
    :param op_mode:
    :return:
    """
    rl_bank_key = get_rl_bank_key(res_tensor)
    if not rl_bank_key:
        logger.warn("op %s can not get rl bank key, will not tune.", kernel_name)
        return False, rl_bank_key, False

    hit_bank = check_bank_hit(res_tensor, kernel_name, op_mode)
    if not hit_bank:
        logger.warn("op %s not hit bank", kernel_name)
        return True, rl_bank_key, hit_bank

    if os.getenv("REPEAT_TUNE", "False").lower() == "true":
        logger.debug("enable REPEAT_TUNE!")
        return True, rl_bank_key, hit_bank
    # Not set REPEAT_TUNE，but hit bank，then do not tune again
    logger.info("op %s already in bank, set REPEAT_TUNE=True to re-tune!", kernel_name)
    return False, rl_bank_key, hit_bank


def get_ori_op_name(op_model_name, kernel_name, op_json):
    """

    :param op_model_name:
    :param kernel_name:
    :param op_json:
    :return:
    """
    if op_model_name:
        default_ori_name = op_model_name
    elif kernel_name:
        default_ori_name = kernel_name

    if not op_json:
        return '[%s]' % default_ori_name

    dict_op_json = json.loads(op_json)
    op_list = dict_op_json.get('op_list', [])
    ori_name_list = []
    for op_info in op_list:
        if op_info.get('type') == 'Data':
            continue

        cur_ori_name = op_info.get('ori_name', [])
        if cur_ori_name:
            ori_name_list.append(str(cur_ori_name))

    if ori_name_list:
        return "[%s]" % ','.join(ori_name_list)

    return default_ori_name


def load_json_str(op_json_str: str) -> dict:
    """
    load json from str to dict
    :param op_json_str: str of json
    :return: dict of json
    """
    try:
        op_desc = json.loads(op_json_str)
    except (ValueError, AttributeError) as exception:
        logger.error("Cannot load op_json_str, %s", str(exception))
        return {}
    finally:
        pass
    return op_desc


def report_rl_tune_progress(progress_q: object, cbkey: str, time_out: int, state: str) -> None:
    """
    report rl tune state to progress
    :param progress_q: communicate que for multi thread
    :param cbkey: operator cbkey string
    :param state: tuning state: start, skip, end
    """
    if progress_q:
        tmp_tune_msg = {"AS": (cbkey, time_out, state)}
        progress_q.put(tmp_tune_msg)
        logger.debug("report tune progress: cbkey:%s, time_out:%s, state:%s", cbkey, time_out, state)
