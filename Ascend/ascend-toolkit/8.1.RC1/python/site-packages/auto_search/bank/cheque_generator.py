#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
cheque generator
"""

from auto_search.utils import logger
from auto_search.bank.cheque import get_primitive_id
from auto_search.bank.cheque import get_scope_id
from auto_search.bank.cheque import get_insn_id
from tbe.common.rl_bank.bank_cfg import BUILD_CONFIG_DICT
from tbe.common.rl_bank.withdraw import REDUCE_OPT_MODE_MAP


def get_stage_index(stages_info, stage_name):
    """

    :param stages_info:
    :param stage_name:
    :return:
    """
    for i, stage_info in enumerate(stages_info):
        if stage_info['name'] == stage_name:
            return i
    return 0


def get_axis_index(axis_infos, axis_name):
    """

    :param axis_infos:
    :param axis_name:
    :return:
    """
    axis_index = 0
    for i, axis_info in enumerate(axis_infos):
        if axis_info.name == axis_name:
            axis_index = i
            break
    return axis_index


def get_at_cheque(stage_idx, target_stage_idx, target_axis_idx):
    """
    :param stage_idx:
    :param target_stage_idx:
    :param target_axis_idx:
    :return:
    """
    cheque = [
        stage_idx,
        get_primitive_id("compute_at"), target_stage_idx, target_axis_idx
    ]
    return cheque


def get_bind_cheque(stage_index):
    """
    :param stage_index:
    :return:
    """
    cheque = [stage_index, get_primitive_id("bind")]
    return cheque


def get_cache_read_cheque(stage_index, buf, consumer_indices):
    """
    :param stage_index:
    :param buf:
    :param consumer_indices:
    :return:
    """
    cheque = [
        stage_index,
        get_primitive_id("cache_read"),
        get_scope_id(buf), consumer_indices
    ]
    return cheque


def get_cache_write_cheque(stage_index, buf):
    """
    :param stage_index:
    :param buf:
    :return:
    """
    cheque = [stage_index, get_primitive_id("cache_write"), get_scope_id(buf)]
    return cheque


def get_cache_write_cheque_spec(stage_index, buf, num_outputs):
    """
    :param stage_index:
    :param buf:
    :param num_outputs:
    :return:
    """
    cheque = [[stage_index, num_outputs],
              get_primitive_id("cache_write"),
              get_scope_id(buf)]

    return cheque


def get_emit_insn_cheque(stage_index, insn_name, axis_info, extra_info=None):
    """
    :param stage_index:
    :param insn_name:
    :param axis_info:
    :param extra_info:
    :return:
    """
    def dma_copy_attr():
        dma_cheque = [extra_info["no_overlap"]]
        cheque.append(dma_cheque)

    def vector_transpose_attr():
        trs_cheque = [extra_info["src_in_dst_order"]]
        cheque.append(trs_cheque)

    def vector_mul_vector_add_attr():
        vector_cheque = [int(extra_info["use_ba_pattern_brc"])]
        cheque.append(vector_cheque)

    def vector_broadcast_attr():
        if "enable_vnchwconv" in extra_info and extra_info["enable_vnchwconv"]:
            cheque.append([1])
        elif "enable_align_eight_dup" in extra_info and extra_info["enable_align_eight_dup"]:
            cheque.append([2])
        elif "last_src_valid_element" in extra_info:
            cheque.append(extra_info["last_src_valid_element"])

    def unknown_broadcast_attr():
        unknown_broadcast_cheque = [int(extra_info["dynamic_fuse"]), int(extra_info["dynamic_split"])]
        cheque.append(unknown_broadcast_cheque)

    axis_name = axis_info[0]
    axis_index = axis_info[1]
    if "[" in axis_name and "]" in axis_name:
        axis_index = int(axis_name.split("axis[")[1].split("]")[0])
        cheque = [
            stage_index,
            get_primitive_id("emit_insn"), [axis_index, -1],
            get_insn_id(insn_name)
        ]
    else:
        cheque = [
            stage_index,
            get_primitive_id("emit_insn"), [-1, axis_index],
            get_insn_id(insn_name)
        ]

    if extra_info:
        insn_attr_map = {
            "dma_copy": dma_copy_attr,
            "vector_transpose": vector_transpose_attr,
            "vector_broadcast": vector_broadcast_attr,
            "unknown_broadcast": unknown_broadcast_attr,
            'vector_mul': vector_mul_vector_add_attr,
            'vector_add': vector_mul_vector_add_attr
        }
        if insn_name in insn_attr_map.keys():
            insn_attr_map.get(insn_name)()

        if insn_name.find('vector_reduce') != -1:
            extra_info_cheque_list = [extra_info.get("extra_space", -1), int(extra_info.get("trans", -1))]
            reduce_opt_mode = extra_info.get("reduce_opt_mode", -1)
            extra_info_cheque_list.append(REDUCE_OPT_MODE_MAP.get(reduce_opt_mode, -1))
            extra_info_cheque_list.append(int(extra_info.get("storage_bound", -1)))
            extra_info_cheque_list.append(int(extra_info.get("reuse_dst_tensor", -1)))
            extra_info_cheque_list.append(int(extra_info.get("enough_buffer", -1)))
            extra_info_cheque_list.append(int(extra_info.get("window", -1)))
            extra_info_cheque_list.append(int(extra_info.get("reuse_src_tensor", -1)))
            extra_info_cheque_list.append(extra_info.get("nlast_reduce_dichotomy", -1))
            cheque.append(extra_info_cheque_list)

    return cheque


def get_pragma_cheque(stage_index, pragma_name, axis_info, pragma_offset):
    """
    :param stage_index:
    :param pragma_name:
    :param axis_info:
    :param pragma_offset:
    :return:
    """
    axis_name = axis_info[0]
    axis_index = axis_info[1]
    if "[" in axis_name and "]" in axis_name:
        axis_index = int(axis_name.split("axis[")[1].split("]")[0])
        cheque = [
            stage_index,
            get_primitive_id("pragma"), [axis_index, -1],
            get_insn_id(pragma_name), pragma_offset
        ]
    else:
        cheque = [
            stage_index,
            get_primitive_id("pragma"), [-1, axis_index],
            get_insn_id(pragma_name), pragma_offset
        ]
    return cheque


def get_reorder_cheque(stage_index, order):
    """
    :param stage_index:
    :param order:
    :return:
    """
    cheque = [stage_index, get_primitive_id("reorder"), list(order)]
    return cheque


def get_split_cheque(stage_index,
                     axis_index,
                     value,
                     primitive="split"):
    """
    :param stage_index:
    :param axis_index:
    :param value:
    :param primitive:
    :return:
    """
    if not isinstance(value, int):
        value = value.tolist()
    if primitive == "split":
        cheque = [stage_index, get_primitive_id("split"), axis_index, value]
    elif primitive == "nparts":
        cheque = [
            stage_index,
            get_primitive_id("split_nparts"), axis_index, value
        ]
    else:
        cheque = []
        logger.error("unknown primitive, only support split and split_nparts!")

    return cheque


def get_axis_cheque(stage, stage_index):
    """
    :param stage:
    :param stage_index:
    :return:
    """
    axis_cheque_list = []
    cheque = [stage_index, get_primitive_id("get_axis"), len(stage.op.axis)]
    axis_cheque_list.append(cheque)
    if stage.op.reduce_axis:
        cheque = [
            stage_index,
            get_primitive_id("get_reduce_axis"),
            len(stage.op.reduce_axis)
        ]
        axis_cheque_list.append(cheque)
    return axis_cheque_list


def get_fuse_cheque(stage_index, fuse_indices):
    """
    :param stage_index:
    :param fuse_indices:
    :return:
    """
    cheque = [stage_index, get_primitive_id("fuse"), list(fuse_indices)]
    return cheque


def get_rfactor_cheque(stage_index, axis_index, factor_axis, mode=1):
    """
    :param stage_index:
    :param axis_index:
    :param factor_axis:
    :return:
    """
    cheque = [
        stage_index,
        get_primitive_id("rfactor"), axis_index, factor_axis, mode
    ]
    return cheque


def get_set_scope_cheque(stage_index, scope):
    """
    :param stage_index:
    :param scope:
    :return:
    """
    cheque = [stage_index, get_primitive_id("set_scope"), get_scope_id(scope)]
    return cheque


def get_inline_cheque(stage_index):
    """
    :param stage_index:
    :return:
    """
    cheque = [stage_index, get_primitive_id("compute_inline")]
    return cheque


def get_ccespec_cheque(cheque_list,
                       stages_info,
                       workspace_list_str,
                       orign_out_tensor_str,
                       real_out_tensor_str):
    """
    :param cheque_list:
    :param stages_info:
    :param workspace_list_str:
    :param orign_out_tensor_str:
    :param real_out_tensor_str:
    :return:
    """
    cce_special_cheque = []
    cce_special_cheque.extend([-1, get_primitive_id("cce_special")])
    for tensor_name_list_str in [
            workspace_list_str, orign_out_tensor_str, real_out_tensor_str
    ]:
        tensor_name_list = tensor_name_list_str.lstrip('[') \
            .rstrip(']').replace(' ', '')
        if not tensor_name_list:
            tensor_name_list = []
        else:
            tensor_name_list = tensor_name_list.split(',')
        tensor_idx_list = []

        spec_scene = False
        for cheque in cheque_list:
            if cheque[1] == 1 and isinstance(cheque[0], list):
                spec_scene = True
                break
        if spec_scene:
            tensor_nums = 0
            other_tensor_list = []
            stage_name = ''
            for idx, tensor_name in enumerate(tensor_name_list):
                if '_v%s' % idx in tensor_name:
                    tensor_nums += 1
                    stage_name = "".join(tensor_name.split('_v%s' % idx)[:2])
                else:
                    other_tensor_list.append(tensor_name)
            if tensor_nums > 0:
                stage_index = get_stage_index(stages_info, stage_name)
                tensor_idx_list.append([stage_index, tensor_nums])
            tensor_name_list = other_tensor_list

        for tensor_name in tensor_name_list:
            stage_index = get_stage_index(stages_info, tensor_name)
            tensor_idx_list.append(stage_index)
        cce_special_cheque.append(tensor_idx_list)
    return cce_special_cheque


def get_storage_align_cheque(stage_index, axis_index, vector_block_num):
    """
    :param stage_index:
    :param axis_index:
    :param vector_block_num:
    :return:
    """
    cheque = [
        stage_index,
        get_primitive_id("storage_align"), axis_index, vector_block_num
    ]
    return cheque


def get_build_cfg_cheque(build_cfg_name, build_cfg_value):
    build_cfg_chque = []
    build_cfg_chque.extend([-1, get_primitive_id("build_config")])
    attr_index = [k for k, v in BUILD_CONFIG_DICT.items() if v == build_cfg_name][0]
    if build_cfg_value:
        attr_value = 1
    else:
        attr_value = 0
    build_cfg_chque.append(attr_index)
    build_cfg_chque.append(attr_value)
    return build_cfg_chque


def get_compute_align_cheque(stage_index, axis_index, vector_block_num, axis_type):
    """
    :param stage_index:
    :param axis_index:
    :param vector_block_num:
    :param axis_type: 0 is normal axis, 1 is reduce axis
    :return:
    """
    cheque = [
        stage_index,
        get_primitive_id("compute_align"), axis_index, vector_block_num, axis_type
    ]
    return cheque


def get_storage_align_cheque_enhance(stage_index, axis_info, vector_block_num):
    """
    :param stage_index:
    :param axis_info:
    :param vector_block_num:
    :return:
    """
    axis_name = axis_info[0]
    axis_index = axis_info[1]

    if "[" in axis_name and "]" in axis_name:
        axis_index = int(axis_name.split("axis[")[1].split("]")[0])
        cheque = [stage_index, get_primitive_id("storage_align"), [axis_index, -1], vector_block_num]
    else:
        cheque = [stage_index, get_primitive_id("storage_align"), [-1, axis_index], vector_block_num]

    return cheque


def get_preload_cheque(stage_index):
    """
    :param stage_index:
    :return:
    """
    cheque = [stage_index, get_primitive_id("preload")]
    return cheque


def get_double_buffer_cheque(stage_index):
    """
    :param stage_index:
    :return:
    """
    cheque = [stage_index, get_primitive_id("double_buffer")]
    return cheque


def get_reuseby_cheque(stage_index,
                       dst_stage_index=-1,
                       reuse_data=False):
    """
    :param stage_index:
    :param dst_stage_index:
    :param reuse_data:
    :return:
    """
    cheque = [
        stage_index,
        get_primitive_id("reused_by"), dst_stage_index,
        int(reuse_data)
    ]
    return cheque


def get_allocate_at_cheque(stage_index, last_stage_index, reuse_axis_idx):
    """
    :param stage_index:
    :param last_stage_index:
    :param reuse_axis_idx:
    :return:
    """
    cheque = [
        stage_index,
        get_primitive_id("allocate_at"), last_stage_index, reuse_axis_idx,
        [reuse_axis_idx]
    ]
    return cheque


def get_mem_uniq_cheque(stage_index):
    """
    :param stage_index:
    :return:
    """
    cheque = [stage_index, get_primitive_id("mem_unique")]
    return cheque


def get_set_buffer_size_cheque(stage_index, buffer_size):
    """
    :param stage_index:
    :param buffer_size:
    :return:
    """
    cheque = [
        stage_index,
        get_primitive_id("set_buffer_size"), buffer_size
    ]
    return cheque


def get_set_constraint_cheque(var_names, compare_symbol, compare_num):
    """
    :param var_names:
    :param compare_symbol:
    :param compare_num:
    :return:
    """
    cheque = [
        var_names, get_primitive_id("set_constraint"), compare_symbol, compare_num
    ]
    return cheque


def get_set_store_predicate_cheque(stage_index, cheque_params=None):
    """
    :param stage_index:
    :param cheque_params:
    :return:
    """
    if not cheque_params:
        set_store_predicate_cheque = [
            stage_index,
            get_primitive_id("set_store_predicate")
        ]
    else:
        target_stage_index = cheque_params.target_stage_index
        axis_index = cheque_params.axis_index
        compare_num = cheque_params.cond_limit
        ub_split_axis = cheque_params.ub_split_axis
        remove_pad = cheque_params.remove_pad
        broadcast_predicate_list = cheque_params.broadcast_predicate_list
        set_store_predicate_cheque = [
            stage_index,
            get_primitive_id("set_store_predicate"), target_stage_index, axis_index, compare_num, ub_split_axis,
            remove_pad,
            broadcast_predicate_list
        ]
    return set_store_predicate_cheque


def get_bind_buffer_cheque(stage_index, axis_num, stride, offset):
    """
    :param stage_index:
    :param axis_num:
    :param stride:
    :param offset:
    :return:
    """
    bind_buffer_cheque = [stage_index,
                          get_primitive_id("bind_buffer"),
                          axis_num,
                          stride,
                          offset]
    return bind_buffer_cheque


def get_block_sync_cheque(
        stage_index,
        block_sync_type,
        axis_index,
        sync_stage_index,
        bottom=True):
    """
    :param stage_index:
    :param block_sync_type:
    :param axis_index:
    :param sync_stage_index:
    :param bottom:
    :return:
    """
    cheque = [
        stage_index,
        get_primitive_id(block_sync_type), axis_index,
        sync_stage_index,
        int(bottom)
    ]
    return cheque


def get_buffer_align_cheque(stage_index, align_list):
    """
    :param stage_index:
    :param align_list:
    :return:
    """
    buffer_align_cheque = [
        stage_index, get_primitive_id("buffer_align"), align_list
    ]
    return buffer_align_cheque


def get_cache_clone_cheque(stage_index, buf, consumer_indices):
    """
    :param stage_index:
    :param buf:
    :param consumer_indices:
    :return:
    """
    cheque = [
        stage_index,
        get_primitive_id("cache_clone"),
        get_scope_id(buf), consumer_indices
    ]
    return cheque
