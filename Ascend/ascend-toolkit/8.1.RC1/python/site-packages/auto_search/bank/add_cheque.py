#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
add cheque to specify bank
"""
import os
import pickle
from typing import NoReturn
from typing import Union

from auto_search.bank.cheque import gen_cheque
from tbe.common.rl_bank.withdraw import withdraw
from tbe.common.rl_bank.search_bank import satisfy_bank
from tbe.common.repository_manager.interface import cann_kb_write
from tbe.common.platform import platform_info
from auto_search.utils import logger

KNOWLEDGE_BANK_VERSION = 1


def get_output_tensors(output_tensors: list, output_names: Union[list, object], load_obj: object) -> None:
    """
    get real output tensors
    :param output_tensors:
    :param output_names: output names in a list or generator
    :param load_obj: pickle load object
    :return:
    """
    for output_name in output_names:
        for i in range(len(load_obj.stages)):
            stage = load_obj.stages[i]
            # support for tuple_reduce_sum
            if output_name.startswith("%s_v" % (stage.op.name)):
                out_idx = int(output_name.split('_v')[-1])
                output_tensors.append(stage.op.output(out_idx))
            elif output_name == stage.op.name:
                out_idx = 0
                output_tensors.append(stage.op.output(out_idx))


def get_outputs(code_line_list: list) -> (list, list):
    """
    get_outputs
    :param code_line_list: shcedule_code_list
    :return: output_tensors, real_schedule_code
    """
    output_tensors = []
    output_names = []
    schedule_code = False
    real_schedule_code = []
    for code_line in code_line_list:
        if not code_line.strip():
            continue
        if "#op_outputs:" in code_line:
            output_names = (output.strip() for output in code_line.split("#op_outputs:")[1].split(","))
        elif "pickle.loads(" in code_line:
            tensor_pickle_byte = code_line.split("pickle.loads(b'")[-1][:-2].encode(
                'ISO-8859-1').decode('unicode-escape').encode('ISO-8859-1')
            load_obj = pickle.loads(tensor_pickle_byte)
            get_output_tensors(output_tensors, output_names, load_obj)
        elif "create_schedule" in code_line:
            schedule_code = True
        elif "config = dict()" in code_line or "return sch" in code_line:
            schedule_code = False
        else:
            if schedule_code and not code_line.startswith("    #"):
                real_schedule_code.append(code_line.strip())
    return output_tensors, real_schedule_code


def diff_code(output_tensors: list, cheque_list: list, real_schedule_code: list) -> None:
    """
    Helper function. Returns a string containing the unified diff of two list
    :param output_tensors: output_tensors to generate expected shcedule code
    :param cheque_list: cheque_list to generate expected schedule code
    :param real_schedule_code: actual
    :return:
    """
    #  gen_sch_by_cheque
    _, draw_code_lines = withdraw(output_tensors, cheque_list)
    print("=" * 80)
    print("\n".join(draw_code_lines))
    print("=" * 80)
    import difflib
    diff = difflib.unified_diff(draw_code_lines, real_schedule_code)
    diff_output = '\n'.join(diff)
    if diff_output:
        print(diff_output)


def get_schedule_code(sch_py_path: str) -> list:
    """
    parse schedule py
    :param sch_py_path: best schedule py file path
    :return: schedule_codes_list
    """
    with open(sch_py_path, 'r') as file_handler:
        file_content = file_handler.read()
    code_lines = file_content.split("\n")
    schedule_codes_list = []
    for i, code_line in enumerate(code_lines):
        if code_line.startswith("def dsl_func_"):
            start = i
        elif code_line == "    return sch":
            end = i
            schedule_codes_list.append(code_lines[start: end + 1])
    if not schedule_codes_list:
        schedule_codes_list = [code_lines]
    logger.debug("get schedule code form %s success.", sch_py_path)
    return schedule_codes_list


def get_cheque_from_sch(sch_py_path: str, kernel_name: str) -> list:
    """
    get cheque which format is same as rl bank
    :param sch_py_path: best sch py file path
    :param kernel_name: op kernel name
    :return: cheque
    """
    stop_sign, output_tensors_list, cheque_list = get_output_and_cheque_list(sch_py_path, kernel_name)
    if stop_sign or not output_tensors_list or not cheque_list or len(output_tensors_list) != len(cheque_list):
        logger.warn("op %s can not get_output_and_cheque_list.", kernel_name)
        return []

    cheque = []
    if isinstance(output_tensors_list, list) and isinstance(output_tensors_list[0], list):
        for i, _ in enumerate(output_tensors_list):
            cheque.extend(cheque_list[i])
    else:
        cheque = cheque_list
    logger.debug("get cheque from %s, kernel_name is %s, cheque is %s.", sch_py_path, kernel_name, cheque)
    return cheque


def get_output_and_cheque_list(sch_py_path: str, kernel_name: str) -> (bool, list, list):
    """
    get output_tensors_list and cheque_list from schedule_codes_list
    :param sch_py_path: best sch py file path
    :param kernel_name: op kernel name
    :return: T/F, output_tensors_list, cheque_list
    """
    stop_sign = False
    if not sch_py_path:
        logger.warn("can not get output and cheque_list, sch_py_path is none, kernel_name is %s.", kernel_name)
        return True, [], []

    schedule_codes_list = get_schedule_code(sch_py_path)

    output_tensors_list = []
    cheque_list = []
    for schedule_codes in schedule_codes_list:
        # get output_tensors
        output_tensors, real_schedule_code = get_outputs(schedule_codes)
        if not output_tensors:
            raise RuntimeError("get output_tensors from schedule py file fail.")
        # gen cheque
        cheque = gen_cheque(schedule_codes, kernel_name=kernel_name)
        if not cheque:
            return True, output_tensors_list, cheque_list
        cheque_list.append(cheque)
        output_tensors_list.append(output_tensors)
        # show code diff if enable DIFF_CODE
        if os.getenv("DIFF_CODE", "False").lower() == "true":
            diff_code(output_tensors, cheque, real_schedule_code)

    return stop_sign, output_tensors_list, cheque_list


def add_cheque_by_kb_write(rl_bank_key: str, cheque: list, cost_time: int, config: dict = None) -> NoReturn:
    """
    add cheque by repository manager cann_kb_write interface
    :param rl_bank_key:
    :param cost_time:
    :param config:
    :return:
    """
    kb_name_op_mode_suffix = config.get("op_mode", "static")
    write_config = {"op_type": f"vector_dsl_{kb_name_op_mode_suffix}",
                    "core_type": platform_info.get_soc_spec(platform_info.AICORE_TYPE),
                    "cost_time": cost_time}
    knowledge_info = {"cheque": cheque, "version": KNOWLEDGE_BANK_VERSION}
    if config.get("op_desc"):
        knowledge_info["op_desc"] = config.get("op_desc")
    # write in user bank
    cann_kb_write(rl_bank_key, knowledge_info, write_config, flush=True)


def add_cheque_to_bank(best_cheque_info: dict, op_info_str: str = "", op_mode: str = "static") -> (bool, str):
    """
    add_cheque_to_bank
    :param best_cheque_info: a dict, including "base_tick" "best_tick" "bank_key" "cheque"
    :param op_info_str: kernel_name@op_type@shape
    :param op_mode: op_mode
    :return: T/F
    """
    logger.debug("start add cheque to bank, op_info: %s, best_cheque_info: %s.",
                 op_info_str, best_cheque_info)

    best_tick = best_cheque_info.get("best_tick")
    base_tick = best_cheque_info.get("base_tick")
    if not satisfy_bank(base_tick, best_tick, 'in'):
        logger.warn(
            "add cheque to bank finished, not satisfy update bank rules, base tick: %s, best tick: %s, op info: %s.",
            base_tick, best_tick, op_info_str)
        return False, "not satisfy update bank rules."

    bank_key = best_cheque_info.get("bank_key")
    if not bank_key:
        logger.warn("can not get rl_bank_key.")
        return False, "get rl_bank_key failed."

    cheque = best_cheque_info.get("cheque")

    config = {"op_mode": op_mode, "op_desc": best_cheque_info.get('op_desc')}
    add_cheque_by_kb_write(bank_key, cheque, best_tick, config)

    logger.debug("add cheque to bank finished, base tick: %s, best tick: %s, op info: %s.",
                 base_tick, best_tick, op_info_str)
    return True, "add cheque to bank success."


def try_add_cheque(best_cheque_info: dict, op_info_str: str = "", op_mode: str = "static") -> (bool, str):
    """
    try_add_cheque
    :param best_cheque_info: a dict, including "base_tick" "best_tick" "bank_key" "cheque"
    :param op_info_str: kernel_name@op_type@shape
    :param op_mode: op_mode
    :return:
    """
    if not best_cheque_info:
        logger.warn("can not add cheque, best_cheque_info is none, op_info: %s, op_mode: %s", op_info_str, op_mode)
        return False, "best_cheque_info is none."

    try:
        ret, info = add_cheque_to_bank(best_cheque_info, op_info_str, op_mode)
        return ret, info
    except Exception as excp:
        logger.error("try add cheque failed, an exception had occurred, exception: %s, op_info: %s",
                     str(excp), op_info_str)
        return False, f"add cheque fail: {str(excp)}"
    finally:
        pass
