#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
auto search main entry
"""
import datetime
import os
import time

from tbe.common.platform.platform_info import set_current_compile_soc_info
from tbe.common.rl_bank import bank_manager

from auto_search.utils import logger
from auto_search.utils import tune_util
from auto_search.utils import util
from auto_search.config import soc_cfg
from auto_search.config import global_manager
from auto_search.estimator import om_runner
from auto_search.estimator.process_tune_result import PostRunAsync
from auto_search.tune import tune


MEANINGLESS_TIME = 1
COMPILE_TIMEOUT = 30


def auto_search(op_json_str_list: list, option_list: list):
    """
    auto_search
    :param op_json_str_list: description list of op
    :param option_list: tune config info list
    :return: T/F
    """
    if not op_json_str_list:
        logger.warn("no op to tune!")
        return

    main_pid = os.getpid()
    logger.event("enter auto search, main_pid: %d, op count: %d.", main_pid, len(op_json_str_list))

    master_pid, cbkey, interactive_mgr = _get_global_info(option_list)

    timer_queue = interactive_mgr.get("timer_q")
    tune_progress_queue = interactive_mgr.get("tune_progress_q")
    om_runner.CB_TASK_QUEUE = interactive_mgr.get("tune_task_d")
    om_runner.CB_RES_DICT = interactive_mgr.get("tune_result_d")
    om_runner.CB_RELEASE_QUEUE = interactive_mgr.get("release_tune_q")

    timer_queue.put(("start", main_pid, "Auto search main process"))

    global_multiprocess_mgr = global_manager.MultiprocessManager()
    global_multiprocess_mgr.init_shared_dict()

    config = {"ppid": master_pid}
    update_bank_async_process = PostRunAsync(interactive_mgr, "static", global_multiprocess_mgr, main_pid, config)
    update_bank_async_process.start()

    for op_json_str, option in zip(op_json_str_list, option_list):
        tune_option = _init_tune_option(option)
        timeout = tune_option.get("timeout")
        tune_option["profiling_name"] = option.get("profiling_name", "")

        timer_queue.put(("start", main_pid, "get_op_res_and_config_option"))
        res, op_config = _get_op_res_and_config_option(op_json_str, option, tune_option, interactive_mgr)
        if not res or not op_config:
            logger.debug("can not get res or op configure.")
            continue
        timer_queue.put(("stop", main_pid, "get_op_res_and_config_option"))

        cb_struct_key = op_config.get("cb_struct_key")
        timer_queue.put(("start", main_pid, "tune_op_%s" % cb_struct_key))
        _set_soc_version_for_each_op(tune_option, op_config)
        global_multiprocess_mgr.clear_shared_dict()
        best_path = ""
        try:
            best_path = tune(res, tune_option, op_config, update_bank_async_process, tune_progress_queue)
        except Exception as exception:
            logger.error("exception occur: auto search tune failed. error msg: %s", repr(exception))
        finally:
            if not best_path:
                tune_util.report_rl_tune_progress(tune_progress_queue, cb_struct_key, timeout, "skip")
            else:
                tune_util.report_rl_tune_progress(tune_progress_queue, cb_struct_key, timeout, "end")
            timer_queue.put(("stop", main_pid, "tune_op_%s" % cb_struct_key))

    tune_util.report_rl_tune_progress(tune_progress_queue, cbkey, MEANINGLESS_TIME, "all_finish")
    timer_queue.put(("stop", main_pid, "Auto search main process"))
    update_bank_async_process.stop()
    global_multiprocess_mgr.shutdown()


def _get_global_info(option_list):
    """
    each option in option_list has same global_mgr, so it needs only to get global_mgr from first option.
    """
    option = option_list[0]
    cb_key = option.get("cb_struct_key")
    interactive_mgr = {
        "tune_progress_q": option.get("global_mgr").get("tune_progress_q"),
        "timer_q": option.get("global_mgr").get("timer_q"),
        "cb_key_task_clean_q": option.get("global_mgr").get("cb_key_task_clean_q"),
        "cb_key_clean_res_d": option.get("global_mgr").get("cb_key_clean_res_d"),
        "tune_report_info_q": option.get("global_mgr").get("tune_report_info_q"),
        "datacmp_task_q": option.get("global_mgr").get("datacmp_task_q"),
        "datacmp_res_d": option.get("global_mgr").get("datacmp_res_d"),
        "tune_task_d": option.get("global_mgr").get("tune_task_d"),
        "tune_result_d": option.get("global_mgr").get("tune_result_d"),
        "release_tune_q": option.get("global_mgr").get("release_tune_q")
    }
    master_pid = option.get("master_pid")

    return master_pid, cb_key, interactive_mgr


def get_op_res(kernel_name: str) -> tuple:
    """
    get schedule_obj and cce special list, then write to file
    :param kernel_name: kernel name of op
    :return: (sch_list, cce_special_list)
    """
    sch_list = bank_manager.get_op_res(kernel_name)
    if not sch_list:
        logger.warn("get res is None by kernel name %s.", kernel_name)
        return [], []

    cce_special_list = []
    for sch in sch_list:
        cce_special_list.append(sch.cce_special)

    return sch_list, cce_special_list


def _set_soc_version_for_each_op(tune_option, op_config):
    """
    each op core type and core num may be not same in a sub graph,
    do need set them for each op
    :param tune_option:
    :param op_config:
    :return:
    """
    soc_version = tune_option.get("soc_version")
    core_type = op_config.get("core_type", "AiCore")
    core_num = op_config.get("core_num")
    l1_fusion = op_config.get("l1_fusion")
    set_current_compile_soc_info(soc_version, core_type, core_num, l1_fusion)
    logger.info("op_name:%s, soc_version:%s, core_type:%s, core_num:%s, l1_fusion:%s", op_config["ori_op_name"],
                soc_version, core_type, core_num, l1_fusion)


def _base_build_compile(kernel_name: str,
                        op_json_str: str,
                        option: dict) -> dict:
    """
    base compile
    :param kernel_name: kernel name of an op
    :param op_json_str: description of an op
    :param option: tune config info corresponding to the op
    :return: compile_res
    """
    func_in_compile = {
        'prerun': (bank_manager.set_current_op_name, [kernel_name]),
        'postrun': (get_op_res, [kernel_name])
        }

    compile_res = {}
    time_stamp = datetime.datetime.utcnow().strftime('%Y%m%d_%H%M%S_%f')
    compile_key = "rl_compile_%s_%s_%s" % (kernel_name, os.getpid(), time_stamp)
    compile_dict = {compile_key: {
        "json_str": op_json_str,
        "pre_and_post": func_in_compile
    }}

    compile_task_queue = option.get("global_mgr").get("compile_task_d")
    compile_res_dict = option.get("global_mgr").get("compile_result_d")
    compile_release_q = option.get("global_mgr").get("release_compile_q")
    compile_task_queue.put(compile_dict)

    compile_begin = time.time()
    while time.time() - compile_begin < COMPILE_TIMEOUT:
        if compile_key in compile_res_dict:
            compile_res = compile_res_dict.get(compile_key)
            compile_release_q.put(compile_key)
            break
    return compile_res


def _base_build(kernel_name: str,
                op_json_str: str,
                option: dict) -> (bool, list, list):
    """
    build base
    :param kernel_name: kernel name of op
    :param op_json_str: description of an op
    :param option: tune config info corresponding to the op
    :return: T/F, sch_list, cce_special_list
    """
    try:
        compile_res = _base_build_compile(kernel_name, op_json_str, option)
    except Exception as exception:
        logger.warn("%s can not base build.", repr(exception))
        return False, None, None
    finally:
        pass

    if not compile_res.get("post_res", None):
        logger.warn("%s can not base build, post_res is empty.", kernel_name)
        return False, None, None

    sch_list, cce_special_list = compile_res.get("post_res")
    if not sch_list or not cce_special_list or len(sch_list) != len(cce_special_list):
        logger.warn("%s can not base build, sch_list:%s, cce_special_list:%s.",
                    kernel_name, sch_list, cce_special_list)
        return False, None, None

    logger.debug("%s base build succ.", kernel_name)
    return True, sch_list, cce_special_list


def _get_res_by_json(op_json_str: str, op_desc: dict, option: dict) -> (list, dict):
    """
    compile op by op_json to get output tensors
    :param op_json_str: description of an op
    :param op_desc: tune config info corresponding to the op
    :param option:
    :return: res_list, op_config_option
    """
    op_name_list = []
    op_type_list = []
    for op_info in op_desc.get("op_list", []):
        if op_info.get("type") != "Data" and "func_name" in op_info:
            op_name_list.append(op_info.get("func_name"))
            op_type_list.append(op_info.get("type").lower())

    kernel_name = str(op_desc.get("fusion_op_name"))
    op_config_option = {
        "op_name": "__".join(op_name_list),
        "kernel_name": kernel_name,
        "op_type": "__".join(op_type_list)
        }

    # base build
    compile_ret, sch_list, cce_special_list = _base_build(kernel_name, op_json_str, option)
    if not compile_ret:
        logger.warn("op %s can not base build, skip!", kernel_name)
        return None, op_config_option
    if not sch_list:
        logger.warn("op %s can not get auto_schedule, skip!", kernel_name)
        return None, op_config_option

    op_config_option["base_kernel"] = os.path.join(soc_cfg.kernel_meta_dir(), kernel_name + ".o")
    res_list = []
    for idx, sch in enumerate(sch_list):
        if cce_special_list[idx].get("tensor_list", []):
            try:
                op_config_option["tensor_list"] = util.get_tensor_list(cce_special_list[idx].get("tensor_list", [])[0])
            except Exception as exception:
                logger.warn("can not get tensor_list. exception msg: %s, op info: %s", repr(exception), op_json_str)
                return None, op_config_option
            finally:
                pass
        res = tune_util.get_res_by_output_name(sch, cce_special_list[idx]["op_outputs"])
        op_config_option["is_fractal_format"] = cce_special_list[idx].get("is_fractal_format")
        res_list.append(res)
        if not tune_util.rl_check_sch(sch, kernel_name):
            logger.warn("op %s can not rl_check_sch, skip!", kernel_name)
            return None, op_config_option

    logger.info("get output tensors end, res_list: %s, op_config_option: %s.", res_list,
                op_config_option)
    return res_list, op_config_option


def _get_op_res_and_config_option(op_json_str, option, tune_option, interactive_mgr):
    """
    get op res and config_option for current tune op
    :param op_json_str: description of op
    :param option: tune config info
    :param tune_option: tune inference option
    :return: res, op_config_option
    """
    tune_progress_q = interactive_mgr.get("tune_progress_q")

    logger.debug("option: %s, op json str: %s", option, op_json_str)
    cbkey = option.get("cb_struct_key")
    op_desc = tune_util.load_json_str(op_json_str)
    if not op_desc:
        logger.warn("cannot load op_json_str: %s, skip!", op_json_str)
        tune_util.report_rl_tune_progress(tune_progress_q, cbkey, MEANINGLESS_TIME, "skip")
        return None, None

    # compile op by op_json to get output tensors
    res, op_config_option = _get_res_by_json(op_json_str, op_desc, option)
    kernel_name = op_config_option.get("kernel_name")
    if not res:
        logger.warn("auto search not support %s, skip!", kernel_name)
        tune_util.report_rl_tune_progress(tune_progress_q, cbkey, MEANINGLESS_TIME, "skip")
        return None, None

    is_tune, bank_key, hit_bank = tune_util.check_repeat_tune(res, kernel_name, tune_option.get("op_mode", "static"))
    if not is_tune:
        logger.warn("op %s has existed in rl bank, and REPEAT_TUNE is false, skip!",
                    kernel_name)
        tune_util.report_rl_tune_progress(tune_progress_q, cbkey, MEANINGLESS_TIME, "skip")
        return None, None

    logger.debug("op %s compile auto schedule and get output tensors success.", kernel_name)

    ori_op_name = tune_util.get_ori_op_name("", kernel_name, op_json_str)
    if option.get("extra_option"):
        ori_op_name = option.get("ori_op_name")
    if ori_op_name:
        op_config_option["ori_op_name"] = ori_op_name
        op_config_option["tune_result_key"] = ori_op_name
        util.write_to_file(os.path.join(tune_option.get("tune_show_dir"), "%s.flag" % kernel_name), ori_op_name)

    op_config_option["core_type"] = op_desc.get("SocInfo").get("coreType")
    op_config_option["core_num"] = op_desc.get("SocInfo").get("coreNum")
    op_config_option["l1_fusion"] = op_desc.get("SocInfo").get("l1Fusion")
    op_config_option["bank_key"] = bank_key
    op_config_option["cb_struct_key"] = cbkey
    op_config_option["hit_bank"] = hit_bank
    op_config_option["op_mode"] = 'static'
    op_config_option["op_desc"] = op_desc

    logger.info("ops compile auto schedule and get output tensors success.")
    return res[0], op_config_option


def _init_tune_option(ori_option: dict) -> dict:
    """
    _init_tune_option
    :param ori_option: original option
    :return: tune option
    """
    # create tune dir
    tmp_file_path = os.path.realpath(ori_option.get("tmp_file_path"))
    suboptimal_path = os.path.realpath(ori_option.get("suboptimal_path")) if ori_option.get("suboptimal_path") else ''
    default_task_time_stamp = "%s_%s" % (datetime.datetime.utcnow().strftime('%Y%m%d_%H%M%S_%f'), os.getpid())
    task_time_stamp = ori_option.get("pid_timestamp", default_task_time_stamp)
    curr_tune_workspace = os.path.join(tmp_file_path, "auto_search_workspace_%s" % task_time_stamp)
    tune_show_dir = os.path.join(tmp_file_path, "tune_show_%s" % task_time_stamp)
    util.create_dir(curr_tune_workspace)
    util.create_dir(tune_show_dir)
    high_perf = ori_option.get("high_perf", False)

    tune_option = {
        "WORKSPACE": tmp_file_path,
        "auto_schedule_golden": True,
        "init_evb": False,
        "rl_mode": "rl_tune_om",
        "main_pid": os.getpid(),
        "run_by_om": True,
        "is_store_cheque": True,
        "not_store_sch": True,
        "tune_workspace": curr_tune_workspace,
        "suboptimal_path": suboptimal_path,
        "tune_show_dir": tune_show_dir,
        "timeout": util.get_timeout(high_perf),
        "job_id": ori_option.get("job_id", ""),
        "op_mode": 'static',
        "soc_version": soc_cfg.get_full_soc_version(),
        "dump_tune_op": os.getenv("DUMP_TUNE_OP") == str(True)
    }
    if ori_option.get("extra_option"):
        tune_option.update(ori_option.get("extra_option"))
    logger.debug("init tune option: %s.", tune_option)
    return tune_option
