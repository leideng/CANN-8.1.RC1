#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
schedule auto tune
"""
import sys

from tbe.common.rl_bank.search_bank import satisfy_bank
from tbe.common.rl_bank.dynamic_op_filter import dynamic_op_filter
from auto_search.utils import logger
from auto_search.utils import util
from auto_search.utils import tune_util
from auto_search.search_strategy.searcher import search
from auto_search.solution_space.op_schedule_info import get_op_schedule_info
from auto_search.solution_space.op_schedule_info import get_dir_by_option
from auto_search.config import global_manager
from auto_search.config.config import TUNE_TICK_THRESHOLD_MICROSECOND

TOP_CHEQUE = 10


def tune(res, option, op_config, update_bank_async_process=None, tune_progress_queue=None):
    logger.event("op: %s, auto search tune begin.", op_config.get("kernel_name"))
    ret, option = _pre_proc(option, op_config)
    if ret is False:
        logger.error("auto search pre process error.")
        return ""
    # 5hd is not support tune now
    if op_config.get('is_fractal_format'):
        logger.event("current op format is 5hd, now is not support tune!")
        return ""

    op_schedule_info = _get_op_schedule_info(res, option)

    if op_schedule_info.base_tick <= 0:
        logger.event("op %s base tick is 0, unable auto schedule, can not tune.", op_config.get("kernel_name"))
        return ""
    # op of less than tune threshold is not tuning
    tune_tick_threshold_microsecond = option.get("tune_tick_threshold", TUNE_TICK_THRESHOLD_MICROSECOND)
    if not dynamic_op_filter.tune_all_op and op_schedule_info.base_tick <= tune_tick_threshold_microsecond:
        logger.event("op %s auto schedule is good enough(%s), no need to tune, current tune tick threshold is %sus.",
                     op_config.get("kernel_name"), op_schedule_info.base_tick, tune_tick_threshold_microsecond)
        return ""

    if tune_progress_queue:
        timeout = option.get("timeout")
        cb_struct_key = op_config.get("cb_struct_key")
        tune_util.report_rl_tune_progress(tune_progress_queue, cb_struct_key, timeout, "start")

    search(op_schedule_info)
    best_path = _post_proc(op_schedule_info)

    if update_bank_async_process:
        top_cheque_infos = _get_top_cheque_info(op_schedule_info)
        update_bank_async_process.update_bank_list.append((op_schedule_info, option, top_cheque_infos, True))

    logger.event("op: %s, auto search tune end.", op_config.get("kernel_name"))
    return best_path


def _pre_proc(option, op_config):
    util.update_workspace(option)

    option = util.init_option(option)

    option["auto_schedule_golden"] = True
    option['op_config'] = op_config

    logger.info("pre process finished.")
    return True, option


def _post_proc(op_schedule_info):
    best_path = util.get_best_sch_path(op_schedule_info, op_schedule_info.store_dir)
    logger.info("post process finished.")
    return best_path


def _get_op_schedule_info(res, option):
    op_schedule_info = get_op_schedule_info(res, option)
    logger.info("get op %s op schedule info success.", op_schedule_info.op_name)
    get_dir_by_option(option, op_schedule_info)
    return op_schedule_info


def _get_top_cheque_info(op_schedule_info: object) -> list:
    """
    get top ten filtered cheque_infos from global_manager.BEST_CHEQUE_DICT keys
    :param op_schedule_info: op's unique info class
    :return: top_cheque_infos, list of dict, key:{best_tick, base_tick, bank_key, cheque}
    """
    if not op_schedule_info:
        return []

    if not global_manager.BEST_CHEQUE_DICT:
        logger.warn("BEST_CHEQUE_DICT is empty, no top cheque infos.")
        return []

    best_cheque_dict_values = global_manager.BEST_CHEQUE_DICT.values()

    total_saved_cheque_list = []
    for saved_cheque_list in best_cheque_dict_values:
        total_saved_cheque_list.extend(saved_cheque_list)
    logger.debug("get top cheque info begin, BEST_CHEQUE_DICT has %s cheque_infos recorded.",
                 len(total_saved_cheque_list))

    kernel_name = op_schedule_info.option.get('op_config', {}).get("kernel_name", "default")
    kernel_name = kernel_name.split("@")[0]

    # sort BEST_CHEQUE_DICT by best_tick, best_cheque_info: dict{best_tick, base_tick, bank_key, cheque}
    total_saved_cheque_list.sort(key=lambda item: item.get("best_tick", sys.maxsize))
    selected_cheque_infos = total_saved_cheque_list[:TOP_CHEQUE]
    top_cheque_infos = []
    for cheque_info in selected_cheque_infos:
        if not satisfy_bank(cheque_info["base_tick"], cheque_info["best_tick"], 'in'):
            break
        top_cheque_infos.append(cheque_info)

    logger.debug("get top cheque info end, op: %s, top_cheque_infos: %s.",
                 kernel_name, top_cheque_infos)
    return top_cheque_infos
