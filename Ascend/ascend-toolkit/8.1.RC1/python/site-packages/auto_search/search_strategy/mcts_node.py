#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
mcts node
"""
import collections
import math
import time
import sys
import numpy as np

from auto_search.utils import logger
from auto_search.estimator.tick import get_tick
from auto_search.solution_space.features import SEARCH_N

_C_PUCT_INIT = 15  # Exploration constants balancing priors vs value net output
_BP_LAMDA = 1.0  # mcts backup lamda
_DIRICHLET_NOISE_WEIGHT = 0.4  # How much to weight the priors vs dirichlet noise when mixing
_MIN_VALUE = -1.0


class DummyRoot:
    """
    a dummy node as the initial mcts node parent
    """

    def __init__(self):
        self.parent = None
        self.node_name = "0"
        self.child_n = collections.defaultdict(int)
        self.child_w = collections.defaultdict(float)
        self.illegal_actions = np.array([0, 1, 1, 1, 1, 1, 1, 1], dtype=np.int32)

    def __repr__(self):
        return f'DummyNode_{self.node_name}'

    def add_virtual_loss(self, up_to):
        pass

    def revert_virtual_loss(self, up_to):
        pass

    def backup_value(self, value, up_to):
        pass

    def move_traces(self, moves):
        pass

    def todo_traces(self, traces):
        pass


class MCTSNode:
    """
    A node of a MCTS search tree.
    """

    def __init__(self, progress, action=None, parent=None):
        self.parent = parent or DummyRoot()
        self.node_name = "0" if parent is None or action is None else parent.node_name + "-" + str(action)
        self.action = action
        self.progress = progress
        self.is_expanded = False
        self.losses_applied = 0
        self.illegal_actions = 1 - self.progress.all_legal_actions()
        self.child_n = np.zeros([SEARCH_N], dtype=np.int32)
        self.child_w = np.zeros([SEARCH_N], dtype=np.float32)
        self.child_prior = np.zeros([SEARCH_N], dtype=np.float32)
        self.children = {}
        self.value = None
        self.tick = 0

    def __repr__(self):
        moves = []
        self.move_traces(moves)
        todos = []
        self.todo_traces(todos)

        return f"MCTSNode(n={self.n_value}, action_value={self.action}, todo={self.progress.todo}, " \
               f"moves={moves}, progress todo traces={'->'.join([todo.action_type for todo in todos])})"

    @property
    def n_value(self):
        return self.parent.child_n[self.action]

    @n_value.setter
    def n_value(self, value):
        self.parent.child_n[self.action] = value

    @property
    def w_value(self):
        return self.parent.child_w[self.action]

    @w_value.setter
    def w_value(self, value):
        self.parent.child_w[self.action] = value

    @property
    def child_action_score(self):
        child_action_score = self.child_q + self.child_u
        for index in range(SEARCH_N):
            if self.illegal_actions[index] == 1:
                child_action_score[index] = float("-inf")

        return child_action_score

    @property
    def child_q(self):
        return self.child_w / (1 + self.child_n)

    @property
    def child_u(self):
        return _C_PUCT_INIT * math.sqrt(max(1, self.n_value - 1)) * self.child_prior / (1 + self.child_n)

    @property
    def q_value(self):
        return self.w_value / (1 + self.n_value)

    @property
    def legal_actions_idx(self):
        return np.where(self.progress.all_legal_actions() == 1)[0]

    @staticmethod
    def readout():
        return np.random.uniform(-1.0, 1.0)

    @staticmethod
    def _value_normalization(tick, base_tick):
        if tick in [0, sys.maxsize, None] or not isinstance(tick, int):
            return _MIN_VALUE

        return math.tanh((base_tick - tick) / tick)

    def select_leaf(self):
        current = self
        while True:
            if not current.is_expanded:
                break
            if current.is_done():
                return current

            best_action = np.argmax(current.child_action_score)
            new_leaf = current.maybe_add_child(best_action)
            if new_leaf.is_done() and current.child_n[best_action] > 0:
                for action, illegal in enumerate(current.illegal_actions):
                    if illegal == 0 and current.child_n[action] == 0:
                        new_leaf = current.maybe_add_child(action)
                        break
            current = new_leaf

        return current

    def maybe_add_child(self, action_value):
        if action_value not in self.children:
            new_progress = self.progress.get_next_progress(action_value)
            self.children[action_value] = MCTSNode(new_progress, action_value, self)
        return self.children[action_value]

    def add_virtual_loss(self, up_to):
        self.losses_applied += 1
        self.w_value -= 1
        if self.parent is None or self is up_to:
            return
        self.parent.add_virtual_loss(up_to)

    def revert_virtual_loss(self, up_to):
        self.losses_applied -= 1
        self.w_value += 1
        if self.parent is None or self is up_to:
            return
        self.parent.revert_virtual_loss(up_to)

    def incorporate_results(self, value, up_to):
        if self.is_done():
            raise AssertionError(f"node is done: {self}")
        if self.is_expanded:
            return
        self.is_expanded = True

        self.child_w = np.ones([SEARCH_N], dtype=np.float32) * value
        self.backup_value(value, up_to=up_to)

    def backup_value(self, value, up_to):
        self.n_value += 1
        if self.is_done():
            self.w_value = value * (self.n_value + 1)
        else:
            self.w_value += value

        if self.is_dead():
            logger.warn("node is dead: %s", self)
            self.set_dead()

        if self.parent is None or self is up_to:
            return

        value = (1 - _BP_LAMDA) * self.q_value + _BP_LAMDA * value
        self.parent.backup_value(value, up_to)

    def is_done(self):
        if self.progress.is_search_over():
            return True
        return False

    def is_dead(self):
        return not self.is_done() and sum(self.illegal_actions) == SEARCH_N

    def set_dead(self):
        self.parent.illegal_actions[self.action] = 1

    def move_traces(self, moves):
        if self.action is not None:
            moves.insert(0, self.action)
        self.parent.move_traces(moves)

    def todo_traces(self, todos):
        if self.progress.todo is not None:
            todos.insert(0, self.progress.todo)
        self.parent.todo_traces(todos)

    def get_value(self):
        if not self.is_done():
            raise AssertionError("node[%s] is not done" % self.node_name)
        if self.value is not None:
            return self.value
        moves = []
        self.move_traces(moves)
        action_tensors = self.progress.action_tensor
        op_schedule_infos = self.progress.op_schedule_info

        tick = get_tick(action_tensors, op_schedule_infos, moves=moves)

        self.value = self._value_normalization(tick, op_schedule_infos.base_tick)
        self.tick = tick

        return self.value

    def inject_noise(self):
        epsilon = 1e-5
        legal_moves = (1 - self.illegal_actions) + epsilon
        np.random.seed(int(time.time() * (10 ** 6)) % (2 ** 32))
        noise = np.random.random([SEARCH_N]) * legal_moves
        noise = noise / noise.sum()
        self.child_prior = (self.child_prior * (1 - _DIRICHLET_NOISE_WEIGHT) + noise * _DIRICHLET_NOISE_WEIGHT)

    def children_as_pi(self, squash=False):
        probs = self.child_n
        if squash:
            probs = probs ** .98
        sum_probs = np.sum(probs)
        if sum_probs == 0:
            return probs
        probs = probs / sum_probs
        return probs
