#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologgeries Co., Ltd. 2022-2022. All rights reserved.
"""
This search strategy will traverse the whole search space by mcts alg.
"""
import random

from auto_search.utils import logger
from auto_search.search_strategy.mcts_node import MCTSNode
from auto_search.solution_space.progress import Progress
from auto_search.search_strategy.searcher import strategy_register
from auto_search.solution_space.prepare_action.first_todo.first_todo_action import FirstTodoAction

_NUM_READOUTS = 30  # MCTS readouts/roll-outs
_SOFTPICK_MOVE_CUTOFF = 1.0  # Percentage of actions that should use softpick
_PARALLEL_READOUTS = 4  # Number of searches to execute once
_ILLEGAL_ACTION = -1


class MCTSSearcher:
    """
    MCTSSearcher
    """

    def __init__(self, op_schedule_info):
        self._num_readouts = _NUM_READOUTS
        self._parallel_readouts = _PARALLEL_READOUTS
        self._temp_threshold = _SOFTPICK_MOVE_CUTOFF
        self._root = MCTSNode(Progress(op_schedule_info, 0, FirstTodoAction(op_schedule_info.op_pattern)), 0)
        self._leaves = set()

    def __repr__(self):
        return f'MCTSSearcher(leaf nums={len(self._leaves)}, leaf ticks={self._leaf_ticks()})'

    def tree_search(self):
        first_node = self._root.select_leaf()
        value = first_node.readout()
        first_node.incorporate_results(value, first_node)
        first_node.value = value
        while True:
            self._root.inject_noise()
            move = self._best_action()
            if move == _ILLEGAL_ACTION:
                break
            self._apply_action(move)
            if self._root.is_done():
                break

    def _best_action(self):
        # move forward directly if current root has only one child, otherwise do the readouts
        if len(self._root.legal_actions_idx) == 1:
            move = self._root.legal_actions_idx[0]
            logger.info("current root has only one child, move forward directly: %s", self._root)
            # ensure the next node is created and expanded
            next_node = self._root.maybe_add_child(move)
            if next_node.is_done():
                value = next_node.get_value()
                self._leaves.add(next_node)
                next_node.backup_value(value, up_to=self._root)
            else:
                value = next_node.readout()
                next_node.value = value
                next_node.incorporate_results(value, up_to=self._root)

            return move

        current_readouts = self._root.n_value
        # we want to do "X additional readouts",
        # rather than "up to X readouts".
        while self._root.n_value < current_readouts + self._num_readouts:
            if self._root.is_dead():
                logger.warn("current root node is dead: %s", self._root)
                break
            self._simulation()

        if self._root.is_dead():
            return _ILLEGAL_ACTION
        move = self._pick_action()
        return move

    def _simulation(self):
        nodes = []
        leaves = []
        failsafe = 0

        while len(nodes) < self._parallel_readouts and failsafe < self._parallel_readouts * 2:
            failsafe += 1
            node = self._root.select_leaf()
            if node.is_done():
                value = node.get_value()
                self._leaves.add(node)
                node.backup_value(value, up_to=self._root)
                node.add_virtual_loss(up_to=self._root)
                leaves.append(node)
                continue
            node.add_virtual_loss(up_to=self._root)
            nodes.append(node)

        for node in nodes:
            value = node.readout()
            node.revert_virtual_loss(up_to=self._root)
            node.value = value
            node.incorporate_results(value, up_to=self._root)

        for leaf in leaves:
            leaf.revert_virtual_loss(up_to=self._root)

    def _pick_action(self):
        cdf = (self._root.children_as_pi(squash=True)).cumsum()
        cdf /= cdf[-1]
        selection = random.random()
        action = cdf.searchsorted(selection)
        if self._root.child_n[action] == 0:
            raise AssertionError("pick illegal action.")
        return action

    def _apply_action(self, move):
        self._root = self._root.maybe_add_child(move)
        del self._root.parent.children

    def _leaf_ticks(self):
        return [leaf.tick for leaf in self._leaves]


@strategy_register('mcts')
def search(op_schedule_info):
    search_handler = MCTSSearcher(op_schedule_info)
    search_handler.tree_search()
    logger.event('MCTS searcher is done: %s', search_handler)
