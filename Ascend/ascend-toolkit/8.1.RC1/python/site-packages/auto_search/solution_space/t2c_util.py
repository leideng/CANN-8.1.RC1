#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
rl schedule search, tss
"""
import functools
from dataclasses import make_dataclass

REDUCE_LAST_KEYWORD = "_last"
REDUCE_NIST_KEYWORD = "_nist"

MODE_RUNTIME = "runtime"
MODE_OFFLINE = "offline"

# ID correspond to layer. Do not adjust
AXIS_LEVEL_O_INDEX = 0
AXIS_LEVEL_IO_INDEX = 1
AXIS_LEVEL_I_II_NORMAL_INDEX = 2
AXIS_LEVEL_C_INDEX = 3
AXIS_LEVEL_SUB_AXIS_INDEX = 4
AXIS_LEVEL_IIO_INDEX = 5
AXIS_LEVEL_OO_INDEX = 6

SPLIT_INFO_KEYS = ('factor',
                   'axis_index',
                   'axis_name',
                   'axis_obj',
                   'outer_axis_name',
                   'outer_axis_obj',
                   'inner_axis_name',
                   'inner_axis_obj')
SplitInfo = make_dataclass('SplitInfo', SPLIT_INFO_KEYS)


def get_ori_order(stage_axis_list):
    """
    :param stage_axis_list:
    :return:
    """

    def axis_cmp(lhs, rhs):  # pylint: disable=R0911
        type_order = {'axis': 0, 'reduce_axis': 1}
        attr_order = {'oo': 0,
                      'o': 1,
                      'io': 2,
                      'all': 3,
                      'c': 4,
                      'i': 5,
                      'ii': 6}
        if type_order.get(lhs.type) > type_order.get(rhs.type):
            return 1
        if type_order.get(lhs.type) < type_order.get(rhs.type):
            return -1

        if lhs.index > rhs.index:
            return 1
        if lhs.index < rhs.index:
            return -1

        if attr_order.get(lhs.attr) > attr_order.get(rhs.attr):
            return 1
        if attr_order.get(lhs.attr) < attr_order.get(rhs.attr):
            return -1

        return 0

    return sorted(stage_axis_list,
                  key=functools.cmp_to_key(axis_cmp))


def get_stage_broadcast_axis(stage):
    """
    :param stage:
    :return:
    """
    broadcast_axis_list = []
    if "broadcast" not in stage.op.tag:
        return broadcast_axis_list
    output_shape = stage.op.output(0).shape
    # broadcast scalar without input tensorï¼Œall axises arebroadcast_axis
    if not stage.op.input_tensors:
        return list(range(len(output_shape)))
    input_shape = stage.op.input_tensors[0].shape
    for i in range(len(input_shape) - 1, -1, -1):
        if input_shape[i].value == 1 and output_shape[i].value != 1:
            broadcast_axis_list.append(i)

    broadcast_axis_list.sort()
    return broadcast_axis_list