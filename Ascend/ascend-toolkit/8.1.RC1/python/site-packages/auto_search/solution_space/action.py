#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
search action
"""
from collections import defaultdict
from enum import Enum
from enum import auto
from abc import ABC
from abc import abstractmethod
import numpy as np

_mask_rule_registry = defaultdict(list)
_apply_action_registry = defaultdict(list)
_director_registry = {}


class PrepareActionType(Enum):
    FIRST_TODO = auto()
    AT_ANALYSIS = auto()
    UPDATE_PROGRESS = auto()
    UPDATE_WORKSPACE_TYPE = auto()
    INFER_RANGE = auto()
    GRAPH_ANALYSIS = auto()


class ScheduleActionType(Enum):
    CACHE_READ = auto()
    CACHE_WRITE = auto()
    CACHE_CLONE = auto()
    INLINE = auto()
    SPLIT = auto()
    REORDER = auto()
    BIND = auto()
    AT = auto()
    DOUBLE_BUFFER = auto()
    EMIT_INSN = auto()
    SET_BUFFER_SIZE = auto()
    PRELOAD = auto()
    SET_CONSTRAINT = auto()
    BUILD_CONFIG = auto()
    REUSE = auto()
    SET_STORE_PREDICATE = auto()
    STORAGE_ALIGN = auto()
    COMPUTE_ALIGN = auto()
    RFACTOR = auto()
    PRAGMA = auto()
    MEM_UNIQUE = auto()


class SearchActionType(Enum):
    ATOMIC = auto()
    ATOMIC_RA_BIND = auto()
    AT_STAGE = auto()
    CHOOSE_AXIS = auto()
    SPLIT = auto()
    DOUBLE_BUFFER = auto()
    CHOOSE_CACHE_CLONE = auto()
    ALIGN_PAD = auto()
    REMOVE_PAD = auto()
    REORDER = auto()
    EMIT_INSN = auto()
    UB_TRANSPOSE = auto()


def mask_rule_register(patterns, action_type):
    def wrapper(func):
        patterns_ = patterns if isinstance(patterns, (list, tuple)) else [patterns]
        register_keys = [(pattern, action_type) for pattern in patterns_]
        for key in register_keys:
            _mask_rule_registry[key].append(func)
        return func

    return wrapper


def apply_action_register(patterns, action_type):
    def wrapper(func):
        patterns_ = patterns if isinstance(patterns, (list, tuple)) else [patterns]
        register_keys = [(pattern, action_type) for pattern in patterns_]
        for key in register_keys:
            _apply_action_registry[key].append(func)
        return func

    return wrapper


def director_register(patterns, action_type):
    def wrapper(func):
        patterns_ = patterns if isinstance(patterns, (list, tuple)) else [patterns]
        register_keys = [(pattern, action_type) for pattern in patterns_]
        for key in register_keys:
            _director_registry[key] = func
        return func

    return wrapper


class Action(ABC):
    def __init__(self, pattern, action_type):
        self._pattern = pattern
        self._action_type = action_type

    def __repr__(self):
        return f'Action(pattern={self.pattern}, type={self.action_type})'

    @property
    def pattern(self):
        return self._pattern.name

    @property
    def action_type(self):
        return self._action_type.name

    @property
    def key(self):
        return self._pattern, self._action_type

    @abstractmethod
    def mask(self, progress):
        pass

    @abstractmethod
    def apply(self, progress, action):
        pass

    @abstractmethod
    def direct(self, progress):
        pass

    def _get_mask_rule(self):
        return _mask_rule_registry.get(self.key, [])

    def _get_apply_action(self):
        return _apply_action_registry.get(self.key, [])

    def _get_director(self):
        director = _director_registry.get(self.key)
        if director is None:
            raise RuntimeError(f"no search director registered on the key: {self.key}")
        return director


class VariableAction(Action):
    def __init__(self, pattern, action_type):
        super().__init__(pattern, action_type)

    def mask(self, progress):
        action_mask = np.array([1] * 8, dtype=int)
        funcs = self._get_mask_rule()
        for func in funcs:
            func(progress, action_mask)
        return action_mask

    def apply(self, progress, action):
        funcs = self._get_apply_action()
        for func in funcs:
            func(progress, action)

    def direct(self, progress):
        func = self._get_director()
        func(progress)


class ConstAction(Action):
    def __init__(self, pattern, action_type):
        super().__init__(pattern, action_type)

    def mask(self, progress):
        return np.array([1, 0, 0, 0, 0, 0, 0, 0], dtype=int)

    def apply(self, progress, action):
        funcs = self._get_apply_action()
        for func in funcs:
            func(progress)

    def direct(self, progress):
        func = self._get_director()
        func(progress)
