#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
"""
mask rule: broadcast_brc_split_factor_32b_align_and_no_tail
"""
from auto_search.utils import logger
from auto_search.utils import util
from auto_search.solution_space.features import SEARCH_N
from auto_search.solution_space.tensor_cfg import AXIS_CNT
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.comm import BLOCK_SIZE_BYTE
from auto_search.compute_analysis.broadcast_analysis import can_use_optimize_schedule_for_bn_operators


def is_last_broadcast(op_schedule_info, output_shape):
    last_broadcast = False
    for stage_index, stage in enumerate(op_schedule_info.schedule_obj.stages):
        if stage.op.tag in ['unknown_broadcast', 'unified_broadcast']:
            input_tensor = stage.op.input_tensors[0]
            if input_tensor.shape[-1] != output_shape[-1]:
                last_broadcast = True
    return last_broadcast


@mask_rule_register(ComputePattern.BROADCAST,
                    SearchActionType.SPLIT)
def mask(progress, action_mask):
    """
    if broadcast adopt brc, in AB scene, ub factor must 32B align and no tail block
    :param progress:
    :param action_mask:
    :return:
    """
    stage_index = progress.todo.stage_index
    op_schedule_info = progress.op_schedule_info
    stage = op_schedule_info.schedule_obj.stages[stage_index]
    if not can_use_optimize_schedule_for_bn_operators(progress):
        return

    # # only sampling is over, than judge this rule
    if progress.todo.sub_action_index > 0:
        return

    curr_stage_nonzero_axes = progress.get_nonzero_axes(stage_index)
    ub_cut_index = progress.todo.axis_index
    if not is_last_broadcast(op_schedule_info, curr_stage_nonzero_axes) or \
            ub_cut_index != (len(curr_stage_nonzero_axes) - 2):
        return

    factor_index = \
        ActionTensorCfg.split_factor_s + \
        progress.todo.cache_layer * AXIS_CNT + \
        progress.todo.axis_index
    factor = progress.action_tensor[progress.todo.stage_index][factor_index]
    stage_dtype = stage.op.output(0).dtype
    elemt_in_block = BLOCK_SIZE_BYTE // util.get_dtype_size(stage_dtype)

    for i in range(SEARCH_N):
        next_factor = factor + pow(SEARCH_N, progress.todo.sub_action_index) * i
        tail_size = curr_stage_nonzero_axes[ub_cut_index] % next_factor
        if next_factor % elemt_in_block != 0 or tail_size > 0:
            action_mask[i] = 0

    logger.debug("broadcast_brc_split_factor_32b_align_and_no_tail action_mask:%s", action_mask)
