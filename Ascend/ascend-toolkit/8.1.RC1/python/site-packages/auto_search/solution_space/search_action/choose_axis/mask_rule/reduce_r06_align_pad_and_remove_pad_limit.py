#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
mask rule
"""
from auto_search.utils import logger
from auto_search.solution_space.features import SEARCH_N
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.compute_analysis.reduce_compute_graph import REDUCE_CASE_LENGTH_THREE
from auto_search.solution_space.tensor_cfg import ActionTensorCfg


def _is_split_reduce_stage(op_schedule_info):
    """
    # judge whether it's just split res stage
    :param op_schedule_info:
    :return:
    """
    stages_info_list = op_schedule_info.stages_info
    at_target_set = set()
    for stage_index, stage_info in enumerate(stages_info_list):
        at_target_set.add(stage_info['at_info'].consumers[0].sampled_target)
    if len(at_target_set) == 1:
        return False
    return True


def _get_ub_split_axis(progress):
    stages = progress.op_schedule_info.schedule_obj.stages
    res_stage_index = len(stages) - 1
    split_vector = \
        progress.action_tensor[res_stage_index][ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    # find ub split axis
    res_ub_cut_axis = 0
    for i, f in enumerate(split_vector):
        if f > 0:
            res_ub_cut_axis = i
            break
    return res_ub_cut_axis


def _is_align_pad_axis_continuous(progress):
    op_schedule_info = progress.op_schedule_info
    align_pad_flag = op_schedule_info.is_align_pad
    if not align_pad_flag:
        return True, None
    atomic_flag = op_schedule_info.is_atomic
    reduce_compute_graph = progress.op_schedule_info.compute_graph_info
    if not atomic_flag:
        return True, None
    if len(reduce_compute_graph.shape_before_reduce) != REDUCE_CASE_LENGTH_THREE:
        return True, None
    res_ub_cut_axis = _get_ub_split_axis(progress)
    if res_ub_cut_axis == 0 and not _is_split_reduce_stage(op_schedule_info):
        return False, res_ub_cut_axis
    return True, None


def _is_remove_pad_ub_not_split_tail_axis(progress):
    remove_pad_tag = progress.op_schedule_info.is_remove_pad
    align_pad_tag = progress.op_schedule_info.is_align_pad
    reduce_compute_graph = progress.op_schedule_info.compute_graph_info
    after_reduce_shape = reduce_compute_graph.shape_after_reduce
    if remove_pad_tag or align_pad_tag:
        return False, len(after_reduce_shape) - 1
    return True, None


def _deal_action_mask(action_mask, filter_list):
    for filter in filter_list:
        if filter[0]:
            continue
        for idx in range(SEARCH_N - 1, -1, -1):
            if idx == filter[1]:
                action_mask[idx] = 0


@mask_rule_register([ComputePattern.REDUCE, ComputePattern.NORM], SearchActionType.CHOOSE_AXIS)
def mask(progress, action_mask):
    """
    in some scene, align pad and remove pad is invalid
    :param progress:
    :param action_mask:
    :return:
    """

    filter_list = []
    # axis after align_pad must be continuous
    filter_result, abandoned_axis = _is_align_pad_axis_continuous(progress)
    filter_list.append([filter_result, abandoned_axis])

    # ARA scene do remove_pad or align_pad ub can not split tail axis
    filter_result, abandoned_axis = _is_remove_pad_ub_not_split_tail_axis(progress)
    filter_list.append([filter_result, abandoned_axis])

    _deal_action_mask(action_mask, filter_list)
