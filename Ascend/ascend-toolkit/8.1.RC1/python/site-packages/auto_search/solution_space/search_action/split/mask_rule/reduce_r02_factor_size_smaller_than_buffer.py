#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
mask rule
"""
from auto_search.utils import logger
from auto_search.solution_space.features import SEARCH_N
from auto_search.solution_space.comm import get_limit_ub_size
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.compute_analysis import get_stage_ordered_axes_obj
from auto_search.solution_space.tensor_cfg import ActionTensorCfg


def update_total_factor_size(progress, total_factor_size, ordered_axes_obj, up_split_axis):
    """
    cond:
    last axis is a axis
    res stage ub split last a axis
    reduce stage split r

    eg: a1ra2
    reduce split r
    res split a2
    reduce stage need compute at a2_outer, so  actually total_factor_size =  r_inner * a2_inner
    not total_factor_size =  r_inner * a2
    :param progress:
    :param total_factor_size:
    :param ordered_axes_obj:
    :param up_split_axis:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    reduce_compute_info = op_schedule_info.compute_graph_info
    if op_schedule_info.is_atomic:
        return total_factor_size
    if not ordered_axes_obj.is_reduce_stage():
        return total_factor_size
    if up_split_axis not in reduce_compute_info.reduce_axes_index:
        return total_factor_size
    if reduce_compute_info.is_last_reduce:
        return total_factor_size
    # calculate res split axis
    split_vector = progress.action_tensor[-1][
                   ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    if sum(split_vector) == 0:
        return False
    res_ub_split_axis = 0
    for i, f in enumerate(split_vector):
        if f > 0:
            res_ub_factor = f
            res_ub_split_axis = i
            break
    if res_ub_split_axis != len(op_schedule_info.schedule_obj.stages[-1].op.axis) - 1:
        return total_factor_size
    total_factor_size = \
        total_factor_size // int(op_schedule_info.schedule_obj.stages[-1].op.axis[-1].dom.extent) * res_ub_factor
    return total_factor_size


@mask_rule_register([ComputePattern.TUPLE_REDUCE, ComputePattern.REDUCE], SearchActionType.SPLIT)
def mask(progress, action_mask):
    """
    if calculate ub_count by factor bigger than ub size, this factor need be masked
    :param progress:
    :param action_mask:
    :return:
    """
    stage_index = progress.todo.stage_index
    axis_index = progress.todo.axis_index

    ordered_axes_obj = get_stage_ordered_axes_obj(progress.op_schedule_info, stage_index)
    total_factor_size = ordered_axes_obj.get_total_size_after_split_axis(axis_index)
    total_factor_size = update_total_factor_size(progress, total_factor_size, ordered_axes_obj, axis_index)

    factor_index = progress.todo.axis_index
    factor = progress.action_tensor[progress.todo.stage_index][factor_index]
    limit_ub_size = get_limit_ub_size(progress.op_schedule_info, stage_index)

    logger.debug("total_factor_size:%s factor:%s factor_index:%s limit_ub_size:%s",
                 total_factor_size, factor, factor_index, limit_ub_size)

    sub_action_index = progress.todo.sub_action_index
    for i in range(SEARCH_N):
        next_factor = factor + pow(SEARCH_N, sub_action_index) * i
        if total_factor_size * next_factor > limit_ub_size:
            action_mask[i] = 0

    logger.debug("reduce split r02 factor size smaller than buffer, "
                 "action_mask:%s", action_mask)
