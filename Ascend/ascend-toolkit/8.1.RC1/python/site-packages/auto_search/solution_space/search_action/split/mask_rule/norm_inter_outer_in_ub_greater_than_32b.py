#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
mask rule: norm factor size smaller than bound
"""
from numpy import ndarray

from auto_search.utils import logger
from auto_search.solution_space.features import SEARCH_N
from auto_search.solution_space.tensor_cfg import AXIS_CNT
from auto_search.solution_space.comm import BLOCK_SIZE_BYTE
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.progress import Progress
from auto_search.utils import util


@mask_rule_register([ComputePattern.NORM], SearchActionType.SPLIT)
def proc(progress: Progress, action_mask: ndarray) -> ndarray:
    """
    :param progress:
    :param action_mask:
    :return:
    """

    if progress.todo.sub_action_index > 0:
        return

    stage_index = progress.todo.stage_index
    stages_info = progress.op_schedule_info.stages_info
    stages = progress.op_schedule_info.schedule_obj.stages

    for stage_idx, stage_info in enumerate(stages_info):
        if 'inter_out' not in stage_info.get('type', []):
            continue
        if progress.op_schedule_info.at_dict.get(stage_idx) != stage_index:
            continue

        stage_dtype = stages[stage_idx].op.output(0).dtype
        elemt_in_block = BLOCK_SIZE_BYTE // util.get_dtype_size(stage_dtype)
        nonzero_axis = progress.get_nonzero_axes(stage_idx)
        total_size = 1
        if progress.todo.axis_index < len(nonzero_axis) - 1:
            for dim in nonzero_axis[progress.todo.axis_index+1:]:
                total_size *= dim

        factor_index = \
            ActionTensorCfg.split_factor_s + \
            progress.todo.cache_layer * AXIS_CNT + \
            progress.todo.axis_index
        factor = progress.action_tensor[stage_index][factor_index]

        for i in range(SEARCH_N):
            factor_size = factor + pow(SEARCH_N, progress.todo.sub_action_index) * i
            if min(factor_size, nonzero_axis[progress.todo.axis_index]) * total_size < elemt_in_block:
                action_mask[i] = 0

    logger.debug("norm factor size rule action_mask:%s", action_mask)
    return
