#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
"""
mask rule: broadcast_multi_output_split_no_tails_tail
"""
import math
from auto_search.utils import logger
from auto_search.solution_space.features import SEARCH_N
from auto_search.solution_space.tensor_cfg import AXIS_CNT
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.config import soc_cfg


def get_block_dim(core_num: int, fuse_len: int):
    """
    :param core_num:
    :param fuse_len:
    """
    block_factor = math.ceil(fuse_len / core_num)
    block_dim = math.ceil(fuse_len / block_factor)

    return block_dim


@mask_rule_register(ComputePattern.BROADCAST,
                    SearchActionType.SPLIT)
def mask(progress, action_mask):
    """
    to fix aic error
    multi output broadcast scene, mask ub and block all have tail scene
    :param progress:
    :param action_mask:
    :return:
    """
    stage_index = progress.todo.stage_index
    op_schedule_info = progress.op_schedule_info
    if len(op_schedule_info.output_tensors) < 2:
        return

    # only sampling is over, than judge this rule
    if progress.todo.sub_action_index > 0:
        return

    factor_index = \
        ActionTensorCfg.split_factor_s + \
        progress.todo.cache_layer * AXIS_CNT + \
        progress.todo.axis_index
    factor = progress.action_tensor[progress.todo.stage_index][factor_index]
    left_axis_total_size = 1
    ub_split_index = progress.todo.axis_index
    curr_stage_nonzero_axes = progress.get_nonzero_axes(stage_index)
    core_num = soc_cfg.get_core_num()
    # cal total size before ub split axis
    for idx in range(0, ub_split_index, 1):
        left_axis_total_size *= curr_stage_nonzero_axes[idx]

    for i in range(SEARCH_N):
        next_factor = factor + pow(SEARCH_N, progress.todo.sub_action_index) * i
        ub_tail = curr_stage_nonzero_axes[ub_split_index] % next_factor
        # block split fused axis len
        block_fuse_len = left_axis_total_size * math.ceil(curr_stage_nonzero_axes[ub_split_index] / next_factor)
        block_dim = get_block_dim(block_fuse_len, core_num)
        block_tail = block_fuse_len % block_dim
        if ub_tail != 0 and block_tail != 0:
            action_mask[i] = 0

    logger.debug("broadcast_multi_output_split_no_tails_tail action_mask:%s", action_mask)
