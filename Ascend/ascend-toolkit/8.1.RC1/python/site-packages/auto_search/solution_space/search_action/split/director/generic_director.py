#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
common director
"""
import copy

from auto_search.solution_space.action import director_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.search_action.choose_axis.choose_axis_action import ChooseAxisAction
from auto_search.solution_space.search_action.emit_insn.emit_insn_action import EmitInsnAction
from auto_search.solution_space.search_action.split.split_action import SplitAction
from auto_search.solution_space.comm import get_split_sub_tree_depth
from auto_search.solution_space.schedule_action.split.split_action import SchSplitAction
from auto_search.solution_space.schedule_action.inline.inline_action import InlineAction


@director_register([ComputePattern.ELEMENTWISE], SearchActionType.SPLIT)
def elementwise_direct(progress):
    """
    :param progress:
    :return:
    """
    # split not done, gon on split
    pattern = progress.op_schedule_info.op_pattern
    if progress.todo.sub_action_index > 0:
        next_todo = copy.deepcopy(progress.todo)
        next_todo.action_value = None
        next_todo.sub_action_index -= 1
    else:
        next_todo = SchSplitAction(pattern)

    progress.todo = next_todo


@director_register([ComputePattern.BROADCAST], SearchActionType.SPLIT)
def broadcast_direct(progress):
    """
    :param progress:
    :return:
    """
    # split not done, gon on split
    pattern = progress.op_schedule_info.op_pattern
    if progress.todo.sub_action_index > 0:
        next_todo = copy.deepcopy(progress.todo)
        next_todo.action_value = None
        next_todo.sub_action_index -= 1
    else:
        next_todo = InlineAction(pattern)
    progress.todo = next_todo


@director_register([ComputePattern.TRANSPOSE], SearchActionType.SPLIT)
def transpose_direct(progress):
    """
    :param progress:
    :return:
    """
    # split not done, gon on split
    pattern = progress.op_schedule_info.op_pattern
    if progress.todo.sub_action_index > 0:
        next_todo = copy.deepcopy(progress.todo)
        next_todo.action_value = None
        next_todo.sub_action_index -= 1
    else:
        stage_index = progress.todo.stage_index
        stage_info = progress.op_schedule_info.stages_info[stage_index]
        if len(stage_info.get("chosen_axes", [])) < 2:
            # continue choose axis
            next_todo = ChooseAxisAction(pattern, stage_index)
        else:
            next_todo = EmitInsnAction(pattern, stage_index)
    progress.todo = next_todo


@director_register([ComputePattern.NORM], SearchActionType.SPLIT)
def norm_direct(progress):
    """
    :param progress:
    :return:
    """
    # split is not done, go on
    pattern = progress.op_schedule_info.op_pattern
    if progress.todo.sub_action_index > 0:
        next_todo = copy.deepcopy(progress.todo)
        next_todo.action_value = None
        next_todo.sub_action_index -= 1
        progress.todo = next_todo
        return

    # judge before stage is need sampling or not
    for stage_index in range(progress.todo.stage_index - 1, -1, -1):
        if not stage_need_split(stage_index, progress.op_schedule_info):
            continue
        nonzero_axes = progress.get_nonzero_axes(stage_index)
        if len(nonzero_axes) == 1:
            chosen_axis = 0
            chosen_axis_len = nonzero_axes[chosen_axis]
            sub_tree_depth = get_split_sub_tree_depth(chosen_axis_len)
            progress.action_tensor[stage_index][chosen_axis] = 1
            progress.todo = SplitAction(pattern, stage_index, sub_tree_depth - 1, chosen_axis)
            return

        progress.todo = ChooseAxisAction(pattern, stage_index)
        return

    progress.todo = InlineAction(pattern)


@director_register([ComputePattern.POOLING], SearchActionType.SPLIT)
def pooling_direct(progress):
    """
    :param progress:
    :return:
    """
    # split is not done, go on
    pattern = progress.op_schedule_info.op_pattern
    if progress.todo.sub_action_index > 0:
        next_todo = copy.deepcopy(progress.todo)
        next_todo.action_value = None
        next_todo.sub_action_index -= 1
        progress.todo = next_todo
        return

    # judge before stage is need sampling or not
    for stage_index in range(progress.todo.stage_index - 1, -1, -1):
        if not stage_need_split(stage_index, progress.op_schedule_info):
            continue
        progress.todo = ChooseAxisAction(pattern, stage_index)
        return

    progress.todo = SchSplitAction(pattern)


def stage_need_split(stage_index, op_schedule_info):
    """
    # if reduce stage be compute_at should be split
    # leaf„ÄÅworkspace need be split
    :param stage_index:
    :param op_schedule_info:
    :return:
    """
    stage_types = op_schedule_info.stages_info[stage_index].get('type', [])
    if 'reduce' in stage_types and \
            stage_index in op_schedule_info.at_dict.values():
        return True
    if {'leaf', 'workspace', "l1fuse_leaf"} & set(stage_types):
        return True
    return False
