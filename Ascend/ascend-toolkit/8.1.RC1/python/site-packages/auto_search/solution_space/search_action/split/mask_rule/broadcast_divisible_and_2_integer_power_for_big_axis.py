#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
mask rule
"""
from auto_search.utils import logger
from auto_search.solution_space.tensor_cfg import AXIS_CNT
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.features import SEARCH_N
from auto_search.solution_space.comm import get_limit_ub_size
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern


def condition_check(progress):
    """
    :param progress:
    :return:
    """
    # get axis len
    stage_index = progress.todo.stage_index
    curr_stage_nonzero_axes = progress.get_nonzero_axes(stage_index)
    axis_len = curr_stage_nonzero_axes[progress.todo.axis_index]

    # bigger than 4096 use 2 power method
    if axis_len < pow(2, 12):
        return False

    ub_right_multi_size = 1
    stage_index = progress.todo.stage_index
    curr_stage_nonzero_axes = progress.get_nonzero_axes(stage_index)
    ub_cut_index = progress.todo.axis_index
    for idx in range(len(curr_stage_nonzero_axes) - 1, ub_cut_index, -1):
        ub_right_multi_size *= curr_stage_nonzero_axes[idx]
    limit_ub_size = get_limit_ub_size(progress.op_schedule_info, stage_index)

    # if current axis factor value range in [1, 1024], need not use 2 power method
    if limit_ub_size // ub_right_multi_size <= pow(2, 10):
        return False

    return True


def need_mask(progress, axis_len, factor, idx):
    """
    :param progress:
    :param axis_len:
    :param factor:
    :param idx:
    :return:
    """
    # factor sampling is not over, judge the factor list can meet the conditions or not
    sub_factor = pow(SEARCH_N, progress.todo.sub_action_index)
    if progress.todo.sub_action_index > 0:
        min_new_factor = factor + sub_factor * idx
        max_new_factor = min_new_factor + sub_factor
        new_factor_list = list(range(min_new_factor, max_new_factor))
    # factor sampling is over, judge the factor itself can meet the conditions or not
    else:
        new_factor_list = [factor + sub_factor * idx]

    mask_flag = True
    for new_factor in new_factor_list:
        if axis_len % new_factor == 0:
            mask_flag = False
            break
        if new_factor & (new_factor - 1) == 0:
            mask_flag = False
            break
        # if factor is multiple of 1024, is also valid,
        # avoid 2 power interval is big when exponent is bigger
        if new_factor % 1024 == 0:
            mask_flag = False
            break

    return mask_flag


@mask_rule_register(ComputePattern.BROADCAST, SearchActionType.SPLIT)
def mask(progress, action_mask):
    """
    if axis len is so bigger, search space is so bigger, it too slow to search a best value,
    so only keep divisible factor or 2 power value in space
    :param progress:
    :param action_mask:
    :return:
    """
    if not condition_check(progress):
        return

    factor_index = ActionTensorCfg.split_factor_s + \
                   progress.todo.cache_layer * AXIS_CNT + \
                   progress.todo.axis_index
    factor = progress.action_tensor[progress.todo.stage_index][factor_index]
    axis_len = progress.get_nonzero_axes(progress.todo.stage_index)[
        progress.todo.axis_index]

    pattern_flag = progress.op_schedule_info.op_pattern in [ComputePattern.ELEMENTWISE]
    if pattern_flag:
        return

    for idx in range(SEARCH_N):
        if need_mask(progress, axis_len, factor, idx):
            action_mask[idx] = 0

    logger.debug('divisible_and_2_integer_power_rule: %s', action_mask)
    return
