#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
mask rule: norm factor size smaller than bound
"""
from numpy import ndarray

from auto_search.utils import logger
from auto_search.solution_space.features import SEARCH_N
from auto_search.solution_space.tensor_cfg import AXIS_CNT
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.comm import get_limit_ub_size


@mask_rule_register([ComputePattern.POOLING], SearchActionType.SPLIT)
def proc(progress: Progress, action_mask: ndarray) -> ndarray:
    """
    if calculate ub_count by factor bigger than ub size, this factor need be masked
    :param progress: Progress
    :param action_mask: action mask
    :return: action mask
    """
    total_factor_size = 1
    stage_index = progress.todo.stage_index
    if stage_index in progress.op_schedule_info.reduce_axis_dict:
        return action_mask

    # ge ub_size
    ub_size = get_limit_ub_size(progress.op_schedule_info, stage_index)
    if progress.op_schedule_info.is_open_db:
        ub_size = ub_size // 2

    if stage_index in progress.op_schedule_info.reduce_axis_dict:
        stage = progress.op_schedule_info.schedule_obj.stages[stage_index]
        total_factor_size *= 16
        if progress.todo.axis_index < len(stage.op.reduce_axis) - 1:
            for axis in stage.op.reduce_axis[progress.todo.axis_index + 1:]:
                total_factor_size *= axis.dom.extent.value
    else:
        nonzero_axis = progress.get_nonzero_axes(stage_index)
        if progress.todo.axis_index < len(nonzero_axis) - 1:
            for dim in nonzero_axis[progress.todo.axis_index + 1:]:
                total_factor_size *= dim

    # get factor
    factor_index = \
        ActionTensorCfg.split_factor_s + \
        progress.todo.cache_layer * AXIS_CNT + \
        progress.todo.axis_index
    factor = progress.action_tensor[progress.todo.stage_index][factor_index]

    for i in range(SEARCH_N):
        next_factor = factor + pow(SEARCH_N, progress.todo.sub_action_index) * i
        if total_factor_size * next_factor > ub_size:
            action_mask[i] = 0

    return action_mask
