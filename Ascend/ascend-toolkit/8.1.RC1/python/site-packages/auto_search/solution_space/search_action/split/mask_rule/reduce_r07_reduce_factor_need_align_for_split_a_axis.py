#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
mask rule
"""
from auto_search.utils import util
from auto_search.utils import logger
from auto_search.solution_space.features import SEARCH_N
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.compute_analysis import get_stage_ordered_axes_obj
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.comm import BLOCK_SIZE_BYTE


@mask_rule_register([ComputePattern.TUPLE_REDUCE, ComputePattern.REDUCE], SearchActionType.SPLIT)
def mask(progress, action_mask):
    """
    if res and reduce all split a axis, reduce factor need align, otherwise aic error
    :param progress:
    :param action_mask:
    :return:
    """
    stage_index = progress.todo.stage_index
    # res need not this rule
    if stage_index == len(progress.op_schedule_info.schedule_obj.stages) - 1:
        return

    # if reduce stage not split a axis, return
    ub_split_index = progress.todo.axis_index
    reduce_compute_graph = progress.op_schedule_info.compute_graph_info
    if ub_split_index not in reduce_compute_graph.normal_axes_index:
        return

    # only sampling is over, than judge this rule
    if progress.todo.sub_action_index > 0:
        return
    # get factor
    factor_index = progress.todo.axis_index
    factor = progress.action_tensor[stage_index][factor_index]
    stages = progress.op_schedule_info.schedule_obj.stages
    stage_dtype = stages[stage_index].op.output(0).dtype
    elemt_in_block = BLOCK_SIZE_BYTE // util.get_dtype_size(stage_dtype)
    res_ub_split_axis, res_ub_factor = _get_res_ub_split_axis_and_factor(progress)
    for i in range(SEARCH_N):
        next_factor = factor + pow(SEARCH_N, progress.todo.sub_action_index) * i
        if next_factor % elemt_in_block != 0:
            action_mask[i] = 0
        # if reduce and res split a same axis, reduce factor should smaller than res factor
        if reduce_compute_graph.normal_axes_index.index(ub_split_index) == res_ub_split_axis:
            if next_factor > res_ub_factor:
                action_mask[i] = 0

    logger.debug("reduce_r07_reduce_factor_need_align_for_split_a_axis, action_mask:%s", action_mask)


def _get_res_ub_split_axis_and_factor(progress):
    """
    :param progress:
    :return:
    """
    stages = progress.op_schedule_info.schedule_obj.stages
    res_stage_index = len(stages) - 1
    split_vector = \
        progress.action_tensor[res_stage_index][ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    # find ub split axis
    res_ub_cut_axis = 0
    res_factor = 1
    for i, f in enumerate(split_vector):
        if f > 0:
            res_ub_cut_axis = i
            res_factor = f
            break

    return res_ub_cut_axis, res_factor
