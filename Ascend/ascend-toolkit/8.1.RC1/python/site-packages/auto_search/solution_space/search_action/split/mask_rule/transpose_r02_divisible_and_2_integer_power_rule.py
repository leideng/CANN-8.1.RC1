#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
mask rule
"""
from auto_search.utils import logger
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.action import SearchActionType
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.tensor_cfg import AXIS_CNT
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.features import SEARCH_N


def need_mask(progress, axis_len, factor, idx):
    """
    :param progress:
    :param axis_len:
    :param factor:
    :param idx:
    :return:
    """
    sub_factor = pow(SEARCH_N, progress.todo.sub_action_index)
    if progress.todo.sub_action_index > 0:
        min_new_factor = factor + sub_factor * idx
        max_new_factor = min_new_factor + sub_factor
        new_factor_list = list(range(min_new_factor, max_new_factor))
    else:
        new_factor_list = [factor + sub_factor * idx]

    mask_flag = True
    for new_factor in new_factor_list:
        if axis_len % new_factor == 0:
            mask_flag = False
            break
        if new_factor & (new_factor - 1) == 0:
            mask_flag = False
            break

    return mask_flag


@mask_rule_register([ComputePattern.TRANSPOSE], SearchActionType.SPLIT)
def mask(progress, action_mask):
    """
    if axis len is so bigger, search space is so bigger, it too slow to search a best value,
    so only keep divisible factor or 2 power value in space
    :param progress:
    :param action_mask:
    :return:
    """
    factor_index = ActionTensorCfg.split_factor_s + \
                   progress.todo.cache_layer * AXIS_CNT + \
                   progress.todo.axis_index
    factor = progress.action_tensor[progress.todo.stage_index][factor_index]
    axis_len = progress.get_nonzero_axes(progress.todo.stage_index)[
        progress.todo.axis_index]

    for idx in range(SEARCH_N):
        if need_mask(progress, axis_len, factor, idx):
            action_mask[idx] = 0

    logger.debug('transpose_r01_divisible_and_2_integer_power_rule: %s', action_mask)
