#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
mask rule: elementwise_factor_rule
"""
from auto_search.utils import logger
from auto_search.solution_space.tensor_cfg import AXIS_CNT
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.features import SEARCH_N
from auto_search.utils.util import DTYPE_BYTE_MAPPING
from auto_search.utils.util import BLOCK_SIZE
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern


def condition_check(progress):
    """
    :param progress:
    :return:
    """
    elemwise_pattern = progress.op_schedule_info.op_pattern in [ComputePattern.ELEMENTWISE]
    if not elemwise_pattern:
        return False

    return True


def need_mask_for_elemwise_operator(progress, axis_len, factor, idx):
    """
    :param progress:
    :param axis_len:
    :param factor:
    :param idx:
    :return:
    """
    # factor sampling is not over, judge the factor list can meet the conditions or not
    sub_factor = pow(SEARCH_N, progress.todo.sub_action_index)
    if progress.todo.sub_action_index > 0:
        min_new_factor = factor + sub_factor * idx
        max_new_factor = min_new_factor + sub_factor
        new_factor_list = list(range(min_new_factor, max_new_factor))
    # factor sampling is over, judge the factor itself can meet the conditions or not
    else:
        new_factor_list = [factor + sub_factor * idx]

    dtype_byte = DTYPE_BYTE_MAPPING.get(progress.op_schedule_info.output_info_list[0].dtype)
    mask_flag = True
    for new_factor in new_factor_list:
        # factor=0 node need be mask
        if progress.todo.sub_action_index == 0 and new_factor == 0:
            return mask_flag
        if new_factor == 0:
            continue
        if axis_len % new_factor == 0:
            mask_flag = False
            break
        if new_factor % (BLOCK_SIZE // dtype_byte) == 0:
            mask_flag = False
            break

    return mask_flag


@mask_rule_register(ComputePattern.ELEMENTWISE, SearchActionType.SPLIT)
def mask(progress, action_mask):
    """
    pure elementwise operator can fused to one axis,
    output tensor dma_copy can add attr no_overlap=0 to improve profiling,
    on condition that ub_count need align.
    :param progress:
    :param action_mask:
    :return:
    """
    if not condition_check(progress):
        return

    factor_index = ActionTensorCfg.split_factor_s + \
                   progress.todo.cache_layer * AXIS_CNT + \
                   progress.todo.axis_index
    factor = progress.action_tensor[progress.todo.stage_index][factor_index]
    axis_len = progress.get_nonzero_axes(progress.todo.stage_index)[
        progress.todo.axis_index]

    for idx in range(SEARCH_N):
        if need_mask_for_elemwise_operator(progress, axis_len, factor, idx):
            action_mask[idx] = 0

    logger.debug('r15_pure_elemwise_factor_rule: %s', action_mask)

    return
