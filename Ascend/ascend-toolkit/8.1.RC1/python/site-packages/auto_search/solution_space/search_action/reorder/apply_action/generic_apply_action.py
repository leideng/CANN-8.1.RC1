#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
search reorder apply action
"""
from itertools import permutations
from typing import NoReturn
from typing import List

from auto_search.solution_space.action import apply_action_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.bank.cheque_generator import get_reorder_cheque
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.tensor_cfg import AXIS_CNT
from auto_search.utils.util import get_dtype_size


def do_dma_reorder(progress: Progress, rw_stage_info: dict, reorder_action: list) -> NoReturn:
    """
    do dma reorder
    :param progress:
    :param rw_stage_info:
    :param reorder_action:
    :return:
    """
    stage_index = progress.todo.stage_index
    stage = progress.op_schedule_info.schedule_obj.stages[stage_index]
    # get nonzero axes
    axis_list = progress.op_schedule_info.feature_tensor[-1][:AXIS_CNT]
    nonzero_axes = [dim for dim in axis_list if dim > 0]
    # get axis info
    reorder_axis_order = reorder_action[:len(nonzero_axes)]
    axes_info = [stage.op.axis[axis_index] for axis_index in reorder_axis_order]
    stage.reorder(*axes_info)

    progress.op_schedule_info.code_lines.append('# reorder_index_%s: %s' % (rw_stage_info['name'], reorder_axis_order))

    code_line = []
    code_line.append('sch[%s].reorder(' % rw_stage_info['name'])
    for axis_num in reorder_axis_order:
        code_line.append("%s.op.axis[%s], " % (rw_stage_info['name'], axis_num))
    code_line.append('%s' % ')')

    cheque = get_reorder_cheque(stage_index, reorder_axis_order)
    progress.op_schedule_info.cheque_list.append(cheque)

    progress.op_schedule_info.code_lines.append(''.join(code_line))


def _update_ordered_axes(next_progress: Progress, ordered_axes: List) -> NoReturn:
    """
    :param next_progress:
    :param ordered_axes:
    :return:
    """
    ori_permute = []
    for stage in next_progress.op_schedule_info.schedule_obj.stages:
        if "permute" in stage.op.attrs:
            ori_permute = [int(i) for i in stage.op.attrs["permute"]]
            break
    out_tensor = next_progress.op_schedule_info.schedule_obj.stages[-1].op.output(0)

    # not_last_transpose or dtype is float32 not need to do reorder, this rule is from manual_schedule
    if int(ori_permute[len(ori_permute) - 1]) == len(ori_permute) - 1 or \
            get_dtype_size(out_tensor.dtype) > 2:
        ordered_axes = list(range(len(ori_permute)))
    return ordered_axes


@apply_action_register([ComputePattern.TRANSPOSE], SearchActionType.REORDER)
def apply(next_progress: Progress, action_value: int):
    """
    reorder action value apply
    :param next_progress: Progress
    :param action_value: action value
    :return: no return
    """
    stage_index = next_progress.todo.stage_index
    stage_info = next_progress.op_schedule_info.stages_info[stage_index]
    stage_info.setdefault('transpose_reorder_num', 0)
    sub_action_index = next_progress.todo.sub_action_index
    stage_info['transpose_reorder_num'] += pow(AXIS_CNT, sub_action_index) * action_value

    # sample finished
    if next_progress.todo.sub_action_index == 0:
        # get reorder num
        reorder_num = stage_info.get('transpose_reorder_num')
        nonzero_axes = next_progress.get_nonzero_axes(0)
        # get axes_index
        axes_index = list(range(len(nonzero_axes)))
        axes_perms = sorted(permutations(axes_index))
        if reorder_num >= len(axes_perms):
            reorder_num = 0
        ordered_axes = axes_perms[reorder_num]

        # clear trs_reorder_num for next reorder
        next_progress.op_schedule_info.stages_info[stage_index]["transpose_reorder_num"] = 0

        # do search reorder for sch
        # the scene of last axis not transpose: size byte is more than 2, input tensor is not reorder
        if 'CacheRead' in stage_info.get('type', []):
            ordered_axes = _update_ordered_axes(next_progress, ordered_axes)

        # manual_debug reorder_action
        debug_params = next_progress.op_schedule_info.option.get("trs_debug", [False, {}])
        if debug_params[0]:
            input_reorder_action = debug_params[1]["trs_input_reorder_action"]
            output_reorder_action = debug_params[1]["trs_output_reorder_action"]
            if 'CacheRead' in stage_info.get('type', []):
                ordered_axes = input_reorder_action
            else:
                ordered_axes = output_reorder_action

        # reorder count for next reorder search
        next_progress.op_schedule_info.dma_reorder_list.append(ordered_axes)

        do_dma_reorder(next_progress, stage_info, ordered_axes)
