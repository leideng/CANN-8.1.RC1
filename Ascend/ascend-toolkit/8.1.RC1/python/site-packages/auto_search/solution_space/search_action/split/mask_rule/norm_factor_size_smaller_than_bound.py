#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
mask rule: norm factor size smaller than bound
"""
from numpy import ndarray

from auto_search.utils import logger
from auto_search.solution_space.features import SEARCH_N
from auto_search.solution_space.tensor_cfg import AXIS_CNT
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.action import mask_rule_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.comm import get_limit_ub_size


@mask_rule_register([ComputePattern.NORM], SearchActionType.SPLIT)
def proc(progress: Progress, action_mask: ndarray) -> ndarray:
    """
    1. if calculate ub_count by factor bigger than ub size, this factor need be masked
    2. if reduce stage not be cut, and compute at current stage,
    judge factor*reduce_dim_size is less equal than ub_size or not
    :param progress: Progress
    :param action_mask: action mask
    :return: action mask
    """
    total_factor_size = 1
    stage_index = progress.todo.stage_index
    # ge ub_size
    ub_size = get_limit_ub_size(progress.op_schedule_info, stage_index)
    if progress.op_schedule_info.is_open_db:
        ub_size = ub_size // 2
    nonzero_axis = progress.get_nonzero_axes(stage_index)

    # get factor
    factor_index = \
        ActionTensorCfg.split_factor_s + \
        progress.todo.cache_layer * AXIS_CNT + \
        progress.todo.axis_index
    factor = progress.action_tensor[progress.todo.stage_index][factor_index]

    reduce_stage_idx, reduce_type = _reduce_stage_not_be_cut_proc(action_mask, factor, progress, stage_index, ub_size)

    # if reduce stage be cut, compare last a_axis_len * factor with ub_size
    if stage_index in reduce_stage_idx:
        if reduce_type in ['nist']:
            at_stage = progress.op_schedule_info.at_dict[stage_index]
            at_stage_split_factor = progress.action_tensor[at_stage][
                        ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
            nonzero_axis = progress.get_nonzero_axes(at_stage)
            if at_stage_split_factor[len(nonzero_axis)-1] == 0:
                total_factor_size = nonzero_axis[-1]
            else:
                total_factor_size = at_stage_split_factor[len(nonzero_axis)-1]
    # not reduce stage proc
    else:
        if progress.todo.axis_index < len(nonzero_axis) - 1:
            for dim in nonzero_axis[progress.todo.axis_index + 1:]:
                total_factor_size *= dim

    for i in range(SEARCH_N):
        next_factor \
            = factor + pow(SEARCH_N, progress.todo.sub_action_index) * i
        if total_factor_size * next_factor >= ub_size:
            action_mask[i] = 0

    logger.debug("norm factor size rule action_mask:%s", action_mask)


def _reduce_stage_not_be_cut_proc(action_mask, factor, progress, stage_index, ub_size):
    """
    :param action_mask:
    :param factor:
    :param progress:
    :param stage_index:
    :param ub_size:
    :return:
    """
    reduce_stage_idx = []
    at_stage_list = list(progress.op_schedule_info.at_dict.values())
    reduce_type = ''
    for key, value in progress.op_schedule_info.reduce_axis_dict.items():
        reduce_stage_idx.append(key)
        reduce_axis = value.get("axis")
        reduce_type = value.get('type')

        # if reduce stage not be cut, and compute at current stage,
        # judge factor*reduce_dim_size is less equal than ub_size or not
        if key not in at_stage_list:
            reduce_at_stage = progress.op_schedule_info.at_dict[key]
            reduce_tensor_shape = progress.get_nonzero_axes(key)
            reduce_dim_size = 1
            for axis in reduce_axis:
                reduce_dim_size *= reduce_tensor_shape[axis]
            if reduce_at_stage == stage_index:
                _reduce_at_stage_proc(action_mask, factor, progress, reduce_dim_size, ub_size)
            else:
                _not_be_at_stage_proc(action_mask, reduce_dim_size, ub_size)
    return reduce_stage_idx, reduce_type


def _not_be_at_stage_proc(action_mask, reduce_dim_size, ub_size):
    """
    :param action_mask:
    :param reduce_dim_size:
    :param ub_size:
    :return:
    """
    for i in range(SEARCH_N):
        if reduce_dim_size > ub_size:
            action_mask[i] = 0


def _reduce_at_stage_proc(action_mask, factor, progress, reduce_dim_size, ub_size):
    """
    :param action_mask:
    :param factor:
    :param progress:
    :param reduce_dim_size:
    :param ub_size:
    :return:
    """
    for i in range(SEARCH_N):
        next_factor = factor + pow(SEARCH_N, progress.todo.sub_action_index) * i
        if reduce_dim_size * next_factor > ub_size:
            action_mask[i] = 0
