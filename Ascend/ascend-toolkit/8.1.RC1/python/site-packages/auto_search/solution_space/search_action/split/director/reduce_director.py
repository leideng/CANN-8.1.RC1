#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
common director
"""
import copy

from auto_search.solution_space.action import director_register
from auto_search.solution_space.action import SearchActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.search_action.choose_axis.choose_axis_action import ChooseAxisAction
from auto_search.solution_space.search_action.split.split_action import SplitAction
from auto_search.solution_space.comm import get_split_sub_tree_depth
from auto_search.solution_space.schedule_action.split.split_action import SchSplitAction
from auto_search.solution_space.schedule_action.rfactor.rfactor_action import RfactorAction
from auto_search.solution_space.schedule_action.rfactor.rfactor_action import RfactorType
from auto_search.compute_analysis import ReduceInfoForRfactor
from auto_search.compute_analysis import get_reduce_info_for_rfactor


def stage_need_split(stage_index, op_schedule_info):
    """
    # if reduce stage be compute_at should be split
    # leaf、workspace need be split
    :param stage_index:
    :param op_schedule_info:
    :return:
    """
    stage_types = op_schedule_info.stages_info[stage_index].get('type', [])
    if 'reduce' in stage_types and \
            stage_index in op_schedule_info.at_dict.values():
        return True
    if {'leaf', 'workspace', "l1fuse_leaf"} & set(stage_types):
        return True
    return False


def _choose_next_to_do_action(progress):
    """
    :param progress:
    :return:
    """
    pattern = progress.op_schedule_info.op_pattern
    reduce_info_for_rfactor: ReduceInfoForRfactor = get_reduce_info_for_rfactor(progress)

    # atomic schedule next action is RfactorAction
    if reduce_info_for_rfactor.is_atomic:
        next_todo = RfactorAction(pattern, reduce_info_for_rfactor, RfactorType.ATOMIC_RFACTOR)
        return next_todo

    # judge before stage is need sampling or not
    for stage_index in range(progress.todo.stage_index - 1, -1, -1):
        if stage_need_split(stage_index, progress.op_schedule_info):
            nonzero_axes = progress.get_nonzero_axes(stage_index)
            if len(nonzero_axes) == 1:
                chosen_axis = 0
                chosen_axis_len = nonzero_axes[chosen_axis]
                sub_tree_depth = get_split_sub_tree_depth(chosen_axis_len)
                progress.action_tensor[stage_index][chosen_axis] = 1
                next_todo = SplitAction(pattern, stage_index, sub_tree_depth - 1, chosen_axis)
                return next_todo

            next_todo = ChooseAxisAction(pattern, stage_index)
            return next_todo

    if reduce_info_for_rfactor.split_stage_num not in [1, 2]:
        raise RuntimeError(
            "reduce schedule only support 1 or 2 stage!, while is %d" % reduce_info_for_rfactor.split_stage_num)

    # normal template: only split res stage, next action is SchSplitAction
    if reduce_info_for_rfactor.split_stage_num == 1:
        next_todo = SchSplitAction(pattern)
        return next_todo

    # normal template: split res and reduce stages
    do_rfactor_before_split = reduce_info_for_rfactor.is_last_reduce \
                              and reduce_info_for_rfactor.ub_split_reduce_axis \
                              and not reduce_info_for_rfactor.ub_split_last_reduce_axis \
                              and pattern == ComputePattern.REDUCE
    if do_rfactor_before_split:
        # last reduce and ub split reduce axis but not last axis should do rfactor before split
        next_todo = RfactorAction(pattern, reduce_info_for_rfactor,
                                  RfactorType.SPLIT_NLAST_REDUCE_AXIS_RFACTOR_FOR_NORMAL)
    else:
        next_todo = SchSplitAction(pattern, reduce_info_for_rfactor)

    return next_todo


@director_register([ComputePattern.TUPLE_REDUCE, ComputePattern.REDUCE], SearchActionType.SPLIT)
def direct(progress):
    """
    :param progress:
    :return:
    """
    # split is not done, go on
    if progress.todo.sub_action_index > 0:
        next_todo = copy.deepcopy(progress.todo)
        next_todo.action_value = None
        next_todo.sub_action_index -= 1
        progress.todo = next_todo
        return

    next_todo = _choose_next_to_do_action(progress)
    progress.todo = next_todo
    return
