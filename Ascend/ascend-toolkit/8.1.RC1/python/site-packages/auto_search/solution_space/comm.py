#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
comm func
"""
import math

from auto_search.utils import util
from auto_search.config import soc_cfg
from auto_search.solution_space.op_schedule_info import OpScheduleInfo
from auto_search.solution_space.tensor_cfg import AXIS_CNT
from auto_search.solution_space.tensor_cfg import MAX_FACTOR

# compute the max depth of sub_tree by factor
MAX_SUB_ACTION_DEPTH = int(math.ceil(math.log(MAX_FACTOR, AXIS_CNT)))

BLOCK_SIZE_BYTE = 32


def get_split_sub_tree_depth(axis_len: int) -> int:
    """
    :param axis_len:
    :return:
    """
    depth = int(math.log(axis_len, AXIS_CNT))
    if axis_len > pow(AXIS_CNT, depth):
        depth = depth + 1
    if depth == 0:
        return 1
    return min(depth, MAX_SUB_ACTION_DEPTH)


def get_limit_ub_size(op_schedule_info: OpScheduleInfo, stage_index: int) -> int:
    """
    get limit ub size for choose_axis and split mask
    :param op_schedule_info:
    :param stage_index:
    :return:
    """
    ub_size = soc_cfg.get_ub_size() // 2  # at least two surviving node
    limit_ub_size = ub_size // BLOCK_SIZE_BYTE * BLOCK_SIZE_BYTE
    stages = op_schedule_info.schedule_obj.stages
    stage_dtype = stages[stage_index].op.output(0).dtype
    limit_ub_size = limit_ub_size // util.get_dtype_size(stage_dtype)

    return limit_ub_size
