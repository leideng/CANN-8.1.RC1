#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
rl schedule search, tss
"""
import numpy as np


AXIS_CNT = 8  # at most 8 aixes per stage
INVALID_AT_AXIS = 65535  # invalid at axis
DEFAULT_INSN_INDEX = 0  # default insn index

OP_LEN = 1  # op len

DEPEND_LEN = 50  # num of depen
DEPEND_BITS = 8  # bits of one depend

MAX_FACTOR = 256 * 1024  # max factor

MAX_ORIGIN_STAGE_CNT = DEPEND_LEN * DEPEND_BITS // 2  # max num of stage




class ActionTensorCfg:
    """
    ActionTensorCfg
    """
    # sampled action len of one stage: 5 axis has two split，two reorder，one at,
    # one emit_insn, two trs_reorder
    action_len = AXIS_CNT * 2 + AXIS_CNT * 2 + 1 + 1 + AXIS_CNT * 2
    split_factor_s = 0
    split_factor_e = AXIS_CNT * 2 - 1
    reorder_s = AXIS_CNT * 2
    reorder_e = AXIS_CNT * 4 - 1
    at_s = AXIS_CNT * 4
    at_e = AXIS_CNT * 4
    emit_insn_s = AXIS_CNT * 4 + 1
    emit_insn_e = AXIS_CNT * 4 + 1
    # reorder for trs-class op,
    # this reorder has an effect on input/output tensor,
    # so apply for an independent axis_len
    trs_reorder_s = AXIS_CNT * 4 + 1 + 1
    trs_reorder_e = AXIS_CNT * 4 + 1 + 1 + AXIS_CNT * 2 - 1

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.action_len

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.at_e


class FeatureTensorCfg:
    """
    FeatureTensorCfg
    """
    featurn_len = AXIS_CNT * 2 + OP_LEN + DEPEND_LEN
    axis_s = 0
    axis_e = AXIS_CNT - 1
    reduce_axis_s = AXIS_CNT
    reduce_axis_e = AXIS_CNT * 2 - 1
    compute_s = AXIS_CNT * 2
    compute_e = AXIS_CNT * 2
    deps_s = AXIS_CNT * 2 + OP_LEN
    deps_e = AXIS_CNT * 2 + OP_LEN + DEPEND_LEN - 1

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.featurn_len

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.deps_s


class AxisInfo:
    """
    AxisInfo
    """
    def __init__(
            self,
            axis_name,
            axis_len,
            axis_type,
            axis_index,
            axis_attr,
            axis_body=None,
            sub_axis_split=None,
            sub_axis_factor=None):
        self.name = axis_name
        self.len = axis_len
        self.type = axis_type
        self.index = axis_index  # ori index of axis 
        self.attr = axis_attr  # attr: o/i/io/ii
        self.body = axis_body  # for processing stage when runtime
        self.sub_axis_split = sub_axis_split  # sub axis tag，such as:N, C, H, W
        self.sub_axis_factor = sub_axis_factor  # factor of sub axis

    def __str__(self):
        print_str = "name: %s, len: %s, type: %s, index: %s, attr: %s, " \
                    "body: %s, sub_axis_split: %s, " \
                    "sub_axis_factor: %s" % (self.name, self.len, self.type,
                                             self.index, self.attr, self.body,
                                             self.sub_axis_split,
                                             self.sub_axis_factor)
        return print_str

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.name

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.type


def get_init_action_tensor_zero(stage_num, axis_cnt=AXIS_CNT, layers=2):
    """
    all factor are initialized to 0
    :param stage_num:
    :param axis_cnt:
    :param layers:
    :return:
    """
    # all factor are 0
    factors = np.zeros([stage_num, axis_cnt], dtype=np.int32)
    # all Reorder are 0~len of axis
    reorders = np.ones([stage_num, axis_cnt],
                       dtype=np.int32).cumsum(axis=1) - 1

    # init at axis to invalid vaule, update by sample and rules
    at_axis = np.full([stage_num, 1], INVALID_AT_AXIS)

    # emit_insn init
    emit_insn_index = np.full([stage_num, 1], DEFAULT_INSN_INDEX)

    # all trs_reorder are 0~len of axis
    trs_reorders = np.ones([stage_num, axis_cnt],
                           dtype=np.int32).cumsum(axis=1) - 1

    # add Factor、Reorder and at emit_insn trs_reorder by layers
    tensor_list = [factors] * layers + [reorders] * layers + [at_axis] + \
                  [emit_insn_index] + [trs_reorders] * 2

    action_tensor = np.concatenate(tensor_list, axis=1)
    return action_tensor


class TensorInfo:
    """
    TensorInfo
    """

    def __init__(self, name, shape, dtype):
        self.name = name
        self.shape = shape
        self.dtype = dtype

    def __str__(self):
        print_str = "TensorInfo, name: %s, shape: %s, dtype: %s" % (
            self.name, self.shape, self.dtype)
        return print_str

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.name

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.shape
