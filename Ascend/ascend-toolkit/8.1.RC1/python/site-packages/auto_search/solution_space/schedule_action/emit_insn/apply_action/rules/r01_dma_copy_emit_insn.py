#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
dma axis
"""
from auto_search.utils import util
from auto_search.utils import logger
from auto_search.compute_analysis.compute_pattern import ComputePattern
from auto_search.utils.util import DTYPE_BYTE_MAPPING
from auto_search.utils.util import BLOCK_SIZE
from auto_search.solution_space.tensor_cfg import FeatureTensorCfg
from auto_search.bank.cheque_generator import get_emit_insn_cheque
from auto_search.bank.cheque_generator import get_reuseby_cheque


def proc(progress):
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_index = op_schedule_info.stage_index
    stage_name = op_schedule_info.stages_info[stage_index]['name']
    stages_info = op_schedule_info.stages_info

    if {'align_pad', 'broadcast_remove_pad'} & set(stages_info[stage_index].get('type', [])):
        return

    # if have been handled stage return directly
    if op_schedule_info.proc_flag_dict.get(stage_index, False):
        return

    intrin = op_schedule_info.op_intrin_key_index[
        op_schedule_info.feature_tensor[stage_index][FeatureTensorCfg.compute_s]].intrin

    if intrin != 'dma_copy':
        return

    virtual_leaf_out = 'virtual_leaf_out' in stages_info[stage_index].get('type', [])
    fanin_stage_index = op_schedule_info.real_fanin_dict[stage_index][0]
    fanin_at_axis = None
    if op_schedule_info.axis_info_list[stage_index] \
            and op_schedule_info.at_dict.get(fanin_stage_index) == stage_index:
        fanin_at_axis = op_schedule_info.at_targets[fanin_stage_index]


    axis_num, dma_axis, dma_axis_obj = \
        _get_dma_axis(op_schedule_info.stage, op_schedule_info.axis_info_list[stage_index], stage_name, fanin_at_axis)

    # inter_out need reuse cache
    reuse, reuse_stage_index = \
        _get_reuse_info(op_schedule_info.real_fanin_dict[stage_index], virtual_leaf_out, stages_info)
    if reuse:
        _reuse_proc(op_schedule_info, reuse_stage_index, dma_axis_obj, axis_num, dma_axis)
        # reused cache read stage emit_insn 'phony_insn'
        op_schedule_info.code_lines.append("sch[{}].emit_insn({}, 'phony_insn')".format(stage_name, dma_axis))
        # gen cheque
        cheque = get_emit_insn_cheque(stage_index, 'phony_insn', (dma_axis, axis_num))
        op_schedule_info.cheque_list.append(cheque)
    elif virtual_leaf_out:
        # virtual_leaf_out emit_insn is phony_insn
        op_schedule_info.stage.emit_insn(dma_axis_obj, 'phony_insn')
        op_schedule_info.code_lines.append("sch[{}].emit_insn({}, 'phony_insn')".format(stage_name, dma_axis))
        # gen emit_insn cheque
        cheque = get_emit_insn_cheque(stage_index, 'phony_insn', (dma_axis, axis_num))
        op_schedule_info.cheque_list.append(cheque)
    else:
        # pure elemwise output dma_copy should set no_overlap=0
        is_align = progress.action_tensor[stage_index][0] % (
                    BLOCK_SIZE // DTYPE_BYTE_MAPPING.get(op_schedule_info.output_info_list[0].dtype)) == 0
        elementwise_dma_flag = op_schedule_info.op_pattern in [ComputePattern.ELEMENTWISE] \
                               and 'leaf' in stages_info[stage_index].get('type', []) \
                               and is_align
        norm_dma_flag = op_schedule_info.op_pattern in [ComputePattern.NORM] \
                        and ('leaf' in stages_info[stage_index].get('type', [])
                             or 'workspace' in stages_info[stage_index].get('type', []))
        if elementwise_dma_flag:
            _do_dma_copy_for_elementwise(op_schedule_info, axis_num, dma_axis, dma_axis_obj)
        elif norm_dma_flag:
            _do_dma_copy_for_norm(progress, axis_num, dma_axis, dma_axis_obj)
        else:
            op_schedule_info.stage.emit_insn(dma_axis_obj, "dma_copy")
            logger.debug("dma axis for %s: %s, axis_num:%s", op_schedule_info.stage.op.name, dma_axis, axis_num)
            op_schedule_info.code_lines.append("sch[{}].emit_insn({}, 'dma_copy')".format(stage_name, dma_axis))

            cheque = get_emit_insn_cheque(stage_index, 'dma_copy', (dma_axis, axis_num))
            op_schedule_info.cheque_list.append(cheque)

    op_schedule_info.proc_flag_dict[stage_index] = True
    return


def _get_dma_axis(stage, curr_axis_info_list, stage_name, fanin_at_axis=None):
    """
    :param stage:
    :param curr_axis_info_list:
    :param stage_name:
    :param fanin_at_axis:
    :return:
    """
    axis_name = None
    emit_insn_axis_obj = None
    # current stage is not split stage
    if curr_axis_info_list is None:
        axis_num = 0
        emit_insn_axis_obj = stage.op.axis[0]
        axis_name = "sch[{}].op.axis[{}]".format(stage_name, 0)
        return axis_num, axis_name, emit_insn_axis_obj

    if fanin_at_axis:
        for i, axis_info in enumerate(curr_axis_info_list):
            if fanin_at_axis.name != axis_info.name:
                continue
            axis_num = i + 1
            if axis_num < len(curr_axis_info_list):
                axis_name = curr_axis_info_list[axis_num].name
                emit_insn_axis_obj = curr_axis_info_list[axis_num].body
                return axis_num, axis_name, emit_insn_axis_obj

    # current stage is not split stage
    for i, axis_info in enumerate(curr_axis_info_list):
        axis_name = axis_info.name
        for axis_ends in ["_ii", "_i"]:
            if axis_name.endswith(axis_ends):
                emit_insn_axis_obj = curr_axis_info_list[i].body
                return i, axis_name, emit_insn_axis_obj

    logger.warn(
        "dma axis not found for stage_name:{}, curr_axis_info_list:{}!".format(stage_name, curr_axis_info_list))

    return 0, axis_name, emit_insn_axis_obj


def _reuse_proc(op_schedule_info, reuse_stage_index, dma_axis_obj, axis_num, dma_axis):
    """
    :param op_schedule_info:
    :param reuse_stage_index:
    :param dma_axis_obj:
    :param axis_num:
    :param dma_axis:
    :return:
    """
    # reuse_src_index is generated by reuse_stage_index cache_write
    reuse_src_index = reuse_stage_index - 1
    # dst_stage_index is generated by reuse_stage_index cache_read
    dst_stage_index = reuse_stage_index + 1
    reuse_src_name = op_schedule_info.stages_info[reuse_src_index]["name"]
    reuse_dst_name = op_schedule_info.stages_info[dst_stage_index]["name"]

    stages = op_schedule_info.schedule_obj.stages
    stages[reuse_src_index].reused_by(stages[dst_stage_index].origin_op.output(0))
    stages[dst_stage_index].reused_by(reuse_data=True)

    op_schedule_info.code_lines.append("sch[%s].reused_by(%s)" %
                                       (reuse_src_name, reuse_dst_name))
    op_schedule_info.code_lines.append("sch[%s].reused_by(reuse_data=True)" %
                                       reuse_dst_name)

    # gen cheque
    cheque = get_reuseby_cheque(reuse_src_index, dst_stage_index=dst_stage_index)
    op_schedule_info.cheque_list.append(cheque)
    cheque = get_reuseby_cheque(reuse_src_index, reuse_data=True)
    op_schedule_info.cheque_list.append(cheque)


def _get_reuse_info(fanin_stage_indices, virtual_leaf_out, stages_info):
    """
    judge current stage need reuse or not, return stage index
    :param fanin_stage_indices:
    :param virtual_leaf_out:
    :param stages_info:
    :return:
    """
    reuse = False
    reuse_stage_index = None
    # virtual_leaf_out need not do reuse
    if virtual_leaf_out:
        return reuse, reuse_stage_index
    for fanin_stage_index in fanin_stage_indices:
        fanin_stage_types = stages_info[fanin_stage_index].get('type', [])
        # inter_out stage need reuse
        if 'inter_out' in fanin_stage_types:
            reuse = True
            reuse_stage_index = fanin_stage_index
            break
    return reuse, reuse_stage_index


def _do_dma_copy_for_elementwise(op_schedule_info, axis_num, dma_axis, dma_axis_obj):
    """
    :param op_schedule_info:
    :param axis_num:
    :param dma_axis:
    :param dma_axis_obj:
    :return:
    """
    stage_index = op_schedule_info.stage_index
    stage = op_schedule_info.stage
    stage_name = op_schedule_info.stages_info[stage_index]['name']
    attrs = {'no_overlap': 0}
    attrs_str = str(attrs)
    extra_info = attrs
    stage.emit_insn(dma_axis_obj, "dma_copy", attrs=attrs)
    logger.debug("dma axis for %s: %s, axis_num:%s", stage.op.name, dma_axis, axis_num)
    op_schedule_info.code_lines.append(
        "sch[{}].emit_insn({}, 'dma_copy', attrs={})".format(stage_name, dma_axis, attrs_str))
    # gen emit_insn cheque
    cheque = get_emit_insn_cheque(stage_index, 'dma_copy', (dma_axis, axis_num), extra_info=extra_info)
    op_schedule_info.cheque_list.append(cheque)


def _do_dma_copy_for_norm(progress, axis_num, dma_axis, dma_axis_obj):
    """
    :param progress:
    :param axis_num:
    :param dma_axis:
    :param dma_axis_obj:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_index = op_schedule_info.stage_index
    stage = op_schedule_info.stage
    stage_name = op_schedule_info.stages_info[stage_index]['name']
    split_factor_list = progress.action_tensor[stage_index]
    dtype_byte = DTYPE_BYTE_MAPPING.get(op_schedule_info.output_info_list[0].dtype)

    for reduce_idx in op_schedule_info.reduce_axis_dict:
        reduce_type = op_schedule_info.reduce_axis_dict[reduce_idx].get('type')
        break

    tensor_shape = util.shape_to_list(stage.op.output(0).shape)
    is_align = tensor_shape[-1] % (BLOCK_SIZE // dtype_byte) == 0

    attrs = {'no_overlap': 3}
    if reduce_type == 'nist' and split_factor_list[len(tensor_shape) - 1] != tensor_shape[-1]:
        attrs = {}
    elif reduce_type == 'nist' and is_align:
        attrs = {'no_overlap': 0}

    stage.emit_insn(dma_axis_obj, "dma_copy", attrs=attrs)
    logger.debug("pragma axis for %s: %s, axis_num:%s", stage.op.name, dma_axis, axis_num)

    op_schedule_info.code_lines.append(
        "sch[{}].emit_insn({}, 'dma_copy', attrs={})".format(stage_name, dma_axis, str(attrs)))
    cheque = get_emit_insn_cheque(stage_index, 'dma_copy', (dma_axis, axis_num), extra_info=attrs)
    op_schedule_info.cheque_list.append(cheque)
