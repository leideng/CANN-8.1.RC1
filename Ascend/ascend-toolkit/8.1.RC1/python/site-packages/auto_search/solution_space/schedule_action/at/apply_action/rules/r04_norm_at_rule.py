#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
norm compute at
"""
from typing import Dict
from typing import NoReturn

from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.tensor_cfg import INVALID_AT_AXIS
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.op_schedule_info import OpScheduleInfo
from auto_search.solution_space.schedule_action.at.apply_action.rules.comm import get_my_at_target
from auto_search.solution_space.schedule_action.at.apply_action.rules.comm import get_at_choices_for_norm_split_reduce
from auto_search.solution_space.schedule_action.at.apply_action.rules.comm import get_at_choices_from_axis_info
from auto_search.solution_space.schedule_action.at.apply_action.rules.comm import ensure_at
from auto_search.solution_space.schedule_action.at.apply_action.rules.comm import get_depend_child_stages


def _split_reduce_stage(op_schedule_info: OpScheduleInfo) -> bool:
    """

    :param op_schedule_info:
    :return:
    """
    split_reduce_stage = False
    for reduce_stage_idx in op_schedule_info.reduce_axis_dict:
        if 'reduce_rfactor' in op_schedule_info.stages_info[reduce_stage_idx].get("type", []):
            continue
        if op_schedule_info.axis_info_list[reduce_stage_idx]:
            split_reduce_stage = True
    return split_reduce_stage


def _get_after_reduce_tensor_at_index(my_at_choices: list, at_choice_index: int, reduce_axis: list) -> int:
    """

    :param my_at_choices:
    :param at_choice_index:
    :param reduce_axis:
    :return:
    """
    at_reduce_flag = True
    while at_reduce_flag:
        at_axis_idx = my_at_choices[at_choice_index][0].index
        if at_axis_idx in reduce_axis:
            at_choice_index = at_choice_index - 1
            if at_choice_index == -1:
                break
        else:
            at_reduce_flag = False
    return at_choice_index


def update_at_choice_index(progress, stage_index, at_targets, at_choice_index, my_at_choices):
    """
    :param progress:
    :param stage_index:
    :param at_targets:
    :param at_choice_index:
    :param my_at_choices:
    :return:
    """
    depended_stages = get_depend_child_stages(progress.op_schedule_info, stage_index)
    for depended_stage in depended_stages:
        for at_choice in range(at_choice_index, -1, -1):
            if at_targets[depended_stage] in my_at_choices[at_choice]:
                at_choice_index = at_choice
                break
    return at_choice_index



def _ensure_at_axis(progress: Progress, reversed_stages: object, at_dict: Dict, at_targets: object) -> NoReturn:
    """

    :param progress:
    :param reversed_stages:
    :param at_dict:
    :param at_targets:
    :param special_stages:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_num = len(reversed_stages)
    norm_graph_info = op_schedule_info.compute_graph_info
    for reverse_index in range(stage_num):
        stage_index = stage_num - reverse_index - 1

        if progress.action_tensor[stage_index][ActionTensorCfg.at_s] == INVALID_AT_AXIS:
            at_targets[stage_index] = None
            continue

        at_stage_index = at_dict[stage_index]
        my_at_choices = get_at_choices_from_axis_info(
            op_schedule_info.axis_info_list[at_stage_index])
        if _split_reduce_stage(op_schedule_info):
            my_at_choices = get_at_choices_for_norm_split_reduce(
                op_schedule_info.axis_info_list[at_stage_index])

        at_choice_index = len(my_at_choices) - 1

        for reduce_stage in op_schedule_info.reduce_axis_dict:
            reduce_axis = op_schedule_info.reduce_axis_dict[reduce_stage].get("axis")
            break

        # after reduce tensor compute at common axis
        src_index = op_schedule_info.stages_info[stage_index]['at_info'].index
        if src_index in norm_graph_info.after_reduce_tensor_indxe_list:
            at_choice_index = _get_after_reduce_tensor_at_index(my_at_choices, at_choice_index, reduce_axis)

        # workspace tensor or reduce fork tensorï¼Œ compute at to block axis
        if 'workspace' in op_schedule_info.stages_info[stage_index].get('type', []) or \
                src_index in norm_graph_info.reduce_fork_tensor_index_list:
            at_choice_index = 0
            if my_at_choices[at_choice_index][0].index in reduce_axis:
                at_choice_index = -1

        if at_choice_index == -1:
            at_targets[stage_index] = None
            continue

        at_choice_index = update_at_choice_index(progress, stage_index, at_targets, at_choice_index, my_at_choices)

        at_targets[stage_index] = get_my_at_target(my_at_choices[at_choice_index])


def proc(progress: Progress) -> bool:
    """
    norm op at rule
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info

    features = op_schedule_info.feature_tensor
    at_dict = op_schedule_info.at_dict
    stage_num = len(features)
    at_choices = []
    for _ in range(stage_num):
        at_choices.append([])

    at_targets = [None] * stage_num
    reversed_stages = list(op_schedule_info.schedule_obj.stages)
    reversed_stages.reverse()

    ensure_at(progress, reversed_stages, at_dict, at_targets)

    _ensure_at_axis(progress, reversed_stages, at_dict, at_targets)

    op_schedule_info.at_targets = at_targets
    return True
