#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
comm
"""
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.tensor_cfg import INVALID_AT_AXIS


def get_depend_child_stages(op_schedule_info, stage_index):
    """
    get depend child stages
    :param op_schedule_info:
    :param stage_index:
    :return:
    """
    final_child_stages = []
    tmp_child_stages = op_schedule_info.real_fanout_dict[
        stage_index]

    at_stage_index = op_schedule_info.at_dict[stage_index]
    while True:
        cur_child_stages = []
        for child_stage in tmp_child_stages:
            child_at_stage = op_schedule_info.at_dict.get(
                child_stage)
            if child_at_stage == at_stage_index:
                final_child_stages.append(child_stage)
            elif child_stage != at_stage_index:
                cur_child_stages.extend(
                    op_schedule_info.real_fanout_dict[child_stage])

        if not cur_child_stages:
            break
        tmp_child_stages = cur_child_stages[:]

    return final_child_stages


def get_my_at_target(my_at_choices):
    """

    :param my_at_choices:
    :return:
    """
    origin_at_axis = None
    for at_choice in my_at_choices:
        origin_at_axis = at_choice

    return origin_at_axis


def _get_at_choices_from_at_axis_infos(at_axis_infos):
    """

    :param at_axis_infos:
    :return:
    """
    index_list = []
    for axis_info in at_axis_infos:
        if axis_info.index not in index_list:
            index_list.append(axis_info.index)

    at_choices = []
    for _ in range(len(index_list)):
        at_choices.append([])

    for axis_info in at_axis_infos:
        pos = index_list.index(axis_info.index)
        at_choices[pos].append(axis_info)

    return at_choices


def get_at_choices_from_axis_info(axis_infos):
    """

    :param axis_infos:
    :return:
    """
    at_axis_infos = [axis for axis in axis_infos if axis.name.endswith('o')]

    return _get_at_choices_from_at_axis_infos(at_axis_infos)


def get_at_choices_for_norm_split_reduce(axis_infos):
    """

    :param axis_infos:
    :return:
    """
    at_axis_infos = []
    for axis in axis_infos:
        if axis.name.endswith('o'):
            at_axis_infos.append(axis)
        if axis.attr == 'ub_out_axis':
            at_axis_infos.append(axis)

    return _get_at_choices_from_at_axis_infos(at_axis_infos)


def get_at_axis(stage_index, op_schedule_info):
    """
    get at axis
    :param stage_index:
    :param op_schedule_info:
    :return:
    """
    at_dict = op_schedule_info.at_dict
    at_index = at_dict[stage_index]

    ori_cut_index = op_schedule_info.cut_axis_index[at_index]

    return ori_cut_index


def clean_align_at(stage_index, clean_at, progress):
    """
    the axis of stage at do not larger than the axis of fanouts at
    """
    op_schedule_info = progress.op_schedule_info
    at_stage_index = op_schedule_info.at_dict[stage_index]
    my_at_choices = get_at_choices_from_axis_info(
        op_schedule_info.axis_info_list[at_stage_index])

    if clean_at >= len(my_at_choices):
        clean_at = len(my_at_choices) - 1

    # get followed stage when same stage at
    if op_schedule_info.option.get("at_align", True):
        depend_stages = get_depend_child_stages(op_schedule_info, stage_index)
        for child_index in depend_stages:
            if clean_at > progress.action_tensor[child_index][
                    ActionTensorCfg.at_s]:
                clean_at = progress.action_tensor[child_index][
                    ActionTensorCfg.at_s]

    return clean_at


def ensure_at(progress, reversed_stages, at_dict, at_targets):
    """

    :param progress:
    :param reversed_stages:
    :param at_dict:
    :param at_targets:
    :return:
    """
    stage_num = len(reversed_stages)
    for reverse_index, stage in enumerate(reversed_stages):
        stage_index = stage_num - reverse_index - 1
        if str(stage.op).startswith("placeholder"):
            progress.action_tensor[stage_index][ActionTensorCfg.at_s] = \
                INVALID_AT_AXIS
            continue

        at_stage_index = at_dict.get(stage_index)
        if at_stage_index is None:
            progress.action_tensor[stage_index][ActionTensorCfg.at_s] = \
                INVALID_AT_AXIS
            continue

        at_axis = get_at_axis(stage_index, progress.op_schedule_info)

        clean_at = clean_align_at(stage_index, at_axis, progress)
        progress.action_tensor[stage_index][
            ActionTensorCfg.at_s] = clean_at

        at_targets[stage_index] = clean_at


def get_max_offset(progress, my_at_choices, at_choice_index, at_targets, stage_index):
    """
    get max_offset
    :param progress:
    :param my_at_choices:
    :param at_choice_index:
    :param at_targets:
    :param stage_index:
    :return:
    """
    depended_stages = get_depend_child_stages(progress.op_schedule_info, stage_index)
    max_offset = len(my_at_choices[at_choice_index]) - 1
    for depended_stage in depended_stages:
        depend_at_index = progress.action_tensor[depended_stage][
            ActionTensorCfg.at_s]
        if depend_at_index == -1:
            depend_at_index = 0

        if depend_at_index != at_choice_index:
            continue

        at_offset = my_at_choices[at_choice_index].index(
            at_targets[depended_stage])
        if at_offset < max_offset:
            max_offset = at_offset

    return max_offset
