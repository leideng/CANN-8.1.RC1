#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
auto schedule
"""
import math

from typing import NoReturn
from typing import List
from typing import Tuple
from dataclasses import make_dataclass

from auto_search.utils import logger
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.bank.cheque_generator import get_axis_cheque
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.bank.cheque_generator import get_split_cheque
from auto_search.bank.cheque_generator import get_axis_index
from auto_search.solution_space import t2c_util
from auto_search.solution_space.op_schedule_info import OpScheduleInfo
from auto_search.solution_space.schedule_action.split.apply_action.split_a_stage import set_ub_split_info

SplitStageParam = make_dataclass("SplitStageParam",
                                 ["code_lines", "stage_axis_info", "stage_axis_obj",
                                  "split_vector", "stage", "stage_index", "stage_name",
                                  "multi_cut_axis_indexes", "last_cut_axis_index"])
SplitAxisParam = make_dataclass("SplitAxisParam", ["factor", "axis", "axis_index", "axis_name", "axis_len"])


def split_axis_once_proc(op_schedule_info: OpScheduleInfo, split_stage_param: SplitStageParam,
                         split_axis_param: SplitAxisParam) -> NoReturn:
    """
    :param op_schedule_info:
    :param split_stage_param:
    :param split_axis_param:
    :return:
    """
    factor = split_axis_param.factor
    op_schedule_info.ub_factor = factor
    axis_name = split_axis_param.axis_name
    axis = split_axis_param.axis
    axis_index = split_axis_param.axis_index
    axis_len = split_axis_param.axis_len

    stage_axis_info = split_stage_param.stage_axis_info
    stage = split_stage_param.stage
    stage_index = split_stage_param.stage_index
    stage_name = split_stage_param.stage_name

    split_stage_param.code_lines.append(
        '%s_o, %s_i = sch[%s].split(sch[%s].op.axis[%d],'
        ' factor=%d)' %
        (axis_name, axis_name, stage_name, stage_name,
         axis_index, factor))

    logger.debug('stage %s axis %s factor: %d', stage, axis, factor)
    axis_obj_o, axis_obj_i = stage.split(axis, factor=factor)

    # save outer_axis
    axis_o_len = math.floor((axis_len + factor - 1) / factor)
    stage_axis_info.append(AxisInfo(axis_name + '_o', axis_o_len, 'axis', axis_index, 'o', axis_obj_o))
    # save inner_axis
    stage_axis_info.append(AxisInfo(axis_name + '_i', factor, 'axis', axis_index, 'i', axis_obj_i))

    ori_order_axis = t2c_util.get_ori_order(stage_axis_info)
    splited_axis_index = get_axis_index(ori_order_axis, axis_name + '_o')
    cheque = get_split_cheque(stage_index, splited_axis_index, factor)
    op_schedule_info.cheque_list.append(cheque)

    dynamic_flag = op_schedule_info.option.get('op_config').get('op_mode', '') in ['dynamic']
    if dynamic_flag:
        set_ub_split_info(op_schedule_info, split_stage_param, split_axis_param)
    return


def append_axis_proc_info_for_no_cut(split_stage_param, split_axis_param, axis_attr):
    """
    :param split_stage_param:
    :param split_axis_param:
    :param axis_attr:
    :return:
    """
    stage_name = split_stage_param.stage_name
    axis_name = split_axis_param.axis_name
    axis_index = split_axis_param.axis_index
    axis_len = split_axis_param.axis_len
    axis = split_axis_param.axis
    split_stage_param.code_lines.append(f'{axis_name} = sch[{stage_name}].op.axis[{axis_index}]')

    split_stage_param.stage_axis_info.append(
        AxisInfo(axis_name, axis_len, 'axis', axis_index, axis_attr, axis))


def split_axis_proc(op_schedule_info: OpScheduleInfo, split_stage_param: SplitStageParam,
                    split_axis_param: SplitAxisParam) -> NoReturn:
    """
    :param op_schedule_info:
    :param split_stage_param:
    :param split_axis_param:
    :return:
    """
    if split_axis_param.axis_index in split_stage_param.multi_cut_axis_indexes:
        split_axis_once_proc(op_schedule_info, split_stage_param, split_axis_param)
        return

    if split_axis_param.axis_index < split_stage_param.last_cut_axis_index:
        append_axis_proc_info_for_no_cut(split_stage_param, split_axis_param, "ub_out_axis")
        return

    if split_axis_param.axis_index > split_stage_param.last_cut_axis_index:
        append_axis_proc_info_for_no_cut(split_stage_param, split_axis_param, "ub_in_axis")
        return


def split_axis(op_schedule_info: OpScheduleInfo, split_stage_param: SplitStageParam) -> int:
    """
    split_axis
    :param op_schedule_info:
    :param split_stage_param
    :return:
    """
    # get axis index
    for index, factor in enumerate(split_stage_param.split_vector):
        if factor != 0:
            split_stage_param.multi_cut_axis_indexes.append(index)

    split_stage_param.last_cut_axis_index = split_stage_param.multi_cut_axis_indexes[-1]

    for axis_index, axis in enumerate(split_stage_param.stage_axis_obj):
        factor = split_stage_param.split_vector[axis_index]
        axis_len = axis.dom.extent.value
        axis_name = '%s_axis_%d' % (split_stage_param.stage_name, axis_index)
        split_axis_param = SplitAxisParam(factor, axis, axis_index, axis_name, axis_len)
        split_axis_proc(op_schedule_info, split_stage_param, split_axis_param)

    return split_stage_param.last_cut_axis_index


def split_a_stage_for_transpose(progress: Progress, stage_index: int) -> Tuple[List, List, int]:
    """
    split_a_stage
    :param progress:
    :param stage_index:
    :return:
    """
    code_lines = []
    stage_axis_info = []
    op_schedule_info = progress.op_schedule_info
    stage = op_schedule_info.schedule_obj.stages[stage_index]
    stage_axis_obj = stage.op.axis
    split_vector = progress.action_tensor[stage_index][
                   ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    stages_info = op_schedule_info.stages_info
    stage_info = stages_info[stage_index]

    # manual_debug split_factor
    debug_params = op_schedule_info.option.get("trs_debug", [False, {}])
    if debug_params[0]:
        split_vector = debug_params[1]["split_vector"]
    # record split info
    if "split_factor_info" not in stages_info[-1].keys():
        stages_info[-1].setdefault('split_factor_info', {})
    stages_info[-1]["split_factor_info"] = split_vector

    multi_cut_axis_indexes = []
    last_cut_axis_index = 0

    split_vector_info = f'# split factor info: {list(split_vector)}'
    code_lines.append(split_vector_info)

    axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[stage_index], stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)

    split_stage_param = SplitStageParam(code_lines, stage_axis_info, stage_axis_obj, split_vector, stage, stage_index,
                                        stage_info['name'], multi_cut_axis_indexes, last_cut_axis_index)

    split_axis(op_schedule_info, split_stage_param)

    return split_stage_param.code_lines, split_stage_param.stage_axis_info, split_stage_param.last_cut_axis_index
