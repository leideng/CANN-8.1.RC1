#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from typing import List
from typing import NoReturn

from auto_search.utils import logger
from auto_search.bank.cheque_generator import get_pragma_cheque
from auto_search.solution_space.t2c_util import MODE_RUNTIME
from auto_search.compute_analysis.reduce_compute_graph import StageOrderedAxes
from auto_search.compute_analysis.reduce_compute_graph import Dim
from auto_search.solution_space.action import apply_action_register
from auto_search.solution_space.action import ScheduleActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.op_schedule_info import OpScheduleInfo

A = "A"
R = "R"


def get_serial_group(op_schedule_info: OpScheduleInfo, reduce_stage_index: int) -> List:
    """
    :param op_schedule_info:
    :param reduce_stage_index:
    :return:
    """
    ordered_axis_obj: StageOrderedAxes = op_schedule_info.stages_info[reduce_stage_index].get('stage_ordered_axes_obj')
    if ordered_axis_obj is None:
        raise RuntimeError("reduce stage info must have stage_ordered_axes_obj!")

    # create virtual mapping
    _shape = [Dim(R, _idx) if _idx in ordered_axis_obj.get_reduce_axes() else Dim(A, _idx)
              for _idx in range(len(ordered_axis_obj.get_origin_axis_dim()))]

    # split, stay the same  with handle writing template
    blk_split_idx = op_schedule_info.cut_axis_index[len(op_schedule_info.schedule_obj.stages) - 1]
    ub_split_idx = op_schedule_info.cut_axis_index[reduce_stage_index]
    if blk_split_idx <= ub_split_idx:
        Dim.split(_shape, blk_split_idx)
        ub_split_idx += 1
        Dim.split(_shape, ub_split_idx, model="UBSplit")
    else:
        Dim.split(_shape, ub_split_idx, model="UBSplit")
        blk_split_idx += 1
        Dim.split(_shape, blk_split_idx, )

    # reorder
    _a_shape, _r_shape = [], []
    for item in _shape:
        if item.axis_type == A:
            _a_shape.append(item)
        else:
            _r_shape.append(item)
    target_shape = _a_shape + _r_shape
    if not ordered_axis_obj.is_reduce_last():
        _r_shape.append(_a_shape.pop(-1))
        target_shape = _a_shape + _r_shape

    # find serial axis
    idx_ub_outer = target_shape.index(_shape[ub_split_idx])
    axis_in_ub = target_shape[idx_ub_outer + 1:]
    axis_in_ub.sort(key=lambda x: x.idx, reverse=True)
    serial_group = Dim.group([x.idx for x in axis_in_ub])
    serial_group.sort(key=lambda x: x[1] - x[0], reverse=True)

    return serial_group


def _get_reduce_stage_index(op_schedule_info: OpScheduleInfo) -> int:
    """
    :param op_schedule_info:
    :return:
    """
    reduce_stage_index = None
    for stage_index in range(len(op_schedule_info.schedule_obj.stages)):
        stage_type = op_schedule_info.stages_info[stage_index].get('type', [])
        if "CacheWrite" in stage_type and "reduce" in stage_type:
            reduce_stage_index = stage_index
            break
    return reduce_stage_index


def _do_pragma_for_axis(progress: Progress, stage_index: int, axis_name: str, axis_idx: int,
                        code_lines: List) -> NoReturn:
    """
    :param progress:
    :param stage_index:
    :param axis_name:
    :param axis_idx:
    :param code_lines:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_name = op_schedule_info.stages_info[stage_index].get('name', [])
    stage = op_schedule_info.schedule_obj.stages[stage_index]
    code_line = f'sch[{stage_name}].pragma({axis_name}, \'axis_group\', 0)'
    code_lines.append(code_line)

    # do pragma
    if op_schedule_info.mode == MODE_RUNTIME:
        stage.pragma(stage.leaf_iter_vars[axis_idx], "axis_group", 0)

    # generate cheque
    cheque = get_pragma_cheque(stage_index, "axis_group", (axis_name, axis_idx), 0)
    op_schedule_info.cheque_list.append(cheque)


def _find_ub_split_inner_axis(progress: Progress, reduce_stage_index: int) -> tuple:
    """
    :param progress:
    :param reduce_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    reduce_stage_axis_info = op_schedule_info.axis_info_list[reduce_stage_index]
    ub_split_axis_inner_index = None
    ub_split_axis_inner_info = None
    for axis_index, axis_info in enumerate(reduce_stage_axis_info):
        if axis_info.name.endswith('i'):
            ub_split_axis_inner_index = axis_index
            ub_split_axis_inner_info = axis_info
            break

    return ub_split_axis_inner_index, ub_split_axis_inner_info


def _check_stage_is_need_pragma(op_schedule_info: OpScheduleInfo, stage_index: int) -> bool:
    """
    :param op_schedule_info:
    :param stage_index:
    :return:
    """
    stages_info = op_schedule_info.stages_info
    if stage_index in op_schedule_info.inlined_stages:
        return False

    stage = op_schedule_info.schedule_obj.stages[stage_index]
    # placeholder not do 'axis_group' pragma
    if (str(stage.op).startswith("placeholder")) or \
            'placeholder' in stages_info[stage_index].get('type', []):
        return False

    if 'align_pad' in stages_info[stage_index].get('type', []):
        return False

    return True


def do_pragma(progress: Progress, pragma_stage_index_list: List, serial_group: List,
              reduce_stage_index: int) -> bool:
    """
    :param progress:
    :param pragma_stage_index_list:
    :param serial_group:
    :param reduce_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = ['\n', '# proc_pragma']
    stages_info = op_schedule_info.stages_info
    reduce_stage_info = stages_info[reduce_stage_index]
    ordered_axis_obj: StageOrderedAxes = reduce_stage_info.get('stage_ordered_axes_obj')
    if ordered_axis_obj is None:
        logger.error("reduce stage info must have stage_ordered_axes_obj!")
        return False

    for stage_index in pragma_stage_index_list:
        stage = op_schedule_info.schedule_obj.stages[stage_index]

        if not _check_stage_is_need_pragma(op_schedule_info, stage_index):
            continue

        if stage.op.tag != "":
            # For ub tensor(not dma tensor)
            do_pragma_for_not_dma_tensor(progress, code_lines, stage_index, reduce_stage_index)
        else:
            # For dma tensor
            do_pragma_for_dma_tensor(progress, code_lines, serial_group, stage_index, reduce_stage_index)

    # For reduce tensor
    do_pragma_for_reduce_tensor(progress, code_lines, reduce_stage_index)

    op_schedule_info.code_lines.extend(code_lines)
    return True


def do_pragma_for_reduce_tensor(progress: Progress, code_lines: List, reduce_stage_index: int) -> NoReturn:
    """
    :param progress:
    :param code_lines:
    :param reduce_stage_index:
    :return:
    """
    reduce_cut_axis = progress.op_schedule_info.cut_axis_index[reduce_stage_index]
    stages_info = progress.op_schedule_info.stages_info
    reduce_stage_info = stages_info[reduce_stage_index]
    ordered_axis_obj: StageOrderedAxes = reduce_stage_info.get('stage_ordered_axes_obj')
    ub_tiling_on_reduce_axis = reduce_cut_axis in ordered_axis_obj.get_reduce_axes()
    # ub_tiling_axis inner needs to be in the axis_group if it is reduce axis
    ub_split_axis_inner_index, ub_split_axis_inner_info = _find_ub_split_inner_axis(progress, reduce_stage_index)
    if ub_split_axis_inner_info is None:
        raise RuntimeError("reduce stage has no split axis info!")
    if ub_tiling_on_reduce_axis:
        axis_name = ub_split_axis_inner_info.name
        _do_pragma_for_axis(progress, reduce_stage_index, axis_name, ub_split_axis_inner_index, code_lines)
    for index, axis_info in \
            enumerate(progress.op_schedule_info.axis_info_list[reduce_stage_index][ub_split_axis_inner_index + 1:]):
        if axis_info.type == "reduce_axis":
            axis_name = axis_info.name
            axis_index = ub_split_axis_inner_index + 1 + index
            _do_pragma_for_axis(progress, reduce_stage_index, axis_name, axis_index, code_lines)


def do_pragma_for_dma_tensor(progress: Progress, code_lines: List, serial_group: List, stage_index: int,
                             reduce_stage_index: int) -> NoReturn:
    """
    :param progress:
    :param code_lines:
    :param serial_group:
    :param stage_index:
    :param reduce_stage_index:
    :return:
    """
    reduce_cut_axis = progress.op_schedule_info.cut_axis_index[reduce_stage_index]
    reduce_stage_info = progress.op_schedule_info.stages_info[reduce_stage_index]
    ordered_axis_obj: StageOrderedAxes = reduce_stage_info.get('stage_ordered_axes_obj')
    shape_before_reduce = ordered_axis_obj.get_origin_axis_dim()
    stage_name = progress.op_schedule_info.stages_info[stage_index].get('name', [])
    extend = serial_group[0][1] - serial_group[0][0] + 1
    length = len(shape_before_reduce)
    axis_range = \
        range(length - 1, length - 1 - extend, -1) if extend != 1 else range(length - 1, length - 3, -1)
    for axis_idx in range(reduce_cut_axis, len(shape_before_reduce)):
        if axis_idx in axis_range:
            axis_name = f'sch[{stage_name}].op.axis[{axis_idx}]'
            _do_pragma_for_axis(progress, stage_index, axis_name, axis_idx, code_lines)


def do_pragma_for_not_dma_tensor(progress: Progress, code_lines: List, stage_index: int,
                                 reduce_stage_index: int) -> NoReturn:
    """
    :param progress:
    :param code_lines:
    :param stage_index:
    :param reduce_stage_index:
    :return:
    """
    reduce_cut_axis = progress.op_schedule_info.cut_axis_index[reduce_stage_index]
    stages_info = progress.op_schedule_info.stages_info
    reduce_stage_info = stages_info[reduce_stage_index]
    ordered_axis_obj: StageOrderedAxes = reduce_stage_info.get('stage_ordered_axes_obj')
    ub_tiling_on_reduce_axis = reduce_cut_axis in ordered_axis_obj.get_reduce_axes()
    shape_before_reduce = ordered_axis_obj.get_origin_axis_dim()
    stage_name = stages_info[stage_index].get('name', [])
    # Iterate all axis after ub_tiling_axis and check if they need to be in the axis_group
    for axis_idx in range(reduce_cut_axis, len(shape_before_reduce) - 1):
        if axis_idx in ordered_axis_obj.get_reduce_axes() or not ub_tiling_on_reduce_axis:
            axis_name = f'sch[{stage_name}].op.axis[{axis_idx}]'
            _do_pragma_for_axis(progress, stage_index, axis_name, axis_idx, code_lines)
    # last axis must be added to axis_group
    last_axis_idx = len(shape_before_reduce) - 1
    axis_name = f'sch[{stage_name}].op.axis[{last_axis_idx}]'
    _do_pragma_for_axis(progress, stage_index, axis_name, last_axis_idx, code_lines)


@apply_action_register([ComputePattern.REDUCE], ScheduleActionType.PRAGMA)
def apply(progress: Progress) -> bool:
    """
    serial group axes do pragma:
    1. if have done rfactor, no need do pragma
    2. if reduce stage is not been split, no need do pragma
    3. the stages before reduce stage and reduce stage itself, need do pragma exclude placeholder
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    # 1.if have done rfactor, no need pragma
    ub_split_last_reduce_axis = op_schedule_info.last_reduce_and_ub_split_last_reduce_axis
    ub_split_nlast_reduce_axis = op_schedule_info.last_reduce_and_ub_split_nlast_reduce_axis
    if ub_split_last_reduce_axis or ub_split_nlast_reduce_axis:
        return True

    reduce_stage_index = _get_reduce_stage_index(op_schedule_info)

    if reduce_stage_index is None:
        return True
    # if reduce stage is not been split, no need do pragma
    if op_schedule_info.axis_info_list[reduce_stage_index] is None:
        return True
    # get serial group axis
    serial_group = get_serial_group(op_schedule_info, reduce_stage_index)
    need_pragma_stage_index_list = list(set(op_schedule_info.all_fanin_dict[reduce_stage_index]))
    ret = do_pragma(progress, need_pragma_stage_index_list, serial_group, reduce_stage_index)

    logger.debug('apply pragma done.')
    return ret
