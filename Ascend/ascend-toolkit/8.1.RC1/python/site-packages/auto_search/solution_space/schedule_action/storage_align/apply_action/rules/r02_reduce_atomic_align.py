#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reduce atomic storage align
"""
from typing import NoReturn
from typing import List

from tbe.tvm import Stage

from auto_search.utils import util
from auto_search.utils import logger
from auto_search.bank.cheque_generator import get_storage_align_cheque_enhance
from auto_search.bank.cheque_generator import get_storage_align_cheque
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.schedule_action.storage_align.apply_action.rules.r01_reduce_normal_align import \
    need_align_stage_proc


def get_align_axis(progress: Progress,  stage: Stage, align_stage_index: int) -> tuple:
    """
    get leaf_iter_vars -2 axis
    :param progress:
    :param stage:
    :param align_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_name = op_schedule_info.stages_info[align_stage_index]["name"]
    align_axis = None
    align_axis_index = None
    align_axis_name = None
    if len(stage.leaf_iter_vars) <= 1:
        logger.info("current stage axis len is small than 1, no need storage align!")
        return align_axis_name, align_axis_index, align_axis
    align_axis = stage.leaf_iter_vars[-2]
    # reduce_axis not become align axis
    for update_align_axis in list(reversed(list(stage.leaf_iter_vars)[:-1])):
        # reduce_axis iter_type is 2, axis iter_type is 0
        if update_align_axis.iter_type == 2:
            continue
        align_axis = update_align_axis
        break
    if op_schedule_info.axis_info_list[align_stage_index] is None or \
            op_schedule_info.axis_info_list[align_stage_index] == []:
        for axis_index, op_axis in enumerate(stage.op.axis):
            if op_axis == align_axis:
                align_axis_index = axis_index
                break
        if align_axis_index is None:
            raise RuntimeError("current stage cant find align axis!")
        align_axis_name = f'sch[{stage_name}].op.axis[{align_axis_index}]'
        return align_axis_name, align_axis_index, align_axis

    for axis_index, axis_info in enumerate(op_schedule_info.axis_info_list[align_stage_index]):
        if axis_info.body == align_axis:
            align_axis_name = axis_info.name
            align_axis_index = axis_index
            break
    if align_axis_index is None:
        raise RuntimeError("current stage can't find align axis!")
    return align_axis_name, align_axis_index, align_axis


def do_storage_align(progress: Progress, need_align_stage_index_list: List[int]) -> NoReturn:
    """
    :param progress:
    :param need_align_stage_index_list:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = []
    code_lines.extend(['\n', '# storage_align code begin'])
    for align_stage_index in need_align_stage_index_list:
        stage = op_schedule_info.schedule_obj.stages[align_stage_index]
        stage_name = op_schedule_info.stages_info[align_stage_index]["name"]
        vector_block_num = util.get_block_num(stage.op.output(0).dtype)
        align_axis_name, align_axis_index, align_axis = get_align_axis(progress, stage, align_stage_index)
        align_code = f'sch[{stage_name}].storage_align({align_axis_name}, {vector_block_num}, 0)'
        code_lines.append(align_code)
        stage.storage_align(align_axis, vector_block_num, 0)
        if "[" in align_axis_name and "]" in align_axis_name:
            cheque = get_storage_align_cheque(align_stage_index, align_axis_index, vector_block_num)
        else:
            cheque = get_storage_align_cheque_enhance(align_stage_index, (align_axis_name, align_axis_index),
                                                      vector_block_num)
        op_schedule_info.cheque_list.append(cheque)
        op_schedule_info.storage_align_para[align_stage_index] = vector_block_num
    op_schedule_info.code_lines.extend(code_lines)


def _is_need_storage_align(progress: Progress, reduce_atomic_rfactor_stage_index: int) -> bool:
    """
    :param progress:
    :param reduce_atomic_rfactor_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    reduce_compute_graph = op_schedule_info.compute_graph_info
    ub_split_info = op_schedule_info.atomic_ub_split_info
    ub_split_axis_type = op_schedule_info.stages_info[reduce_atomic_rfactor_stage_index].get('split_axis_type', None)
    if ub_split_axis_type is None:
        logger.error("ub_split_axis_type should not be None!")
    nlast_and_ub_split_last_a_axis = not reduce_compute_graph.is_last_reduce \
                                     and ub_split_axis_type == 'axis' \
                                     and ub_split_info.axis_index == len(reduce_compute_graph.normal_axes_index) - 1
    last_and_ub_split_last_r_axis = reduce_compute_graph.is_last_reduce \
                                    and ub_split_axis_type == 'reduce_axis' \
                                    and ub_split_info.axis_index == len(reduce_compute_graph.reduce_axes_index) - 1
    if nlast_and_ub_split_last_a_axis or last_and_ub_split_last_r_axis:
        return False

    return True


def proc(progress: Progress) -> bool:
    """
    the stages before reduce rf need do storage_align, align axis is leaf_iter_vars[-2]
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info

    atomic_stage_index = None
    for stage_index, _ in enumerate(op_schedule_info.schedule_obj.stages):
        stage_type = op_schedule_info.stages_info[stage_index].get('type', [])
        if "reduce_atomic_rfactor" in stage_type:
            atomic_stage_index = stage_index
            break

    if atomic_stage_index is None:
        logger.error("atomic_stage_index should not be None!")
        return False

    if not _is_need_storage_align(progress, atomic_stage_index):
        logger.debug("not need storage align!")
        return True

    need_align_stage_index_list = list(set(op_schedule_info.all_fanin_dict[atomic_stage_index]))
    if not (op_schedule_info.atomic_last_reduce_and_ub_split_last_reduce_axis
            or op_schedule_info.atomic_last_reduce_and_ub_split_nlast_reduce_axis):
        need_align_stage_index_list.append(atomic_stage_index)
    # need_align_stage_index_list
    need_align_stage_index_list_new = []
    for stage_index in need_align_stage_index_list:
        if need_align_stage_proc(progress, stage_index):
            need_align_stage_index_list_new.append(stage_index)

    logger.debug("all need storage align stage index is %s", need_align_stage_index_list_new)

    do_storage_align(progress, need_align_stage_index_list_new)

    return True
