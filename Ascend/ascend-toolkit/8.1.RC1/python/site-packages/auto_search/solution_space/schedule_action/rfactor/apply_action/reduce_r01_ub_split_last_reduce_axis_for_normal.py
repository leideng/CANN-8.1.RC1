#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reduce_r01_ub_split_last_reduce_axis_for_normal
"""
from typing import NoReturn
import copy
import numpy

from tbe.tvm import Stage
from tbe.common.platform import platform_info

from auto_search.solution_space import t2c_util
from auto_search.compute_analysis import StageOrderedAxes
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.solution_space.tensor_cfg import get_init_action_tensor_zero
from auto_search.solution_space.t2c_util import MODE_RUNTIME
from auto_search.bank.cheque_generator import get_rfactor_cheque
from auto_search.bank.cheque_generator import get_set_scope_cheque
from auto_search.bank.cheque_generator import get_axis_cheque
from auto_search.solution_space import tvm_compute as tvm_compute_to_tensor
from auto_search.solution_space.progress import Progress


def add_a_stage_info(progress: Progress, rfactor_stage_index: int, reduce_stage: Stage,
                     rfactor_stage_name: str) -> NoReturn:
    """
    add a stage info for new stage
    :param progress:
    :param rfactor_stage_index:
    :param reduce_stage:
    :param rfactor_stage_name:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    # get original reduce info
    at_info = copy.deepcopy(op_schedule_info.stages_info[rfactor_stage_index].get('at_info'))
    reduce_type = t2c_util.REDUCE_LAST_KEYWORD
    reduce_op_tag = reduce_stage.origin_op.tag + reduce_type
    op_schedule_info.stages_info[rfactor_stage_index]['op_tag'] = reduce_op_tag
    op_schedule_info.stages_info.insert(rfactor_stage_index,
                                  {
                                      'name': rfactor_stage_name,
                                      'type': ['reduce_rfactor'],
                                      'scope': platform_info.scope_ubuf,
                                      'op_tag': reduce_op_tag,
                                      'reduce_type': reduce_type,
                                      'at_info': at_info,
                                  })


def update_reduce_stage_axis_info(progress: Progress, reduce_stage_index: int) -> NoReturn:
    """
    after add rfactor stage, original reduce stage axes need be updated
    :param progress:
    :param reduce_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    code_lines.extend(['\n', '#  update reduce stage axis info'])
    stage_name = op_schedule_info.stages_info[reduce_stage_index].get('name')
    stage = op_schedule_info.schedule_obj.stages[reduce_stage_index]

    stage_axis_info = []
    for axis_index, axis in enumerate(stage.op.axis):
        axis_name = f'{stage_name}_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.axis[axis_index].dom.extent.value,
                                        'axis', axis_index, 'axis', axis))

    for axis_index, axis in enumerate(stage.op.reduce_axis):
        axis_name = f'{stage_name}_reduce_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.reduce_axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.reduce_axis[axis_index].dom.extent.value,
                                        'reduce_axis', axis_index, 'reduce_axis', axis))

    op_schedule_info.axis_info_list[reduce_stage_index] = stage_axis_info
    axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[reduce_stage_index], reduce_stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)


def add_a_stage_axis_info(progress: Progress, rfactor_stage_index: int) -> NoReturn:
    """
    add rfactor stage axis info
    :param progress:
    :param rfactor_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    stage_name = op_schedule_info.stages_info[rfactor_stage_index].get('name')
    stage = op_schedule_info.schedule_obj.stages[rfactor_stage_index]

    stage_axis_info = []
    for axis_index, axis in enumerate(stage.op.axis):
        axis_name = f'{stage_name}_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.axis[axis_index].dom.extent.value,
                                        'axis', axis_index, 'axis', axis))

    for axis_index, axis in enumerate(stage.op.reduce_axis):
        axis_name = f'{stage_name}_reduce_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.reduce_axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.reduce_axis[axis_index].dom.extent.value,
                                        'reduce_axis', axis_index, 'reduce_axis', axis))

    op_schedule_info.axis_info_list.insert(rfactor_stage_index, stage_axis_info)
    axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[rfactor_stage_index], rfactor_stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)


def update_stage_index_map(progress: Progress, reduce_stage_index: int):
    """
    :param progress:
    :param reduce_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_index_map = op_schedule_info.stage_index_map
    for key, value in stage_index_map.items():
        if value >= reduce_stage_index:
            stage_index_map[key] += 1


def update_feature(progress: Progress) -> NoReturn:
    """
    stage num change，need update feature
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    feature_tensor, reduce_axis_dict = \
        tvm_compute_to_tensor.proc(op_schedule_info.schedule_obj,
                                   op_schedule_info.stages_info,
                                   op_schedule_info.op_name)
    src_reduce_axis_dict = op_schedule_info.reduce_axis_dict
    op_schedule_info.src_reduce_axis_dict = src_reduce_axis_dict
    op_schedule_info.feature_tensor = feature_tensor
    op_schedule_info.reduce_axis_dict = reduce_axis_dict
    op_schedule_info.feature_tensor = feature_tensor


def update_actions(progress: Progress, rfactor_stage_index: int) -> NoReturn:
    """
    :param progress:
    :param rfactor_stage_index:
    :return:
    """
    action = get_init_action_tensor_zero(1)
    action = action.tolist()[0]
    progress.action_tensor = numpy.insert(progress.action_tensor, rfactor_stage_index, action, 0)


def update_inlined_stages(progress: Progress, rfactor_stage_index: int) -> NoReturn:
    """
    :param progress:
    :param rfactor_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    inlined_stages = op_schedule_info.inlined_stages
    for idx, stage_index in enumerate(inlined_stages):
        if stage_index >= rfactor_stage_index:
            inlined_stages[idx] = stage_index + 1

    op_schedule_info.inlined_stages = list(inlined_stages)


def update_cut_axis_index(progress: Progress, rfactor_stage_index: int) -> NoReturn:
    """
    add a stage, all cut_axis_index move back one, cut_axis_index[rfactor_stage_index] set as 0
    :param progress:
    :param rfactor_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    cut_axis_index = op_schedule_info.cut_axis_index
    stages_num = len(op_schedule_info.stages_info)
    for i in range(stages_num-1, rfactor_stage_index, -1):
        cut_axis_index[i] = cut_axis_index[i-1]

    cut_axis_index[rfactor_stage_index] = 0


def update_at_dict(progress: Progress) -> NoReturn:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_index_map = op_schedule_info.stage_index_map

    for stage_index, stage_info in enumerate(op_schedule_info.stages_info):
        if 'at_info' not in stage_info:
            continue
        at_info = stage_info['at_info']
        for consumer in at_info.consumers:
            sampled_target = consumer.sampled_target
            stage_types = stage_info.get('type', [])
            if 'reduce_rfactor' in stage_types:
                # rfactor stage compute at it's behind stage (original reduce stage)
                consumer.set_updated_sampled_target(stage_index + 1)
                continue
            new_sampled_target = stage_index_map[sampled_target]
            target_stage_types = op_schedule_info.stages_info[new_sampled_target].get('type', [])
            current_stage_types = op_schedule_info.stages_info[stage_index].get('type', [])
            if 'reduce_gm' in target_stage_types and 'reduce' not in current_stage_types:
                # the stage index be saved in consumer is before do cache r/w
                # the stage before reduce stage, compute at rfactor stage
                consumer.set_updated_sampled_target(new_sampled_target - 2)
                continue
            consumer.set_updated_sampled_target(new_sampled_target)

    op_schedule_info.update_at_dict()


def update_stages_relevant_info(progress: Progress, reduce_stage_index: int, rfactor_stage_name: str) -> NoReturn:
    """
    after doing rfactor add a stage，need update stage relevant info
    :param progress:
    :param reduce_stage_index:
    :param rfactor_stage_name:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    # update stage index
    rfactor_stage_index = reduce_stage_index
    reduce_stage_index = reduce_stage_index + 1
    # reduce gm stage is the next of reduce ub stage，trough reduce_gm stage can get op.tag
    reduce_stage_gm = op_schedule_info.schedule_obj.stages[reduce_stage_index + 1]
    # update stages_info
    add_a_stage_info(progress, rfactor_stage_index, reduce_stage_gm, rfactor_stage_name)
    # update axis_info_list
    add_a_stage_axis_info(progress, rfactor_stage_index)
    update_reduce_stage_axis_info(progress, reduce_stage_index)
    # update stage_index_map is used in
    update_stage_index_map(progress, reduce_stage_index)
    # update feature
    update_feature(progress)
    # update actions
    update_actions(progress, rfactor_stage_index)
    # update inlined stage
    update_inlined_stages(progress, rfactor_stage_index)
    # update cut_axis_index
    update_cut_axis_index(progress, rfactor_stage_index)
    # update at_dict
    update_at_dict(progress)
    # update dependency_dict
    op_schedule_info.update_dependency_dict()


def do_rfactor(progress: Progress, reduce_stage_index: int, rfactor_axis_info: AxisInfo) -> NoReturn:
    """
    进行rfactor
    :param progress:
    :param reduce_stage_index:
    :param rfactor_axis_info:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    reduce_tensor = op_schedule_info.schedule_obj.stages[reduce_stage_index].origin_op.output(0)
    rfactor_axis_obj = rfactor_axis_info.body
    last_axis_index = len(op_schedule_info.schedule_obj.stages[reduce_stage_index].leaf_iter_vars) - 1

    # code_lines
    reduce_stage_name = op_schedule_info.stages_info[reduce_stage_index].get('name')
    rfactor_stage_name = f"{reduce_stage_name}_rfactor"
    rfactor_axis_name = rfactor_axis_info.name
    rfactor_code_lines = f"{rfactor_stage_name} = sch.rfactor({reduce_stage_name}, {rfactor_axis_name}, factor_axis=-1)"
    set_scope_code_lines = f"sch[{rfactor_stage_name}].set_scope('{platform_info.scope_ubuf}')"
    code_lines.append(rfactor_code_lines)
    code_lines.append(set_scope_code_lines)

    # rfactor的runtime
    if op_schedule_info.mode == MODE_RUNTIME:
        rfactor_tensor = op_schedule_info.schedule_obj.rfactor(reduce_tensor, rfactor_axis_obj, factor_axis=-1)
        op_schedule_info.schedule_obj[rfactor_tensor].set_scope(platform_info.scope_ubuf)

    # gen rfactor cheque
    cheque = get_rfactor_cheque(reduce_stage_index, last_axis_index, -1)
    op_schedule_info.cheque_list.append(cheque)

    # gen set_scope cheque
    cheque = get_set_scope_cheque(reduce_stage_index, platform_info.scope_ubuf)
    op_schedule_info.cheque_list.append(cheque)

    # add a new stage, need update relevant info
    update_stages_relevant_info(progress, reduce_stage_index, rfactor_stage_name)


def proc(progress: Progress):
    """
    last reduce，ub split last reduce axis，do rfactor for ub_inner
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    if op_schedule_info.is_atomic:
        return
    stages = list(op_schedule_info.schedule_obj.stages)
    # find reduce stage
    for stage_index, _ in enumerate(stages):
        # if not split stage ,continue
        split_vector = progress.action_tensor[stage_index][
                       ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
        if sum(split_vector) == 0:
            continue
        # find ub split axis
        ub_cut_axis = _find_cut_axis(split_vector)
        stage_info = op_schedule_info.stages_info[stage_index]
        # find reduce stage
        if 'reduce' not in stage_info.get('type', []):
            continue
        # reduce stage's stage info has stage_ordered_axes_obj
        ordered_axis_obj: StageOrderedAxes = stage_info.get('stage_ordered_axes_obj', None)
        if ordered_axis_obj is None:
            continue
        if not ordered_axis_obj.is_reduce_last():
            continue
        op_schedule_info.last_reduce = True
        if ub_cut_axis != ordered_axis_obj.get_reduce_axes()[-1]:
            return
        # now reduce stage has been split，so axis_info_list is not None
        if op_schedule_info.axis_info_list[stage_index] is None:
            continue
        last_reduce_inner_axis_info = op_schedule_info.axis_info_list[stage_index][-1]
        do_rfactor(progress, stage_index, last_reduce_inner_axis_info)
        op_schedule_info.last_reduce_and_ub_split_last_reduce_axis = True
        break

    return


def _find_cut_axis(split_vector):
    """
    :param split_vector:
    :return:
    """
    ub_cut_axis = 0
    for i, f in enumerate(split_vector):
        if f > 0:
            ub_cut_axis = i
            break
    return ub_cut_axis
