#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reduce normal storage align
"""
from typing import NoReturn
from typing import List

from tbe import tvm
from tbe.tvm import Stage

from auto_search.utils import util
from auto_search.utils import logger
from auto_search.bank.cheque_generator import get_storage_align_cheque_enhance
from auto_search.bank.cheque_generator import get_storage_align_cheque
from auto_search.solution_space.progress import Progress


def need_align_stage_proc(progress: Progress, stage_index: int) -> bool:
    """
    :param progress:
    :param stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage = op_schedule_info.schedule_obj.stages[stage_index]
    if isinstance(stage.op, tvm.PlaceholderOp):
        return False

    if stage_index in op_schedule_info.inlined_stages:
        return False
    gm_type_set = {
        'leaf', 'origin_leaf_out', 'inter_out', 'workspace', 'virtual_leaf_out'
    }
    # ub to gm stage need not do storage align
    if gm_type_set.intersection(set(op_schedule_info.stages_info[stage_index].get('type', []))):
        return False
    if 'src_align_pad' in op_schedule_info.stages_info[stage_index].get('type', []):
        return False
    if 'remove_pad' in op_schedule_info.stages_info[stage_index].get('type', []):
        return False

    return True


def _update_align_axis(stage, stage_name, axis_info):
    """
    update align axis
    :param stage:
    :param stage_name:
    :param axis_info:
    :return:
    """
    align_axis_index = axis_info.index
    align_axis_name = f"sch[{stage_name}].op.{axis_info.type}[{align_axis_index}]"
    align_axis = None
    if axis_info.type == "axis":
        align_axis = stage.op.axis[align_axis_index]
    elif axis_info.type == "reduce_axis":
        align_axis = stage.op.reduce_axis[align_axis_index]

    return align_axis_name, align_axis_index, align_axis


def get_align_axis(progress: Progress,  stage: Stage, align_stage_index: int) -> tuple:
    """
    get storage align axis: leaf_iter_vars[-2]
    :param progress:
    :param stage:
    :param align_stage_index:
    :return:
    """
    align_axis_name = None
    align_axis_index = None
    align_axis = None
    op_schedule_info = progress.op_schedule_info
    stage_name = op_schedule_info.stages_info[align_stage_index]["name"]
    if len(stage.leaf_iter_vars) <= 1:
        logger.info("current stage axis len is small than 1, no need storage align!")
        return align_axis_name, align_axis_index, align_axis
    align_axis = stage.leaf_iter_vars[-2]
    # reduce_axis not become align axis
    for adjust_align_axis in list(reversed(list(stage.leaf_iter_vars)[:-1])):
        # reduce_axis iter_type is 2, axis iter_type is 0
        if adjust_align_axis.iter_type == 2:
            continue
        align_axis = adjust_align_axis
        break
    # if axis_info_list is None, represent current stage is not be cut,
    # need get axis from stage.op.axis or stage.op.reduce_axis
    if op_schedule_info.axis_info_list[align_stage_index] is None:
        if len(stage.op.axis) >= 2:
            align_axis = stage.op.axis[-2]
        align_axis_index, align_axis_name = \
            _find_align_axis_for_no_split_stage(align_axis, stage, stage_name)
        return align_axis_name, align_axis_index, align_axis

    for axis_index, axis_info in enumerate(op_schedule_info.axis_info_list[align_stage_index]):
        if axis_info.body == align_axis:
            # storage_align only support set origin axis, axis after split need to update
            if axis_info.attr != "all":
                align_axis_name, align_axis_index, align_axis = _update_align_axis(stage, stage_name, axis_info)
            else:
                align_axis_name = axis_info.name
                align_axis_index = axis_index
            break

    if align_axis_index is None:
        logger.error("current stage cant find align axis!")
        return align_axis_name, align_axis_index, align_axis

    return align_axis_name, align_axis_index, align_axis


def _find_align_axis_for_no_split_stage(align_axis, stage, stage_name):
    """
    :param align_axis:
    :param stage:
    :param stage_name:
    :return:
    """
    for axis_index, op_axis in enumerate(stage.op.axis):
        if op_axis == align_axis:
            align_axis_index = axis_index
            align_axis_name = f'sch[{stage_name}].op.axis[{align_axis_index}]'
            return align_axis_index, align_axis_name

    raise RuntimeError("current stage cant find align axis!")


def do_storage_align(progress: Progress, need_align_stage_index_list: List[int]) -> NoReturn:
    """
    :param progress:
    :param need_align_stage_index_list:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = []
    code_lines.extend(['\n', '# storage_align code begin'])
    for align_stage_index in need_align_stage_index_list:
        stage = op_schedule_info.schedule_obj.stages[align_stage_index]
        stage_name = op_schedule_info.stages_info[align_stage_index]["name"]
        vector_block_num = util.get_block_num(stage.op.output(0).dtype)
        align_axis_name, align_axis_index, align_axis = get_align_axis(progress, stage, align_stage_index)
        if align_axis_index is None:
            return
        align_code = f'sch[{stage_name}].storage_align({align_axis_name}, {vector_block_num}, 0)'
        code_lines.append(align_code)
        stage.storage_align(align_axis, vector_block_num, 0)
        # gen storage_align cheque
        if "[" in align_axis_name and "]" in align_axis_name:
            cheque = get_storage_align_cheque(align_stage_index, align_axis_index, vector_block_num)
        else:
            cheque = get_storage_align_cheque_enhance(align_stage_index, (align_axis_name, align_axis_index),
                                                      vector_block_num)
        op_schedule_info.cheque_list.append(cheque)
        op_schedule_info.storage_align_para[align_stage_index] = vector_block_num
    op_schedule_info.code_lines.extend(code_lines)


def proc(progress: Progress) -> bool:
    """
    last reduce:
    the stage before reduce stage need do storage align, align axis is leaf_iter_vars[-2]
    nlast reduce:
    all stages need do storage align, align axis is leaf_iter_vars[-2]
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    reduce_stage_index = None
    for stage_index, _ in enumerate(op_schedule_info.schedule_obj.stages):
        stage_type = op_schedule_info.stages_info[stage_index].get('type', [])
        if "CacheWrite" in stage_type and "reduce" in stage_type:
            reduce_stage_index = stage_index
            break

    if reduce_stage_index is None:
        return False

    reduce_compute_info = op_schedule_info.compute_graph_info

    if reduce_compute_info.is_last_reduce:
        # last reduce only need do storage_align for the stages before reduce stage
        need_align_stage_index_list = \
            list(set(op_schedule_info.all_fanin_dict[reduce_stage_index]))
    else:
        # nlast reduce need do storage_align for all stages
        need_align_stage_index_list = list(range(len(op_schedule_info.schedule_obj.stages)))

    # need_align_stage_index_list
    need_align_stage_index_list_new = []
    for stage_index in need_align_stage_index_list:
        if need_align_stage_proc(progress, stage_index):
            need_align_stage_index_list_new.append(stage_index)

    logger.debug("all need storage align stage index is %s", need_align_stage_index_list_new)

    do_storage_align(progress, need_align_stage_index_list_new)

    return True
