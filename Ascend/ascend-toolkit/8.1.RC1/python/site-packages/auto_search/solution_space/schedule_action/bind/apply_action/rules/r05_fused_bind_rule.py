#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
fused bind rule
"""
from typing import List
from typing import NoReturn

from tbe import tvm
from tbe.tvm import Stage

from auto_search.utils import util
from auto_search.utils import logger
from auto_search.config import soc_cfg
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.bank.cheque_generator import get_split_cheque
from auto_search.bank.cheque_generator import get_bind_cheque
from auto_search.solution_space.op_schedule_info import OpScheduleInfo
from auto_search.solution_space.progress import Progress
from auto_search.utils.dynamic_util import BlockSplitInfo
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.comm import BLOCK_SIZE_BYTE
from auto_search.solution_space.schedule_action.bind.apply_action.rules.comm import fuse_axis
from auto_search.solution_space.schedule_action.bind.apply_action.rules.comm import get_block_factor_and_block_dim


def proc(progress: Progress) -> bool:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info

    # only one stage can be bind
    stage, stage_index = op_schedule_info.bind_stages[0]
    stage_name = stage.op.name

    # if stage have been processed, skip
    if op_schedule_info.proc_flag_dict.get(stage_index, False):
        logger.debug('Stage processed.')
        return True

    stage_axis_info = op_schedule_info.axis_info_list[stage_index]
    block_dim = _block_tiling(stage_index, stage_axis_info, progress, stage)
    op_schedule_info.block_dim = block_dim
    if block_dim == 1:
        logger.debug('block_dim: %s', block_dim)
        return True
    bind_axis_info = stage_axis_info[0]

    # bind
    op_schedule_info.code_lines.append("block = tvm.thread_axis('blockIdx.x')")
    code_line = "sch[{}].bind({}, block)".format(stage_name, bind_axis_info.name)
    op_schedule_info.code_lines.append(code_line)
    op_schedule_info.proc_flag_dict[stage_index] = True

    block = tvm.thread_axis('blockIdx.x')
    stage.bind(bind_axis_info.body, block)

    cheque = get_bind_cheque(stage_index)
    op_schedule_info.cheque_list.append(cheque)

    return True


def _update_block_dim_for_ub_less_than_32b(progress, stage_index, stage, block_dim):
    """
    :param progress:
    :param stage_index:
    :param stage:
    :param block_dim:
    :return:
    """
    curr_stage_nonzero_axes = progress.get_nonzero_axes(stage_index)
    ub_cut_index, factor = _get_bind_stage_ub_split_axis_and_factor(progress, stage_index)
    ub_right_multi_size = 1
    for idx in range(len(curr_stage_nonzero_axes) - 1, ub_cut_index, -1):
        ub_right_multi_size *= curr_stage_nonzero_axes[idx]
    in_ub_size = factor * ub_right_multi_size
    stage_dtype = stage.op.output(0).dtype
    elemt_in_block = BLOCK_SIZE_BYTE // util.get_dtype_size(stage_dtype)
    # if in_ub_size less than 32b, if block dim bigger than 1, will run failed
    if in_ub_size < elemt_in_block:
        block_dim = 1

    return block_dim


def _get_bind_stage_ub_split_axis_and_factor(progress, stage_index):
    """
    :param progress:
    :param stage_index:
    :return:
    """
    split_vector = \
        progress.action_tensor[stage_index][ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    # find ub split axis
    ub_cut_axis = 0
    factor = 1
    for i, f in enumerate(split_vector):
        if f > 0:
            ub_cut_axis = i
            factor = f
            break

    return ub_cut_axis, factor


def _set_block_split_info(op_schedule_info: OpScheduleInfo, cut_axis_index: int, block_dim: int,
                          core_num: int) -> NoReturn:
    """
    generate BlockSplitInfo for infer_range
    :param op_schedule_info:
    :param cut_axis_index:
    :param block_dim:
    :param core_num:
    :return:
    """
    block_factor_var_name = ''
    if op_schedule_info.is_need_block_tiling:
        # record split order, and factor name
        if op_schedule_info.tiling_record is None:
            op_schedule_info.tiling_record = {'block_split_num': 0, 'ub_split_num': 0, 'split_var_name_list': []}
        block_split_num = op_schedule_info.tiling_record.get("block_split_num", None)
        if block_split_num is None:
            raise RuntimeError("block_split_num is None, please check!")
        block_factor_var_name = '_block_factor_' + str(block_split_num)
        op_schedule_info.tiling_record['block_split_num'] = block_split_num + 1
        op_schedule_info.tiling_record['split_var_name_list'].append(block_factor_var_name)

    bind_axes = list(range(0, cut_axis_index + 1))
    block_split_info = BlockSplitInfo(cut_axis_index, bind_axes, block_factor_var_name, core_num, block_dim)
    op_schedule_info.block_split_info = block_split_info


def _block_tiling(stage_index, stage_axis_info, progress, stage):
    """
    block tiling use factor mode
    :param stage_index:
    :param stage_axis_info:
    :param progress:
    :param stage:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    core_num = soc_cfg.get_core_num()
    op_schedule_info.is_need_block_tiling = False
    block_split_axis = op_schedule_info.cut_axis_index[stage_index]
    block_dim = 1
    fuse_len = 1
    for i in range(0, op_schedule_info.cut_axis_index[stage_index] + 1):
        fuse_len *= stage_axis_info[i].len
        if fuse_len < core_num:
            continue
        split_axis_info = stage_axis_info[i]
        block_split_axis = i
        block_dim, block_factor = get_block_factor_and_block_dim(core_num, fuse_len, i, stage_axis_info)
        op_schedule_info.is_need_block_tiling = True
        axis_name = split_axis_info.name
        op_schedule_info.code_lines.append(f'# block_dim={block_dim}')
        op_schedule_info.code_lines.append('{}_oo, {}_o = sch[{}].split({}, factor={})'.format(
            axis_name, axis_name, stage.op.name, axis_name, block_factor))

        axis_obj_o, axis_obj_i = stage.split(split_axis_info.body, factor=block_factor)

        del stage_axis_info[i]
        stage_axis_info.insert(i, AxisInfo(f"{axis_name}_o", block_factor, 'axis', split_axis_info.index, 'o',
                                           axis_obj_i))
        stage_axis_info.insert(i, AxisInfo(f"{axis_name}_oo", block_dim, 'axis', split_axis_info.index, 'oo',
                                           axis_obj_o))

        cheque = get_split_cheque(stage_index, block_split_axis, block_factor, "split")
        op_schedule_info.cheque_list.append(cheque)
        # generate BlockSplitInfo for infer_range
        if op_schedule_info.option.get('op_config').get('op_mode', '') in ['dynamic']:
            _set_block_split_info(op_schedule_info, block_split_axis, block_dim, core_num)
        break

    if not op_schedule_info.is_need_block_tiling:
        # is_need_block_tiling use to control block is need tiling or not
        # eg:ub tiling,then block is less equal core_num
        # generate BlockSplitInfo for infer_range
        block_dim = fuse_len
        op_schedule_info.code_lines.append(f'# block_dim={block_dim}')
        if op_schedule_info.option.get('op_config').get('op_mode', '') in ['dynamic']:
            _set_block_split_info(op_schedule_info, 0, block_dim, core_num)

    # fuse left axis
    if block_split_axis > 0:
        fuse_axis(block_split_axis, stage_axis_info, op_schedule_info, stage, stage_index)
    block_dim = _update_block_dim_for_ub_less_than_32b(progress, stage_index, stage, block_dim)
    op_schedule_info.code_lines.append(f'# update_block_dim={block_dim}')
    return block_dim
