#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reduce atomic insn rule
"""
from auto_search.solution_space.tensor_cfg import FeatureTensorCfg
from auto_search.bank.cheque_generator import get_emit_insn_cheque
from auto_search.solution_space.progress import Progress
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.schedule_action.emit_insn.apply_action.rules.comm import get_use_ub_size


def proc(progress: Progress) -> bool:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    # if have been handled stage return directly
    stage_index = op_schedule_info.stage_index
    if op_schedule_info.proc_flag_dict.get(stage_index, False):
        return False

    if {'align_pad', 'remove_pad'} & set(op_schedule_info.stages_info[stage_index].get('type', [])):
        return False

    if not op_schedule_info.is_atomic:
        return False
    stage_index = op_schedule_info.stage_index
    stage_info = op_schedule_info.stages_info[stage_index]

    if 'reduce_atomic' in stage_info.get('type', []):
        return _do_reduce_atomic_stage_emit_insn(progress)
    if "reduce_atomic_write" in stage_info.get('type', []):
        return _do_reduce_atomic_write_stage_emit_insn(progress)
    if "reduce_atomic_rfactor" in stage_info.get('type', []):
        return _do_reduce_atomic_rfactor_stage_emit_insn(progress)
    if "reduce_rfactor" in stage_info.get('type', []):
        return _do_reduce_rfactor_stage_emit_insn(progress)

    return False


def _do_reduce_atomic_stage_emit_insn(progress: Progress) -> bool:
    """
    reduce_atomic stage is emit_insn 'phony_insn'
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_index = op_schedule_info.stage_index
    stage_name = op_schedule_info.stage_name
    stage = op_schedule_info.stage
    emit_insn_axis_obj = stage.op.axis[0]
    emit_insn_axis_name = f'sch[{stage_name}].op.axis[0]'
    stage.emit_insn(emit_insn_axis_obj, 'phony_insn')
    emit_insn_code =  f"sch[{stage_name}].emit_insn({emit_insn_axis_name}, 'phony_insn')"
    op_schedule_info.code_lines.append(emit_insn_code)

    cheque = get_emit_insn_cheque(stage_index, 'phony_insn', (emit_insn_axis_name, 0))
    op_schedule_info.cheque_list.append(cheque)
    op_schedule_info.proc_flag_dict[stage_index] = True
    return True


def _do_reduce_atomic_write_stage_emit_insn(progress: Progress) -> bool:
    """
    reduce_atomic_write stage is emit_insn 'dma_copy'
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_index = op_schedule_info.stage_index
    stage_name = op_schedule_info.stage_name
    stage = op_schedule_info.stage
    emit_insn_axis_obj = stage.op.axis[0]
    emit_insn_axis_name = f'sch[{stage_name}].op.axis[0]'
    stage.emit_insn(emit_insn_axis_obj, 'dma_copy')
    emit_insn_code = f"sch[{stage_name}].emit_insn({emit_insn_axis_name}, 'dma_copy')"
    op_schedule_info.code_lines.append(emit_insn_code)

    cheque = get_emit_insn_cheque(stage_index, 'dma_copy', (emit_insn_axis_name, 0))
    op_schedule_info.cheque_list.append(cheque)
    op_schedule_info.proc_flag_dict[stage_index] = True
    return True


def _get_emit_insn_axis_for_nlast_reduce(progress: Progress) -> tuple:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    curr_axis_info_list = op_schedule_info.axis_info_list[op_schedule_info.stage_index]
    ub_split_info = op_schedule_info.atomic_ub_split_info
    reduce_compute_graph = op_schedule_info.compute_graph_info
    ub_split_axis_type = op_schedule_info.stages_info[-1].get('split_axis_type', None)

    nlast_and_ub_split_not_last_a_axis = \
        ub_split_axis_type == 'axis' \
        and ub_split_info.axis_index != len(reduce_compute_graph.normal_axes_index) - 1
    emit_insn_axis_index = None
    emit_insn_axis = None
    emit_insn_axis_obj = None
    if nlast_and_ub_split_not_last_a_axis:
        # if ub split a axis but not last a axis, emit_insn_axis(rbi) should be the first reduce_axis
        for axis_index, curr_axis_info in enumerate(curr_axis_info_list):
            if curr_axis_info.type == "reduce_axis":
                emit_insn_axis = curr_axis_info
                emit_insn_axis_obj = emit_insn_axis.body
                emit_insn_axis_index = axis_index
                break
    else:
        # emit_insn_axis is inner axis normally
        for axis_index, curr_axis_info in enumerate(curr_axis_info_list):
            if curr_axis_info.name.endswith('i'):
                emit_insn_axis = curr_axis_info
                emit_insn_axis_obj = emit_insn_axis.body
                emit_insn_axis_index = axis_index

    return emit_insn_axis, emit_insn_axis_obj, emit_insn_axis_index


def _get_emit_insn_axis_for_last_reduce(progress: Progress) -> tuple:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    curr_axis_info_list = op_schedule_info.axis_info_list[op_schedule_info.stage_index]
    ub_split_axis_type = op_schedule_info.stages_info[-1].get('split_axis_type', None)
    emit_insn_axis_index = None
    emit_insn_axis = None
    emit_insn_axis_obj = None
    if ub_split_axis_type == 'axis':
        # ub split a axis, emit_insn_axis should be the first reduce_axis
        for axis_index, axis_info in enumerate(curr_axis_info_list):
            if axis_info.type == "reduce_axis":
                emit_insn_axis = axis_info
                emit_insn_axis_obj = emit_insn_axis.body
                emit_insn_axis_index = axis_index
                break
    elif ub_split_axis_type == 'reduce_axis':
        emit_insn_axis, emit_insn_axis_index, emit_insn_axis_obj = \
            __get_emit_axis_for_ub_split_reduce_axis(curr_axis_info_list, op_schedule_info)

    return emit_insn_axis, emit_insn_axis_obj, emit_insn_axis_index


def __get_emit_axis_for_ub_split_reduce_axis(curr_axis_info_list, op_schedule_info):
    """
    :param curr_axis_info_list:
    :param op_schedule_info:
    :return:
    """
    emit_insn_axis_index = None
    emit_insn_axis = None
    emit_insn_axis_obj = None
    if op_schedule_info.atomic_last_reduce_and_ub_split_last_reduce_axis \
            or op_schedule_info.atomic_last_reduce_and_ub_split_nlast_reduce_axis:
        # after do reduce rfactor, this stage only have one reduce_axis
        for axis_index, axis_info in enumerate(curr_axis_info_list):
            if axis_info.type == "reduce_axis":
                emit_insn_axis = axis_info
                emit_insn_axis_obj = emit_insn_axis.body
                emit_insn_axis_index = axis_index
    else:
        # ub split a axis, emit_insn_axis should be the inner axis
        for axis_index, axis_info in enumerate(curr_axis_info_list):
            if axis_info.type == "reduce_axis" and axis_info.name.endswith('i'):
                emit_insn_axis = axis_info
                emit_insn_axis_obj = emit_insn_axis.body
                emit_insn_axis_index = axis_index
                break
    return emit_insn_axis, emit_insn_axis_index, emit_insn_axis_obj


def _do_reduce_atomic_rfactor_stage_emit_insn(progress: Progress) -> bool:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_index = op_schedule_info.stage_index

    features = op_schedule_info.feature_tensor
    stage_name = op_schedule_info.stage_name
    stage = op_schedule_info.stage
    # get ub_info_rf from handle template compile info
    extra_space = get_use_ub_size(op_schedule_info)

    reduce_compute_graph = op_schedule_info.compute_graph_info
    if not reduce_compute_graph.is_last_reduce:
        emit_insn_axis, emit_insn_axis_obj, emit_insn_axis_index = _get_emit_insn_axis_for_nlast_reduce(progress)
    else:
        emit_insn_axis, emit_insn_axis_obj, emit_insn_axis_index = _get_emit_insn_axis_for_last_reduce(progress)

    if op_schedule_info.op_pattern == ComputePattern.TUPLE_REDUCE and not reduce_compute_graph.is_last_reduce:
        attrs = {'storage_bound': extra_space // 2, "reduce_opt_mode": "dichotomy_reduce", "reuse_src_tensor": True,
                 "nlast_reduce_dichotomy": 16}
    else:
        attrs = {'storage_bound': extra_space}
    attrs_str = str(attrs)

    intrinsic_func_name = op_schedule_info.op_intrin_key_index[
        features[stage_index][FeatureTensorCfg.compute_s]].intrin
    code_line = f"sch[{stage_name}].emit_insn({emit_insn_axis.name}, '{intrinsic_func_name}', {attrs_str})"
    op_schedule_info.code_lines.append(code_line)

    stage.emit_insn(emit_insn_axis_obj, intrinsic_func_name, attrs=attrs)
    cheque = get_emit_insn_cheque(stage_index, intrinsic_func_name, (emit_insn_axis.name, emit_insn_axis_index),
                                  extra_info=attrs)
    op_schedule_info.cheque_list.append(cheque)

    op_schedule_info.proc_flag_dict[stage_index] = True
    return True


def _do_reduce_rfactor_stage_emit_insn(progress: Progress) -> bool:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_index = op_schedule_info.stage_index

    stage_name = op_schedule_info.stage_name
    stage = op_schedule_info.stage
    extra_space = get_use_ub_size(op_schedule_info)

    curr_axis_info_list = op_schedule_info.axis_info_list[op_schedule_info.stage_index]

    emit_insn_axis, emit_insn_axis_index, emit_insn_axis_obj = \
        _get_emit_insn_axis_for_reduce_rfactor_stage(curr_axis_info_list, op_schedule_info)

    if op_schedule_info.op_pattern == ComputePattern.TUPLE_REDUCE:
        attrs = {'storage_bound': extra_space // 2, "reduce_opt_mode": "dichotomy_reduce", "reuse_src_tensor": True,
                 "nlast_reduce_dichotomy": 16}
    else:
        attrs = {'storage_bound': extra_space}

    intrinsic_func_name = op_schedule_info.op_intrin_key_index[
        op_schedule_info.feature_tensor[stage_index][FeatureTensorCfg.compute_s]].intrin
    code_line = f"sch[{stage_name}].emit_insn({emit_insn_axis.name}, '{intrinsic_func_name}', {str(attrs)})"
    op_schedule_info.code_lines.append(code_line)

    stage.emit_insn(emit_insn_axis_obj, intrinsic_func_name, attrs=attrs)
    cheque = get_emit_insn_cheque(stage_index, intrinsic_func_name,
                         (emit_insn_axis.name, emit_insn_axis_index), extra_info=attrs)
    op_schedule_info.cheque_list.append(cheque)

    op_schedule_info.proc_flag_dict[stage_index] = True

    return True


def _get_emit_insn_axis_for_reduce_rfactor_stage(curr_axis_info_list, op_schedule_info):
    """
    :param curr_axis_info_list:
    :param op_schedule_info:
    :return:
    """
    emit_insn_axis_index = None
    emit_insn_axis = None
    emit_insn_axis_obj = None
    for axis_index, axis_info in enumerate(curr_axis_info_list):
        if op_schedule_info.atomic_last_reduce_and_ub_split_last_reduce_axis:
            # rfactor stage emit_insn axis is last a axis
            if axis_info.type == "axis":
                emit_insn_axis = axis_info
                emit_insn_axis_obj = emit_insn_axis.body
                emit_insn_axis_index = axis_index
        elif op_schedule_info.atomic_last_reduce_and_ub_split_nlast_reduce_axis:
            # rfactor stage emit_insn axis is ub split inner axis
            if axis_info.type == "reduce_axis" and axis_info.name.endswith('i'):
                emit_insn_axis = axis_info
                emit_insn_axis_obj = emit_insn_axis.body
                emit_insn_axis_index = axis_index
                break
        else:
            raise RuntimeError("ub not split reduce axis!")
    return emit_insn_axis, emit_insn_axis_index, emit_insn_axis_obj
