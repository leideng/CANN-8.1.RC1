#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
common apply action
"""
from typing import NoReturn

import copy
import json
import importlib

from auto_search.utils import logger
from auto_search.solution_space.action import apply_action_register
from auto_search.solution_space.action import ScheduleActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.t2c_util import MODE_RUNTIME
from auto_search.solution_space.schedule_action.utils import get_schedule_action_rules
from auto_search.bank.cheque_generator import get_stage_index
from auto_search.bank.cheque_generator import get_at_cheque
from auto_search.solution_space import depend
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.op_schedule_info import OpScheduleInfo
from auto_search.compute_analysis.broadcast_analysis import is_small_stage_in_bn_operator


def runtime_proc(op_schedule_info: OpScheduleInfo,
                 stage_index: int,
                 stage: object,
                 target_stage: str,
                 target_axis: object) -> NoReturn:
    """

    :param op_schedule_info:

    :param stage_index:
    :param stage:
    :param target_stage:
    :param target_axis:
    """
    at_target_obj = None

    for tmp_stage_index, tmp_stage in enumerate(op_schedule_info.schedule_obj.stages):
        tmp_stage_name = op_schedule_info.stages_info[tmp_stage_index]['name']
        if tmp_stage_name == target_stage:
            at_target_obj = tmp_stage
            op_schedule_info.at_dict[stage_index] = tmp_stage_index
            break
    stage.compute_at(at_target_obj, target_axis.body)


def gen_at_cheque(op_schedule_info: OpScheduleInfo,
                  stage_index: int,
                  target_stage: str,
                  target_axis: object) -> NoReturn:
    """
    gen at cheque
    :param op_schedule_info:
    :param stage_index:
    :param target_stage:
    :param target_axis:
    :return:
    """
    target_stage_index = get_stage_index(op_schedule_info.stages_info, target_stage)

    target_axis_index = 0
    for i, axis_info in enumerate(
            op_schedule_info.axis_info_list[target_stage_index]):
        if axis_info.name == target_axis.name:
            target_axis_index = i
            break
    cheque = get_at_cheque(stage_index, target_stage_index, target_axis_index)
    op_schedule_info.cheque_list.append(cheque)


def do_compute_at(progress: Progress, code_lines: list) -> NoReturn:
    """
    do compute at
    :param progress:
    :param code_lines:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    sch = op_schedule_info.schedule_obj
    stages_info = op_schedule_info.stages_info
    at_targets = op_schedule_info.at_targets
    for stage_index, stage in enumerate(sch.stages):
        if str(stage.op).startswith("placeholder"):
            continue
        inlined_stages = op_schedule_info.inlined_stages
        if stage_index in inlined_stages:
            continue
        if is_small_stage_in_bn_operator(progress, stage_index):
            continue
        stage_name = stages_info[stage_index]['name']
        target_axis = at_targets[stage_index]
        if target_axis is None:
            continue

        target_stage = target_axis.name.split('_reduce')[0].split('_axis')[0]
        code_line = 'sch[%s].compute_at(sch[%s], %s)' % (stage_name, target_stage, target_axis.name)
        code_lines.append(code_line)
        if op_schedule_info.mode == MODE_RUNTIME:
            runtime_proc(op_schedule_info, stage_index, stage, target_stage, target_axis)

        gen_at_cheque(op_schedule_info, stage_index, target_stage, target_axis)


@apply_action_register(
    [ComputePattern.ELEMENTWISE, ComputePattern.BROADCAST, ComputePattern.REDUCE, ComputePattern.NORM,
     ComputePattern.TRANSPOSE, ComputePattern.POOLING, ComputePattern.TUPLE_REDUCE],
    ScheduleActionType.AT)
def apply(progress: Progress) -> NoReturn:
    """
    apply action
    :param progress:
    :return:
    """
    op_pattern = progress.op_schedule_info.op_pattern
    rules = get_schedule_action_rules(op_pattern, "proc_at")

    op_schedule_info = progress.op_schedule_info
    code_lines = []
    op_schedule_info.fanout_sub_tree = depend.get_fanout_sub_tree_indices(
        op_schedule_info.feature_tensor)
    op_schedule_info.code_lines.extend(['\n', '# compute_at code'])
    at_dict = copy.deepcopy(op_schedule_info.at_dict)

    ori_at_dict_str = '# compute_at_dict:' + json.dumps(
        op_schedule_info.ori_at_dict)
    code_lines.extend(['\n', ori_at_dict_str])

    for rule in rules:
        module = importlib.import_module(rule)
        ret = module.proc(progress)
        if ret:
            break

    do_compute_at(progress, code_lines)

    for at_axis, ated in op_schedule_info.at_dict.items():
        if at_axis and ated:
            code_lines.append("#%s at %s" %
                              (op_schedule_info.stages_info[at_axis]['name'],
                               op_schedule_info.stages_info[ated]['name']))
    op_schedule_info.code_lines.extend(code_lines)
    op_schedule_info.at_dict = at_dict

    logger.debug("apply compute at done.")
