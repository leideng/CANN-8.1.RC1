#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reduce nlast reduce insn rule
"""
from auto_search.solution_space.tensor_cfg import FeatureTensorCfg
from auto_search.solution_space.progress import Progress
from auto_search.bank.cheque_generator import get_emit_insn_cheque
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.schedule_action.emit_insn.apply_action.rules.comm import get_use_ub_size


def proc(progress: Progress) -> bool:
    """
    nalast reduce emit insn
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    if op_schedule_info.is_atomic:
        return True

    reduce_compute_graph_info = op_schedule_info.compute_graph_info
    if reduce_compute_graph_info.is_last_reduce:
        return True

    stage_index = op_schedule_info.stage_index
    if op_schedule_info.proc_flag_dict.get(stage_index, False):
        return True

    if {'align_pad', 'remove_pad'} & set(op_schedule_info.stages_info[stage_index].get('type', [])):
        return True

    stage_type = op_schedule_info.stages_info[stage_index].get('type', [])

    split_vector = progress.action_tensor[stage_index][
                   ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    if sum(split_vector) == 0:
        return False
    # find ub split axis
    ub_cut_axis = 0
    for i, f in enumerate(split_vector):
        if f > 0:
            ub_cut_axis = i
            break
    ub_split_nlast_a_axis = ub_cut_axis in reduce_compute_graph_info.normal_axes_index[:-1]

    if "CacheWrite" in stage_type and "reduce" in stage_type:
        _do_emit_insn_for_reduce_stage(op_schedule_info, ub_split_nlast_a_axis)
    return True


def _do_emit_insn_for_reduce_stage(op_schedule_info, ub_split_nlast_a_axis):
    """
    :param op_schedule_info:
    :param ub_split_nlast_a_axis:
    :return:
    """
    stage_name = op_schedule_info.stage_name
    stage = op_schedule_info.stage
    stage_index = op_schedule_info.stage_index
    curr_axis_info_list = op_schedule_info.axis_info_list[stage_index]
    extra_space = get_use_ub_size(op_schedule_info)

    emit_insn_axis, emit_insn_axis_index, emit_insn_axis_obj = \
        _get_emit_insn_axis(curr_axis_info_list, ub_split_nlast_a_axis)
    if op_schedule_info.op_pattern == ComputePattern.TUPLE_REDUCE:
        attrs = {'storage_bound': extra_space // 2, "reduce_opt_mode": "dichotomy_reduce", "reuse_src_tensor": True,
                 "nlast_reduce_dichotomy": 16}
    else:
        attrs = {'storage_bound': extra_space}

    intrinsic_func_name = op_schedule_info.op_intrin_key_index[
        op_schedule_info.feature_tensor[stage_index][FeatureTensorCfg.compute_s]].intrin
    code_line = f"sch[{stage_name}].emit_insn({emit_insn_axis.name}, '{intrinsic_func_name}', {str(attrs)})"
    op_schedule_info.code_lines.append(code_line)
    stage.emit_insn(emit_insn_axis_obj, intrinsic_func_name, attrs=attrs)
    # gen emit_insn cheque
    cheque = get_emit_insn_cheque(stage_index, intrinsic_func_name,
                         (emit_insn_axis.name, emit_insn_axis_index), extra_info=attrs)
    op_schedule_info.cheque_list.append(cheque)
    op_schedule_info.proc_flag_dict[stage_index] = True


def _get_emit_insn_axis(curr_axis_info_list, ub_split_nlast_a_axis):
    """
    :param curr_axis_info_list:
    :param ub_split_nlast_a_axis:
    :return:
    """
    emit_insn_axis = None
    emit_insn_axis_obj = None
    emit_insn_axis_index = None
    if ub_split_nlast_a_axis:
        # if ub split a axis but not nlast a axis, emit_insn_axis is the first reduce axis
        for axis_index, axis_info in enumerate(curr_axis_info_list):
            if axis_info.type == "reduce_axis":
                emit_insn_axis = axis_info
                emit_insn_axis_obj = emit_insn_axis.body
                emit_insn_axis_index = axis_index
                break
    else:
        # reduce ub stage emit insn axis is inner axis for normal
        for axis_index, axis_info in enumerate(curr_axis_info_list):
            if axis_info.name.endswith('i'):
                emit_insn_axis = axis_info
                emit_insn_axis_obj = emit_insn_axis.body
                emit_insn_axis_index = axis_index
                break
    return emit_insn_axis, emit_insn_axis_index, emit_insn_axis_obj
