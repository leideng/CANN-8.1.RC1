#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
common apply action
"""
from typing import NoReturn
from typing import List

from tbe import tvm
from tbe.tvm import Stage

from auto_search.bank.cheque_generator import get_storage_align_cheque_enhance
from auto_search.bank.cheque_generator import get_storage_align_cheque
from auto_search.utils import util
from auto_search.utils import logger
from auto_search.solution_space.action import apply_action_register
from auto_search.solution_space.action import ScheduleActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.t2c_util import MODE_RUNTIME
from auto_search.solution_space.progress import Progress


def need_align_stage_proc(progress: Progress, stage_index: int) -> bool:
    """
    :param progress:
    :param stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage = op_schedule_info.schedule_obj.stages[stage_index]

    if op_schedule_info.compute_graph_info.is_last_reduce and \
        op_schedule_info.stages_info[stage_index].get("at_info").index in \
            op_schedule_info.compute_graph_info.after_reduce_tensor_indxe_list:
        return False

    if isinstance(stage.op, tvm.PlaceholderOp):
        return False

    if stage_index in op_schedule_info.inlined_stages:
        return False

    if 'src_align_pad' in op_schedule_info.stages_info[stage_index].get('type', []):
        return False
    if 'remove_pad' in op_schedule_info.stages_info[stage_index].get('type', []):
        return False

    if op_schedule_info.stages_info[stage_index].get('scope', '') != "local.UB":
        return False

    return True


def do_storage_align(progress: Progress, need_align_stage_index_list: List[int]) -> NoReturn:
    """
    :param progress:
    :param need_align_stage_index_list:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = []
    code_lines.extend(['\n', '# storage_align code begin'])
    for align_stage_index in need_align_stage_index_list:
        stage = op_schedule_info.schedule_obj.stages[align_stage_index]
        stage_name = op_schedule_info.stages_info[align_stage_index]["name"]
        vector_block_num = util.get_block_num(stage.op.output(0).dtype)
        align_axis_name, align_axis_index, align_axis = get_align_axis(progress, stage, align_stage_index)
        align_code = 'sch[{}].storage_align({}, {}, 0)'.format(stage_name, align_axis_name, vector_block_num)
        code_lines.append(align_code)
        if op_schedule_info.mode == MODE_RUNTIME:
            stage.storage_align(align_axis, vector_block_num, 0)

        if "[" in align_axis_name and "]" in align_axis_name:
            cheque = get_storage_align_cheque(align_stage_index, align_axis_index, vector_block_num)
        else:
            cheque = get_storage_align_cheque_enhance(align_stage_index, (align_axis_name, align_axis_index),
                                                      vector_block_num)
        op_schedule_info.cheque_list.append(cheque)

    op_schedule_info.code_lines.extend(code_lines)


def get_align_axis(progress: Progress,  stage: Stage, align_stage_index: int) -> tuple:
    """
    get leaf_iter_vars -2 axis
    :param progress:
    :param stage:
    :param align_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_name = op_schedule_info.stages_info[align_stage_index]["name"]
    align_axis_index = None
    align_axis_name = None
    align_axis = None
    if len(stage.leaf_iter_vars) <= 1:
        logger.debug("current stage axis len is small than 1, no need storage align!")
        return align_axis_name, align_axis_index, align_axis

    leaf_axis_index = len(stage.leaf_iter_vars) - 2
    for i in range(len(stage.leaf_iter_vars)-1, -1, -1):
        if i < leaf_axis_index:
            break
        if stage.leaf_iter_vars[i] in stage.op.reduce_axis:
            leaf_axis_index -= 1
    align_axis = stage.leaf_iter_vars[leaf_axis_index]
    if op_schedule_info.axis_info_list[align_stage_index] is None:
        for axis_index, op_axis in enumerate(stage.op.axis):
            if op_axis == align_axis:
                align_axis_index = axis_index
                break
        if align_axis_index is None:
            align_axis_index = len(stage.op.axis) - 2
        align_axis_name = 'sch[{}].op.axis[{}]'.format(stage_name, align_axis_index)
        return align_axis_name, align_axis_index, align_axis

    for axis_index, axis_info in enumerate(op_schedule_info.axis_info_list[align_stage_index]):
        if axis_info.body == align_axis:
            align_axis_index = axis_index
            align_axis_name = axis_info.name
            break
    if align_axis_index is None:
        raise RuntimeError("current stage cant find align axis!")
    return align_axis_name, align_axis_index, align_axis


@apply_action_register([ComputePattern.NORM], ScheduleActionType.STORAGE_ALIGN)
def apply_for_norm(progress):
    """
    apply for transpose
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    reduce_stage_index = None
    for stage_index, _ in enumerate(op_schedule_info.schedule_obj.stages):
        stage_type = op_schedule_info.stages_info[stage_index].get('type', [])
        if "CacheWrite" in stage_type and "reduce" in stage_type:
            reduce_stage_index = stage_index
            break

    if reduce_stage_index is None:
        return

    if op_schedule_info.is_ub_transpose:
        return

    # need_align_stage_index_list
    need_align_stage_index_list_new = []
    for stage_index, _ in enumerate(progress.op_schedule_info.stages_info):
        if need_align_stage_proc(progress, stage_index):
            need_align_stage_index_list_new.append(stage_index)

    do_storage_align(progress, need_align_stage_index_list_new)

    logger.debug("apply norm storage_align done.")
