#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
broadcast apply action
"""
from typing import List
from typing import NoReturn

from tbe.tvm import Stage

from auto_search.bank.cheque_generator import get_compute_align_cheque
from auto_search.utils import util
from auto_search.utils import logger
from auto_search.solution_space.action import apply_action_register
from auto_search.solution_space.action import ScheduleActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.progress import Progress


@apply_action_register([ComputePattern.BROADCAST], ScheduleActionType.COMPUTE_ALIGN)
def apply_for_broadcast(progress):
    """
    apply for transpose
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    cache_read_index_list = []
    for stage_index, _ in enumerate(op_schedule_info.schedule_obj.stages):
        stage_type = op_schedule_info.stages_info[stage_index].get('type', [])
        if "broadcast_remove_pad" in stage_type:
            cache_read_index_list.append(stage_index)

    if not cache_read_index_list:
        # if don't have remove pad cache_read stage, need not do compute_align
        return
    all_fanin_set = set()
    for cache_read_index in cache_read_index_list:
        all_fanin_set = all_fanin_set | set(op_schedule_info.all_fanin_dict[cache_read_index])
    all_fanin_list = list(all_fanin_set)
    # need_align_stage_index_list
    need_align_stage_index = []
    for stage_index, _ in enumerate(progress.op_schedule_info.stages_info):
        if _need_align_stage_proc(progress, stage_index, all_fanin_list):
            need_align_stage_index.append(stage_index)
    # Update the stage that needs to be compute_align to op_schedule_info
    op_schedule_info.compute_align_index = need_align_stage_index

    logger.debug("all need storage align stage index is %s", need_align_stage_index)

    _do_compute_align(progress, need_align_stage_index)

    logger.debug("apply compute align done.")


def _need_align_stage_proc(progress: Progress, stage_index: int, all_fanin_list: List) -> bool:
    """
    :param progress:
    :param stage_index:
    :param all_fanin_list:
    :return:
    """
    op_schedule_info = progress.op_schedule_info

    if 'CacheWrite' not in op_schedule_info.stages_info[stage_index].get('type', []):
        return False

    if stage_index in op_schedule_info.inlined_stages:
        return False

    if stage_index not in all_fanin_list:
        return False

    return True


def _do_compute_align(progress: Progress, need_align_stage_index_list: List[int]) -> NoReturn:
    """
    :param progress:
    :param need_align_stage_index_list:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = []
    code_lines.extend(['\n', '# compute_align code begin'])
    for align_stage_index in need_align_stage_index_list:
        stage = op_schedule_info.schedule_obj.stages[align_stage_index]
        stage_name = op_schedule_info.stages_info[align_stage_index]["name"]
        vector_block_num = util.get_block_num(stage.op.output(0).dtype)
        align_axis_name, align_axis_index, align_axis = _get_align_axis(progress, stage, align_stage_index)
        align_code = 'sch[{}].compute_align({}, {})'.format(stage_name, align_axis_name, vector_block_num)
        code_lines.append(align_code)

        stage.compute_align(align_axis, vector_block_num)
        cheque = get_compute_align_cheque(align_stage_index, align_axis_index, vector_block_num, 0)
        op_schedule_info.cheque_list.append(cheque)

    op_schedule_info.code_lines.extend(code_lines)


def _get_align_axis(progress: Progress,  stage: Stage, align_stage_index: int) -> tuple:
    """
    get leaf_iter_vars -1 axis
    :param progress:
    :param stage:
    :param align_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_name = op_schedule_info.stages_info[align_stage_index]["name"]
    align_axis_index = None
    align_axis_name = None
    align_axis = None
    if len(stage.leaf_iter_vars) <= 0:
        logger.debug("current stage axis len is small than 1, no need compute align!")
        return align_axis_name, align_axis_index, align_axis
    align_axis = stage.leaf_iter_vars[-1]
    for axis_index, op_axis in enumerate(stage.op.axis):
        if op_axis == align_axis:
            align_axis_index = axis_index
            break
    if align_axis_index is None:
        raise RuntimeError("current stage can't find align axis!")
    align_axis_name = 'sch[{}].op.axis[{}]'.format(stage_name, align_axis_index)
    return align_axis_name, align_axis_index, align_axis
