#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
common director
"""
from math import factorial

from auto_search.solution_space.comm import get_split_sub_tree_depth
from auto_search.solution_space.action import director_register
from auto_search.solution_space.action import ScheduleActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.schedule_action.cache_read.cache_read_action import CacheReadAction
from auto_search.solution_space.schedule_action.cache_write.cache_write_action import CacheWriteAction
from auto_search.solution_space.search_action.reorder.reorder_action import ReorderAction
from auto_search.solution_space.schedule_action.inline.director.broadcast_director import remove_pad_for_broadcast


@director_register([ComputePattern.ELEMENTWISE, ComputePattern.REDUCE, ComputePattern.POOLING,
                    ComputePattern.TUPLE_REDUCE],
                   ScheduleActionType.CACHE_READ)
def direct(progress):
    """
    generic cache read direct
    :param progress:
    :return:
    """
    stages_info = progress.op_schedule_info.stages_info
    pattern = progress.op_schedule_info.op_pattern
    for stage_index, stage_info in enumerate(stages_info):
        if {'placeholder', 'workspace', 'inter_out'} & set(stage_info.get('type', [])) \
                and 'src_cache_read' not in stage_info.get('type', []):
            next_action = CacheReadAction(pattern, stage_index)
            progress.todo = next_action
            return

    if progress.op_schedule_info.is_align_pad:
        for stage_index, stage_info in enumerate(stages_info):
            if {'CacheRead'} & set(stage_info.get('type', [])) \
                    and not {'src_cache_read', 'align_pad'} & set(stage_info.get('type', [])):
                next_action = CacheReadAction(pattern, stage_index)
                progress.todo = next_action
                return

    for stage_index, stage_info in enumerate(stages_info):
        if 'placeholder' not in stage_info.get('type', []) \
                and stage_info.get('scope', '') not in ['local.UB']:
            next_action = CacheWriteAction(pattern, stage_index)
            progress.todo = next_action
            return


@director_register([ComputePattern.NORM], ScheduleActionType.CACHE_READ)
def norm_direct(progress):
    """
    generic cache read direct
    :param progress:
    :return:
    """
    stages_info = progress.op_schedule_info.stages_info
    pattern = progress.op_schedule_info.op_pattern
    for stage_index, stage_info in enumerate(stages_info):
        if {'placeholder', 'workspace', 'inter_out'} & set(stage_info.get('type', [])) \
                and 'src_cache_read' not in stage_info.get('type', []):
            next_action = CacheReadAction(pattern, stage_index)
            progress.todo = next_action
            return

    if progress.op_schedule_info.is_align_pad:
        for stage_index, stage_info in enumerate(stages_info):
            ori_index = stage_info.get('at_info').index
            if {'CacheRead'} & set(stage_info.get('type', [])) \
                    and not {'src_cache_read', 'align_pad'} & set(stage_info.get('type', [])) \
                    and ori_index in progress.op_schedule_info.compute_graph_info.align_pad_tensor_list:
                next_action = CacheReadAction(pattern, stage_index)
                progress.todo = next_action
                return

    for stage_index, stage_info in enumerate(stages_info):
        if 'placeholder' not in stage_info.get('type', []) \
                and stage_info.get('scope', '') not in ['local.UB']:
            next_action = CacheWriteAction(pattern, stage_index)
            progress.todo = next_action
            return


@director_register([ComputePattern.TRANSPOSE], ScheduleActionType.CACHE_READ)
def transpose_direct(progress):
    """
    transpose cache read direct
    :param progress:
    :return:
    """
    pattern = progress.op_schedule_info.op_pattern
    stage_index = progress.todo.stage_index
    nonzero_axes = progress.get_nonzero_axes(0)
    permutation_num = factorial(len(nonzero_axes))
    sub_tree_depth = get_split_sub_tree_depth(permutation_num)
    progress.todo = ReorderAction(pattern, stage_index + 1, sub_tree_depth - 1)


@director_register([ComputePattern.BROADCAST], ScheduleActionType.CACHE_READ)
def broadcast_direct(progress):
    """
    generic cache read direct
    :param progress:
    :return:
    """
    stages_info = progress.op_schedule_info.stages_info
    pattern = progress.op_schedule_info.op_pattern
    for stage_index, stage_info in enumerate(stages_info):
        if {'placeholder', 'workspace', 'inter_out'} & set(stage_info.get('type', [])) \
                and 'src_cache_read' not in stage_info.get('type', []):
            next_action = CacheReadAction(pattern, stage_index)
            progress.todo = next_action
            return

    for stage_index, stage_info in enumerate(stages_info):
        if 'placeholder' not in stage_info.get('type', []) \
                and stage_info.get('scope', '') not in ['local.UB'] \
                and not {'virtual_leaf_out', 'src_cache_write'} & set(stage_info.get('type', [])):
            next_action = CacheWriteAction(pattern, stage_index)
            progress.todo = next_action
            return

    remove_pad_for_broadcast(progress)
