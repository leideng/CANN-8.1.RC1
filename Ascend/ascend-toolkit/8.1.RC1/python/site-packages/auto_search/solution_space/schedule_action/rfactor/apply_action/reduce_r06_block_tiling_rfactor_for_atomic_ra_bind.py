#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reduce_r06_block_tiling_rfactor_for_atomic_ra_bind
"""
import copy
import math

from tbe import tvm
from tbe.common.platform import platform_info

from auto_search.compute_analysis import StageOrderedAxes
from auto_search.compute_analysis.reduce_compute_graph import _calculate_r0_a0_factor
from auto_search.utils import logger
from auto_search.config import soc_cfg
from auto_search.solution_space.tensor_cfg import AxisInfo, ActionTensorCfg
from auto_search.solution_space import t2c_util
from auto_search.solution_space.schedule_action.split.apply_action import reduce_comm
from auto_search.solution_space.progress import Progress
from auto_search.bank.cheque_generator import get_split_cheque
from auto_search.bank.cheque_generator import get_axis_cheque
from auto_search.bank.cheque_generator import get_rfactor_cheque
from auto_search.bank.cheque_generator import get_set_scope_cheque
from auto_search.bank.cheque_generator import get_cache_write_cheque
from auto_search.bank.cheque_generator import get_cache_write_cheque_spec
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r05_block_tiling_rfactor_for_atomic import \
    update_stages_relevant_info


def _get_axis_index_in_all_axes(stage, axis_obj):
    """
    get axis_index in all axes for generating cheque_list
    :param stage:
    :param axis_obj:
    :return:
    """
    # get block_split_info.axis_obj in all axis index
    all_axes = list(stage.leaf_iter_vars)
    axis_index_in_all_axes = 0
    for axis_idx, axis in enumerate(all_axes):
        if axis == axis_obj:
            axis_index_in_all_axes = axis_idx
            break
    return axis_index_in_all_axes


def _gen_r0a0_split_info(op_schedule_info, reduce_gm_stage_index):
    """
    gen r0 and a0 split info
    :param op_schedule_info:
    :param reduce_gm_stage_index:
    :return:
    """
    reduce_compute_graph = op_schedule_info.compute_graph_info
    reduce_stage_info = op_schedule_info.stages_info[reduce_gm_stage_index]
    reduce_stage = op_schedule_info.schedule_obj.stages[reduce_gm_stage_index]
    stage_reduce_axis_objs = reduce_stage.op.reduce_axis

    # calculate r0_factor and a0_factor for ra bind multicore
    r0_split_axis_index = 0
    a0_split_axis_index = 1
    r0_factor, a0_factor = _calculate_r0_a0_factor(reduce_compute_graph, r0_split_axis_index, a0_split_axis_index)

    # gen r0 split info
    r0_split_info = reduce_comm.gen_split_info(
        factor=r0_factor,
        axis_index=r0_split_axis_index,
        axis_name=f"{reduce_stage_info.get('name')}_reduce_axis_{r0_split_axis_index}",
        axis_obj=stage_reduce_axis_objs[r0_split_axis_index])

    # gen a0 split info
    a0_split_info = reduce_comm.gen_split_info(
        factor=a0_factor,
        axis_index=a0_split_axis_index)

    return r0_split_info, a0_split_info


def _do_r0_split(op_schedule_info, code_lines, r0_split_info, reduce_gm_stage_index):
    """
    do r0 split
    :param op_schedule_info:
    :param code_lines:
    :param r0_split_info:
    :param reduce_gm_stage_index:
    :return:
    """
    stage = op_schedule_info.schedule_obj.stages[reduce_gm_stage_index]
    stage_name = op_schedule_info.stages_info[reduce_gm_stage_index].get('name')
    outer_axis_name = '%s_o' % r0_split_info.axis_name
    inner_axis_name = '%s_i' % r0_split_info.axis_name
    code_lines.append(
        '%s, %s = sch[%s].split(sch[%s].op.reduce_axis[%d], factor=%d)' %
        (outer_axis_name,
         inner_axis_name,
         stage_name,
         stage_name,
         r0_split_info.axis_index,
         r0_split_info.factor))

    # get r0_split_info.axis_obj in all axis index
    axis_index_in_all_axes = _get_axis_index_in_all_axes(stage, r0_split_info.axis_obj)

    # r0 split
    r0_split_axis_obj_o, r0_split_axis_obj_i = \
        stage.split(r0_split_info.axis_obj, factor=r0_split_info.factor)

    # gen block_split_info
    r0_split_info = reduce_comm.gen_split_info(r0_split_info,
                                               outer_axis_name=outer_axis_name,
                                               outer_axis_obj=r0_split_axis_obj_o,
                                               inner_axis_name=inner_axis_name,
                                               inner_axis_obj=r0_split_axis_obj_i)

    # gen cheque
    cheque = get_split_cheque(reduce_gm_stage_index, axis_index_in_all_axes, r0_split_info.factor)
    op_schedule_info.cheque_list.append(cheque)

    return r0_split_info


def _get_reduce_tag(reduce_stage):
    """
    get reduce info, get reduce tag
    :param reduce_stage:
    :return:
    """
    # get reduce's type
    reduce_type = t2c_util.REDUCE_NIST_KEYWORD
    source_axis_vars = reduce_stage.op.body[0].source[0].indices
    for reduce_axis in reduce_stage.op.reduce_axis:
        if reduce_axis.var.same_as(source_axis_vars[-1]):
            reduce_type = t2c_util.REDUCE_LAST_KEYWORD
            break
    # get reduce tag
    reduce_op_tag = reduce_stage.origin_op.tag + reduce_type
    return reduce_type, reduce_op_tag


def _rfactor_proc(progress, code_lines, reduce_gm_stage_index, reduce_tensors, rfactor_axis_info):
    """
    do rfactor
    :param progress:
    :param code_lines:
    :param reduce_gm_stage_index:
    :param reduce_tensors:
    :param rfactor_axis_info:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    # get reduce tag
    reduce_type, reduce_op_tag = _get_reduce_tag(op_schedule_info.schedule_obj.stages[reduce_gm_stage_index])

    # rfactor code_lines
    rfactor_axis_name, rfactor_axis_obj = rfactor_axis_info
    reduce_stage_name = op_schedule_info.stages_info[reduce_gm_stage_index].get('name')
    rfactor_stage_name = f'{reduce_stage_name}_rfactor'
    if len(reduce_tensors) > 1:
        rfactor_codes = f'sch.rfactor({reduce_stage_name}, {rfactor_axis_name}, factor_axis=-1)[0]'
    else:
        rfactor_codes = f'sch.rfactor({reduce_stage_name}, {rfactor_axis_name}, factor_axis=-1)'
    rfactor_codes = f'{rfactor_stage_name} = {rfactor_codes}'
    code_lines.append(rfactor_codes)
    code_lines.append(f"sch[{rfactor_stage_name}].set_scope('{platform_info.scope_ubuf}')")

    # get rfactor_axis_obj in all axis index
    axis_index_in_all_axes = \
        _get_axis_index_in_all_axes(op_schedule_info.schedule_obj.stages[reduce_gm_stage_index], rfactor_axis_obj)

    # notice: rfactor object is the op in original compute, not stage.op, is stage.origin_op
    if len(reduce_tensors) > 1:
        rfactor_tensor = op_schedule_info.schedule_obj.rfactor(reduce_tensors[0], rfactor_axis_obj, factor_axis=-1)[0]
    else:
        rfactor_tensor = op_schedule_info.schedule_obj.rfactor(reduce_tensors[0], rfactor_axis_obj, factor_axis=-1)
    if not isinstance(rfactor_tensor, tvm.Tensor):
        logger.error("rfactor tensor type should be Tensor!")
    op_schedule_info.schedule_obj[rfactor_tensor].set_scope(platform_info.scope_ubuf)

    # after do rfactor, will gen a new stage, add a new stage_info to stages_info
    at_info = copy.deepcopy(op_schedule_info.stages_info[reduce_gm_stage_index].get('at_info'))
    op_schedule_info.stages_info.insert(
        reduce_gm_stage_index,
        {
            'name': rfactor_stage_name,
            'type': ['reduce_atomic_rfactor'],
            'scope': platform_info.scope_ubuf,
            'op_tag': reduce_op_tag,
            'reduce_type': reduce_type,
            'at_info': at_info,
            'split_axis_type': op_schedule_info.stages_info[reduce_gm_stage_index].get('split_axis_type', None)
        }
    )

    # gen rfactor cheque
    cheque = get_rfactor_cheque(reduce_gm_stage_index, axis_index_in_all_axes, -1)
    op_schedule_info.cheque_list.append(cheque)
    # gen set_scope cheque
    cheque = get_set_scope_cheque(reduce_gm_stage_index, platform_info.scope_ubuf)
    op_schedule_info.cheque_list.append(cheque)


def _do_rfactor(progress, code_lines, reduce_gm_stage_index, r0_split_info, reduce_tensors):
    """
    do rfactor
    :param progress:
    :param code_lines:
    :param reduce_gm_stage_index:
    :param r0_split_info:
    :param reduce_tensors:
    :return:
    """
    _rfactor_proc(progress, code_lines, reduce_gm_stage_index,
                  reduce_tensors, [r0_split_info.outer_axis_name, r0_split_info.outer_axis_obj])

    # after rfactor and before split, gen current stage all axis cheque
    axis_cheque_list = \
        get_axis_cheque(progress.op_schedule_info.schedule_obj.stages[reduce_gm_stage_index], reduce_gm_stage_index)
    progress.op_schedule_info.cheque_list.extend(axis_cheque_list)


def _do_gm_cache_write(progress, code_lines, reduce_gm_stage_index, reduce_tensors):
    """
    do gm cache write
    :param progress:
    :param code_lines:
    :param reduce_gm_stage_index:
    :param reduce_tensors:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    reduce_stage_name = op_schedule_info.stages_info[reduce_gm_stage_index].get('name')
    write_stage_name = f"{reduce_stage_name}_l"
    # tuple reduce sum
    if len(reduce_tensors) > 1:
        reduce_tensor_names = []
        write_tensor_names = []
        for index in range(len(reduce_tensors)):
            reduce_tensor_names.append('%s_v%d' % (reduce_stage_name, index))
            write_tensor_names.append('%s_v%d_l' % (reduce_stage_name, index))
        code_lines.append("{} = sch.cache_write({}, '')".format(", ".join(write_tensor_names),
                                                                "[" + ", ".join(reduce_tensor_names) + "]"))
        code_lines.append('{} = {}'.format(write_stage_name, write_tensor_names[0]))
        write_tensors = op_schedule_info.schedule_obj.cache_write(reduce_tensors, "")
        cheque = get_cache_write_cheque_spec(reduce_gm_stage_index, "", len(reduce_tensors))
        progress.op_schedule_info.cheque_list.append(cheque)
    # single output
    else:
        code_lines.append(f"{write_stage_name} = sch.cache_write({reduce_stage_name}, '')")
        # reduce_tensors and write_tensors type are all list
        write_tensors = op_schedule_info.schedule_obj.cache_write(reduce_tensors, "")
        write_tensor_names = [write_stage_name]

        # gen cache_write cheque
        cheque = get_cache_write_cheque(reduce_gm_stage_index, "")
        op_schedule_info.cheque_list.append(cheque)

    # after cache write, stage index will change
    write_stage_index = reduce_gm_stage_index

    # add reduce_write stage_info to stages_info
    at_info = copy.deepcopy(op_schedule_info.stages_info[reduce_gm_stage_index].get('at_info'))
    op_schedule_info.stages_info.insert(
        write_stage_index,
        {
            'name': write_stage_name,
            'type': ['CacheWrite', 'reduce_atomic_write'],
            'scope': "",
            'at_info': at_info
        }
    )

    return write_tensor_names, write_tensors


def _gen_a_stage_axis_info(progress, stage_index, a0_split_info):
    """
    gen a stage axis info
    :param progress:
    :param stage_index:
    :param a0_split_info:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    stage_name = op_schedule_info.stages_info[stage_index].get('name')
    stage = op_schedule_info.schedule_obj.stages[stage_index]

    stage_axis_info = []
    for axis_index, axis in enumerate(stage.op.axis):
        axis_name = f'{stage_name}_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.axis[axis_index].dom.extent.value,
                                        'axis', axis_index, 'axis', axis))

    for axis_index, axis in enumerate(stage.op.reduce_axis):
        axis_name = f'{stage_name}_reduce_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.reduce_axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.reduce_axis[axis_index].dom.extent.value,
                                        'reduce_axis', axis_index, 'reduce_axis', axis))

    axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[stage_index], stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)

    return stage_axis_info


def _do_a0_split(op_schedule_info, code_lines, a0_split_info, reduce_write_stage_index, reduce_write_stage_axis_info):
    """
    do a0 split
    :param op_schedule_info:
    :param code_lines:
    :param a0_split_info:
    :param reduce_write_stage_index:
    :param reduce_write_stage_axis_info:
    :return:
    """
    stage = op_schedule_info.schedule_obj.stages[reduce_write_stage_index]
    stage_name = op_schedule_info.stages_info[reduce_write_stage_index].get('name')
    a0_split_axis_name = f"{stage_name}_axis_{a0_split_info.axis_index}"
    outer_axis_name = '%s_o' % a0_split_axis_name
    inner_axis_name = '%s_i' % a0_split_axis_name
    code_lines.extend(['\n', '# block tiling: split a0'])
    code_lines.append(
        '%s, %s = sch[%s].split(%s, factor=%d)' %
        (outer_axis_name,
         inner_axis_name,
         stage_name,
         a0_split_axis_name,
         a0_split_info.factor))

    a0_split_axis_obj = stage.op.axis[a0_split_info.axis_index]

    # get a0_split_axis_obj in all axis index
    axis_index_in_all_axes = _get_axis_index_in_all_axes(stage, a0_split_axis_obj)

    # a0 split
    a0_split_axis_obj_o, a0_split_axis_obj_i = \
        stage.split(a0_split_axis_obj, factor=a0_split_info.factor)

    # gen block_split_info
    a0_split_info = reduce_comm.gen_split_info(a0_split_info,
                                               axis_name=a0_split_axis_name,
                                               axis_obj=a0_split_axis_obj,
                                               outer_axis_name=outer_axis_name,
                                               outer_axis_obj=a0_split_axis_obj_o,
                                               inner_axis_name=inner_axis_name,
                                               inner_axis_obj=a0_split_axis_obj_i)

    # gen cheque
    cheque = get_split_cheque(reduce_write_stage_index, axis_index_in_all_axes, a0_split_info.factor)
    op_schedule_info.cheque_list.append(cheque)

    # axis_info_list update
    del reduce_write_stage_axis_info[a0_split_info.axis_index]
    axis_o_len = math.floor((a0_split_axis_obj.dom.extent.value + a0_split_info.factor - 1) / a0_split_info.factor)
    reduce_write_stage_axis_info.insert(a0_split_info.axis_index,
                                        AxisInfo(a0_split_info.outer_axis_name, axis_o_len,
                                                 'axis', a0_split_info.axis_index, 'o', a0_split_info.outer_axis_obj))
    reduce_write_stage_axis_info.insert(a0_split_info.axis_index + 1,
                                        AxisInfo(a0_split_info.inner_axis_name, a0_split_info.factor,
                                                 'axis', a0_split_info.axis_index, 'i', a0_split_info.inner_axis_obj))

    return a0_split_info


def _get_ub_split_axis_index_and_factor(op_schedule_info, reduce_gm_stage_index, reduce_stage_info, split_axis_obj,
                                        split_vector):
    """
    :param op_schedule_info:
    :param reduce_gm_stage_index:
    :param reduce_stage_info:
    :param split_axis_obj:
    :param split_vector:
    :return:
    """
    ub_split_axis_index = len(split_axis_obj) - 1
    ub_split_factor = 1
    if 'stage_ordered_axes_obj' not in reduce_stage_info:
        reduce_stage_info['stage_ordered_axes_obj'] = \
            StageOrderedAxes(op_schedule_info.schedule_obj.stages, reduce_gm_stage_index)
    ordered_axes_obj: StageOrderedAxes = reduce_stage_info.get('stage_ordered_axes_obj', None)
    for axis_index, factor in enumerate(split_vector):
        # find first not zero factor is split axis
        if factor != 0:
            # axis_index is the index in reduce stage's reduce_before_shape,
            # here need get index in reduce_axis or axis
            ub_split_axis_index = ordered_axes_obj.get_index_within_type(axis_index)
            ub_split_factor = factor
            break
    return ub_split_axis_index, ub_split_factor


def _get_ub_tiling(progress, code_lines, reduce_gm_stage_index: int):
    """
    get ub tiling info
    :param progress:
    :param code_lines:
    :param reduce_gm_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    reduce_stage_info = op_schedule_info.stages_info[reduce_gm_stage_index]
    reduce_stage_name = reduce_stage_info.get('name')
    ub_split_axis_type = reduce_stage_info.get('split_axis_type', None)
    if ub_split_axis_type is None:
        raise RuntimeError("atomic ub_split_axis_type must be set as 'axis' or 'reduce_axis'!")
    split_vector = progress.action_tensor[reduce_gm_stage_index][
                   ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    split_axis_obj = op_schedule_info.schedule_obj.stages[reduce_gm_stage_index].op.reduce_axis
    if ub_split_axis_type == 'axis':
        split_axis_obj = op_schedule_info.schedule_obj.stages[reduce_gm_stage_index].op.axis
    ub_split_axis_index, ub_split_factor = \
        _get_ub_split_axis_index_and_factor(op_schedule_info, reduce_gm_stage_index,
                                            reduce_stage_info, split_axis_obj,
                                            split_vector)

    # stage's reduce axis will changed，record ub_split_axis
    prefix = "reduce_axis"
    if ub_split_axis_type == 'axis':
        prefix = "axis"
    ub_split_axis_name = f'ub_split_{prefix}'
    code_lines.append(f'{ub_split_axis_name} = sch[{reduce_stage_name}].op.{prefix}[{ub_split_axis_index}]')

    ub_split_info = reduce_comm.gen_split_info(
        factor=ub_split_factor,
        axis_index=ub_split_axis_index,
        axis_name=ub_split_axis_name,
        axis_obj=split_axis_obj[ub_split_axis_index])
    return ub_split_info


def proc(progress: Progress):
    """
    reduce atomic ra bind rfactor
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    if not op_schedule_info.is_atomic:
        return

    stages = list(op_schedule_info.schedule_obj.stages)
    # atomic last stage need be reduce stage
    reduce_gm_stage_index = len(stages) - 1
    if 'reduce_atomic' not in op_schedule_info.stages_info[reduce_gm_stage_index].get('type', []):
        logger.error("last stage is not reduce_atomic stage!")
        return

    logger.debug("enable tuple_reduce atomic ra bind optimization.")

    code_lines = op_schedule_info.code_lines
    code_lines.append('# enable atomic ra bind')

    # gen split stage all axes cheque
    axis_cheque_list = \
        get_axis_cheque(op_schedule_info.schedule_obj.stages[reduce_gm_stage_index], reduce_gm_stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)

    reduce_compute_graph = op_schedule_info.compute_graph_info
    reduce_compute_graph.reduce_tensors = [
        op_schedule_info.schedule_obj.outputs[0].output(idx)
        for idx in range(op_schedule_info.schedule_obj.outputs[0].num_outputs)
    ]
    reduce_compute_graph.reduce_stage = stages[reduce_gm_stage_index]

    # save ub_split_info
    ub_split_info = _get_ub_tiling(progress, code_lines, reduce_gm_stage_index)
    op_schedule_info.atomic_ub_split_info = ub_split_info

    # now: only r0a0r1a1 case enable ra bind
    # gen ra split info
    r0_split_info, a0_split_info = _gen_r0a0_split_info(op_schedule_info, reduce_gm_stage_index)

    # r0 split
    r0_split_info = _do_r0_split(op_schedule_info, code_lines, r0_split_info, reduce_gm_stage_index)

    # do rfactor
    _do_rfactor(progress, code_lines, reduce_gm_stage_index, r0_split_info, reduce_compute_graph.reduce_tensors)
    # rfactor_stage and reduce_gm_stage will change after do rfactor
    rfactor_stage_index = reduce_gm_stage_index
    reduce_gm_stage_index = rfactor_stage_index + 1

    # reduce gm stage do cache_write
    reduce_write_tensor_names, reduce_write_tensors = \
        _do_gm_cache_write(progress, code_lines, reduce_gm_stage_index, reduce_compute_graph.reduce_tensors)
    # after do cache_write, add a cache_write stage，stage_index need update
    reduce_write_stage_index = reduce_gm_stage_index
    reduce_gm_stage_index = reduce_write_stage_index + 1

    # get cache_write stage axis_info
    reduce_write_stage_axis_info = _gen_a_stage_axis_info(progress, reduce_write_stage_index, a0_split_info)

    # a0 split
    a0_split_info = _do_a0_split(op_schedule_info, code_lines, a0_split_info,
                                 reduce_write_stage_index, reduce_write_stage_axis_info)
    op_schedule_info.atomic_block_split_info = a0_split_info


    # axis_info_list is [] now need create
    stage_num = len(op_schedule_info.schedule_obj.stages)
    op_schedule_info.axis_info_list = [[]] * stage_num
    op_schedule_info.axis_info_list[reduce_write_stage_index] = reduce_write_stage_axis_info

    # add two stage need update something
    update_stages_relevant_info(progress,
                                reduce_gm_stage_index,
                                reduce_write_tensor_names,
                                reduce_write_tensors)

    return
