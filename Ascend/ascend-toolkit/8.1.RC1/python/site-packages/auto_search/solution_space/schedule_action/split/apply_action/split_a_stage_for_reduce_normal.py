#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
auto schedule
"""
import math
from typing import List

from tbe.tvm import Stage
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.bank.cheque_generator import get_split_cheque
from auto_search.bank.cheque_generator import get_axis_cheque
from auto_search.compute_analysis import OrderedAxisInfo
from auto_search.bank.cheque_generator import get_axis_index
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.schedule_action.split.apply_action.reduce_comm import do_split


def get_axis_by_axis_info_wrapper(stage: Stage, axis_info_wrapper: OrderedAxisInfo) -> int:
    """
    :param stage:
    :param axis_info_wrapper:
    :return:
    """
    if axis_info_wrapper.prefix == 'reduce_':
        axes = stage.op.reduce_axis
    else:
        axes = stage.op.axis
    return axes[axis_info_wrapper.idx_by_type]


def handle_axis_info_wrapper(stage: Stage, axis_info_wrappers: List[OrderedAxisInfo], code_lines: List,
                             stage_name: str) -> AxisInfo:
    """
    :param stage:
    :param axis_info_wrappers:
    :param code_lines:
    :param stage_name:
    :return:
    """
    stage_axis_info = []
    for item in axis_info_wrappers:
        axis_name = '%s_%saxis_%d' % (stage_name, item.prefix, item.idx_by_type)
        code_lines.append('%s = sch[%s].op.%saxis[%d]' %
                          (axis_name, stage_name, item.prefix, item.idx_by_type))
        axis = get_axis_by_axis_info_wrapper(stage, item)
        stage_axis_info.append(
            AxisInfo(axis_name, item.dim,
                     f"{item.prefix}axis", item.idx_by_type, 'all', axis))
    return stage_axis_info


def _get_split_axis_and_factor(progress, stage_index, code_lines):
    """

    :param progress:
    :param stage_index:
    :return:
    """
    split_vector = progress.action_tensor[stage_index][
                   ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    cut_axis, factor = 0, 1
    for i, f in enumerate(split_vector):
        if f > 0:
            cut_axis, factor = i, f
            break
    code_lines.append(f'# split factor info: {list(split_vector)}')
    code_lines.append(f'# chosen split axis: {cut_axis}')
    return cut_axis, factor


def last_reduce_and_ub_split_nlast_reduce_axis_proc(progress: Progress, stage_index: int) -> tuple:
    """
    last reduce split nlast reduce axisï¼Œshould split rfactor stage
    :param progress:
    :param stage_index:
    :return:
    """
    code_lines = []
    cut_axis, factor = _get_split_axis_and_factor(progress, stage_index, code_lines)

    reduce_stage_info = progress.op_schedule_info.stages_info[stage_index + 1]
    reduce_ordered_axes_obj = reduce_stage_info['stage_ordered_axes_obj']
    cut_aiw = reduce_ordered_axes_obj.get_cut_axis_info_wrapper(cut_axis)
    cut_axis_in_reduce_axes = cut_aiw.idx_by_type

    code_lines.append(f'# cut_axis in reduce axes: {cut_axis_in_reduce_axes}')

    stage_axis_info = do_split(progress.op_schedule_info, stage_index, cut_axis_in_reduce_axes, factor, code_lines)

    return code_lines, stage_axis_info, cut_axis


def _other_do_split(stage, stage_info, code_lines, cut_axis, factor):
    """

    :param stage:
    :param stage_info:
    :param code_lines:
    :param cut_axis:
    :param factor:
    :return:
    """
    stage_name = stage_info.get('name', None)
    ordered_axes_obj = stage_info.get('stage_ordered_axes_obj', None)
    cut_aiw, a_aiw, r_aiw = ordered_axes_obj.get_axis_info_wrapper_with_cut_axis(cut_axis)

    a_stage_axis_info = handle_axis_info_wrapper(stage, a_aiw, code_lines, stage_name)
    r_stage_axis_info = handle_axis_info_wrapper(stage, r_aiw, code_lines, stage_name)

    axis_name = '%s_%saxis_%d' % (stage_name, cut_aiw.prefix, cut_aiw.idx_by_type)
    code_lines.append(
        '%s_o, %s_i = sch[%s].split(sch[%s].op.%saxis[%d],'
        ' factor=%d)' %
        (axis_name, axis_name, stage_name, stage_name,
         cut_aiw.prefix, cut_aiw.idx_by_type, factor))

    axis = get_axis_by_axis_info_wrapper(stage, cut_aiw)
    axis_o_len = math.floor((axis.dom.extent.value + factor - 1) / factor)

    axis_obj_o, axis_obj_i = stage.split(axis, factor=factor)
    if cut_aiw.prefix == 'reduce_':
        temp_stage_axis_info = r_stage_axis_info
    else:
        temp_stage_axis_info = a_stage_axis_info

    idx_with_type = ordered_axes_obj.get_index_within_type(cut_axis)
    temp_stage_axis_info.insert(idx_with_type,
                                AxisInfo(axis_name + "_o", axis_o_len,
                                         cut_aiw.prefix + 'axis', idx_with_type, 'o', axis_obj_o))
    temp_stage_axis_info.insert(idx_with_type + 1,
                                AxisInfo(axis_name + "_i", factor,
                                         cut_aiw.prefix + 'axis', idx_with_type, 'i', axis_obj_i))

    return a_stage_axis_info + r_stage_axis_info, axis_name + "_o"


def split_a_stage_for_reduce_normal(progress: Progress, stage_index: int) -> tuple:
    """
    do normal reduce split
    :param progress:
    :param stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_info = op_schedule_info.stages_info[stage_index]
    if op_schedule_info.last_reduce_and_ub_split_nlast_reduce_axis and 'reduce_rfactor' in stage_info.get('type'):
        return last_reduce_and_ub_split_nlast_reduce_axis_proc(progress, stage_index)

    code_lines = []

    stage = op_schedule_info.schedule_obj.stages[stage_index]
    cut_axis, factor = _get_split_axis_and_factor(progress, stage_index, code_lines)
    stage_axis_info, axis_o_name = _other_do_split(stage, stage_info, code_lines, cut_axis, factor)

    axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[stage_index], stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)
    split_axis_index = get_axis_index(stage_axis_info, axis_o_name)
    cheque = get_split_cheque(stage_index, split_axis_index, factor)
    op_schedule_info.cheque_list.append(cheque)

    return code_lines, stage_axis_info, cut_axis
