#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
split a stage
"""
import math
from typing import NoReturn
from typing import List
from typing import Tuple
from dataclasses import make_dataclass

from auto_search.utils import logger
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.bank.cheque_generator import get_split_cheque
from auto_search.bank.cheque_generator import get_axis_cheque
from auto_search.bank.cheque_generator import get_axis_index
from auto_search.utils.dynamic_util import UbSplitInfo
from auto_search.solution_space import t2c_util
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.op_schedule_info import OpScheduleInfo


SplitStageParam = make_dataclass("SplitStageParam",
                                 ["code_lines", "stage_axis_info", "stage_axis_obj", "split_vector",
                                  "stage", "stage_index", "stage_name", "cut_axis_index", "axis_type"])
SplitAxisParam = make_dataclass("SplitAxisParam", ["factor", "axis", "axis_index", "axis_name", "axis_len"])


def set_ub_split_info(op_schedule_info : OpScheduleInfo, split_stage_param: SplitStageParam,
                       split_axis_param: SplitAxisParam) -> NoReturn:
    """
    generate BlockSplitInfo for infer_range
    :param op_schedule_info:
    :param split_stage_param:
    :param split_axis_param:
    :return:
    """
    if op_schedule_info.tiling_record is None:
        op_schedule_info.tiling_record = {'block_split_num': 0, 'ub_split_num': 0, 'split_var_name_list': []}
    ub_split_num = op_schedule_info.tiling_record.get("ub_split_num", 0)
    if ub_split_num is None:
        raise RuntimeError("ub_split_num is None, please check!")
    ub_factor_var_name = '_ub_factor_' + str(ub_split_num)
    op_schedule_info.tiling_record['ub_split_num'] = ub_split_num + 1
    op_schedule_info.tiling_record['split_var_name_list'].append(ub_factor_var_name)

    ub_split_axis = split_axis_param.axis_index
    stage_id = split_stage_param.stage_index
    # ub_count is changed in proc_set_buffer_size
    ub_count = split_axis_param.factor
    axis_num = len(op_schedule_info.input_info_list[0].shape)
    ub_calc_axes = list(range(ub_split_axis, axis_num))
    ub_split_info = UbSplitInfo(stage_id, ub_split_axis, ub_calc_axes, ub_factor_var_name, ub_count)
    if not hasattr(op_schedule_info, 'ub_split_info_list') \
            or not op_schedule_info.ub_split_info_list:
        op_schedule_info.ub_split_info_list = []
    op_schedule_info.ub_split_info_list.append(ub_split_info)


def split_axis_once_proc(op_schedule_info: OpScheduleInfo, split_stage_param: SplitStageParam,
                                        split_axis_param: SplitAxisParam) -> NoReturn:
    """
    :param op_schedule_info:
    :param split_stage_param:
    :param split_axis_param:
    :return:
    """
    factor = split_axis_param.factor
    op_schedule_info.ub_factor = factor
    op_schedule_info.ub_is_full_cut = \
        factor == split_axis_param.axis_len or \
        (factor == 1 and split_stage_param.cut_axis_index < len(split_stage_param.stage.op.axis) - 1)
    split_stage_param.code_lines.append('# ub_is_full_cut: %s' % op_schedule_info.ub_is_full_cut)

    axis_name = split_axis_param.axis_name
    axis_index = split_axis_param.axis_index

    stage_axis_info = split_stage_param.stage_axis_info
    stage_index = split_stage_param.stage_index
    axis_type = split_stage_param.axis_type

    split_stage_param.code_lines.append(
        f'{axis_name}_o, {axis_name}_i = sch[{split_stage_param.stage_name}].split('
        f'sch[{split_stage_param.stage_name}].op.{axis_type}[{axis_index}], factor={factor})')

    axis_obj_o, axis_obj_i = split_stage_param.stage.split(split_axis_param.axis, factor=factor)

    if factor != 0:
        axis_o_len = math.floor((split_axis_param.axis_len + factor - 1) / factor)
        stage_axis_info.append(AxisInfo(axis_name + '_o', axis_o_len, axis_type, axis_index, 'o', axis_obj_o))
        stage_axis_info.append(AxisInfo(axis_name + '_i', factor, axis_type, axis_index, 'i', axis_obj_i))
        op_schedule_info.ub_split_outer_name = f'{axis_name}_o'
    else:
        logger.error("Invalid factor!!!")
        return

    ori_order_axis = t2c_util.get_ori_order(stage_axis_info)
    splited_axis_index = get_axis_index(ori_order_axis, axis_name + '_o')
    cheque = get_split_cheque(stage_index, splited_axis_index, factor)
    op_schedule_info.cheque_list.append(cheque)

    dynamic_flag = op_schedule_info.option.get('op_config').get('op_mode', '') in ['dynamic']
    if dynamic_flag:
        set_ub_split_info(op_schedule_info, split_stage_param, split_axis_param)
    return


def append_axis_proc_info_for_no_cut(split_stage_param, split_axis_param, axis_attr):
    """
    :param split_stage_param:
    :param split_axis_param:
    :param axis_attr:
    :return:
    """
    stage_name = split_stage_param.stage_name
    axis_name = split_axis_param.axis_name
    axis_index = split_axis_param.axis_index
    axis_len = split_axis_param.axis_len
    axis = split_axis_param.axis
    axis_type = split_stage_param.axis_type

    split_stage_param.code_lines.append(f'{axis_name} = sch[{stage_name}].op.{axis_type}[{axis_index}]')

    split_stage_param.stage_axis_info.append(
        AxisInfo(axis_name, axis_len, axis_type, axis_index, axis_attr, axis))


def split_axis_proc(op_schedule_info: OpScheduleInfo, split_stage_param: SplitStageParam,
                               split_axis_param: SplitAxisParam) -> NoReturn:
    """
    :param op_schedule_info:
    :param split_stage_param:
    :param split_axis_param:
    :return:
    """
    if split_axis_param.axis_index == split_stage_param.cut_axis_index:
        split_axis_once_proc(op_schedule_info, split_stage_param, split_axis_param)

    elif split_axis_param.axis_index < split_stage_param.cut_axis_index:
        append_axis_proc_info_for_no_cut(split_stage_param, split_axis_param, "ub_out_axis")

    elif split_axis_param.axis_index > split_stage_param.cut_axis_index:
        append_axis_proc_info_for_no_cut(split_stage_param, split_axis_param, "ub_in_axis")


def split_axis(op_schedule_info: OpScheduleInfo, split_stage_param: SplitStageParam) -> int :
    """
    split_axis
    :param op_schedule_info:
    :param split_stage_param
    :return:
    """
    stage_info = op_schedule_info.stages_info[split_stage_param.stage_index]
    stage_ordered_axes_obj = stage_info.get('stage_ordered_axes_obj')

    for axis_index, axis in enumerate(split_stage_param.stage_axis_obj):
        if stage_ordered_axes_obj and split_stage_param.axis_type == "reduce_axis":
            reduce_axes = stage_ordered_axes_obj.get_reduce_axes()
            factor = split_stage_param.split_vector[reduce_axes[axis_index]]
            axis_name = '%s_reduce_axis_%d' % (split_stage_param.stage_name, axis_index)
        else:
            factor = split_stage_param.split_vector[axis_index]
            axis_name = '%s_axis_%d' % (split_stage_param.stage_name, axis_index)
        axis_len = axis.dom.extent.value
        split_axis_param = SplitAxisParam(factor, axis, axis_index, axis_name, axis_len)
        split_axis_proc(op_schedule_info, split_stage_param, split_axis_param)

    return split_stage_param.cut_axis_index


def split_a_stage(progress: Progress, stage_index: int) -> Tuple[List, List, int]:
    """
    split_a_stage
    :param progress:
    :param stage_index:
    :return:
    """
    code_lines = []
    stage_axis_info = []
    op_schedule_info = progress.op_schedule_info
    stage = op_schedule_info.schedule_obj.stages[stage_index]
    split_vector = progress.action_tensor[stage_index][
                   ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    stage_name = op_schedule_info.stages_info[stage_index]['name']
    cut_axis_index = 0

    axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[stage_index], stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)

    code_lines.append(f'# split factor info: {list(split_vector)}')
    stage_info = op_schedule_info.stages_info[stage_index]
    stage_ordered_axes_obj = stage_info.get('stage_ordered_axes_obj')
    reduce_axes = []
    axis_type = "axis"
    if stage_ordered_axes_obj:
        reduce_axes = stage_ordered_axes_obj.get_reduce_axes()
    for idx, factor in enumerate(split_vector):
        if factor == 0:
            continue
        if idx in reduce_axes:
            cut_axis_index = reduce_axes.index(idx)
            axis_type = "reduce_axis"
        else:
            cut_axis_index = idx

    if axis_type == "reduce_axis":
        for axis_index, axis in enumerate(stage.op.axis):
            axis_name = f'{stage_name}_axis_{axis_index}'
            code_lines.append('%s = sch[%s].op.axis[%d]' % (axis_name, stage_name, axis_index))
            stage_axis_info.append(
                AxisInfo(axis_name,
                         stage.op.axis[axis_index].dom.extent.value,
                         'axis', axis_index, 'all', axis))

        stage_axis_obj = stage.op.reduce_axis
    else:
        stage_axis_obj = stage.op.axis

    split_stage_param = SplitStageParam(code_lines, stage_axis_info, stage_axis_obj, split_vector, stage,
                                        stage_index, stage_name, cut_axis_index, axis_type)

    split_axis(op_schedule_info, split_stage_param)

    return split_stage_param.code_lines, split_stage_param.stage_axis_info, split_stage_param.cut_axis_index
