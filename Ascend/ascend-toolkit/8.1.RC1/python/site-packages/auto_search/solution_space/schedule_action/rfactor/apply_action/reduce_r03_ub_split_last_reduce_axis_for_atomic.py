#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reduce_r03_ub_split_last_reduce_axis_for_atomic
"""
import copy
from typing import NoReturn

from tbe.common.platform import platform_info

from auto_search.utils import logger
from auto_search.solution_space.tensor_cfg import FeatureTensorCfg
from auto_search.solution_space import t2c_util
from auto_search.compute_analysis import StageOrderedAxes
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.bank.cheque_generator import get_axis_cheque
from auto_search.bank.cheque_generator import get_rfactor_cheque
from auto_search.bank.cheque_generator import get_set_scope_cheque
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import add_a_stage_axis_info
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_stage_index_map
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_feature
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_actions
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_inlined_stages


def add_a_stage_info(progress: Progress, rfactor_stage_index: int, rfactor_stage_name: str) -> NoReturn:
    """
    add a stage info for new stage
    :param progress:
    :param rfactor_stage_index:
    :param rfactor_stage_name:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    # get original reduce info
    at_info = copy.deepcopy(op_schedule_info.stages_info[rfactor_stage_index].get('at_info'))
    reduce_type = t2c_util.REDUCE_LAST_KEYWORD
    # because now features is not been update, so original reduce stage index in features is rfactor_stage_index
    reduce_op_tag = op_schedule_info.op_intrin_key_index[
        op_schedule_info.feature_tensor[rfactor_stage_index][FeatureTensorCfg.compute_s]].op_tag
    op_schedule_info.stages_info[rfactor_stage_index]['op_tag'] = reduce_op_tag
    op_schedule_info.stages_info.insert(rfactor_stage_index,
                                  {
                                      'name': rfactor_stage_name,
                                      'type': ['reduce_rfactor'],
                                      'scope': platform_info.scope_ubuf,
                                      'op_tag': reduce_op_tag,
                                      'reduce_type': reduce_type,
                                      'at_info': at_info,
                                  })


def update_reduce_stage_axis_info(progress: Progress, reduce_stage_index: int) -> NoReturn:
    """
    after add rfactor stage, original reduce stage axes need be updated
    :param progress:
    :param reduce_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    code_lines.extend(['\n', '#  update reduce stage axis info'])
    stage_name = op_schedule_info.stages_info[reduce_stage_index].get('name')
    stage = op_schedule_info.schedule_obj.stages[reduce_stage_index]

    stage_axis_info = []
    for axis_index, axis in enumerate(stage.op.axis):
        axis_name = f'{stage_name}_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.axis[axis_index].dom.extent.value,
                                        'axis', axis_index, 'axis', axis))

    for axis_index, axis in enumerate(stage.op.reduce_axis):
        axis_name = f'{stage_name}_reduce_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.reduce_axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.reduce_axis[axis_index].dom.extent.value,
                                        'reduce_axis', axis_index, 'reduce_axis', axis))

    op_schedule_info.axis_info_list[reduce_stage_index] = stage_axis_info


def update_at_dict(progress: Progress) -> NoReturn:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_index_map = op_schedule_info.stage_index_map

    for stage_index, stage_info in enumerate(op_schedule_info.stages_info):
        if 'at_info' not in stage_info:
            continue
        _update_at_dict_for_each_stage(op_schedule_info, stage_index, stage_index_map, stage_info)

    op_schedule_info.update_at_dict()


def _update_at_dict_for_each_stage(op_schedule_info, stage_index, stage_index_map, stage_info):
    """
    :param op_schedule_info:
    :param stage_index:
    :param stage_index_map:
    :param stage_info:
    :return:
    """
    at_info = stage_info.get('at_info')
    stage_types = stage_info.get('type', [])
    for consumer in at_info.consumers:
        sampled_target = consumer.updated_sampled_target
        if 'reduce_rfactor' in stage_types:
            # reduce_atomic_rf_rf stage compute at the stage behind it(reduce_atomic_rf)
            consumer.set_updated_sampled_target(stage_index + 1)
            continue
        if 'reduce_atomic_rfactor' in stage_types:
            # reduce_atomic_rf stage compute at the stage behind it(reduce_cache_write)
            consumer.set_updated_sampled_target(stage_index + 1)
            continue
        new_sampled_target = stage_index_map.get(sampled_target, None)
        if not new_sampled_target:
            continue
        target_stage_types = op_schedule_info.stages_info[new_sampled_target].get('type', [])
        current_stage_types = op_schedule_info.stages_info[stage_index].get('type', [])
        if 'reduce_atomic' in target_stage_types and 'reduce_gm' not in current_stage_types:
            # the stage index be saved in consumer is before do cache r/w
            # the stages before reduce stage，compute at reduce_atomic_rf_rf stage
            # current order：reduce_atomic_rf_rf, reduce_atomic_rf, reduce_cache_write, reduce_atomic(leaf)
            consumer.set_updated_sampled_target(new_sampled_target - 3)
            continue
        consumer.set_updated_sampled_target(new_sampled_target)


def update_stages_relevant_info(progress: Progress, reduce_stage_index: int, rfactor_stage_name: str) -> NoReturn:
    """
    rfactor add a new stage，need update stage info
    :param progress:
    :param reduce_stage_index:
    :param rfactor_stage_name:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    # update index
    rfactor_stage_index = reduce_stage_index
    # because add a stage before reduce stage, so reduce stage index need add 1
    reduce_stage_index = reduce_stage_index + 1
    # update reduce atomic stage cheque
    axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[reduce_stage_index], reduce_stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)
    # update stages_info
    add_a_stage_info(progress, rfactor_stage_index, rfactor_stage_name)
    # update axis_info_list
    add_a_stage_axis_info(progress, rfactor_stage_index)
    update_reduce_stage_axis_info(progress, reduce_stage_index)
    # update stage_index_map
    update_stage_index_map(progress, reduce_stage_index)
    # update feature
    update_feature(progress)
    # update actions
    update_actions(progress, rfactor_stage_index)
    # update inlined stage
    update_inlined_stages(progress, rfactor_stage_index)
    # update at_dict
    update_at_dict(progress)
    # update dependency_dict
    op_schedule_info.update_dependency_dict()


def do_rfactor(progress: Progress, reduce_stage_index: int, rfactor_axis_info: AxisInfo,
               last_axis_index: int) -> NoReturn:
    """
    :param progress:
    :param reduce_stage_index:
    :param rfactor_axis_info:
    :param last_axis_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    reduce_tensor = op_schedule_info.schedule_obj.stages[reduce_stage_index].origin_op.output(0)
    rfactor_axis_obj = rfactor_axis_info.body

    # code_lines
    reduce_stage_name = op_schedule_info.stages_info[reduce_stage_index].get('name')
    rfactor_stage_name = f"{reduce_stage_name}_rfactor"
    rfactor_axis_name = rfactor_axis_info.name
    rfactor_code_lines = f"{rfactor_stage_name} = sch.rfactor({reduce_stage_name}, {rfactor_axis_name}, factor_axis=-1)"
    set_scope_code_lines = f"sch[{rfactor_stage_name}].set_scope('{platform_info.scope_ubuf}')"
    code_lines.append(rfactor_code_lines)
    code_lines.append(set_scope_code_lines)

    rfactor_tensor = op_schedule_info.schedule_obj.rfactor(reduce_tensor, rfactor_axis_obj, factor_axis=-1)
    logger.debug("rfactor_tensor: %s, %s", rfactor_tensor, type(rfactor_tensor))
    op_schedule_info.schedule_obj[rfactor_tensor].set_scope(platform_info.scope_ubuf)

    # gen rfactor cheque
    cheque = get_rfactor_cheque(reduce_stage_index, last_axis_index, -1)
    op_schedule_info.cheque_list.append(cheque)

    # gen set_scope cheque
    cheque = get_set_scope_cheque(reduce_stage_index, platform_info.scope_ubuf)
    op_schedule_info.cheque_list.append(cheque)

    update_stages_relevant_info(progress, reduce_stage_index, rfactor_stage_name)


def proc(progress: Progress):
    """
    atomic last reduce, and ub split last reduce axis, do rfactor for inner axis
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    if not op_schedule_info.is_atomic:
        return

    stages = list(op_schedule_info.schedule_obj.stages)

    if len(stages) < 3:
        logger.error("stages num should bigger than 3, while is : %s", len(stages))
        return
    reduce_gm_stage_index = len(stages) - 1
    reduce_atomic_stage_index = len(stages) - 3

    ub_cut_axis = _get_find_cut_axis(progress, reduce_atomic_stage_index)

    reduce_gm_stage_info = op_schedule_info.stages_info[reduce_gm_stage_index]
    ordered_axis_obj: StageOrderedAxes = reduce_gm_stage_info.get('stage_ordered_axes_obj', None)
    if ordered_axis_obj is None:
        raise RuntimeError("reduce_gm stage info should have ordered_axis_obj!")
    if not ordered_axis_obj.is_reduce_last():
        return
    op_schedule_info.last_reduce = True
    op_schedule_info.atomic_last_reduce = True
    if ub_cut_axis != ordered_axis_obj.get_reduce_axes()[-1]:
        return

    op_schedule_info.atomic_last_reduce_and_ub_split_last_reduce_axis = True
    # current reduce atomic stage has been cut, so axis_info_list is not None
    if op_schedule_info.axis_info_list[reduce_atomic_stage_index] is None:
        raise RuntimeError("reduce atomic stage should have axis_info_list after split!")

    reduce_atomic_stage = stages[reduce_atomic_stage_index]
    if op_schedule_info.atomic_block_split_info.axis_index == len(ordered_axis_obj.get_reduce_axes()) - 1:
        # eg: a0 r0, atomic split r0 , a0 r0_o r0_i, after r0_o do rfactor(factor_axis=-1),
        # reduce_rfactor axis order is a0 r0_o r0_i, then ub split r0_i, a0 r0_o r0_i_o r0_i_1,
        # then do rfactor for r0_i_1
        last_reduce_inner_axis = reduce_atomic_stage.leaf_iter_vars[-1]
        last_axis_index = len(op_schedule_info.schedule_obj.stages[reduce_atomic_stage_index].leaf_iter_vars) - 1
    else:
        # eg: a0 r0 a1 r1, atomic split r0 , a0 r0_o r0_i a1 r1, after r0_o do rfactor(factor_axis=-1),
        # reduce_rfactor axis order is a0 a1 r0_o a1 r1 r0_i, then ub split r1, a0 a1 r0_o a1 r1_o r1_i r0_i,
        # then do rfactor for r1_i
        last_reduce_inner_axis = reduce_atomic_stage.leaf_iter_vars[-2]
        last_axis_index = len(op_schedule_info.schedule_obj.stages[reduce_atomic_stage_index].leaf_iter_vars) - 2
    reduce_atomic_stage_axis_info = op_schedule_info.axis_info_list[reduce_atomic_stage_index]
    last_reduce_inner_axis_info = None
    for _, axis_info in enumerate(reduce_atomic_stage_axis_info):
        if last_reduce_inner_axis == axis_info.body:
            last_reduce_inner_axis_info = axis_info
            break

    do_rfactor(progress, reduce_atomic_stage_index, last_reduce_inner_axis_info, last_axis_index)

    return


def _get_find_cut_axis(progress, reduce_atomic_stage_index):
    """
    :param progress:
    :param reduce_atomic_stage_index:
    :return:
    """
    split_vector = progress.action_tensor[reduce_atomic_stage_index][
                   ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    if sum(split_vector) == 0:
        raise RuntimeError("reduce_gm split vector should not all 0!")
    # find ub split axis
    ub_cut_axis = 0
    for i, f in enumerate(split_vector):
        if f > 0:
            ub_cut_axis = i
            break
    return ub_cut_axis
