#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
common apply action
"""
from typing import NoReturn

from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.action import apply_action_register
from auto_search.solution_space.action import ScheduleActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.progress import Progress
from auto_search.utils import logger

from .split_a_stage import split_a_stage
from .split_a_stage_for_reduce_atomic import split_a_stage_for_reduce_atomic
from .split_a_stage_for_reduce_normal import split_a_stage_for_reduce_normal
from .split_a_stage_for_pooling import split_a_stage_for_pooling
from .split_a_stage_for_transpose import split_a_stage_for_transpose


@apply_action_register([ComputePattern.ELEMENTWISE, ComputePattern.BROADCAST, ComputePattern.NORM],
                       ScheduleActionType.SPLIT)
def apply(progress: Progress) -> NoReturn:
    """
    :param progress:
    :return:
    """
    sch = progress.op_schedule_info.schedule_obj
    code_lines = ['\n', '# split code']
    axis_info_list = []
    cleaned_actions = progress.action_tensor
    cut_axis_index = 0
    for stage_index, _ in enumerate(sch.stages):
        progress.op_schedule_info.stage_index = stage_index
        split_vector = cleaned_actions[stage_index][
                       ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]

        if sum(split_vector) == 0:
            sub_code, stage_axis_info = [], None
        else:
            sub_code, stage_axis_info, cut_axis_index = split_a_stage(progress, stage_index)

        code_lines.extend(sub_code)
        if isinstance(stage_axis_info, list) and isinstance(stage_axis_info[0], list):
            axis_info_list.extend(stage_axis_info)
        else:
            axis_info_list.append(stage_axis_info)
        progress.op_schedule_info.cut_axis_index[stage_index] = cut_axis_index

    progress.op_schedule_info.code_lines.extend(code_lines)
    progress.op_schedule_info.axis_info_list = axis_info_list
    logger.debug("apply split done.")


@apply_action_register([ComputePattern.TRANSPOSE], ScheduleActionType.SPLIT)
def apply_for_transpose(progress: Progress) -> NoReturn:
    """
    transpose apply for split
    :param progress:
    :return:
    """
    sch = progress.op_schedule_info.schedule_obj
    code_lines = ['\n', '# split code']
    axis_info_list = []

    cut_axis_index = 0
    for stage_index, _ in enumerate(sch.stages):
        progress.op_schedule_info.stage_index = stage_index
        split_vector = progress.action_tensor[stage_index][
                       ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]

        if sum(split_vector) == 0:
            sub_code, stage_axis_info = [], None
        else:
            sub_code, stage_axis_info, cut_axis_index = split_a_stage_for_transpose(
                progress, stage_index)

        code_lines.extend(sub_code)
        if isinstance(stage_axis_info, list) \
                and isinstance(stage_axis_info[0], list):
            axis_info_list.extend(stage_axis_info)
        else:
            axis_info_list.append(stage_axis_info)
        progress.op_schedule_info.cut_axis_index[stage_index] = cut_axis_index

    progress.op_schedule_info.code_lines.extend(code_lines)
    progress.op_schedule_info.axis_info_list = axis_info_list


@apply_action_register([ComputePattern.TUPLE_REDUCE, ComputePattern.REDUCE], ScheduleActionType.SPLIT)
def apply_for_reduce(progress: Progress) -> NoReturn:
    """
    :param progress:
    :return:
    """
    sch = progress.op_schedule_info.schedule_obj
    code_lines = ['\n', '# split code']
    axis_info_list = []
    cleaned_actions = progress.action_tensor
    cut_axis_index = 0
    atomic_flag = progress.op_schedule_info.is_atomic
    for stage_index, _ in enumerate(sch.stages):
        progress.op_schedule_info.stage_index = stage_index
        split_vector = cleaned_actions[stage_index][
                       ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]

        if sum(split_vector) == 0:
            #  before split maybe have creat axis_info_list, such as rfactor
            if progress.op_schedule_info.axis_info_list and progress.op_schedule_info.axis_info_list[stage_index]:
                sub_code = []
                stage_axis_info = progress.op_schedule_info.axis_info_list[stage_index]
            else:
                sub_code, stage_axis_info = [], None
        else:
            if atomic_flag:
                sub_code, stage_axis_info, cut_axis_index = split_a_stage_for_reduce_atomic(progress, stage_index)
            else:
                sub_code, stage_axis_info, cut_axis_index = split_a_stage_for_reduce_normal(progress, stage_index)

        code_lines.extend(sub_code)
        if isinstance(stage_axis_info, list) and isinstance(stage_axis_info[0], list):
            axis_info_list.extend(stage_axis_info)
        else:
            axis_info_list.append(stage_axis_info)
        progress.op_schedule_info.cut_axis_index[stage_index] = cut_axis_index

    progress.op_schedule_info.code_lines.extend(code_lines)
    progress.op_schedule_info.axis_info_list = axis_info_list


@apply_action_register([ComputePattern.POOLING], ScheduleActionType.SPLIT)
def apply_for_pooling(progress: Progress) -> NoReturn:
    """
    :param progress:
    :return:
    """
    sch = progress.op_schedule_info.schedule_obj
    code_lines = ['\n', '# split code']
    axis_info_list = []
    cleaned_actions = progress.action_tensor
    cut_axis_index = 0
    for stage_index, _ in enumerate(sch.stages):
        progress.op_schedule_info.stage_index = stage_index
        split_vector = cleaned_actions[stage_index][
                       ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]

        if sum(split_vector) == 0:
            sub_code, stage_axis_info = [], None
        else:
            sub_code, stage_axis_info, cut_axis_index = split_a_stage_for_pooling(progress, stage_index)

        code_lines.extend(sub_code)
        if isinstance(stage_axis_info, list) and isinstance(stage_axis_info[0], list):
            axis_info_list.extend(stage_axis_info)
        else:
            axis_info_list.append(stage_axis_info)
        progress.op_schedule_info.cut_axis_index[stage_index] = cut_axis_index

    progress.op_schedule_info.code_lines.extend(code_lines)
    progress.op_schedule_info.axis_info_list = axis_info_list
    logger.debug("apply split done.")
