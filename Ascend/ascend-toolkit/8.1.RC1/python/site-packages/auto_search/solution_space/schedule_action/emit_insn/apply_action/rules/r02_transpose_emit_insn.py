#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
trs dma axis add attrs
"""
from typing import NoReturn

from tbe import tvm
from tbe.tvm import Stage

from auto_search.utils import logger
from auto_search.solution_space.schedule_action.storage_align.apply_action.transpose_comm \
    import calc_trs_reorder_action
from auto_search.solution_space.schedule_action.storage_align.apply_action.transpose_comm \
    import calc_trs_split_axis
from auto_search.solution_space.op_schedule_info import OpScheduleInfo
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.t2c_util import MODE_RUNTIME
from auto_search.solution_space.tensor_cfg import FeatureTensorCfg
from auto_search.bank.cheque_generator import get_emit_insn_cheque
from auto_search.solution_space.tensor_cfg import ActionTensorCfg


def proc(progress: Progress):
    """
    transpose emit insn rule proc
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stages_info = op_schedule_info.stages_info

    # calc chosen_axes
    chosen_axes = []
    all_stages = op_schedule_info.schedule_obj.stages
    for index, _ in enumerate(all_stages):
        if "chosen_axes" in stages_info[index].keys():
            chosen_axes = stages_info[index]['chosen_axes']
            break

    # manual_debug choose_axes
    debug_params = op_schedule_info.option.get("trs_debug", [False, {}])
    if debug_params[0]:
        chosen_axes = debug_params[1]["chosen_axes"]

    # record and update chosen axes info
    stages_info[-1]["chosen_axes"] = chosen_axes

    features = op_schedule_info.feature_tensor
    stage_index = op_schedule_info.stage_index

    intrin = op_schedule_info.op_intrin_key_index[
        features[stage_index][FeatureTensorCfg.compute_s]].intrin

    if intrin.find("##") != -1:
        intrins = intrin.split('##')
        emit_insn_action_index = progress.action_tensor[stage_index][
            ActionTensorCfg.emit_insn_s]
        intrin = str(intrins[emit_insn_action_index])

    _do_trs_emit_insn(op_schedule_info, stages_info, stage_index, intrin, chosen_axes)

    op_schedule_info.proc_flag_dict[stage_index] = True


def _get_dma_axis(stage: Stage, curr_axis_info_list: list,
                  stage_name: str, proc_sch: bool = True) -> (int, str, object):
    """
    get dma axis
    :param stage:
    :param curr_axis_info_list:
    :param proc_sch:
    :param stage_name:
    :return:
    """
    emit_insn_axis_obj = None
    axis_name = ""

    if curr_axis_info_list is None:
        axis_num = 0
        if proc_sch:
            emit_insn_axis_obj = stage.op.axis[axis_num]
        return \
            axis_num, "sch[{}].op.axis[{}]".format(stage_name, axis_num), \
            emit_insn_axis_obj

    for i, axis_info in enumerate(curr_axis_info_list):
        axis_name = axis_info.name
        for axis_ends in ["_ii", "_i"]:
            proc_sch_flag = axis_name.endswith(axis_ends) and proc_sch
            if proc_sch_flag:
                emit_insn_axis_obj = curr_axis_info_list[i].body
                return i, axis_name, emit_insn_axis_obj

    logger.warn("Pragma axis not found for stage_name:%s,  "
                "curr_axis_info_list:%s !", stage_name, curr_axis_info_list)
    return 0, axis_name, emit_insn_axis_obj


def _get_src_and_dst_order(permute: list, ori_permute: list,
                           reorder_in_index: list, reorder_out_index: list) -> (list, list):
    """
    get src_order and dst_order
    :param permute:
    :param ori_permute:
    :param reorder_in_index:
    :param reorder_out_index:
    :return:
    """
    base_order = list(range(len(permute)))
    src_order = [base_order[i] for i in reorder_in_index]
    dst_order = [ori_permute[i] for i in reorder_out_index]

    return src_order, dst_order


def _get_ub_src_and_dst_order(op_schedule_info: OpScheduleInfo, permute: list, ori_permute: list,
                              low_ub_split_axis: int, high_ub_split_axis: int) -> (list, list):
    """
    get ub_src_order and ub_dst_order
    :param op_schedule_info:
    :param permute:
    :param ori_permute:
    :param low_ub_split_axis:
    :param high_ub_split_axis:
    :return:
    """
    # calc reorder_index
    reorder_in_index, reorder_out_index = calc_trs_reorder_action(op_schedule_info)

    src_order, dst_order = _get_src_and_dst_order(
        permute, ori_permute, reorder_in_index, reorder_out_index)

    continus_src = src_order[ori_permute[low_ub_split_axis]:]
    continus_dst = dst_order[high_ub_split_axis:]
    ub_src_order = [_o for _o in src_order if _o in continus_dst and _o not in continus_src]
    ub_src_order.extend(continus_src)
    ub_dst_order = [_o for _o in dst_order if _o in continus_src and _o not in continus_dst]
    ub_dst_order.extend(continus_dst)

    return ub_src_order, ub_dst_order


def _calc_src_in_dst_order_attr(op_schedule_info: OpScheduleInfo, chosen_axes: list) -> (dict, list):
    """
    calculate src_in_dst_order_attr
    :param op_schedule_info:
    :param chosen_axes:
    :return:
    """
    # calc split axis
    low_ub_split_axis, high_ub_split_axis = calc_trs_split_axis(op_schedule_info, chosen_axes)

    # calc ori_permute and permute
    ori_permute = []
    for stage in op_schedule_info.schedule_obj.stages:
        if "permute" in stage.op.attrs:
            ori_permute = [int(i) for i in stage.op.attrs["permute"]]
            break

    ori_perm = []
    for ind in ori_permute:
        ori_perm.append(int(ind))
    permute = sorted(range(len(ori_perm)), key=ori_perm.__getitem__)

    # get ub_src_order and ub_dst_order
    ub_src_order, ub_dst_order = _get_ub_src_and_dst_order(
        op_schedule_info, permute, ori_permute, low_ub_split_axis, high_ub_split_axis)

    src_in_dst_order_list = [ub_src_order.index(_o) for _o in ub_dst_order]
    src_in_dst_order = tvm.call_cce_pure_intrin('handle', 'tir.tvm_tuple', *src_in_dst_order_list)
    attrs = {"src_in_dst_order": src_in_dst_order}

    op_schedule_info.code_lines.append(
        "src_in_dst_order = tvm.call_cce_pure_intrin('handle', 'tir.tvm_tuple', {}, ".format(*src_in_dst_order_list))

    return attrs, src_in_dst_order_list


def _do_trs_emit_insn(op_schedule_info: OpScheduleInfo, stages_info: list, stage_index: int,
                      intrin: str, chosen_axes: list) -> NoReturn:
    """
    do transpose emit insn
    :param op_schedule_info:
    :param stages_info:
    :param stage_index:
    :param intrin:
    :param chosen_axes:
    :return:
    """
    stage = op_schedule_info.stage
    stage_name = op_schedule_info.stages_info[stage_index]['name']
    proc_sch = bool(op_schedule_info.mode == MODE_RUNTIME)

    axis_num, dma_axis, dma_axis_obj = \
        _get_dma_axis(stage, op_schedule_info.axis_info_list[stage_index],
                      stage_name, proc_sch=proc_sch)

    attrs = None
    attrs_str = None
    extra_info = None
    if intrin == 'dma_copy' and 'leaf' in stages_info[stage_index].get("type", []):
        # output dma_tensor need to set overlap:2
        attrs = {"no_overlap": 2}
        attrs_str = str(attrs)
        extra_info = attrs
    elif intrin == 'vector_transpose' and stages_info[stage_index].get("tag") == "transpose":
        # vector_transposeçš„tensor need to set attrs
        attrs, src_in_dst_order_list = _calc_src_in_dst_order_attr(op_schedule_info, chosen_axes)
        attrs_str = "{\'src_in_dst_order\': src_in_dst_order}"
        extra_info = {"src_in_dst_order": src_in_dst_order_list}

    if proc_sch:
        stage.emit_insn(dma_axis_obj, intrin, attrs=attrs)
    op_schedule_info.code_lines.append(
        "sch[{}].emit_insn({}, '{}', attrs={})".format(stage_name, dma_axis, intrin, attrs_str))

    if attrs is not None:
        cheque = get_emit_insn_cheque(stage_index, intrin, (dma_axis, axis_num), extra_info=extra_info)
        op_schedule_info.cheque_list.append(cheque)
    else:
        cheque = get_emit_insn_cheque(stage_index, intrin, (dma_axis, axis_num))
        op_schedule_info.cheque_list.append(cheque)
