#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
rl schedule search, tss
"""
from typing import List

from auto_search.utils import logger
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.schedule_action.at.apply_action.rules.reduce_atomic_r02_last_reduce_at_rule import \
    reduce_atomic_rfactor_at


def _atomic_rfactor_in_at_target_stage_at(op_schedule_info, at_target_stage_index, at_targets, stage_index):
    """

    :param op_schedule_info:
    :param at_target_stage_index:
    :param at_targets:
    :param stage_index:
    :return:
    """
    axis_info_list: List[List[AxisInfo]] = op_schedule_info.axis_info_list
    ub_split_info = op_schedule_info.atomic_ub_split_info
    reduce_compute_graph = op_schedule_info.compute_graph_info
    ub_split_axis_type = op_schedule_info.stages_info[-1].get('split_axis_type', None)
    nlast_and_ub_split_last_a_axis = not op_schedule_info.compute_graph_info.is_last_reduce \
                                     and ub_split_axis_type == 'axis' \
                                     and ub_split_info.axis_index == len(reduce_compute_graph.normal_axes_index) - 1
    at_target_stage_axis_info = axis_info_list[at_target_stage_index]
    if nlast_and_ub_split_last_a_axis:
        # if nlast reduce and ub split a1, compute at r1(last reduce axis)
        for stage_axis_info in at_target_stage_axis_info:
            if stage_axis_info.type == "reduce_axis":
                at_targets[stage_index] = stage_axis_info
    else:
        # before reduce_atomic_rfactor stage compute at reduce_atomic_rfactor outer axis
        # if split multi times, compute at last outer axis
        for stage_axis_info in at_target_stage_axis_info:
            if stage_axis_info.name.endswith('o'):
                at_targets[stage_index] = stage_axis_info


def proc(progress: Progress) -> bool:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    if not op_schedule_info.is_atomic:
        return False

    ub_split_last_reduce_axis = op_schedule_info.atomic_last_reduce_and_ub_split_last_reduce_axis
    ub_split_nlast_reduce_axis = op_schedule_info.atomic_last_reduce_and_ub_split_nlast_reduce_axis
    if ub_split_last_reduce_axis or ub_split_nlast_reduce_axis:
        return False

    stage_num = len(op_schedule_info.feature_tensor)
    at_targets = [None] * stage_num
    at_dict = op_schedule_info.at_dict

    for stage_index, stage in enumerate(op_schedule_info.schedule_obj.stages):
        if str(stage.op).startswith("placeholder"):
            continue
        at_target_stage_index = at_dict[stage_index]
        if at_target_stage_index is None:
            continue
        curr_stage_type = op_schedule_info.stages_info[stage_index].get('type', [])
        at_target_stage_type = op_schedule_info.stages_info[at_target_stage_index].get('type', [])
        if "reduce_atomic_rfactor" in at_target_stage_type:
            _atomic_rfactor_in_at_target_stage_at(op_schedule_info, at_target_stage_index, at_targets, stage_index)
        elif "reduce_atomic_rfactor" in curr_stage_type:
            reduce_atomic_rfactor_at(op_schedule_info, at_target_stage_index, at_targets, stage_index)

    op_schedule_info.at_targets = at_targets
    logger.debug('reduce_atomic_at_rule')
    return True
