#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
generic db
"""
from auto_search.utils import logger
from auto_search.solution_space.t2c_util import MODE_RUNTIME
from auto_search.bank.cheque_generator import get_double_buffer_cheque
from auto_search.bank.cheque_generator import get_mem_uniq_cheque
from auto_search.solution_space.op_schedule_info import OpScheduleInfo


def proc(op_schedule_info: OpScheduleInfo, stage_index: int) -> bool:
    """
    :param op_schedule_info:
    :param stage_index:
    :return:
    """
    stage = op_schedule_info.schedule_obj.stages[stage_index]
    stage_info = op_schedule_info.stages_info[stage_index]
    stage_name = stage_info['name']

    if not op_schedule_info.is_open_db:
        return True

    if stage_index in op_schedule_info.inlined_stages:
        return True

    if ".local.UB" not in stage.op.name:
        return True

    # now only mte2 tensor to enable double buffer in tuple reduce ra scene
    if op_schedule_info.enable_atomic_ra_bind and \
            not ('CacheRead' in stage_info['type'] and stage_info['tag'] == 'mem_copy'):
        return True

    logger.debug('double_buffer stage_name: %s', stage_name)
    op_schedule_info.code_lines.append('sch[%s].double_buffer()' % stage_name)
    # gen double buffer cheque
    cheque = get_double_buffer_cheque(stage_index)
    op_schedule_info.cheque_list.append(cheque)

    op_schedule_info.double_buffer_list.append(stage_name)

    if op_schedule_info.mode == MODE_RUNTIME:
        stage.double_buffer()
    return True
