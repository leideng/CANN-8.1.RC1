#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reduce_r02_ub_split_nlast_reduce_axis_for_normal
"""
from typing import List
from typing import NoReturn
import copy
import numpy

from tbe.common.platform import platform_info

from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.solution_space.tensor_cfg import get_init_action_tensor_zero
from auto_search.solution_space.t2c_util import MODE_RUNTIME
from auto_search.compute_analysis import StageOrderedAxes
from auto_search.bank.cheque_generator import get_rfactor_cheque
from auto_search.bank.cheque_generator import get_set_scope_cheque
from auto_search.bank.cheque_generator import get_axis_cheque
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import add_a_stage_info
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_stage_index_map
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_feature
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_inlined_stages
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_at_dict


def update_actions(progress: Progress, rfactor_stage_index: int) -> NoReturn:
    """
    last reduce ub split nlast reduce axis,
    this scene need split rfactor stage,
    original reduce stage not be cut
    :param progress:
    :param rfactor_stage_index:
    :return:
    """
    # save original reduce stage action
    ori_reduce_stage_action = copy.deepcopy(progress.action_tensor[rfactor_stage_index])
    # reduce stage's axtion init as a all zero array, because reduce stage not be cut
    action = get_init_action_tensor_zero(1)
    action = action.tolist()[0]
    progress.action_tensor[rfactor_stage_index] = action
    # rfactor stage action use original reduce action
    progress.action_tensor = numpy.insert(progress.action_tensor, rfactor_stage_index, ori_reduce_stage_action, 0)


def update_reduce_stage_axis_info(progress: Progress) -> NoReturn:
    """
    after add rfactor stage, original reduce stage axes need be updated
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    code_lines.extend(['\n', '#  update reduce stage axis info'])
    for stage_index, stage in enumerate(op_schedule_info.schedule_obj.stages):
        stage_name = op_schedule_info.stages_info[stage_index].get('name')
        stage_type = op_schedule_info.stages_info[stage_index].get('type', [])
        if "CacheWrite" in stage_type and "reduce" in stage_type:
            stage_axis_info = []
            for axis_index, axis in enumerate(stage.op.axis):
                axis_name = f'{stage_name}_axis_{axis_index}'
                code_lines.append(f'{axis_name} = sch[{stage_name}].op.axis[{axis_index}]')
                stage_axis_info.append(AxisInfo(axis_name,
                                                stage.op.axis[axis_index].dom.extent.value,
                                                'axis', axis_index, 'axis', axis))

            for axis_index, axis in enumerate(stage.op.reduce_axis):
                axis_name = f'{stage_name}_reduce_axis_{axis_index}'
                code_lines.append(f'{axis_name} = sch[{stage_name}].op.reduce_axis[{axis_index}]')
                stage_axis_info.append(AxisInfo(axis_name,
                                                stage.op.reduce_axis[axis_index].dom.extent.value,
                                                'reduce_axis', axis_index, 'reduce_axis', axis))
            axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[stage_index], stage_index)
            op_schedule_info.cheque_list.extend(axis_cheque_list)
            # now axis_info_list is []，need creat first
            stage_num = len(op_schedule_info.schedule_obj.stages)
            op_schedule_info.axis_info_list = [[]] * stage_num
            op_schedule_info.axis_info_list[stage_index] = stage_axis_info


def update_stages_relevant_info(progress: Progress, reduce_stage_index: int, rfactor_stage_name: str) -> NoReturn:
    """
    after doing rfactor add a stage，need update stage relevant info
    :param progress:
    :param reduce_stage_index:
    :param rfactor_stage_name:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    # update stage index
    rfactor_stage_index = reduce_stage_index
    # because add a stage before reduce stage, so reduce stage index need add 1
    reduce_stage_index = reduce_stage_index + 1
    # reduce gm stage index is behind reduce stage，only through gm stage can get op.tag
    reduce_stage_gm = op_schedule_info.schedule_obj.stages[reduce_stage_index + 1]
    # update stages_info
    add_a_stage_info(progress, rfactor_stage_index, reduce_stage_gm, rfactor_stage_name)
    # update stage_index_map is used in
    update_stage_index_map(progress, reduce_stage_index)
    # update feature
    update_feature(progress)
    # update actions
    update_actions(progress, rfactor_stage_index)
    # update inlined stage
    update_inlined_stages(progress, rfactor_stage_index)
    # update at_dict
    update_at_dict(progress)
    # update dependency_dict
    op_schedule_info.update_dependency_dict()
    # update reduce stage axis info
    update_reduce_stage_axis_info(progress)


def do_rfactor(progress: Progress, reduce_stage_index: int, rfactor_axis_info: AxisInfo) -> NoReturn:
    """
    进行rfactor
    :param progress:
    :param reduce_stage_index:
    :param rfactor_axis_info:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    reduce_tensor = op_schedule_info.schedule_obj.stages[reduce_stage_index].origin_op.output(0)
    rfactor_axis_obj = rfactor_axis_info.body
    last_axis_index = len(op_schedule_info.schedule_obj.stages[reduce_stage_index].leaf_iter_vars) - 1

    # code_lines
    reduce_stage_name = op_schedule_info.stages_info[reduce_stage_index].get('name')
    rfactor_stage_name = f"{reduce_stage_name}_rfactor"
    rfactor_axis_name = rfactor_axis_info.name
    rfactor_code_lines = f"{rfactor_stage_name} = sch.rfactor({reduce_stage_name}, {rfactor_axis_name}, factor_axis=-1)"
    set_scope_code_lines = f"sch[{rfactor_stage_name}].set_scope('{platform_info.scope_ubuf}')"
    code_lines.append(rfactor_code_lines)
    code_lines.append(set_scope_code_lines)

    # rfactor的runtime
    if op_schedule_info.mode == MODE_RUNTIME:
        rfactor_tensor = op_schedule_info.schedule_obj.rfactor(reduce_tensor, rfactor_axis_obj, factor_axis=-1)
        op_schedule_info.schedule_obj[rfactor_tensor].set_scope(platform_info.scope_ubuf)

    # gen rfactor cheque
    cheque = get_rfactor_cheque(reduce_stage_index, last_axis_index, -1)
    op_schedule_info.cheque_list.append(cheque)

    update_stages_relevant_info(progress, reduce_stage_index, rfactor_stage_name)
    # gen set_scope cheque
    cheque = get_set_scope_cheque(reduce_stage_index, platform_info.scope_ubuf)
    op_schedule_info.cheque_list.append(cheque)


def get_reduce_stage_axis_info(progress: Progress, reduce_stage_index: int) -> List:
    """
    get reduce stage axis info
    :param progress:
    :param reduce_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    stage_name = op_schedule_info.stages_info[reduce_stage_index].get('name')
    stage = op_schedule_info.schedule_obj.stages[reduce_stage_index]

    stage_axis_info = []
    for axis_index, axis in enumerate(stage.op.axis):
        axis_name = f'{stage_name}_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.axis[axis_index].dom.extent.value,
                                        'axis', axis_index, 'axis', axis))

    for axis_index, axis in enumerate(stage.op.reduce_axis):
        axis_name = f'{stage_name}_reduce_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.reduce_axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.reduce_axis[axis_index].dom.extent.value,
                                        'reduce_axis', axis_index, 'reduce_axis', axis))

    axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[reduce_stage_index], reduce_stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)

    return stage_axis_info


def proc(progress: Progress):
    """
    last reduce and ub split nlast reduce axis, first do rfactor for last reduce axis,
    then split rf stage
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    if op_schedule_info.is_atomic:
        return

    stages = list(op_schedule_info.schedule_obj.stages)
    # find reduce stage
    for stage_index, _ in enumerate(stages):
        # if not split stage ,continue
        split_vector = progress.action_tensor[stage_index][
                       ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
        if sum(split_vector) == 0:
            continue
        # find ub split axis
        ub_cut_axis = 0
        for i, f in enumerate(split_vector):
            if f > 0:
                ub_cut_axis = i
                break
        # reduce stage stage_info hasattr stage_ordered_axes_obj
        stage_info = op_schedule_info.stages_info[stage_index]
        ordered_axis_obj: StageOrderedAxes = stage_info.get('stage_ordered_axes_obj', None)
        if ordered_axis_obj is None:
            continue
        if not ordered_axis_obj.is_reduce_last():
            continue

        if ub_cut_axis not in ordered_axis_obj.get_reduce_axes()[:-1]:
            return
        # current is before split, axis_info_list is [], so need creat stage_axis_info
        reduce_stage_axis_info = get_reduce_stage_axis_info(progress, stage_index)
        # get last reduce axis，reduce_stage_axis_info order is axis first than reduce_axis
        last_reduce_axis_info = reduce_stage_axis_info[-1]
        do_rfactor(progress, stage_index, last_reduce_axis_info)

        op_schedule_info.last_reduce_and_ub_split_nlast_reduce_axis = True
        break

    return
