#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reused_by rule
"""
from typing import Dict
from typing import NoReturn

from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.t2c_util import MODE_RUNTIME
from auto_search.solution_space.schedule_action.inline.apply_action.rules.\
    comm import get_real_fanin_fanout
from auto_search.bank.cheque_generator import get_reuseby_cheque
from auto_search.solution_space.progress import Progress


def _get_reused_tensor_map(progress: Progress, special_cast_map: Dict) -> NoReturn:
    """
    get_reused_tensor_map
    :param progress:
    :param special_cast_map:
    :return:
    """
    sch = progress.op_schedule_info.schedule_obj
    stages = list(sch.stages)
    for stage_index, stage_info in enumerate(progress.op_schedule_info.stages_info):
        if 'inter_out' not in stage_info.get('type', []):
            continue
        if 'elewise_single_cast' not in stage_info.get('tag', '') and \
                'elewise_single_round' not in stage_info.get('tag', ''):
            continue

        fanin_stage_indices = progress.op_schedule_info.real_fanin_dict[
            stage_index]
        fanout_stage_indices = progress.op_schedule_info.real_fanout_dict[
            stage_index]

        fanin_list, _ = get_real_fanin_fanout(sch, fanin_stage_indices[0])
        _, fanout_list = get_real_fanin_fanout(sch, fanout_stage_indices[0])
        producer_tensor_dtype = stages[fanin_list[0]].op.output(0).dtype
        if "elewise_single_cast" in stages[fanout_list[0]].op.tag \
                and stages[fanout_list[0]].op.output(0).dtype == producer_tensor_dtype:

            reuse_src_index = fanin_list[0]

            factor_vector = progress.action_tensor[reuse_src_index][
                            ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e]
            if sum(factor_vector):
                continue

            dst_stage_index = fanout_list[0]
            progress.op_schedule_info.stages_info[fanin_stage_indices[0]]["need_mem_unique"] = True
            progress.op_schedule_info.stages_info[dst_stage_index]["force_phony_insn"] = True
            special_cast_map[reuse_src_index] = dst_stage_index


def proc(progress: Progress) -> bool:
    """
    special cast do reused_by
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    sch = op_schedule_info.schedule_obj
    stages = list(sch.stages)
    special_cast_with_ori_tensor_map = {}
    _get_reused_tensor_map(progress, special_cast_with_ori_tensor_map)

    for reuse_src_index, dst_stage_index in special_cast_with_ori_tensor_map.items():
        reuse_src_name = op_schedule_info.stages_info[reuse_src_index]["name"]
        reuse_dst_name = op_schedule_info.stages_info[dst_stage_index]["name"]
        if op_schedule_info.mode == MODE_RUNTIME:
            stages[reuse_src_index].reused_by(stages[dst_stage_index].origin_op.output(0))
            stages[dst_stage_index].reused_by(reuse_data=True)

        op_schedule_info.code_lines.append("sch[%s].reused_by(%s)" %
                                           (reuse_src_name, reuse_dst_name))
        op_schedule_info.code_lines.append("sch[%s].reused_by(reuse_data=True)" %
                                           reuse_dst_name)

        # gen cheque
        cheque = get_reuseby_cheque(reuse_src_index, dst_stage_index=dst_stage_index)
        op_schedule_info.cheque_list.append(cheque)
        cheque = get_reuseby_cheque(reuse_src_index, reuse_data=True)
        op_schedule_info.cheque_list.append(cheque)


    return True
