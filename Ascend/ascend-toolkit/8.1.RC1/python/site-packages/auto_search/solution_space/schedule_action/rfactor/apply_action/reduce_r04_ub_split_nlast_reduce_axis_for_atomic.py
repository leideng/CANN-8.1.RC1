#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reduce_r04_ub_split_nlast_reduce_axis_for_atomic
"""
from typing import NoReturn

from tbe.common.platform import platform_info

from auto_search.utils import logger
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.solution_space.t2c_util import MODE_RUNTIME
from auto_search.bank.cheque_generator import get_rfactor_cheque
from auto_search.bank.cheque_generator import get_set_scope_cheque
from auto_search.bank.cheque_generator import get_axis_cheque
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import add_a_stage_info
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_stage_index_map
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_feature
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r02_ub_split_nlast_reduce_axis_for_normal \
    import update_actions
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r01_ub_split_last_reduce_axis_for_normal \
    import update_inlined_stages
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r03_ub_split_last_reduce_axis_for_atomic \
    import update_at_dict
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r02_ub_split_nlast_reduce_axis_for_normal \
    import update_reduce_stage_axis_info
from auto_search.solution_space.schedule_action.rfactor.apply_action.reduce_r02_ub_split_nlast_reduce_axis_for_normal \
    import get_reduce_stage_axis_info


def insert_a_empty_stage_axis_info(progress: Progress, rfactor_stage_index: int) -> NoReturn:
    """
    add rfactor stage axis info
    :param progress:
    :param rfactor_stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    op_schedule_info.axis_info_list.insert(rfactor_stage_index, [])
    axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[rfactor_stage_index], rfactor_stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)


def add_a_stage_axis_info(progress: Progress, reduce_atomic_rfactor_index: int) -> NoReturn:
    """
    add rfactor stage axis info
    :param progress:
    :param reduce_atomic_rfactor_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    stage_name = op_schedule_info.stages_info[reduce_atomic_rfactor_index].get('name')
    stage = op_schedule_info.schedule_obj.stages[reduce_atomic_rfactor_index]

    stage_axis_info = []
    for axis_index, axis in enumerate(stage.op.axis):
        axis_name = f'{stage_name}_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.axis[axis_index].dom.extent.value,
                                        'axis', axis_index, 'axis', axis))

    for axis_index, axis in enumerate(stage.op.reduce_axis):
        axis_name = f'{stage_name}_reduce_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.reduce_axis[{axis_index}]')
        stage_axis_info.append(AxisInfo(axis_name,
                                        stage.op.reduce_axis[axis_index].dom.extent.value,
                                        'reduce_axis', axis_index, 'reduce_axis', axis))

    op_schedule_info.axis_info_list[reduce_atomic_rfactor_index] = stage_axis_info
    axis_cheque_list = \
        get_axis_cheque(op_schedule_info.schedule_obj.stages[reduce_atomic_rfactor_index], reduce_atomic_rfactor_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)


def update_stages_relevant_info(progress: Progress, reduce_atomic_rfactor_index: int,
                                rfactor_stage_name: str) -> NoReturn:
    """
    :param progress:
    :param reduce_atomic_rfactor_index:
    :param rfactor_stage_name:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    # update stage index
    rfactor_stage_index = reduce_atomic_rfactor_index
    reduce_atomic_rfactor_index = reduce_atomic_rfactor_index + 1
    reduce_atomic_rfactor_write = reduce_atomic_rfactor_index + 1
    reduce_stage_gm_index = reduce_atomic_rfactor_write + 1
    # only through gm stage can get op.tag
    reduce_stage_gm = op_schedule_info.schedule_obj.stages[reduce_stage_gm_index]
    # update stages_info
    add_a_stage_info(progress, rfactor_stage_index, reduce_stage_gm, rfactor_stage_name)
    # update stage_index_map is used in
    update_stage_index_map(progress, reduce_atomic_rfactor_index)
    # update feature
    update_feature(progress)
    # update actions
    update_actions(progress, rfactor_stage_index)
    # update axis_info_list
    insert_a_empty_stage_axis_info(progress, rfactor_stage_index)
    # add reduce_atomic_rfactor stage_axis_info
    add_a_stage_axis_info(progress, reduce_atomic_rfactor_index)
    # update inlined stage
    update_inlined_stages(progress, rfactor_stage_index)
    # update at_dict
    update_at_dict(progress)
    # update dependency_dict
    op_schedule_info.update_dependency_dict()
    # update reduce stage axis info
    update_reduce_stage_axis_info(progress)


def do_rfactor(progress: Progress, reduce_atomic_rfactor_index: int, rfactor_axis_info: AxisInfo) -> NoReturn:
    """
    :param progress:
    :param reduce_atomic_rfactor_index:
    :param rfactor_axis_info:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    code_lines = op_schedule_info.code_lines
    reduce_tensor = op_schedule_info.schedule_obj.stages[reduce_atomic_rfactor_index].origin_op.output(0)
    rfactor_axis_obj = rfactor_axis_info.body
    last_axis_index = len(op_schedule_info.schedule_obj.stages[reduce_atomic_rfactor_index].leaf_iter_vars) - 2

    # code_lines
    reduce_stage_name = op_schedule_info.stages_info[reduce_atomic_rfactor_index].get('name')
    rfactor_stage_name = f"{reduce_stage_name}_rfactor"
    rfactor_axis_name = rfactor_axis_info.name
    rfactor_code_lines = f"{rfactor_stage_name} = sch.rfactor({reduce_stage_name}, {rfactor_axis_name}, factor_axis=-1)"
    set_scope_code_lines = f"sch[{rfactor_stage_name}].set_scope('{platform_info.scope_ubuf}')"
    code_lines.append(rfactor_code_lines)
    code_lines.append(set_scope_code_lines)

    # rfactor的runtime
    if op_schedule_info.mode == MODE_RUNTIME:
        rfactor_tensor = op_schedule_info.schedule_obj.rfactor(reduce_tensor, rfactor_axis_obj, factor_axis=-1)
        logger.debug("rfactor_tensor: %s, %s", rfactor_tensor, type(rfactor_tensor))
        op_schedule_info.schedule_obj[rfactor_tensor].set_scope(platform_info.scope_ubuf)

    # gen rfactor cheque
    cheque = get_rfactor_cheque(reduce_atomic_rfactor_index, last_axis_index, -1)
    op_schedule_info.cheque_list.append(cheque)

    update_stages_relevant_info(progress, reduce_atomic_rfactor_index, rfactor_stage_name)
    # gen set_scope cheque
    reduce_rfactor_index = reduce_atomic_rfactor_index
    cheque = get_set_scope_cheque(reduce_rfactor_index, platform_info.scope_ubuf)
    op_schedule_info.cheque_list.append(cheque)


def proc(progress: Progress):
    """
    atomic last reduce, and ub split nlast reduce axis, do rfactor for last reduce axis, than split new rf stage
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    if not op_schedule_info.is_atomic:
        return

    stages = list(op_schedule_info.schedule_obj.stages)
    # find reduce stage
    for stage_index, _ in enumerate(stages):
        # only proc split stage
        split_vector = progress.action_tensor[stage_index][
                       ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
        if sum(split_vector) == 0:
            continue

        reduce_info_for_rfactor = progress.todo.reduce_info_for_rfactor
        if not reduce_info_for_rfactor.is_last_reduce:
            return
        if reduce_info_for_rfactor.ub_split_last_reduce_axis:
            return

        op_schedule_info.atomic_last_reduce_and_ub_split_nlast_reduce_axis = True
        # current is before split, axis_info_list is [], so need creat stage_axis_info
        reduce_stage_axis_info = get_reduce_stage_axis_info(progress, stage_index)
        # get last reduce axis，reduce_stage_axis_info order is axis first than reduce_axis
        # reduce_stage_axis_info[-1] is nlast reduce_axis inner after split,
        # so last reduce_axis is reduce_stage_axis_info[-2] actually
        # eg: a0 r0 a1 r1, atomic split r0 , a0 r0_o r0_i a1 r1, after r0_o do rfactor(factor_axis=-1),
        # reduce_rfactor axis order is a0 a1 r0_o a1 r1 r0_i
        last_reduce_axis_info = reduce_stage_axis_info[-2]
        do_rfactor(progress, stage_index, last_reduce_axis_info)
        break

    return
