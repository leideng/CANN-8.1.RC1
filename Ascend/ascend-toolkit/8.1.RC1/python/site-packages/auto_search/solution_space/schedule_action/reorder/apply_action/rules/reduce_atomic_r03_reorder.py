#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
auto search
"""
from typing import List
from typing import Dict
from typing import NoReturn

from auto_search.utils import logger
from auto_search.solution_space import t2c_util
from auto_search.solution_space.progress import Progress


def _reorder_for_reduce_rfactor(progress: Progress, a_axis_info: List, r_axis_info: List) -> tuple:
    """
    :param progress:
    :param a_axis_info:
    :param r_axis_info:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    ub_split_info = op_schedule_info.atomic_ub_split_info
    block_split_info = op_schedule_info.atomic_block_split_info
    if op_schedule_info.atomic_last_reduce_and_ub_split_last_reduce_axis:
        # reorder to (rbo_fused, ak, ak-1, a2, a1, rbi,rb-1,r2,r1_outer ,rf_rf)
        # rf_rf is the r1_inner after rfactor, rf_rf is last axis in a_axis_info(factor_axis=-1)
        # rbo_fused is second to last in a_axis_info
        # r1_outer is last axis in r_axis_info
        # rbi is second to last in r_axis_info
        if len(a_axis_info) >= 2:
            if len(r_axis_info) >= 2:
                # rbi(rbi is second to last in r_axis_info) reorder forefront r_axis_info
                r_axis_info = r_axis_info[-2:-1] + r_axis_info[:-2] + r_axis_info[-1:]
            # rf_rf reorder to backmost r_axis_info
            r_axis_info = r_axis_info + a_axis_info[-1:]
            # a_axis_info remove rf_rf
            a_axis_info = a_axis_info[:-1]
            # rbo_fused reorder to forefront a_axis_info
            a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]
    elif op_schedule_info.atomic_last_reduce_and_ub_split_nlast_reduce_axis:
        if block_split_info.axis_index != ub_split_info.axis_index:
            # block and ub split same r axis
            # reorder to (rbo_fused, ak, ak-1, a2, a1, rbi, rb-1, rb-2 ,ruo+1, ruo, rui, ru-1, ru-2, r2, r1, rf_rf)
            # rf_rf is last axis in a_axis_info(factor_axis=-1)
            # rbo_fused is second to last in a_axis_info
            # rbi is the last axis in r_axis_info

            # rbi reorder to forefront r_axis_info
            r_axis_info = r_axis_info[-1:] + r_axis_info[:-1]
            # rf_rf reorder to backmost r_axis_info
            r_axis_info = r_axis_info + a_axis_info[-1:]
            # a_axis_info remove rf_rf
            a_axis_info = a_axis_info[:-1]
            # rbo_fused reorder to forefront a_axis_info
            a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]
        else:
            # block and ub split not same r axis,
            # reorder to (rbo_fused, ak, ak-1, a2, a1, rbi_o,rbi_i,rb-1,..r2,r1, rf_rf)
            # rf_rf is last axis in a_axis_info(factor_axis=-1)
            # rbo_fused is second to last in a_axis_info
            # rbi_i is the last axis in r_axis_info
            # rbi_o is second to last in r_axis_info

            # rbi_o and  rbi_i which is last two axis in r_axis_info should be reordered to forefront of r_axis_info
            if len(r_axis_info) < 2:
                raise RuntimeError("reduce_atomic_rfactor reduce axis must bigger equal than 2 after split rbi!")
            r_axis_info = r_axis_info[-2:] + r_axis_info[:-2]
            # rf_rf reorder to backmost r_axis_info
            r_axis_info = r_axis_info + a_axis_info[-1:]
            # a_axis_info remove rf_rf
            a_axis_info = a_axis_info[:-1]
            # rbo_fused reorder to forefront a_axis_info
            a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]

    return a_axis_info, r_axis_info


def _reorder_for_reduce_atomic_rfactor_last(progress: Progress, a_axis_info: List, r_axis_info: List,
                                       stage_info: Dict) -> tuple:
    """
    :param progress:
    :param a_axis_info:
    :param r_axis_info:
    :param stage_info:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    ub_split_info = op_schedule_info.atomic_ub_split_info
    block_split_info = op_schedule_info.atomic_block_split_info
    ub_split_axis_type = stage_info.get('split_axis_type', None)

    # split normal axis reorder to (rbo_fused, ak,..a_ub_o, a_ub_i,..a1,rbi,rb-1,..r2,r1)
    if ub_split_axis_type == 'axis':
        # rbo_fused reorder to forefront a_axis_info
        a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]
        # rbi reorder to forefront r_axis_info
        r_axis_info = r_axis_info[-1:] + r_axis_info[:-1]
    # split reduce axis
    elif ub_split_axis_type == 'reduce_axis':
        if op_schedule_info.atomic_last_reduce_and_ub_split_last_reduce_axis \
                or op_schedule_info.atomic_last_reduce_and_ub_split_nlast_reduce_axis:
            # because do reduce rfactor optimize, so this stage only has one reduce_axis
            # reorder to (rbo_fused, ak,..a1,r1)
            # rbo_fused reorder to forefront a_axis_info
            a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]
        else:
            if block_split_info.axis_index == ub_split_info.axis_index:
                # rbo_fused reorder to forefront a_axis_info
                a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]
                # rbi_o and  rbi_i which is last two axis in r_axis_info
                # should be reordered to forefront of r_axis_info
                r_axis_info = r_axis_info[-2:] + r_axis_info[:-2]
            else:
                # rbo_fused reorder to forefront a_axis_info
                a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]
                # rbi reorder to forefront r_axis_info
                r_axis_info = r_axis_info[-1:] + r_axis_info[:-1]

    return a_axis_info, r_axis_info


def _reorder_for_reduce_atomic_rfactor(progress: Progress, a_axis_info: List, r_axis_info: List,
                                       stage_info: Dict) -> tuple:
    """
    :param progress:
    :param a_axis_info:
    :param r_axis_info:
    :param stage_info:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    ub_split_info = op_schedule_info.atomic_ub_split_info
    block_split_info = op_schedule_info.atomic_block_split_info
    ub_split_axis_type = stage_info.get('split_axis_type', None)
    if not op_schedule_info.compute_graph_info.is_last_reduce:
        # nlast reduce
        # reduce reorder to (rbo_fused, ak,..a2,rbi,rb-1,..r2,r1,a1)
        # rbo_fused is last axis in a_axis_info(factor_axis=-1)
        # a1 is second to last in a_axis_info
        # rbi is last reduce axis in r_axis_info
        if block_split_info.axis_index == ub_split_info.axis_index and ub_split_axis_type == 'reduce_axis':
            # rbo_fused reorder to forefront a_axis_info
            a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]
            # rbi_o and  rbi_i which is last two axis in r_axis_info should be reordered to forefront of r_axis_info
            if len(r_axis_info) < 2:
                raise RuntimeError("reduce_atomic_rfactor reduce axis must bigger equal than 2 after split rbi!")
            r_axis_info = r_axis_info[-2:] + r_axis_info[:-2]
            # a1 reorder to backmost r_axis_info
            r_axis_info = r_axis_info + a_axis_info[-1:]
            # a_axis_info remove a1
            a_axis_info = a_axis_info[:-1]
        else:
            # rbo_fused reorder to forefront a_axis_info
            a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]
            # rbi reorder to forefront r_axis_info
            r_axis_info = r_axis_info[-1:] + r_axis_info[:-1]
            # a1 reorder to backmost r_axis_info
            r_axis_info = r_axis_info + a_axis_info[-1:]
            # a_axis_info remove a1
            a_axis_info = a_axis_info[:-1]
    else:
        # last reduce
        a_axis_info, r_axis_info = _reorder_for_reduce_atomic_rfactor_last(progress, a_axis_info, r_axis_info,
                                                                           stage_info)

    return a_axis_info, r_axis_info


def _reorder_for_reduce_atomic_write(progress: Progress, a_axis_info: List, r_axis_info: List) -> tuple:
    """
    :param progress:
    :param a_axis_info:
    :param r_axis_info:
    :return:
    """
    # reorder (ak,..a2,a1,rbo) to (rbo,ak,..a2,a1) rbo is the only reduce_axis in reduce_atomic_write stage
    if len(r_axis_info) != 1:
        raise RuntimeError("reduce_atomic_write only have one reduce axis after do atomic rfactor!")

    op_schedule_info = progress.op_schedule_info
    if op_schedule_info.enable_atomic_ra_bind:
        for info_index, axis_info in enumerate(a_axis_info):
            if axis_info.name.endswith('_o'):
                r_axis_info.append(axis_info)
                a_axis_info = a_axis_info[: info_index] + a_axis_info[info_index + 1:]

    a_axis_info = r_axis_info + a_axis_info
    r_axis_info = []
    return a_axis_info, r_axis_info


def _check_is_need_do_reorder(progress: Progress, stage_idx: int, stage_axis_list: List) -> bool:
    """
    check current stage is need reorder or not
    :param t2c_params:
    :param stage_idx:
    :param stage_axis_list:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    if stage_axis_list is None:
        return False

    stage_info = op_schedule_info.stages_info[stage_idx]
    if not (set(stage_info.get('type', []))
            & {'reduce_atomic_rfactor', 'reduce_atomic_write', 'reduce_rfactor'}):
        return False
    return True


def _reorder_for_reduce_atomic_rfactor_ra_bind(progress, a_axis_info, r_axis_info, stage_info):
    """

    :param progress:
    :param a_axis_info:
    :param r_axis_info:
    :param stage_info:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    ub_split_info = op_schedule_info.atomic_ub_split_info
    if not op_schedule_info.compute_graph_info.is_last_reduce:
        # nlast reduce
        # reduce reorder to (rbo_fused, ak,..a2,rbi,rb-1,..r2,r1,a1)
        # rbo_fused is last axis in a_axis_info(factor_axis=-1)
        # a1 is second to last in a_axis_info
        # rbi is last reduce axis in r_axis_info
        if ub_split_info.axis_index == 0:
            # r0a0r1a1 ub split r0_inner
            # rbo_fused reorder to forefront a_axis_info
            a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]
            # rbi_o and  rbi_i which is last two axis in r_axis_info should be reordered to forefront of r_axis_info
            r_axis_info = r_axis_info[-2:] + r_axis_info[:-2]
            # a1 reorder to backmost r_axis_info
            r_axis_info = r_axis_info + a_axis_info[-1:]
            # a_axis_info remove a1
            a_axis_info = a_axis_info[:-1]
        else:
            # rbo_fused reorder to forefront a_axis_info
            a_axis_info = a_axis_info[-1:] + a_axis_info[:-1]
            # rbi reorder to forefront r_axis_info
            r_axis_info = r_axis_info[-1:] + r_axis_info[:-1]
            # a1 reorder to backmost r_axis_info
            r_axis_info = r_axis_info + a_axis_info[-1:]
            # a_axis_info remove a1
            a_axis_info = a_axis_info[:-1]
    else:
        # last reduce
        a_axis_info, r_axis_info = _reorder_for_reduce_atomic_rfactor_last(progress, a_axis_info, r_axis_info,
                                                                           stage_info)

    return a_axis_info, r_axis_info


def _reorder_for_reduce_atomic_rfactor_proc(progress, a_axis_info, r_axis_info, stage_info):
    """

    :param progress:
    :param a_axis_info:
    :param r_axis_info:
    :param stage_info:
    :return:
    """
    if progress.op_schedule_info.enable_atomic_ra_bind:
        a_axis_info, r_axis_info = _reorder_for_reduce_atomic_rfactor_ra_bind(
            progress, a_axis_info, r_axis_info, stage_info)
    else:
        a_axis_info, r_axis_info = _reorder_for_reduce_atomic_rfactor(
            progress, a_axis_info, r_axis_info, stage_info)
    return a_axis_info, r_axis_info


def proc(progress: Progress) -> NoReturn:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    atomic_flag = op_schedule_info.is_atomic
    if not atomic_flag:
        return

    leveled_axis_list = []
    op_schedule_info.leveled_axis_for_reorder = leveled_axis_list
    for stage_idx, stage_axis_list in enumerate(op_schedule_info.axis_info_list):
        leveled_axis = [[], [], [], [], [], [], []]
        leveled_axis_list.append(leveled_axis)
        # skip the stage without need to reorder
        if not _check_is_need_do_reorder(progress, stage_idx, stage_axis_list):
            continue

        # collect a and r axis
        a_axis_info, r_axis_info = [], []
        for axis_info in stage_axis_list:
            if 'reduce_axis' in axis_info.name:
                r_axis_info.append(axis_info)
            else:
                a_axis_info.append(axis_info)

        stage_info = op_schedule_info.stages_info[stage_idx]
        if 'reduce_atomic_rfactor' in stage_info.get('type'):
            a_axis_info, r_axis_info = _reorder_for_reduce_atomic_rfactor_proc(progress, a_axis_info, r_axis_info,
                                                                               stage_info)
        elif 'reduce_atomic_write' in stage_info.get('type'):
            a_axis_info, r_axis_info = _reorder_for_reduce_atomic_write(progress, a_axis_info, r_axis_info)
        elif 'reduce_rfactor' in stage_info.get('type'):
            a_axis_info, r_axis_info = _reorder_for_reduce_rfactor(progress, a_axis_info, r_axis_info)

        leveled_axis[t2c_util.AXIS_LEVEL_O_INDEX] = a_axis_info
        leveled_axis[t2c_util.AXIS_LEVEL_I_II_NORMAL_INDEX] = r_axis_info

    logger.debug('leveled_axis_for_reorder: %s', op_schedule_info.leveled_axis_for_reorder)
