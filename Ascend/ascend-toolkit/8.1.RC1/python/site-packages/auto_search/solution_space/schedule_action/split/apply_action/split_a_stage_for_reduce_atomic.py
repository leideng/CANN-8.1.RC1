#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
auto schedule
"""
import math
from typing import List
from typing import NoReturn

from auto_search.utils import logger
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.solution_space.tensor_cfg import ActionTensorCfg
from auto_search.bank.cheque_generator import get_split_cheque
from auto_search.bank.cheque_generator import get_axis_cheque
from auto_search.solution_space.t2c_util import SplitInfo
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.op_schedule_info import OpScheduleInfo
from auto_search.solution_space.schedule_action.split.apply_action.reduce_comm import gen_split_info
from auto_search.solution_space.schedule_action.split.apply_action.reduce_comm import do_split


def gen_a_stage_axis_info(op_schedule_info: OpScheduleInfo, stage_index: int, ub_split_info: SplitInfo,
                          block_split_axis_index: int, code_lines: List) -> List:
    """
    :param op_schedule_info:
    :param stage_index:
    :param ub_split_info:
    :param block_split_axis_index:
    :param code_lines:
    :return:
    """
    stage_name = op_schedule_info.stages_info[stage_index].get('name')
    stage = op_schedule_info.schedule_obj.stages[stage_index]
    ub_split_axis_type = op_schedule_info.stages_info[stage_index].get('split_axis_type', None)
    if ub_split_axis_type is None:
        logger.error("ub_split_axis_type can not be None!")
        return []
    ub_split_axis_in_type = ub_split_info.axis_index

    if ub_split_axis_type == 'reduce_axis':
        if op_schedule_info.enable_atomic_ra_bind:
            # multi reduce_axis, split not_last_reduce_axis, reduce_axis_o doing rfactor,  will be put into innermost
            # example: reduce_axis_0/reduce_axis_1: split reduce_axis_0 -> reduce_axis_0_o, reduce_axis_0_i,
            # after rfactor, reduce_axis: reduce_axis_1, reduce_axis_0_i
            ub_split_axis_in_type = len(stage.op.reduce_axis) - ub_split_info.axis_index - 1
        elif block_split_axis_index == ub_split_info.axis_index:
            # if block split axis index is equal to ub split axis,
            # ub split the r_b_inner axis which is the last r axis in reduce_axis list
            ub_split_axis_in_type = len(stage.op.reduce_axis) - 1
        else:
            # after block tiling and do rfactor, the reduce_axis before block_split_axis_index
            # has been fused and become normal axis, block_split_inner(r_b_inner) axis put in the last reduce_axis,
            # so find ub_split_axis_in_type in reduce_axis as follows:
            ub_split_axis_in_type = ub_split_axis_in_type - 1 - block_split_axis_index

    # add no split axis
    a_stage_axis_info = []
    for axis_index, axis in enumerate(stage.op.axis):
        if not (axis_index == ub_split_axis_in_type and ub_split_axis_type == 'axis'):
            axis_name = f'{stage_name}_axis_{axis_index}'
            code_lines.append(f'{axis_name} = sch[{stage_name}].op.axis[{axis_index}]')
            a_stage_axis_info.append(AxisInfo(axis_name,
                                              stage.op.axis[axis_index].dom.extent.value,
                                              'axis', axis_index, 'all', axis))

    r_stage_axis_info = []
    for axis_index, axis in enumerate(stage.op.reduce_axis):
        if not (axis_index == ub_split_axis_in_type and ub_split_axis_type == 'reduce_axis'):
            axis_name = f'{stage_name}_reduce_axis_{axis_index}'
            code_lines.append(f'{axis_name} = sch[{stage_name}].op.reduce_axis[{axis_index}]')
            r_stage_axis_info.append(AxisInfo(axis_name,
                                              stage.op.reduce_axis[axis_index].dom.extent.value,
                                              'reduce_axis', axis_index, 'all', axis))

    # add split axis
    if ub_split_axis_type == 'axis':
        axis = stage.op.axis[ub_split_axis_in_type]
        axis_o_len = math.floor((axis.dom.extent.value + ub_split_info.factor - 1) / ub_split_info.factor)
        a_stage_axis_info.insert(ub_split_axis_in_type,
                                 AxisInfo(ub_split_info.outer_axis_name, axis_o_len,
                                          'axis', ub_split_axis_in_type, 'o', ub_split_info.outer_axis_obj))
        a_stage_axis_info.insert(ub_split_axis_in_type + 1,
                                 AxisInfo(ub_split_info.inner_axis_name, ub_split_info.factor,
                                          'axis', ub_split_axis_in_type, 'i', ub_split_info.inner_axis_obj))
    elif ub_split_axis_type == 'reduce_axis':
        axis = stage.op.reduce_axis[ub_split_axis_in_type]
        axis_o_len = math.floor((axis.dom.extent.value + ub_split_info.factor - 1) / ub_split_info.factor)

        r_stage_axis_info.insert(ub_split_axis_in_type,
                                 AxisInfo(ub_split_info.outer_axis_name, axis_o_len,
                                          'reduce_axis', ub_split_axis_in_type, 'o', ub_split_info.outer_axis_obj))
        r_stage_axis_info.insert(ub_split_axis_in_type + 1,
                                 AxisInfo(ub_split_info.inner_axis_name, ub_split_info.factor,
                                          'reduce_axis', ub_split_axis_in_type, 'i', ub_split_info.inner_axis_obj))

    return a_stage_axis_info + r_stage_axis_info


def update_reduce_atomic_dict(op_schedule_info: OpScheduleInfo, stage_axis_info: List) -> NoReturn:
    """
    :param op_schedule_info:
    :param stage_axis_info:
    :return:
    """
    ub_outer_axis_info = None
    ub_inner_axis_info = None
    for axis_info in stage_axis_info:
        if axis_info.attr == 'o':
            ub_outer_axis_info = axis_info
        if axis_info.attr == 'i':
            ub_inner_axis_info = axis_info

    reduce_atomic_dict = {
        "ub_outer_axis_info": ub_outer_axis_info,
        "ub_inner_axis_info": ub_inner_axis_info
    }
    op_schedule_info.reduce_atomic_dict.update(reduce_atomic_dict)


def _get_axis_index(rfactor_stage, ub_split_info):
    """
    :param rfactor_stage:
    :param ub_split_info:
    :return:
    """
    all_axes = list(rfactor_stage.leaf_iter_vars)
    axis_index_in_all_axes = 0
    for axis_idx, axis in enumerate(all_axes):
        if axis == ub_split_info.axis_obj:
            axis_index_in_all_axes = axis_idx
            break

    return axis_index_in_all_axes


def do_ub_tiling(op_schedule_info: OpScheduleInfo, code_lines: List, rfactor_stage_index: int,
                 block_split_axis_index: int,
                 ub_split_info: SplitInfo) -> List:
    """
    do atomic ub tiling
    :param op_schedule_info:
    :param code_lines:
    :param rfactor_stage_index:
    :param block_split_axis_index:
    :param ub_split_info:
    :return:
    """
    # record ub_split_axis_type
    ub_split_axis_type = op_schedule_info.stages_info[rfactor_stage_index].get('split_axis_type', 'reduce_axis')
    code_lines.append('# split_axis_type: %s' % ub_split_axis_type)

    rfactor_stage = op_schedule_info.schedule_obj.stages[rfactor_stage_index]
    rfactor_stage_name = op_schedule_info.stages_info[rfactor_stage_index].get('name')

    if ub_split_axis_type == 'reduce_axis' and op_schedule_info.enable_atomic_ra_bind:
        # multi reduce_axis, split not_last_reduce_axis, reduce_axis_o doing rfactor,  will be put into innermost
        # example: reduce_axis_0/reduce_axis_1: split reduce_axis_0 -> reduce_axis_0_o, reduce_axis_0_i,
        # after rfactor, reduce_axis: reduce_axis_1, reduce_axis_0_i
        axis_name = f'sch[{rfactor_stage_name}].op.' \
                    f'reduce_axis[{len(rfactor_stage.op.reduce_axis) - ub_split_info.axis_index - 1}]'
        ub_split_info = gen_split_info(ub_split_info, axis_name=axis_name,
            axis_obj=rfactor_stage.op.reduce_axis[len(rfactor_stage.op.reduce_axis) - ub_split_info.axis_index - 1])
    elif ub_split_axis_type == 'reduce_axis' and block_split_axis_index == ub_split_info.axis_index:
        # if ub split axis is same as block split axis, this reduce_axis has been split before,
        # so need split inner reduce_axis which is the last axis in reduce_axis list after doing rfactor
        axis_name = f'sch[{rfactor_stage_name}].op.reduce_axis[{len(rfactor_stage.op.reduce_axis) - 1}]'
        ub_split_info = gen_split_info(ub_split_info, axis_name=axis_name,
                                       axis_obj=rfactor_stage.op.reduce_axis[len(rfactor_stage.op.reduce_axis) - 1])

    prefix = 'axis' if ub_split_axis_type == 'axis' else 'reduce_axis'
    rfactor_split_axis_name = f'{rfactor_stage_name}_{prefix}_{ub_split_info.axis_index}'

    code_lines.append(f'{rfactor_split_axis_name}_o, {rfactor_split_axis_name}_i = '
                      f'sch[{rfactor_stage_name}].split({ub_split_info.axis_name}, factor={ub_split_info.factor})')

    axis_index_in_all_axes = _get_axis_index(rfactor_stage, ub_split_info)

    # run time
    ub_split_axis_obj_o, ub_split_axis_obj_i = rfactor_stage.split(ub_split_info.axis_obj, factor=ub_split_info.factor)
    ub_split_info = gen_split_info(ub_split_info,
                                   outer_axis_name='%s_o' % rfactor_split_axis_name,
                                   outer_axis_obj=ub_split_axis_obj_o,
                                   inner_axis_name='%s_i' % rfactor_split_axis_name,
                                   inner_axis_obj=ub_split_axis_obj_i)
    if ub_split_info.factor == 0:
        logger.error(f'Invalid factor: {ub_split_info.factor}')
        raise RuntimeError(f'Invalid factor: {ub_split_info.factor}')

    # gen rfactor_stage axis info
    rfactor_stage_axis_info = gen_a_stage_axis_info(op_schedule_info, rfactor_stage_index, ub_split_info,
                                                    block_split_axis_index, code_lines)

    cheque = get_split_cheque(rfactor_stage_index, axis_index_in_all_axes, ub_split_info.factor)
    op_schedule_info.cheque_list.append(cheque)

    return rfactor_stage_axis_info


def update_split_info(progress: Progress, split_info: SplitInfo, split_stage_index) -> SplitInfo:
    """
    because progress is deepcopy after every action, axis obj is changed, should update
    :param progress:
    :param split_info:
    :param split_stage_index:
    :return:
    """
    stages = list(progress.op_schedule_info.schedule_obj.stages)
    stage = stages[split_stage_index]
    for axis_var in stage.leaf_iter_vars:
        if axis_var.var.name == split_info.axis_obj.var.name:
            split_info.axis_obj = axis_var
            break

    return split_info


def last_reduce_and_ub_split_nlast_reduce_axis_proc(progress: Progress, stage_index: int) -> tuple:
    """
    last reduce split nlast reduce axis，should split rfactor stage
    :param progress:
    :param stage_index:
    :return:
    """
    code_lines = []
    split_vector = progress.action_tensor[stage_index][
                   ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    cut_axis, factor = 0, 1
    for i, f in enumerate(split_vector):
        if f > 0:
            cut_axis, factor = i, f
            break

    reduce_gm_stage_info = progress.op_schedule_info.stages_info[-1]
    reduce_ordered_axes_obj = reduce_gm_stage_info['stage_ordered_axes_obj']
    cut_aiw = reduce_ordered_axes_obj.get_cut_axis_info_wrapper(cut_axis)
    cut_axis_in_reduce_axes = cut_aiw.idx_by_type

    code_lines.append(f'# split factor info: {list(split_vector)}')
    code_lines.append(f'# chosen split axis: {cut_axis}')
    code_lines.append(f'# cut_axis in reduce axes: {cut_axis_in_reduce_axes}')

    stage_axis_info = do_split(progress.op_schedule_info, stage_index, cut_axis_in_reduce_axes, factor, code_lines)

    return code_lines, stage_axis_info, cut_axis


def split_a_stage_for_reduce_atomic(progress: Progress, stage_index: int) -> tuple:
    """
    reduce atomic split
    :param progress:
    :param stage_index:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    stage_info = op_schedule_info.stages_info[stage_index]
    cut_axis_index = None
    rfactor_stage_axis_info = None
    if op_schedule_info.atomic_last_reduce_and_ub_split_nlast_reduce_axis and \
            'reduce_rfactor' in stage_info.get('type'):
        return last_reduce_and_ub_split_nlast_reduce_axis_proc(progress, stage_index)

    if 'reduce_atomic_rfactor' not in op_schedule_info.stages_info[stage_index].get('type', []):
        logger.error("not reduce_atomic stage!")
        return [], rfactor_stage_axis_info, cut_axis_index

    ub_split_info = update_split_info(progress, op_schedule_info.atomic_ub_split_info, stage_index)
    block_split_info = update_split_info(progress, op_schedule_info.atomic_block_split_info, -1)

    code_lines = []
    rfactor_stage_index = stage_index
    rfactor_stage_axis_info = do_ub_tiling(op_schedule_info, code_lines, rfactor_stage_index,
                                           block_split_info.axis_index, ub_split_info)
    update_reduce_atomic_dict(op_schedule_info, rfactor_stage_axis_info)

    logger.debug("atomic split end.")

    return code_lines, rfactor_stage_axis_info, cut_axis_index
