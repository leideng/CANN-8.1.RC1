#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
common director
"""
from auto_search.utils import logger
from auto_search.solution_space.action import apply_action_register
from auto_search.solution_space.action import ScheduleActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.compute_analysis.reduce_compute_graph import SPLIT_FACTOR_S
from auto_search.compute_analysis.reduce_compute_graph import SPLIT_FACTOR_E
from auto_search.compute_analysis.reduce_compute_graph import find_cut_axis_index
from auto_search.solution_space.schedule_action.storage_align.apply_action.rules \
    .r02_reduce_atomic_align import proc as atomic_proc
from auto_search.solution_space.schedule_action.storage_align.apply_action.rules \
    .r01_reduce_normal_align import proc as normal_reduce_proc


@apply_action_register([ComputePattern.TUPLE_REDUCE, ComputePattern.REDUCE], ScheduleActionType.STORAGE_ALIGN)
def apply(progress):
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    # last reduce, ub split axis is last r axis, need not do storage_align
    if not _need_storage_align(progress):
        return
    # if reduce enable ub_transpose, don't need do storage_align
    if op_schedule_info.is_ub_transpose:
        return
    op_schedule_info = progress.op_schedule_info
    atomic_flag = op_schedule_info.is_atomic
    if atomic_flag:
        ret = atomic_proc(progress)
    else:
        ret = normal_reduce_proc(progress)
    if ret:
        logger.debug("reduce storage_align is OK")
    else:
        raise RuntimeError("reduce storage_align is failed!")

    logger.debug("apply reduce storage_align done.")
    return


def _need_storage_align(progress):
    """
    these scene need not do storage align:
    1. last reduce and ub split last reduce axis
    2. nlast reduce and ub split last a axis
    :param progress:
    :return:
    """
    # split_stage_num == 1 only split res
    # split_stage_num == 2 only split res and reduce

    op_schedule_info = progress.op_schedule_info
    stages = list(op_schedule_info.schedule_obj.stages)
    is_atomic = progress.op_schedule_info.is_atomic
    is_last_reduce = progress.op_schedule_info.compute_graph_info.is_last_reduce

    if is_atomic:
        ub_split_stage_index = len(stages) - 1
        ub_cut_axis = find_cut_axis_index(progress, ub_split_stage_index)
        # last reduce and ub split last reduce axis, need not do storage align
        if is_last_reduce and ub_cut_axis == progress.op_schedule_info.compute_graph_info.reduce_axes_index[-1]:
            return False
        # nlast reduce and ub split last a axis, need not do storage align
        if not is_last_reduce and ub_cut_axis == progress.op_schedule_info.compute_graph_info.normal_axes_index[-1]:
            return False

    else:
        split_stage_num, ub_split_stage_index = _get_split_num_and_stage_index(progress, stages)
        if split_stage_num == 1:
            # only split res stage, do storage_align
            return True
        elif split_stage_num == 2:
            ub_cut_axis = find_cut_axis_index(progress, ub_split_stage_index)
            # last reduce and ub split last reduce axis, need not do storage align
            if is_last_reduce and ub_cut_axis == progress.op_schedule_info.compute_graph_info.reduce_axes_index[-1]:
                return False
            # nlast reduce and ub split last a axis, need not do storage align
            if not is_last_reduce and ub_cut_axis == progress.op_schedule_info.compute_graph_info.normal_axes_index[-1]:
                return False

    if ub_split_stage_index is None:
        raise RuntimeError("can not find reduce ub stage!")

    return True


def _get_split_num_and_stage_index(progress, stages):
    """
    :param progress:
    :param stages:
    :return:
    """
    op_schedule_info = progress.op_schedule_info
    ub_split_stage_index = None
    split_stage_num = 0
    for stage_index, _ in enumerate(stages):
        split_vector = progress.action_tensor[stage_index][SPLIT_FACTOR_S:SPLIT_FACTOR_E + 1]
        if sum(split_vector) != 0:
            split_stage_num = split_stage_num + 1

        if 'CacheWrite' in op_schedule_info.stages_info[stage_index].get('type', []) \
                and 'reduce' in op_schedule_info.stages_info[stage_index].get('type', []):
            ub_split_stage_index = stage_index
    return split_stage_num, ub_split_stage_index
