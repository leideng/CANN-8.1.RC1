#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
common apply action
"""
from typing import NoReturn

from tbe import tvm

from auto_search.solution_space.schedule_action.storage_align.apply_action.transpose_comm \
    import calc_trs_split_axis
from auto_search.solution_space.schedule_action.storage_align.apply_action.transpose_comm \
    import calc_trs_reorder_action
from auto_search.bank.cheque_generator import get_storage_align_cheque
from auto_search.solution_space.op_schedule_info import OpScheduleInfo
from auto_search.utils import logger
from auto_search.utils import util
from auto_search.solution_space.action import apply_action_register
from auto_search.solution_space.action import ScheduleActionType
from auto_search.compute_analysis import ComputePattern
from auto_search.solution_space.t2c_util import MODE_RUNTIME


def last_axis_has_cross(ori_permute: list, high_ub_split_axis: int, low_ub_split_axis: int) -> bool:
    """
    last axis has cross or not
    :param ori_permute:
    :param high_ub_split_axis:
    :param low_ub_split_axis:
    :return:
    """
    ori_perm = []
    for index in ori_permute:
        ori_perm.append(int(index))
    permute = sorted(range(len(ori_perm)), key=ori_perm.__getitem__)

    dim_len = len(ori_permute)
    is_last_transpose = ori_permute[dim_len - 1] != dim_len - 1
    src_in_ub_by_out = permute[ori_permute[low_ub_split_axis]:]
    base_order = list(range(len(permute)))
    consequent_dst = base_order[high_ub_split_axis:]
    last_has_cross = is_last_transpose and any(i in consequent_dst for i in src_in_ub_by_out)

    return last_has_cross


def calc_storage_align(ori_permute: list,
                       high_ub_split_axis: int, low_ub_split_axis: int,
                       reorder_in_index: int, reorder_out_index: int) -> [list, bool]:
    """
    calculate storage_align axis index
    :param ori_permute:
    :param permute:
    :param high_ub_split_axis:
    :param low_ub_split_axis:
    :param reorder_in_index:
    :param reorder_out_index:
    :return:
    """
    ori_perm = []
    for ind in ori_permute:
        ori_perm.append(int(ind))
    permute = sorted(range(len(ori_perm)), key=ori_perm.__getitem__)

    # split out: all axes after out_split_axis, include itself
    # split input axis in input_tensor
    # split out axes in input_tensor
    out_in_input_split = []
    for axis in ori_perm[high_ub_split_axis:]:
        if axis < ori_perm[low_ub_split_axis]:
            out_in_input_split.append(axis)
    # find align axis in input_order_tensor index
    input_align_axis = -1
    for index, value in enumerate(reorder_in_index):
        if value in out_in_input_split:
            input_align_axis = index

    out_in_output_split = []
    for axis in permute[ori_perm[low_ub_split_axis]:]:
        if axis < high_ub_split_axis:
            out_in_output_split.append(axis)
    output_align_axis = -1
    for index, value in enumerate(reorder_out_index):
        if value in out_in_output_split:
            output_align_axis = index

    return [input_align_axis, output_align_axis]


def align_a_trs_stage(stage_name: str, align_axis_index: int,
                      op_schedule_info: OpScheduleInfo, stage_index: int, last_has_cross: bool) -> list:
    """
    align transpose stage
    :param stage:
    :param stage_name:
    :param align_axis_index:
    :param op_schedule_info:
    :return:
    """
    stage = op_schedule_info.schedule_obj.stages[stage_index]
    vector_block_num = util.get_block_num(stage.op.output(0).dtype)
    if align_axis_index < 0:
        return []

    # b32 and b64 last_tranpose, output tensor align condition become origin 16 multiple
    ori_permute = []
    for stage_ in op_schedule_info.schedule_obj.stages:
        if "permute" in stage_.op.attrs:
            ori_permute = [int(i) for i in stage_.op.attrs["permute"]]
            break
    dim_len = len(ori_permute)
    is_last_trs = int(ori_permute[dim_len - 1]) != dim_len - 1
    # b16_factor
    if stage.op.tag == "transpose" and not last_has_cross \
            and is_last_trs and vector_block_num < 16:
        vector_block_num *= 16

    code_line = 'sch[%s].storage_align(sch[%s].op.axis[%s], %s, 0)' % \
                (stage_name, stage_name, align_axis_index, vector_block_num)
    if op_schedule_info.mode == MODE_RUNTIME:
        stage.storage_align(stage.op.axis[align_axis_index], vector_block_num,
                            0)

    cheque = get_storage_align_cheque(stage_index, align_axis_index, vector_block_num)
    op_schedule_info.cheque_list.append(cheque)
    return [code_line]


def do_trs_align(op_schedule_info: OpScheduleInfo, do_align_dict: dict, last_has_cross: bool) -> NoReturn:
    """
    do align for trs
    :param t2c_params:
    :param do_align_dict:
    :return:
    """
    # do_align
    op_schedule_info.code_lines.extend(['\n', '# storage_align code for trs'])
    code_lines = []
    for stage_index, axis_index in do_align_dict.items():
        stage_name = op_schedule_info.stages_info[stage_index]["name"]
        sub_code = align_a_trs_stage(stage_name, axis_index,
                                     op_schedule_info, stage_index, last_has_cross)
        code_lines.extend(sub_code)

    op_schedule_info.code_lines.extend(code_lines)


@apply_action_register([ComputePattern.TRANSPOSE], ScheduleActionType.STORAGE_ALIGN)
def apply_for_transpose(progress):
    """
    apply for transpose
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info

    align_stage_list = _get_align_stage_list(op_schedule_info)

    # only do align for input and output in UB
    if len(align_stage_list) != 2:
        logger.warn('align stages num should be equal to 2 for transpose.')

    # calc ori_permute and chosen_axes
    ori_permute = []
    for stage in op_schedule_info.schedule_obj.stages:
        if "permute" in stage.op.attrs:
            ori_permute = [int(i) for i in stage.op.attrs["permute"]]
            break

    # calc split axis
    low_ub_split_axis, high_ub_split_axis = \
        calc_trs_split_axis(op_schedule_info, op_schedule_info.stages_info[-1]["chosen_axes"])
    # calc reorder index
    reorder_in_index, reorder_out_index = calc_trs_reorder_action(op_schedule_info)
    # calc storage_align axis index
    align_axes = calc_storage_align(
        ori_permute, high_ub_split_axis, low_ub_split_axis,
        reorder_in_index, reorder_out_index)
    # calc last axis has cross or not
    last_has_cross = last_axis_has_cross(ori_permute, high_ub_split_axis, low_ub_split_axis)

    # do_storage_align
    do_align_dict = {}
    for index, (stage_index, _) in enumerate(align_stage_list):
        # -1 not do align, keep same with handle template
        if align_axes[index] == -1:
            continue
        do_align_dict[stage_index] = align_axes[index]

    do_trs_align(op_schedule_info, do_align_dict, last_has_cross)

    # record debug info
    op_schedule_info.code_lines.extend(['# chosen_axes: %s' % op_schedule_info.stages_info[-1]["chosen_axes"]])
    op_schedule_info.code_lines.extend(['# updated_axes: %s' % [low_ub_split_axis, high_ub_split_axis]])
    op_schedule_info.code_lines.extend(['# align_axes: %s' % align_axes])

    logger.debug("apply transpose storage_align done.")


def _get_align_stage_list(op_schedule_info):
    """
    :param op_schedule_info:
    :return:
    """
    align_stage_list = []
    for stage_index, stage in enumerate(op_schedule_info.schedule_obj.stages):
        if isinstance(stage.op, tvm.PlaceholderOp):
            continue

        if stage_index in op_schedule_info.inlined_stages:
            continue

        if '.local.UB' in stage.op.name:
            align_stage_list.append((stage_index, stage))
    return align_stage_list
