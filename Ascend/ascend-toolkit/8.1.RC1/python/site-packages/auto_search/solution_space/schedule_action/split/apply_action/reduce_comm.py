#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
reduce comm
"""
from typing import Tuple
import math

from auto_search.utils import logger
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.solution_space.t2c_util import SPLIT_INFO_KEYS
from auto_search.solution_space.t2c_util import SplitInfo
from auto_search.bank.cheque_generator import get_axis_index
from auto_search.bank.cheque_generator import get_axis_cheque
from auto_search.bank.cheque_generator import get_split_cheque


def find_split_axis(shape: list, begin_axis: int, end_axis: int, bound_size: int) -> Tuple[int, int]:
    """
    :param shape:
    :param begin_axis:
    :param end_axis:
    :param bound_size:
    :return:
    """
    axis_num = len(shape)
    if begin_axis >= axis_num \
            or begin_axis < 0 \
            or end_axis >= axis_num \
            or end_axis < 0:
        return 0, 1
    if begin_axis < end_axis:
        step = 1
    else:
        step = -1
    split_axis_index = end_axis
    temp_size = 1
    need_split = False
    for i in range(begin_axis, end_axis + step, step):
        temp_size = temp_size * shape[i]
        if temp_size >= bound_size:
            split_axis_index = i
            temp_size = temp_size / shape[i]
            need_split = True
            break

    if not need_split:
        return split_axis_index, shape[end_axis]

    # split the split axis
    split_size = 1
    for i in range(1, shape[split_axis_index] + 1, 1):
        if (temp_size * i) == bound_size:
            split_size = i
            break
        if (temp_size * i) > bound_size:
            split_size = i - 1
            break

    return split_axis_index, split_size


def gen_split_info(split_info=None, **kwargs):
    """
    gen split info
    :param split_info:
    :param kwargs:
    :return:
    """
    values = []
    for key in SPLIT_INFO_KEYS:
        value = kwargs.get(key)
        if value is None:
            value = getattr(split_info, key, None)
        values.append(value)

    return SplitInfo(*values)


def do_split(op_schedule_info, stage_index, cut_axis_in_reduce_axes, factor, code_lines) :
    """
    :param op_schedule_info:
    :param stage_index:
    :param cut_axis_in_reduce_axes:
    :param factor:
    :param code_lines:
    :return:
    """
    stage_name = op_schedule_info.stages_info[stage_index].get('name')
    stage = op_schedule_info.schedule_obj.stages[stage_index]

    a_stage_axis_info = []
    for axis_index, axis in enumerate(stage.op.axis):
        axis_name = f'{stage_name}_axis_{axis_index}'
        code_lines.append(f'{axis_name} = sch[{stage_name}].op.axis[{axis_index}]')
        a_stage_axis_info.append(AxisInfo(axis_name,
                                          stage.op.axis[axis_index].dom.extent.value,
                                          'axis', axis_index, 'all', axis))

    r_stage_axis_info = []
    for axis_index, axis in enumerate(stage.op.reduce_axis):
        if axis_index != cut_axis_in_reduce_axes:
            axis_name = f'{stage_name}_reduce_axis_{axis_index}'
            code_lines.append(f'{axis_name} = sch[{stage_name}].op.reduce_axis[{axis_index}]')
            r_stage_axis_info.append(AxisInfo(axis_name,
                                              stage.op.reduce_axis[axis_index].dom.extent.value,
                                              'reduce_axis', axis_index, 'all', axis))

    axis_name = f'{stage_name}_reduce_axis_{cut_axis_in_reduce_axes}'
    code_lines.append(f'{axis_name}_o, {axis_name}_i = '
                      f'sch[{stage_name}].split(sch[{stage_name}].op.reduce_axis[{cut_axis_in_reduce_axes}], '
                      f'factor={factor})')
    if factor != 0:
        axis = stage.op.reduce_axis[cut_axis_in_reduce_axes]
        axis_o_len = math.floor((axis.dom.extent.value + factor - 1) / factor)
        axis_obj_o, axis_obj_i = stage.split(axis, factor=factor)
    else:
        logger.error(f'Invalid factor: {factor}')
        raise RuntimeError(f'Invalid factor: {factor}')

    r_stage_axis_info.insert(cut_axis_in_reduce_axes,
                             AxisInfo(axis_name + '_o', axis_o_len,
                                      'reduce_axis', cut_axis_in_reduce_axes, 'o', axis_obj_o))
    r_stage_axis_info.insert(cut_axis_in_reduce_axes + 1,
                             AxisInfo(axis_name + "_i", factor,
                                      'reduce_axis', cut_axis_in_reduce_axes, 'i', axis_obj_i))

    stage_axis_info = a_stage_axis_info + r_stage_axis_info

    axis_cheque_list = get_axis_cheque(op_schedule_info.schedule_obj.stages[stage_index], stage_index)
    op_schedule_info.cheque_list.extend(axis_cheque_list)

    splited_axis_index = get_axis_index(stage_axis_info, axis_name + '_o')
    cheque = get_split_cheque(stage_index, splited_axis_index, factor)
    op_schedule_info.cheque_list.append(cheque)

    return stage_axis_info
