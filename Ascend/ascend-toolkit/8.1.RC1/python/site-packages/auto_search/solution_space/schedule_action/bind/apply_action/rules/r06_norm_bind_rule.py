#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
norm bind rule
"""
from typing import List
from typing import NoReturn
from typing import Optional

from tbe import tvm
from tbe.tvm import Stage

from auto_search.utils import logger
from auto_search.config import soc_cfg
from auto_search.solution_space.tensor_cfg import AxisInfo
from auto_search.bank.cheque_generator import get_split_cheque
from auto_search.bank.cheque_generator import get_bind_cheque
from auto_search.bank.cheque_generator import get_fuse_cheque
from auto_search.utils.dynamic_util import BlockSplitInfo
from auto_search.solution_space.t2c_util import MODE_RUNTIME
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.op_schedule_info import OpScheduleInfo
from auto_search.solution_space.schedule_action.bind.apply_action.rules.comm import fuse_axis
from auto_search.solution_space.schedule_action.bind.apply_action.rules.comm import get_block_factor_and_block_dim


def _set_block_split_info(op_schedule_info: OpScheduleInfo, cut_axis_index: Optional[int], block_dim: int,
                          core_num: int) -> NoReturn:
    """
    generate BlockSplitInfo for infer_range
    :param op_schedule_info:
    :param cut_axis_index:
    :param block_dim:
    :param core_num:
    :return:
    """
    block_factor_var_name = ''
    if op_schedule_info.is_need_block_tiling:
        # record split order, and factor name
        if op_schedule_info.tiling_record is None:
            op_schedule_info.tiling_record = {'block_split_num': 0, 'ub_split_num': 0, 'split_var_name_list': []}
        block_split_num = op_schedule_info.tiling_record.get("block_split_num", None)
        if block_split_num is None:
            raise RuntimeError("block_split_num is None, please check!")
        block_factor_var_name = '_block_factor_' + str(block_split_num)
        op_schedule_info.tiling_record['split_var_name_list'].append(block_factor_var_name)
        op_schedule_info.tiling_record['block_split_num'] = block_split_num + 1

    stage_index = -1
    for stage_idx, stage_info in enumerate(op_schedule_info.stages_info):
        if 'leaf' in stage_info.get('type', []):
            stage_index = stage_idx
            break

    if isinstance(cut_axis_index, int):
        # get block axis origin index
        bind_axes = []
        stage_axis_info = op_schedule_info.axis_info_list[stage_index]
        split_axis_index = stage_axis_info[cut_axis_index].index
        for i in range(0, cut_axis_index + 1):
            bind_axes.append(stage_axis_info[i].index)
    else:
        split_axis_index = cut_axis_index
        bind_axes = None

    block_split_info = BlockSplitInfo(split_axis_index, bind_axes, block_factor_var_name, core_num, block_dim)
    op_schedule_info.block_split_info = block_split_info


def _norm_block_tiling(stage_index: int,
                       stage_axis_info: List,
                       op_schedule_info: OpScheduleInfo,
                       stage: Stage,
                       ) -> int:
    """
    block tiling use factor mode
    :param stage_index:
    :param stage_axis_info:
    :param op_schedule_info:
    :param stage:
    :return:
    """
    op_schedule_info.is_need_block_tiling = False
    block_dim = 1
    for idx in op_schedule_info.reduce_axis_dict:
        reduce_axis = op_schedule_info.reduce_axis_dict[idx].get('axis')
        break
    bind_axis_num = _get_bind_axis_num(op_schedule_info, reduce_axis, stage_axis_info, stage_index)

    if bind_axis_num == 0:
        op_schedule_info.code_lines.append(f'# block_dim={block_dim}')
        _set_block_split_info(op_schedule_info, None, block_dim, soc_cfg.get_core_num())
        return 1

    bind_stage_name = stage.op.name
    # fuse
    fuse_axis_name = '%s_axis_fused_o' % bind_stage_name
    fused_axes_obj_list = []
    fused_axes_name = []
    index_list = []
    axis_index = []
    fuse_len = 1
    axis_info_list = op_schedule_info.axis_info_list[stage_index]

    for i in range(bind_axis_num):
        fused_axes_obj_list.append(axis_info_list[i].body)
        fused_axes_name.append(axis_info_list[i].name)
        index_list.append(axis_info_list[i].index)
        axis_index.append(i)
        fuse_len *= axis_info_list[i].len

    code_line = f"{fuse_axis_name} = sch[{bind_stage_name}].fuse({', '.join(fused_axes_name)})"
    op_schedule_info.code_lines.append(code_line)
    fused_axis_obj = None
    if op_schedule_info.mode == MODE_RUNTIME:
        fused_axis_obj = stage.fuse(*fused_axes_obj_list)

    del axis_info_list[axis_index[0]: axis_index[-1] + 1]
    axis_info_list.insert(axis_index[0],
                          AxisInfo(fuse_axis_name, fuse_len,
                                   'fused_axis', index_list[0], 'o', fused_axis_obj))

    op_schedule_info.axis_info_list[stage_index] = axis_info_list

    fuse_cheque = get_fuse_cheque(stage_index, axis_index)
    op_schedule_info.cheque_list.append(fuse_cheque)

    block_dim, block_factor = get_block_factor_and_block_dim(soc_cfg.get_core_num(), fuse_len, 0, stage_axis_info)

    op_schedule_info.code_lines.append(f'# block_dim={block_dim}')
    op_schedule_info.code_lines.append('{}_oo, {}_o = sch[{}].split({}, factor={})'.format(
        fuse_axis_name, fuse_axis_name, stage.op.name, fuse_axis_name, block_factor))
    axis_obj_o, axis_obj_i = stage.split(fused_axis_obj,  factor=block_factor)

    del axis_info_list[0]
    axis_info_list.insert(0, AxisInfo(f"{fuse_axis_name}_o", block_factor, 'axis', index_list[0], 'o', axis_obj_i))
    axis_info_list.insert(0, AxisInfo(f"{fuse_axis_name}_oo", block_dim, 'axis', index_list[0], 'oo', axis_obj_o))

    cheque = get_split_cheque(stage_index, 0, block_factor, "split")
    op_schedule_info.cheque_list.append(cheque)

    return block_dim


def _get_bind_axis_num(op_schedule_info: OpScheduleInfo, reduce_axis: List, stage_axis_info : List, stage_index: int):
    """
    :param op_schedule_info:
    :param reduce_axis:
    :param stage_axis_info:
    :param stage_index:
    :return:
    """
    bind_axis_num = 0
    for axis in stage_axis_info:
        if axis.index not in reduce_axis:
            bind_axis_num += 1
            if axis.index == op_schedule_info.cut_axis_index[stage_index]:
                break
        else:
            break
    return bind_axis_num


def proc(progress: Progress) -> bool:
    """
    :param progress:
    :return:
    """
    op_schedule_info = progress.op_schedule_info

    # only one stage can be bind
    stage, stage_index = op_schedule_info.bind_stages[0]
    stage_name = stage.op.name

    # if stage have been processed, skip
    if op_schedule_info.proc_flag_dict.get(stage_index, False):
        logger.debug('Stage processed.')
        return True

    stage_axis_info = op_schedule_info.axis_info_list[stage_index]
    block_dim = _norm_block_tiling(stage_index, stage_axis_info, op_schedule_info, stage)
    op_schedule_info.block_dim = block_dim
    if block_dim == 1:
        logger.debug('block_dim: %s', block_dim)
        return True
    bind_axis_info = stage_axis_info[0]

    # bind
    op_schedule_info.code_lines.append("block = tvm.thread_axis('blockIdx.x')")
    code_line = "sch[{}].bind({}, block)".format(stage_name, bind_axis_info.name)
    op_schedule_info.proc_flag_dict[stage_index] = True
    op_schedule_info.code_lines.append(code_line)

    block = tvm.thread_axis('blockIdx.x')
    stage.bind(bind_axis_info.body, block)

    cheque = get_bind_cheque(stage_index)
    op_schedule_info.cheque_list.append(cheque)

    return True
