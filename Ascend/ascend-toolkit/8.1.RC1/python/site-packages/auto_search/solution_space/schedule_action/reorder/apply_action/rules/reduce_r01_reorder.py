#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
auto search
"""
from typing import NoReturn

from auto_search.utils import logger
from auto_search.solution_space import t2c_util
from auto_search.solution_space.progress import Progress
from auto_search.solution_space.tensor_cfg import ActionTensorCfg


def proc(progress: Progress) -> NoReturn:
    """
    rule: for reduce operator, reorder according to following
    1) reduce_last, all normal axis before reduce axis
    2) nlast, all normal axis except the last axis before reduce axis
    :param progress:
    :return:
    """
    # atomic has dedicated rule
    op_schedule_info = progress.op_schedule_info
    if op_schedule_info.is_atomic:
        return

    # if do rfactor, has dedicated rule
    ub_split_last_reduce_axis = op_schedule_info.last_reduce_and_ub_split_last_reduce_axis
    ub_split_nlast_reduce_axis = op_schedule_info.last_reduce_and_ub_split_nlast_reduce_axis
    if ub_split_last_reduce_axis or ub_split_nlast_reduce_axis:
        return
    leveled_axis_list = []
    op_schedule_info.leveled_axis_for_reorder = leveled_axis_list
    for stage_idx, stage_axis_list in enumerate(op_schedule_info.axis_info_list):
        leveled_axis = [[], [], [], [], [], [], []]
        leveled_axis_list.append(leveled_axis)
        # skip the stage without need to reorder
        if stage_axis_list is None:
            continue

        a_axis_info, r_axis_info = _axis_info_categorization(stage_axis_list)

        a_axis_info, r_axis_info = _update_reduce_order(progress, stage_idx, a_axis_info, r_axis_info)

        leveled_axis[t2c_util.AXIS_LEVEL_O_INDEX] = a_axis_info
        leveled_axis[t2c_util.AXIS_LEVEL_I_II_NORMAL_INDEX] = r_axis_info

    logger.debug('leveled_axis_for_reorder: %s', op_schedule_info.leveled_axis_for_reorder)
    return


def _update_reduce_order(progress, stage_index, a_axis_info, r_axis_info):
    """
    reorder to ara or ar
    :param a_axis_info:
    :param ordered_axis_obj:
    :param r_axis_info:
    :return:
    """
    ordered_axis_obj = progress.op_schedule_info.stages_info[stage_index].get('stage_ordered_axes_obj')
    if ordered_axis_obj is None:
        logger.error("reduce stage info must have stage_ordered_axes_obj!")
        return a_axis_info, r_axis_info
    if not ordered_axis_obj.is_reduce_stage():
        return a_axis_info, r_axis_info

    split_vector = progress.action_tensor[stage_index][
                   ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    if sum(split_vector) == 0:
        raise RuntimeError("reduce stage need be cut!")
    # find ub split axis
    ub_cut_axis = _find_cut_axis(split_vector)
    ub_split_last_a_axis = ub_cut_axis == len(ordered_axis_obj.get_origin_axis_dim()) - 1

    if not ordered_axis_obj.is_reduce_last():
        if not ub_split_last_a_axis:
            r_axis_info = r_axis_info + a_axis_info[-1:]
            a_axis_info = a_axis_info[:-1]
        else:
            # if a0 r a1, ub split a1 --> a0 r a1o a1i---> reorder to :a0 r a1o a1i
            r_axis_info = r_axis_info + a_axis_info[-2:]
            a_axis_info = a_axis_info[:-2]

    return a_axis_info, r_axis_info


def _find_cut_axis(split_vector):
    """
    :param split_vector:
    :return:
    """
    ub_cut_axis = 0
    for i, f in enumerate(split_vector):
        if f > 0:
            ub_cut_axis = i
            break
    return ub_cut_axis


def _axis_info_categorization(stage_axis_list):
    """
    :param stage_axis_list:
    :return:
    """
    a_axis_info, r_axis_info = [], []

    for axis_info in stage_axis_list:
        if 'reduce_axis' in axis_info.name:
            r_axis_info.append(axis_info)
        else:
            a_axis_info.append(axis_info)
    return a_axis_info, r_axis_info
