#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
"""
rl schedule search, tss
"""
import numpy as np

from auto_search.solution_space import tensor_cfg


def _get_deps_flags(deps_vector):
    """
    :param deps_vector:
    :return:
    """
    # deps_vector has eight number, each number are eight bits. each bit correspond to one stage
    # eg. for Stage25，it depend on Stage24 and Stage23，Stage26 depned on it，
    # then the value of deps_vector is ：[0，0，0，0，0，0，0，0，0，0，0，0，5，128，0，0]
    # bit23，bit24，bit26 are set one，other bit are clear 0
    # The order is rigth to left.
    deps_flags = []
    # traversal each deps_u8 in reverse order
    for deps_u8 in reversed(deps_vector):
        # deps_u8's range from 0 to 255
        if not 0 <= deps_u8 < 256:
            raise AssertionError()
        # save flag to deps_flags
        for i in range(8):
            u8_bit_i = (deps_u8 >> i) % 2
            deps_flags.append(u8_bit_i)
    return deps_flags


def _get_fanin_stage_indices(stage_index, features):
    """
    :param stage_index:
    :param features:
    :return:
    """
    # get nearest dependency
    deps_vector = np.uint32(
        features[stage_index][tensor_cfg.FeatureTensorCfg.
                              deps_s:tensor_cfg.FeatureTensorCfg.deps_e + 1])
    deps_flags = _get_deps_flags(deps_vector)
    return [i for i, dep_flag in enumerate(deps_flags[:stage_index]) if dep_flag == 1]


def _get_fanout_stage_indices(stage_index, features):
    """

    :param stage_index:
    :param features:
    :return:
    """
    deps_vector = np.uint32(
        features[stage_index][tensor_cfg.FeatureTensorCfg.
                              deps_s:tensor_cfg.FeatureTensorCfg.deps_e + 1])
    deps_flags = _get_deps_flags(deps_vector)
    return [i for i, dep_flag in enumerate(deps_flags) if dep_flag == 1 and i > stage_index]


def get_fanin_sub_tree_indices(features):
    """
    get input sub_tree
    :param features:
    :return:
    """
    # get all deps, include direct and indirect dependence
    subtree_indices = {}
    deps_s = tensor_cfg.FeatureTensorCfg.deps_s
    deps_e = tensor_cfg.FeatureTensorCfg.deps_e + 1
    for stage_index, feature_vec in enumerate(features):
        subtree_indices[stage_index] = []
        deps_vector = np.uint32(feature_vec[deps_s:deps_e])
        deps_flags = _get_deps_flags(deps_vector)
        direct_deps = [i for i, dep_flag in enumerate(deps_flags[:stage_index]) if dep_flag == 1]
        subtree_indices.get(stage_index).extend(direct_deps)
        for direct_dep in direct_deps:
            subtree_indices.get(stage_index).extend(subtree_indices.get(direct_dep))
    return subtree_indices


def get_fanout_sub_tree_indices(features):
    """
    get ouput sub_tree
    :param features:
    :return:
    """
    # get all deps, include direct and indirect dependence
    subtree_indices = {}
    deps_s = tensor_cfg.FeatureTensorCfg.deps_s
    deps_e = tensor_cfg.FeatureTensorCfg.deps_e + 1
    stage_num = len(features)
    for stage_index in range(stage_num - 1, -1, -1):
        feature_vec = features[stage_index]
        subtree_indices[stage_index] = []
        deps_vector = np.uint32(feature_vec[deps_s:deps_e])
        deps_flags = _get_deps_flags(deps_vector)
        direct_deps = [i for i, dep_flag in enumerate(deps_flags[stage_index + 1:], stage_index + 1) if dep_flag == 1]
        subtree_indices.get(stage_index).extend(direct_deps)
        for direct_dep in direct_deps:
            subtree_indices.get(stage_index).extend(subtree_indices.get(direct_dep))
    return subtree_indices


def get_real_fanin_fanout_stages(stage_index,
                                 features,
                                 inlined_stages,
                                 direction='fanin'):
    """
    get direct dependence for stage. If it is inline, then get next
    """
    if direction == 'fanin':
        func = _get_fanin_stage_indices
    else:
        func = _get_fanout_stage_indices
    fan_stages = func(stage_index, features)
    tmp_child_stages = fan_stages.copy()
    read_child_stages = []
    while True:
        cur_child_stages = []
        for child_stage in tmp_child_stages:
            if child_stage not in inlined_stages:
                # the target of child stage is the same with the target of stage at，then it is dependent stage
                read_child_stages.append(child_stage)
            else:
                # the target between child stage and stage at are differnt，
                # and child stage is not target of current stage at，go on
                cur_child_stages.extend(func(child_stage, features))

        if not cur_child_stages:
            break
        tmp_child_stages = cur_child_stages

    return fan_stages, read_child_stages
