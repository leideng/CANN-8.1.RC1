#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
Compute Manager for fusion
"""
# 'pylint: disable=too-many-lines
import hashlib
import importlib
import itertools
import inspect
import json
import sys
import os
import glob
import stat
import warnings
import copy

# 'pylint: disable=useless-object-inheritance, too-many-instance-attributes, too-many-public-methods

_PARALLEL_SCH_OP = ("MatMul", "MatMulV2", "BatchMatMul", "BatchMatMulV2")
_PARALLEL_SCH_PROCESS = 8


class FusionManager(object):
    """Manage computes which are registered
    Save and call compute function by their registered key
    """
    def __init__(self):
        """init"""
        self._build_cfg = "enable"
        self._current_op_pattern = "Opaque"
        self._pass_opt_list = "invalid"
        self._current_op_name = ""
        self._current_op_func_name = ""
        self._op_build_type = {}
        self.tik_build_config = {}
        self._op_args = {}
        self.fusion_build_config = {}
        self._op_kwds = {}

    def clear(self):
        """clear"""
        self.__init__()

    def register(self, register_name):
        """Register compute

        Parameters
        ----------
        register_name : string
            register_name to call compute.

        Returns
        -------
        """
        warnings.warn("te_fusion.fusion_manager.fusion_manager.register is deprecated,"
                      "please replace it with tbe.common.register.register_op_compute",
                      DeprecationWarning, stacklevel=2)
        import tbe.common.register
        return tbe.common.register.register_op_compute(register_name, op_mode="static", support_fusion=True)

    def get_op_compute_func(self, register_name):
        """get op compute function
        Parameters
        ----------
        register_name : string
            compute_name to call compute.
        Returns
        -------
            op compute function
        """
        warnings.warn("te_fusion.fusion_manager.fusion_manager.get_op_compute_func is deprecated,"
                      "please replace it with tbe.common.register.get_op_compute",
                      DeprecationWarning, stacklevel=2)
        import tbe.common.register
        op_compute = tbe.common.register.get_op_compute(register_name, op_mode="static")
        if op_compute is not None:
            return op_compute.get_func()
        return None

    def get_op_compute(self, register_name, *args, **kwds):
        """Get op compute

        Parameters
        ----------
        register_name : string
            register_name to call func.
        *args, **kwds
            op_params.

        Returns
        -------
        op_compute : compute
            compute corresponding to the compute_name.
        """
        return self._op_compute[register_name](*args, **kwds)

    def set_current_op_name(self, op_name):
        """Set current op_name

        Parameters
        ----------
        op_name : string
            update current op_name to save op_params.
        """
        self._current_op_name = op_name


    def set_op_params(self, *args, **kwds):
        """Set current op_name's op_params

        Parameters
        ----------
        *args, **kwds
            save current op_name's op_params.
        """
        self._op_args[self._current_op_name] = args
        self._op_kwds[self._current_op_name] = kwds


    def set_op_build_type(self, args_type):
        """Get current op_name's build type, it is singlebuild or prebuild

        Parameters
        ----------
        args_type : string
            singlebuild or prebuild
        """
        self._op_build_type[self._current_op_name] = args_type

    def get_op_build_type(self, register_name):
        """Get current op_name's build type

        Parameters
        ----------
        register_name : string
            key to get build type

        Returns
        -------
        args
            current op_name's build type.
        """
        if register_name in self._op_build_type:
            return self._op_build_type[register_name]
        return ""

    def set_op_res(self, res):
        """Get current op_name's build type, it is singlebuild or prebuild

        Parameters
        ----------
        args_type : string
            singlebuild or prebuild
        """
        import tbe.common.rl_bank.bank_manager as bank_manager
        bank_manager.set_op_res(res)
        warnings.warn("fusion_manager.set_op_res is expired, please replace it with bank_manager.set_op_res",
                      DeprecationWarning, stacklevel=2)

    def set_tensor_list(self, tensor_list):
        """save tensor_list

        Parameters
        ----------
        args_type : list
            tensor_list
        """
        import tbe.common.rl_bank.bank_manager as bank_manager
        bank_manager.set_tensor_list(tensor_list)
        warnings.warn("fusion_manager.set_tensor_list is expired, please replace it with bank_manager.set_tensor_list",
                      DeprecationWarning, stacklevel=2)

    def set_tik_tensor(self, input_tensor, output):
        """Save tik op input&output tensor

        Parameters
        ----------
        input_tensor : tik input tensor
        output : tik output tensor
        """
        import tbe.common.rl_bank.bank_manager as bank_manager
        bank_manager.set_tik_tensor(input_tensor, output)
        warnings.warn("fusion_manager.set_tik_tensor is expired, please replace it with bank_manager.set_tik_tensor",
                      DeprecationWarning, stacklevel=2)

    def set_cheque_list(self, cheque_list):
        """Save RL cheque_list

        Parameters
        ----------
        cheque_list : RL cheque_list
        """
        import tbe.common.rl_bank.bank_manager as bank_manager
        bank_manager.set_cheque_list(cheque_list)
        warnings.warn("fusion_manager.set_cheque_list is expired, please replace it with bank_manager.set_cheque_list",
                      DeprecationWarning, stacklevel=2)

    def clear_res_index(self):
        """clear RL res_index

        Parameters
        ----------
        """
        import tbe.common.rl_bank.bank_manager as bank_manager
        bank_manager.clear_res_index()
        warnings.warn("fusion_manager.clear_res_index is expired, please replace it with bank_manager.clear_res_index",
                      DeprecationWarning, stacklevel=2)

    def clear_cheque_list(self):
        """clear RL cheque_list

        Parameters
        ----------
        """
        import tbe.common.rl_bank.bank_manager as bank_manager
        bank_manager.clear_cheque_list()
        warnings.warn("fusion_manager.clear_cheque_list is expired,"
                      "please replace it with bank_manager.clear_cheque_list",
                      DeprecationWarning, stacklevel=2)

    def get_op_res(self, key):
        """Get current op_name's build type

        Parameters
        ----------
        register_name : string
            key to get build type

        Returns
        -------
        args
            current op_name's build type.
        """
        warnings.warn("fusion_manager.get_op_res is expired, please replace it with bank_manager.get_op_res",
                      DeprecationWarning, stacklevel=2)
        import tbe.common.rl_bank.bank_manager as bank_manager
        return bank_manager.get_op_res(key)

    def get_tik_tensor(self, key):
        """Get tik op input&output tensor

        Parameters
        ----------

        Returns
        -------
        args
            none
        """
        warnings.warn("fusion_manager.get_tik_tensor is expired, please replace it with bank_manager.get_tik_tensor",
                      DeprecationWarning, stacklevel=2)
        import tbe.common.rl_bank.bank_manager as bank_manager
        return bank_manager.get_tik_tensor(key)

    def get_cheque_list(self, res_index=None):
        """Get RL cheque_list

        Parameters
        ----------
        res_index:
        Returns
        -------
        args
            none
        """
        warnings.warn("fusion_manager.get_cheque_list is expired, please replace it with bank_manager.get_cheque_list",
                      DeprecationWarning, stacklevel=2)
        import tbe.common.rl_bank.bank_manager as bank_manager
        return bank_manager.get_cheque_list(res_index)

    def get_res_index(self):
        """Get RL res_index

        Parameters
        ----------
        Returns
        -------
        args
            none
        """
        warnings.warn("fusion_manager.get_res_index is expired, please replace it with bank_manager.get_res_index",
                      DeprecationWarning, stacklevel=2)
        import tbe.common.rl_bank.bank_manager as bank_manager
        return bank_manager.get_res_index()


    def get_op_args(self, op_name):
        """Get current op_name's op_args

        Parameters
        ----------
        op_name : string
            key to get op_args

        Returns
        -------
        args
            save current op_name's op_args.
        """
        return self._op_args[op_name]

    def init_current_op_pattern(self):
        """Init current op's pattern"""

        self._current_op_pattern = "Opaque"

    def set_current_op_pattern(self, op_pattern):
        """Set current op's pattern

        Parameters
        ----------
        op_pattern : string
            current single op's pattern.
        """
        self._current_op_pattern = op_pattern

    def get_current_op_pattern(self):
        """Get current single op's pattern

        Returns
        ----------
        op_pattern : string
            current single op's pattern.
        """
        return self._current_op_pattern

    def set_current_op_func_name(self, op_func_name):
        """Set current op's func name

        Parameters
        ----------
        op_func_name : string
            current single op's func name.
        """
        self._current_op_func_name = op_func_name

    def get_current_op_func_name(self):
        """Get current single op's func name

        Returns
        ----------
        op_func_name : string
            current single op's func name.
        """
        return self._current_op_func_name

    def get_fuse_info(self):
        """Check whether this op will be fused

        Returns
        ----------
        True : bool
            this op will be fused
        False : bool
            this op will not be fused
        """
        if self._current_op_name \
                and self._current_op_func_name:
            return True
        return False

    def set_lic_pass_opt_list(self, op_type, pass_opt_list):
        """
        :param op_type:
        :param pass_opt_list:
        :return:
        """
        import tbe.common.utils.log as logger
        if pass_opt_list == "invalid":
            logger.debug("set_lic_pass_opt_list, pass_opt_list is invalid, op_type:%s", op_type)
            return

        import tbe.common.register
        db_value = tbe.common.register.get_fusion_buildcfg(op_type)
        if db_value == pass_opt_list:
            logger.debug("set_lic_pass_opt_list, newer is same with old:%s, op_type:%s", pass_opt_list, op_type)
            return
        logger.info("set_lic_pass_opt_list key:%s, val:%s", op_type, pass_opt_list)
        tbe.common.register.set_fusion_buildcfg(op_type, {"lic_params":pass_opt_list})
        self._pass_opt_list = pass_opt_list

    def set_build_cfg(self, op_build_cfg):
        """Set current op's build switch

        Parameters
        ----------
        op_pattern : string
            current single op's switch.
        """
        from tbe.common.buildcfg import set_current_build_config
        if op_build_cfg == "enable":
            set_current_build_config("enable_op_prebuild", False)
        else:
            set_current_build_config("enable_op_prebuild", True)

    def get_build_cfg(self):
        """Get current single op's switch

        Returns
        ----------
        op_pattern : string
            current single op's switch.
        """
        warnings.warn("te_fusion.fusion_manager.get_build_cfg is deprecated,"
                      "please replace it with tbe.common.buildcfg.get_current_build_config",
                      DeprecationWarning, stacklevel=2)
        from tbe.common.buildcfg import get_current_build_config
        enable_op_prebuild = get_current_build_config("enable_op_prebuild")
        if enable_op_prebuild:
            return "disable"
        else:
            return "enable"


# 'pylint: disable=invalid-name
# Singleton for managing all registered compute
fusion_manager = FusionManager()


def set_current_op_name(op_name):
    """Set current op_name, external interface for C call python

    Parameters
    ----------
    op_name : string
        update current op_name to save op_params.

    Returns
    -------
    succ_flag : boolean
        end of execution
    """
    fusion_manager.set_current_op_name(op_name)


def set_current_op_func_name(op_func_name):
    """Set current op's func name, external interface for C call python

    Parameters
    ----------
    op_func_name : string
        current single op's func name.

    Returns
    -------
    succ_flag : boolean
        end of execution
    """
    fusion_manager.set_current_op_func_name(op_func_name)


def set_op_params(*args, **kwds):
    """Set current name's op_params, external interface for C call python

    Parameters
    ----------
    *args, **kwds
        save current op_name's op_params.

    Returns
    -------
    succ_flag : boolean
        end of execution
    """
    fusion_manager.set_op_params(*args, **kwds)


def set_op_build_type(args_type):
    """Get current op_name's build type

    Parameters
    ----------
    args_type : string
        build type need to be set
    """
    fusion_manager.set_op_build_type(args_type)


def get_op_build_type(register_name):
    """Get current op_name's op_args

    Parameters
    ----------
    register_name : string
        key to get build type

    Returns
    -------
    args
        return current op_name's build type.
    """
    return fusion_manager.get_op_build_type(register_name)


def set_op_res(res_val):
    """Get current op_name's build type

    Parameters
    ----------
    args_type : string
        build type need to be set
    """
    import tbe.common.rl_bank.bank_manager as bank_manager
    bank_manager.set_op_res(res_val)
    warnings.warn("fusion_manager.set_op_res is expired, please replace it with bank_manager.set_op_res",
                  DeprecationWarning, stacklevel=2)


def set_tensor_list(tensor_list):
    """save tensor_list

    Parameters
    ----------
    args_type : list
        tensor_list need to save
    """
    import tbe.common.rl_bank.bank_manager as bank_manager
    bank_manager.set_tensor_list(tensor_list)
    warnings.warn("fusion_manager.set_tensor_list is expired, please replace it with bank_manager.set_tensor_list",
                  DeprecationWarning, stacklevel=2)


def set_tik_tensor(input_tensor, output):
    """save tik_tensor

    Parameters
    ----------
    input_tensor : tik input tensor
    output : tik output tensor
    """
    import tbe.common.rl_bank.bank_manager as bank_manager
    bank_manager.set_tik_tensor(input_tensor, output)
    warnings.warn("fusion_manager.set_tik_tensor is expired, please replace it with bank_manager.set_tik_tensor",
                  DeprecationWarning, stacklevel=2)


def set_cheque_list(cheque_list):
    """Save RL cheque_list

    Parameters
    ----------
    cheque_list : RL cheque_list
    """
    import tbe.common.rl_bank.bank_manager as bank_manager
    bank_manager.set_cheque_list(cheque_list)
    warnings.warn("fusion_manager.set_cheque_list is expired, please replace it with bank_manager.set_cheque_list",
                  DeprecationWarning, stacklevel=2)


def clear_cheque_list():
    """clear RL cheque_list

    Parameters
    ----------
    """
    import tbe.common.rl_bank.bank_manager as bank_manager
    bank_manager.clear_cheque_list()
    warnings.warn("fusion_manager.clear_cheque_list is expired, please replace it with bank_manager.clear_cheque_list",
                  DeprecationWarning, stacklevel=2)


def clear_res_index():
    """clear RL res_index

    Parameters
    ----------
    """
    import tbe.common.rl_bank.bank_manager as bank_manager
    bank_manager.clear_res_index()
    warnings.warn("fusion_manager.clear_res_index is expired, please replace it with bank_manager.clear_res_index",
                  DeprecationWarning, stacklevel=2)


def get_op_res(key):
    """Get current op_name's op_args

    Parameters
    ----------
    register_name : string
        key to get build type

    Returns
    -------
    args
        return current op_name's build type.
    """
    import tbe.common.rl_bank.bank_manager as bank_manager
    warnings.warn("fusion_manager.get_op_res is expired, please replace it with bank_manager.get_op_res",
                  DeprecationWarning, stacklevel=2)
    return bank_manager.get_op_res(key)


def get_tik_tensor(key):
    """Get tik op input&output tensor

    Parameters
    ----------

    Returns
    -------
    args
        none
    """
    import tbe.common.rl_bank.bank_manager as bank_manager
    warnings.warn("fusion_manager.get_tik_tensor is expired, please replace it with bank_manager.get_tik_tensor",
                  DeprecationWarning, stacklevel=2)
    return bank_manager.get_tik_tensor(key)


def get_cheque_list(res_index=None):
    """Get RL cheque_list

    Parameters
    ----------
    res_index:
    Returns
    -------
    args
        none
    """
    import tbe.common.rl_bank.bank_manager as bank_manager
    warnings.warn("fusion_manager.get_cheque_list is expired, please replace it with bank_manager.get_cheque_list",
                  DeprecationWarning, stacklevel=2)
    return bank_manager.get_cheque_list(res_index)


def get_res_index():
    """Get RL res_index

    Parameters
    ----------
    Returns
    -------
    args
        none
    """
    import tbe.common.rl_bank.bank_manager as bank_manager
    warnings.warn("fusion_manager.get_res_index is expired, please replace it with bank_manager.get_res_index",
                  DeprecationWarning, stacklevel=2)
    return bank_manager.get_res_index()


def op_build_cfg_en():
    """Set current name's op_params, enable  build .o

    Parameters
    ----------

    Returns
    -------
    succ_flag : boolean
        end of execution
    """
    fusion_manager.set_build_cfg("enable")


def op_build_cfg_dis():
    """Set current name's op_params, disable build .o

    Parameters
    ----------

    Returns
    -------
    succ_flag : boolean
        end of execution
    """
    fusion_manager.set_build_cfg("disable")

def set_lic_pass_opt_list(optype, pass_opt_list):
    return fusion_manager.set_lic_pass_opt_list(optype, pass_opt_list)

def get_build_cfg():
    """Get current name's op_params, build .o or not

    Parameters
    ----------

    Returns
    -------
    succ_flag : boolean
        end of execution
    """
    return fusion_manager.get_build_cfg()


def init_op_pattern():
    """init current name's pattern

    Parameters
    ----------

    Returns
    -------
    op pattern value
        end of execution
    """
    fusion_manager.init_current_op_pattern()


def get_op_pattern():
    """Get current name's pattern

    Parameters
    ----------

    Returns
    -------
    op pattern value
        end of execution
    """
    return fusion_manager.get_current_op_pattern()


def get_func_of_op(op_module, op_func_name, soft_sync_op):
    """
    Get function from op module

    Parameters
    ----------
    op_module:op module
    op_func_name:function name

    Returns
    -------
    op function
        end of execution
    """
    import tbe.common.utils.log as logger
    op_func = None
    opm = None
    try:
        opm = importlib.import_module(op_module)
    except ImportError as exce:
        logger.warn("Unable to import %s, reason:%s.", op_module, exce)

    if hasattr(opm, op_func_name):
        op_func = getattr(opm, op_func_name)
    elif "dynamic" in op_module and soft_sync_op != "True":
        pos = op_module.find("dynamic")
        new_op_module = op_module[0:pos] + op_module[pos+8:]
        logger.info("Try to get function[%s] from static impl of op module[%s].", op_func_name, new_op_module)
        try:
            new_opm = importlib.import_module(new_op_module)
        except ImportError as exce:
            logger.warn("Unable to import %s, reason:%s.", op_module, exce)
        if hasattr(new_opm, op_func_name):
            op_func = getattr(new_opm, op_func_name)

    return op_func


def call_op_func(op_args, op_module, op_func_name, op_type=None, op_impl_mode=None,
                 soft_sync_op=None, context_param=None):
    """
    invoke function of op

    Parameters
    ----------
    op_args : list
    inputs, outputs, attrs
    op_module: string
    module name
    op_func_name: string
    function name which will be call

    Returns
    -------
    depend on op_func_name
    """
    op_func = get_func_of_op(op_module, op_func_name, soft_sync_op)
    if op_func is None:
        import tbe.common.utils.log as logger
        logger.warn("Op module[{}] does not have function[{}].".format(op_module, op_func_name))
        return None

    inputs, outputs, attrs = op_args

    import tbe.common.context.op_context as op_context
    import tbe.common.context.op_info as operator_info
    with op_context.OpContext():
        context = op_context.get_context()
        op_impl_mode_dict = {}
        new_attrs = attrs
        if op_type is not None:
            op_info = operator_info.OpInfo(op_func_name, op_type)
            if op_impl_mode is not None and len(op_impl_mode) > 0:
                op_info.precision_mode = op_impl_mode
            context_attrs = list(attrs)
            op_info, new_attrs, context_attrs = attrs_is_dict(op_info, attrs)
            op_info.attrs = context_attrs
            op_info.inputs = inputs
            op_info.outputs = outputs
            context.add_op_info(op_info)
            context.set_graph_op_info(op_info)
            op_impl_mode_dict[op_type] = op_impl_mode

        context.add_addition("op_impl_mode_dict", op_impl_mode_dict)
        if context_param is not None:
            context.add_addition("jit_compiler", context_param.get("jit_compiler", None))
            context.add_addition("virtual_type", context_param.get("virtual_type", None))
        return op_func(*inputs, *outputs, *new_attrs)


def generate_op_unique_keys(op_args, op_type, op_impl_mode, json_str):
    """
    generate op unique key by invoke api of template

    Parameters
    ----------
    op_type : string
    op_args : inputs, outputs, attrs
        inputs, outputs : list
        attrs : list<dict>
    Returns
    -------
    op unique key : string
    """
    inputs, outputs, attrs = op_args
    attrs = json.loads(json.dumps(attrs))
    import te_fusion.fusion_util as fusion_util
    json_data = json.loads(json_str)
    single_op = json_data["op_list"][0]
    extra_params = {}
    if op_impl_mode is not None and len(op_impl_mode) > 0:
        extra_params["impl_mode"] = op_impl_mode
    extra_params_str = single_op["extra_params"] if "extra_params" in single_op else None
    extra_params.update(fusion_util.get_extra_params(extra_params_str))
    for input_desc in single_op["input_desc"]:
        if "is_first_layer" in input_desc:
            del input_desc["is_first_layer"]
    for output_desc in single_op["output_desc"]:
        if "data_type" in output_desc:
            output_desc["dtype"] = output_desc.pop("data_type")
        if "sgt_slice_shape" in output_desc:
            del output_desc["sgt_slice_shape"]
        if "output_index" in output_desc:
            del output_desc["output_index"]

    from tbe.common.utils import get_op_compile_unique_key
    import tbe.common.utils.log as logger
    try:
        op_info_dict = get_op_compile_unique_key(op_type, single_op["input_desc"], single_op["output_desc"],
                                                attrs, extra_params, False)
        if not isinstance(op_info_dict, (str, list)):
            logger.error("[%s] get_op_compile_unique_key return type not in str or list.", op_type)
            return []
        if isinstance(op_info_dict, str):
            op_info_list = []
            op_info_list.append(op_info_dict)
            return op_info_list
        else:
            return op_info_dict
    except Exception as e:
        logger.error("[%s] get_op_compile_unique_key failed. Exception:(%s)", op_type, str(e))
        return []
    finally:
        pass


def range_padding(inputs, outputs):
    """
    pad range paramters if range and shape not match
    """
    inouts = []
    for ele in itertools.chain(inputs, outputs):
        if isinstance(ele, (list, tuple)):
            inouts.extend(ele)
        else:
            inouts.append(ele)

    import te_fusion.fusion_util as fusion_util
    for item in inouts:
        fusion_util.update_range_common(item)


# 'pylint: disable=too-many-arguments
def check_op_impl_mode(op_module, op_func_name):
    """
    check if op has impl_mode paramter
    """
    opm = importlib.import_module(op_module)
    opfunc = getattr(opm, op_func_name)

    impl_mode_arg = inspect.signature(opfunc).parameters.get('impl_mode', None)

    if impl_mode_arg is not None and \
       impl_mode_arg.kind in (inspect.Parameter.KEYWORD_ONLY,
                              inspect.Parameter.POSITIONAL_OR_KEYWORD):
        return True

    return False


def is_op_support_fusion(op_type, op_name, dyn_impl):
    import tbe.common.register as tbe_register
    if dyn_impl:
        op_comp = tbe_register.get_op_compute(op_type, "dynamic")
    else:
        op_comp = tbe_register.get_op_compute(op_name, "static")
    support = op_comp.if_support_fusion() if op_comp else False
    return support


def get_prebuild_op_pattern(compile_info):
    if compile_info.get("op_pattern") is not None:
        return compile_info.get("op_pattern")
    else:
        return get_op_pattern()


def set_outputs_atomic_compile_info(inputs, outputs, atomic_type):
    for input_desc in inputs:
        if input_desc is not None:
            atomic_type.append("")
    for output_desc in outputs:
        if isinstance(output_desc, tuple):
            for desc in output_desc:
                if desc is not None:
                    atomic_type.append(desc.get("atomic_type", ""))
        else:
            if output_desc is not None:
                atomic_type.append(output_desc.get("atomic_type", ""))


def get_single_caxis_value(inoroutputs):
    import tbe.common.utils.log as logger
    caxis_valus = []
    for inoroutputdesc in inoroutputs:
        if isinstance(inoroutputdesc, tuple):
            for desc in inoroutputdesc:
                if desc is not None:
                    caxis_value = desc.get("input_c_values", -1)
                    caxis_valus.append(caxis_value)
                    logger.info("get_single_caxis_value desc notnone input_c_values:%s", str(caxis_value))
        else:
            if inoroutputdesc is not None:
                caxis_value = inoroutputdesc.get("input_c_values", -1)
                caxis_valus.append(caxis_value)
                logger.info("get_single_caxis_value inoroutputdesc notnone input_c_values:%s", str(caxis_value))
    return caxis_valus


def set_single_op_stride_info(inputs, outputs):
    from tbe.tvm.buffer_manager import get_buffer_manager
    buffer_manager = get_buffer_manager()
    buffer_manager.clear_remapped_buffers()

    def _add_stride_info(stride_info, desc, index):
        buffer_scope = "global"
        addr_type = desc.get("addr_type", 0)
        if addr_type == 1:
            buffer_scope = "local.L1_Fusion"
        if addr_type == 3:
            buffer_scope = "local.UB_Fusion"
        input_shape = desc.get("total_shape", [])
        valid_shape = desc.get("valid_shape", [])
        l1AddrOffset = None
        if addr_type == 2:
            l1AddrOffset = desc.get("L1_addr_offset", None)
        stride_info.append((index, buffer_scope, tuple(input_shape),
                            tuple(valid_shape), l1AddrOffset))
    def _add_out_stride_info(stride_info, desc, index):
        buffer_scope = "global"
        addr_type = desc.get("addr_type", 0)
        if addr_type == 1:
            buffer_scope = "local.L1_Fusion"
        if addr_type == 3:
            buffer_scope = "local.UB_Fusion"
        output_shape = desc.get("total_shape", [])
        valid_shape = desc.get("shape", [])
        l1AddrOffset = None
        if addr_type == 2:
            l1AddrOffset = desc.get("L1_addr_offset", None)
        stride_info.append((index, buffer_scope, tuple(output_shape),
                            tuple(valid_shape), l1AddrOffset))
    stride_info = []
    all_valid_shape = []
    addr_types = []
    index = 0
    for input_desc in inputs:
        if isinstance(input_desc, tuple):
            for desc in input_desc:
                if desc is not None:
                    _add_stride_info(stride_info, desc, index)
                    tmp_valid_shape = desc.get("valid_shape", [])
                    all_valid_shape.append(tmp_valid_shape)
                    addr_types.append(desc.get("addr_type", 0))
                    index += 1
        else:
            if input_desc is not None:
                _add_stride_info(stride_info, input_desc, index)
                tmp_valid_shape = input_desc.get("valid_shape", [])
                all_valid_shape.append(tmp_valid_shape)
                addr_types.append(input_desc.get("addr_type", 0))
                index += 1

    l1_fusion_type = -1
    for output_desc in outputs:
        if isinstance(output_desc, tuple):
            for desc in output_desc:
                if desc is not None:
                    _add_out_stride_info(stride_info, desc, index)
                    tmp_valid_shape = desc.get("valid_shape", [])
                    all_valid_shape.append(tmp_valid_shape)
                    addr_types.append(desc.get("addr_type", 0))
                    l1_fusion_type = desc.get("L1_fusion_type", -1)
                    index += 1
        else:
            if output_desc is not None:
                _add_out_stride_info(stride_info, output_desc, index)
                tmp_valid_shape = output_desc.get("valid_shape", [])
                all_valid_shape.append(tmp_valid_shape)
                addr_types.append(output_desc.get("addr_type", 0))
                l1_fusion_type = output_desc.get("L1_fusion_type", -1)
                index += 1
    def _not_set_stride_info(lx_stride_info, lx_valid_shape, addr_types):
        for idx, item in enumerate(lx_stride_info):
            if item[1] in ("local.L1_Fusion", "local.UB_Fusion") or (addr_types[idx] == 2 and item[4] != 0):
                return False
        for item in lx_valid_shape:
            if any(item):
                return False
        return True

    # addr types has nano ub, set ub_fusion_type
    if 3 in addr_types:
        buffer_manager.set_ub_fusion_type(int(l1_fusion_type))
    else:
        buffer_manager.set_l1_fusion_type(int(l1_fusion_type))
    not_set_lx_info = _not_set_stride_info(stride_info, all_valid_shape,
                                           addr_types)
    if not_set_lx_info:
        return
    rbs = []
    from tbe.tvm.buffer_manager import RemappedBuffer
    for i in stride_info:
        rbs.append(RemappedBuffer(*i))
    buffer_manager.set_remapped_buffers(rbs)


def set_context_parameter(context, device_id=None, reset_op_info=None):
    if device_id is not None and len(device_id) > 0:
        context.add_addition("device_id", device_id)
    if reset_op_info is not None:
        context.add_addition("reset_op_info", reset_op_info)


def collect_ctx(ctx_queue, item_num):
    """Collect op context value from child op context

    Args:
        ctx_queue (multiprocessing.Queue): context queue used for IPC
        item_num (int): Number of child process.
    """
    import tbe.common.context.op_context as op_context
    op_ctx = op_context.get_context()
    compile_info_all = op_ctx.get_compile_info()
    for _ in range(item_num):
        ctx_info = ctx_queue.get()
        if isinstance(ctx_info, str):
            raise RuntimeError(ctx_info)
        pattern = ctx_info.get("pattern", None)
        compile_info = ctx_info.get("compile_info", None)
        if pattern:
            op_ctx.add_build_res("pattern", pattern)
        if compile_info:
            compile_info_all = merge_dict(compile_info_all, compile_info)
    op_ctx.set_compile_info(compile_info_all)


def merge_dict(origin, update):
    """Merge dict recurisvely, list value also merged

    Args:
        origin (Any): origin value
        update (Any): update value

    Returns:
        Any: merged dict. origin is updated inplace
    """
    if not isinstance(origin, dict) or not isinstance(update, dict):
        return update
    for k, v in update.items():
        if k in origin:
            origin[k] = merge_dict(origin[k], v)
        else:
            origin[k] = v
    return origin


def parallel_runner(op_func):
    """return a op_func wrapper which runs parallelly

    Args:
        op_func (Callable): op entry function

    Returns:
        Callable: op_func wrapper
    """
    import traceback
    import multiprocessing
    mp = multiprocessing.get_context('fork')
    from tbe.dsl.base import operation
    import tbe.common.context.op_context as op_context

    def context_handler(ctx_queue, op_func, *args, **kwds):
        try:
            op_func(*args, **kwds)
        except Exception:
            msg = traceback.format_exc()
            ctx_queue.put(msg)
        else:
            pattern = op_context.get_context().get_build_res("pattern")
            compile_info = op_context.get_context().get_compile_info()
            ctx_queue.put({"pattern": pattern,
                           "compile_info": compile_info})

    def _wrapper(*args, **kwds):
        context = operation.get_context()
        proc_num = _PARALLEL_SCH_PROCESS
        value_num = mp.Value('i', 0)
        build_list_ruls = mp.Queue()
        ctx_q = mp.Queue()
        process_list = []
        deamon_status = mp.current_process().daemon
        mp.current_process().daemon = False
        for idx in range(proc_num):
            op_compile_process_vars = {
                "idx":idx,
                "num":proc_num,
                "op_process_value":value_num,
                "build_list_ruls":build_list_ruls}
            context.set_op_compile_process_vars(op_compile_process_vars)
            p = mp.Process(target=context_handler, args=(ctx_q, op_func, *args), kwargs=kwds)
            process_list.append(p)
            p.start()
        mp.current_process().daemon = deamon_status
        exitcode_list = []
        collect_ctx(ctx_q, proc_num)
        for p in process_list:
            p.join()
            exitcode_list.append(p.exitcode)
        for exitcode in exitcode_list:
            if exitcode != 0:
                raise RuntimeError("compile process of Op [mat_mul] exited unexpectedly, exitcode: %d.", exitcode)
    return _wrapper


# 'pylint: disable=too-many-locals, too-many-statements
def get_op_func(op_module, op_func_name, op_type, is_dynamic_impl):
    opm = importlib.import_module(op_module)
    if is_dynamic_impl:
        import tbe.common.register as tbe_register
        operateor = tbe_register.get_operator(op_type)
        if operateor is not None:
            op_func = operateor.get_func()
            if op_type in _PARALLEL_SCH_OP:
                return op_func, parallel_runner(op_func)
            return op_func, op_func

    op_func = getattr(opm, op_func_name)
    return op_func, op_func


def set_single_op_sgt_slice_info(inputs, outputs):
    """
    Set single op sgt slice info
    -------

    Returns
    -------
    True: Success
    False: Fail
    """
    def _add_stride_info(stride_info, desc, index):
        buffer_scope = "global"
        input_shape = desc.get("total_shape", [])
        sgt_slice_shape = desc.get("sgt_slice_shape", [])
        stride_info.append((index, buffer_scope, tuple(input_shape), tuple(sgt_slice_shape)))

    def _add_out_stride_info(stride_info, desc, index):
        buffer_scope = "global"
        output_shape = desc.get("total_shape", [])
        sgt_slice_shape = desc.get("sgt_slice_shape", [])
        stride_info.append((index, buffer_scope, tuple(output_shape), tuple(sgt_slice_shape)))
    stride_info = []
    all_valid_shape = []
    index = 0
    for input_desc in inputs:
        if not isinstance(input_desc, tuple):
            if input_desc is not None:
                _add_stride_info(stride_info, input_desc, index)
                tmp_valid_shape = input_desc.get("sgt_slice_shape", [])
                all_valid_shape.append(tmp_valid_shape)
                index += 1
            continue
        for desc in input_desc:
            if desc is not None:
                _add_stride_info(stride_info, desc, index)
                tmp_valid_shape = desc.get("sgt_slice_shape", [])
                all_valid_shape.append(tmp_valid_shape)
                index += 1
    for output_desc in outputs:
        if not isinstance(output_desc, tuple):
            if output_desc is not None:
                _add_out_stride_info(stride_info, output_desc, index)
                tmp_valid_shape = output_desc.get("sgt_slice_shape", [])
                all_valid_shape.append(tmp_valid_shape)
                index += 1
            continue
        for desc in output_desc:
            if desc is not None:
                _add_out_stride_info(stride_info, desc, index)
                tmp_valid_shape = desc.get("sgt_slice_shape", [])
                all_valid_shape.append(tmp_valid_shape)
                index += 1

    def _not_set_stride_info(sgt_slice_shape):
        for item in sgt_slice_shape:
            if any(item):
                return False
        return True

    not_set_sgt_info = _not_set_stride_info(all_valid_shape)
    if not_set_sgt_info:
        return
    from tbe.tvm.buffer_manager import get_buffer_manager
    buffer_manager = get_buffer_manager()
    buffer_manager.clear_remapped_buffers()
    rbs = []
    from tbe.tvm.buffer_manager import RemappedBuffer
    for i in stride_info:
        rbs.append(RemappedBuffer(*i))
    buffer_manager.set_remapped_buffers(rbs)


def attrs_is_dict(op_info, attrs):
    context_attrs = list(attrs)
    new_attrs = []
    flag = True
    if not context_attrs:
        return op_info, new_attrs, context_attrs
    if not isinstance(context_attrs[0], dict):
        flag = False
    else:
        if 'name' not in context_attrs[0] or 'dtype' not in context_attrs[0] or 'value' not in context_attrs[0]:
            flag = False
    attrs_flag = context_attrs and flag
    if attrs_flag:
        for context_attr in context_attrs:
            if isinstance(context_attr, dict):
                new_attrs.append(context_attr.get('value'))
        if isinstance(context_attrs[-1], str):
            op_info.kernel_name = context_attrs.pop()
            new_attrs.append(op_info.kernel_name)
    else:
        if context_attrs:
            op_info.kernel_name = context_attrs.pop()
        new_attrs = list(attrs)
    return op_info, new_attrs, context_attrs


def no_need_do_prebuild(build_mode, need_precompile, is_support_fusion):
    if build_mode == "prebuild" and need_precompile == "false" and not is_support_fusion:
        return True
    return False


def set_single_op_context(op_info, fuzz_build_info_json, master_pid, op_name, status_check,
                          context_param, tune_param, device_id, reset_op_info, core_type,
                          optional_input_mode, caxis_valus, build_cfg, dynamic_param_mode,
                          superkenel_sub_info_dict):
    import tbe.common.context.op_context as op_context
    context = op_context.get_context()
    context.add_op_info(op_info)
    import tbe.common.context.op_info as operator_info
    op_info_bak = copy.deepcopy(op_info)
    graph_op_info = operator_info.OpInfo(op_name, op_info_bak.op_type)
    graph_op_info.inputs = op_info_bak.inputs
    graph_op_info.outputs = op_info_bak.outputs
    graph_op_info.attrs = op_info_bak.attrs
    context.set_graph_op_info(graph_op_info)
    context.set_build_type(fuzz_build_info_json.get('compile_type'))
    context.add_addition("missing_support_info", fuzz_build_info_json.get('miss_support_info'))
    context.add_addition("max_kernel_id", fuzz_build_info_json.get('max_kernel_id'))
    import te_fusion.fusion_util as fusion_util
    bank_path_dict = fusion_util.OpImplPolicy.bank_path_kwargs
    context.add_addition("op_bank_path", bank_path_dict.get("op_bank_path", None))
    context.add_addition("mdl_bank_path", bank_path_dict.get("mdl_bank_path", None))
    context.add_addition("master_pid", master_pid)
    context.add_addition("op_name", op_name)
    context.add_addition("status_check", status_check)
    context.add_addition("optional_input_mode", optional_input_mode)
    context.add_addition("dynamic_param_mode", dynamic_param_mode)
    context.add_addition("input_c_values", caxis_valus)
    context.add_addition("build_options", build_cfg)
    context.add_addition("super_kernel_sub_info", superkenel_sub_info_dict)
    fusion_util.add_context_param(context, context_param)
    context.add_compile_info("device_id", device_id)
    context.add_compile_info("_cube_vector_core_type", core_type)

    if tune_param:
        context.add_addition("tune_param", json.loads(tune_param))
    set_context_parameter(context, device_id, reset_op_info)


def update_compile_info(json_file_path, compile_info):
    """
    update compile info into json file if necessary
    """
    import tbe.common.utils.log as logger
    logger.debug("update compile info into json file path: %s.", json_file_path)

    if not json_file_path:
        return

    if not os.path.exists(json_file_path):
        logger.warn("[update_compile_info]: json_file_path does not exist!")
        return

    if not compile_info:
        logger.warn("[update_compile_info]: compile_info is empty!")
        return

    logger.debug("update compile info into json file path: %s.", json_file_path)

    json_content = {}
    with open(json_file_path) as fr:
        json_content = json.load(fr)

    # update compile info if necessary
    if "compileInfo" not in json_content:
        logger.warn("[update_compile_info]: update compile info into json file path: %s.", json_file_path)
        json_content["compileInfo"] = compile_info

        with open(json_file_path, "w") as fw:
            json.dump(json_content, fw, sort_keys=True,
                    indent=4, separators=(',', ':'))


def generate_ddr_base_prop(inputs, outputs):
    ddr_base_prop_vec = []
    for input_desc in inputs:
        if isinstance(input_desc, tuple):
            for desc in input_desc:
                if desc is not None and desc.get("ddr_base_prop") is not None:
                    ddr_base_prop_vec.append(desc.get("ddr_base_prop"))
                    desc.pop("ddr_base_prop")
        else:
            if input_desc is not None and input_desc.get("ddr_base_prop") is not None:
                ddr_base_prop_vec.append(input_desc.get("ddr_base_prop"))
                input_desc.pop("ddr_base_prop")

    for output_desc in outputs:
        if isinstance(output_desc, tuple):
            for desc in output_desc:
                if desc is not None and desc.get("ddr_base_prop") is not None:
                    ddr_base_prop_vec.append(desc.get("ddr_base_prop"))
                    desc.pop("ddr_base_prop")
        else:
            if output_desc is not None and output_desc.get("ddr_base_prop") is not None:
                ddr_base_prop_vec.append(output_desc.get("ddr_base_prop"))
                output_desc.pop("ddr_base_prop")
    return ddr_base_prop_vec


# 'pylint: disable=too-many-locals, too-many-statements
def build_single_op(op_module, op_func_name, op_type, build_mode, *op_args, inputs=None, outputs=None, attrs=None,
                    options=None, private_attrs=None, unknown_shape=False, int64_mode=False, is_dynamic_impl=False,
                    op_pattern=None, device_id=None, fuzz_build_info=None, reset_op_info=None, context_param=None,
                    pass_opt_list="", tune_param=None, master_pid=None, op_name=None, extra_params=None,
                    relation_param="", op_impl_switch="", op_impl_mode="", optional_input_mode=None,
                    enable_superkernel_plus="", superkenel_sub_info="", dynamic_param_mode=None,
                    binary_compile_mode=False):
    """Prebuild Op
    Parameters
    ----------
    op_module: op module name
    op_args: op args

    Returns
    -------
    op pattern value
        end of execution
    """
    dyn_flag = unknown_shape
    origin_opfunc, opfunc = get_op_func(op_module, op_func_name, op_type, is_dynamic_impl)

    res = dict()
    flag_enable = False

    import te_fusion.fusion_util as fusion_util
    kwargs = fusion_util.get_op_impl_mode_args(origin_opfunc, op_impl_mode)
    if not binary_compile_mode:
        fusion_util.trans_bool_to_int8(op_type, inputs, outputs)

    from tbe.common.buildcfg import build_config
    if build_mode == 'prebuild':
        set_current_op_func_name(op_func_name)  # for pattern
        init_op_pattern()                       # for init pattern to Opaque
        op_build_cfg_dis()                      # for cce build
        flag_enable = True
    else:
        op_build_cfg_en()
        flag_enable = False

    set_lic_pass_opt_list(op_type, pass_opt_list)

    incremental_link_dict = []
    fuzz_build_info_json = dict()
    if fuzz_build_info is not None:
        fuzz_build_info_json = json.loads(fuzz_build_info)
        if fuzz_build_info_json["incremental_link"]:
            incremental_link_dict.append(fuzz_build_info_json.get('incremental_link'))
    status_check = options.get("status_check", "").lower() != "false"
    jit_mode = options.get("jit_compile_mode", 0)
    dyn_impl = dyn_flag or is_dynamic_impl

    if no_need_do_prebuild(build_mode, options.get("need_precompile"),
                           is_op_support_fusion(op_type, op_func_name, dyn_impl)):
        res["pattern"] = "Opaque"
        res["core_type"] = "Default"
        res["prebuilt_options"] = ""
        return res

    relation_list = relation_param.split()
    relation_list = [int(i) for i in relation_list]
    atomic_type = []
    set_outputs_atomic_compile_info(inputs, outputs, atomic_type)

    deterministic = True if options.get('deterministic') == 'true' else False
    single_op_build_cfg = options.get("single_op_build_cfg")
    ddr_base_prop_vec = generate_ddr_base_prop(inputs, outputs)

    is_enable_superkernel_plus = enable_superkernel_plus == "true"
    is_enable_vector_core = True if options.get('enable_vector_core', "").lower() == 'true' else False
    core_type = "MIX_VECTOR_CORE" if is_enable_vector_core else options.get("coreType", "AiCore")
    superkenel_sub_info_dict = {}
    if superkenel_sub_info != "":
        superkenel_sub_info_dict = json.loads(superkenel_sub_info)
    is_enable_ascendc_superkernel = superkenel_sub_info_dict.get("enable_super_kernel", False)
    with build_config(enable_op_prebuild = flag_enable, incremental_link = incremental_link_dict,
                      compatible=True, lic_params=pass_opt_list, status_check=status_check,
                      inplace_output_tensor_index=relation_list, enable_auto_atomic=atomic_type,
                      enable_deterministic_mode=deterministic, jit_compile_mode=jit_mode,
                      ddr_base_property=ddr_base_prop_vec, enable_model_fusion=is_enable_superkernel_plus,
                      enable_vector_core=is_enable_vector_core,
                      enable_super_kernel=is_enable_ascendc_superkernel):
        set_single_op_stride_info(inputs, outputs)
        set_single_op_sgt_slice_info(inputs, outputs)
        res["impl_mode"] = kwargs.get("impl_mode", "null")
        res["pattern"] = ""
        res["core_type"] = ""
        res["prebuilt_options"] = ""

        def build_dyn_op(op_info, new_attrs, caxis_valus):
            import tbe.common.context.op_context as op_context
            import tbe.common.utils.log as logger
            range_padding(inputs, outputs)
            op_info.inputs = inputs
            op_info.outputs = outputs

            build_res = None
            with op_context.OpContext("dynamic"):
                set_single_op_context(op_info, fuzz_build_info_json, master_pid, op_name,
                                      status_check, context_param, tune_param, device_id,
                                      reset_op_info, core_type, optional_input_mode, caxis_valus, single_op_build_cfg,
                                      dynamic_param_mode, superkenel_sub_info_dict)
                opfunc(*inputs, *outputs, *new_attrs, **kwargs)

                if build_mode == 'prebuild':
                    res["op_pattern"] = op_context.get_context().get_build_res("pattern")
                    res["prebuilt_options"] = op_context.get_context().get_build_res("prebuilt_options")
                    logger.debug("op_pattern = %s.", res["op_pattern"])
                else:
                    json_file_path = op_context.get_context().get_build_res("json_file_path")
                    logger.debug("json_file_path= %s.", json_file_path)

                    if not json_file_path:
                        from tbe.common.buildcfg import get_current_build_config
                        json_file_path = os.path.join(get_current_build_config("kernel_meta_parent_dir"),
                            "kernel_meta", op_info.kernel_name + ".json")
                        logger.warn("json_file_path=%s.", json_file_path)

                    if os.path.exists(json_file_path):
                        build_res = {"json_file_path": json_file_path}
                        update_compile_info(json_file_path, op_context.get_context().get_compile_info(None))
                    else:
                        build_res = {"json_file_path": json_file_path, \
                            "compile_info":op_context.get_context().get_compile_info(None)}

            return build_res

        def build_static_op(op_info, new_attrs, caxis_valus):
            import tbe.common.context.op_context as op_context
            import tbe.common.utils.log as logger
            range_padding(inputs, outputs)

            build_res = None
            with op_context.OpContext("static"):
                set_single_op_context(op_info, fuzz_build_info_json, master_pid, op_name,
                                        status_check, context_param, tune_param,
                                        device_id, reset_op_info, core_type, optional_input_mode,
                                        caxis_valus, single_op_build_cfg, dynamic_param_mode,
                                        superkenel_sub_info_dict)
                opfunc(*inputs, *outputs, *new_attrs, **kwargs)

                if build_mode == 'prebuild':
                    res["op_pattern"] = op_context.get_context().get_build_res("pattern")
                    res["prebuilt_options"] = op_context.get_context().get_build_res("prebuilt_options")
                    logger.debug("op_pattern=%s.", res["op_pattern"])
                else:
                    json_file_path = op_context.get_context().get_build_res("json_file_path")
                    logger.debug("json_file_path = %s.", json_file_path)
                    read_dump_tensor_list(options, op_context.get_context(), op_info)

                    if not json_file_path:
                        from tbe.common.buildcfg import get_current_build_config
                        json_file_path = os.path.join(get_current_build_config("kernel_meta_parent_dir"),
                            "kernel_meta", op_info.kernel_name + ".json")
                        logger.warn("json_file_path=%s.", json_file_path)

                    build_res = {"json_file_path": json_file_path}
            return build_res

        def build_pre_static_op(op_info, new_attrs, caxis_valus):
            import tbe.common.context.op_context as op_context
            import tbe.common.utils.log as logger
            with op_context.OpContext("pre-static"):
                set_single_op_context(op_info, fuzz_build_info_json, master_pid, op_name,
                                        status_check, context_param, tune_param,
                                        device_id, reset_op_info, core_type, optional_input_mode,
                                        caxis_valus, single_op_build_cfg, dynamic_param_mode,
                                        superkenel_sub_info_dict)
                opfunc(*inputs, *outputs, *new_attrs, **kwargs)

                build_res = None
                if build_mode == 'prebuild':
                    res["prebuilt_options"] = op_context.get_context().get_build_res("prebuilt_options")
                else:
                    json_file_path = op_context.get_context().get_build_res("json_file_path")
                    logger.debug("json_file_path = %s.", json_file_path)
                    read_dump_tensor_list(options, op_context.get_context(), op_info)

                    if not json_file_path:
                        from tbe.common.buildcfg import get_current_build_config
                        json_file_path = os.path.join(get_current_build_config("kernel_meta_parent_dir"),
                            "kernel_meta", op_info.kernel_name + ".json")
                        logger.warn("json_file_path=%s.", json_file_path)

                    build_res = {"json_file_path": json_file_path}

                return build_res

        def call_op():
            import tbe.common.context.op_info as operator_info
            import tbe.common.utils.log as logger
            op_info = operator_info.OpInfo(op_func_name, op_type)
            op_info.pattern = op_pattern
            op_info.inputs = inputs
            op_info.outputs = outputs
            context_attrs = list(attrs)
            op_info, new_attrs, context_attrs = attrs_is_dict(op_info, attrs)
            if private_attrs:
                context_attrs = context_attrs + list(private_attrs)
            logger.debug("op[%s] with attrs: %s, and private_attr: %s", str(op_type),
                         str(context_attrs), str(private_attrs))
            caxis_valus = get_single_caxis_value(inputs)
            op_info.attrs = context_attrs
            op_info.extra_params = dict(kwargs)
            op_info.precision_mode = op_impl_mode
            import te_fusion.fusion_util as fusion_util
            op_extra_params = fusion_util.get_extra_params(extra_params)
            if op_impl_switch is not None and len(op_impl_switch) > 0:
                op_extra_params["op_impl_switch"] = op_impl_switch
            op_info.extra_params.update(op_extra_params)
            logger.debug("start build op_type: [%s], kernel_name = [%s].", op_type, op_info.kernel_name)

            build_res = None
            if dyn_flag:
                build_res = build_dyn_op(op_info, new_attrs, caxis_valus)
            else:
                if is_dynamic_impl:
                    build_res = build_static_op(op_info, new_attrs, caxis_valus)
                else:
                    build_res = build_pre_static_op(op_info, new_attrs, caxis_valus)

            logger.debug("build finished. op_type: [%s], kernel_name = [%s].", op_type, op_info.kernel_name)
            if build_mode == 'prebuild':
                res["prebuilt_options"] = "" if res["prebuilt_options"] is None else res["prebuilt_options"]
                return res
            else:
                return build_res

        is_compile_with_int64 = int64_mode and not dyn_flag
        from tbe.tvm._api_config import api_config as _api_config
        if is_compile_with_int64:
            with _api_config.bit_width_64():# 'pylint: disable=not-context-manager
                build_res = call_op()
        else:
            with _api_config.bit_width_32():# 'pylint: disable=not-context-manager
                build_res = call_op()

        if build_mode == 'prebuild':
            op_build_cfg_en()
            with build_config(enable_op_prebuild=False, compatible=True, lic_params=pass_opt_list):
                res["pattern"] = get_prebuild_op_pattern(res)
                return res
        else:
            return build_res


def read_dump_tensor_list(options, context, op_info):
    """
    read tensor_list and dump compute json

    Parameters
    ----------
    op_name: op name
    op_info: op info

    Returns
    -------
    """
    import tbe.common.utils.log as logger
    from te_fusion.fusion_util import dump_compute_json
    if options is not None and options.get('op_debug_level', '0') == '4':
        logger.debug("Real op debug level is 4")
        tensor_list = context.get_addition("tensor_list")
        if tensor_list:
            logger.debug("tensor_list is not null and tensor_list's length is %d.", len(tensor_list))
        else:
            logger.debug("tensor_list is null")
            return

        inputs_number = len(op_info.inputs)
        if tensor_list and len(tensor_list) > inputs_number:
            tensor_inputs = tensor_list[0: inputs_number]
            tensor_outputs = tensor_list[inputs_number:]
            dump_compute_json(tensor_outputs, tensor_inputs, op_info.kernel_name)
    else:
        logger.debug("Real op debug level is not 4")
        return


def save_op_params(op_name, op_build_type, op_args):
    """Save op params

    Parameters
    ----------
    op_name: op name
    op_func_name: op function name
    op_args: op args

    Returns
    -------
    """
    set_current_op_name(op_name)
    set_op_build_type(op_build_type)  # for fusion
    if isinstance(op_args, (list, tuple)):
        if len(op_args) == 2:
            outputs, _ = op_args
            set_op_params(*outputs)
        else:
            set_op_params(*op_args)
    else:
        set_op_params(op_args)


def op_params_to_json(op_name):
    """
    transform op params to json
    """
    args_json = {'list_args': []}
    try:
        args_json['list_args'].extend(fusion_manager.get_op_args(op_name))
    except Exception:       # 'pylint: disable=bare-except,broad-except
        import tbe.common.utils.log as logger
        logger.warn("Exception: Failed to get attrs from the option_node: %s", op_name)
    return json.dumps(args_json)


def get_fusion_build_cfg():
    """get build_config used by fusion manager

    Returns
    -------
    fusion_manger build_config:
    """
    warnings.warn("te_fusion.fusion_manager.get_fusion_build_cfg is deprecated,"
                  "please replace it with tbe.common.register.set_fusion_buildcfg",
                  DeprecationWarning, stacklevel=2)
    import tbe.common.register
    fusion_build_config = tbe.common.register.get_fusion_buildcfg()
    for key in fusion_build_config.keys():
        for k, v in fusion_build_config[key].items():
            if k in fusion_manager.fusion_build_config:
                if fusion_manager.fusion_build_config[k] != v:
                    logger.warn("Exception: fusion_build_config of %s is not same: %s and %s",
                                str(k), str(v), str(fusion_manager.fusion_build_config[k]))
            fusion_manager.fusion_build_config[k] = v
    return fusion_manager.fusion_build_config


def reset_fusion_build_cfg():
    """reset build_config used by fusion manager
    """
    fusion_manager.fusion_build_config = {}
    import tbe.common.register
    tbe.common.register.reset()


def clear_fusion_params():
    """
    clear fusion op params
    """
    fusion_manager.clear()


def get_str_sha256_hash_from_c(str_to_hash):
    """
    get sha256 hash string from tefsuion c side
    """
    sha256_hash = hashlib.sha256()
    sha256_hash.update(str_to_hash.encode('utf-8'))
    return sha256_hash.hexdigest()


def get_binfile_sha256_hash_from_c(str_bytes):
    """
    get sha256 hash string from tefsuion c side
    """
    sha256_hash = hashlib.sha256(str_bytes).hexdigest()
    return sha256_hash

def get_file_sha256_hash_from_c(file_path):
    """
    get .o file sha256 hash value from tefsuion c side
    """
    sha256_hash = ""
    try:
        with open(file_path, 'rb') as nwe_file:
            sha256_hash = hashlib.sha256(nwe_file.read()).hexdigest()
    except IOError as e:
        import tbe.common.utils.log as logger
        logger.warn("Open file[%s] failed, reason: %s", file_path, str(e))

    return sha256_hash


def get_tik_build_config():
    """
    get tbe build config for tik dsl op in RL, after the config
    is fetched, it will be reset to empty
    """
    res = fusion_manager.tik_build_config
    fusion_manager.tik_build_config = {}
    return res


def generalize_shape_and_range_from_c(op_args, op_type, op_module, op_impl_mode, generalize_config):
    """
    generalize shape and range by tbe for fuzz build

    Parameters
    ----------
    op_args : list
    inputs, outputs, attrs
    op_type: string
    op type
    generalize_config: string dict

    Returns
    -------
    shape and range generalize result
    """
    import tbe.common.utils.log as logger
    dyn_op_module = op_module.split(".")
    op_file_name = dyn_op_module[-1]
    dyn_op_module[-1] = "dynamic"
    dyn_op_module.append(op_file_name)
    dyn_op_module = ".".join(dyn_op_module)

    try:
        importlib.import_module(dyn_op_module)
    except ImportError as exce:
        logger.warn("Unable to import %s, reason:%s.", dyn_op_module, exce)
        return json.dumps("")
    finally:
        pass

    import tbe.common.register as tbe_register
    generalize_func = tbe_register.get_param_generalization(op_type)
    if generalize_func:
        inputs, outputs, attrs = op_args
        import te_fusion.fusion_util as fusion_util
        kwargs = fusion_util.get_op_impl_mode_args(generalize_func, op_impl_mode)
        kwargs["generalize_config"] = generalize_config

        generalize_res = generalize_func(*inputs, *outputs, *attrs, **kwargs)
        return json.dumps(generalize_res)
    logger.warn("generalize func of node[%s] not exist." % op_type)
    return json.dumps("")


def is_generalize_func_register_from_c(op_type, op_module):
    """
    check is op has registered generalize func

    Parameters
    ----------
    op_type: string
    op type

    Returns
    -------
    True or False
    """

    dyn_op_module = op_module.split(".")
    op_file_name = dyn_op_module[-1]
    if "dynamic" not in dyn_op_module:
        dyn_op_module[-1] = "dynamic"
        dyn_op_module.append(op_file_name)
    dyn_op_module = ".".join(dyn_op_module)

    try:
        importlib.import_module(dyn_op_module)
    except ImportError as exce:
        import tbe.common.utils.log as logger
        logger.warn("Unable to import %s, output:%s.", dyn_op_module, exce)
        return False
    finally:
        pass

    # 'pylint: disable=E0401,C0414,C0415
    from tbe.common import register as register
    generalize_func = register.get_param_generalization(op_type)
    return bool(generalize_func)


def is_func_in_opModule_from_c(func_name, op_module):
    """
    check is func in op module

    Parameters
    ----------
    func_name: string
    op_module

    Returns
    -------
    True or False
    """

    try:
        opm = importlib.import_module(op_module)
    except ImportError as exce:
        return False

    if hasattr(opm, func_name):
        return True
    return False


def get_op_register_pattern():
    """
    get_op_register_pattern
    """
    from tbe.common import register as register_api
    return register_api.get_op_register_pattern()


def get_op_no_trans_bool_to_s8():
    """
    get_op_no_trans_bool_to_s8
    """
    from tbe.common.register import operation_func_mgr
    return operation_func_mgr.get_op_no_trans_bool_to_s8()


def build_single_op_from_c(op_module, op_func_name, op_type, build_mode, unknown_shape, op_args,
                           int64_mode, is_dynamic_impl, options, op_pattern, auto_tiling_mode=None, device_id=None,
                           fuzz_build_info=None, extra_params=None, op_impl_switch=None, op_impl_mode=None):
    """
    build_single_op_from_c need remove
    """
    pass