#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
compile task manager
"""
import importlib
import datetime
import traceback
import json
import sys
import os
import time
from typing import Optional
from te_fusion import fusion_manager
from te_fusion import log_util as te_log
from te_fusion.parallel_compilation import mygetattr
from te_fusion.parallel_compilation import gen_task_res
from te_fusion.parallel_compilation import OpCompiler
from te_fusion.parallel_compilation import CompilerEnv
from te_fusion.parallel_compilation import FusionOpTask
from te_fusion.parallel_compilation import SingleOpTask
from te_fusion.parallel_compilation import TaskFusionTask, SuperKernelTask
from te_fusion.parallel_compilation import OpTask
from te_fusion.parallel_compilation import update_running_task
from te_fusion.parallel_compilation import compile_op
from te_fusion.parallel_compilation import set_soc_info_before_compile
from te_fusion.fusion_util import get_params_from_task_desc
from te_fusion.fusion_util import get_params_from_graph_desc
from tbe.common.platform import platform_info as tbe_platform_info


class PrebuildTask(OpTask):
    """
    Task to prebuild tbe op
    """

    def __init__(self, graph_id, task_id, op_module, op_type, op_func, *op_args, inputs=None, outputs=None,
                 attrs=None, unknown_shape=False, int64_mode=False, options=None, is_dynamic_impl=False,
                 context_param=None, pass_opt_list=None, master_pid=None, op_name=None, extra_params=None,
                 op_impl_switch=None, op_impl_mode=None):
        """
        init
        :param graph_id:
        :param task_id:
        :param op_module:
        :param op_func:
        :param op_args:
        """
        super().__init__()
        self.graph_id = graph_id
        self._op_module = op_module
        self.task_id = task_id
        self._op_type = op_type
        self._op_type = op_type
        self._op_args = op_args
        self._op_func = op_func
        self._op_outputs = outputs
        self._op_inputs = inputs
        self.build_type = 0
        self._op_attrs = attrs
        self.options = options
        self._int64_mode = int64_mode
        self._unknown_shape = unknown_shape
        self._device_id = self.options.get("device_id") if self.options is not None else None
        self._is_dynamic_impl = is_dynamic_impl
        self._context_param = context_param
        self._master_pid = master_pid
        self._op_impl_mode = op_impl_mode
        self._pass_opt_list = pass_opt_list
        self._op_impl_switch = op_impl_switch
        self._op_name = op_name
        self._extra_params = extra_params

    def __str__(self):
        """
        string representation
        :return:
        """
        return "taskID[{}.{}]".format(self.graph_id, self.task_id)

    def run(self):
        """
        do prebuild
        :return:
        """
        self.check_core_type_before_prebuild()
        try:
            start = datetime.datetime.now()
            res = fusion_manager.build_single_op(
                self._op_module, self._op_func,
                self._op_type, "prebuild",
                *self._op_args,
                inputs=self._op_inputs,
                outputs=self._op_outputs,
                attrs=self._op_attrs,
                options=self.options,
                unknown_shape=self._unknown_shape,
                int64_mode=self._int64_mode,
                is_dynamic_impl=self._is_dynamic_impl,
                device_id=self._device_id,
                context_param=self._context_param,
                pass_opt_list=self._pass_opt_list,
                master_pid=self._master_pid,
                op_name=self._op_name,
                extra_params=self._extra_params,
                op_impl_switch=self._op_impl_switch,
                op_impl_mode=self._op_impl_mode)
            end = datetime.datetime.now()
            if self._context_param is not None:
                for key in self._context_param.keys():
                    if key == "prebuild_targets":
                        if "coreType" not in self._context_param[key]:
                            res["core_type"] = "Default"

            # after build_single_op, get core_type from tbe_platform_info
            if res["core_type"] != "Default":
                res["core_type"] = tbe_platform_info.get_soc_spec("AICORE_TYPE")
            infomsg = "prebuild success. core_type from compiler[{}] pattern[{}] module[{}] "\
                "func[{}], time:{}/{}".format(res["core_type"], res["pattern"], self._op_module,
                                              self._op_func, start, end-start)
            op_res_dict = {"pattern":res["pattern"], "core_type":res["core_type"], \
                "prebuilt_options":res["prebuilt_options"]}
            return gen_task_res(self.build_type, self.graph_id, self.task_id,
                                0, "success", infomsg, op_res=json.dumps(op_res_dict))
        except Exception:       # 'pylint: disable=broad-except
            except_msg, except_list_msg = te_log.except_msg()
            errmsg = "prebuild failed. module[{}] func[{}]"\
                .format(self._op_module, self._op_func)
            te_log.tefusion_log_full(te_log.LogLevel.ERROR, "%s. args: [%s].\n", errmsg, self._op_args)
            return gen_task_res(self.build_type, self.graph_id, self.task_id,
                                1, 'exception', errmsg,
                                err_args="args:{}, input:{}, outputs:{}, attrs:{}"
                                .format(self._op_args,
                                        self._op_inputs,
                                        self._op_outputs,
                                        self._op_attrs),
                                except_msg=except_msg,
                                except_tuple_msg=(except_list_msg,
                                                  self._op_func))

    def check_core_type_before_prebuild(self):
        import tbe.common.utils.log as logger
        core_type = self.options.get("coreType" , "")
        if core_type == "Default":
            logger.warn("[%s]core_type is :%s", self._op_type, core_type)
            self.options["coreType"] = ""

    def desc(self):
        """
        task description in json format
        """
        op_desc = {
            "type:": "prebuild",
            "module": self._op_module,
            "args": self._op_args,
            "task_infos": "args:{}, input:{}, outputs:{}, attrs:{}"
            .format(self._op_args,
                    self._op_inputs,
                    self._op_outputs,
                    self._op_attrs)
        }
        return json.dumps(op_desc)


class OpTuneSyncTask(OpTask):
    """
    Task to sync op tune params from parent to child process.
    """

    def __init__(self, module_name, func_name, func_params):
        """
        init
        :param module_name:
        :param func_name:
        :param func_params:
        """
        super().__init__()
        self._module_name = module_name
        self._func_name = func_name
        self._func_params = func_params

    def run(self):
        """
        do the data sync
        :return:
        """
        try:
            opm = importlib.import_module(self._module_name)
            opfunc = mygetattr(opm, self._func_name)
            if self._func_params is None:
                opfunc()
            else:
                params_list = self._func_params.split(",")
                opfunc(params_list)
            return
        except Exception:  # pylint: disable=broad-except
            import tbe.common.utils.log as logger
            logger.warn("Executive function %s from %s failed, traceback message: %s",
                         self._func_name, self._module_name, traceback.format_exc())


class PySysPathTask(OpTask):
    """
    task to add directories to sys.path
    """

    def __init__(self, syspath):
        """
        init
        :param syspath: path needed to add to sys.path
        """
        super().__init__()
        self._syspath = syspath

    def run(self):
        """
        add directory to sys.path
        :return:
        """
        if self._syspath not in sys.path:
            sys.path.insert(0, self._syspath)


class PyImportTask(OpTask):
    """
    task to import py modules
    """

    def __init__(self, module_list):
        """
        init
        :param module_list:
        """
        super().__init__()
        self._module_list = module_list.split(",")

    def run(self):
        """
        do python module import
        :return:
        """
        for mlist in self._module_list:
            if mlist:
                importlib.import_module(mlist)


# 'pylint: disable=too-many-arguments
def dispatch_prebuild_task(graph_id, task_id, l1size, op_module, op_name, op_type, op_func, unknown_shape,
                           op_args, int64_mode=False, is_dynamic_impl=False, context_param=None, pass_opt_list=None,
                           extra_params=None, op_impl_switch=None, op_impl_mode=None):
    """
    prebuild task
    :param graph_id:
    :param task_id:
    :param op_module:
    :param op_func:
    :param op_args:
    """
    with CompilerEnv.env_guard():
        if OpCompiler.compiler is None:
            return
        if not OpCompiler.is_sub_proc_ok():
            raise Exception("Sub compiler processes not ok")
        inputs, outputs, attrs, options = op_args
        master_pid = OpCompiler.master_pid
        task = PrebuildTask(graph_id, task_id, op_module, op_type, op_func, inputs=inputs, outputs=outputs, attrs=attrs,
                            unknown_shape=unknown_shape, int64_mode=int64_mode, options=options,
                            is_dynamic_impl=is_dynamic_impl, context_param=context_param, pass_opt_list=pass_opt_list,
                            master_pid=master_pid, op_name=op_name, extra_params=extra_params,
                            op_impl_switch=op_impl_switch, op_impl_mode=op_impl_mode)
        task.set_l1size(l1size)
        OpCompiler.compiler.dispatch_task(task)
        CompilerEnv.task_counter_modify(1)


# 'pylint: disable=too-many-arguments, too-many-locals
def dispatch_single_op_compile_task(graph_id, task_id, l1size, op_module, op_name,
                                    op_type, op_func, kernel_name, unknown_shape,
                                    op_args, int64_mode=False, pre_task=None, post_task=None,
                                    is_dynamic_impl=False, op_pattern=None, fuzz_build_info=None,
                                    context_param=None, pass_opt_list=None, tune_param=None,
                                    extra_params=None, relation_param="", op_impl_switch="", op_impl_mode="",
                                    optional_input_mode=None, enable_superkernel_plus="", superkenel_sub_info="",
                                    dynamic_param_mode=None):
    """
    single op build task
    :param graph_id:
    :param task_id:
    :param op_module:
    :param op_func:
    :param kernel_name:
    :param op_args:
    """
    with CompilerEnv.env_guard():
        if OpCompiler.compiler is None:
            return

        if not OpCompiler.is_sub_proc_ok():
            raise Exception("Sub compiler processes not ok")

        inputs, outputs, attrs, options, private_attrs = op_args
        if pre_task is not None:
            pre_task = json.loads(pre_task)
        if post_task is not None:
            post_task = json.loads(post_task)

        task = SingleOpTask(graph_id, task_id, op_module,
                            op_type, op_func, kernel_name,
                            inputs=inputs, outputs=outputs, attrs=attrs, private_attrs=private_attrs,
                            unknown_shape=unknown_shape, int64_mode=int64_mode,
                            options=options, pre_task=pre_task, post_task=post_task,
                            is_dynamic_impl=is_dynamic_impl, op_pattern=op_pattern,
                            fuzz_build_info=fuzz_build_info, reset_op_info=OpCompiler.compiler.get_reset_op_info(),
                            context_param=context_param, pass_opt_list=pass_opt_list,
                            tune_param=tune_param, master_pid=OpCompiler.master_pid, op_name=op_name,
                            extra_params=extra_params, relation_param=relation_param, op_impl_switch=op_impl_switch,
                            op_impl_mode=op_impl_mode, optional_input_mode=optional_input_mode,
                            enable_superkernel_plus=enable_superkernel_plus, superkenel_sub_info=superkenel_sub_info,
                            dynamic_param_mode=dynamic_param_mode)

        task.set_l1size(l1size)
        OpCompiler.compiler.dispatch_task(task)
        CompilerEnv.task_counter_modify(1)


def dispatch_binary_single_op_compile_task(task_desc_str):
    with CompilerEnv.env_guard():
        if OpCompiler.compiler is None:
            return

        if not OpCompiler.is_sub_proc_ok():
            raise Exception("Sub compiler processes not ok")

        single_op_params = get_params_from_task_desc(task_desc_str)

        task = SingleOpTask(single_op_params.graph_id,
                            single_op_params.task_id,
                            single_op_params.op_module,
                            single_op_params.op_type,
                            single_op_params.op_func,
                            single_op_params.kernel_name,
                            inputs=single_op_params.inputs,
                            outputs=single_op_params.outputs,
                            attrs=single_op_params.attrs,
                            unknown_shape=single_op_params.unknown_shape,
                            int64_mode=single_op_params.int64_mode,
                            options=single_op_params.options,
                            pre_task=single_op_params.pre_task_json,
                            post_task=single_op_params.post_task_json,
                            is_dynamic_impl=single_op_params.is_dynamic_impl,
                            op_pattern=single_op_params.op_pattern,
                            fuzz_build_info=None,
                            reset_op_info=None,
                            context_param=single_op_params.context_param,
                            pass_opt_list=single_op_params.pass_opt_list,
                            tune_param=None,
                            master_pid=OpCompiler.master_pid,
                            op_name=single_op_params.op_name,
                            extra_params=single_op_params.extra_params,
                            relation_param=single_op_params.relation_param,
                            op_impl_switch=single_op_params.op_impl_switch,
                            op_impl_mode=single_op_params.op_impl_mode,
                            optional_input_mode=single_op_params.optional_input_mode,
                            dynamic_param_mode=single_op_params.dynamic_param_mode,
                            binary_compile_mode=True)

        task.set_l1size(single_op_params.l1_size)
        OpCompiler.compiler.dispatch_task(task)
        CompilerEnv.task_counter_modify(1)


def dispatch_fusion_op_compile_task(graph_id, task_id, l1size,
                                    json_str, kernel_name, pre_task, post_task, first_options,
                                    context_param, pass_opt_list, op_name, reused_relation,
                                    fixpipe_ub_cfg, optional_input_mode, dynamic_param_mode):# 'pylint: disable=too-many-locals
    """
    fusion op build task
    :param graph_id:
    :param task_id:
    :param json_str:
    :param kernel_name:
    """
    with CompilerEnv.env_guard():
        if OpCompiler.compiler is None:
            return
        if not OpCompiler.is_sub_proc_ok():
            raise Exception("Sub compiler processes not ok")
        if pre_task is not None:
            pre_task = json.loads(pre_task)
        if post_task is not None:
            post_task = json.loads(post_task)

        task = FusionOpTask(graph_id, task_id, json_str, kernel_name,
                            pre_task=pre_task, post_task=post_task, options=first_options,
                            reset_op_info=OpCompiler.compiler.get_reset_op_info(),
                            context_param=context_param,
                            pass_opt_list=pass_opt_list,
                            master_pid=OpCompiler.master_pid,
                            op_name=op_name,
                            reused_relation=reused_relation,
                            fixpipe_ub_cfg=fixpipe_ub_cfg,
                            optional_input_mode=optional_input_mode,
                            dynamic_param_mode=dynamic_param_mode)

        task.set_l1size(l1size)
        OpCompiler.compiler.dispatch_task(task)
        CompilerEnv.task_counter_modify(1)


def dispatch_task_fusion_task(graph_id, task_id, l1size, json_str, first_options):
    """
    fusion op build task
    :param graph_id:
    :param task_id:
    :param json_str:
    :param task_info_str:
    """
    with CompilerEnv.env_guard():
        if OpCompiler.compiler is None:
            return
        if not OpCompiler.is_sub_proc_ok():
            raise Exception("Sub compiler processes not ok")

        task = TaskFusionTask(graph_id, task_id, json_str, options=first_options)

        task.set_l1size(l1size)
        OpCompiler.compiler.dispatch_task(task)
        CompilerEnv.task_counter_modify(1)


def dispatch_super_kernel_task(graph_id, task_id, l1size, json_str, first_options):
    """
    fusion op build task
    :param graph_id:
    :param task_id:
    :param json_str:
    :param task_info_str:
    """
    with CompilerEnv.env_guard():
        if OpCompiler.compiler is None:
            return
        if not OpCompiler.is_sub_proc_ok():
            raise Exception("Sub compiler processes not ok")

        task = SuperKernelTask(graph_id, task_id, json_str, options=first_options)

        task.set_l1size(l1size)
        OpCompiler.compiler.dispatch_task(task)
        CompilerEnv.task_counter_modify(1)


def dispatch_binary_fusion_op_compile_task(task_desc_str):
    with CompilerEnv.env_guard():
        if OpCompiler.compiler is None:
            return

        if not OpCompiler.is_sub_proc_ok():
            raise Exception("Sub compiler processes not ok")

        fusion_op_params = get_params_from_graph_desc(task_desc_str)

        task = FusionOpTask(fusion_op_params.graph_id,
                            fusion_op_params.task_id,
                            fusion_op_params.json_str,
                            fusion_op_params.kernel_name,
                            pre_task=fusion_op_params.pre_task_json,
                            post_task=fusion_op_params.post_task_json,
                            options=fusion_op_params.options,
                            reset_op_info=None,
                            context_param=fusion_op_params.context_param,
                            pass_opt_list=fusion_op_params.pass_opt_list,
                            master_pid=OpCompiler.master_pid,
                            op_name=fusion_op_params.op_name,
                            reused_relation=fusion_op_params.reused_relation,
                            fixpipe_ub_cfg=fusion_op_params.fixpipe_ub_cfg,
                            optional_input_mode=fusion_op_params.optional_input_mode,
                            dynamic_param_mode=fusion_op_params.dynamic_param_mode,
                            binary_compile_mode=True)

        task.set_l1size(fusion_op_params.l1_size)
        OpCompiler.compiler.dispatch_task(task)
        CompilerEnv.task_counter_modify(1)


def sync_op_tune_params(module_name, func_name, has_params=False, func_params=None):
    """
    sync op tune params to worker process
    :param module_name:
    :param func_name:
    :param has_params:
    :param func_params:
    """
    if OpCompiler.master_pid == 0:
        return
    if not has_params:
        func_params = None
    task = OpTuneSyncTask(module_name, func_name, func_params)

    if OpCompiler.master_pid == os.getpid():
        OpCompiler.compiler.sync_data(task)
    else:
        # This is autotune sub process
        pid = os.getpid()
        OpCompiler.task_dispatcher.sync_data(task, pidfrom=pid)


def sync_syspath(syspath):
    """
    sync syspath to worker process
    :param syspath: the path needed to add to sys.path of worker process
    """
    if OpCompiler.compiler is None:
        return
    task = PySysPathTask(syspath)
    OpCompiler.compiler.sync_data(task)


def import_py_module(module_list):
    """
    import py module task
    :param module_list:
    """
    if OpCompiler.compiler is None:
        return
    task = PyImportTask(module_list)
    OpCompiler.compiler.sync_data(task)


def compile_op_sync(json_str: str, op_env_cfg: Optional[dict] = None) -> dict:
    """
    compile op synchronously
    """
    defer = compile_op(json_str, op_env_cfg)
    while True:
        time.sleep(0.01)
        res = defer.get()
        if res is not None:
            return res


def build_single_const_op(json_str):
    opdesc = json.loads(json_str)
    op_name = opdesc["op_name"]
    op_type = opdesc["op_type"]
    kernel_name = opdesc["kernel_name"]
    inputs = opdesc["inputs"]
    outputs = opdesc["outputs"]
    attrs = opdesc["attrs"]
    attrs.append(kernel_name)
    options = opdesc["options"]
    thread_id = opdesc["thread_id"]
    task_id = opdesc["task_id"]

    if op_name == "" or op_type == "":
        return

    dispatch_single_op_compile_task(
        thread_id,
        task_id,
        -1,
        f"impl.dynamic.{op_name!s}",
        op_name,
        op_type,
        op_name,
        kernel_name,
        False,
        [inputs, outputs, attrs, options],
        is_dynamic_impl=True,
        pass_opt_list="",
    )


def get_single_compile_op_result(json_str):
    from te_fusion.parallel_compilation import get_finished_compilation_task
    opdesc = json.loads(json_str)
    thread_id = opdesc["thread_id"]
    res = get_finished_compilation_task(thread_id)
    if res:
        return remove_kernel_elf(res)
    return ""


def remove_kernel_elf(compile_res):
    import subprocess
    import numpy
    compile_info = compile_res[0]["op_res"]
    compile_info = json.loads(compile_info)
    json_file_path = compile_info["json_file_path"]
    kernel_file_path = json_file_path.replace(".json", ".o")
    asm_file_path = json_file_path.replace(".json", ".data")

    cmd = [f"readelf -S {kernel_file_path!s} | grep .text"]
    proc = subprocess.run(cmd, capture_output=True, text=True, shell=True)
    text_str = str(proc.stdout).strip()
    offset_str = text_str.split(" ")[-1]
    offset_val = int(offset_str, 16)

    ori_data = numpy.fromfile(kernel_file_path, numpy.int8)
    no_elf_data = ori_data[offset_val:]

    no_elf_data.tofile(asm_file_path)
    return asm_file_path


def dispatch_autotune_task(graph_id, task_id, l1size, json_str, data_dict, kernel_name, op_name):
    """
    dispatch autotune task need remove
    """
    pass