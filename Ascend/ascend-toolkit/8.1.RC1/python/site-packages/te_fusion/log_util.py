#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
Log utils for ops fusion
"""
import sys
import traceback
import inspect
import os
from enum import Enum, unique

FILE_PATH = os.path.dirname(os.path.realpath(__file__))


def modify_except_msg(evalue):
    """
    modify except msg 'No space left on device' to 'No space left on disk'
    """
    if evalue and hasattr(evalue, 'strerror') and \
       evalue.strerror == 'No space left on device':
        evalue.strerror = 'No space left on disk'


def get_py_exception_list(etype, value, tback):
    """
    return python exception list, calling from C for error log uploading
    """
    _ = traceback.format_exception(etype, value, tback)
    err_msg = value.args
    err_list = []
    if err_msg and isinstance(err_msg, tuple):
        if isinstance(err_msg[0], tuple):
            for cur_err_msg in err_msg[0]:
                if isinstance(cur_err_msg, dict):
                    err_dict = dict()
                    for dict_key, dict_value in cur_err_msg.items():
                        err_dict[dict_key] = str(dict_value)
                    err_list.append(err_dict)
        elif isinstance(err_msg[0], dict):
            err_list.append(err_msg[0])
        return err_list
    return []


def get_py_exception_str(etype, value, tback, eprint=False):
    """
    return python exception string, calling from C for error log printing
    """
    modify_except_msg(value)
    exc_list = traceback.format_exception(etype, value, tback)
    msg = "".join(exc_list)
    if msg.find('#Conv2DBackpropInput only support#') != -1:
        msg = "".join(value.args)

    if eprint:
        traceback.print_exception(etype, value, tback)

    return msg


def except_msg():
    """
    Return exception msg.
    """
    etype, evalue, tback = sys.exc_info()
    err_list = get_py_exception_list(etype, evalue, tback)
    if len(err_list) > 1:
        err_msg = ""
    else:
        err_msg = get_py_exception_str(etype, evalue, tback)
    return err_msg, err_list


def tefusion_log_full(log_level, log_msg, *log_paras):
    """
    print full log
    """
    import tbe.common.utils.log as logger
    line_no = inspect.currentframe().f_back.f_lineno
    funcname = inspect.currentframe().f_back.f_code.co_name
    co_filename = inspect.currentframe().f_back.f_code.co_filename
    filename = os.path.relpath(co_filename, FILE_PATH)
    log_header = '[%s:%d][%s] ' % (filename, line_no, funcname)
    log_str = log_header + log_msg % log_paras
    slice_len = 800
    log_str_list = [log_str[i:i+slice_len] for i in range(0, len(log_str), slice_len)]
    for log in log_str_list:
        if log_level == LogLevel.DEBUG:
            logger.debug('%s', log)
        elif log_level == LogLevel.INFO:
            logger.info('%s', log)
        elif log_level == LogLevel.WARN:
            logger.warn('%s', log)
        elif log_level == LogLevel.ERROR:
            logger.error('%s', log)


@unique
class LogLevel(Enum):
    DEBUG = 1
    INFO = 2
    WARN = 3
    ERROR = 4