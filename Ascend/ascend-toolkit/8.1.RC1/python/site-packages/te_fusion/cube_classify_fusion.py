#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright 2019-2021 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================

from tbe.dsl.unify_schedule.constants import Pattern
from tbe.common.register import register_api


class _op():
    def __init__(self):
        self.value = []
        self.idx = []


class CubeClassifyFusion():
    def __init__(self, op_list, pattern, mode="cube"):
        self.op_list = op_list
        self.pattern = pattern
        self.mode = mode
        self.ins_list = None
        self.ins_with_attr_list = None
        self.op_classify = None
        self.placeholder_op = _op()
        self.init()

    def get_attrs_and_options(self):
        attrs = []
        options = []
        if self.op_list is None:
            return attrs, options
        for op_node in self.op_list:
            if op_node["type"] == "conv2d_data_rm" or op_node["type"] == "Data":
                continue
            attr_dict = {}
            attr_val = []
            if "attr_desc" in op_node:
                for attr_desc in op_node["attr_desc"]:
                    attr_val.append(attr_desc)
            if attr_val is []:
                continue
            attr_dict["val"] = attr_val
            attr_dict["name"] = op_node.get("name")
            attrs.append(attr_dict)
            option = {}
            option["name"] = op_node.get("name")
            option["options"] = op_node.get("options")
            if option.get("options") is None:
                continue
            options.append(option)
        return attrs, options

    def get_type(self):
        return self.op_classify.get_type()

    def init(self):
        cube_input_name_vec = []
        for key, node in enumerate(self.op_list):
            if node.get("pattern") in [Pattern.CONV2D, Pattern.CONV2D_BACKPROP_INPUT, Pattern.CONV2D_BACKPROP_FILTER, \
                                       Pattern.MAT_MUL, Pattern.BATCH_MATMUL, Pattern.CONV3D, \
                                       Pattern.CONV3D_BACKPROP_INPUT, Pattern.CONV3D_BACKPROP_FILTER,
                                       Pattern.QUANT_CONV2D]:
                for input_desc in node["input_desc"]:
                    cube_input_name_vec.append(input_desc["name"])

        input_desc_vec = []
        for key, node in enumerate(self.op_list):
            if node.get("type") == "Data":
                self.placeholder_op.value.append(node)
                self.placeholder_op.idx.append(key)
                output_desc = node.get("output_desc")[0]
                if output_desc["name"] in cube_input_name_vec:
                    output_desc["input_pattern"] = self.mode
                input_desc_vec.append(output_desc)

        self.op_classify = register_api.get_classify_processor(self.pattern)
        if self.op_classify is None:
            self.ins_list = [input_desc_vec]
        else:
            cls_func = self.op_classify.get_func()
            if self.get_type() == "all":
                attrs = []
                options = []
                attrs, options = self.get_attrs_and_options()
                self.ins_with_attr_list = cls_func((input_desc_vec, attrs, options), self.pattern)
            else:
                self.ins_with_attr_list = cls_func(input_desc_vec)


