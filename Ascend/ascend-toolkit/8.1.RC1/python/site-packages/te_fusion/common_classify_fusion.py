#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright 2019-2021 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================

from tbe.dsl import classify
from tbe.common.register import register_api


class _op():
    def __init__(self):
        self.idx = []
        self.value = []


class CommonClassifyFusion():
    def __init__(self, op_list, pattern, mode):
        self.ins_with_attr_list = None
        self.null_shape_dict = None
        self.op_classify = None
        self.ins_list = None
        self.op_list = op_list
        self.pattern = pattern

        self.mode = mode
        self.placeholder_op = _op()
        self.init()


    @staticmethod
    def _handle_input_range(inputs):
        for input in inputs:
            shape_range = input.get("range")
            if shape_range is None:
                return
            for range in shape_range:
                if len(range) == 2:
                    if range[1] == -1:
                        range[1] = None


    def get_attrs_and_options(self):
        attrs = []
        options = []
        for op_node in self.placeholder_op.value:
            if op_node["type"] == "conv2d_data_rm":
                continue
            attr_dict = {}
            attr_val = []
            attr_dict["name"] = op_node.get("name")
            if "attr_desc" in op_node:
                for attr_desc in op_node["attr_desc"]:
                    attr_val.append(attr_desc)
            attr_dict["val"] = attr_val
            option = {}
            option["name"] = op_node.get("name")
            option["options"] = op_node.get("options")
            attrs.append(attr_dict)
            options.append(option)
        return attrs, options


    def get_type(self):
        return self.op_classify.get_type()


    def init(self):
        for key, node in enumerate(self.op_list):
            if node.get("type") == "Data":
                self.placeholder_op.value.append(node)
                self.placeholder_op.idx.append(key)

        # define dynamic inputs
        inputs_desc = [x.get("output_desc")[0] for x in self.placeholder_op.value]
        CommonClassifyFusion._handle_input_range(inputs_desc)
        self.op_classify = register_api.get_classify_processor(self.mode)
        if self.mode == "cube":
            self.ins_list = [inputs_desc]
        else:
            if self.op_classify is None:
                inputs_desc_list, self.null_shape_dict = del_input_desc_shape_null(inputs_desc)
                self.ins_list = classify(inputs_desc_list, self.mode)
            else:
                cls_func = self.op_classify.get_func()
                if self.get_type() == "all":
                    attrs = []
                    options = []
                    attrs, options = self.get_attrs_and_options()
                    self.ins_with_attr_list = cls_func((inputs_desc, attrs, options), self.mode)
                else:
                    self.ins_with_attr_list = cls_func(inputs_desc)


def del_input_desc_shape_null(inputs_desc):
    # DSL can not recognize null input, so need to delete the null input before calling function.
    count = 0
    null_shape_dict = {}
    for inpt in inputs_desc:
        if not isinstance(inpt, dict):
            count += 1
            continue
        for key in list(inpt.keys()):
            if key == "shape" and inpt[key] == "NULL":
                null_shape_dict[count] = inpt
        count += 1

    for i in null_shape_dict.values():
        inputs_desc.remove(i)

    return inputs_desc, null_shape_dict