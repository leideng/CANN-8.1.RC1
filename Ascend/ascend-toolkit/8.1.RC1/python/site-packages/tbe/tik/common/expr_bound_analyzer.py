#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     expr_bound_analyzer.py
DESC:     for var analyzer function
CREATED:  2020-01-10 19:02:50
MODIFIED: 2020-01-10 19:02:50
"""
from tbe import tvm
from tbe.common.platform import scope_gm

from tbe.tik.api.tik_check_api import is_tik_var
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.common.util import reduce_mul
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_expr import Expr

# memory stamp flag between dst gm
STAMP = 1
NO_STAMP = 0
POSSIBLY_STAMP = -1


def set_var_value_range(analyzer, var, cur_range):
    """
    set var value range to analyzer
    Parameters
    ----------
    analyzer: analyzer obj
    var: for var
    cur_range: for var value range

    Returns for_begin_end_has_expr
    -------

    """
    for idx, elem in enumerate(cur_range):
        elem = Expr(elem).eval_value()
        if not isinstance(elem, int):
            return True
        cur_range[idx] = elem

    analyzer.update(var, tvm.arith.ConstIntBound(*cur_range))
    return False


def analyzer_for_var(for_var, for_var_list, analyzer, for_begin_end):
    """
    analyzer cur expr all for var
    for_name struct like [[i, j], k] corresponds to the for_begin_end struct like [[[0, 2], [0, 3]], [0, 1]]

    Parameters
    ----------
    for_var: cur expr contains for var list
    for_var_list: for var list
    analyzer: analyzer obj
    for_begin_end: for_begin_end list

    Returns for_begin_end_has_expr
    -------

    """
    for_begin_end_has_expr = False
    for cur_expr_var in for_var:
        for index, for_loop_var in enumerate(for_var_list):
            # when for range thread_num > 1, for_loop_var is list
            if isinstance(for_loop_var, list) and cur_expr_var in for_loop_var:
                index_j = for_loop_var.index(cur_expr_var)
                for_begin_end_has_expr = set_var_value_range(
                    analyzer, cur_expr_var, for_begin_end[index][index_j])
                break
            elif for_loop_var == cur_expr_var:
                for_begin_end_has_expr = set_var_value_range(
                    analyzer, cur_expr_var, for_begin_end[index])
                break
        if for_begin_end_has_expr:
            return True
    return False


def compute_expr_val(expr, for_var, for_begin_end, for_var_list, input_scalar_set):
    """
    compute expr val with analyzer, passing var arguments calculate expr max value
    Parameters
    ----------
    input_scalar_set: tik instance's input scalar set
    for_var_list: for loop var list
    expr: src expr
    for_var: expr contains for var list
    for_begin_end: for begin end list

    Returns compute res
    -------

    """
    ret_value = expr
    if not isinstance(expr, int):
        analyzer = tvm.arith.Analyzer()
        for_var.clear()
        exist_expr = 1
        has_expr = []

        def collecting_for_var_expr(tree):
            # check expr contains input scalar and scalar
            if tree in input_scalar_set or type(tree) == tvm.tir.Load:
                has_expr.append(exist_expr)
            elif type(tree) == tvm.tir.Var:
                for_var.add(tree)

        tvm.tir.stmt_functor.post_order_visit(expr, collecting_for_var_expr)

        if len(has_expr) == 0 and len(for_var) > 0:
            for_begin_end_has_expr = analyzer_for_var(
                for_var, for_var_list, analyzer, for_begin_end)
            # when expr contains for var and the for_begin_end list does not contain the expr elem,
            # calculator the expr max value
            if not for_begin_end_has_expr:
                ret = analyzer.const_int_bound(expr)
                ret_value = ret.max_value
    return ret_value


def check_dst_gm_overflow(dm_api_ins, offset_extent_diff_shape_value, offset_diff_shape_value):
    """

    Parameters
    ----------
    offset_diff_shape_value
    offset_extent_diff_shape_value
    dm_api_ins: DataMoveApi instance

    Returns
    -------

    """
    if not isinstance(offset_extent_diff_shape_value, int):
        offset_extent_diff_shape_value = tvm.tir.Simplify(offset_extent_diff_shape_value)
    if not isinstance(offset_diff_shape_value, int):
        offset_diff_shape_value = tvm.tir.Simplify(offset_diff_shape_value)
    offset_extent_diff_shape_max_value = compute_expr_val(offset_extent_diff_shape_value, dm_api_ins.for_var,
                                                          dm_api_ins.tik_instance.for_begin_end,
                                                          dm_api_ins.tik_instance.for_var_list,
                                                          dm_api_ins.tik_instance.input_scalar_set)
    offset_diff_shape_max_value = compute_expr_val(offset_diff_shape_value, dm_api_ins.for_var,
                                                   dm_api_ins.tik_instance.for_begin_end,
                                                   dm_api_ins.tik_instance.for_var_list,
                                                   dm_api_ins.tik_instance.input_scalar_set)
    offset_extent_diff_shape_max_value = Expr(offset_extent_diff_shape_max_value).eval_value()
    offset_diff_shape_max_value = Expr(offset_diff_shape_max_value).eval_value()

    if isinstance(offset_diff_shape_max_value, int) and offset_diff_shape_max_value > 0:
        dm_api_ins.tik_instance.mem_stamp.append((dm_api_ins.dst.original_name, STAMP))
    elif isinstance(offset_extent_diff_shape_max_value, int):
        if offset_extent_diff_shape_max_value > 0:
            dm_api_ins.tik_instance.mem_stamp.append((dm_api_ins.dst.original_name, STAMP))
    else:
        dm_api_ins.tik_instance.mem_stamp.append((dm_api_ins.dst.original_name, POSSIBLY_STAMP))


def analysis_args_check_overflow(dm_api_ins):
    """
    analysis src to dst gm args is overflow and collecting overflow info
    Returns None
    -------

    """
    if dm_api_ins.dst.scope == scope_gm and isinstance(dm_api_ins.dst, Tensor):
        dst_shape = reduce_mul(dm_api_ins.dst.original_shape)
        origin_args = [
            dm_api_ins.dst.offset, dst_shape, dm_api_ins.burst,
            dm_api_ins.nburst, dm_api_ins.dst_stride
        ]
        input_check_args = []
        for arg in origin_args:
            if is_tik_var(arg):
                arg = arg.get()
            input_check_args.append(arg)
        offset, flatten_shape, burst, nburst, stride = input_check_args
        one_blk_ele_num = ONE_BLK_SIZE // DTYPE_SIZE[dm_api_ins.dst.dtype]
        extent = ((burst + stride) * (nburst - 1) + burst)
        extent_ele_num = extent * one_blk_ele_num
        offset_extent_diff_shape_value = offset + extent_ele_num - flatten_shape
        offset_diff_shape_value = offset - flatten_shape
        check_dst_gm_overflow(dm_api_ins, offset_extent_diff_shape_value, offset_diff_shape_value)
