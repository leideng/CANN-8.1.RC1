#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vec_util.py
DESC:     provide vec instructions api for codegen and debug
CREATED:  2021-04-25 18:53:42
MODIFIED: 2021-04-25 19:17:00
"""

from collections import namedtuple
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import reduce_mul
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.common_util import is_tensor
from tbe.tik.common.common_util import vector_tensor_overflow_check
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_params import ONE_REP_BYTE_SIZE
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_params import BLK_NUM_PER_REP
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil


def _cal_dst_extent_vreduce(mask, mask_mode, repeat_times, dtype, is_910b=False):
    """
    calculate dst extent in instruction vreduce

    Parameters
    ----------
    mask_mode: "normal" - mask normal mode; "counter" - mask counter mode
    repeat_times : Repeated iterations times
    dtype : destination operator dtype

    Returns
    -------
    dst_extent
    """
    if mask_mode == "normal":
        dst_extent = repeat_times * ONE_REP_BYTE_SIZE
    else:
        if is_910b:
            dst_extent = repeat_times * mask * DTYPE_SIZE[dtype]
        else:
            dst_extent = mask * DTYPE_SIZE[dtype]
    dst_extent = Expr(dst_extent).get()
    return dst_extent


def _check_vreduce_tensor_overflow(tensor_need_size, tensor_ava_size, tensor_name):
    """
    check vreduce src1_pattern overflow

    Parameters
    ----------
    tensor_need_size : tensor need elements
    tensor_ava_size : tensor available elements
    tensor_name: parameter's name

    Returns
    -------
    None
    """
    expected_ele = Expr(tensor_need_size).eval_value()
    actual_ele = Expr(tensor_ava_size).eval_value()
    if expected_ele is not None and actual_ele is not None:
        TikCheckUtil.check_ge(
            actual_ele, expected_ele,
            "%s tensor overflow, expected elements nums: %s, "
            "actual elements nums: %s" % (tensor_name, expected_ele, actual_ele))


def _check_vreduce_src1_overflow(mask, mask_mode, src1_pattern, input_params):
    """
    check vreduce src1_pattern overflow

    Parameters
    ----------
    mask :
    mask_mode : normal/counter
    src1_pattern : src1 tensor
    input_params: others operator parameters

    Returns
    -------
    None
    """
    src1_rep_stride, repeat_times, src1_original_shape, src1_offset = input_params

    if Expr(src1_rep_stride).eval_value() is None:
        return

    src1_actual_ele = reduce_mul(src1_original_shape)
    if mask_mode == "normal":
        if src1_rep_stride == 0:
            src1_expected_ele = ONE_REP_BYTE_SIZE // DTYPE_SIZE[src1_pattern.dtype] // \
                                get_bit_len(src1_pattern.dtype) + src1_offset
        else:
            src1_expected_ele = repeat_times * ONE_REP_BYTE_SIZE // DTYPE_SIZE[src1_pattern.dtype] // \
                                get_bit_len(src1_pattern.dtype) + src1_offset
    else:
        if Expr(mask).eval_value() is None:
            return
        if src1_rep_stride == 0:
            src1_expected_ele = min(
                ceil_div(mask, get_bit_len(src1_pattern.dtype)),
                ONE_REP_BYTE_SIZE // DTYPE_SIZE[src1_pattern.dtype] //
                get_bit_len(src1_pattern.dtype)) + src1_offset
        else:
            src1_expected_ele = ceil_div(mask, get_bit_len(src1_pattern.dtype)) + src1_offset

    src1_expected_ele = Expr(src1_expected_ele).eval_value()
    src1_actual_ele = Expr(src1_actual_ele).eval_value()
    if src1_expected_ele is not None and src1_actual_ele is not None:
        TikCheckUtil.check_ge(
            src1_actual_ele, src1_expected_ele,
            "src1_pattern tensor overflow, expected shape: %s, actual "
            "shape: %s" % (src1_expected_ele, src1_actual_ele))


def check_vreduce_overflow(input_params, dst_extent):
    """
    for check vreduce, vreducev2 tensor overflow
    """
    params_cls = namedtuple(
        "ParamsCls", "mask dst src0 src1_pattern repeat_times src0_blk_stride src0_rep_stride"
                     " src1_rep_stride stride_unit mask_mode dst_original_shape dst_offset"
                     " src0_original_shape src0_offset src1_original_shape src1_offset is_910b")
    params = params_cls(*input_params)
    mask = params.mask
    ori_offset = 0
    if params.mask_mode == "normal":
        mask = ONE_REP_BYTE_SIZE // DTYPE_SIZE[params.src0.dtype]
    vector_tensor_overflow_check((params.src0, mask, BLK_NUM_PER_REP, ONE_BLK_SIZE // DTYPE_SIZE[params.src0.dtype],
                                  params.repeat_times,
                                  params.src0_blk_stride, params.src0_rep_stride, "src0 tensor overflow",
                                  params.stride_unit, params.mask_mode, ori_offset, params.src0_offset,
                                  params.src0_original_shape, params.is_910b))

    if is_tensor(params.src1_pattern):
        if not params.is_910b:
            _check_vreduce_src1_overflow(mask, params.mask_mode, params.src1_pattern,
                                         [params.src1_rep_stride, params.repeat_times,
                                          params.src1_original_shape, params.src1_offset])
        else:
            one_rep_eles = ONE_REP_BYTE_SIZE // DTYPE_SIZE[params.src0.dtype]
            if params.mask_mode == "counter":
                one_rep_eles = mask
            one_rep_src1_eles = ceil_div(one_rep_eles, get_bit_len(params.src1_pattern.dtype))
            src1_needed_eles = ((params.repeat_times - 1) * params.src1_rep_stride * ONE_BLK_SIZE +
                                one_rep_src1_eles * DTYPE_SIZE[params.src1_pattern.dtype]) // \
                               DTYPE_SIZE[params.src1_pattern.dtype]
            _check_vreduce_tensor_overflow(src1_needed_eles,
                                           reduce_mul(params.src1_original_shape) -
                                           params.src1_offset, "src1_pattern")
    else:
        if Expr(params.src1_pattern).eval_value() is not None:
            _check_vreduce_tensor_overflow(dst_extent // DTYPE_SIZE[params.dst.dtype],
                                           reduce_mul(params.dst_original_shape) -
                                           params.dst_offset, "dst")


def _cal_src1_extent_vreduce(mask, mask_mode, params_list, src1_offset, is_910b=False):
    """
    calculate src1 extent in instruction vreduce

    Parameters
    ----------
    or user defined tensor(dtype unsigned int),
    per bit 1/0 for effective operation on element
    mask: Effective operation on element
    mask_mode: "normal" - mask normal mode; counter" - mask counter mode

    Returns
    -------
    src1_extent
    """
    src1_pattern, repeat_times, rep_stride, src1_original_shape = params_list
    src1_extent = 0
    if is_tensor(src1_pattern):
        dtype = src1_pattern.dtype
        rep_stride_value = Expr(rep_stride).eval_value()
        if rep_stride_value is None:
            src1_extent = (reduce_mul(src1_original_shape) - src1_offset) * DTYPE_SIZE[dtype]
        elif rep_stride_value == 0:
            if is_910b and mask_mode == "counter":
                src1_extent = ceil_div(mask, get_bit_len(dtype)) * DTYPE_SIZE[dtype]
            else:
                src1_extent = ceil_div(ONE_REP_BYTE_SIZE // DTYPE_SIZE[dtype],
                                       get_bit_len(dtype)) * DTYPE_SIZE[dtype]
        else:
            if is_910b:
                if mask_mode == "normal":
                    src1_extent = (repeat_times - 1) * rep_stride_value * ONE_BLK_SIZE + \
                                  ceil_div(ONE_REP_BYTE_SIZE // DTYPE_SIZE[dtype],
                                           get_bit_len(dtype)) * DTYPE_SIZE[dtype]
                else:
                    # one repeat element nums is mask value
                    src1_extent = (repeat_times - 1) * rep_stride_value * ONE_BLK_SIZE + \
                                  ceil_div(mask, get_bit_len(dtype)) * DTYPE_SIZE[dtype]
            else:
                if mask_mode == "normal":
                    src1_extent = ceil_div(repeat_times * ONE_REP_BYTE_SIZE // DTYPE_SIZE[dtype],
                                           get_bit_len(dtype)) * DTYPE_SIZE[dtype]
                else:
                    src1_extent = ceil_div(mask, get_bit_len(dtype)) * DTYPE_SIZE[dtype]
    src1_extent = Expr(src1_extent).get()
    return src1_extent


def _cal_src0_extent_vreducev2(mask_list, repeat_times, rep_stride, blk_stride, dtype):
    """
    calculate src0 extent, based on mask and mask mode, only for vreducev2

    Parameters
    ----------
    repeat_times: Repeated iterations times
    blk_stride: offset of dst/src operator between different block in one
                iteration
    rep_stride: offset of dst/src operator in the same block between adjacent
                iterations
    dtype: tensor dtype

    Returns
    -------
    extent
    """
    mask, mask_mode = mask_list
    one_repeat_blocks = BLK_NUM_PER_REP
    if mask_mode == 'counter':
        # one repeat element nums is mask value
        one_repeat_ele_nums = mask * DTYPE_SIZE[dtype]
        one_repeat_blocks = ceil_div(one_repeat_ele_nums, ONE_BLK_SIZE)

    extent = ((repeat_times - 1) * rep_stride + (one_repeat_blocks - 1) * blk_stride + 1) * ONE_BLK_SIZE
    return Expr(extent).get()


def cal_extent_stride_unit_mask(params_set):
    """
    calculate extent, based on mask, stride_unit

    Parameters
    ----------
    params_set: contains
    -mask: Effective operation on element
    -repeat_times: Repeated iterations times
    -tensor: dst/src tensor
    -stride_unit: address and offset unit both affect it. default = 0
    -blk_stride: offset of dst/src operator between different block in one iteration
    -rep_stride: offset of dst/src operator in the same block between adjacent iterations
    -mask_mode: "normal" - mask normal mode "counter" - mask counter mode

    Returns
    -------
    extent
    """
    if params_set.mask_mode == 'counter':
        repeat = ceil_div(params_set.mask, ONE_REP_BYTE_SIZE // DTYPE_SIZE[params_set.src0.dtype])
    else:  # normal
        repeat = params_set.repeat_times
    # blk_stride: stride, rep_stride: stride, unit: 32B
    if params_set.stride_unit == 0:
        extent = ((repeat - 1) * params_set.src0_rep_stride + (BLK_NUM_PER_REP - 1) * params_set.src0_blk_stride +
                  1) * ONE_BLK_SIZE
    # blk_stride: stride, rep_stride: gap, unit: 32B
    elif params_set.stride_unit == 1:
        extent = ((repeat - 1) * params_set.src0_rep_stride +
                  repeat * ((BLK_NUM_PER_REP - 1) * params_set.src0_blk_stride + 1)) * ONE_BLK_SIZE
    # blk_stride: gap, rep_stride: stride, unit: elements
    elif params_set.stride_unit == 2:
        extent = ((repeat - 1) * params_set.src0_rep_stride + (BLK_NUM_PER_REP - 1) * params_set.src0_blk_stride +
                  ONE_REP_BYTE_SIZE // DTYPE_SIZE[params_set.src0.dtype]) * \
                 DTYPE_SIZE[params_set.src0.dtype]
    # blk_stride: gap, rep_stride: gap, unit: elements
    else:
        extent = ((repeat - 1) * params_set.src0_rep_stride + repeat * (
                ONE_REP_BYTE_SIZE // DTYPE_SIZE[params_set.src0.dtype] +
                (BLK_NUM_PER_REP - 1) * params_set.src0_blk_stride)) * DTYPE_SIZE[params_set.src0.dtype]
    return Expr(extent).get()


def get_extents(get_extents_list, is_910b=False):
    """
    for calculate dst/src0/src1's extent for vreduce/vreducev2
    """

    if is_910b:
        src0_extent = _cal_src0_extent_vreducev2((get_extents_list.mask, get_extents_list.mask_mode),
                                                 get_extents_list.repeat_times, get_extents_list.src0_rep_stride,
                                                 get_extents_list.src0_blk_stride, get_extents_list.src0.dtype)
    else:
        src0_extent = cal_extent_stride_unit_mask(get_extents_list)

    dst_extent = _cal_dst_extent_vreduce(get_extents_list.mask, get_extents_list.mask_mode,
                                         get_extents_list.repeat_times, get_extents_list.dst.dtype, is_910b)
    if not is_tensor(get_extents_list.src1_pattern):
        src1_pattern_value = Expr(get_extents_list.src1_pattern).eval_value()
        if src1_pattern_value is not None:
            if 0 < get_extents_list.src1_pattern < 3:
                dst_extent = dst_extent // 2
            elif 2 < get_extents_list.src1_pattern < 7:
                dst_extent = dst_extent // 4

    src1_extent = _cal_src1_extent_vreduce(get_extents_list.mask, get_extents_list.mask_mode,
                                           (get_extents_list.src1_pattern, get_extents_list.repeat_times,
                                            get_extents_list.src1_rep_stride, get_extents_list.src1_original_shape),
                                           get_extents_list.src1_offset, is_910b)
    return dst_extent, src0_extent, src1_extent
