#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     overflow_util.py
DESC:     provide common function
CREATED:  2021-12-13 11:33:42
MODIFIED: 2021-12-13 11:33:42
"""
from tbe.tik.common.util import get_mask_len
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import reduce_mul
from tbe.tik.common.tik_get_soc_name import get_compatible_blk_size
from tbe.tik.tik_lib.tik_params import MASK_VALUE_ZERO
from tbe.tik.tik_lib.tik_params import VA0_INDEX
from tbe.tik.tik_lib.tik_params import BLK_NUM_PER_REP
from tbe.tik.tik_lib.tik_params import MASK_HIGH_IDX
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_expr import Expr


def check_tensor_list_overflow(tensor_list, name, params_list, store_high_half=False, mask_mode="normal"):
    """
    check scatter vector instruction, input tensor_list tensor overflow
    for api module and debug module

    Parameters
    ----------
    tensor_list : input parameters, dst_list or src_list, length = 8
    name : name of tensor_list, for printing check RuntimeError message
    params_list : mask, repeat_times, rep_stride, valid_num_per_block
    store_high_half : store_high_half
    mask_mode : mask mode, normal or counter

    Returns
    -------
    None
    """
    mask, repeat_times, rep_stride, valid_num_per_block = params_list
    if mask_mode == "counter":
        if Expr(mask).eval_value() is None:
            return
        rep_len = valid_num_per_block*BLK_NUM_PER_REP
        repeat_times = ceil_div(mask, rep_len)
        mask = mask % rep_len
        if mask == 0:
            mask = rep_len

    repeat_times = Expr(repeat_times).eval_value()
    if repeat_times is None:
        return

    if not isinstance(mask, (list, tuple)):
        mask = [mask]
    for value in mask:
        if Expr(value).eval_value() is None:
            return
    if len(mask) == 1:
        mask_len = mask[MASK_HIGH_IDX]
    else:
        mask_len = get_mask_len(mask)
    TikCheckUtil.check_ge(
        len(tensor_list)*valid_num_per_block, mask_len,
        "Please check number of %s for current mask." % name)

    tensor_list_overflow_check(tensor_list, name, (mask_len, repeat_times, rep_stride), valid_num_per_block,
                               store_high_half=store_high_half)


def tensor_list_overflow_check(tensor_list, name, params_list, valid_num_per_block, store_high_half=False):
    """
    check scatter vector instruction, input tensor_list tensor overflow
    for api module and debug module

    Parameters
    ----------
    tensor_list: input parameters, dst_list or src_list, length = 8
    name: name of tensor_list, for printing check RuntimeError message
    params_list : mask_len, repeat_times, rep_stride
    valid_num_per_block: actual valid numbers of each block
    store_high_half : store_high_half

    Returns
    -------
    None
    """
    mask_len, repeat_times, rep_stride = params_list
    # If you import at the top of the file, it causes a loop
    # blk_num: number of blks whose mask_len_per_blk is blk_len
    blk_num = ceil_div(mask_len, valid_num_per_block)
    # mask_left: mask_len of last processed blk
    mask_left = mask_len % valid_num_per_block
    if mask_left == MASK_VALUE_ZERO:
        mask_left = valid_num_per_block
    # elements of 1 blk
    blk_len = get_compatible_blk_size() // DTYPE_SIZE.get(tensor_list[VA0_INDEX].dtype)
    TikCheckUtil.check_in_range_by_dtype(
        blk_len, msg="please check tensor list dtype!", var_range=[valid_num_per_block, 2*valid_num_per_block])
    for index in range(blk_num):
        params_list = (repeat_times, blk_len, valid_num_per_block, store_high_half,
                       rep_stride, tensor_list, index)
        expected_ele = _gen_expected_ele(params_list)
        # for last processed blk, mask_len_per_blk not blk_len but mask_left
        if index == blk_num - 1:
            expected_ele = expected_ele - valid_num_per_block + mask_left

        actual_ele = reduce_mul(tensor_list[index].original_shape)

        expected_ele = Expr(expected_ele).eval_value()
        actual_ele = Expr(actual_ele).eval_value()
        if expected_ele is not None and actual_ele is not None:
            TikCheckUtil.check_ge(
                actual_ele, expected_ele,
                "%s[%s] tensor overflow, expected elements: %s, actual "
                "elements: %s" % (name, index, expected_ele, actual_ele))


def _gen_expected_ele(params_list):
    repeat_times, blk_len, valid_num_per_block, store_high_half, \
    rep_stride, tensor_list, index = params_list
    if isinstance(repeat_times, int) and repeat_times == 1:
        if blk_len != valid_num_per_block and store_high_half:
            expected_ele = rep_stride * blk_len + blk_len + \
                           tensor_list[index].offset
        else:
            expected_ele = rep_stride * blk_len + valid_num_per_block + \
                           tensor_list[index].offset
    else:
        if blk_len != valid_num_per_block and store_high_half:
            expected_ele = (repeat_times - 1) * rep_stride * blk_len + \
                           blk_len + tensor_list[index].offset
        else:
            expected_ele = (repeat_times - 1) * rep_stride * blk_len + \
                           valid_num_per_block + tensor_list[index].offset
    return expected_ele
