#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_system_control_api_.py
DESC:     provide system control instructions
CREATED:  2019-08-12 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""
import numpy as np
from tbe import tvm
from tbe.common.platform.platform_info import api_check_support

from tbe.tik.common.tik_api_map import VEC_610
from tbe.tik.common.tik_api_map import AIC_610
from tbe.tik.common.tik_api_map import AIC_310P
from tbe.tik.common.tik_api_map import VEC_310P
from tbe.tik.common.tik_api_map import ASCEND_910BAIC
from tbe.tik.common.tik_api_map import HI3796CV300ESAIC
from tbe.tik.common.tik_api_map import HI3796CV300CSAIC
from tbe.tik.common.tik_api_map import SD3403AIC
from tbe.tik.common.tik_api_map import AIC_BS9SX1A
from tbe.tik.common.tik_api_map import ASCEND_310
from tbe.tik.common.tik_api_map import ASCEND_910AIC
from tbe.tik.common.tik_api_map import arch_version_mode
from tbe.tik.common.tik_api_map import ONLY_TIK_API_MAP
from tbe.tik.common.tik_ir_builder_util import ForRangeTuple
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_soc_core_type
from tbe.tik.debug.tik_vector_ops_debug.tik_system_control_debug import set_ctrl_bits
from tbe.tik.debug.tik_vector_ops_debug.tik_system_control_debug import set_l0_set_value_decorator
from tbe.tik.tik_lib.tik_util import dtype_convert
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik import debug
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.tik.tik_lib.tik_params import OVERFLOW_WARNING_SHIFT_POS
from tbe.tik.tik_lib.tik_params import PIPE_MTE1
from tbe.tik.tik_lib.tik_params import get_atomic_add_mod_start_pos as mod_start_pos
from tbe.tik.tik_lib.tik_params import get_atomic_add_mod_end_pos as mod_end_pos
from tbe.tik.tik_lib.tik_params import SMALL_CHANNEL_ENABLE_SHIFT_POS
from tbe.tik.tik_lib.tik_params import FP2INT_SHIFT_POS
from tbe.tik.tik_lib.tik_params import FP2FP_SHIFT_POS
from tbe.tik.tik_lib.tik_params import SYSTEM_CACHE_MODE_SHIFT_POS
from tbe.tik.tik_lib.tik_params import MAX_TWO_BITS_VALUE
from tbe.tik.tik_lib.tik_params import MAX_ONE_BIT_VALUE
from tbe.tik.tik_lib.tik_params import SMALL_CHANNEL_MASK
from tbe.tik.tik_lib.tik_params import SYSTEM_CACHE_MASK
from tbe.tik.tik_lib.tik_params import FP2INT_MASK
from tbe.tik.tik_lib.tik_params import FP2FP_MASK
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_params import INSTR_UNIT
from tbe.tik.tik_lib.tik_params import CACHE_LINE_SIZE
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager

_MAX_OVERFLOW_STATUS = 2
_MODE_RANGE = [0, 1]
_910B_ATOMIC_OP = 1


class TikSysControlApi(TikIRBuilder):
    """
    Proposal Operation Api
    """
    def __init__(self):
        super(TikSysControlApi, self).__init__()
        # use to save atomic add value,value is int.
        self.atomic_add_value = 0

    @source_info_decorator()
    @debug.get_status_bits(OVERFLOW_WARNING_SHIFT_POS)
    def mov_overflow_warning_to_scalar(self, scalar):
        """
        mov the overflow_warning bit of STATUS register to scalar

        Parameters
        ----------
        scalar : destination scalar operation

        Returns
        -------
        scalar : scalar with the overflow_warning bit
        """
        TikCheckUtil.check_type_match(
            scalar, Scalar, "input scalar should be Scalar")
        TikCheckUtil.check_equality(
            scalar.dtype, "uint64", "scalar must be uint64")
        status = self._mov_status_spr_to_scalar()
        status.set_as(status & (MAX_ONE_BIT_VALUE << OVERFLOW_WARNING_SHIFT_POS))
        status.set_as(status >> OVERFLOW_WARNING_SHIFT_POS)
        scalar.set_as(status)
        return scalar

    @source_info_decorator()
    @debug.atomic_add_to_scalar()
    def mov_atomic_add_to_scalar(self, scalar):
        """
        mov the atomic_add bits of CTRL register to scalar

        Parameters
        ----------
        scalar : destination scalar operation

        Returns
        -------
        scalar : scalar with the atomic_add bits
        """
        TikCheckUtil.check_not_equality(
            get_soc_name(), ASCEND_310,
            "this api doesn't support version: ASCEND_310")
        TikCheckUtil.check_type_match(
            scalar, Scalar, "input scalar should be Scalar")
        TikCheckUtil.check_equality(
            scalar.dtype, "uint64", "scalar must be uint64")
        ctrl = self._mov_ctrl_spr_to_scalar()
        ctrl.set_as(ctrl & (MAX_TWO_BITS_VALUE << mod_start_pos()))
        ctrl.set_as(ctrl >> mod_start_pos())
        scalar.set_as(ctrl)
        return scalar

    @source_info_decorator()
    @debug.get_ctrl_bits(SMALL_CHANNEL_ENABLE_SHIFT_POS, SMALL_CHANNEL_ENABLE_SHIFT_POS + 1)
    def mov_small_channel_to_scalar(self, scalar):
        """
        mov the small_channel bits of CTRL register to scalar

        Parameters
        ----------
        scalar : destination scalar operation

        Returns
        -------
        scalar : scalar with the small_channel bits
        """
        TikCheckUtil.check_not_equality(
            get_soc_name(), ASCEND_310,
            "this api doesn't support version: ASCEND_310")
        TikCheckUtil.check_type_match(
            scalar, Scalar, "input scalar should be Scalar")
        TikCheckUtil.check_equality(
            scalar.dtype, "uint64", "scalar must be uint64")
        ctrl = self._mov_ctrl_spr_to_scalar()
        ctrl.set_as(ctrl & (MAX_ONE_BIT_VALUE <<
                            SMALL_CHANNEL_ENABLE_SHIFT_POS))
        ctrl.set_as(ctrl >> SMALL_CHANNEL_ENABLE_SHIFT_POS)
        scalar.set_as(ctrl)
        return scalar

    @source_info_decorator()
    @debug.get_ctrl_bits(SYSTEM_CACHE_MODE_SHIFT_POS,
                         SYSTEM_CACHE_MODE_SHIFT_POS + 2)
    def mov_system_cache_to_scalar(self, scalar):
        """
        mov the system_cache bits of CTRL register to scalar

        Parameters
        ----------
        scalar : destination scalar operation

        Returns
        -------
        scalar : scalar with the system_cache bits
        """
        TikCheckUtil.check_not_equality(
            get_soc_name(), ASCEND_310,
            "this api doesn't support version: ASCEND_310")
        TikCheckUtil.check_type_match(
            scalar, Scalar, "input scalar should be Scalar")
        TikCheckUtil.check_equality(
            scalar.dtype, "uint64", "scalar must be uint64")
        ctrl = self._mov_ctrl_spr_to_scalar()
        ctrl.set_as(ctrl & (MAX_TWO_BITS_VALUE <<
                            SYSTEM_CACHE_MODE_SHIFT_POS))
        ctrl.set_as(ctrl >> SYSTEM_CACHE_MODE_SHIFT_POS)
        scalar.set_as(ctrl)
        return scalar

    @source_info_decorator()
    @debug.get_ctrl_bits(FP2INT_SHIFT_POS, FP2INT_SHIFT_POS + 1)
    def mov_fp2int_mode_to_scalar(self, scalar):
        """
        mov the fp2int_mode bits of CTRL register to scalar

        Parameters
        ----------
        scalar : destination scalar operation

        Returns
        -------
        scalar : scalar with the fp2int_mode bits
        """
        TikCheckUtil.check_not_equality(
            get_soc_name(), ASCEND_310,
            "this api doesn't support version: ASCEND_310")
        TikCheckUtil.check_type_match(
            scalar, Scalar, "input scalar should be Scalar")
        TikCheckUtil.check_equality(
            scalar.dtype, "uint64", "scalar must be uint64")
        ctrl = self._mov_ctrl_spr_to_scalar()
        ctrl.set_as(ctrl & (MAX_ONE_BIT_VALUE << FP2INT_SHIFT_POS))
        ctrl.set_as(ctrl >> FP2INT_SHIFT_POS)
        scalar.set_as(ctrl)
        return scalar

    @source_info_decorator()
    def set_atomic_add(self, mode):
        """
        set mode to the atomic_add bits of CTRL register

        Parameters
        ----------
        mode : atomic add mode, 0 - disable, 1 - float32, 2 - float16
        mode : for 910b: 3 - s16, 4 - s32, 5 - s8. 6 - bf16

        Returns
        -------
        None
        """
        atomic_add_dtype_and_value = {
            "float32": 1,
            "float16": 2,
            "int16": 3,
            "int32": 4,
            "int8": 5,
            "bfloat16": 6,
        }
        soc_name = get_soc_name()
        TikCheckUtil.check_type_match(mode, (int, Scalar, str), "mode should be int, str or Scalar")
        TikCheckUtil.check_equality(api_check_support("tik." + "set_atomic_add", ""), True,
                                    gen_api_check_statement("", "set_atomic_add"))

        # check mode range
        mode_range = arch_version_mode[soc_name]
        if isinstance(mode, str):
            core_type = get_soc_core_type()
            support_dtype = ONLY_TIK_API_MAP["set_atomic_add"].get(soc_name + core_type)
            TikCheckUtil.check_var_in_list(mode, support_dtype, "mode should be in the range of %s, input value: %s"
                                           % (support_dtype, mode))
            mode = atomic_add_dtype_and_value.get(mode)
            self.atomic_add_value = mode
        elif isinstance(mode, int):
            self.atomic_add_value = mode
            TikCheckUtil.check_var_in_list(mode, mode_range, "mode should be in the range of %s, input value: %s"
                                           % (mode_range, mode))

        elif isinstance(mode, Scalar):
            self.atomic_add_value = mode
            TikCheckUtil.check_equality(mode.dtype, "uint64", "scalar_mode should be a scalar of uint64")

        mode_start = mode_range[0]
        mode_end = mode_range[-1]

        @set_ctrl_bits(mod_start_pos(), mod_end_pos(), mode_start, mode_end, "mode")
        def set_atomic_add_gen_code(tik_instance, input_mode):
            with tik_instance.new_scope():
                if TikSocManager.is_910b_soc():
                    tik_instance.emit(tvm.call_extern("uint64", "set_atomic_write_op", _910B_ATOMIC_OP))
                if isinstance(input_mode, Scalar):
                    tik_instance.emit(tvm.call_extern("uint64", "set_atomic_write", input_mode.get()))
                else:
                    tik_instance.emit(tvm.call_extern("uint64", "set_atomic_write", input_mode))
        set_atomic_add_gen_code(self, mode)

    @source_info_decorator()
    @set_ctrl_bits(SMALL_CHANNEL_ENABLE_SHIFT_POS, SMALL_CHANNEL_ENABLE_SHIFT_POS + 1, 0, 1, "enable")
    def set_small_channel(self, enable):
        """
        set enable mode to the small_channel bit of CTRL register

        Parameters
        ----------
        enable : small_channel mode, 0 - disable, 1 - enable

        Returns
        -------
        None
        """
        TikCheckUtil.check_type_match(
            enable, (int, Scalar), "enable should be int or Scalar")
        TikCheckUtil.check_equality(api_check_support("tik." + "set_small_channel", ""), True,
                                    gen_api_check_statement("", "set_small_channel"))
        if isinstance(enable, int):
            TikCheckUtil.check_in_range_by_dtype(
                enable, msg="enable should be in the range of [%d, %d], input value %d"
                            % (_MODE_RANGE[0], _MODE_RANGE[1], enable), var_range=_MODE_RANGE)
        if isinstance(enable, Scalar):
            TikCheckUtil.check_equality(enable.dtype, "uint64", "scalar_enable should be a scalar of uint64")
        ctrl = self._mov_ctrl_spr_to_scalar()
        ctrl.set_as(ctrl & SMALL_CHANNEL_MASK)
        ctrl.set_as(ctrl | (enable << SMALL_CHANNEL_ENABLE_SHIFT_POS))
        with self.new_scope():
            self.emit(tvm.call_extern("uint64", "set_ctrl", ctrl.get()))

    @source_info_decorator()
    @set_ctrl_bits(SYSTEM_CACHE_MODE_SHIFT_POS, SYSTEM_CACHE_MODE_SHIFT_POS + 2, 0, 3, "mode")
    def set_system_cache(self, mode):
        """
        set mode to the system_cache bits of CTRL register

        Parameters
        ----------
        mode : system_cache mode, 0 - Normalread, 1 - ReadLast, 2 - ReadInvalid, 3 - NotNeedWriteBack

        Returns
        -------
        None
        """
        TikCheckUtil.check_equality(api_check_support("tik." + "set_system_cache", ""), True,
                                    gen_api_check_statement("", "set_system_cache"))
        TikCheckUtil.check_type_match(mode, (int, Scalar), "mode should be int or Scalar")
        _max_mode = 3
        if isinstance(mode, int):
            TikCheckUtil.check_in_range_by_dtype(mode, msg="mode should be in the range of [%d, %d], input value: %d"
                                                 % (0, _max_mode, mode), var_range=[0, _max_mode])
        if isinstance(mode, Scalar):
            TikCheckUtil.check_equality(mode.dtype, "uint64", "scalar_mode should be a scalar of uint64")
        ctrl = self._mov_ctrl_spr_to_scalar()
        ctrl.set_as(ctrl & SYSTEM_CACHE_MASK)
        ctrl.set_as(ctrl | (mode << SYSTEM_CACHE_MODE_SHIFT_POS))
        with self.new_scope():
            self.emit(tvm.call_extern("uint64", "set_ctrl", ctrl.get()))

    @source_info_decorator()
    def set_fp2int_mode(self, mode):
        """
        set mode to the fp2int_mode bit of CTRL register

        Parameters
        ----------
        mode : fp2int_mode mode, 0 - Saturated, 1 - Truncted

        Returns
        -------
        None
        """
        TikCheckUtil.check_equality(api_check_support("tik." + "set_fp2int_mode", ""), True,
                                    gen_api_check_statement("", "set_fp2int_mode"))
        TikCheckUtil.check_type_match(mode, (int, Scalar), "mode should be int or Scalar")
        if isinstance(mode, int):
            TikCheckUtil.check_in_range_by_dtype(mode, msg="mode should be in the range of [%d, %d], input value: %d"
                                                 % (_MODE_RANGE[0], _MODE_RANGE[1], mode), var_range=_MODE_RANGE)
        if isinstance(mode, Scalar):
            TikCheckUtil.check_equality(mode.dtype, "uint64", "scalar_mode should be a scalar of uint64")
        ctrl = self._mov_ctrl_spr_to_scalar()
        ctrl.set_as(ctrl & FP2INT_MASK)
        ctrl.set_as(ctrl | (mode << FP2INT_SHIFT_POS))

        @set_ctrl_bits(FP2INT_SHIFT_POS, FP2INT_SHIFT_POS + 1, 0, 1, "mode")
        def set_fp2int_mode_gen_code(tik_instance, input_mode):
            with self.new_scope():
                tik_instance.emit(tvm.call_extern("uint64", "set_ctrl", ctrl.get()))
        set_fp2int_mode_gen_code(self, mode)

    @source_info_decorator()
    def set_cond_task_id(self, cond_task_id):
        """
        set address of the task for COND operator

        Parameters
        ----------
        cond_task_id : cond task id, 64-bit, it can be tik.Scalar or int

        Returns
        -------
        None
        """
        TikCheckUtil.check_equality(api_check_support("tik." + "set_cond_task_id", ""), True,
                                    gen_api_check_statement("", "set_cond_task_id"))
        TikCheckUtil.check_type_match(cond_task_id, (int, Scalar), "task_id should be int or Scalar")
        if isinstance(cond_task_id, int):
            int64_min = -9223372036854775808
            uint64_max = 18446744073709551615
            if cond_task_id > uint64_max or cond_task_id < int64_min:
                TikCheckUtil.raise_error("cond_task_id should be in range of b64, input value is: %d" % cond_task_id)
        else:
            allowed_type_list = ["int8", "uint8", "int16", "uint16", "int32", "uint32", "int64", "uint64"]
            TikCheckUtil.check_var_in_list(cond_task_id.dtype, allowed_type_list,
                                           "type of cond_task_id should be int/uint, input type is: %s"
                                           % cond_task_id.dtype)
            cond_task_id = cond_task_id.get()

        with self.new_scope():
            self.emit(tvm.call_extern("uint64", "set_cond_taskid", cond_task_id))

    @source_info_decorator()
    @set_ctrl_bits(FP2FP_SHIFT_POS, FP2FP_SHIFT_POS + 1, 0, 1, "mode")
    def set_fp2fp_mode(self, mode):
        """
        set mode to the f322f16_mode bit of CTRL register

        Parameters
        ----------
        mode : f322f16_mode mode, 0 - Saturated, 1 - Truncted

        Returns
        -------
        None
        """
        TikCheckUtil.check_type_match(
            mode, (int, Scalar), "mode should be int or Scalar")
        if isinstance(mode, int):
            TikCheckUtil.check_in_range_by_dtype(mode, msg="mode should be in the range of [%d, %d], input value: %d"
                                                 % (_MODE_RANGE[0], _MODE_RANGE[1], mode), var_range=_MODE_RANGE)
        if isinstance(mode, Scalar):
            TikCheckUtil.check_equality(
                mode.dtype, "uint64",
                "scalar_mode should be a scalar of uint64")
        ctrl = self._mov_ctrl_spr_to_scalar()
        ctrl.set_as(ctrl & FP2FP_MASK)
        ctrl.set_as(ctrl | (mode << FP2FP_SHIFT_POS))
        with self.new_scope():
            self.emit(tvm.call_extern("uint64", "set_ctrl", ctrl.get()))

    @source_info_decorator()
    def instr_preload(self, icache_base_addr, instr_num):
        """
        instr_num must be multiple of 128/4=32
        """
        arch_version_str = get_soc_name() + get_soc_core_type()
        TikCheckUtil.check_var_in_list(
            arch_version_str, [ASCEND_910AIC, ASCEND_910BAIC, HI3796CV300ESAIC, HI3796CV300CSAIC, SD3403AIC,
                               AIC_310P, VEC_610, AIC_610, VEC_310P, AIC_BS9SX1A],
            "%s doesn't support instr_preload." % arch_version_str)
        TikCheckUtil.check_type_match(
            instr_num, (int, Scalar, Expr), "instr_num should be int, Scalar or Expr")
        if isinstance(instr_num, int):
            TikCheckUtil.check_equality(instr_num % INSTR_UNIT, 0, "instr_num must be multiple of 32.")
        with self.new_scope():
            with self.context.freeze():
                icache_addr = self.scalar_("uint64")
                for_range_tuple_ = ForRangeTuple(begint=0, endt=instr_num // INSTR_UNIT, name="i", thread_num=1,
                                                 thread_type="whole", block_num=1, dtype="int32", for_type="serial")
                with self.for_range_(for_range_tuple_) as i:
                    icache_addr.set_as(icache_base_addr + i*CACHE_LINE_SIZE)
                    self.emit(tvm.call_extern("uint64", "preload", icache_addr.get()))

    @source_info_decorator()
    def get_overflow_status(self, status):
        """
        get overflow status stored in scalar buffer

        Parameters
        ----------
        status : destination scalar operation

        Returns
        -------
        None
        """
        TikCheckUtil.check_not_equality(
            get_soc_name(), ASCEND_310, "this api doesn't support version: ASCEND_310")
        TikCheckUtil.check_type_match(
            status, Scalar, "variable should be Scalar, invalid type for status: %s" % type(status))
        TikCheckUtil.check_equality(
            status.dtype, "uint64",
            "variable should be a Scalar of uint64, invalid dtype for status: %s" % status.dtype)
        with self.new_scope():
            # overflow status is stored on scalar buffer, the address is 0x40000
            self.emit(
                tvm.call_extern("uint64_t", "reg_set", status.get(),
                                tvm.call_extern("uint64", "get_overflow_status")))

    @source_info_decorator()
    def set_overflow_status(self, value):
        """
        set overflow status to scalar buffer

        Parameters
        ----------
        value : overflow status

        Returns
        -------
        None
        """
        TikCheckUtil.check_not_equality(
            get_soc_name(), ASCEND_310, "this api doesn't support version: ASCEND_310")
        TikCheckUtil.check_type_match(
            value, int, "value should be Int, invalid type: %s" % type(value))
        TikCheckUtil.check_equality(
            value, 0, "value should be 0, invalid value: %s" % value)
        with self.new_scope():
            self.emit(tvm.call_extern("uint64_t", "clear_overflow_status"))

    @source_info_decorator()
    @set_l0_set_value_decorator
    def set_l0_set_value(self, value, dtype):
        """
        for tensor padding with matrix

        Parameters
        ----------
        value : input
        dtype : input's type

        Returns
        -------
        None
        """
        TikCheckUtil.check_type_match(value, (int, float, Scalar), "value should be int, float or Scalar")
        TikCheckUtil.check_var_in_list(dtype, ["float16", ], "dtype only support float16")
        if isinstance(value, Scalar):
            TikCheckUtil.check_equality(value.dtype, "float16", "scalar_value should be float16")
        if not isinstance(value, Scalar):
            if dtype == "int16":
                l0_set_2d_value = np.int16(value)
            elif dtype == "uint16":
                l0_set_2d_value = np.uint16(value)
            else:
                l0_set_2d_value = np.float16(value)
            l0_set_2d_value = l0_set_2d_value.view(np.float16)
            l0_set_2d_value = float(l0_set_2d_value)
            l0_set_2d_temp = dtype_convert(l0_set_2d_value, dtype)
        else:
            l0_set_2d_temp = dtype_convert(value, dtype)
        with self.new_scope():
            # one ir is call_extern
            l0_instr = tvm.call_extern("float16", "set_l0_set_value", l0_set_2d_temp)
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_MTE1)
            self.emit(l0_instr)

    def _mov_ctrl_spr_to_scalar(self):
        """
        mov all bits of CTRL register to scalar

        Parameters
        ----------
        Returns
        -------
        ctrl : CTRL register
        """
        ctrl = self.scalar_(dtype="uint64")

        @debug.get_ctrl_bits(0, SMALL_CHANNEL_ENABLE_SHIFT_POS + 1)
        def mov_ctrl_spr_to_scalar(tik_instance, ctrl_scalar):
            with tik_instance.new_scope():
                tik_instance.emit(tvm.call_extern(ctrl_scalar.dtype, "reg_set", ctrl_scalar.get(),
                                                  tvm.call_extern(ctrl_scalar.dtype, "get_ctrl")))

        mov_ctrl_spr_to_scalar(self, ctrl)
        return ctrl

    def _mov_status_spr_to_scalar(self):
        """
        mov all bits of STATUS register to scalar

        Parameters
        ----------
        Returns
        -------
        status : CSTATUS register
        """
        status = self.scalar_(dtype="uint64")
        with self.new_scope():
            self.emit(tvm.call_extern(status.dtype, "reg_set", status.get(),
                                      tvm.call_extern(status.dtype, "get_status")))
        return status
