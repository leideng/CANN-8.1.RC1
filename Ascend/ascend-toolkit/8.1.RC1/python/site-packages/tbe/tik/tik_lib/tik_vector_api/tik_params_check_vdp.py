#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_params_check_vdp.py
DESC:     common util file for tik api and debug
CREATED:  2020-01-10 19:02:50
MODIFIED: 2020-01-10 19:02:50
"""

from tbe import tvm
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.common.util import reduce_mul
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil


def check_vdp_dst_overflow(dst_list, num_pixel, num_disparity, path_mode, name="dst"):
    """
    check dst overflow
    """
    dst, dst_offset = dst_list
    if isinstance(dst_offset, (tvm.tir.IntImm, tvm.tir.FloatImm, tvm.tir.StringImm)):
        dst_offset = dst_offset.value
    total_size = reduce_mul(dst.original_shape)
    if num_disparity == 64 and path_mode == 1:
        need_offset = Expr(2 * num_disparity * num_pixel + dst_offset).eval_value()
        if need_offset is not None:
            TikCheckUtil.check_le(
                need_offset, total_size, "tensor overflow, %s need %s but only %s" % (name, need_offset, total_size))
    else:
        need_offset = Expr(num_disparity * num_pixel + dst_offset).eval_value()
        if need_offset is not None:
            TikCheckUtil.check_le(
                need_offset, total_size, "tensor overflow, %s need %s but only %s" % (name, need_offset, total_size))


def check_vdp_src_overflow(src_list, num_pixel, num_disparity, path_mode, name="src"):
    """
    check src overflow
    """
    src, src_offset = src_list
    if isinstance(src_offset, (tvm.tir.IntImm, tvm.tir.FloatImm, tvm.tir.StringImm)):
        src_offset = src_offset.value
    total_size = reduce_mul(src.original_shape)
    if path_mode == 0:
        need_offset = Expr(num_disparity * num_pixel + src_offset).eval_value()
        if need_offset is not None:
            TikCheckUtil.check_le(
                need_offset, total_size, "tensor overflow, %s need %s but only %s" % (name, need_offset, total_size))
    elif path_mode == 1:
        if num_disparity == 128:
            need_offset = Expr(num_disparity + src_offset).eval_value()
            if need_offset is not None:
                TikCheckUtil.check_le(
                    need_offset, total_size,
                    "tensor overflow, %s need %s but only %s" % (name, need_offset, total_size))
        elif num_disparity == 64:
            need_offset = Expr(2 * num_pixel * num_disparity + src_offset).eval_value()
            if need_offset is not None:
                TikCheckUtil.check_le(
                    need_offset, total_size,
                    "tensor overflow, %s need %s but only %s" % (name, need_offset, total_size))


def check_vdp_tensor_overflow(vdp_overflow_api):
    """
    check tensor overflow
    """

    if vdp_overflow_api.num_pixel is None:
        return

    if vdp_overflow_api.num_max_disparity == 0:
        num_disparity = 128
    elif vdp_overflow_api.num_max_disparity == 1:
        num_disparity = 64
    else:
        return

    # check dst overflow
    dst_list = (vdp_overflow_api.dst, vdp_overflow_api.dst_offset)
    check_vdp_dst_overflow(dst_list, vdp_overflow_api.num_pixel, num_disparity, vdp_overflow_api.path_mode, name="dst")

    # check src0 overflow
    src0_list = (vdp_overflow_api.src0, vdp_overflow_api.src0_offset)
    check_vdp_dst_overflow(src0_list, vdp_overflow_api.num_pixel, num_disparity,
                           vdp_overflow_api.path_mode, name="src0")

    # check src1 overflow
    src1_list = (vdp_overflow_api.src1, vdp_overflow_api.src1_offset)
    check_vdp_src_overflow(src1_list, vdp_overflow_api.num_pixel, num_disparity,
                           vdp_overflow_api.path_mode, name="src1")


def cal_vdp_tensor_need_size(num_pixel, num_max_disparity, path_mode, offset_list):
    """
    calculate tensor need size
    """
    dst_offset, src0_offset, src1_offset = offset_list
    if num_max_disparity == 0:
        num_disparity = 128
        if path_mode == 0:
            src1_need = Expr(num_disparity * num_pixel + src1_offset).eval_value()
        elif path_mode == 1:
            src1_need = Expr(num_disparity + src1_offset).eval_value()
    elif num_max_disparity == 1:
        num_disparity = 64
        if path_mode == 0:
            src1_need = Expr(num_disparity * num_pixel + src1_offset).eval_value()
        elif path_mode == 1:
            src1_need = Expr(2 * num_pixel * num_disparity + src1_offset).eval_value()

    dst_need = Expr(num_disparity * num_pixel + dst_offset).eval_value()
    src0_need = Expr(num_disparity * num_pixel + src0_offset).eval_value()

    return dst_need, src0_need, src1_need


def check_vdp_overlap(vdp_overlap_api):
    """
    check instr overlap
    """
    value_range = (vdp_overlap_api.num_pixel, vdp_overlap_api.num_max_disparity, vdp_overlap_api.path_mode,
                   vdp_overlap_api.dst_offset, vdp_overlap_api.src0_offset, vdp_overlap_api.src1_offset)
    if any(value is None for value in value_range):
        return

    offset_list = (vdp_overlap_api.dst_offset, vdp_overlap_api.src0_offset, vdp_overlap_api.src1_offset)
    dst_need, src0_need, src1_need = cal_vdp_tensor_need_size(
        vdp_overlap_api.num_pixel, vdp_overlap_api.num_max_disparity, vdp_overlap_api.path_mode, offset_list)

    check_vdp_overlap_raise_err(vdp_overlap_api, dst_need, src0_need, src1_need)


def check_vdp_overlap_raise_err(vdp_overlap_api, dst_need, src0_need, src1_need):
    """
    check vdp overlap raise error
    """
    if vdp_overlap_api.dst.buffer == vdp_overlap_api.src0.buffer:
        if vdp_overlap_api.dst_offset == vdp_overlap_api.src0_offset or \
                dst_need <= vdp_overlap_api.src0_offset or src0_need <= vdp_overlap_api.dst_offset:
            pass
        else:
            TikCheckUtil.raise_error("vdp doesn't support dst and src0 address overlapping partially.")

    if vdp_overlap_api.dst.buffer == vdp_overlap_api.src1.buffer:
        if dst_need <= vdp_overlap_api.src1_offset or src1_need <= vdp_overlap_api.dst_offset:
            pass
        else:
            TikCheckUtil.raise_error("vdp doesn't support dst and src1 address overlapping fully or partially.")

    if vdp_overlap_api.src0.buffer == vdp_overlap_api.src1.buffer:
        if src0_need <= vdp_overlap_api.src1_offset or src1_need <= vdp_overlap_api.src0_offset:
            pass
        else:
            TikCheckUtil.raise_error("vdp doesn't support src0 and src1 address overlapping fully or partially.")
