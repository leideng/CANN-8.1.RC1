#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_source_info.py
DESC:     handle source information
CREATED:  2020-1-21 20:12:13
MODIFIED: 2020-12-7 19:17:00
"""
import sys
from functools import wraps
from tbe.tvm.ir.base import Span
from tbe.tvm.ir.base import SourceName
from tbe.tik.tik_lib.tik_check_util import SpanManager
from tbe.tik.tik_lib.tik_check_util import ERROR_MSG_LEVEL
from tbe.tik.tik_lib.tik_check_util import TIK_ERROR_MSG
from tbe.tik.tik_lib.tik_check_util import clear_tik_error_msg
from tbe.tik.tik_lib.tik_check_util import TIK_CONTROL
from tbe.tik.tik_lib.tik_check_util import get_error_dict_args
from tbe.tik.tik_lib.tik_check_util import current_frame
from tbe.tik.tik_lib.tik_params import CUR_FRAME_IDX


def _get_value_by_class_type(first_arg):
    """
    for Tensor, Scalar, ScalarArray, return the original class object
    Parameters
    ----------
    first_arg: Api's object or Tik object, first args of source_info_decorator

    Returns
    -------
    object: class object of Tensor, Scalar or None
    """
    ret_value = None
    if first_arg.is_tensor():
        ret_value = first_arg
    elif first_arg.is_scalar_array():
        ret_value = first_arg.get_scalar_by_index(0)  # just for return a Scalar
    elif first_arg.is_scalar():
        ret_value = first_arg
    elif first_arg.is_tensor_addr():
        ret_value = first_arg
    return ret_value


def _check_curr_cond_is_false(first_arg, func_name):
    """
    to check whether the api function can be skipped,
    but some functions cannot be skipped even the if elif else condition is false
    Parameters
    ----------
    first_arg: Api's object or Tik object, first args of source_info_decorator
    func_name: the function's name of tik api

    Returns
    -------
    bool:
        True: current condition is True, this api can be run
        False: current condition is False, this api no need to run
    None or others: others is special values, for example, Tensor item, Scalar or ScalarArray item

    """
    ret_status = True
    ret_value = None

    # func list all with return object of TikWithScope or WithScope or tik var object
    no_need_check_func_list = ["if_scope", "elif_scope", "else_scope", "new_scope", "new_stmt_scope",
                               "multi_for_range", "for_range", "Tensor", "Scalar", "TensorAddrList",
                               "Vector", "ScalarArray"]
    # for some special Class, some API with return value not Class Value, should be deal with special
    no_need_check_data_type_class = ["Tensor", "Scalar", "TensorAddrList", "Vector", "ScalarArray"]
    no_need_check_class_func = ["shape", "size", "name"]

    # deal with api of some special Class
    if func_name in no_need_check_class_func and hasattr(first_arg, "data_type") and \
            first_arg.data_type in no_need_check_data_type_class:
        ret_status = True
    elif hasattr(first_arg, "tik_instance"):   # deal with api which with attr tik_instance
        # is_break_continue: if is_break and is_continue is true, the code is not executed.
        if first_arg.tik_instance.curr_cond_is_false() or first_arg.tik_instance.is_break_continue():
            ret_status = False
    elif func_name not in no_need_check_func_list:  # even the cond is False, some special API must be run
        # first arg is tik_instance object, call api by tik_instance.xxx
        # is_break_continue: if is_break and is_continue is true, the code is not executed.
        if hasattr(first_arg, "is_tik_instance") and \
                (first_arg.curr_cond_is_false() or first_arg.is_break_continue()):
            ret_status = False
        # first arg is not tik_instance object, but Tensor, Scalar, ScalarArray object, return special value
        # is_break_continue: if is_break and is_continue is true, the code is not executed.
        elif hasattr(first_arg, "ir_generator") and \
                (first_arg.ir_generator.curr_cond_is_false() or first_arg.ir_generator.is_break_continue()):
            ret_status = False
            ret_value = _get_value_by_class_type(first_arg)

    return ret_status, ret_value


def source_info_decorator(depth=1):
    """
    bind this decorator with func that need register source info

    Parameters
    ----------
    depth : stack depth

    Returns
    -------
    function
    """
    def get_source_info_decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            """
            bind this decorator with func that need register source info
            """
            if len(args) > 0:
                first_arg = args[0]
                func_name = func.__name__
                is_false, ret_value = _check_curr_cond_is_false(first_arg, func_name)
                if is_false is False:
                    return ret_value

            if TIK_CONTROL.is_user_call:
                TikSourceInfo.register_source_info(depth)
                TikSourceInfo.set_not_user_call()
                f_return = func(*args, **kwargs)
                TikSourceInfo.clear_source_info()
                TikSourceInfo.set_is_user_call()
            else:
                f_return = func(*args, **kwargs)
            return f_return
        return wrapper
    return get_source_info_decorator


def get_span():
    """
    get place corresponding to node
    """
    if TIK_ERROR_MSG.api_source_info is None:
        if TIK_CONTROL.if_loc_invalid_raise_error:
            msg = '''location is invalid, please check!!!\n
                    "There are two reasons for the error:\n"
                    "If it is an open interface, please "
                    "register source at the beginning;\n"
                    "If it is an unopened interface,"
                    " please correct this mistake;'''
            get_error_dict_args(msg)
        print("WARNING: location is invalid, please check!!!")
        return Span(SourceName("invalid"), 0, 0, 0, 0)
    file = TIK_ERROR_MSG.api_source_info[CUR_FRAME_IDX].get("filename")
    col = str(TIK_ERROR_MSG.api_source_info[CUR_FRAME_IDX].get("line_no"))
    return Span(SourceName(file), int(col), int(col), 0, 0)


def most_recent_traceback():
    """
    get system's exc info that contains type, exception, traceback
    """
    trace = sys.exc_info()[2]
    trace_list = []
    while trace:
        trace_list.append({"filename": trace.tb_frame.f_code.co_filename,
                           "line_no": trace.tb_lineno,
                           "function": trace.tb_frame.f_code.co_name})
        trace = trace.tb_next
    trace_list.reverse()
    return trace_list


class TikSourceInfo():
    """
    handle tik api source information
    """
    is_inited = False  # one tik_instance only need init once

    def __init__(self):
        if not hasattr(TIK_CONTROL, "if_loc_invalid_raise_error"):
            TIK_CONTROL.if_loc_invalid_raise_error = True
        if not hasattr(TIK_ERROR_MSG, "span_manager"):
            TIK_ERROR_MSG.span_manager = SpanManager()
        if not hasattr(ERROR_MSG_LEVEL, "err_msg_level"):
            ERROR_MSG_LEVEL.err_msg_level = 0
        if TikSourceInfo.is_inited is True:
            return

        TIK_ERROR_MSG.api_source_info = None
        TIK_CONTROL.is_user_call = True
        TikSourceInfo.is_inited = True

    @staticmethod
    def register_source_info(depth=1, source_info=None):
        """
        register source information

        Parameters
        ----------
        depth : stack depth
        source_info : source information

        Returns
        -------
        None
        """
        if TIK_ERROR_MSG.api_source_info is not None:
            msg = "please clear source info before register, previous info:" \
                  " \n%s" % TIK_ERROR_MSG.api_source_info[CUR_FRAME_IDX]
            get_error_dict_args(msg)
        # set debug module info or for_range/if_scope/else_scope
        if source_info is not None:
            TIK_ERROR_MSG.api_source_info = source_info
        else:
            depth += 1
            TIK_ERROR_MSG.api_source_info = current_frame(depth)

    @staticmethod
    def set_not_user_call():
        """
        set is_user_call to false, indicating that the function is not called by user next Therefore, source info will
        not be recorded repeatedly.
        """
        TIK_CONTROL.is_user_call = False

    @staticmethod
    def set_is_user_call():
        """
        set is_user_call to True, indicating that the function is called by user next
        """
        TIK_CONTROL.is_user_call = True

    @staticmethod
    def clear_source_info():
        """
        clear source information
        """
        TIK_ERROR_MSG.api_source_info = None

    @staticmethod
    def get_source_info():
        """
        get source information
        """
        return TIK_ERROR_MSG.api_source_info

    @staticmethod
    def set_node_span(tvm_node, span=None):
        """
        set place for node
        """
        if span is None:
            TIK_ERROR_MSG.span_manager.set_span(tvm_node, get_span())
        else:
            TIK_ERROR_MSG.span_manager.set_span(tvm_node, span)

    @staticmethod
    def get_node_span(tvm_node=None):
        """
        get place of node
        """
        return TIK_ERROR_MSG.span_manager.get_span(tvm_node)

    @staticmethod
    def clear_node_loc():
        """
        Clear correspondence between node and place to tvm
        """
        TIK_ERROR_MSG.span_manager.clear()

    @staticmethod
    def end_and_clear():
        """
        when tik end, clear TIK_ERROR_MSG
        """
        clear_tik_error_msg()
