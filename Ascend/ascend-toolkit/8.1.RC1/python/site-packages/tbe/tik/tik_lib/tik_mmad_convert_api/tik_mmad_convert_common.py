#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_mmad_convert_common.py
DESC:     tik_mmad_convert_check
CREATED:  2021-12-07 9:37 AM
MODIFIED: 2021-12-07 9:37 AM
"""
from tbe.common.platform import scope_gm
from tbe.common.platform import scope_ubuf
from tbe.common.platform import scope_cbuf

from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.common.tik_api_map import AIC_610
from tbe.tik.common.tik_api_map import AIC_610L
from tbe.tik.common.tik_api_map import AIC_BS9SX2A
from tbe.tik.common.tik_api_map import AIC_MC61AM21A
from tbe.tik.common.tik_api_map import AIC_BS9SX1A
from tbe.tik.common.tik_api_map import AIC_310P
from tbe.tik.common.tik_api_map import SD3403AIC
from tbe.tik.common.tik_api_map import HI3796CV300CSAIC
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_soc_core_type
from tbe.tik.tik_lib.tik_api_constants import LOAD3DV2_FUNC_MAP
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_params import BYTE_PER_C0
from tbe.tik.tik_lib.tik_params import MIN_CHANNEL_SIZE
from tbe.tik.tik_lib.tik_params import MAX_CHANNEL_SIZE
from tbe.tik.tik_lib.tik_params import ELE_PER_FRACTAL_EDGE
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_params import PADDING_LEFT_IDX
from tbe.tik.tik_lib.tik_params import PADDING_RIGHT_IDX
from tbe.tik.tik_lib.tik_params import PADDING_TOP_IDX
from tbe.tik.tik_lib.tik_params import PADDING_BOT_IDX

COL2IMG_REG_XT_OFFSET_LIST = [0, 6, 12, 20, 28, 36, 52, 56]
COL2IMG_REG_XT_SEGMENT_LIST = [6, 6, 8, 8, 8, 8, 1, 8]
COL2IMG_REG_XM_OFFSET_LIST = [16, 24, 32, 48]
COL2IMG_REG_XM_SEGMENT_LIST = [8, 8, 16, 16]


def check_mmad_param_type_range(name, value, start=0, end=0, is_debug=False):
    """
    check param type and range
    :param name: params name
    :param value: params value
    :param start: params range start
    :param end: params range end
    :param is_debug : Whether or not debug
    :return: no return
    """
    if not is_debug:
        TikCheckUtil.check_type_match(
            value, (int, Scalar, Expr),
            "%s should be int, Scalar or Expr, input type of %s: %s" % (name, name, type(value)))
        check_scalar_dtype(value, "scalar %s should be a scalar of int/uint" % name)
    TikCheckUtil.check_in_range_by_dtype(value, msg="%s should be in the range of [%s, %s], input value is: %s"
                                                    % (name, start, end, value), var_range=[start, end])


def check_load3dv2_channel_size(channel_size, src_dtype):
    """
    check channel_size

    Parameters
    ----------
    channel_size: input param channel_size of instruction load3dv2
    src_dtype: dtype of src, int8/uint8/float16

    Returns
    -------
    None
    """
    # check channel_size
    TikCheckUtil.check_type_match(
        channel_size, (int, Scalar, Expr),
        "channel_size should be int, Scalar or Expr, input type of channel_size:%s" % type(channel_size))
    check_scalar_dtype(channel_size, "scalar_channel_size should be a scalar of int/uint")
    TikCheckUtil.check_in_range_by_dtype(
        channel_size, msg="channel_size should be in the range of [%s, %s], input channel_size: %s"
        % (MIN_CHANNEL_SIZE, MAX_CHANNEL_SIZE, channel_size), var_range=[MIN_CHANNEL_SIZE, MAX_CHANNEL_SIZE])

    if Expr(channel_size).eval_value() is not None:
        # ISA v7.9.3
        # if soc is 910b & src dtype is fp32, channel_size_f32 mod 16 should be 0 or 4
        # channel_size_f16 mod 16 should be 0, 4 or 8
        # channel_size_b8 mod 32 should be 0, 4, 8, 16
        channel_size_8_list = [0, 4]
        channel_size_16_list = [0, 4, 8]
        channel_size_32_list = [0, 4, 8, 16]
        if src_dtype == "float32":
            TikCheckUtil.check_var_in_list(
                channel_size % (BYTE_PER_C0 // DTYPE_SIZE[src_dtype]), channel_size_8_list,
                "for f32 src tensor, channel_size mod 16 should be 0 of 4 "
                "input channel_size: %s" % channel_size)
        elif src_dtype == "float16":
            TikCheckUtil.check_var_in_list(
                channel_size % (BYTE_PER_C0 // DTYPE_SIZE[src_dtype]), channel_size_16_list,
                "for f16 src tensor, channel_size mod 16 should be 0, 4, or 8, "
                "input channel_size: %s" % channel_size)
        else:
            TikCheckUtil.check_var_in_list(
                channel_size % (BYTE_PER_C0 // DTYPE_SIZE[src_dtype]), channel_size_32_list,
                "for b8 src tensor, channel_size mod 32 should be 0, 4, 8 or 16, "
                "input channel_size: %s" % channel_size)


def check_load3dv2_m_extension(dlt_params, oth_params):
    """
    check load3dv2 m_extension, m_start_pt

    Parameters
    ----------
    dlt_params: filter_w, filter_h, dilation_filter_w, dilation_filter_h
    oth_params: pad_list, m_extension, l1_w, l1_h, stride_w, stride_h, m_start_pt

    Returns
    -------
    None
    """
    pad_list, m_extension, l1_w, l1_h, stride_w, stride_h, m_start_pt = oth_params
    dlt_w = (dlt_params[0] - 1) * dlt_params[2] + 1
    dlt_h = (dlt_params[1] - 1) * dlt_params[3] + 1

    w_o = (l1_w + pad_list[PADDING_LEFT_IDX] + pad_list[PADDING_RIGHT_IDX] - dlt_w) // stride_w + 1
    h_o = (l1_h + pad_list[PADDING_TOP_IDX] + pad_list[PADDING_BOT_IDX] - dlt_h) // stride_h + 1

    # expected m should be multiple of 16
    max_m = w_o * h_o
    expected_m = m_extension + m_start_pt
    max_m = Expr(max_m).eval_value()
    expected_m = Expr(expected_m).eval_value()
    m_extension = Expr(m_extension).eval_value()
    # need to check whether is lowermost fractal matrix
    if max_m is not None and expected_m is not None and m_extension is not None:
        if expected_m < max_m:
            TikCheckUtil.check_equality(
                0, m_extension % ELE_PER_FRACTAL_EDGE,
                "m_extension(%s) should be multiple of 16 is if is not lowermost fractal matrix" % str(m_extension))
        elif expected_m > max_m:
            TikCheckUtil.raise_error("m_extension(%s) + m_start_pt(%s) larger than expected "
                                     "maximum m extension: %s" % (m_extension, m_start_pt, max_m))


def check_load3dv2_k_extension(params, src_dtype):
    """
    check load3dv2 k_extension, k_start_pt

    Parameters
    ----------
    params: channel_size, k_extension, filter_h, filter_w, k_start_pt
    src_dtype: dtype of src, float16/int8/uint8

    Returns
    -------
    None
    """
    channel_size, k_extension, filter_h, filter_w, k_start_pt = params
    if not isinstance(channel_size, int):
        return
    max_k = channel_size * filter_h * filter_w
    valid_c0_value = BYTE_PER_C0 // DTYPE_SIZE.get(src_dtype)
    max_k = ceil_div(max_k, valid_c0_value) * valid_c0_value

    # expected k should be multiple of 32B
    expected_k = k_extension + k_start_pt
    max_k = Expr(max_k).eval_value()
    expected_k = Expr(expected_k).eval_value()
    k_extension = Expr(k_extension).eval_value()
    if max_k is not None and expected_k is not None and k_extension is not None:
        if expected_k < max_k:
            TikCheckUtil.check_equality(
                0, k_extension * DTYPE_SIZE[src_dtype] % ONE_BLK_SIZE,
                "k_extension(%s) in Byte round up to multiple of 32B if is not rightmost fractal matrix" %
                str(k_extension))
        elif expected_k > max_k:
            TikCheckUtil.raise_error(
                "k_extension(%s) + k_start_pt(%s) larger than expected maximum k extension: %s" %
                (k_extension, k_start_pt, max_k))


def get_sk_tp(load_3dv2_api):
    """
    get sk_tp
    Parameters
    ----------

    load_3dv2_api: load3dv2 ins
    Returns sk_tp_bit
    """
    arch_version_str = get_soc_name() + get_soc_core_type()
    TikCheckUtil.check_type_match(
        load_3dv2_api.en_small_k, bool,
        "en_small_k should be bool, input type of en_small_k: {}".format(type(load_3dv2_api.en_small_k)))
    if load_3dv2_api.en_small_k:
        TikCheckUtil.check_var_in_list(
            arch_version_str, LOAD3DV2_FUNC_MAP["sk"],
            "{} doesn't support small_k".format(arch_version_str))

    # check transpose
    TikCheckUtil.check_type_match(
        load_3dv2_api.en_transpose, bool,
        "en_transpose should be bool, input type of en_transpose: {}".format(type(load_3dv2_api.en_transpose)))
    if load_3dv2_api.en_transpose:
        if arch_version_str in (AIC_610L, AIC_BS9SX2A, AIC_MC61AM21A) and \
                load_3dv2_api.src.dtype not in ("float16", "int16", "uint16"):
            msg = "{} {} {} doesn't support transpose".format(arch_version_str,
                                                              load_3dv2_api.instr_name, load_3dv2_api.src.dtype)
            TikCheckUtil.raise_error(msg)
        else:
            TikCheckUtil.check_var_in_list(
                arch_version_str,
                [HI3796CV300CSAIC, AIC_610, AIC_310P, AIC_BS9SX1A, SD3403AIC, AIC_610L, AIC_BS9SX2A, AIC_MC61AM21A],
                "{} {} {} doesn't support transpose".format(arch_version_str,
                                                            load_3dv2_api.instr_name, load_3dv2_api.src.dtype))
        sk_tp_bit = 1
    else:
        sk_tp_bit = 0

    return sk_tp_bit


def check_dilation_filter_size(params, dimension):
    """
    check dilation filter size, should be smaller than l1 tensor size after padding

    Parameters
    ----------
    params: filter_len, dilation_filter, src_len, pad_0, pad_1
    dimension: H/W dimension, dtype:str

    Returns
    -------
    None
    """
    filter_len, dilation_filter, src_len, pad_0, pad_1 = params
    dlt_filter_len = (filter_len - 1) * dilation_filter + 1
    pad_src_len = src_len + pad_0 + pad_1
    dlt_filter_len = Expr(dlt_filter_len).eval_value()
    pad_src_len = Expr(pad_src_len).eval_value()
    if dlt_filter_len is not None and pad_src_len is not None:
        TikCheckUtil.check_le(
            dlt_filter_len, pad_src_len,
            "in %s dimension, feature map size(after_padding): %s should be "
            "larger than filter size(after dilation): %s" % (dimension, pad_src_len, dlt_filter_len))


def load2d_3d_align_fn(dst, src):
    """
    get the src and dst align

    Parameters
    ----------
    dst : dst tensor
    src : src tensor

    Returns
    -------
    src_align, dst_align
    """
    src_align = 512
    dst_align = 512
    if src.scope == scope_gm:
        src_align = 1
    if dst.scope == scope_gm:
        dst_align = 1
    if dst.scope in [scope_ubuf, scope_cbuf]:
        dst_align = 32
    if src.scope in [scope_ubuf, scope_cbuf]:
        src_align = 32

    return src_align, dst_align
