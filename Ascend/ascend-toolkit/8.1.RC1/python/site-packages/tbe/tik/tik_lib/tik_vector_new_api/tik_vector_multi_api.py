#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_multi_api.py
DESC:     tik v210 multi source api
CREATED:  2021-11-25 19:48
MODIFIED: 2021-11-25 19:48
"""

from tbe.common.platform import intrinsic_check_support
from tbe.common.platform import scope_ubuf
from tbe.tik.common.common_util import check_address_align
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.common.util import TikCheckUtil
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.api.tik_vector import Vector
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_new_api_base import TikVectorNewApiBase


class TikVectorMultiApi(TikVectorNewApiBase):
    """
    tik vector multi api
    """

    @source_info_decorator()
    def vector_vrnd(self, mask, dst, src0, src1):
        """
        Do round by single element.
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation

        Returns
        -------
        None
        """
        if isinstance(src1, Vector):
            vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vrnd', mask, dst, None, None, src0, src1)
            self._vector_reg_binary_tenary_elewise_func(vec_op_params_ins, mode="MODE_MERGING")
        else:
            TikCheckUtil.check_type_match(
                src1, (int, Expr, Scalar),
                "Instruction %s's %s should be vector, int, Expr or Scalar, "
                "input type is %s" % ("vector_vrnd", "src1", type(src1)))
            vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vrnds', mask, dst, src0, src1, None, None)
            self._vector_reg_scalar_single_elewise_func(vec_op_params_ins,
                                                        api_name="vector_vrnd", mode="MODE_MERGING",
                                                        scalar_name="src1")

    @source_info_decorator()
    def vector_vadif(self, mask, dst, src0, src1):
        """
        do vector addition and difference of element
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params("vectorized_vadif", mask, dst, None, None, src0, src1)
        return self._vector_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vsad(self, mask, dst, src0, src1):
        """
        do vector summation of absolute difference of element
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params("vectorized_vsad", mask, dst, None, None, src0, src1)
        return self._vector_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vsadd(self, mask, dst, src0, src1):
        """
        do vector addition instrcution with saturation of element
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vsadd', mask, dst, None, None, src0, src1)
        return self._vector_reg_binary_tenary_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vssub(self, mask, dst, src0, src1):
        """
        do vector subtraction with saturation of element
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vssub', mask, dst, None, None, src0, src1)
        return self._vector_reg_binary_tenary_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vdiv(self, mask, dst, src0, src1):
        """
        Do div by single element.
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params("vectorized_vdiv", mask, dst, None, None, src0, src1)
        return self._vector_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vshl(self, mask, dst, src0, src1):
        """
        Do logic pr arithmetic left shift for each active elements.
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """

        if isinstance(src1, Vector):
            vec_op_params_ins = TikVectorMultiApi.vec_op_params("vectorized_vshl", mask, dst, None, None, src0, src1)
            self._vector_elewise_func(vec_op_params_ins)  # vshl
        else:
            vec_op_params_ins = TikVectorMultiApi.vec_op_params("vectorized_vshls", mask, dst, src0, src1, None, None)
            self._vector_elewise_scalar_func(vec_op_params_ins,
                                             mode="MODE_MERGING", api_name="vector_vshl")  # vshls

    @source_info_decorator()
    def vector_vand(self, mask, dst, src0, src1):
        """
        Do vector and instruction
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vand', mask, dst, None, None, src0, src1)
        return self._vector_reg_binary_tenary_elewise_func(vec_op_params_ins, mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vor(self, mask, dst, src0, src1):
        """
        Do vector or instruction
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vor', mask, dst, None, None, src0, src1)
        return self._vector_reg_binary_tenary_elewise_func(vec_op_params_ins, mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vxor(self, mask, dst, src0, src1):
        """
        Do vector xor instruction
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vxor', mask, dst, None, None, src0, src1)
        return self._vector_reg_binary_tenary_elewise_func(vec_op_params_ins, mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vsel(self, mask, dst, src0, src1):
        """
        Do vector seelection instruction
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vsel', mask, dst, None, None, src0, src1)
        return self._vector_reg_binary_tenary_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vmax(self, mask, dst, src0, src1):
        """
        Do max() by single element.
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params("vectorized_vmax", mask, dst, None, None, src0, src1)
        return self._vector_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vmin(self, mask, dst, src0, src1):
        """
        Do max() by single element.
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params("vectorized_vmin", mask, dst, None, None, src0, src1)
        return self._vector_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vmula(self, mask, dst, src0, src1):
        """
        Do multiply and addition by single element.
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params("vectorized_vmula", mask, dst, None, None, src0, src1)
        return self._vector_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vmadd(self, mask, dst, src0, src1):
        """
        Do multiply and addition by single element.
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vmadd', mask, dst, None, None, src0, src1)
        return self._vector_reg_binary_tenary_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vscatter(self, mask, dst, src0, src1):
        """
        dst = src <op> scalar
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: Tensor destination operator
        src0: Vector source operation
        src1: Vector source operation

        Returns
        -------
        None
        """
        api_name = "vector_vscatter"
        TikCheckUtil.check_type_match(
            dst, Tensor, "Instruction %s's dst should be Tensor" % api_name)
        TikCheckUtil.check_type_match(
            src0, Vector, "Instruction %s's src0 should be Vector" % api_name)
        TikCheckUtil.check_type_match(
            src1, Vector, "Instruction %s's src1 should be Vector" % api_name)
        TikCheckUtil.check_equality(
            dst.scope, scope_ubuf, "Instruction %s's dst's scope must be scope_ubuf" % api_name)

        name = "vectorized_vscatter"
        # check instruction
        TikCheckUtil.check_equality(src0.dtype, dst.dtype,
                                    "Intrinsic %s's src0's dtype should be equal to dst's dtype" % name)
        dtype_str = DTYPE_MAP.get(dst.dtype) + DTYPE_MAP.get(src1.dtype)
        dtype_str_error = "src1 " + src1.dtype + " dst " + dst.dtype
        TikCheckUtil.check_equality(intrinsic_check_support("Intrinsic_" + name, dtype_str), True,
                                    gen_api_check_statement(dtype_str_error, api_name))

        check_address_align(dst, ["dst"])
        vec_op_params_ins = TikVectorMultiApi.vec_op_params(name, mask, dst, None, None, src0, src1)
        self._vector_vscatter_code_gen(vec_op_params_ins)

    @source_info_decorator()
    def vector_vlrelu(self, mask, dst, src0, src1):
        """
        do leaky relu of element
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: scalar operation or vector source operation 1
        Returns
        -------
        None
        """
        # if src1 is Vector, call vprelu
        if isinstance(src1, Vector):
            vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vlrelu', mask, dst, None, None, src0, src1)
            self._vector_reg_binary_tenary_elewise_func(vec_op_params_ins, mode="MODE_MERGING")
        else:
            vec_op_params_ins = TikVectorMultiApi.vec_op_params('vectorized_vlrelu', mask, dst, src0, src1, None, None)
            self._vector_reg_scalar_single_elewise_func(
                vec_op_params_ins, mode="MODE_MERGING", src_name="src0", scalar_name="src1")
