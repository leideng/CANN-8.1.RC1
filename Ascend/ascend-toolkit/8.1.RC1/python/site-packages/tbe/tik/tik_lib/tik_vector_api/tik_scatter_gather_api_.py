#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_scatter_gather_api_.py
DESC:     tik data scatter/gather
CREATED:  2021-11-19 10:46:42
MODIFIED: 2021-11-26 11:20:37
"""
from tbe import tvm
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.common.common_util import is_expr
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vscatter_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vgatherb_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vgather_decorator
from tbe.tik.common.util import get_bit_len
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_util import concat_params
from tbe.tik.tik_lib.tik_vector_api.tik_parms_check_scatter import CheckParams
from tbe.tik.tik_lib.tik_vector_api.tik_parms_check_scatter import VGatherbCheckParams
from tbe.tik.tik_lib.tik_vector_api.tik_scatter_gather_op import ScatterGatherOp
from tbe.tik.tik_lib.tik_vector_api.tik_scatter_gather_op import VGatherbOp
from tbe.tik.tik_lib.tik_api_util import reset_ctrl_value
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import BIT_LEN_16
from tbe.tik.tik_lib.tik_params import VSCATTER_VGATHER_XT_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import VSCATTER_VGATHER_XT_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import PIPE_S
from tbe.tik.tik_lib.tik_api_util import set_ctrl_counter_mask
from tbe.tik.tik_lib.tik_vector_api.tik_compute_control import ControlOp
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.common.util import reduce_mul


class VScatterOps:
    """
    VScatter Vector Ops
    """

    def __init__(self, tik_instance, vscatter_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = vscatter_api.name
        self.print_name = self.name
        self.control_op = ControlOp(vscatter_api.mask, vscatter_api.repeat_times,
                                    vscatter_api.stride_unit, vscatter_api.mask_mode)
        self.dst_tensor_op = ScatterGatherOp(vscatter_api.dst, blk_stride='',
                                             rep_stride='', tensor_op_name="dst")
        self.src_tensor_op = ScatterGatherOp(vscatter_api.src, blk_stride='',
                                             rep_stride=vscatter_api.rep_stride, tensor_op_name="src")
        self.dst_offset_tensor_op = ScatterGatherOp(vscatter_api.offset_tensor, blk_stride='',
                                                    rep_stride='', tensor_op_name="dst_offset")

        self.repeat_times = vscatter_api.repeat_times
        self.base_addr = vscatter_api.base_addr
        self.stride_unit = vscatter_api.stride_unit
        # debug check instance
        self.check_params = (self.dst_tensor_op, self.src_tensor_op, self.dst_offset_tensor_op,
                             self.control_op, self.base_addr)
        self.scatter_gather_check_obj = CheckParams(self.name, self.check_params)
        self.mask_o = None

    @vscatter_decorator
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        # code gen
        if TikSocManager.is_v300_610l_soc() or TikSocManager.is_v210_vec_soc():
            self._vscatter_code_gen_v300()
            return
        orig_ctrl = ''
        default_stride = 0
        if isinstance(self.base_addr, Scalar):
            with self.tik_instance.context.freeze():
                with self.tik_instance.new_scope():
                    self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_S)
                    self.base_addr.set_as(
                        self.base_addr + tvm.tir.Cast(
                            "int64", tvm.call_extern("handle", "", self.dst_tensor_op.tensor_obj.access_ptr("rw"))))
        else:
            self.base_addr = self.base_addr + tvm.tir.Cast(
                "int64", tvm.call_extern("handle", "", self.dst_tensor_op.tensor_obj.access_ptr("rw")))

        config = [self.base_addr, default_stride,
                  self.src_tensor_op.rep_stride, self.stride_unit, self.repeat_times]
        args = concat_params(config, VSCATTER_VGATHER_XT_OFFSET_LIST, VSCATTER_VGATHER_XT_SEGMENT_LIST)
        if get_bit_len(self.src_tensor_op.tensor_obj.dtype) == BIT_LEN_16:
            dtype_str = "uint16"
        else:
            dtype_str = "uint32"

        if self.control_op.mask_mode == "counter":
            # save orig_ctrl
            orig_ctrl = set_ctrl_counter_mask(self.tik_instance)

        with self.tik_instance.new_scope():
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *self.mask_o))

            instr = tvm.call_extern(
                self.dst_offset_tensor_op.tensor_obj.dtype, self.print_name,
                self.dst_offset_tensor_op.tensor_obj.reinterpret_cast_to('uint32').access_ptr("r"),
                self.src_tensor_op.tensor_obj.reinterpret_cast_to(dtype_str).access_ptr("r"), args)
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.scope_attr(
                tvm.thread_axis("cce"), "append_mem",
                tvm.call_extern("handle", "mem_vector", self.dst_tensor_op.tensor_obj.access_ptr("rw")))
            self.tik_instance.emit(instr)

        # reset CTRL SPR as orig_ctrl
        if self.control_op.mask_mode == "counter":
            reset_ctrl_value(self.tik_instance, orig_ctrl)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.mask_o = self.scatter_gather_check_obj.check_all(self.tik_instance)
        self.gen_code()

    def _vscatter_code_gen_v300(self):
        default_stride = 0
        args = [self.base_addr, self.control_op.repeat_times, self.src_tensor_op.rep_stride, default_stride,
                self.control_op.stride_unit]

        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.tik_instance.add_source_id()
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *self.mask_o))

            instr = tvm.call_extern(
                self.dst_offset_tensor_op.tensor_obj.dtype, self.print_name,
                self.dst_tensor_op.tensor_obj.access_ptr("w"),
                self.dst_offset_tensor_op.tensor_obj.reinterpret_cast_to('uint32').access_ptr("r"),
                self.src_tensor_op.tensor_obj.access_ptr("r"), *type_convert(args),
                self.control_op.mask_mode)
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.scope_attr(
                tvm.thread_axis("cce"), "append_mem",
                tvm.call_extern("handle", "mem_vector", self.dst_tensor_op.tensor_obj.access_ptr("rw")))
            self.tik_instance.emit(instr)


class VGatherOps:
    """
    VGather Vector Ops
    """

    def __init__(self, tik_instance, scatter_gather_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = scatter_gather_api.name
        self.print_name = self.name
        self.control_op = ControlOp(scatter_gather_api.mask, scatter_gather_api.repeat_times,
                                    scatter_gather_api.stride_unit, scatter_gather_api.mask_mode)
        self.dst_tensor_op = ScatterGatherOp(scatter_gather_api.dst, blk_stride='',
                                             rep_stride=scatter_gather_api.rep_stride, tensor_op_name="dst")
        self.src_tensor_op = ScatterGatherOp(scatter_gather_api.src, blk_stride='', rep_stride='', tensor_op_name="src")
        self.src_offset_tensor_op = ScatterGatherOp(scatter_gather_api.offset_tensor, blk_stride='',
                                                    rep_stride='', tensor_op_name="src_offset")
        self.repeat_times = scatter_gather_api.repeat_times
        self.base_addr = scatter_gather_api.base_addr
        self.stride_unit = scatter_gather_api.stride_unit
        # debug check instance
        self.check_params = (self.dst_tensor_op, self.src_tensor_op, self.src_offset_tensor_op,
                             self.control_op, self.base_addr)
        self.scatter_gather_check_obj = CheckParams(self.name, self.check_params)
        self.mask_o = None

    @vgather_decorator
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        # code gen
        if TikSocManager.is_v300_610l_soc() or TikSocManager.is_v210_vec_soc():
            self._vgather_code_gen_v300()
            return
        orig_ctrl = ''
        default_stride = 0

        if isinstance(self.base_addr, Scalar):
            self.base_addr = self.tik_instance.Scalar("uint32", init_value=self.base_addr)
            with self.tik_instance.context.freeze():
                with self.tik_instance.new_scope():
                    self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_S)
                    self.base_addr.set_as(self.base_addr + tvm.tir.Cast("int64", tvm.call_extern(
                        "handle", "", self.src_tensor_op.tensor_obj.access_ptr("r"))))
        else:
            self.base_addr = self.base_addr + tvm.tir.Cast("int64", tvm.call_extern(
                "handle", "", self.src_tensor_op.tensor_obj.access_ptr("r")))

        config = [self.base_addr, self.dst_tensor_op.rep_stride,
                  default_stride, self.control_op.stride_unit, self.control_op.repeat_times]
        if get_bit_len(self.src_tensor_op.tensor_obj.dtype) == BIT_LEN_16:
            dtype_str = "uint16"
        else:
            dtype_str = "uint32"
        args = concat_params(config, VSCATTER_VGATHER_XT_OFFSET_LIST, VSCATTER_VGATHER_XT_SEGMENT_LIST)
        if self.control_op.mask_mode == "counter":
            # save orig_ctrl
            orig_ctrl = set_ctrl_counter_mask(self.tik_instance)

        src_extent = reduce_mul(self.src_tensor_op.tensor_obj.original_shape) - self.src_tensor_op.tensor_obj.offset
        dst_extent = reduce_mul(self.dst_tensor_op.tensor_obj.original_shape) - self.dst_tensor_op.tensor_obj.offset
        if is_expr(src_extent):
            src_extent = src_extent.get()
        if is_expr(dst_extent):
            dst_extent = dst_extent.get()
        with self.tik_instance.new_scope():
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *self.mask_o))
            instr = tvm.call_extern(
                self.src_offset_tensor_op.tensor_obj.dtype, self.print_name,
                self.dst_tensor_op.tensor_obj.reinterpret_cast_to(dtype_str).access_ptr("w", extent=dst_extent),
                self.src_offset_tensor_op.tensor_obj.reinterpret_cast_to("uint32").access_ptr("r", extent=src_extent),
                args)
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.scope_attr(
                tvm.thread_axis("cce"), "append_mem", tvm.call_extern(
                    "handle", "mem_vector", self.src_tensor_op.tensor_obj.access_ptr("r")))
            self.tik_instance.emit(instr)

        # reset CTRL SPR as orig_ctrl
        if self.control_op.mask_mode == "counter":
            reset_ctrl_value(self.tik_instance, orig_ctrl)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.mask_o = self.scatter_gather_check_obj.check_all(self.tik_instance)
        self.gen_code()

    def _vgather_code_gen_v300(self):
        src_extent = reduce_mul(self.src_tensor_op.tensor_obj.original_shape) - self.src_tensor_op.tensor_obj.offset
        dst_extent = reduce_mul(self.dst_tensor_op.tensor_obj.original_shape) - self.dst_tensor_op.tensor_obj.offset
        if is_expr(src_extent):
            src_extent = src_extent.get()
        if is_expr(dst_extent):
            dst_extent = dst_extent.get()
        default_stride = 0
        args = [self.base_addr, self.control_op.repeat_times, self.dst_tensor_op.rep_stride, default_stride,
                self.control_op.stride_unit]
        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.tik_instance.add_source_id()
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *self.mask_o))
            instr = tvm.call_extern(
                self.src_offset_tensor_op.tensor_obj.dtype, self.print_name,
                self.dst_tensor_op.tensor_obj.access_ptr("w", extent=dst_extent),
                self.src_offset_tensor_op.tensor_obj.reinterpret_cast_to("uint32").access_ptr("r"),
                self.src_tensor_op.tensor_obj.access_ptr("r", extent=src_extent), *type_convert(args),
                self.control_op.mask_mode)
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.scope_attr(
                tvm.thread_axis("cce"), "append_mem", tvm.call_extern(
                    "handle", "mem_vector", self.src_tensor_op.tensor_obj.access_ptr("r")))
            self.tik_instance.emit(instr)


class VGatherbOps:
    """
    VGather Vector Ops
    """

    def __init__(self, tik_instance, vgatherb_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = vgatherb_api.name
        self.print_name = self.name
        self.control_op = ControlOp(mask='', repeat_times=vgatherb_api.repeat_times, stride_unit='', mask_mode='')
        self.dst_tensor_op = VGatherbOp(vgatherb_api.dst, vgatherb_api.dst_blk_stride,
                                        vgatherb_api.dst_rep_stride, tensor_op_name="dst")
        self.src_tensor_op = VGatherbOp(vgatherb_api.src, blk_stride='', rep_stride='', tensor_op_name="src")
        self.src_offsets_tensor_op = VGatherbOp(vgatherb_api.src_offsets, blk_stride='',
                                                rep_stride='', tensor_op_name="src_offsets")
        self.repeat_times = vgatherb_api.repeat_times
        self.stride_unit = 0
        # debug check instance
        self.check_params = (self.dst_tensor_op, self.src_tensor_op, self.src_offsets_tensor_op, self.control_op)
        self.vgatherb_check_obj = VGatherbCheckParams(self.name, self.check_params)
        self.mask_o = None

    @vgatherb_decorator
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        # code gen
        base_addr = tvm.tir.Cast("int64", tvm.call_extern("handle", "", self.src_tensor_op.tensor_obj.access_ptr("r")))
        if TikSocManager.is_v300_610l_soc():
            type_args = [self.src_tensor_op.tensor_obj.access_ptr("r"), self.control_op.repeat_times,
                         self.dst_tensor_op.blk_stride, self.dst_tensor_op.rep_stride]
        else:
            type_args = [base_addr, self.dst_tensor_op.rep_stride, self.dst_tensor_op.blk_stride,
                         self.control_op.repeat_times]

        if get_bit_len(self.src_tensor_op.tensor_obj.dtype) == BIT_LEN_16:
            dtype_str = "uint16"
        else:
            dtype_str = "uint32"
        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                with self.tik_instance.if_scope(self.control_op.repeat_times != 0):
                    self.tik_instance.add_source_id()
                    self.gen_instr(type_args, dtype_str)
            else:
                self.gen_instr(type_args, dtype_str)

    def gen_instr(self, type_args, dtype_str):
        """
        code gen

        Returns
        -------
        None
        """
        dst_ptr = self.dst_tensor_op.tensor_obj.reinterpret_cast_to(dtype_str).access_ptr("w")
        if TikSocManager.is_v300_610l_soc() or TikSocManager.is_v210_vec_soc():
            dst_ptr = self.dst_tensor_op.tensor_obj.access_ptr("w")
        instr = tvm.call_extern(self.src_offsets_tensor_op.tensor_obj.dtype, self.print_name, dst_ptr,
                                self.src_offsets_tensor_op.tensor_obj.reinterpret_cast_to(
                                    "uint32").access_ptr("r"), *type_convert(type_args))
        self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
        self.tik_instance.scope_attr(tvm.thread_axis("cce"), "append_mem", tvm.call_extern(
            "handle", "mem_vector", self.src_tensor_op.tensor_obj.access_ptr("r")))
        self.tik_instance.emit(instr)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.vgatherb_check_obj.check_all(self.tik_instance)
        self.gen_code()
