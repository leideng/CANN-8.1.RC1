#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_spec_single_api.py
DESC:     v210 single api, args contain scalar or not (mask, dst, src) args
CREATED:  2021-11-26 9:00
MODIFIED: 2021-11-26 9:00
"""
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import _vcvt_dtype_check
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_new_api_base import TikVectorNewApiBase
from tbe.common.platform import intrinsic_check_support
from tbe.tik.common.util import TikCheckUtil
from tbe.tik.tik_lib.tik_check_util import print_error_msg
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_params import ROUND_MODE_MAP
from tbe.tik.tik_lib.tik_params import VTRC_ROUND_MODE_MAP
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_vector import Vector
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import check_param_is_vreg
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import vfcvt_dtype_check
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import get_vector_dup_instruction_name


class TikVectorSpecSingleApi(TikVectorNewApiBase):
    """
    tik v210 special api contain scalar or not (mask, dst, src) args
    """

    @source_info_decorator()
    def vector_vmuls(self, mask, dst, src, scalar):
        """
        Multiple each element with a scalar in a vector

        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: vector scalar operation
        Returns
        -------
        None
        """
        name = "vectorized_vmuls"
        vec_op_params_ins = TikVectorSpecSingleApi.vec_op_params(name, mask, dst, src, scalar, None, None)
        self._vector_elewise_scalar_func(vec_op_params_ins, mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vmaxs(self, mask, dst, src, scalar):
        """
        Multiple each element with a scalar in a vector

        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: vector scalar operation
        Returns
        -------
        None
        """
        name = "vectorized_vmaxs"
        vec_op_params_ins = TikVectorSpecSingleApi.vec_op_params(name, mask, dst, src, scalar, None, None)
        self._vector_elewise_scalar_func(vec_op_params_ins, mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vmins(self, mask, dst, src, scalar):
        """
        Multiple each element with a scalar in a vector

        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: vector scalar operation
        Returns
        -------
        None
        """
        name = "vectorized_vmins"
        vec_op_params_ins = TikVectorSpecSingleApi.vec_op_params(name, mask, dst, src, scalar, None, None)
        self._vector_elewise_scalar_func(vec_op_params_ins, mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vadds(self, mask, dst, src, scalar):
        """
        add each element with a scalar in a vector
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: scalar operation
        Returns
        -------
        None
        """
        name = "vectorized_vadds"
        vec_op_params_ins = TikVectorSpecSingleApi.vec_op_params(name, mask, dst, src, scalar, None, None)
        self._vector_elewise_scalar_func(vec_op_params_ins, mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vshls(self, mask, dst, src, scalar):
        """
        do logic or arithmetic each element with a in a vector
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: scalar operation
        Returns
        -------
        None
        """
        name = "vectorized_vshls"
        vec_op_params_ins = TikVectorSpecSingleApi.vec_op_params(name, mask, dst, src, scalar, None, None)
        self._vector_elewise_scalar_func(vec_op_params_ins, mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vshrs(self, mask, dst, src, scalar):
        """
        do logic or arithmetic each element with a in a vector
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: scalar operation
        Returns
        -------
        None
        """
        name = "vectorized_vshrs"
        vec_op_params_ins = TikVectorSpecSingleApi.vec_op_params(name, mask, dst, src, scalar, None, None)
        self._vector_elewise_scalar_func(vec_op_params_ins, mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vaxpy(self, mask, dst, src, scalar):
        """
        do a*x + y each element with a in a vector
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: scalar operation
        Returns
        -------
        None
        """
        if TikSocManager.is_v300_610l_soc():
            mode = "MODE_MERGING"
        else:
            mode = None
        vec_op_params_ins = TikVectorSpecSingleApi.vec_op_params('vectorized_vaxpy', mask, dst, src, scalar, None, None)
        self._vector_reg_scalar_single_elewise_func(vec_op_params_ins, mode=mode)

    @source_info_decorator()
    def vector_vsadds(self, mask, dst, src, scalar):
        """
        do perfrom element-wise addition of element
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: scalar operation
        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorSpecSingleApi.vec_op_params(
            'vectorized_vsadds', mask, dst, src, scalar, None, None)
        self._vector_reg_scalar_single_elewise_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_vcbmax(self, mask, dst, dst1, src):
        """
        do vector maximum reduction instruction of element

        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        dst1: vector source operation
        src: vector source operation

        Returns
        -------
        None
        """
        vec_vcb_params_ins = TikVectorSpecSingleApi.vec_vcb_params("vectorized_vcbmax", mask, dst, dst1, src)
        return self._vector_reg_tenary_whole_reduce_func(vec_vcb_params_ins)

    @source_info_decorator()
    def vector_vcbmin(self, mask, dst, dst1, src):
        """
        do vector minimum reduction instruction of element

        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        dst1: vector source operation
        src: vector source operation

        Returns
        -------
        None
        """
        vec_vcb_params_ins = TikVectorSpecSingleApi.vec_vcb_params("vectorized_vcbmin", mask, dst, dst1, src)
        return self._vector_reg_tenary_whole_reduce_func(vec_vcb_params_ins)

    @source_info_decorator()
    def vector_cast(self, mask, dst, src, saturate_flag=False, part_indicator=None, round_mode="none"):
        """
        do vector cast instruction
        conversion between floating-point and floating-point
        conversion between floating-point and int-point
        conversion between int-point and int-point
        Parameters
        ----------
        mask: effective operation on element, only support one mode: Continuous
        dst: vector destination operator
        src: vector destination operator
        saturate_flag:
        when saturate_flag = True: do saturate instruction
        saturate_flag =False:do unsaturate instrcution
        part_indicator :
        "PART_EVEN" : even part
        "PART_ODD" : odd part
        "PART_P0":index equaling to 4*N
        "PART_P1":index equaling to 4*N +1
        "PART_P2":index equaling to 4*N +2
        "PART_P3":index equaling to 4*N +3
        round_mode:
        "": No need to round
        "none": No need to round
        "round":round to even
        "floor":round to minus infinity
        "ceil":round to positive infinity
        "ceiling":round to positive infinity
        "away-zero":round to away zero
        "to-zero":round to zero
        "odd": Von Neumann rounding
        """
        instr_name = "vectorized_cast"
        self.check_params_obj.check_vector_one_dst_one_src_params(instr_name, dst, src)
        
        if TikSocManager.is_v300_610l_soc():
            vcvt_vscvt_dtype = ["u8u16", "u8u32", "s8s16", "s8s32", "u16u8", "u16u32", "s16u8", "s16u32", "s16s32",
                                "u32u8", "u32u16", "u32s16", "s32u8", "s32u16", "s32s16", "s32s64", "s64s32"]
            vfcvt_vsfcvt_dtype = ["f32s64", "f32s32", "f32s16", "f16s32", "f16s16", "f16s8", "f16u8", "f16s32",
                                  "f32f16", "f32bf16", "f16f32", "bf16f32", "u8f16", "s8f16", "s16f16", "s16f32",
                                  "s32f32", "s64f32", "s4f16", "f16s4", "bf1632"]
        else:
            vfcvt_vsfcvt_dtype = ["f32f16", "f32s32", "f32s16", "f16f32", "f16s8", "f16u8",
                                  "f16s32", "f16s16", "u8f16", "s8f16", "s16f16", "s16f32", "s32f32"]
            vcvt_vscvt_dtype = ["u8u16", "u8u32", "s8s16", "s8s32", "u16u8", "u16u32", "s16u8",
                                "s16u32", "s16s32", "u32u8", "u32u16", "u32s16", "s32u8", "s32u16", "s32s16"]
        TikCheckUtil.check_var_in_list(round_mode, ROUND_MODE_MAP, "round_mode: %s is not supported" % round_mode)

        dtype_str = DTYPE_MAP.get(src.dtype) + DTYPE_MAP.get(dst.dtype)
        if dtype_str in vfcvt_vsfcvt_dtype:
            if not TikSocManager.is_v300_610l_soc():
                if dtype_str not in ["s32f32", "s16f16", "f16s16", "f32s32"] and mask is not None:
                    print_error_msg("when src %s cast to dst %s, mask should be None" % (src.dtype, dst.dtype))

            self.vector_vfcvt(mask, dst, src, saturate_flag, part_indicator, round_mode)
        elif dtype_str in vcvt_vscvt_dtype:
            if round_mode not in ["", "none"]:
                print_error_msg("when src %s cast to dst %s, "
                                "round_mode should be 'None' or ''" % (src.dtype, dst.dtype))
            if TikSocManager.is_v300_610l_soc():
                vec_cast_vfcvt_ins = self.vec_cast_vfcvt(
                    mask, dst, src, saturate_flag, part_indicator, None)
                _vcvt_dtype_check(vec_cast_vfcvt_ins)
                self._gen_vector_vcvt_code(vec_cast_vfcvt_ins)
            else:
                self.vector_vcvt(dst, src, saturate_flag, part_indicator)
        else:
            print_error_msg("vector_cast not support src %s cast to dst %s" % (src.dtype, dst.dtype))

    @source_info_decorator()
    def vector_vfcvt(self, mask, dst, src, saturate_index=False, part_indicator=None,
                     mode=None, literal_value="MODE_MERGING"):
        """
        do vfcvt and vsfcvt instruction
        conversion between floating-point and floating-point
        Parameters
        ----------
        literal_value
        mode
        mask: effective operation on element, only support one mode: Continuous
        dst: vector destination operator
        src: vector destination operator

        saturate_index:
        when saturate_index = True: do vsfcvt instruction
        -    saturate_index = False:do vfcvt instrcution

        1)when src.dtype = "float32" dst.dtype = "float16"
        saturate_index = False:
        part_indicator = "PART_EVEN" : even part
        -                "PART_ODD" : odd part

        mode = "ROUND_R":rount to nearest, tie to even
        -      "ROUND_O":rount to odd

        saturate_index = True:
        part_indicator : "PART_EVEN" : even part
        -                "PART_ODD" : odd part
        mode = "ROUND_R":rount to nearest, tie to even
        -      "ROUND_Z":rount to zero
        when dst vector is not initialized, literal_value = None
        other, literal_value = "MODE_MERGING"

        2)when src.dtype = "float32" dst.dtype = "int32"
        saturate_index = False:
        part_indicator = None
        mode = "ROUND_R"
        -      "ROUND_A"
        -      "ROUND_F":round to minus infinity
        -      "ROUND_C":round to positive infinity
        -      "ROUND_Z":round to zero

        saturate_index = True:
        part_indicator = None
        mode = "ROUND_R"
        -      "ROUND_A"
        -      "ROUND_F":round to minus infinity
        -      "ROUND_C":round to positive infinity
        -      "ROUND_Z":round to zero
        when dst vector is not initialized, literal_value = None
        other, literal_value = "MODE_MERGING"

        3)when src.dtype = "float32" dst.dtype = "int16"
        saturate_index = False:
        part_indicator : "PART_EVEN"
        -                "PART_ODD"
        mode = "ROUND_R"
        -      "ROUND_Z"

        4)when src.dtype = "float16" dst.dtype = "float32"
        -      src.dtype = "uint8" dst.dtype ="float16"
        -      src.dtype = "int8" dst.dtype ="float16"
        -      src.dtype = "int16" dst.dtype= "float32"
        saturate_index = False:
        part_indicator : "PART_EVEN"
        -                "PART_ODD"
        mode=None
        literal_value = None

        5) when src.dtype = "float16" dst.dtype="int8"
        -       src.dtype = "flota16" dst.dtype="uint8"
        -       src.dtype = "float16" dst.dtype="int32"
        saturate_index = False:
        part_indicator : "PART_EVEN"
        -                "PART_ODD"
        mode = "ROUND_R"
        -      "ROUND_A"
        -      "ROUND_F"
        -      "ROUND_C"
        -      "ROUND_Z"
        when src.dtype = "float16" dst.dtype="int32",literal_value = None
        others, when dst vector is not initialized, literal_value = None
        other, literal_value = "MODE_MERGING"

        6) when src.dtype = "float16" dst.dtype="int8"
        src.dtype = "flota16" dst.dtype="uint8"
        saturate_index = True:
        part_indicator : "PART_EVEN"
        -                "PART_ODD"
        mode = "ROUND_R"
        -      "ROUND_A"
        -      "ROUND_F"
        -      "ROUND_C"
        -      "ROUND_Z"
        when dst vector is not initialized, literal_value = None
        other, literal_value = "MODE_MERGING"

        7) when src.dtype = "float16" dst.dtype ="int16"
        -       src.dtype = "int16" dst.dtype ="float16"
        -       src.dtype = "int32" dst.dtype ="float32"
        saturate_index = False:
        part_indicator = None
        mode = None

        8) when src.dtype = "float16" dst.dtype ="int16"
        saturate_index = True:
        part_indicator = None
        mode = None
        when dst vector is not initialized, literal_value = None
        other, literal_value = "MODE_MERGING"

        Returns
        -------
        None
        """
        if TikSocManager.is_v300_610l_soc():
            literal_value = "MODE_ZEROING"
        vec_cast_vfcvt_ins = TikVectorSpecSingleApi.vec_cast_vfcvt(
            mask, dst, src, saturate_index, part_indicator, mode)
        vfcvt_dtype_check(vec_cast_vfcvt_ins, mode)
        dtype_str = DTYPE_MAP[src.dtype] + "2" + DTYPE_MAP[dst.dtype]
        if not TikSocManager.is_v300_610l_soc():
            if dtype_str in ["f162s32", "f162f32", "s162f32", "u82f16", "s82f16"]:
                literal_value = None
        mode = ROUND_MODE_MAP[mode]
        vec_cast_vfcvt_ins = TikVectorSpecSingleApi.vec_cast_vfcvt(
            mask, dst, src, saturate_index, part_indicator, mode)
        self._gen_vector_vfcvt_code(vec_cast_vfcvt_ins, literal_value)

    @source_info_decorator()
    def vector_vtrc(self, mask, dst, src, round_mode="None"):
        """
        do vector truncate instruction
        truncate floating-point
        Parameters
        ----------
        mask: effective operation on element, only support one mode: Continuous
        dst: vector destination operator
        src: vector destination operator
        round_mode: "round": round to nearest, tie to even(c language rint),
        -     "floor": round to minus infinity(c language floor),
        -     "ceil": round to positive infinity(c language ceil).,
        -     "away-zero": round to nearest, tie away from zero(c language round).
        -     "to-zero": round to zero(c language truncation).
        """
        instr_name = "vectorized_vtrc"
        self.check_params_obj.check_vector_one_dst_one_src_params(instr_name, dst, src)
        TikCheckUtil.check_var_in_list(round_mode, VTRC_ROUND_MODE_MAP, "round_mode: %s is not supported" % round_mode)
        mode = VTRC_ROUND_MODE_MAP.get(round_mode)
        vec_op_params_ins = TikVectorSpecSingleApi.vec_op_params(instr_name, mask, dst, src, None, None, None)
        self._gen_vector_vtrc_code(vec_op_params_ins, mode)

    @source_info_decorator()
    def vector_vdup(self, mask, dst, src, mask_mode=0, dup_flag=False):
        """
        do vdup instruction
        Parameters
        ----------
        mask: effective operation on element, only support one mode: Continuous
        dst: vector destination operator
        src: vector source operation, scalar or imm

        mask_mode:
        mask_mode is the predication mode indicator
        mode = 0: merging mode
        mode = 1: zeroing mode
        default mode = 0

        dup_flag:
        duplicate one single value in the lowest or
        the highest element position of source vector register
        when src is not vector register/scalar, dup_flag must be set as False
        mode = False, duplicate the first element of src vector register
        mode = True, duplicate the last element of src vector register
        default mode = False

        Returns
        -------
        None
        """
        name = get_vector_dup_instruction_name(src, dup_flag)
        api_name = "vector_vdup"
        TikCheckUtil.check_type_match(dst, Vector, "dst should be Vector, input type of dst: %s" % type(dst))
        TikCheckUtil.check_equality(intrinsic_check_support("Intrinsic_" + name, dst.dtype), True,
                                    gen_api_check_statement(dst.dtype, api_name))
        TikCheckUtil.check_type_match(mask_mode, int,
                                      "mask_mode must be int, input type of mask_mode: %s" % type(mask_mode))
        TikCheckUtil.check_var_in_list(mask_mode, [0, 1],
                                       "mask_mode should be 0 or 1, input mask_mode: %s" % mask_mode)
        TikCheckUtil.check_type_match(dup_flag, bool,
                                      "dup_flag must be bool, input type of dup_flag: %s" % type(dup_flag))
        if isinstance(src, Expr) and dst.dtype == "float16":
            TikCheckUtil.check_var_in_list(
                src.dtype, ["float16", "float32"],
                "For Intrinsic %s, when dst type is float16, src is Expr type, src's dtype can be float16 or float32,"
                "but input src's dtype is: %s" % (api_name, src.dtype))
        elif isinstance(src, (Scalar, Expr, Vector)):
            TikCheckUtil.check_equality(dst.dtype, src.dtype,
                                        "Intrinsic %s's src's dtype should be equal to dst's dtype, input dst's "
                                        "dtype: %s, input src's dtype: %s" % (api_name, dst.dtype, src.dtype))
            if isinstance(src, Vector):
                check_param_is_vreg(api_name, src, "src")
        if isinstance(src, (int, float, Scalar, Expr)):
            TikCheckUtil.check_equality(dup_flag, False,
                                        "only vector src supports dup_flag, input dup_flag: %s" % dup_flag)
            if isinstance(src, (int, float)):
                TikCheckUtil.check_in_range_by_dtype(src, dst.dtype,
                                                     "Variable out of range, input dtype of dst: %s" % dst.dtype)
                if "int" in dst.dtype:
                    TikCheckUtil.check_equality(
                        type(src), int, "Intrinsic %s's src's dtype should be equal to dst's dtype, input dst's "
                                        "dtype: %s, input src's dtype: %s" % (api_name, dst.dtype, "float"))
        # code gen
        vec_op_params_ins = TikVectorSpecSingleApi.vec_op_params(name, mask, dst, src, None, None, None)
        self._gen_vector_vdup_instruction_code(vec_op_params_ins, mask_mode)
