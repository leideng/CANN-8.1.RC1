#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     vector_common_util.py
DESC:     provide vector instructions
CREATED:  2021-10-28 18:53:42
"""

from tbe import tvm
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import is_immediate_number
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.tik_lib.tik_params import ONE_BYTE_BIT_LEN
from tbe.tik.tik_lib.tik_params import BLK_NUM_PER_REP
from tbe.tik.common.tik_get_soc_name import get_compatible_blk_size
from tbe.tik.common.tik_get_soc_name import get_compatible_rep_size
from tbe.tik.common.tik_get_soc_name import get_rep_size

_DEFAULT_STRIDE = 0
_STRIDE_UNIT_ZERO = 0
_STRIDE_UNIT_ONE = 1


def new_cal_extent_stride_unit_mask(control_op, tensor, blk_stride, rep_stride):
    """
    calculate extent, based on mask, stride_unit

    Parameters
    ----------
    control_op: mask, strid_unit, repeat_times, mask_mode
    tensor: dst/src tensor
    blk_stride: offset of dst/src operator between different block in one iteration
    rep_stride: offset of dst/src operator in the same block between adjacent iterations

    Returns
    -------
    extent
    """
    one_rep_size = get_compatible_rep_size()
    one_blk_size = get_compatible_blk_size()
    if control_op.mask_mode == 'counter':
        repeat = ceil_div(control_op.mask, one_rep_size // DTYPE_SIZE[tensor.dtype])
    else:  # normal
        repeat = control_op.repeat_times
    # blk_stride: stride, rep_stride: stride, unit: 32B
    if control_op.stride_unit == 0:
        extent = ((repeat - 1) * rep_stride + (BLK_NUM_PER_REP - 1) * blk_stride +
                  1) * one_blk_size
    # blk_stride: stride, rep_stride: gap, unit: 32B
    elif control_op.stride_unit == 1:
        extent = ((repeat - 1) * rep_stride +
                  repeat * ((BLK_NUM_PER_REP - 1) * blk_stride + 1)) * one_blk_size
    # blk_stride: gap, rep_stride: stride, unit: elements
    elif control_op.stride_unit == 2:
        extent = ((repeat - 1) * rep_stride + (BLK_NUM_PER_REP - 1) * blk_stride +
                  one_rep_size // DTYPE_SIZE[tensor.dtype]) * \
                 DTYPE_SIZE[tensor.dtype]
    # blk_stride: gap, rep_stride: gap, unit: elements
    else:
        extent = ((repeat - 1) * rep_stride + repeat * (
                one_rep_size // DTYPE_SIZE[tensor.dtype] +
                (BLK_NUM_PER_REP - 1) * blk_stride)) * DTYPE_SIZE[tensor.dtype]
    return Expr(extent).get()


def get_new_dst_bs(dst_blk_stride, stride_unit):
    """
    get new dst block stride

    Parameters
    ----------
    dst_blk_stride
    stride_unit

    Returns
    -------
    new_dst_bs
    """
    if is_immediate_number(dst_blk_stride) and stride_unit in (_STRIDE_UNIT_ZERO, _STRIDE_UNIT_ONE) and \
            dst_blk_stride == _DEFAULT_STRIDE:
        new_dst_bs = 1
    else:
        new_dst_bs = dst_blk_stride

    return new_dst_bs


def gen_block_list(tensor_bit_len_max, dtype):
    """
    gen block list

    Parameters
    ----------
    tensor_bit_len_max: tensor bit_len max
    dtype: dtype

    Returns
    -------

    """
    one_rep_size = get_compatible_rep_size()
    parallelism = one_rep_size * ONE_BYTE_BIT_LEN // tensor_bit_len_max
    block_len = one_rep_size // get_bit_len(dtype)
    block_list = [parallelism // block_len, block_len]
    return block_list


def gen_b64_mask_mode(mask, mask_mode=None):
    """
    generate mask mode, there are four modes: "counter","consecutive","bits",""
    mask_mode      mask           ret_value
    "counter"                    "counter"           None              ""
    "normal"     list/tuple        "bits"
    "normal"  scalar/expr/imm    "consecutive"

    Parameters
    ----------
    mask: user input mask, can be a expr/scalar/immediate/list/tuple
    mask_mode: "normal" or "counter"

    Returns
    -------
    list: [mask_mode] or [mask_mode, mask_call]("consecutive" mode)
    mask mode: "counter","consecutive","bits",""
    mask_call: call with parameter mask, only enable in "convsecutiv" mode
    """
    if mask_mode == "counter":
        return [mask_mode]  # counter mode
    elif mask is None:
        return [""]  # mask is none, mode is ""
    elif isinstance(mask, (list, tuple)):
        return ["bits"]  # bits mode
    else:  # expr/scalar/immediate
        mask_call = tvm.call_extern("int64", "mask", Expr(mask).get())
        return ["consecutive", mask_call]  # consecutive mode
