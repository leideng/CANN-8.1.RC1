#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_data_move_common.py
DESC:     tik data_move params
CREATED:  2021-10-25 14:04:45
MODIFIED: 2021-10-27 14:04:45
"""
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.tik_api_map import ASCEND_310AIC
from tbe.tik.common.tik_api_map import ASCEND_910AIC
from tbe.tik.common.tik_api_map import ASCEND_910BAIC
from tbe.tik.common.tik_api_map import ASCEND_910BVEC
from tbe.tik.common.tik_api_map import ASCEND_910_93AIC
from tbe.tik.common.tik_api_map import ASCEND_910_93VEC
from tbe.tik.common.tik_api_map import HI3796CV300CSAIC
from tbe.tik.common.tik_api_map import HI3796CV300ESAIC
from tbe.tik.common.tik_api_map import SD3403AIC
from tbe.tik.common.tik_api_map import AIC_610
from tbe.tik.common.tik_api_map import AIC_BS9SX1A
from tbe.tik.common.tik_api_map import VEC_BS9SX1A
from tbe.tik.common.tik_api_map import AIC_310P
from tbe.tik.common.tik_api_map import VEC_610
from tbe.tik.common.tik_api_map import VEC_310P
from tbe.tik.common.tik_api_map import VEC_310B
from tbe.tik.common.tik_api_map import VEC_310M
from tbe.tik.common.tik_api_map import AIC_310B
from tbe.tik.common.tik_api_map import AIC_310M
from tbe.tik.common.tik_api_map import AIC_610L
from tbe.tik.common.tik_api_map import AIC_BS9SX2A
from tbe.tik.common.tik_api_map import AIC_MC61AM21A

from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_soc_core_type
from tbe.tik.common.tik_get_soc_name import get_compatible_blk_size
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_api_constants import SCOPE_MAP
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import PIPE_MTE1
from tbe.tik.tik_lib.tik_params import PIPE_MTE2
from tbe.tik.tik_lib.tik_params import PIPE_MTE3
from tbe.tik.tik_lib.tik_params import PIPE_FIX

FROM_TENSOR_TO_TENSOR = 0
FROM_TENSORADDRLIST_TO_TENSORADDRLIST = 1
FROM_TENSORADDRLIST_TO_TENSOR = 2
FROM_TENSOR_TO_TENSORADDRLIST = 3


archversion_scope = {
    ASCEND_310AIC: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    ASCEND_910AIC: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    ASCEND_910BAIC: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    ASCEND_910BVEC: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    ASCEND_910_93AIC: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    ASCEND_910_93VEC: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    HI3796CV300ESAIC: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    HI3796CV300CSAIC: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    SD3403AIC: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    AIC_310P: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'cc_dp162ubuf', 'cc_dp322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    AIC_610: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'cc_dp162ubuf', 'cc_dp322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    VEC_610: ['gm2ubuf', 'ubuf2gm'],
    VEC_310P: ['gm2ubuf', 'ubuf2gm'],
    VEC_310B: ['gm2ubuf', 'ubuf2gm', 'ubuf2ubuf'],
    AIC_310B: ['gm2ubuf', 'ubuf2gm', 'gm2cbuf', 'cbuf2ubuf', 'ubuf2cbuf', 'ubuf2ubuf', 'cbuf2gm'],
    VEC_310M: ['gm2ubuf', 'ubuf2gm', 'ubuf2ubuf'],
    AIC_310M: ['gm2ubuf', 'ubuf2gm', 'gm2cbuf', 'cbuf2ubuf', 'ubuf2cbuf', 'ubuf2ubuf', 'cbuf2gm'],
    AIC_610L: ['gm2ubuf', 'ubuf2gm', 'gm2cbuf', 'cbuf2ubuf', 'ubuf2cbuf', 'ubuf2ubuf', 'cbuf2gm'],
    AIC_BS9SX2A: ['gm2ubuf', 'ubuf2gm', 'gm2cbuf', 'cbuf2ubuf', 'ubuf2cbuf', 'ubuf2ubuf', 'cbuf2gm'],
    AIC_MC61AM21A: ['gm2ubuf', 'ubuf2gm', 'gm2cbuf', 'cbuf2ubuf', 'ubuf2cbuf', 'ubuf2ubuf', 'cbuf2gm'],
    AIC_BS9SX1A: [
        'gm2cbuf', 'gm2ubuf', 'cbuf2ubuf',
        'cc_m162ubuf', 'cc_m322ubuf', 'cc_v162ubuf', 'cc_v322ubuf',
        'ubuf2gm', 'ubuf2cbuf', 'ubuf2ubuf',
        'ubuf2cc_m16', 'ubuf2cc_m32', 'ubuf2cc_v16', 'ubuf2cc_v32'
    ],
    VEC_BS9SX1A: ['gm2ubuf', 'ubuf2gm', 'ubuf2ubuf']
}
archversion_nd2nz = {
    ASCEND_910BAIC: ['gm2cbuf', ],
    ASCEND_910_93AIC: ['gm2cbuf', ],
}
archversion_convrelu = {
    ASCEND_310AIC: [0, 1, 2, 3, 4, 5, 6, 7],
    ASCEND_910AIC: [0, 1, 2, 3, 4, 5, 6, 7],
    ASCEND_910BAIC: [0, 1, 2, 3, 4, 5, 6, 7],
    ASCEND_910BVEC: [0, 1, 2, 3, 4, 5, 6, 7],
    ASCEND_910_93AIC: [0, 1, 2, 3, 4, 5, 6, 7],
    ASCEND_910_93VEC: [0, 1, 2, 3, 4, 5, 6, 7],
    HI3796CV300ESAIC: [0, 3, 5, 6, 7, 8, 9],
    HI3796CV300CSAIC: [0, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    SD3403AIC: [0, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    AIC_610: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    AIC_310P: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    AIC_BS9SX1A: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    VEC_BS9SX1A: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    VEC_310B: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    AIC_310B: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    VEC_310M: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    AIC_310M: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    AIC_610L: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    AIC_BS9SX2A: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    AIC_MC61AM21A: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
}
block_mode_appendix_map = {
    "": "",
    "m": "_matrix",
    "v": "_vector",
    "sc": "_small_matrix",
    "dp": "_depthwise"
}
tensor_mov_dma_list = {
    # l0c16/l0c32-ub
    ("cc_m", "ubuf"): (PIPE_V, 'copy_matrix_cc_to_ubuf'),
    # l0c16/l0c32-gm
    ("cc_m", "gm"): (PIPE_FIX, 'copy_matrix_cc_to_gm'),
    # ub-l0c16/l0c32
    ("ubuf", "cc_m"): (PIPE_V, 'copy_matrix_ubuf_to_cc'),
    # l0c16v/l0c32v-ub
    ("cc_v", "ubuf"): (PIPE_V, 'copy_vector_cc_to_ubuf'),
    # ub-l0c16v/l0c32v
    ("ubuf", "cc_v"): (PIPE_V, 'copy_vector_ubuf_to_cc'),
    # l0c32sc-ub
    ("cc_sc", "ubuf"): (PIPE_V, 'copy_small_matrix_cc_to_ubuf'),
    # ub-l0c32sc
    ("ubuf", "cc_sc"): (PIPE_V, 'copy_small_matrix_ubuf_to_cc'),
    # l0cdpf16/l0cdpf32-ub
    ("cc_dp", "ubuf"): (PIPE_V, 'copy_depthwise_cc_to_ubuf'),
    ("ubuf", "ubuf"): (PIPE_V, 'copy_ubuf_to_ubuf'),
    ("cbuf", "ubuf"): (PIPE_MTE1, 'copy_cbuf_to_ubuf'),
    ("cbuf", "cc_m"): (PIPE_MTE1, 'copy_cbuf_to_matrix_cc'),
    ("cbuf", "cc_v"): (PIPE_MTE1, 'copy_cbuf_to_vector_cc'),
    ("cbuf", "cc_sc"): (PIPE_MTE1, 'copy_cbuf_to_small_matrix_cc'),
    # LSU2
    ("gm", "cbuf"): (PIPE_MTE2, 'copy_gm_to_cbuf'),
    ("gm", "ubuf"): (PIPE_MTE2, 'copy_gm_to_ubuf'),
    # LSU3
    ("ubuf", "gm"): (PIPE_MTE3, 'copy_ubuf_to_gm'),
    ("ubuf", "cbuf"): (PIPE_MTE3, 'copy_ubuf_to_cbuf'),
    ("cbuf", "gm"): (PIPE_MTE3, 'copy_cbuf_to_gm')
}

src_dst_scope_dtype_map = {
    "gm": {
        "cbuf": [
            "u8u8", "s8s8", "f16f16", "u16u16", "s16s16", "f32f32",
            "s32s32", "u32u32", "f64f64", "u64u64", "s64s64"
        ],
        "ubuf": [
            "u8u8", "s8s8", "f16f16", "u16u16", "s16s16", "f32f32",
            "s32s32", "u32u32", "f64f64", "u64u64", "s64s64"
        ]
    },
    "cbuf": {
        "ubuf": [
            "u8u8", "s8s8", "f16f16", "u16u16", "s16s16", "f32f32",
            "s32s32", "u32u32", "f64f64", "u64u64", "s64s64"
        ],
        "cc_m":
            ["f16f16", "u16u16", "s16s16", "f32f32", "s32s32",
             "u32u32"],
        "cc_v": ["f32f32", "s32s32", "u32u32"],
        "cc_sc": ["f32f32", "s32s32", "u32u32"],
        "gm": [
            "u8u8", "s8s8", "f16f16", "u16u16", "s16s16", "f32f32",
            "s32s32", "u32u32", "f64f64", "u64u64", "s64s64"
        ]
    },
    "cc_m": {
        "ubuf": [
            "f16f16", "f32f32", "s32s32", "f32f16", "f32f16relu",
            "s32f16deq", "f16f16relu", "f32f32relu", "s32s32relu",
            "f16f16deq", "s32f16vdeq", "s32f16vdeqrelu", "s32s8vdeq8",
            "s32u8vdeq8", "s32s8vdeq8relu", "s32u8vdeq8relu",
            "s32s8deq8", "s32u8deq8", "s32s8deq8relu", "s32u8deq8relu",
            "s32f16vdeq16", "s32f16vdeq16relu", "s32f16deq16",
            "s32f16deq16relu", "s32s16vdeqs16", "s32s16vdeqs16relu",
            "s32s16deqs16", "s32s16deqs16relu", "u32u32"
        ]
    },
    "cc_v": {
        "ubuf": [
            "f16f16", "f32f32", "s32s32", "f32f16", "f32f16relu",
            "s32f16deq", "f16f16relu", "f32f32relu", "s32s32relu",
            "f16f16deq", "s32f16vdeq", "s32f16vdeqrelu", "s32s8vdeq8",
            "s32u8vdeq8", "s32s8vdeq8relu", "s32u8vdeq8relu",
            "s32s8deq8", "s32u8deq8", "s32s8deq8relu", "s32u8deq8relu",
            "s32f16vdeq16", "s32f16vdeq16relu", "s32f16deq16",
            "s32f16deq16relu", "s32s16vdeqs16", "s32s16vdeqs16relu",
            "s32s16deqs16", "s32s16deqs16relu"
        ]
    },
    "cc_sc": {
        "ubuf": [
            "f32f32", "s32s32", "s32f16deq", "f32f32relu",
            "s32s32relu", "s32f16vdeq", "s32f16vdeqrelu", "s32s8vdeq8",
            "s32u8vdeq8", "s32s8vdeq8relu", "s32u8vdeq8relu",
            "s32s8deq8", "s32u8deq8", "s32s8deq8relu", "s32u8deq8relu",
            "s32f16vdeq16", "s32f16vdeq16relu", "s32f16deq16",
            "s32f16deq16relu", "s32s16vdeqs16", "s32s16vdeqs16relu",
            "s32s16deqs16", "s32s16deqs16relu"
        ]
    },
    "cc_dp": {
        "ubuf": [
            "f16f16", "f32f32", "s32s32", "f32f16", "f32f16relu",
            "f16f16relu", "f16f16deq"
        ]
    },
    "ubuf": {
        "gm": [
            "u8u8", "s8s8", "f16f16", "u16u16", "s16s16", "f32f32",
            "s32s32", "u32u32", "f64f64", "u64u64", "s64s64"
        ],
        "cbuf": [
            "u8u8", "s8s8", "f16f16", "u16u16", "s16s16", "f32f32",
            "s32s32", "u32u32", "f64f64", "u64u64", "s64s64"
        ],
        "ubuf": [
            "u8u8", "s8s8", "f16f16", "u16u16", "s16s16", "f32f32",
            "s32s32", "u32u32", "f64f64", "u64u64", "s64s64"
        ],
        "cc_m": ["f16f16", "f32f32", "s32s32", "f32f16", "u32u32"],
        "cc_v": ["f16f16", "f32f32", "s32s32", "f32f16", "u32u32"],
        "cc_sc": ["f32f32", "s32s32", "f32f16"]
    }
}


def get_scope_str(block_mode, src, dst):
    """
    get scope in string format
    Parameters
    ----------
    block_mode: data move's mode, like "m" "v" ...
    src: src tensor
    dst: dst tensor

    Returns
    -------
    scope string
    """
    src_scope = SCOPE_MAP.get(src.scope)
    dst_scope = SCOPE_MAP.get(dst.scope)
    if src_scope == "cc":
        src_scope = src_scope + "_" + block_mode + str(get_bit_len(src.dtype))
    if dst_scope == "cc":
        dst_scope = dst_scope + "_" + block_mode + str(get_bit_len(dst.dtype))
    return src_scope + '2' + dst_scope


def _cal_burst_len_size(scope_str, src):
    """
    get the space of per burst length
    Parameters
    ----------
    block_mode: data move's mode, like "m" "v" ...
    src: src tensor
    dst: dst tensor

    Returns
    -------
    burst len size. Byte
    """
    # Byte. according to ISA DMA table
    burst_len_size_map = {
        "cc_m322ubuf": 1024,
        "cc_m162ubuf": 512,
        "cc_v322ubuf": 64,
        "cc_v162ubuf": 32,
        "cc_sc32ubuf": 256,
        "cc_dp16ubuf": 256,
        "cc_dp32ubuf": 512,
        "ubuf2cc_m32": 1024,
        "ubuf2cc_m16": 512,
        "ubuf2cc_v32": 64,
        "ubuf2cc_v16": 32,
        "ubuf2cc_sc32": 256,
    }
    if scope_str == "cc_dp32ubuf":
        if src.dtype == "f32":
            return 512
        if src.dtype == "s32":
            return 1024
    else:
        if scope_str in burst_len_size_map:
            return burst_len_size_map.get(scope_str)
    return get_compatible_blk_size()


def _cal_src_gap_block_size(scope_str, src):
    """
    get the space of per src gap block
    Parameters
    ----------
    block_mode: data move's mode, like "m" "v" ...
    src: src tensor
    dst: dst tensor

    Returns
    -------
    src block size. Byte
    """
    src_gap_size_map = {
        "cc_m322ubuf": 1024,
        "cc_m162ubuf": 512,
        "cc_v322ubuf": 1024,
        "cc_v162ubuf": 512,
        "cc_sc32ubuf": 256,
        "cc_dp16ubuf": 256,
        "cc_dp32ubuf": 512,
    }
    if scope_str == "cc_dp32ubuf":
        if src.dtype == "f32":
            return 512
        if src.dtype == "s32":
            return 1024
    else:
        if scope_str in src_gap_size_map:
            return src_gap_size_map.get(scope_str)
    return get_compatible_blk_size()


def _cal_dst_gap_block_size(scope_str):
    """
    get the space of per dst gap block
    Parameters
    ----------
    block_mode: data move's mode, like "m" "v" ...
    src: src tensor
    dst: dst tensor

    Returns
    -------
    dst block size. Byte
    """
    dst_gap_size_map = {
        "ubuf2cc_m32": 1024,
        "ubuf2cc_m16": 512,
        "ubuf2cc_v32": 1024,
        "ubuf2cc_v16": 512,
        "ubuf2cc_sc32": 256,
    }
    if scope_str in dst_gap_size_map:
        return dst_gap_size_map.get(scope_str)
    return get_compatible_blk_size()


def calculate_extent(scope_str, src, params, is_src, en_onthefly=False):
    """
    calculate data move instruction's extent

    Parameters
    ----------
    block_mode: data move's mode, like "m" "v" ...
    src: src tensor
    dst: dst tensor
    params: args
    is_src: if calculate src or calculate dst
    en_onthefly: if enable on-the-fly

    Returns
    -------
    src_extent or dst_extent
    """
    spec_byte = None
    if len(params) == 6:
        spec_byte = params[3]
    if spec_byte is None:
        burst_length_size = _cal_burst_len_size(scope_str, src)
    else:
        burst_length_size = spec_byte
    if is_src:
        gap_block_size = _cal_src_gap_block_size(scope_str, src)
    else:
        gap_block_size = _cal_dst_gap_block_size(scope_str)
        if en_onthefly:
            # if enable on-the-fly, only low 8 bits store dst_stride
            params[2] = params[2] & 0x00FF
    if len(params) == 6 and params[4] == "data_move_pad" and params[5] == "global":
        gap_block_size = 1
    extent = Expr(params[0] * params[1] * burst_length_size + (params[0] - 1) * params[2] * gap_block_size)
    return extent.get()


# aipp input format
YUV420 = 0
XRGB8888 = 1
NC1HWC0DI_FP16 = 2
NC1HWC0DI_INT8 = 3
RGB888 = 4
ARGB8888 = 5
YUYV = 6
YUV422 = 7
AYUV444 = 8
YUV400 = 9
RAW10 = 10
RAW12 = 11
RAW16 = 12
RAW24 = 15

AIPP_INIT_VALUE = 0
AIPP_ENABLE = 1
AIPP_DISABLE = 0
AIPP_INIT_FLOAT_VALUE_ZERO = 0.0
AIPP_INIT_FLOAT_VALUE_ONE = 1.0
DTC_MEAN_TYPE_UINT = 0
DTC_MEAN_TYPE_FLOAT = 1

SCALE_COF = 262144

CROP_BIT = 1
SWAP_BIT = 4
CSC_BIT = 8
DTC_BIT = 64
AREA_PAD_BIT = 256
CPAD_BIT = 512
PRE_CLIP_BIT = 2
SCF_BIT = 16
POST_CLIP_BIT = 32
FLIP_BIT = 128
STRETCH = 1024
RAW_BIT = 2048

# function format
CROP = 1
PRE_CLIP = 2
SWAP = 4
CSC = 8
SCF = 16
POST_CLIP = 32
DTC = 64
FLIP = 128
AERA_PADDING = 256
CPADDING = 512
RAW = 2048

RAW_TO_16_N = [0, 8, 9, 10, 11, 12, 13, 14, 15, 16]

DEF_VALUE = 0

HISIAICINFO = {
        YUV420: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING, PRE_CLIP, SCF,
                 POST_CLIP, FLIP, STRETCH},
        XRGB8888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING, PRE_CLIP, SCF,
                   POST_CLIP, FLIP, STRETCH},
        RGB888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING, PRE_CLIP, SCF,
                 POST_CLIP, FLIP, STRETCH},
        ARGB8888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING, PRE_CLIP, SCF,
                   POST_CLIP, FLIP, STRETCH},
        YUYV: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING, PRE_CLIP, SCF,
               POST_CLIP, FLIP, STRETCH},
        YUV422: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING, PRE_CLIP, SCF,
                 POST_CLIP, FLIP, STRETCH},
        AYUV444: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING, PRE_CLIP, SCF,
                  POST_CLIP, FLIP, STRETCH},
        YUV400: {CROP, DTC, AERA_PADDING, CPADDING, PRE_CLIP, SCF, POST_CLIP, FLIP,
                 STRETCH},
        RAW10: {CROP, DTC, CPADDING, STRETCH},
        RAW12: {CROP, DTC, CPADDING, STRETCH},
        RAW16: {CROP, DTC, CPADDING, STRETCH},
    }

V200AICINFO = {
        YUV420: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
        XRGB8888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
        NC1HWC0DI_INT8: {CROP, SWAP, CPADDING},
        NC1HWC0DI_FP16: {CROP, SWAP, CPADDING},
        RGB888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
        YUV400: {CROP, DTC, AERA_PADDING, CPADDING},
        RAW16: {CROP, DTC, CPADDING, RAW},
        RAW24: {CROP, DTC, CPADDING, RAW},
    }

BS9SX1AINFO = {
        YUV420: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
        XRGB8888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
        NC1HWC0DI_INT8: {CROP, SWAP, CPADDING},
        NC1HWC0DI_FP16: {CROP, SWAP, CPADDING},
        RGB888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
        YUV400: {CROP, CSC, DTC, AERA_PADDING, CPADDING},
        RAW16: {CROP, DTC, CPADDING, RAW}
}

V100INFO_CL = {
        YUV420: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
        XRGB8888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
        RGB888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
        YUV400: {CROP, DTC, AERA_PADDING, CPADDING},
    }

V100INFO_MI = {
    YUV420: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
    XRGB8888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
    NC1HWC0DI_INT8: {CROP, SWAP, CPADDING},
    NC1HWC0DI_FP16: {CROP, SWAP, CPADDING},
    RGB888: {CROP, SWAP, CSC, DTC, AERA_PADDING, CPADDING},
    YUV400: {CROP, DTC, AERA_PADDING, CPADDING},
}

AIPP_INPUT_VERSON_AND_FUNCTION = {
    ASCEND_310AIC: V100INFO_MI,
    ASCEND_910AIC: V100INFO_CL,
    ASCEND_910BAIC: V100INFO_CL,
    ASCEND_910_93AIC: V100INFO_CL,
    HI3796CV300ESAIC: HISIAICINFO,
    HI3796CV300CSAIC: HISIAICINFO,
    SD3403AIC: HISIAICINFO,
    AIC_310P: V200AICINFO,
    AIC_BS9SX1A: BS9SX1AINFO,
    AIC_610: V200AICINFO
}

AIPP_INPUT_TYPE_SWAP_ALIGN = {
    YUV420: {'type': 'uint8', 'channels': 3,
             'swap': [[0], [0, 1], [0]], 'addr1_align': 2, 'addr2_align': 2,
             '1src_align': 2, 'size_channel': 1.5, 'src0_size_channel': 1,
             'src1_size_channel': 0.5, 'src0_size_bytes': 1},
    XRGB8888: {'type': 'uint8', 'channels': 3,
               'swap': [[0, 1], [0], [0, 1]],
               '1src_align': 4, 'size_channel': 4},
    NC1HWC0DI_INT8: {'type': 'int8', 'channels': 5,
                     'swap': [[0, 1], [0, 1], [0]],
                     'addr1_align': 4, 'addr2_align': 2,
                     '1src_align': 2, 'size_channel': 6, 'src0_size_channel': 4,
                     'src1_size_channel': 2, 'src0_size_bytes': 4},
    NC1HWC0DI_FP16: {'type': 'float16', 'channels': 5,
                     'swap': [[0, 1], [0, 1], [0]],
                     'addr1_align': 8, 'addr2_align': 4,
                     '1src_align': 4, 'size_channel': 12,
                     'src0_size_channel': 8, 'src1_size_channel': 4,
                     'src0_size_bytes': 8},
    RGB888: {'type': 'uint8', 'channels': 3, 'swap': [[0, 1], [0], [0]],
             '1src_align': 2, 'size_channel': 3},
    ARGB8888: {'type': 'uint8', 'channels': 4,
               'swap': [[0, 1], [0], [0, 1]],
               '1src_align': 4, 'size_channel': 4},
    YUYV: {'type': ['uint8'], 'channels': 3,
           'swap': [[0], [0, 1], [0]], '1src_align': 2, 'size_channel': 2},
    YUV422: {'type': ['uint8'], 'channels': 3,
             'swap': [[0], [0, 1], [0]], 'addr1_align': 2,
             'addr2_align': 2, '1src_align': 2,
             'size_channel': 2, 'src0_size_channel': 1,
             'src1_size_channel': 1, 'src0_size_bytes': 1},
    AYUV444: {'type': ['uint8'], 'channels': 4,
              'swap': [[0], [0, 1], [0, 1]],
              '1src_align': 4, 'size_channel': 4},
    YUV400: {'type': ['uint8'], 'channels': 1,
             '1src_align': 2, 'addr1_align': 2, 'size_channel': 1},
    RAW10: {'type': ['uint16'], 'channels': 1,
            '1src_align': 2, 'size_channel': 2},
    RAW12: {'type': ['uint16'], 'channels': 1,
            '1src_align': 2, 'size_channel': 2},
    RAW16: {'type': ['uint16'], 'channels': 1,
            '1src_align': 2, 'size_channel': 2},
    RAW24: {'type': ['uint8'], 'channels': 1,
            '1src_align': 3, 'size_channel': 3}
}

# AIPP SPR
AIPP0_OFFSET_LIST = [0, 48, 56]
AIPP0_SEGMENT_LIST = [48, 8, 8]
AIPP1_OFFSET_LIST = [0, 63]
AIPP1_SEGMENT_LIST = [48, 1]
AIPP2_OFFSET_LIST = [0, 16, 32, 48]
AIPP2_SEGMENT_LIST = [16, 16, 16, 16]
AIPP3_OFFSET_LIST = [0, 16, 32, 48]
AIPP3_SEGMENT_LIST = [16, 16, 16, 16]
AIPP4_OFFSET_LIST = [0, 16, 24, 32, 40, 48, 56]
AIPP4_SEGMENT_LIST = [16, 8, 8, 8, 8, 8, 8]
AIPP5_OFFSET_LIST = [0, 16, 32, 48]
AIPP5_SEGMENT_LIST = [16, 16, 16, 16]
AIPP6_OFFSET_LIST = [0, 16, 32, 48]
AIPP6_SEGMENT_LIST = [16, 16, 16, 16]
AIPP7_OFFSET_LIST = [0, 16, 32, 48]
AIPP7_SEGMENT_LIST = [16, 16, 16, 16]
AIPP8_OFFSET_LIST = [0, 16, 32, 48]
AIPP8_SEGMENT_LIST = [16, 16, 16, 16]
AIPP9_OFFSET_LIST = [0, 16, 17, 18, 19, 24, 25, 26, 27, 29, 30, 35, 36, 38, 40, 48, 56]
AIPP9_SEGMENT_LIST = [16, 1, 1, 1, 4, 1, 1, 1, 2, 1, 5, 1, 2, 2, 1, 8, 8]
AIPP10_OFFSET_LIST = [48]
AIPP10_SEGMENT_LIST = [16]
AIPP11_OFFSET_LIST = [2, 8]
AIPP11_SEGMENT_LIST = [6, 6]
AIPP12_OFFSET_LIST = [0, 16]
AIPP12_SEGMENT_LIST = [12, 12]
AIPP13_OFFSET_LIST = [0, 2, 7, 8, 9, 10, 11]
AIPP13_SEGMENT_LIST = [1, 1, 1, 1, 1, 1, 1]
AIPP15_OFFSET_LIST = [0, 32]
AIPP15_SEGMENT_LIST = [30, 30]
AIPP16_OFFSET_LIST = [0, 32]
AIPP16_SEGMENT_LIST = [24, 24]
AIPP17_OFFSET_LIST = [0, 8, 16, 24, 61]
AIPP17_SEGMENT_LIST = [6, 6, 6, 6, 1]
AIPP_XS_OFFSET_LIST = [0, 16, 32, 48]
AIPP_XT_OFFSET_LIST = [0, 16, 24, 32, 45, 58]

# format_convert
AIPP_FORMAT_CONVERT = {

    # YUV420
    1: {
        'csc_matrix': [[298, 0, 409], [298, -100, -208], [298, 516, 0]],
        'csc_out_bias': [0, 0, 0],
        'csc_in_bias': [16, 128, 128],
    },

    2: {
        'csc_matrix': [[298, 516, 0], [298, -100, -208], [298, 0, 409]],
        'csc_out_bias': [0, 0, 0],
        'csc_in_bias': [16, 128, 128],
    },

    3: {
        'csc_matrix': [[256, 0, 0], [0, 0, 0], [0, 0, 0]],
        'csc_out_bias': [0, 0, 0],
        'csc_in_bias': [0, 0, 0],
    },

    # xrgb
    4: {
        'csc_matrix': [[66, 129, 25], [-38, -74, 112], [112, -94, -18]],
        'csc_out_bias': [16, 128, 128],
        'csc_in_bias': [0, 0, 0],
    },

    5: {
        'csc_matrix': [[66, 129, 25], [112, -94, -18], [-38, -74, 112]],
        'csc_out_bias': [16, 128, 128],
        'csc_in_bias': [0, 0, 0],
    },

    6: {
        'csc_matrix': [[76, 150, 30], [0, 0, 0], [0, 0, 0]],
        'csc_out_bias': [0, 0, 0],
        'csc_in_bias': [0, 0, 0],
    },

    # rgb
    7: {
        'csc_matrix': [[66, 129, 25], [-38, -74, 112], [112, -94, -18]],
        'csc_out_bias': [16, 128, 128],
        'csc_in_bias': [0, 0, 0],
    },

    8: {
        'csc_matrix': [[66, 129, 25], [112, -94, -18], [-38, -74, 112]],
        'csc_out_bias': [16, 128, 128],
        'csc_in_bias': [0, 0, 0],
    },

    9: {
        'csc_matrix': [[76, 150, 30], [0, 0, 0], [0, 0, 0]],
        'csc_out_bias': [0, 0, 0],
        'csc_in_bias': [0, 0, 0],
    },

    # hisi-es
    # rgb2yuv_601_narrow
    10: {
        'csc_matrix': [[1052, 2065, 401], [-607, -1192, 1799], [1799, -1506, -293]],
        'csc_out_bias': [16, 128, 128],
        'csc_in_bias': [0, 0, 0],
    },

    # rgb2yuv_601_wide
    12: {
        'csc_matrix': [[1225, 2404, 467], [-691, -1357, 2048], [2048, -1715, -333]],
        'csc_out_bias': [0, 128, 128],
        'csc_in_bias': [0, 0, 0],
    },

    # rgb2yuv_709_narrow
    14: {
        'csc_matrix': [[748, 2516, 254], [-421, -1389, 1799], [1799, -1634, -165]],
        'csc_out_bias': [16, 128, 128],
        'csc_in_bias': [0, 0, 0]
    },

    # rgb2yuv_709_narrow
    16: {
        'csc_matrix': [[871, 2929, 296], [-469, -1579, 2048], [2048, -1860, -188]],
        'csc_out_bias': [0, 128, 128],
        'csc_in_bias': [0, 0, 0]
    },

    # yuv2rgb_601_narrow
    11: {
        'csc_matrix': [[298, 0, 409], [298, -100, -208], [298, 517, 0]],
        'csc_out_bias': [0, 0, 0],
        'csc_in_bias': [16, 128, 128]
    },

    # yuv2rgb_601_wide
    13: {
        'csc_matrix': [[256, 0, 359], [256, -88, -183], [256, 454, 0]],
        'csc_out_bias': [0, 0, 0],
        'csc_in_bias': [0, 128, 128]
    },

    # yuv2rgb_601_narrow
    15: {
        'csc_matrix': [[298, 0, 459], [298, -55, -137], [298, 541, 0]],
        'csc_out_bias': [0, 0, 0],
        'csc_in_bias': [16, 128, 128]
    },

    # yuv2rgb_601_wide
    17: {
        'csc_matrix': [[256, 0, 403], [256, -48, -120], [256, 475, 0]],
        'csc_out_bias': [0, 0, 0],
        'csc_in_bias': [0, 128, 128]
    },

    # YUV400 to RGB888
    18: {
        'csc_matrix': [[256, 0, 0], [256, 0, 0], [256, 0, 0]],
        'csc_out_bias': [0, 0, 0],
        'csc_in_bias': [0, 0, 0]
    }
}


def is_610_610b_310p_aic():
    """
    use to check whether is ASCEND_610, ASCEND_610B, ASCEND_310P
    """
    soc_name = get_soc_name()
    soc_core_type = get_soc_core_type()
    arch_version = soc_name + soc_core_type
    return arch_version in (AIC_610, AIC_BS9SX1A, AIC_310P)
