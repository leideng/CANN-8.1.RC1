#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_single_api_.py
DESC:     provide vector instructions
CREATED:  2021-09-8 18:53:42
"""

import numpy as np
from tbe import tvm
from tbe.tik.tik_lib.tik_api_constants import VNCHWCONV_INSTR_APPENDIX_MAP
from tbe.tik import debug
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_data_transform_debug import vec_trans_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_data_transform_debug import vnchwconv_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vpadding_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vbcb_decorator
from tbe.tik.tik_lib.tik_util import type_convert
from tbe.tik.tik_lib.tik_util import concat_params
from tbe.tik.tik_lib.tik_util import change_dtype_str
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import PER_TRANSPOSE_DATA_SIZE
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_7
from tbe.tik.tik_lib.tik_params import DST_TYPE_LEN
from tbe.tik.tik_lib.tik_params import ONE_BYTE_BIT_LEN
from tbe.tik.tik_lib.tik_params import ONE_REP_BYTE_SIZE
from tbe.tik.tik_lib.tik_params import ONE_REP_BYTE_SIZE_FOR_NANO
from tbe.tik.tik_lib.tik_params import VPADDING_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import VPADDING_SEGMENT_LIST
from tbe.tik.tik_lib.tik_vector_api.tik_vector_name_map import FILLS_NAME_DICT
from tbe.tik.tik_lib.tik_vector_api.tik_compute_control import ControlOp
from tbe.tik.tik_lib.tik_vector_api.tik_tensor_op import TensorOp
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_fills import VpaddingCheckParams
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_fills import VnchwconvCheckParams
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_fills import VecTransCheckParams
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_fills import DupCheckParams
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_fills import VciCheckParams
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_fills import VbcbCheckParams
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_vector_api.tik_scalar_op import ScalarOp
from tbe.tik.tik_lib.tik_vector_api.tik_vcbd_op import VbcbOp
from tbe.tik.tik_lib.tik_vector_api.tik_vcbd_op import VnchwconvOp
from tbe.tik.tik_lib.tik_util import dtype_convert
from tbe.tik.tik_lib.tik_api_util import set_ctrl_counter_mask
from tbe.tik.tik_lib.tik_api_util import reset_ctrl_value
from tbe.tik.tik_lib.tik_vector_api.vector_common_util import get_new_dst_bs
from tbe.tik.tik_lib.tik_vector_api.vector_common_util import new_cal_extent_stride_unit_mask
from tbe.tik.tik_lib.tik_vector_api.vector_common_util import _STRIDE_UNIT_ZERO
from tbe.tik.tik_lib.tik_vector_api.vector_common_util import _STRIDE_UNIT_ONE
from tbe.tik.tik_lib.tik_mask_concat_ import mask_concat
from tbe.tik.common.util import is_basic_expr
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import reassign_mask
from tbe.tik.common.util import check_mask1_mask2
from tbe.tik.common.tik_get_soc_name import get_block_size
from tbe.tik.common.tik_get_soc_name import is_compatible_mode
from tbe.tik.common.tik_get_soc_name import get_compatible_blk_size
from tbe.tik.tik_lib import Expr
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_vector_api.vector_common_util import gen_b64_mask_mode

_DEFAULT_STRIDE = 0


class DupOpApi:
    """
    Vector Dup Ops
    """
    def __init__(self, tik_instance, dup_api, mask_o=None):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = FILLS_NAME_DICT.get(dup_api.name)
        self.print_name = dup_api.name
        if hasattr(dup_api, "api_name"):
            self.name = dup_api.api_name
        self.control_op = ControlOp(dup_api.mask, dup_api.repeat_times, dup_api.stride_unit, dup_api.mask_mode)
        if dup_api.name == "vci":
            self.dst_tensor_op = TensorOp(dup_api.dst, dup_api.dst_blk_stride, dup_api.dst_rep_stride, "dst_index")
            self.scalar_op = ScalarOp(dup_api.scalar, "start_point")
            self.check_params = (self.dst_tensor_op, self.scalar_op, self.control_op)
            self.check_obj = VciCheckParams(self.print_name, self.check_params, self.name)
        else:
            self.dst_tensor_op = TensorOp(dup_api.dst, dup_api.dst_blk_stride, dup_api.dst_rep_stride, "dst")
            self.scalar_op = ScalarOp(dup_api.scalar, "scalar")
            self.check_params = (self.dst_tensor_op, self.scalar_op, self.control_op)
            self.check_obj = DupCheckParams(self.print_name, self.check_params, self.name)
        self.mask_o = mask_o

    def gen_code_param_stride(self, blk_stride):
        """
        blk stride is int or scalar expr to gen code
        Parameters
        ----------
        blk_stride: blk stride

        Returns
        -------

        """
        if self.name == "vci":
            config = [self.control_op.repeat_times, blk_stride, self.dst_tensor_op.rep_stride,
                      self.control_op.stride_unit & 0b01, (self.control_op.stride_unit & 0b10) >> 1]
        elif TikSocManager.is_v200_soc() or TikSocManager.is_v210_soc():
            config = [self.control_op.repeat_times, blk_stride, _DEFAULT_STRIDE,
                      self.dst_tensor_op.rep_stride, _DEFAULT_STRIDE,
                      self.control_op.stride_unit & 0b01, (self.control_op.stride_unit & 0b10) >> 1]
        elif TikSocManager.is_nano_soc():
            config = [self.control_op.repeat_times, blk_stride, self.dst_tensor_op.rep_stride]
        else:
            config = [self.control_op.repeat_times, blk_stride, _DEFAULT_STRIDE,
                      self.dst_tensor_op.rep_stride, _DEFAULT_STRIDE]
        dst = self.dst_tensor_op.tensor_obj
        if dst.dtype == "int64":
            mask_mode = gen_b64_mask_mode(self.control_op.mask)
            config.extend(mask_mode)

        scalar_tmp = dtype_convert(self.scalar_op.scalar_obj, dst.dtype)
        if self.control_op.mask_mode == "counter":
            # save orig_ctrl
            orig_ctrl = set_ctrl_counter_mask(self.tik_instance)
        new_dst_bs = get_new_dst_bs(blk_stride, self.control_op.stride_unit)
        dst_extent = new_cal_extent_stride_unit_mask(self.control_op, self.dst_tensor_op.tensor_obj, new_dst_bs,
                                                     self.dst_tensor_op.rep_stride)

        if self.control_op.stride_unit in (_STRIDE_UNIT_ZERO, _STRIDE_UNIT_ONE) and \
                is_basic_expr(blk_stride):
            dst_extent = dst_extent + ONE_REP_BYTE_SIZE

        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.tik_instance.add_source_id()
            instr = tvm.call_extern(dst.dtype, self.name, dst.access_ptr("w", extent=dst_extent),
                                    scalar_tmp, *type_convert(config))
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *self.mask_o))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(instr)

        # reset CTRL SPR as orig_ctrl
        if self.control_op.mask_mode == "counter":
            reset_ctrl_value(self.tik_instance, orig_ctrl)

    @debug.vec_scalar_elewise_func_dec_new
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """

        if self.name == "vector_dup":
            if isinstance(self.dst_tensor_op.blk_stride, int):
                if self.dst_tensor_op.blk_stride == 0:
                    self.dst_tensor_op.blk_stride = 1
                self.gen_code_param_stride(self.dst_tensor_op.blk_stride)
            else:
                with self.tik_instance.if_scope(self.dst_tensor_op.blk_stride == 0):
                    self.dst_tensor_op.blk_stride.set_as(1)
                self.gen_code_param_stride(self.dst_tensor_op.blk_stride)
        else:
            self.gen_code_param_stride(self.dst_tensor_op.blk_stride)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        mask_o = self.check_obj.check_all(self.tik_instance)
        if self.mask_o is None:
            self.mask_o = mask_o
        self.gen_code()



class NanoDupOpApi(DupOpApi):
    """
    Vector Dup Ops in Nano
    """
    def blklen_16_gen_code(self, params_list):
        """
        run all_check and code_gen for nano

        Parameters
        ----------
        params_list : dst, blk_stride, rep_stride, mask_o

        Returns
        -------
        None
        """
        dst, blk_stride, rep_stride, mask_o = params_list

        config = [self.control_op.repeat_times, blk_stride, rep_stride]
        scalar_tmp = dtype_convert(self.scalar_op.scalar_obj, dst.dtype)
        if self.control_op.mask_mode == "counter":
            # save orig_ctrl
            orig_ctrl = set_ctrl_counter_mask(self.tik_instance)
        new_dst_bs = get_new_dst_bs(blk_stride, self.control_op.stride_unit)
        dst_extent = new_cal_extent_stride_unit_mask(self.control_op, dst, new_dst_bs, rep_stride)

        if self.control_op.stride_unit in (_STRIDE_UNIT_ZERO, _STRIDE_UNIT_ONE) and is_basic_expr(blk_stride):
            dst_extent = dst_extent + ONE_REP_BYTE_SIZE_FOR_NANO

        with self.tik_instance.new_scope():
            instr = tvm.call_extern(dst.dtype, self.name, dst.access_ptr("w", extent=dst_extent),
                                    scalar_tmp, *type_convert(config))
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *mask_o))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(instr)

        # reset CTRL SPR as orig_ctrl
        if self.control_op.mask_mode == "counter":
            reset_ctrl_value(self.tik_instance, orig_ctrl)

    def convert_zero_blk_stride(self):
        """
        convert the blk_stride to 1 if the blk_stride is 0

        Returns
        -------
        None
        """
        if isinstance(self.dst_tensor_op.blk_stride, int):
            if self.dst_tensor_op.blk_stride == 0:
                self.dst_tensor_op.blk_stride = 1
        else:
            with self.tik_instance.if_scope(self.dst_tensor_op.blk_stride == 0):
                self.dst_tensor_op.blk_stride.set_as(1)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """


        if not is_compatible_mode():
            mask_o = self.check_obj.check_all(self.tik_instance)
            self.convert_zero_blk_stride()
            self.blklen_16_gen_code((self.dst_tensor_op.tensor_obj, self.dst_tensor_op.blk_stride,
                                     self.dst_tensor_op.rep_stride, mask_o))
        else:
            self.check_obj.check_all(self.tik_instance)
            tensor_bit_len = get_bit_len(self.dst_tensor_op.tensor_obj.dtype)
            one_block_elements = get_block_size() // DTYPE_SIZE[self.dst_tensor_op.tensor_obj.dtype]
            mask1, mask2 = reassign_mask(self.tik_instance, self.control_op.mask, one_block_elements)
            enable_mask1, enable_mask2 = check_mask1_mask2(mask1, mask2)
            self.convert_zero_blk_stride()
            if enable_mask1:
                mask_o1 = mask_concat(self.tik_instance, mask1, tensor_bit_len=tensor_bit_len)
                self.blklen_16_gen_code((self.dst_tensor_op.tensor_obj, 2 * self.dst_tensor_op.blk_stride,
                                         2 * self.dst_tensor_op.rep_stride, mask_o1))
            if enable_mask2:
                one_block_elements = self.tik_instance.Scalar(name="one_block_elements", init_value=one_block_elements)
                mask_o2 = mask_concat(self.tik_instance, mask2, tensor_bit_len=tensor_bit_len)
                self.blklen_16_gen_code((self.dst_tensor_op.tensor_obj[one_block_elements:],
                                         2 * self.dst_tensor_op.blk_stride,
                                         2 * self.dst_tensor_op.rep_stride, mask_o2))


class VpaddingOpApi:
    """
    vector padding ops
    """
    def __init__(self, tik_instance, vpadding_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = vpadding_api.name
        self.print_name = vpadding_api.name
        self.control_op = ControlOp(vpadding_api.mask, vpadding_api.repeat_times, vpadding_api.stride_unit,
                                    vpadding_api.mask_mode)
        self.dst_tensor_op = TensorOp(vpadding_api.dst, vpadding_api.dst_blk_stride, vpadding_api.dst_rep_stride, "dst")
        self.src_tensor_op = TensorOp(vpadding_api.src, vpadding_api.src_blk_stride, vpadding_api.src_rep_stride, "src")
        self.check_params = (self.dst_tensor_op, self.src_tensor_op, self.control_op)
        self.pad_mode = vpadding_api.pad_mode
        self.pad_side = vpadding_api.pad_side
        self.vpadding_check_obj = VpaddingCheckParams(self.name, self.check_params, self.pad_mode, self.pad_side)
        self.mask_o = None

    @vpadding_decorator
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        if self.pad_side == "left":
            pad_side_t = 0
        else:
            pad_side_t = 1
        # change dtype_str
        dtype_str = change_dtype_str(self.dst_tensor_op.tensor_obj)
        dst_extent = new_cal_extent_stride_unit_mask(self.control_op, self.dst_tensor_op.tensor_obj,
                                                     self.dst_tensor_op.blk_stride, self.dst_tensor_op.rep_stride)
        src_extent = new_cal_extent_stride_unit_mask(self.control_op, self.src_tensor_op.tensor_obj,
                                                     self.src_tensor_op.blk_stride, self.src_tensor_op.rep_stride)
        config = [self.dst_tensor_op.blk_stride, self.src_tensor_op.blk_stride, self.dst_tensor_op.rep_stride,
                  self.src_tensor_op.rep_stride, self.pad_mode, pad_side_t, self.control_op.stride_unit,
                  self.control_op.repeat_times]
        args = concat_params(config, VPADDING_OFFSET_LIST, VPADDING_SEGMENT_LIST)
        if self.control_op.mask_mode == "counter":
            # save orig_ctrl
            orig_ctrl = set_ctrl_counter_mask(self.tik_instance)
        else:
            orig_ctrl = ""
        with self.tik_instance.new_scope():
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *self.mask_o))
            instr = tvm.call_extern(
                self.dst_tensor_op.tensor_obj.dtype, self.name,
                self.dst_tensor_op.tensor_obj.reinterpret_cast_to(dtype_str).access_ptr("w", extent=dst_extent),
                self.src_tensor_op.tensor_obj.reinterpret_cast_to(dtype_str).access_ptr("r", extent=src_extent), args)

            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(instr)

        # reset CTRL SPR as orig_ctrl
        if self.control_op.mask_mode == "counter":
            reset_ctrl_value(self.tik_instance, orig_ctrl)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.mask_o = self.vpadding_check_obj.check_all(self.tik_instance)
        self.gen_code()


class VbcbOpApi:
    """
    vector vbcb ops
    """
    def __init__(self, tik_instance, vbcb_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.print_name = FILLS_NAME_DICT.get(vbcb_api.name)
        self.name = vbcb_api.name
        self.control_op = ControlOp(repeat_times=vbcb_api.repeat_times)
        self.dst_tensor_op = VbcbOp(vbcb_api.dst, vbcb_api.dst_blk_stride, vbcb_api.dst_rep_stride, "dst")
        self.src_tensor_op = VbcbOp(vbcb_api.src, blk_stride=None, rep_stride=None, tensor_op_name="src")
        # debug check instance
        self.check_params = (self.dst_tensor_op, self.src_tensor_op, self.control_op)
        self.vbcb_check_obj = VbcbCheckParams(self.name, self.check_params)
        self.mask_o = None

    @source_info_decorator()
    @vbcb_decorator
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        if TikSocManager.is_v300_610l_soc():
            type_args = [self.control_op.repeat_times, self.dst_tensor_op.blk_stride, self.dst_tensor_op.blk_stride,
                         self.dst_tensor_op.rep_stride]
        else:
            type_args = [self.dst_tensor_op.blk_stride, self.dst_tensor_op.rep_stride, self.control_op.repeat_times]

        if get_bit_len(self.dst_tensor_op.tensor_obj.dtype) == DST_TYPE_LEN:
            dtype_str = "uint16"
        else:
            dtype_str = "uint32"

        src_extent = Expr(self.control_op.repeat_times * ONE_BYTE_BIT_LEN * ONE_BLK_SIZE)
        rep_extent = (self.control_op.repeat_times - 1) * self.dst_tensor_op.blk_stride
        blk_extent = SHIFT_BIT_POS_7 * self.dst_tensor_op.blk_stride + 1
        dst_extent = Expr((rep_extent + blk_extent) * ONE_BLK_SIZE)
        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.tik_instance.add_source_id()
            instr = tvm.call_extern(
                self.dst_tensor_op.tensor_obj.dtype, self.print_name,
                self.dst_tensor_op.tensor_obj.reinterpret_cast_to(dtype_str).access_ptr("w", extent=src_extent.get()),
                self.src_tensor_op.tensor_obj.reinterpret_cast_to(dtype_str).access_ptr("r", extent=dst_extent.get()),
                *type_convert(type_args))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(instr)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.vbcb_check_obj.check_all()
        self.gen_code()


class NanoVbcbOpApi(VbcbOpApi):
    """
    vector vbcb ops
    """

    @source_info_decorator()
    def blklen_16_gen_code(self, params_list):
        """
        code gen

        Returns
        -------
        None
        """
        blk_size = get_compatible_blk_size()
        dst, src, dst_blk_stride, dst_rep_stride, repeat_times = params_list
        type_args = [repeat_times, dst_blk_stride, dst_rep_stride]
        src_extent = Expr(self.control_op.repeat_times * ONE_BYTE_BIT_LEN * blk_size)
        rep_extent = (self.control_op.repeat_times - 1) * self.dst_tensor_op.blk_stride
        blk_extent = SHIFT_BIT_POS_7 * self.dst_tensor_op.blk_stride + 1
        dst_extent = Expr((rep_extent + blk_extent) * blk_size)
        with self.tik_instance.new_scope():
            instr = tvm.call_extern(dst.dtype, self.print_name,
                                    dst.access_ptr("w", extent=src_extent.get()),
                                    src.access_ptr("r", extent=dst_extent.get()), *type_convert(type_args))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(instr)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.vbcb_check_obj.check_all()
        if not is_compatible_mode():
            self.blklen_16_gen_code((self.dst_tensor_op.tensor_obj, self.src_tensor_op.tensor_obj,
                                    self.dst_tensor_op.blk_stride, self.dst_tensor_op.rep_stride,
                                    self.control_op.repeat_times))
        else:
            one_block_elements = get_block_size() // DTYPE_SIZE[self.dst_tensor_op.tensor_obj.dtype]
            one_block_elements = self.tik_instance.Scalar(name="one_block_elements", init_value=one_block_elements)
            self.blklen_16_gen_code((self.dst_tensor_op.tensor_obj, self.src_tensor_op.tensor_obj,
                                    2 * self.dst_tensor_op.blk_stride, 2 * self.dst_tensor_op.rep_stride,
                                    self.control_op.repeat_times))
            self.blklen_16_gen_code((self.dst_tensor_op.tensor_obj[one_block_elements:],
                                    self.src_tensor_op.tensor_obj,
                                    2 * self.dst_tensor_op.blk_stride, 2 * self.dst_tensor_op.rep_stride,
                                    self.control_op.repeat_times))


class VecTransApi:
    """
    vector vbcb ops
    """
    def __init__(self, tik_instance, vec_trans_api, name):
        self.tik_instance = tik_instance
        self.name = name
        self.control_op = ControlOp(repeat_times=vec_trans_api.repeat_times)
        self.dst_tensor_op = TensorOp(vec_trans_api.dst, None, vec_trans_api.dst_rep_stride, "dst")
        self.src_tensor_op = TensorOp(vec_trans_api.src, None, vec_trans_api.src_rep_stride, "src")
        # debug check instance
        self.check_params = (self.dst_tensor_op, self.src_tensor_op, self.control_op)
        self.vec_trans_check_obj = VecTransCheckParams(self.name, self.check_params)
        self.mask_o = None

    @source_info_decorator()
    @vec_trans_decorator
    def gen_code(self):
        """
        vec_trans code gen

        Parameter
        ----------
        vec_trans_api: vec_trans_api

        Returns
        ----------
        """
        # data type is B16, 2Bytes
        extent_value = PER_TRANSPOSE_DATA_SIZE*2
        extent = Expr(extent_value)
        if self.dst_tensor_op.tensor_obj.dtype in ("int16", "uint16", "float16"):
            dtype = "uint16"
        else:
            dtype = "uint8"
        # deal with input params are scalar
        with self.tik_instance.new_scope():
            # 2 is size of b16, 2 Bytes
            # one ir is call_extern
            with self.tik_instance.for_range(0, self.control_op.repeat_times) as index:
                self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
                dst_offset = Expr(self.dst_tensor_op.rep_stride*PER_TRANSPOSE_DATA_SIZE*index)
                src_offset = Expr(self.src_tensor_op.rep_stride*PER_TRANSPOSE_DATA_SIZE*index)
                self.tik_instance.emit(tvm.call_extern(self.dst_tensor_op.tensor_obj.dtype, "vtranspose",
                                                       self.dst_tensor_op.tensor_obj.reinterpret_cast_to(dtype).
                                                       access_ptr("w", extent=extent.get(), offset=dst_offset.get()),
                                                       self.src_tensor_op.tensor_obj.reinterpret_cast_to(dtype).
                                                       access_ptr("r", extent=extent.get(), offset=src_offset.get())))

    @source_info_decorator()
    @vec_trans_decorator
    def v210_vec_gen_code(self):
        """
        vec_trans code gen

        Parameter
        ----------
        vec_trans_api: vec_trans_api

        Returns
        ----------
        """
        extent_value = PER_TRANSPOSE_DATA_SIZE*2
        extent = Expr(extent_value)
        config = [self.control_op.repeat_times, self.dst_tensor_op.rep_stride, self.src_tensor_op.rep_stride]
        with self.tik_instance.new_scope():
            instr = tvm.call_extern(self.dst_tensor_op.tensor_obj.dtype, "vtrans",
                                    self.dst_tensor_op.tensor_obj.access_ptr("w", extent=extent.get()),
                                    self.src_tensor_op.tensor_obj.access_ptr("r", extent=extent.get()),
                                    *type_convert(config))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(instr)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.vec_trans_check_obj.check_all()
        if TikSocManager.is_v210_vec_soc():
            self.v210_vec_gen_code()
        else:
            self.gen_code()


class NanoVecTransApi(VecTransApi):
    """
    nano vtranspose
    """
    @source_info_decorator()
    def nano_compatible_gen_code(self):
        """
        vec_trans code gen

        Parameter
        ----------
        vec_trans_api: vec_trans_api

        Returns
        ----------
        """
        dst_list, src_list = [], []
        for i in range(16):
            dst_list.append(self.dst_tensor_op.tensor_obj[i*16:])
            src_list.append(self.src_tensor_op.tensor_obj[i*16:])

        self.tik_instance.vec_trans_scatter(False, False, dst_list, src_list,
                                            self.control_op.repeat_times,
                                            16 * self.dst_tensor_op.rep_stride,
                                            16 * self.src_tensor_op.rep_stride)
        self.tik_instance.set_high_level_api_state()

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.vec_trans_check_obj.check_all()
        if is_compatible_mode():
            self.nano_compatible_gen_code()
            self.tik_instance.set_high_level_api_state()
        else:
            self.gen_code()


class VnchwconvApi:
    """
    vector vnchwconv ops
    """
    def __init__(self, tik_instance, vnchwconv_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = vnchwconv_api.name
        self.dst_high_half = vnchwconv_api.dst_high_half
        self.src_high_half = vnchwconv_api.src_high_half
        self.control_op = ControlOp(repeat_times=vnchwconv_api.repeat_times)
        self.dst_tensor_op = VnchwconvOp(vnchwconv_api.dst_list, None, vnchwconv_api.dst_rep_stride, "dst_list")
        self.src_tensor_op = VnchwconvOp(vnchwconv_api.src_list, None, vnchwconv_api.src_rep_stride, "src_list")
        # debug check instance
        self.check_params = (self.dst_tensor_op, self.src_tensor_op, self.control_op,
                             self.dst_high_half, self.src_high_half)
        self.vnchwconv_check_obj = VnchwconvCheckParams(self.name, self.check_params)
        self.mask_o = None

    @staticmethod
    def _get_extents(repeat_times, dst_rep_stride, src_rep_stride):
        """
        Parameters
        ----------
        repeat_times : int, Repeated iterations times
        dst_rep_stride : int, offset of dst operator in the same block between adjacent iterations
        src_rep_stride : int, offset of src operator in the same block between adjacent iterations

        Returns
        -------
        the extents
        """
        dst_extent = Expr(((repeat_times - 1) * dst_rep_stride + 1) * ONE_BLK_SIZE).get()
        src_extent = Expr(((repeat_times - 1) * src_rep_stride + 1) * ONE_BLK_SIZE).get()
        return [dst_extent, src_extent]

    @staticmethod
    def _dtype_convert(value, dtype):
        """
        Get target's scope

        Parameters
        ----------
        value : int, The scope value
        dtype : str, The scope dtype

        Returns
        -------
        the key of scope
        """
        valuet = type_convert(value)
        return valuet.astype(dtype)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.vnchwconv_check_obj.check_all()
        self.gen_code()

    @vnchwconv_decorator
    def gen_code(self):
        """
        vec_trans code gen

        Parameter
        ----------
        vec_trans_api: vec_trans_api

        Returns
        ----------
        """
        # code gen
        with self.tik_instance.context.freeze():
            with self.tik_instance.if_scope(self.control_op.repeat_times == 1):
                self._gen_code(0, 0)
            with self.tik_instance.else_scope():
                self._gen_code(self.dst_tensor_op.rep_stride, self.src_tensor_op.rep_stride)

    def _gen_code(self, dst_rep_stride, src_rep_stride):
        dtype_str = self.dst_tensor_op.get_dtype_str(self.src_tensor_op.tensor_obj, self.dst_tensor_op.tensor_obj,
                                                     self.name)

        config = [self._dtype_convert(self.control_op.repeat_times, "int64"), dst_rep_stride, src_rep_stride]
        if VNCHWCONV_INSTR_APPENDIX_MAP[dtype_str] == "b8" and not TikSocManager.is_nano_soc():
            config.append(int(self.dst_high_half))
            config.append(int(self.src_high_half))
        if TikSocManager.is_v210_vec_soc():
            self.tik_instance.v210_config_var(
                [self.dst_tensor_op.tensor_obj, self.src_tensor_op.tensor_obj], dtype_str, config)
        else:
            # The fourth parameter is [dst_extent, src_extent]
            extents = self._get_extents(
                self.control_op.repeat_times, dst_rep_stride, src_rep_stride)
            self.tik_instance.config_vas(
                [self.dst_tensor_op.tensor_obj, self.src_tensor_op.tensor_obj], dtype_str, config, extents)
