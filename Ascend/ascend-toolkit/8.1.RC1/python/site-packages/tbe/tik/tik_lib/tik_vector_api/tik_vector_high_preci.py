#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vecotr_high_preci.py
DESC:     provide vector instructions
CREATED:  2021-12-18 11:02:42
MODIFIED: 2021-12-18 11:17:00
"""
from collections import namedtuple
from tbe.common.platform import ASCEND_310
from tbe.common.platform.platform_info import api_check_support
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import is_immediate_number
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.common_nametuple_util import VecDupApi
from tbe.tik.common.common_nametuple_util import VecSelApi
from tbe.tik.common.common_nametuple_util import VecVcmpvApi
from tbe.tik.common.common_nametuple_util import OverHighApi
from tbe.tik.common.common_nametuple_util import VecSingleApi
from tbe.tik.common.common_nametuple_util import HighPreciParams
from tbe.tik.common.common_nametuple_util import VecScalarMultisApi
from tbe.tik.common.common_nametuple_util import VecVcmpApi
from tbe.tik.common.common_nametuple_util import VecMultiApi
from tbe.tik.common.common_nametuple_util import TaylorTuple
from tbe.tik.common.check_over_high_preci_common import check_over_high_preci
from tbe.tik.common.common_check_func import check_mask_valid
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.high_preci_common_util import HighPreciCommonUtil
from tbe.tik.tik_lib.tik_params import MIN_STRIDE
from tbe.tik.tik_lib.tik_params import MIN_STRIDE_UNIT
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_params import CONST_NEG_FOUR_THREE
from tbe.tik.tik_lib.tik_params import LOG_FOUR_THREE
from tbe.tik.tik_lib.tik_params import CONST_FIVE_THREE
from tbe.tik.tik_lib.tik_params import CONST_ONE_THREE
from tbe.tik.tik_lib.tik_params import CONST_ONE
from tbe.tik.tik_lib.tik_params import CONST_NEG_ONE
from tbe.tik.tik_lib.tik_params import CONST_ONE_FIVE
from tbe.tik.tik_lib.tik_params import CONST_THREE_FOUR
from tbe.tik.tik_lib.tik_params import CONST_NEG_HALF
from tbe.tik.tik_lib.tik_params import CONST_NEG_ONE_FOUR
from tbe.tik.tik_lib.tik_params import CONST_HALF
from tbe.tik.tik_lib.tik_params import CONST_ONE_NINE
from tbe.tik.tik_lib.tik_params import CONST_NEG_ONE_SIX
from tbe.tik.tik_lib.tik_params import CONST_NEG_ONE_EIGHT
from tbe.tik.tik_lib.tik_params import CONST_ONE_SEVEN
from tbe.tik.tik_lib.tik_vector_api.tik_scalar_multis_api_ import ScalarMultisOps
from tbe.tik.tik_lib.tik_vector_api.tik_vector_fills_api_ import DupOpApi
from tbe.tik.tik_lib.tik_vector_api.tik_vector_compare_api_ import VcmpOpApi
from tbe.tik.tik_lib.tik_vector_api.tik_vector_compare_api_ import VcmpvOpApi
from tbe.tik.tik_lib.tik_vector_api.tik_vector_multi_api_ import MultiOp
from tbe.tik.tik_lib.tik_vector_api.tik_vector_single_api_ import SingleOpApi
from tbe.tik.tik_lib.tik_vector_api_ import TikVectorApi
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_api_util import check_high_preci_param
from tbe.tik.tik_lib.tik_mask_concat_ import mask_concat
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.debug.decorators import high_level_api_debug_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_high_preci_debug import vexpm1_high_preci_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_high_preci_debug import vec_ln_high_preci_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_high_preci_debug import vrec_high_preci_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_high_preci_debug import vrsqrt_high_preci_decorator


class TikHighPrec(TikVectorApi):
    """
    High Prec Api
    """

    stride_unit = 0

    @staticmethod
    def check_vexpm1_params(vexpm_high_params):
        """
        check vexpm1 params
        """
        # params check
        high_preci_api = HighPreciParams(vexpm_high_params.dst, vexpm_high_params.src,
                                         vexpm_high_params.work_tensor, vexpm_high_params.repeat_times,
                                         vexpm_high_params.dst_rep_stride, vexpm_high_params.src_rep_stride)
        check_high_preci_param(high_preci_api)
        TikCheckUtil.check_equality(vexpm_high_params.work_tensor.dtype, vexpm_high_params.dst.dtype,
                                    "work_tensor's dtype must be same with dst's dtype")
        TikCheckUtil.check_equality(api_check_support("tik." + vexpm_high_params.name,
                                                      vexpm_high_params.dst.dtype), True,
                                    gen_api_check_statement(vexpm_high_params.dst.dtype, vexpm_high_params.name))
        # check mask
        check_mask_valid(vexpm_high_params.mask, tensor_bit_len=max(get_bit_len(vexpm_high_params.src.dtype),
                                                                    get_bit_len(vexpm_high_params.dst.dtype)))
        multi_factor = 11
        over_high = OverHighApi(
            vexpm_high_params.mask, vexpm_high_params.dst, vexpm_high_params.src, vexpm_high_params.work_tensor,
            vexpm_high_params.repeat_times, vexpm_high_params.dst_rep_stride, vexpm_high_params.src_rep_stride,
            Expr(vexpm_high_params.dst.offset).eval_value(), Expr(vexpm_high_params.src.offset).eval_value(),
            Expr(vexpm_high_params.work_tensor.offset).eval_value(), multi_factor, vexpm_high_params.name)
        check_over_high_preci(over_high)

    @staticmethod
    def _vrec_high_prec_check(vrec_api, instr_name, mask):
        """
        check params and return src_bit_len, multi_factor
        Parameters
        ----------
        vrec_api: vrec params
        instr_name: instr name
        mask: mask

        Returns
        -------
        """
        # params check
        check_high_preci_param(vrec_api)
        TikCheckUtil.check_equality(
            vrec_api.work_tensor.dtype, "float32",
            "work_tensor dtype should be float32, but input dtype: %s" % vrec_api.work_tensor.dtype)
        TikCheckUtil.check_equality(api_check_support("tik." + instr_name, vrec_api.dst.dtype), True,
                                    gen_api_check_statement(vrec_api.dst.dtype, instr_name))

        src_bit_len = get_bit_len(vrec_api.src.dtype)
        dst_bit_len = get_bit_len(vrec_api.dst.dtype)
        check_mask_valid(mask, tensor_bit_len=max(src_bit_len, dst_bit_len))
        multi_factor = 2
        if vrec_api.src.dtype == "float16":
            # 4B of fp32, need keep 32B algin
            multi_factor += 2
        # check overflow and overlap
        over_high = OverHighApi(
            mask, vrec_api.dst, vrec_api.src, vrec_api.work_tensor, vrec_api.repeat_times, vrec_api.dst_rep_stride,
            vrec_api.src_rep_stride, Expr(vrec_api.dst.offset).eval_value(), Expr(vrec_api.src.offset).eval_value(),
            Expr(vrec_api.work_tensor.offset).eval_value(), multi_factor, instr_name)
        check_over_high_preci(over_high)
        return src_bit_len, multi_factor

    @staticmethod
    def _check_vrsqrt_high_preci(vrsqrt_high_params, instr_name):
        """
        check vrsqrt high preci
        Parameters
        ----------
        vrsqrt_high_params: vrsqrt high params
        instr_name: instr name
        """
        high_preci_api = HighPreciParams(vrsqrt_high_params.dst, vrsqrt_high_params.src,
                                         vrsqrt_high_params.work_tensor, vrsqrt_high_params.repeat_times,
                                         vrsqrt_high_params.dst_rep_stride, vrsqrt_high_params.src_rep_stride)
        check_high_preci_param(high_preci_api)
        TikCheckUtil.check_equality(vrsqrt_high_params.work_tensor.dtype, "float32",
                                    "work_tensor's dtype should be float32, input: %s"
                                    % vrsqrt_high_params.work_tensor.dtype)
        TikCheckUtil.check_equality(api_check_support("tik." + instr_name, vrsqrt_high_params.dst.dtype), True,
                                    gen_api_check_statement(vrsqrt_high_params.dst.dtype, instr_name))
        # check mask
        check_mask_valid(vrsqrt_high_params.mask, tensor_bit_len=max(get_bit_len(vrsqrt_high_params.src.dtype),
                                                                     get_bit_len(vrsqrt_high_params.dst.dtype)))

    @vexpm1_high_preci_decorator
    def vexpm_high_preci(self, vexpm_high_params):
        with self.context.freeze():
            self.vexpm_high_preci_codegen(vexpm_high_params)

    @high_level_api_debug_decorator
    def vexpm_high_preci_high_level(self, vexpm_high_params):
        self.vexpm_high_preci_codegen(vexpm_high_params)

    def vexpm_high_preci_codegen(self, vexpm_high_params):
        """
        gen vexpm high preci

        Parameters
        ----------
        vexpm_high_params: namedtuple of vexpm_high_params
        """
        self.check_vexpm1_params(vexpm_high_params)

        default_rep_stride = self._gen_exm_rep_stride(vexpm_high_params)
        default_mask = 128
        extent = self.get_wk_tensor_extend(default_mask, vexpm_high_params.src.dtype,
                                            vexpm_high_params.repeat_times, default_rep_stride)
        mask_o = mask_concat(self, vexpm_high_params.mask,
                                tensor_bit_len=get_bit_len(vexpm_high_params.src.dtype))

        params_dict = {"src": vexpm_high_params.src, "mask": vexpm_high_params.mask,
                        "work_tensor": vexpm_high_params.work_tensor,
                        "repeat_times": vexpm_high_params.repeat_times,
                        "src_rep_stride": vexpm_high_params.src_rep_stride}
        cmp_sel = self._gen_comparator(params_dict, extent, vexpm_high_params.name, mask_o)
        expm1_params = namedtuple('Expm1Api', ["name", "mask", "dst", "work_tensor", "src", "repeat_times",
                                                "dst_rep_stride", "wk_rep_stride", "src_rep_stride", "mask_o"])
        expm1_params = expm1_params(vexpm_high_params.name, vexpm_high_params.mask,
                                    vexpm_high_params.work_tensor[extent:2 * extent],
                                    vexpm_high_params.work_tensor[2 * extent:3 * extent],
                                    vexpm_high_params.src, vexpm_high_params.repeat_times,
                                    vexpm_high_params.src_rep_stride, vexpm_high_params.src_rep_stride,
                                    vexpm_high_params.src_rep_stride, mask_o)
        self._expm1(expm1_params)
        high_prec_api = TikVectorApi.high_prec_api(
            self._expm1_taylor, vexpm_high_params.name, vexpm_high_params.mask,
            vexpm_high_params.work_tensor[2 * extent:3 * extent], vexpm_high_params.src,
            vexpm_high_params.work_tensor[3 * extent:], vexpm_high_params.repeat_times,
            vexpm_high_params.src_rep_stride, vexpm_high_params.src_rep_stride, 4)
        self.fp162fp32_high_preci_func(high_prec_api)
        self._do_select(vexpm_high_params, cmp_sel, mask_o, extent)

    def vec_rec_high_preci_(self, vrec_obj):
        """
        Get high precision reciprocal using newton method.
        """
        work_tensor0 = vrec_obj.work_tensor[0:vrec_obj.tensor_split_size]
        work_tensor1 = vrec_obj.work_tensor[vrec_obj.tensor_split_size:]

        vrec_api = VecSingleApi(vrec_obj.name, vrec_obj.mask, vrec_obj.dst, vrec_obj.src,
                                vrec_obj.repeat_times, MIN_STRIDE, MIN_STRIDE, vrec_obj.dst_rep_stride,
                                vrec_obj.src_rep_stride, MIN_STRIDE_UNIT, 'vrec')
        vrec_op = SingleOpApi(self, vrec_api)
        vrec_op.run_all()

        # iteration 1
        # compute tmp: a*x(n-1)
        self._vmul_h_api(vrec_obj, [work_tensor0, vrec_obj.src, vrec_obj.dst,
                                    vrec_obj.src_rep_stride, vrec_obj.src_rep_stride, vrec_obj.dst_rep_stride])
        # compute tmp: -1*tmp
        self._vmuls_h_api(vrec_obj, [work_tensor1, work_tensor0, -1,
                                     vrec_obj.src_rep_stride, vrec_obj.src_rep_stride])
        # compute tmp: 2+tmp
        self._vmuls_h_api(vrec_obj, [work_tensor0, work_tensor1, 2,
                                     vrec_obj.src_rep_stride, vrec_obj.src_rep_stride], api_name="vadds")
        # compute x(n): tmp*x(n-1)
        self._vmul_h_api(vrec_obj, [work_tensor1, work_tensor0, vrec_obj.dst,
                                    vrec_obj.src_rep_stride, vrec_obj.src_rep_stride, vrec_obj.dst_rep_stride])

        # iteration 2
        # compute tmp: a*x(n-1)
        self._vmul_h_api(vrec_obj, [work_tensor0, vrec_obj.src, work_tensor1,
                                    vrec_obj.src_rep_stride, vrec_obj.src_rep_stride, vrec_obj.src_rep_stride])
        # compute tmp: -1*tmp
        self._vmuls_h_api(vrec_obj, [vrec_obj.dst, work_tensor0, -1,
                                     vrec_obj.dst_rep_stride, vrec_obj.src_rep_stride])
        # compute tmp: 2+tmp
        self._vmuls_h_api(vrec_obj, [work_tensor0, vrec_obj.dst, 2,
                                     vrec_obj.src_rep_stride, vrec_obj.dst_rep_stride], api_name="vadds")
        # compute x(n): tmp*x(n-1)
        self._vmul_h_api(vrec_obj, [vrec_obj.dst, work_tensor0, work_tensor1,
                                    vrec_obj.dst_rep_stride, vrec_obj.src_rep_stride, vrec_obj.src_rep_stride])

    def high_rsqrt_cloud(self, rsqrt_obj):
        """
        cloud
        """
        default_stride = 1
        work_tensor0 = rsqrt_obj.work_tensor[0:rsqrt_obj.tensor_split_size]
        work_tensor1 = rsqrt_obj.work_tensor[rsqrt_obj.tensor_split_size:]

        vrsqrt_obj = VecSingleApi(rsqrt_obj.name, rsqrt_obj.mask, work_tensor0, rsqrt_obj.src, rsqrt_obj.repeat_times,
                                  default_stride, default_stride, rsqrt_obj.src_rep_stride, rsqrt_obj.src_rep_stride,
                                  0, 'vsqrt')

        vrsqrt_obj = SingleOpApi(self, vrsqrt_obj, rsqrt_obj.mask_o)
        vrsqrt_obj.run_all()

        vrec_obj = TikVectorApi.vec_high_prec_api(
            rsqrt_obj.name, rsqrt_obj.mask, rsqrt_obj.dst, work_tensor0, work_tensor1, rsqrt_obj.repeat_times,
            rsqrt_obj.dst_rep_stride, rsqrt_obj.src_rep_stride, rsqrt_obj.tensor_split_size, rsqrt_obj.mask_o)
        self.vec_rec_high_preci_(vrec_obj)

    def high_rsqrt_mini(self, rsqrt_obj):
        """
        vrsqrt instr by newton iter method
        """
        default_stride = 1
        stride_unit = 0
        # calc ele
        work_tensor1 = rsqrt_obj.work_tensor[0:rsqrt_obj.tensor_split_size]
        work_tensor2 = rsqrt_obj.work_tensor[rsqrt_obj.tensor_split_size:2 * rsqrt_obj.tensor_split_size]
        work_tensor3 = rsqrt_obj.work_tensor[2 * rsqrt_obj.tensor_split_size:]
        # newton init value: vrsqrt

        vrsqrt_obj = VecSingleApi(rsqrt_obj.name, rsqrt_obj.mask, rsqrt_obj.dst, rsqrt_obj.src,
                                  rsqrt_obj.repeat_times, default_stride, default_stride,
                                  rsqrt_obj.dst_rep_stride, rsqrt_obj.src_rep_stride, stride_unit, 'vrsqrt')

        vrsqrt_obj = SingleOpApi(self, vrsqrt_obj, rsqrt_obj.mask_o)
        vrsqrt_obj.run_all()

        # mini
        iteration_times = 2
        with self.for_range(0, iteration_times):
            # method 3
            # dst maybe not allow as work_tensor

            vmul_obj = VecMultiApi(rsqrt_obj.name, rsqrt_obj.mask, work_tensor1, rsqrt_obj.src, rsqrt_obj.dst,
                                   rsqrt_obj.repeat_times, default_stride, default_stride, default_stride,
                                   rsqrt_obj.src_rep_stride, rsqrt_obj.src_rep_stride, rsqrt_obj.dst_rep_stride,
                                   stride_unit, "vmul")
            vmul_obj = MultiOp(self, vmul_obj)
            vmul_obj.run_all()

            vrec_obj = TikVectorApi.vec_high_prec_api(
                rsqrt_obj.name, rsqrt_obj.mask, work_tensor2, work_tensor1, work_tensor3, rsqrt_obj.repeat_times,
                rsqrt_obj.src_rep_stride, rsqrt_obj.src_rep_stride, rsqrt_obj.tensor_split_size, rsqrt_obj.mask_o)
            self.vec_rec_high_preci_(vrec_obj)

            vadd_obj = VecMultiApi(rsqrt_obj.name, rsqrt_obj.mask, work_tensor1, rsqrt_obj.dst, work_tensor2,
                                   rsqrt_obj.repeat_times, default_stride, default_stride,
                                   default_stride, rsqrt_obj.src_rep_stride, rsqrt_obj.dst_rep_stride,
                                   rsqrt_obj.src_rep_stride, stride_unit, "vadd")
            vadd_obj = MultiOp(self, vadd_obj)
            vadd_obj.run_all()

            vmuls_obj = VecScalarMultisApi(rsqrt_obj.name, rsqrt_obj.mask, rsqrt_obj.dst, work_tensor1, 0.5,
                                           rsqrt_obj.repeat_times, default_stride, default_stride,
                                           rsqrt_obj.dst_rep_stride, rsqrt_obj.src_rep_stride,
                                           stride_unit, 0, "normal", "vmuls")
            vmuls_obj = ScalarMultisOps(self, vmuls_obj, rsqrt_obj.mask_o)
            vmuls_obj.run_all()

    @vec_ln_high_preci_decorator
    def vln_high_preci(self, op_obj):
        with self.context.freeze():
            self.vln_high_preci_codegen(op_obj)

    @high_level_api_debug_decorator
    def vln_high_preci_high_level(self, op_obj):
        self.vln_high_preci_codegen(op_obj)

    def vln_high_preci_codegen(self, op_obj):
        """
        vln high preci
        Parameters
        ----------
        op_obj: op obj
        """
        instr_name = "vec_ln_high_preci"
        default_blk_stride = 1
        multi_factor = 10  # work_tensor size need more than 10 * src_extend
        # params check
        high_preci = HighPreciParams(op_obj.dst, op_obj.src, op_obj.work_tensor,
                                        op_obj.repeat_times, op_obj.dst_rep_stride,
                                        op_obj.src_rep_stride)
        check_high_preci_param(high_preci)
        TikCheckUtil.check_equality(op_obj.work_tensor.dtype, op_obj.dst.dtype,
                                    "work_tensor's dtype must be same with dst's dtype")
        TikCheckUtil.check_equality(api_check_support("tik." + instr_name, op_obj.dst.dtype), True,
                                    gen_api_check_statement(op_obj.dst.dtype, instr_name))
        # check mask
        check_mask_valid(op_obj.mask, tensor_bit_len=max(get_bit_len(op_obj.src.dtype),
                                                            get_bit_len(op_obj.dst.dtype)))

        over_high = OverHighApi(op_obj.mask, op_obj.dst, op_obj.src, op_obj.work_tensor,
                                op_obj.repeat_times, op_obj.dst_rep_stride,
                                op_obj.src_rep_stride, Expr(op_obj.dst.offset).eval_value(),
                                Expr(op_obj.src.offset).eval_value(),
                                Expr(op_obj.work_tensor.offset).eval_value(),
                                multi_factor, instr_name)

        check_over_high_preci(over_high)

        self.vln_calculate_by_taylor_expand((
            instr_name, op_obj.mask, op_obj.dst, op_obj.src, op_obj.work_tensor,
            op_obj.repeat_times, default_blk_stride,
            default_blk_stride, op_obj.dst_rep_stride, op_obj.src_rep_stride))

    def vln_calculate_by_taylor_expand(self, taylor_expand_tuple):
        """
        calculate ln(raw_tensor), use taylor expansion to calculate log
        """
        name, mask, dst, src, work_tensor, repeat_times, \
        dst_blk_stride, src_blk_stride, dst_rep_stride, src_rep_stride = taylor_expand_tuple

        src_data_size = self.get_wk_tensor_extend(mask, src.dtype,
                                                  repeat_times, src_rep_stride)

        mask_o = mask_concat(self, mask, tensor_bit_len=get_bit_len(src.dtype))

        vln_op = TaylorTuple(name, mask, dst, src, work_tensor, repeat_times, dst_blk_stride, src_blk_stride,
                             dst_rep_stride, src_rep_stride, src_data_size, src_rep_stride * 16, mask_o,
                             TikHighPrec.stride_unit)

        _ln_compute_block_lt_5_3_gt_1(
            self, work_tensor[:src_data_size], src, work_tensor[src_data_size:src_data_size * 5], vln_op)
        _ln_compute_block_gt_5_3((
            self, work_tensor[src_data_size * 4:src_data_size * 5],
            work_tensor[:src_data_size], src, work_tensor[src_data_size:src_data_size * 3], vln_op))
        _ln_compute_block_gt_half_lt_1((
            self, work_tensor[0:src_data_size], work_tensor[src_data_size * 4:src_data_size * 5],
            src, work_tensor[src_data_size:src_data_size * 4], vln_op))
        _ln_compute_block_lt_half((self, dst, work_tensor[:src_data_size], src, work_tensor[src_data_size:], vln_op))

    def _gen_exm_rep_stride(self, vexpm_high_params):
        """
        gen exm rep stride
        """
        default_rep_stride = vexpm_high_params.src_rep_stride
        if is_immediate_number(vexpm_high_params.src_rep_stride):
            if 0 < vexpm_high_params.src_rep_stride < 8:
                default_rep_stride = 8
        else:
            default_rep_stride = self.scalar_(init_value=vexpm_high_params.src_rep_stride)
            with self.if_scope(vexpm_high_params.src_rep_stride > 0):
                with self.if_scope(vexpm_high_params.src_rep_stride < 8):
                    default_rep_stride.set_as(8)

        return default_rep_stride

    def _expm1(self, expm1_params):
        """
        expm 1
        -------

        """
        expm1_exp_api = VecSingleApi(expm1_params.name, expm1_params.mask, expm1_params.work_tensor, expm1_params.src,
                                     expm1_params.repeat_times, 1, 1, expm1_params.wk_rep_stride,
                                     expm1_params.src_rep_stride, 0, 'vexp')
        vexp_obj = SingleOpApi(self, expm1_exp_api, mask_o=expm1_params.mask_o)
        vexp_obj.run_all()
        expm1_adds_api = VecScalarMultisApi(expm1_params.name, expm1_params.mask, expm1_params.dst,
                                            expm1_params.work_tensor, -1, expm1_params.repeat_times, 1, 1,
                                            expm1_params.dst_rep_stride, expm1_params.wk_rep_stride, 0, 0,
                                            'normal', 'vadds')
        vadds_obj = ScalarMultisOps(self, expm1_adds_api, mask_o=expm1_params.mask_o)
        vadds_obj.run_all()

    def _expm_vmult_h_api(self, params_list, name, api_name, mask_o):
        """
        expm vmult h api
        Parameters
        ----------
        params_list: params list
        name: name
        api_name: api name
        mask_o: mask
        """
        vec_vmult_obj = VecMultiApi(name, *params_list, 0, api_name)
        vec_vmult_obj = MultiOp(self, vec_vmult_obj, mask_o)
        vec_vmult_obj.run_all()

    def _expm_vmults_h_api(self, params_list, name, api_name, mask_o):
        """
        expm vmilts h api
        Parameters
        ----------
        params_list: params list
        name: name
        api_name: api name
        mask_o: mask
        """
        vec_vmultis_obj = VecScalarMultisApi(name, *params_list, 0, 0, "normal", api_name)
        vec_vmultis_obj = ScalarMultisOps(self, vec_vmultis_obj, mask_o)
        vec_vmultis_obj.run_all()

    def _expm1_taylor(self, expm1_obj):
        """
        expm1 taylor compute
        Parameters
        ----------

        Returns
        -------

        """
        wk_tensor1 = expm1_obj.work_tensor[:expm1_obj.tensor_split_size]
        wk_tensor2 = expm1_obj.work_tensor[expm1_obj.tensor_split_size:2 * expm1_obj.tensor_split_size]

        self._expm_vmults_h_api((expm1_obj.mask, expm1_obj.dst, expm1_obj.src, 0, expm1_obj.repeat_times, 1, 1,
                                 expm1_obj.dst_rep_stride, expm1_obj.src_rep_stride),
                                expm1_obj.name, "vadds", expm1_obj.mask_o)

        taylor_param = 1 / 2
        self._expm_vmults_h_api((expm1_obj.mask, wk_tensor1, expm1_obj.src, 0, expm1_obj.repeat_times,
                                 1, 1, expm1_obj.src_rep_stride, expm1_obj.src_rep_stride),
                                expm1_obj.name, "vadds", expm1_obj.mask_o)

        self._expm_vmult_h_api((expm1_obj.mask, wk_tensor2, wk_tensor1, expm1_obj.src, expm1_obj.repeat_times,
                                1, 1, 1, expm1_obj.src_rep_stride, expm1_obj.src_rep_stride, expm1_obj.src_rep_stride),
                               expm1_obj.name, "vmul", expm1_obj.mask_o)

        self._expm_vmults_h_api((expm1_obj.mask, wk_tensor1, wk_tensor2, taylor_param,
                                 expm1_obj.repeat_times, 1, 1, expm1_obj.src_rep_stride, expm1_obj.src_rep_stride),
                                expm1_obj.name, "vmuls", expm1_obj.mask_o)

        self._expm_vmult_h_api((expm1_obj.mask, wk_tensor2, wk_tensor1, expm1_obj.dst, expm1_obj.repeat_times,
                                1, 1, 1, expm1_obj.src_rep_stride, expm1_obj.src_rep_stride, expm1_obj.dst_rep_stride),
                               expm1_obj.name, "vadd", expm1_obj.mask_o)

        for index in range(3, 8):
            taylor_param = 1 / index
            if index % 2 == 1:
                self._expm_vmult_h_api((expm1_obj.mask, expm1_obj.dst, wk_tensor1, expm1_obj.src,
                                        expm1_obj.repeat_times, 1, 1, 1, expm1_obj.dst_rep_stride,
                                        expm1_obj.src_rep_stride, expm1_obj.src_rep_stride),
                                       expm1_obj.name, "vmul", expm1_obj.mask_o)
                self._expm_vmults_h_api((expm1_obj.mask, wk_tensor1, expm1_obj.dst, taylor_param,
                                         expm1_obj.repeat_times, 1, 1, expm1_obj.src_rep_stride,
                                         expm1_obj.dst_rep_stride), expm1_obj.name, "vmuls", expm1_obj.mask_o)
                self._expm_vmult_h_api((expm1_obj.mask, expm1_obj.dst, wk_tensor2, wk_tensor1, expm1_obj.repeat_times,
                                        1, 1, 1, expm1_obj.dst_rep_stride, expm1_obj.src_rep_stride,
                                        expm1_obj.src_rep_stride), expm1_obj.name, "vadd", expm1_obj.mask_o)
            else:
                self._expm_vmult_h_api((expm1_obj.mask, wk_tensor2, wk_tensor1,
                                        expm1_obj.src, expm1_obj.repeat_times, 1, 1, 1, expm1_obj.src_rep_stride,
                                        expm1_obj.src_rep_stride, expm1_obj.src_rep_stride),
                                       expm1_obj.name, "vmul", expm1_obj.mask_o)
                self._expm_vmults_h_api((expm1_obj.mask, wk_tensor1, wk_tensor2, taylor_param,
                                         expm1_obj.repeat_times, 1, 1, expm1_obj.src_rep_stride,
                                         expm1_obj.src_rep_stride), expm1_obj.name, "vmuls", expm1_obj.mask_o)
                self._expm_vmult_h_api((expm1_obj.mask, wk_tensor2, expm1_obj.dst, wk_tensor1, expm1_obj.repeat_times,
                                        1, 1, 1, expm1_obj.src_rep_stride, expm1_obj.dst_rep_stride,
                                        expm1_obj.src_rep_stride), expm1_obj.name, "vadd", expm1_obj.mask_o)

    def _cmp_params_convert(self, param, target, src_rep_stride):
        """
        cmp params convert
        Parameters
        ----------
        param: params
        target: target
        src_rep_stride: src repeat stride

        Returns
        -------

        """
        result = param
        if is_immediate_number(src_rep_stride):
            if src_rep_stride == 0:
                result = target
        else:
            result = self.scalar_(init_value=param)
            with self.if_scope(src_rep_stride == 0):
                result.set_as(target)
        return result

    def _gen_comparator(self, params_dict, extent, instr_name, mask_o):
        """
        gen comparator

        Parameters
        ----------
        params_dict: dict of params
        extent: work tensor size single
        instr_name: the instr name
        mask_o: cncat mask

        Returns
        -------
        return:and_tensor
        """

        src_rep_stride = params_dict.get("src_rep_stride")

        # if src_rep_stride is 0, make cmp_repeat_times 1
        cmp_repeat_times = self._cmp_params_convert(params_dict.get("repeat_times"), 1, src_rep_stride)
        # if src_rep_stride is 0, make and_rep_stride 0, else 8
        and_rep_stride = self._cmp_params_convert(8, 0, src_rep_stride)

        vec_dup_obj = VecDupApi(instr_name, params_dict.get("mask"), params_dict.get("work_tensor")[:extent],
                                1.7, params_dict.get("repeat_times"), 1, src_rep_stride, 0, "normal", "vector_dup")
        vec_dup_obj = DupOpApi(self, vec_dup_obj, mask_o=mask_o)
        vec_dup_obj.run_all()

        lt_tensor = params_dict.get("work_tensor")[extent:2 * extent].reinterpret_cast_to("uint16")
        vcmpv_lt_obj = VecVcmpvApi(instr_name, params_dict.get("mask"), lt_tensor, params_dict.get("src"),
                                   params_dict.get("work_tensor")[:extent], cmp_repeat_times, 1, 1, src_rep_stride,
                                   src_rep_stride, "vcmpv_lt")
        vcmpv_lt_obj = VcmpvOpApi(self, vcmpv_lt_obj)
        vcmpv_lt_obj.run_all()

        vec_dup_obj = VecDupApi(instr_name, params_dict.get("mask"), params_dict.get("work_tensor")[:extent],
                                -0.7, params_dict.get("repeat_times"), 1, src_rep_stride, 0, "normal", "vector_dup")
        vec_dup_obj = DupOpApi(self, vec_dup_obj, mask_o=mask_o)
        vec_dup_obj.run_all()

        gt_tensor = params_dict.get("work_tensor")[2 * extent:3 * extent].reinterpret_cast_to("uint16")
        vcmpv_gt_obj = VecVcmpvApi(instr_name, params_dict.get("mask"), gt_tensor, params_dict.get("src"),
                                   params_dict.get("work_tensor")[:extent], cmp_repeat_times,
                                   1, 1, src_rep_stride, src_rep_stride, "vcmpv_gt")
        vcmpv_gt_obj = VcmpvOpApi(self, vcmpv_gt_obj)
        vcmpv_gt_obj.run_all()

        and_tensor = params_dict.get("work_tensor")[:extent].reinterpret_cast_to("uint16")
        vec_vand_obj = VecMultiApi(instr_name, 128, and_tensor, lt_tensor, gt_tensor, params_dict.get("repeat_times"),
                                   1, 1, 1, and_rep_stride, and_rep_stride, and_rep_stride, 0, "vand")
        vec_vand_obj = MultiOp(self, vec_vand_obj, mask_o=mask_o)
        vec_vand_obj.run_all()
        return and_tensor

    def _do_select(self, vexpm_high_params, cmp_sel, mask_o, extent):
        """
        do select
        Parameters
        ----------
        vexpm_high_params: vexpm high params
        cmp_sel: cmp sel
        mask_o: mask
        extent: extent
        """
        src_offset = vexpm_high_params.src_rep_stride * ONE_BLK_SIZE // DTYPE_SIZE[vexpm_high_params.src.dtype]
        dst_offset = vexpm_high_params.dst_rep_stride * ONE_BLK_SIZE // DTYPE_SIZE[vexpm_high_params.src.dtype]
        sel_offset = self.scalar_(init_value=8)
        with self.if_scope(vexpm_high_params.src_rep_stride == 0):
            sel_offset.set_as(0)

        with self.for_range(0, vexpm_high_params.repeat_times) as index:
            vec_sel_obj = VecSelApi(vexpm_high_params.mask, 0, vexpm_high_params.dst[dst_offset * index:],
                                    cmp_sel[sel_offset * index:],
                                    vexpm_high_params.work_tensor[2 * extent + src_offset * index:],
                                    vexpm_high_params.work_tensor[extent + src_offset * index:], 1,
                                    vexpm_high_params.dst_rep_stride, vexpm_high_params.src_rep_stride,
                                    vexpm_high_params.src_rep_stride,
                                    vexpm_high_params.name, mask_o)
            self.vec_sel_(vec_sel_obj)

    @vrec_high_preci_decorator
    def _vrec_high_preci(self, mask, instr_name, vrec_api):
        with self.context.freeze():
            self._vrec_high_preci_codegen(mask, instr_name, vrec_api)

    @high_level_api_debug_decorator
    def _vrec_high_preci_high_level(self, mask, instr_name, vrec_api):
        self._vrec_high_preci_codegen(mask, instr_name, vrec_api)

    def _vrec_high_preci_codegen(self, mask, instr_name, vrec_api):
        """
        vrec high preci
        Parameters
        ----------
        mask: mask
        instr_name: instr name
        vrec_api: vrec api

        Returns
        -------

        """
        src_bit_len, multi_factor = self._vrec_high_prec_check(vrec_api, instr_name, mask)

        if vrec_api.src.dtype == "float16":
            # work_tensor need more!
            high_prec_api = TikHighPrec.high_prec_api(
                self.vec_rec_high_preci_, instr_name, mask, vrec_api.dst, vrec_api.src, vrec_api.work_tensor,
                vrec_api.repeat_times, vrec_api.dst_rep_stride, vrec_api.src_rep_stride, multi_factor)
            self.fp162fp32_high_preci_func(high_prec_api)
            return

        # get mask_o
        mask_o = mask_concat(self, mask, tensor_bit_len=src_bit_len)
        tensor_split_size = self.get_wk_tensor_extend(mask, vrec_api.src.dtype,
                                                      vrec_api.repeat_times, vrec_api.src_rep_stride)
        vrec_obj = TikHighPrec.vec_high_prec_api(
            instr_name, mask, vrec_api.dst, vrec_api.src, vrec_api.work_tensor, vrec_api.repeat_times,
            vrec_api.dst_rep_stride, vrec_api.src_rep_stride, tensor_split_size, mask_o)
        self.vec_rec_high_preci_(vrec_obj)

    def _vmul_h_api(self, vrec_obj, tensors):
        """
        vmul for high_preci_vrec
        :param vrec_obj: vrec obj, include name, mask, ...
        :param tensors: include dst, src0, src1, dst_rep_stride, src0_rep_stride, src1_rep_stride
        :return: no return
        """
        vmul_api = VecMultiApi(vrec_obj.name, vrec_obj.mask, *tensors[:3], vrec_obj.repeat_times, MIN_STRIDE,
                               MIN_STRIDE, MIN_STRIDE, *tensors[3:], MIN_STRIDE_UNIT, 'vmul')
        vmul_obj = MultiOp(self, vmul_api)
        vmul_obj.run_all()

    def _vmuls_h_api(self, vrec_obj, tensors, api_name='vmuls'):
        """
        vmuls and vadds for high_preci_vrec
        :param vrec_obj: vrec obj, include name, mask, ...
        :param tensors: include dst, src0, src1, dst_rep_stride, src0_rep_stride, src1_rep_stride
        :param api_name: vmuls or vadds
        :return:
        """
        scalar_multis_api = VecScalarMultisApi(
            vrec_obj.name, vrec_obj.mask, *tensors[:3], vrec_obj.repeat_times, MIN_STRIDE, MIN_STRIDE,
            *tensors[3:], MIN_STRIDE_UNIT, 0, 'normal', api_name)
        vmuls_obj = ScalarMultisOps(self, scalar_multis_api)
        vmuls_obj.run_all()

    @vrsqrt_high_preci_decorator
    def _vrsqrt_high_preci(self, vrsqrt_high_params):
        with self.context.freeze():
            self._vrsqrt_high_preci_codegen(vrsqrt_high_params)

    @high_level_api_debug_decorator
    def _vrsqrt_high_preci_high_level(self, vrsqrt_high_params):
        self._vrsqrt_high_preci_codegen(vrsqrt_high_params)

    def _vrsqrt_high_preci_codegen(self, vrsqrt_high_params):
        """
        vrsqrt high preci
        Parameters
        ----------
        vrsqrt_high_params: vrsqrt high params
        """
        instr_name = "vec_rsqrt_high_preci"
        self._check_vrsqrt_high_preci(vrsqrt_high_params, instr_name)
        multi_factor = 3
        if get_soc_name() == ASCEND_310:
            multi_factor = 4
        if vrsqrt_high_params.src.dtype == "float16":
            # 4B of fp32, need keep 32B algin
            multi_factor += 2
        # check overflow and overlap
        over_high = OverHighApi(vrsqrt_high_params.mask, vrsqrt_high_params.dst, vrsqrt_high_params.src,
                                vrsqrt_high_params.work_tensor, vrsqrt_high_params.repeat_times,
                                vrsqrt_high_params.dst_rep_stride, vrsqrt_high_params.src_rep_stride,
                                Expr(vrsqrt_high_params.dst.offset).eval_value(),
                                Expr(vrsqrt_high_params.src.offset).eval_value(),
                                Expr(vrsqrt_high_params.work_tensor.offset).eval_value(), multi_factor, instr_name)
        check_over_high_preci(over_high)

        if vrsqrt_high_params.src.dtype == "float16":
            # work_tensor need more!
            if get_soc_name() == ASCEND_310:
                high_prec_api = TikVectorApi.high_prec_api(self.high_rsqrt_mini, instr_name,
                                                            vrsqrt_high_params.mask, vrsqrt_high_params.dst,
                                                            vrsqrt_high_params.src, vrsqrt_high_params.work_tensor,
                                                            vrsqrt_high_params.repeat_times,
                                                            vrsqrt_high_params.dst_rep_stride,
                                                            vrsqrt_high_params.src_rep_stride, multi_factor)
                self.fp162fp32_high_preci_func(high_prec_api)
            else:
                high_prec_api = TikVectorApi.high_prec_api(self.high_rsqrt_cloud, instr_name,
                                                            vrsqrt_high_params.mask, vrsqrt_high_params.dst,
                                                            vrsqrt_high_params.src, vrsqrt_high_params.work_tensor,
                                                            vrsqrt_high_params.repeat_times,
                                                            vrsqrt_high_params.dst_rep_stride,
                                                            vrsqrt_high_params.src_rep_stride, multi_factor)
                self.fp162fp32_high_preci_func(high_prec_api)
            return
        # get mask_o
        mask_o = mask_concat(self, vrsqrt_high_params.mask, tensor_bit_len=get_bit_len(vrsqrt_high_params.src.dtype))
        # get split tensor size
        tensor_split_size = self.get_wk_tensor_extend(
            vrsqrt_high_params.mask, vrsqrt_high_params.src.dtype, vrsqrt_high_params.repeat_times,
            vrsqrt_high_params.src_rep_stride)
        vrec_obj = HighPreciCommonUtil.vec_high_prec_api(
            instr_name, vrsqrt_high_params.mask, vrsqrt_high_params.dst, vrsqrt_high_params.src,
            vrsqrt_high_params.work_tensor, vrsqrt_high_params.repeat_times, vrsqrt_high_params.dst_rep_stride,
            vrsqrt_high_params.src_rep_stride,
            tensor_split_size, mask_o)
        if TikSocManager.is_mini_soc():
            self.high_rsqrt_mini(vrec_obj)
        else:
            self.high_rsqrt_cloud(vrec_obj)


def _vadds_vmul(vadds_mul_tuple):
    self, dst_data, src_data, tmp_work_tensor, scalar_value, vln_op = vadds_mul_tuple
    # vadds
    multis_api = VecScalarMultisApi(vln_op.name, vln_op.mask, tmp_work_tensor, dst_data, scalar_value,
                                    vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride,
                                    vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.stride_unit, 0,
                                    "normal", "vadds")
    ScalarMultisOps(self, multis_api, vln_op.mask_o).run_all()

    # vmul
    multis_api = VecMultiApi(vln_op.name, vln_op.mask, dst_data, src_data, tmp_work_tensor,
                             vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride, vln_op.src_blk_stride,
                             vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.src_rep_stride,
                             vln_op.stride_unit, "vmul")
    MultiOp(self, multis_api, "normal", vln_op.mask_o).run_all()


def _taylor_compute_five(self, dst_data, src_data, tmp_work_tensor, vln_op):
    """
    taylor compute five
    """
    multis_api = VecScalarMultisApi(vln_op.name, vln_op.mask, dst_data, src_data, CONST_ONE_FIVE,
                                    vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride,
                                    vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.stride_unit, 0,
                                    "normal", "vmuls")
    ScalarMultisOps(self, multis_api, vln_op.mask_o).run_all()

    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_NEG_ONE_FOUR, vln_op))
    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_ONE_THREE, vln_op))
    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_NEG_HALF, vln_op))
    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_ONE, vln_op))


def _taylor_compute_nine(self, dst_data, src_data, tmp_work_tensor, vln_op):
    """
    taylor compute nine
    """
    multis_api = VecScalarMultisApi(vln_op.name, vln_op.mask, dst_data, src_data, CONST_ONE_NINE,
                                    vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride,
                                    vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.stride_unit, 0,
                                    "normal", "vmuls")
    ScalarMultisOps(self, multis_api, vln_op.mask_o).run_all()

    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_NEG_ONE_EIGHT, vln_op))
    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_ONE_SEVEN, vln_op))
    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_NEG_ONE_SIX, vln_op))
    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_ONE_FIVE, vln_op))
    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_NEG_ONE_FOUR, vln_op))
    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_ONE_THREE, vln_op))
    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_NEG_HALF, vln_op))
    _vadds_vmul((self, dst_data, src_data, tmp_work_tensor, CONST_ONE, vln_op))


def _compute_block_ten(self, src_data, tmp_work_tensor, vln_op):
    """
    compute block ten
    """
    # vadds
    multis_api = VecScalarMultisApi(vln_op.name, vln_op.mask, tmp_work_tensor, src_data, CONST_NEG_FOUR_THREE,
                                    vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride,
                                    vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.stride_unit, 0,
                                    "normal", "vadds")
    ScalarMultisOps(self, multis_api, vln_op.mask_o).run_all()
    # vmuls
    multis_api = VecScalarMultisApi(vln_op.name, vln_op.mask,
                                    tmp_work_tensor[vln_op.src_data_size:vln_op.src_data_size * 2],
                                    tmp_work_tensor, CONST_THREE_FOUR,
                                    vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride,
                                    vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.stride_unit, 0,
                                    "normal", "vmuls")
    ScalarMultisOps(self, multis_api, vln_op.mask_o).run_all()
    # vector_dup
    multis_api = VecDupApi(vln_op.name, vln_op.mask,
                           tmp_work_tensor[vln_op.src_data_size * 2:vln_op.src_data_size * 3], CONST_ONE_THREE,
                           vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_rep_stride, vln_op.stride_unit,
                           "normal", "vector_dup")
    DupOpApi(self, multis_api, vln_op.mask_o).run_all()
    # vadds
    multis_api = VecScalarMultisApi(vln_op.name, vln_op.mask, tmp_work_tensor, src_data, CONST_NEG_ONE,
                                    vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride,
                                    vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.stride_unit, 0,
                                    "normal", "vadds")
    ScalarMultisOps(self, multis_api, vln_op.mask_o).run_all()


def _ln_compute_block_lt_5_3_gt_1(self, dst_data, src_data, tmp_work_tensor, vln_op):
    """
    ln compute block
    """
    _compute_block_ten(self, src_data, tmp_work_tensor, vln_op)

    if isinstance(vln_op.src_rep_stride, int):
        tmp_mask_len = 0
        tmp_mask_offset = 8
        if vln_op.src_rep_stride != 0:
            tmp_mask_len = 2
            tmp_mask_offset = vln_op.repeat_times * 8
    else:
        tmp_mask_len = self.Scalar(dtype="int32", name="tmp_mask_len", init_value=0)
        tmp_mask_offset = self.Scalar(dtype="int32", name="tmp_mask_offset", init_value=8)
        with self.if_scope(vln_op.src_rep_stride != 0):
            tmp_mask_len.set_as(2)
            tmp_mask_offset.set_as(vln_op.repeat_times * 8)

    tmp_tensor_index = vln_op.src_data_size * 3
    tmp_tensor = tmp_work_tensor[tmp_tensor_index:tmp_tensor_index + tmp_mask_offset].reinterpret_cast_to("uint64")

    with self.for_range(0, vln_op.repeat_times) as index:
        # vcmp_ge
        multis_api = VecVcmpApi(vln_op.name, vln_op.mask, tmp_work_tensor[index * vln_op.src_offset],
                                tmp_work_tensor[vln_op.src_data_size * 2 + index * vln_op.src_offset],
                                vln_op.src_blk_stride, vln_op.src_blk_stride, 'vcmp_ge')
        cmpmask = VcmpOpApi(self, multis_api, vln_op.mask_o).run_all()

        self.mov_cmpmask_to_tensor(tmp_tensor[index * tmp_mask_len], cmpmask)
        self.vsel(vln_op.mask, 0, dst_data[index * vln_op.src_offset], cmpmask,
                  tmp_work_tensor[vln_op.src_data_size + index * vln_op.src_offset],
                  tmp_work_tensor[index * vln_op.src_offset], 1,
                  vln_op.src_blk_stride,
                  vln_op.src_blk_stride, vln_op.src_blk_stride,
                  name=vln_op.name, mask_o=vln_op.mask_o)

    _taylor_compute_five(self, tmp_work_tensor[0:vln_op.src_data_size], dst_data,
                         tmp_work_tensor[vln_op.src_data_size * 2:vln_op.src_data_size * 3], vln_op)

    # phase3: add log(4/3)
    multis_api = VecScalarMultisApi(vln_op.name, vln_op.mask,
                                    tmp_work_tensor[vln_op.src_data_size:vln_op.src_data_size * 2],
                                    tmp_work_tensor[0:vln_op.src_data_size], LOG_FOUR_THREE,
                                    vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride,
                                    vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.stride_unit, 0,
                                    "normal", "vadds")
    ScalarMultisOps(self, multis_api, vln_op.mask_o).run_all()

    with self.for_range(0, vln_op.repeat_times) as index:
        cmpmask = self.mov_tensor_to_cmpmask(tmp_tensor[index * tmp_mask_len])
        self.vsel(vln_op.mask, 0, dst_data[index * vln_op.src_offset], cmpmask,
                  tmp_work_tensor[vln_op.src_data_size + index * vln_op.src_offset],
                  tmp_work_tensor[index * vln_op.src_offset], 1, vln_op.src_blk_stride, vln_op.src_blk_stride,
                  vln_op.src_blk_stride, name=vln_op.name, mask_o=vln_op.mask_o)


def _ln_compute_block_gt_5_3(compute_tuple):
    """
    when src_data > 5/3, use vlog directly

    Returns
    -------
    res : return of log
    """
    # if src_data > 5/3, use vlog
    self, dst_data, tmp_dst_data, src_data, tmp_work_tensor, vln_op = compute_tuple
    # vln
    multis_api = VecSingleApi(vln_op.name, vln_op.mask,
                              tmp_work_tensor[vln_op.src_data_size:vln_op.src_data_size * 2], src_data,
                              vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride,
                              vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.stride_unit, 'vln')
    SingleOpApi(self, multis_api, vln_op.mask_o).run_all()
    # vector_dup
    multis_api = VecDupApi(vln_op.name, vln_op.mask, tmp_work_tensor[0:vln_op.src_data_size], CONST_FIVE_THREE,
                           vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_rep_stride, vln_op.stride_unit,
                           "normal", "vector_dup")
    DupOpApi(self, multis_api, vln_op.mask_o).run_all()

    with self.for_range(0, vln_op.repeat_times) as index:
        # vcmp_ge
        multis_api = VecVcmpApi(vln_op.name, vln_op.mask, src_data[index * vln_op.src_offset],
                                tmp_work_tensor[index * vln_op.src_offset],
                                vln_op.src_blk_stride, vln_op.src_blk_stride, 'vcmp_ge')
        cmpmask = VcmpOpApi(self, multis_api, vln_op.mask_o).run_all()
        self.vsel(vln_op.mask, 0, dst_data[index * vln_op.src_offset], cmpmask,
                  tmp_work_tensor[vln_op.src_data_size + index * vln_op.src_offset],
                  tmp_dst_data[index * vln_op.src_offset], 1,
                  vln_op.src_blk_stride, vln_op.src_blk_stride,
                  vln_op.src_blk_stride, name=vln_op.name, mask_o=vln_op.mask_o)


def _ln_compute_block_gt_half_lt_1(compute_tuple):
    """
    ln compute block
    """
    self, dst_data, tmp_dst_data, src_data, tmp_work_tensor, vln_op = compute_tuple
    # vadds
    multis_api = VecScalarMultisApi(vln_op.name, vln_op.mask,
                                    tmp_work_tensor, src_data, CONST_NEG_ONE,
                                    vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride,
                                    vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.stride_unit, 0,
                                    "normal", "vadds")
    ScalarMultisOps(self, multis_api, vln_op.mask_o).run_all()
    _taylor_compute_nine(self,
                         tmp_work_tensor[vln_op.src_data_size:vln_op.src_data_size * 2], tmp_work_tensor,
                         tmp_work_tensor[vln_op.src_data_size * 2:vln_op.src_data_size * 3], vln_op)
    # vector_dup
    multis_api = VecDupApi(vln_op.name, vln_op.mask, tmp_work_tensor, CONST_ONE,
                           vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_rep_stride, vln_op.stride_unit,
                           "normal", "vector_dup")
    DupOpApi(self, multis_api, vln_op.mask_o).run_all()

    with self.for_range(0, vln_op.repeat_times) as index:
        # vcmp_le
        multis_api = VecVcmpApi(vln_op.name, vln_op.mask, src_data[index * vln_op.src_offset],
                                tmp_work_tensor[index * vln_op.src_offset],
                                vln_op.src_blk_stride, vln_op.src_blk_stride, 'vcmp_le')
        cmpmask = VcmpOpApi(self, multis_api, mask_o=None).run_all()

        self.vsel(vln_op.mask, 0, dst_data[index * vln_op.src_offset], cmpmask,
                  tmp_work_tensor[vln_op.src_data_size + index * vln_op.src_offset],
                  tmp_dst_data[index * vln_op.src_offset],
                  1, vln_op.src_blk_stride, vln_op.src_blk_stride,
                  vln_op.src_blk_stride, name=vln_op.name, mask_o=vln_op.mask_o)


def _ln_compute_block_lt_half(compute_tuple):
    """
    ln compute block lt half
    """
    self, dst_data, tmp_dst_data, src_data, tmp_work_tensor, vln_op = compute_tuple

    high_prec_api = TikVectorApi.high_prec_api(self.vec_rec_high_preci_, vln_op.name, vln_op.mask,
                                               tmp_work_tensor[0:vln_op.src_data_size], src_data,
                                               tmp_work_tensor[vln_op.src_data_size:], vln_op.repeat_times,
                                               vln_op.src_rep_stride, vln_op.src_rep_stride, 4)
    self.fp162fp32_high_preci_func(high_prec_api)

    _ln_compute_block_gt_5_3((self,
                              tmp_work_tensor[vln_op.src_data_size * 3:vln_op.src_data_size * 4], tmp_dst_data,
                              tmp_work_tensor[0:vln_op.src_data_size],
                              tmp_work_tensor[vln_op.src_data_size:vln_op.src_data_size * 3], vln_op))

    # vmuls
    multis_api = VecScalarMultisApi(vln_op.name, vln_op.mask,
                                    tmp_work_tensor[vln_op.src_data_size:vln_op.src_data_size * 2],
                                    tmp_work_tensor[vln_op.src_data_size * 3:vln_op.src_data_size * 4],
                                    CONST_NEG_ONE, vln_op.repeat_times, vln_op.src_blk_stride, vln_op.src_blk_stride,
                                    vln_op.src_rep_stride, vln_op.src_rep_stride, vln_op.stride_unit, 0,
                                    "normal", "vmuls")
    ScalarMultisOps(self, multis_api, vln_op.mask_o).run_all()

    # vector_dup
    multis_api = VecDupApi(vln_op.name, vln_op.mask, tmp_work_tensor, CONST_HALF, vln_op.repeat_times,
                           vln_op.src_blk_stride, vln_op.src_rep_stride, vln_op.stride_unit, "normal", "vector_dup")
    DupOpApi(self, multis_api, vln_op.mask_o).run_all()

    dst_offset = vln_op.dst_rep_stride * 16
    with self.for_range(0, vln_op.repeat_times) as index:
        # vcmp_le
        multis_api = VecVcmpApi(vln_op.name, vln_op.mask, src_data[index * vln_op.src_offset],
                                tmp_work_tensor[index * vln_op.src_offset],
                                vln_op.src_blk_stride, vln_op.src_blk_stride, 'vcmp_le')
        cmpmask = VcmpOpApi(self, multis_api, mask_o=vln_op.mask_o).run_all()
        self.vsel(vln_op.mask, 0, dst_data[index * dst_offset], cmpmask,
                  tmp_work_tensor[vln_op.src_data_size + index * vln_op.src_offset],
                  tmp_dst_data[index * vln_op.src_offset], 1, vln_op.dst_blk_stride,
                  vln_op.src_blk_stride, vln_op.src_blk_stride,
                  name=vln_op.name, mask_o=vln_op.mask_o)
