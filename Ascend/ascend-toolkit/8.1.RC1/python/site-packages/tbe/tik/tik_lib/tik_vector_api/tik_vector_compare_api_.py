#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_single_api_.py
DESC:     provide vector instructions
CREATED:  2021-09-8 18:53:42
"""
from tbe import tvm
from tbe.common.platform import scope_ubuf
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.tik_lib.tik_mask_concat_ import mask_concat
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_vector_api.tik_compute_control import ControlOp
from tbe.tik.tik_lib.tik_vector_api.tik_tensor_op import TensorOp
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_vector_api.tik_scalar_op import ScalarOp
from tbe.tik.tik_lib.tik_vector_api.tik_vector_name_map import VCMP_NAME_DICT
from tbe.tik.tik_lib.tik_vector_api.tik_params_check import VcmpCheckParams
from tbe.tik.tik_lib.tik_vector_api.tik_params_check import VcmpvCheckParams
from tbe.tik.tik_lib.tik_vector_api.tik_params_check import VcmpvsCheckParams
from tbe.tik.tik_lib.tik_vector_api.vector_common_util import gen_b64_mask_mode
from tbe.tik.tik_lib.tik_params import CMPMASK_VAR
from tbe.tik.tik_lib.tik_util import dtype_convert
from tbe.tik.tik_lib.tik_util import concat_params
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vcmp_decorator_new
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vcmpv_decorator_new
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vcmpvs_decorator_new
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_api_util import set_vsel_cmpmask
from tbe.tik.tik_lib.tik_params import VSEL_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import VSEL_SEGMENT_LIST
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_compare import VselCheckParams
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vsel_decorator_new
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_compare import VreduceCheckParams
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_compare import VconvCheckParams
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vreduce_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vconv_decorator_new
from tbe.tik.tik_lib.tik_util import change_dtype_str
from tbe.tik.tik_lib.tik_api_util import set_ctrl_counter_mask
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import compatible_blk_continuous_mask
from tbe.tik.common.tik_get_soc_name import get_rep_size
from tbe.tik.common.tik_get_soc_name import get_block_size
from tbe.tik.common.tik_get_soc_name import is_compatible_mode
from tbe.tik.common.tik_get_soc_name import get_compatible_blk_size
from tbe.tik.common.tik_get_soc_name import get_compatible_rep_size
from tbe.tik.tik_lib.tik_api_util import reset_ctrl_value
from tbe.tik.tik_lib.tik_params import ONE_BYTE_BIT_LEN
from tbe.tik.tik_lib.tik_params import VREDUCE_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import VREDUCE_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import VSEL_TENSOR_TO_TENSOR_CMP_MODE
from tbe.tik.tik_lib.tik_params import VSEL_TENSOR_TO_SCALAR_CMP_MODE
from tbe.tik.tik_lib.tik_vector_api.tik_vector_name_map import SINGLE_NAME_DICT
from tbe.tik.tik_lib.tik_util import insert_set_deqscale_attr
from tbe.tik.tik_lib.tik_util import set_deqscale_attr_nano

_VCMP_REP_STRIDE = 0
VCMPVS_OFFSET_LIST = [16, 40, 56]
VCMPVS_SEGMENT_LIST = [16, 8, 8]


class VcmpOpApi:
    """
    Vcmp Ops
    """
    _VCMP_REPEAT_TIMES = 1

    def __init__(self, tik_instance, vcmp_api, mask_o=None):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = VCMP_NAME_DICT.get(vcmp_api.name)
        self.print_name = vcmp_api.name
        if hasattr(vcmp_api, "api_name"):
            self.name = vcmp_api.api_name
        self.control_op = ControlOp(vcmp_api.mask, self._VCMP_REPEAT_TIMES)
        self.src0_tensor_op = TensorOp(vcmp_api.src0, vcmp_api.src0_blk_stride, _VCMP_REP_STRIDE, "src0")
        self.src1_tensor_op = TensorOp(vcmp_api.src1, vcmp_api.src1_blk_stride, _VCMP_REP_STRIDE, "src1")
        # debug check instance
        self.check_params = (self.src0_tensor_op, self.src1_tensor_op, self.control_op)
        self.vcmp_check_obj = VcmpCheckParams(self.print_name, self.check_params, self.name)
        self.mask_o = mask_o

    @vcmp_decorator_new
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        strides = [_VCMP_REP_STRIDE, self.src0_tensor_op.blk_stride, self.src1_tensor_op.blk_stride,
                   _VCMP_REP_STRIDE, _VCMP_REP_STRIDE, _VCMP_REP_STRIDE]
        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.tik_instance.add_source_id()
            config = type_convert([self._VCMP_REPEAT_TIMES] + strides)
            if self.src0_tensor_op.tensor_obj.dtype == "int64":
                mask_mode = gen_b64_mask_mode(self.control_op.mask)
                config.extend(mask_mode)
            if self.src0_tensor_op.tensor_obj.dtype == "int16":
                instr = tvm.call_extern(
                    self.src0_tensor_op.tensor_obj.dtype, self.name,
                    self.src0_tensor_op.tensor_obj.reinterpret_cast_to("uint16").access_ptr("w"),
                    self.src1_tensor_op.tensor_obj.reinterpret_cast_to("uint16").access_ptr("r"),
                    *config)
            else:
                instr = tvm.call_extern(self.src0_tensor_op.tensor_obj.dtype, self.name,
                                        self.src0_tensor_op.tensor_obj.access_ptr("w"),
                                        self.src1_tensor_op.tensor_obj.access_ptr("r"),
                                        *config)
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *self.mask_o))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            # one ir is set_vector_mask, one is call_extern
            self.tik_instance.emit(instr)
        return CMPMASK_VAR

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        mask_o = self.vcmp_check_obj.check_all(self.tik_instance)
        if self.mask_o is None:
            self.mask_o = mask_o
        return self.gen_code()


class VcmpvOpApi:
    """
    Vcmpv Ops
    """
    _default_blk_stride = 1
    _default_rep_stride = 8

    def __init__(self, tik_instance, vcmpv_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = VCMP_NAME_DICT.get(vcmpv_api.name)
        self.print_name = vcmpv_api.name
        if hasattr(vcmpv_api, "api_name"):
            self.name = vcmpv_api.api_name
        self.control_op = ControlOp(repeat_times=vcmpv_api.repeat_times)
        self.dst_tensor_op = TensorOp(vcmpv_api.dst, self._default_blk_stride, self._default_rep_stride, "dst")
        self.src0_tensor_op = TensorOp(vcmpv_api.src0, vcmpv_api.src0_blk_stride, vcmpv_api.src0_rep_stride, "src0")
        self.src1_tensor_op = TensorOp(vcmpv_api.src1, vcmpv_api.src1_blk_stride, vcmpv_api.src1_rep_stride, "src1")
        # debug check instance
        self.check_params = (self.dst_tensor_op, self.src0_tensor_op, self.src1_tensor_op, self.control_op)
        self.vcmpv_check_obj = VcmpvCheckParams(self.name, self.check_params)
        self.mask_o = None

    @vcmpv_decorator_new
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        if TikSocManager.is_nano_soc():
            if is_compatible_mode():
                if isinstance(self.src0_tensor_op.blk_stride, int):
                    TikCheckUtil.check_equality(self.src0_tensor_op.blk_stride, 1,
                                                "In nano compatible mode, the vcmpv_xx api src0_blk_stride must be 1,"
                                                " input: %d." % self.src0_tensor_op.blk_stride)
                if isinstance(self.src1_tensor_op.blk_stride, int):
                    TikCheckUtil.check_equality(self.src1_tensor_op.blk_stride, 1,
                                                "In nano compatible mode, the vcmpv_xx api src1_blk_stride must be 1,"
                                                " input: %d." % self.src1_tensor_op.blk_stride)
                # In compatible mode, one repeat must be split into two non-compatible repeats.
                config = [2, self._default_blk_stride, self._default_blk_stride,
                          self._default_rep_stride, self._default_rep_stride]
                with self.tik_instance.for_range(0, self.control_op.repeat_times) as idx:
                    one_compatible_blk_size = get_compatible_blk_size()
                    one_compatible_rep_size = get_compatible_rep_size()
                    data_size = DTYPE_SIZE[self.src0_tensor_op.tensor_obj.dtype]
                    src0_offset = self.src0_tensor_op.rep_stride * one_compatible_blk_size // data_size * idx
                    src1_offset = self.src1_tensor_op.rep_stride * one_compatible_blk_size // data_size * idx
                    dst_bit_len = get_bit_len(self.dst_tensor_op.tensor_obj.dtype)
                    dst_offset = one_compatible_rep_size // data_size // dst_bit_len * idx
                    self._emit_instr(self.dst_tensor_op.tensor_obj[dst_offset:],
                                     self.src0_tensor_op.tensor_obj[src0_offset:],
                                     self.src1_tensor_op.tensor_obj[src1_offset:], config)
            else:
                config = [
                    self.control_op.repeat_times, self.src0_tensor_op.blk_stride, self.src1_tensor_op.blk_stride,
                    self.src0_tensor_op.rep_stride, self.src1_tensor_op.rep_stride]
                self._emit_instr(self.dst_tensor_op.tensor_obj, self.src0_tensor_op.tensor_obj,
                                 self.src1_tensor_op.tensor_obj, config)
        else:
            default_stride = 0
            config = [
                self.control_op.repeat_times, default_stride, self.src0_tensor_op.blk_stride,
                self.src1_tensor_op.blk_stride, default_stride, self.src0_tensor_op.rep_stride,
                self.src1_tensor_op.rep_stride]
            self._emit_instr(self.dst_tensor_op.tensor_obj, self.src0_tensor_op.tensor_obj,
                             self.src1_tensor_op.tensor_obj, config)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.vcmpv_check_obj.check_all()
        self.gen_code()

    def _emit_instr(self, dst, src0, src1, config):
        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.tik_instance.add_source_id()
            instr = tvm.call_extern(
                dst.dtype, self.name, dst.access_ptr("w", cast_dtype="uint8"),
                src0.access_ptr("r"), src1.access_ptr("r"), *type_convert(config))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            # 1 ir is call_extern
            self.tik_instance.emit(instr)


class VcmpvsOpApi:
    """
    Vcmpvs Ops
    """
    _default_blk_stride = 1
    _default_rep_stride = 8

    def __init__(self, tik_instance, vcmpvs_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = VCMP_NAME_DICT.get(vcmpvs_api.name)
        self.print_name = vcmpvs_api.name
        self.control_op = ControlOp(repeat_times=vcmpvs_api.repeat_times)
        self.dst_tensor_op = TensorOp(vcmpvs_api.dst, self._default_blk_stride, self._default_rep_stride, "dst")
        self.src_tensor_op = TensorOp(vcmpvs_api.src, vcmpvs_api.src_blk_stride, vcmpvs_api.src_rep_stride, "src")
        self.scalar_op = ScalarOp(vcmpvs_api.scalar, "scalar")
        # debug check instance
        self.check_params = (self.dst_tensor_op, self.src_tensor_op, self.scalar_op, self.control_op)
        self.vcmpvs_check_obj = VcmpvsCheckParams(self.name, self.check_params)
        self.mask_o = None

    @vcmpvs_decorator_new
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        scalar_tmp = dtype_convert(self.scalar_op.scalar_obj, self.src_tensor_op.tensor_obj.dtype)
        if TikSocManager.is_v300_610l_soc() or TikSocManager.is_v210_vec_soc():
            config = [self.control_op.repeat_times, self.src_tensor_op.rep_stride, self.src_tensor_op.blk_stride]
            args = type_convert(config)
            with self.tik_instance.new_scope():
                if TikSocManager.is_v300_610l_soc():
                    self.tik_instance.add_source_id()
                instr = tvm.call_extern(
                    self.dst_tensor_op.tensor_obj.dtype, self.name,
                    self.dst_tensor_op.tensor_obj.reinterpret_cast_to("uint8").access_ptr("w"),
                    self.src_tensor_op.tensor_obj.access_ptr("r"), scalar_tmp, *args)
                self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
                # 1 ir is call_extern
                self.tik_instance.emit(instr)
        elif TikSocManager.is_nano_soc() and is_compatible_mode():
            if isinstance(self.src_tensor_op.blk_stride, int):
                TikCheckUtil.check_equality(self.src_tensor_op.blk_stride, 1,
                                            "In nano compatible mode, the vcmpvs_xx api src0_blk_stride must be 1,"
                                            " input: %d." % self.src_tensor_op.blk_stride)
            config = [self._default_blk_stride, self._default_rep_stride, 2]
            args = concat_params(config, VCMPVS_OFFSET_LIST, VCMPVS_SEGMENT_LIST)
            with self.tik_instance.for_range(0, self.control_op.repeat_times) as idx:
                one_compatible_blk_size = get_compatible_blk_size()
                one_compatible_rep_size = get_compatible_rep_size()
                data_size = DTYPE_SIZE[self.src_tensor_op.tensor_obj.dtype]
                src_offset = self.src_tensor_op.rep_stride * one_compatible_blk_size // data_size * idx
                dst_bit_len = get_bit_len(self.dst_tensor_op.tensor_obj.dtype)
                dst_offset = one_compatible_rep_size // data_size // dst_bit_len * idx
                with self.tik_instance.new_scope():
                    instr = tvm.call_extern(
                        self.dst_tensor_op.tensor_obj.dtype, self.name,
                        self.dst_tensor_op.tensor_obj[dst_offset].reinterpret_cast_to("uint8").access_ptr("w"),
                        self.src_tensor_op.tensor_obj[src_offset].access_ptr("r"), scalar_tmp, args)
                    self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
                    # 1 ir is call_extern
                    self.tik_instance.emit(instr)
        else:
            config = [self.src_tensor_op.blk_stride, self.src_tensor_op.rep_stride, self.control_op.repeat_times]
            args = concat_params(config, VCMPVS_OFFSET_LIST, VCMPVS_SEGMENT_LIST)
            with self.tik_instance.new_scope():
                instr = tvm.call_extern(
                    self.dst_tensor_op.tensor_obj.dtype, self.name,
                    self.dst_tensor_op.tensor_obj.reinterpret_cast_to("uint8").access_ptr("w"),
                    self.src_tensor_op.tensor_obj.access_ptr("r"), scalar_tmp, args)
                self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
                # 1 ir is call_extern
                self.tik_instance.emit(instr)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.vcmpvs_check_obj.check_all()
        self.gen_code()


class VselOpApi:
    """
    Single Vector Ops
    """
    _BLOCK_LEN = 8

    def __init__(self, tik_instance, vsel_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.print_name = vsel_api.name
        self.name = VCMP_NAME_DICT.get(vsel_api.name)
        if hasattr(vsel_api, "api_name"):
            self.name = vsel_api.api_name
        self.control_op = ControlOp(vsel_api.mask, vsel_api.repeat_times)
        self.dst_tensor_op = TensorOp(vsel_api.dst, vsel_api.dst_blk_stride, vsel_api.dst_rep_stride, "dst")
        self.src0_tensor_op = TensorOp(vsel_api.src0, vsel_api.src0_blk_stride, vsel_api.src0_rep_stride, "src0")
        self.src1_tensor_op = TensorOp(vsel_api.src1, vsel_api.src1_blk_stride, vsel_api.src1_rep_stride, "src1")
        self.mode = vsel_api.mode
        self.mask_o = vsel_api.mask_o
        self.sel = vsel_api.sel
        self.int64_mode = False
        # debug check instance
        self.check_params1 = (self.dst_tensor_op, self.src0_tensor_op, self.src1_tensor_op, self.control_op)
        self.check_params2 = (self.mode, self.mask_o, self.sel)
        self.vsel_check_obj = VselCheckParams(self.print_name, self.check_params1, self.check_params2, self.name)

    @staticmethod
    def _calculate_extent(repeat_times, rep_stride, block_count, blk_stride):
        """
        calculate extent

        Parameters
        ----------
        repeat_times : Repeated iterations times
        rep_stride : stride of operator in the same block between repeats
        block_count: block number in one repeat
        blk_stride : stride of operator between different block

        Returns
        -------
        extent
        """
        extent = Expr(((repeat_times - 1) * rep_stride +
                       (block_count - 1) * blk_stride + 1) * get_block_size())
        return extent.get()

    def gen_instr(self, mem_access_param):
        """
        calculate extent

        Parameters
        ----------
        mem_access_param : memory access param

        Returns
        -------
        None
        """
        dst_access_ptr = self.dst_tensor_op.tensor_obj.access_ptr("w", extent=self._calculate_extent(
            self.control_op.repeat_times, self.dst_tensor_op.rep_stride, VselOpApi._BLOCK_LEN,
            self.dst_tensor_op.blk_stride))
        src0_access_ptr = self.src0_tensor_op.tensor_obj.access_ptr("r", extent=self._calculate_extent(
            self.control_op.repeat_times, self.src0_tensor_op.rep_stride, VselOpApi._BLOCK_LEN,
            self.src0_tensor_op.blk_stride))

        if not TikSocManager.is_v300_610l_soc() and not TikSocManager.is_v210_vec_soc() and not self.int64_mode:
            if self.mode == VSEL_TENSOR_TO_SCALAR_CMP_MODE:
                src1_access_ptr = self.sel.access_ptr("r", cast_dtype=self.src0_tensor_op.tensor_obj.dtype)
            else:
                src1_access_ptr = self.src1_tensor_op.tensor_obj.access_ptr("r", extent=self._calculate_extent(
                    self.control_op.repeat_times, self.src1_tensor_op.rep_stride, VselOpApi._BLOCK_LEN,
                    self.src1_tensor_op.blk_stride))
            instr = tvm.call_extern(self.dst_tensor_op.tensor_obj.dtype, "vsel",
                                    dst_access_ptr, src0_access_ptr, src1_access_ptr, mem_access_param)
        else:
            if self.mode == VSEL_TENSOR_TO_SCALAR_CMP_MODE:
                src1_access_ptr = type_convert(self.src1_tensor_op.tensor_obj, self.src0_tensor_op.tensor_obj.dtype)
                vsl_ptr = self.sel.access_ptr("r")
                mem_access_param.append(vsl_ptr)
            else:
                src1_access_ptr = self.src1_tensor_op.tensor_obj.access_ptr("r", extent=self._calculate_extent(
                    self.control_op.repeat_times, self.src1_tensor_op.rep_stride, VselOpApi._BLOCK_LEN,
                    self.src1_tensor_op.blk_stride))
                if self.mode == VSEL_TENSOR_TO_TENSOR_CMP_MODE:
                    vsl_ptr = self.sel.access_ptr("r")
                    mem_access_param.append(vsl_ptr)
            if self.int64_mode:
                mask_mode = gen_b64_mask_mode(self.control_op.mask)
                mem_access_param.extend(mask_mode)
            instr = tvm.call_extern(self.dst_tensor_op.tensor_obj.dtype, "vsel",
                                    dst_access_ptr, src0_access_ptr, src1_access_ptr, *mem_access_param)

        self.tik_instance.emit(instr)

    @vsel_decorator_new
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        # gen
        config = [self.dst_tensor_op.blk_stride, self.src0_tensor_op.blk_stride, self.src1_tensor_op.blk_stride,
                  self.dst_tensor_op.rep_stride, self.src0_tensor_op.rep_stride, self.src1_tensor_op.rep_stride,
                  self.mode, self.control_op.repeat_times]
        self.int64_mode = (self.dst_tensor_op.tensor_obj.dtype == "int64")

        args = concat_params(config, VSEL_OFFSET_LIST, VSEL_SEGMENT_LIST)
        if not TikSocManager.is_v300_610l_soc() and not TikSocManager.is_v210_vec_soc() and not self.int64_mode:
            # set cmpmask
            set_vsel_cmpmask(self.tik_instance, self.mode,
                             self.src0_tensor_op.tensor_obj, self.src1_tensor_op.tensor_obj, self.sel)
        else:
            args = [self.control_op.repeat_times,
                    self.dst_tensor_op.blk_stride, self.src0_tensor_op.blk_stride, self.src1_tensor_op.blk_stride,
                    self.dst_tensor_op.rep_stride, self.src0_tensor_op.rep_stride, self.src1_tensor_op.rep_stride,
                    self.mode]
        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.tik_instance.add_source_id()
            elif self.mode == 2:
                self.tik_instance.emit(tvm.call_extern("int32", "pipe_barrier",
                                                       tvm.call_cce_pure_intrin("int32", "tvm_cce_string_print",
                                                                                "PIPE_V")))
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *self.mask_o))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            mem_access_param = type_convert(args)
            self.gen_instr(mem_access_param)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.mask_o = self.vsel_check_obj.check_all(self.tik_instance)
        self.gen_code()


class VselOpNanoCompatibleApi(VselOpApi):

    def __init__(self, tik_instance, vsel_pararms, vsel_api):
        super(VselOpNanoCompatibleApi, self).__init__(tik_instance, vsel_api)
        self.tik_instance = tik_instance
        self.vsel_api = vsel_api
        self.vsel_pararms = vsel_pararms
        self.one_rep_ele = get_rep_size() // DTYPE_SIZE[self.vsel_api.dst.dtype]
        self.def_blk_stride = 1
        self.def_rep_stride = 0

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        if isinstance(self.vsel_api.dst_blk_stride, int):
            TikCheckUtil.check_equality(self.vsel_api.dst_blk_stride, 1,
                                        "In nano compatible mode, the vsel api dst_blk_stride must be 1,"
                                        " input: %d." % self.vsel_api.dst_blk_stride)
        if isinstance(self.vsel_api.src0_blk_stride, int):
            TikCheckUtil.check_equality(self.vsel_api.src0_blk_stride, 1,
                                        "In nano compatible mode, the vsel api src0_blk_stride must be 1,"
                                        " input: %d." % self.vsel_api.src0_blk_stride)
        if isinstance(self.vsel_api.src1_blk_stride, int) and self.vsel_api.mode != 1:
            TikCheckUtil.check_equality(self.vsel_api.src1_blk_stride, 1,
                                        "In nano compatible mode, the vsel api src1_blk_stride must be 1,"
                                        " input: %d." % self.vsel_api.src1_blk_stride)
        mask_o = mask_concat(self.tik_instance, self.vsel_api.mask,
                             tensor_bit_len=get_bit_len(self.vsel_api.src0.dtype))
        mask_o1, mask_o2 = compatible_blk_continuous_mask(mask_o, DTYPE_SIZE[self.vsel_api.src0.dtype])

        if self.vsel_api.mode == 0:
            TikCheckUtil.check_equality(self.vsel_api.name, "vec_sel",
                                        "In nano compatible mode, vsel doesn't support mode 0")
            self._vsel_nano_compatible_mode_0(mask_o1, mask_o2)
        elif self.vsel_api.mode == 1:
            self._vsel_nano_compatible_mode_1(mask_o1, mask_o2)
        else:
            self._vsel_nano_compatible_mode_2(mask_o1, mask_o2)

    def _vsel_nano_compatible_mode_0(self, mask_o1, mask_o2):
        """
        In non-compatible mode, mode param is 0, split left and right and calculate the result twice.
        """
        rep_offset = self.tik_instance.Scalar("uint32", init_value=self.one_rep_ele)
        scalar_sel_offset = self.tik_instance.Scalar(dtype=self.vsel_api.sel.dtype, init_value=8)
        sel2 = self.tik_instance.mov_tensor_to_cmpmask(self.vsel_api.sel[scalar_sel_offset:])
        vsel_api = self.vsel_pararms(
            mask_o2, self.vsel_api.mode,
            self.vsel_api.dst[rep_offset:], sel2, self.vsel_api.src0[rep_offset:],
            self.vsel_api.src1[rep_offset:], self.vsel_api.repeat_times,
            self.vsel_api.dst_blk_stride, self.vsel_api.src0_blk_stride, self.vsel_api.src1_blk_stride,
            self.vsel_api.dst_rep_stride * 2, self.vsel_api.src0_rep_stride * 2, self.vsel_api.src1_rep_stride * 2,
            self.vsel_api.name, mask_o2)
        vsel_obj = VselOpApi(self.tik_instance, vsel_api)
        vsel_obj.run_all()

        sel1 = self.tik_instance.mov_tensor_to_cmpmask(self.vsel_api.sel)
        vsel_api = self.vsel_pararms(
            mask_o1, self.vsel_api.mode,
            self.vsel_api.dst, sel1, self.vsel_api.src0, self.vsel_api.src1,
            self.vsel_api.repeat_times,
            self.vsel_api.dst_blk_stride, self.vsel_api.src0_blk_stride, self.vsel_api.src1_blk_stride,
            self.vsel_api.dst_rep_stride * 2, self.vsel_api.src0_rep_stride * 2, self.vsel_api.src1_rep_stride * 2,
            self.vsel_api.name, mask_o1)
        vsel_obj = VselOpApi(self.tik_instance, vsel_api)
        vsel_obj.run_all()

    def _vsel_nano_compatible_mode_1(self, mask_o1, mask_o2):
        """
        In non-compatible mode, mode param is 1, Each repeat splits the left and right calculation results.
        """
        one_compatible_blk_size = get_compatible_blk_size()
        data_type_size = DTYPE_SIZE[self.vsel_api.dst.dtype]
        sel_temp_ub = self.tik_instance.Tensor(self.vsel_api.src0.dtype, (self.one_rep_ele,),
                                               name="sel_temp_ub", scope=scope_ubuf)
        self.tik_instance.vec_dup(self.one_rep_ele, sel_temp_ub, self.vsel_api.src1, 1, 8)
        with self.tik_instance.for_range(0, self.vsel_api.repeat_times) as idx:
            dst_offset1 = one_compatible_blk_size * self.vsel_api.dst_rep_stride // data_type_size * idx
            src0_offset1 = one_compatible_blk_size * self.vsel_api.src0_rep_stride // data_type_size * idx
            sel_offset1 = get_compatible_rep_size() // data_type_size // ONE_BYTE_BIT_LEN * idx
            vsel_api = self.vsel_pararms(
                mask_o1, 2,
                self.vsel_api.dst[dst_offset1:], self.vsel_api.sel[sel_offset1:],
                self.vsel_api.src0[src0_offset1:], sel_temp_ub,
                1, self.def_blk_stride, self.def_blk_stride, self.def_blk_stride,
                self.def_rep_stride, self.def_rep_stride, self.def_rep_stride,
                self.vsel_api.name, mask_o1)
            vsel_obj = VselOpApi(self.tik_instance, vsel_api)
            vsel_obj.run_all()

            dst_offset2 = dst_offset1 + self.one_rep_ele
            src0_offset2 = src0_offset1 + self.one_rep_ele
            sel_offset2 = sel_offset1 + self.one_rep_ele // ONE_BYTE_BIT_LEN
            vsel_api = self.vsel_pararms(
                mask_o2, 2,
                self.vsel_api.dst[dst_offset2:], self.vsel_api.sel[sel_offset2:],
                self.vsel_api.src0[src0_offset2:], sel_temp_ub,
                1, self.def_blk_stride, self.def_blk_stride, self.def_blk_stride,
                self.def_rep_stride, self.def_rep_stride, self.def_rep_stride,
                self.vsel_api.name, mask_o2)
            vsel_obj = VselOpApi(self.tik_instance, vsel_api)
            vsel_obj.run_all()

    def _vsel_nano_compatible_mode_2(self, mask_o1, mask_o2):
        """
        In non-compatible mode, mode param is 2, Each repeat splits the left and right calculation results.
        """
        one_compatible_blk_size = get_compatible_blk_size()
        data_type_size = DTYPE_SIZE[self.vsel_api.dst.dtype]
        with self.tik_instance.for_range(0, self.vsel_api.repeat_times) as idx:
            dst_offset1 = one_compatible_blk_size * self.vsel_api.dst_rep_stride // data_type_size * idx
            src0_offset1 = one_compatible_blk_size * self.vsel_api.src0_rep_stride // data_type_size * idx
            src1_offset1 = one_compatible_blk_size * self.vsel_api.src1_rep_stride // data_type_size * idx
            sel_offset1 = get_compatible_rep_size() // data_type_size // ONE_BYTE_BIT_LEN * idx
            vsel_api = self.vsel_pararms(
                mask_o1, self.vsel_api.mode,
                self.vsel_api.dst[dst_offset1:], self.vsel_api.sel[sel_offset1:],
                self.vsel_api.src0[src0_offset1:], self.vsel_api.src1[src1_offset1:],
                1, self.def_blk_stride, self.def_blk_stride, self.def_blk_stride,
                self.def_rep_stride, self.def_rep_stride, self.def_rep_stride,
                self.vsel_api.name, mask_o1)
            vsel_obj = VselOpApi(self.tik_instance, vsel_api)
            vsel_obj.run_all()

            dst_offset2 = dst_offset1 + self.one_rep_ele
            src0_offset2 = src0_offset1 + self.one_rep_ele
            src1_offset2 = src1_offset1 + self.one_rep_ele
            sel_offset2 = sel_offset1 + self.one_rep_ele // ONE_BYTE_BIT_LEN
            vsel_api = self.vsel_pararms(
                mask_o2, self.vsel_api.mode,
                self.vsel_api.dst[dst_offset2:], self.vsel_api.sel[sel_offset2:],
                self.vsel_api.src0[src0_offset2:], self.vsel_api.src1[src1_offset2:],
                1, self.def_blk_stride, self.def_blk_stride, self.def_blk_stride,
                self.def_rep_stride, self.def_rep_stride, self.def_rep_stride,
                self.vsel_api.name, mask_o2)
            vsel_obj = VselOpApi(self.tik_instance, vsel_api)
            vsel_obj.run_all()


class VreduceOp:
    """
    Vreduce Ops
    """

    def __init__(self, tik_instance, vreduce_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.print_name = vreduce_api.name
        self.name = VCMP_NAME_DICT.get(vreduce_api.name)
        self.control_op = ControlOp(vreduce_api.mask, vreduce_api.repeat_times,
                                    vreduce_api.stride_unit, vreduce_api.mask_mode)
        self.dst_tensor_op = TensorOp(vreduce_api.dst, 0, 0, "dst")
        self.src0_tensor_op = TensorOp(vreduce_api.src0, vreduce_api.src0_blk_stride,
                                       vreduce_api.src0_rep_stride, "src0")
        self.src1_tensor_op = TensorOp(vreduce_api.src1_pattern, 0, vreduce_api.src1_rep_stride, "src1_pattern")
        self.rsvd_scalar = vreduce_api.rsvd_scalar

        # debug check instance
        self.check_params = (self.dst_tensor_op, self.src0_tensor_op, self.src1_tensor_op, self.control_op)
        self.vreduce_check_obj = VreduceCheckParams(self.print_name, self.check_params, self.rsvd_scalar)
        self.mask_o = None
        self.dst_extent = None
        self.src0_extent = None
        self.src1_extent = None
        self.pattern = None

    @staticmethod
    def gen_access_ptr(tensor, dtype_str, mode, extent, is_implicit=False):
        """
        gen access ptr

        Parameters
        ----------
        tensor : dst, src0, src1
        dtype_str : dtype str
        mode : "w" or "r"
        extent : tensor's entent

        Returns
        -------
        access_ptr
        """
        access_ptr = tensor.reinterpret_cast_to(dtype_str).access_ptr(mode, extent=extent, is_implicit=is_implicit)
        return access_ptr

    def gen_config_args(self):
        """
        gen config args

        Returns
        -------
        args
        """
        if self.print_name == "vreduce":
            config = [self.src0_tensor_op.blk_stride, self.pattern, self.src0_tensor_op.rep_stride,
                      self.src1_tensor_op.rep_stride, self.control_op.stride_unit, self.control_op.repeat_times]
            args = [concat_params(config, VREDUCE_OFFSET_LIST, VREDUCE_SEGMENT_LIST)]
        else:
            config = [self.control_op.repeat_times, self.src0_tensor_op.blk_stride, self.pattern,
                      self.src0_tensor_op.rep_stride, self.src1_tensor_op.rep_stride]
            args = type_convert(config)
        return args

    @vreduce_decorator
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        args = self.gen_config_args()
        dtype_str = change_dtype_str(self.dst_tensor_op.tensor_obj)
        if self.control_op.mask_mode == "counter":
            if not TikSocManager.is_v300_610l_soc():
                orig_ctrl = set_ctrl_counter_mask(self.tik_instance)
            with self.tik_instance.new_scope():
                mask_o = mask_concat(self.tik_instance, self.control_op.mask,
                                     self.control_op.mask_mode, get_bit_len(self.dst_tensor_op.tensor_obj.dtype))
                self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *mask_o))
        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.tik_instance.add_source_id()
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            dst_access_ptr = self.gen_access_ptr(self.dst_tensor_op.tensor_obj, dtype_str, "w", self.dst_extent)
            src0_access_ptr = self.gen_access_ptr(self.src0_tensor_op.tensor_obj, dtype_str, "r", self.src0_extent)
            if isinstance(self.src1_tensor_op.tensor_obj, Tensor):
                src1_access_ptr = self.gen_access_ptr(self.src1_tensor_op.tensor_obj, dtype_str, "r", self.src1_extent)
                src1_tensor = 0
            else:
                src1_access_ptr = src0_access_ptr
                src1_tensor = self.src1_tensor_op.tensor_obj
            if TikSocManager.is_v300_610l_soc():
                vreduce_param_list = [self.dst_tensor_op.tensor_obj.dtype, self.print_name,
                                      dst_access_ptr, src0_access_ptr, src1_access_ptr,
                                      *type_convert([src1_tensor]),
                                      *type_convert([self.control_op.repeat_times]),
                                      *type_convert([self.src0_tensor_op.blk_stride]),
                                      *type_convert([self.src0_tensor_op.rep_stride]),
                                      *type_convert([self.src1_tensor_op.rep_stride]),
                                      *type_convert([self.control_op.stride_unit]),
                                      *type_convert([1]), *type_convert([1]), *type_convert([8]),
                                      self.control_op.mask_mode]
                instr = tvm.call_extern(*vreduce_param_list)
            else:
                instr = tvm.call_extern(self.dst_tensor_op.tensor_obj.dtype, self.print_name,
                                        dst_access_ptr, src0_access_ptr, src1_access_ptr, *args)
            self.tik_instance.emit(instr)
        # reset CTRL SPR as orig_ctrl
        if self.control_op.mask_mode == "counter" and not TikSocManager.is_v300_610l_soc():
            reset_ctrl_value(self.tik_instance, orig_ctrl)
        # read RSVD
        if isinstance(self.rsvd_scalar, Scalar):
            with self.tik_instance.new_scope():
                tvm_rsvd_scalar = self.rsvd_scalar.get()
                if TikSocManager.is_v300_610l_soc():
                    # because dst_tensor may not be used later,
                    # it needs to be used here as implicit_tvm_access_ptr to prevent optimization.
                    implicit_dst_access_ptr = self.gen_access_ptr(
                        self.dst_tensor_op.tensor_obj, dtype_str, "w", self.dst_extent, is_implicit=True)
                    # the uint of get_ar value is Byte, and the uint of rsvd_scalar value is element number
                    # the value of get_ar needs to be divided by dst tensor dtype.
                    self.tik_instance.emit(
                        tvm.call_extern('handle', "reg_set", tvm_rsvd_scalar,
                                        tvm.tir.Div(tvm.call_extern("int64", "get_ar"),
                                                    DTYPE_SIZE[self.dst_tensor_op.tensor_obj.dtype]),
                                                    implicit_dst_access_ptr))
                else:
                    self.tik_instance.emit(tvm.call_extern(self.rsvd_scalar.dtype, "reg_set", tvm_rsvd_scalar,
                                                           tvm.call_extern(self.rsvd_scalar.dtype, "get_rsvd_cnt")))

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.dst_extent, self.src0_extent, self.src1_extent, self.pattern = self.vreduce_check_obj.check_all()
        self.gen_code()


class VconvOpApi(TikIRBuilder):
    """
    Vconv Ops
    """
    _BLOCK_LEN = 8
    VDEQ_BLK_STRIDE = 0
    VDEQ_REP_STRIDE = 0

    def __init__(self, tik_instance, vconv):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = SINGLE_NAME_DICT.get(vconv.name)
        self.print_name = vconv.name
        if hasattr(vconv, "api_name"):
            self.name = vconv.api_name
        self.control_op = ControlOp(vconv.mask, vconv.repeat_times, vconv.stride_unit)
        self.dst_tensor_op = TensorOp(vconv.dst, vconv.dst_blk_stride, vconv.dst_rep_stride, "dst")
        self.src_tensor_op = TensorOp(vconv.src, vconv.src_blk_stride, vconv.src_rep_stride, "src")
        self.deqscale_op = TensorOp(vconv.deqscale, VconvOpApi.VDEQ_BLK_STRIDE, VconvOpApi.VDEQ_REP_STRIDE, "deqscale")
        self.round_mode = vconv.round_mode

        self.ldst_high_half = vconv.ldst_high_half
        self.mask_o = vconv.mask_o

        self.check_params1 = (self.dst_tensor_op, self.src_tensor_op, self.deqscale_op, self.control_op)
        self.check_params2 = (self.round_mode, self.ldst_high_half, self.mask_o)
        self.vonv_check_obj = VconvCheckParams(self.print_name, self.check_params1, self.check_params2)
        self.dtype_str = None
        self.deqscale = None

    @vconv_decorator_new
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        args = [self.control_op.repeat_times, self.dst_tensor_op.blk_stride, self.src_tensor_op.blk_stride,
                self.dst_tensor_op.rep_stride, self.src_tensor_op.rep_stride]
        if TikSocManager.is_v200_soc() or (TikSocManager.is_v210_soc() and TikSocManager.is_aicore_core()):
            args.append(self.control_op.stride_unit & 0b01)
            args.append((self.control_op.stride_unit & 0b10) >> 1)
        if self.dtype_str in ["deqs162b8", "vdeqs162b8"]:
            if TikSocManager.is_910b_soc():
                ldst_str_map = {True: "h", False: "l"}
                self.dtype_str += ldst_str_map.get(self.ldst_high_half)
            else:
                args.append(int(self.ldst_high_half))
        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.tik_instance.add_source_id()
            instr = tvm.call_extern(
                self.dst_tensor_op.tensor_obj.dtype, "vconv_" + self.dtype_str,
                self.dst_tensor_op.tensor_obj.access_ptr("w", extent=self._calculate_extent(
                    VconvOpApi._BLOCK_LEN, self.dst_tensor_op)),
                self.src_tensor_op.tensor_obj.access_ptr("r", extent=self._calculate_extent(
                    VconvOpApi._BLOCK_LEN, self.src_tensor_op)),
                *type_convert(args))
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *self.mask_o))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            if isinstance(self.deqscale, Tensor):
                self.tik_instance.scope_attr(tvm.thread_axis("cce"), "append_mem",
                                             tvm.call_extern("handle", "mem_vector", self.deqscale.access_ptr("r")))
            self.tik_instance.emit(instr)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.dtype_str, self.deqscale, self.mask_o = self.vonv_check_obj.check_all(self.tik_instance)
        # deqscale
        if "deq" in self.dtype_str:
            if TikSocManager.is_nano_soc():
                set_deqscale_attr_nano(self.tik_instance, self.deqscale)
            else:
                insert_set_deqscale_attr(self.tik_instance, self.deqscale,
                                         self.dtype_str, self.dst_tensor_op.tensor_obj.dtype)
        self.gen_code()

    def _calculate_extent(self, block_count, tensor_op):
        """
        calculate extent

        Parameters
        ----------
        repeat_times : Repeated iterations times
        rep_stride : stride of operator in the same block between repeats
        block_count: block number in one repeat
        blk_stride : stride of operator between different block

        Returns
        -------
        extent
        """
        extent_number = ((self.control_op.repeat_times - 1) * tensor_op.rep_stride +
                         (block_count - 1) * tensor_op.blk_stride + 1)
        extent = Expr(extent_number * ONE_BLK_SIZE)
        return extent.get()


class VconvOpApiNano(VconvOpApi):

    def _blklen_16_gen_code(self, params_list):
        mask_o, dst, src = params_list
        config = [self.control_op.repeat_times,
                  self.dst_tensor_op.blk_stride, self.src_tensor_op.blk_stride,
                  self.dst_tensor_op.rep_stride, self.src_tensor_op.rep_stride]
        with self.tik_instance.new_scope():
            instr = tvm.call_extern(
                dst.dtype, "vconv_" + self.dtype_str,
                dst.access_ptr("w", extent=self._calculate_extent(VconvOpApi._BLOCK_LEN, self.dst_tensor_op)),
                src.access_ptr("r", extent=self._calculate_extent(VconvOpApi._BLOCK_LEN, self.src_tensor_op)),
                *type_convert(config))
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *mask_o))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(instr)

    @vconv_decorator_new
    def gen_code(self):
        if is_compatible_mode():
            max_dtype_size = max(DTYPE_SIZE[self.dst_tensor_op.tensor_obj.dtype],
                                 DTYPE_SIZE[self.src_tensor_op.tensor_obj.dtype])
            mask_o1, mask_o2 = compatible_blk_continuous_mask(self.mask_o, max_dtype_size)

            self.dst_tensor_op.blk_stride = self.dst_tensor_op.blk_stride
            self.src_tensor_op.blk_stride = self.src_tensor_op.blk_stride
            self.dst_tensor_op.rep_stride = self.dst_tensor_op.rep_stride * 2
            self.src_tensor_op.rep_stride = self.src_tensor_op.rep_stride * 2

            tensor_obj_offset = self.tik_instance.Scalar("int32", init_value=get_rep_size() // max_dtype_size)
            self._blklen_16_gen_code((mask_o2,
                                      self.dst_tensor_op.tensor_obj[tensor_obj_offset:],
                                      self.src_tensor_op.tensor_obj[tensor_obj_offset:]))

            self._blklen_16_gen_code((mask_o1, self.dst_tensor_op.tensor_obj, self.src_tensor_op.tensor_obj))


        else:
            self._blklen_16_gen_code((self.mask_o, self.dst_tensor_op.tensor_obj, self.src_tensor_op.tensor_obj))

