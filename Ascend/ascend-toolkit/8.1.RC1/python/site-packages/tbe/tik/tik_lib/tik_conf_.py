#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_conf_.py
DESC:     configuration of tik
CREATED:  2019-04-18 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""
from tbe.common.platform import set_current_compile_soc_info
from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.platform import scope_cbuf
from tbe.common.platform import scope_ubuf
from tbe.common.platform import scope_ca
from tbe.common.platform import scope_cb
from tbe.common.platform import scope_cc
from tbe.common.platform import scope_smask
from tbe.common.platform import scope_vreg
from tbe.common.platform import scope_preg
from tbe.common.platform import scope_areg
from tbe.common.platform import scope_ureg
from tbe.common.platform import scope_wreg
from tbe.common.platform.platform_info import scope_fb0
from tbe.common.platform.platform_info import scope_bt
from tbe.common.context import get_context
from tbe.common.context.op_context import OpContext
from tbe.tik.common.tik_api_map import AIC_610
from tbe.tik.common.tik_api_map import AIC_310P
from tbe.tik.common.tik_api_map import AIC_031
from tbe.tik.common.tik_api_map import VEC_031
from tbe.tik.common.tik_api_map import VEC_310B
from tbe.tik.common.tik_api_map import AIC_310B
from tbe.tik.common.tik_api_map import VEC_310M
from tbe.tik.common.tik_api_map import AIC_310M
from tbe.tik.common.tik_api_map import AIC_610L
from tbe.tik.common.tik_api_map import AIC_BS9SX2A
from tbe.tik.common.tik_api_map import AIC_MC61AM21A
from tbe.tik.common.tik_api_map import ASCEND_035AIC
from tbe.tik.common.tik_api_map import HI3796CV300ESAIC
from tbe.tik.common.tik_api_map import HI3796CV300CSAIC
from tbe.tik.common.tik_api_map import SD3403AIC
from tbe.tik.common.tik_api_map import VEC_610
from tbe.tik.common.tik_api_map import VEC_310P
from tbe.tik.common.tik_api_map import ASCEND_910BAIC
from tbe.tik.common.tik_api_map import ASCEND_910BVEC
from tbe.tik.common.tik_api_map import ASCEND_910_93AIC
from tbe.tik.common.tik_api_map import ASCEND_910_93VEC
from tbe.tik.common.tik_api_map import AIC_BS9SX1A
from tbe.tik.common.tik_api_map import VEC_BS9SX1A
from tbe.tik.common.tik_api_map import ASCEND_910
from tbe.tik.common.tik_api_map import ASCEND_310
from tbe.tik.common.tik_api_map import HI3796CV300CS
from tbe.tik.common.tik_api_map import HI3796CV300ES
from tbe.tik.common.tik_api_map import SD3403
from tbe.tik.common.tik_api_map import ASCEND_610
from tbe.tik.common.tik_api_map import BS9SX1A
from tbe.tik.common.tik_api_map import ASCEND_910AIC
from tbe.tik.common.tik_api_map import ASCEND_310AIC
from tbe.tik.common.tik_api_map import ASCEND_310P
from tbe.tik.common.tik_api_map import ASCEND_310B
from tbe.tik.tik_lib.tik_params import KB_SIZE
from tbe.tik.tik_lib.tik_params import L1_BUFFER
from tbe.tik.tik_lib.tik_params import UB_BUFFER
from tbe.tik.tik_lib.tik_params import L0A_BUFFER
from tbe.tik.tik_lib.tik_params import L0B_BUFFER
from tbe.tik.tik_lib.tik_params import LOC_BUFFER
from tbe.tik.tik_lib.tik_params import SMASK_BUFFER
from tbe.tik.tik_lib.tik_params import FB0_BUFFER
from tbe.tik.tik_lib.tik_params import BT_BUFFER
from tbe.tik.tik_lib.tik_params import VECTOR_REG
from tbe.tik.tik_lib.tik_params import PREDICATE_REG
from tbe.tik.tik_lib.tik_params import ADDRESS_REG
from tbe.tik.tik_lib.tik_params import ADDRESS_REG_SIZE
from tbe.tik.tik_lib.tik_params import ALIGNMENT_REG
from tbe.tik.tik_lib.tik_params import ALIGNMENT_REG_SIZE
from tbe.tik.tik_lib.tik_params import WIDE_REG
from tbe.tik.tik_lib.tik_source_info import TikSourceInfo
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.common.tik_get_soc_name import TIK_SOC_INFO
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_soc_core_type

SET_PRODUCT_FLAG = {"is_set_product_version": False}


def _get_buffers_parameter(buffer_arch_list):
    """
    According  D core information,buffers parameters can be known.

    Parameters
    ----------
    buffer_arch_list:D aicore information

    Returns
    ----------
    return:buffers_map
    buffers_map: L0A/B/C,L1 and UB buffer memory size

    """
    buffer_names = [L1_BUFFER, UB_BUFFER,
                    L0A_BUFFER, L0B_BUFFER, LOC_BUFFER, SMASK_BUFFER, FB0_BUFFER, BT_BUFFER]
    buffer_arch = {}
    for buffer_params in buffer_arch_list:
        for buffer_name in buffer_names:
            if buffer_params.find(buffer_name) != 0:
                continue
            buffer_paras = buffer_params.split(' ')
            if buffer_name == SMASK_BUFFER:
                buffer_size = buffer_paras[-1].split("B")[0]
                buffer_arch[buffer_name] = int(buffer_size)
            else:
                buffer_size = buffer_paras[-1].split("KB")[0]
                buffer_arch[buffer_name] = int(buffer_size)*KB_SIZE
    return buffer_arch


def _get_regs_parameter(reg_arch_list):
    """
    According D core information, reg parameters can be known.

    Parameters
    ----------
    reg_arch_list: D aicore information

    Returns
    ----------
    return:reg_arch
    reg_arch: vector, address, predicate reg size

    """
    reg_names = [VECTOR_REG, ADDRESS_REG, PREDICATE_REG, ALIGNMENT_REG, WIDE_REG]
    reg_arch = {}
    for buffer_params in reg_arch_list:
        for reg_name in reg_names:
            if buffer_params.find(reg_name) == 0:
                reg_paras = buffer_params.split(' ')
                reg_size = reg_paras[-1].split("B")[0]
                reg_arch[reg_name] = int(reg_size)
    return reg_arch


class Dprofile1:
    """
    ai_core profile explanation
    """
    def __init__(self, ai_core_arch=None, ai_core_version=None, ddk_version=None):
        """
        ai_core profile initialization
        Parameters
        ----------
        ai_core_arch : ai_core architecture
        ai_core_version: ai_core version

        Returns
        -------
        """
        # need TikSourceInfo() init function to set source_info None first
        TikSourceInfo.clear_source_info()  # clear first, for add is_inited
        self.source_info = TikSourceInfo()
        self.source_info.register_source_info(depth=2)
        if ddk_version is None and not SET_PRODUCT_FLAG.get("is_set_product_version") and \
                ai_core_arch is not None and ai_core_version is not None:
            TikCheckUtil.check_type_match(ai_core_arch, str,
                                          "ai_core_arch should be str")
            TikCheckUtil.check_type_match(ai_core_version, str,
                                          "ai_core_version should be str")
            self.ai_core_arch = ai_core_arch.lower()
            self.ai_core_version = ai_core_version.lower()
            # version
            self._core_version, self._core_type =\
                _gen_version(self.ai_core_arch, self.ai_core_version)
            set_current_compile_soc_info(self._core_version, core_type=self._core_type)
            TIK_SOC_INFO.soc_name = None
            TIK_SOC_INFO.soc_core_type = None
        # we will use cce product params to represent ai core arch and version.
        # map for save device buffer info
        self.ai_core_buffer = {}
        self.ai_core_reg = {}
        self.registe()

        self.source_info.clear_source_info()

    @staticmethod
    @source_info_decorator()
    def get_aicore_num():
        """
        return ai_core number for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:ai_core number
        """
        return get_soc_spec("CORE_NUM")

    @staticmethod
    @source_info_decorator()
    def get_l1_buffer_size():
        """
        return l1 buffer size for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:l1_buffer_size
        """
        return _get_l1_size()

    @staticmethod
    @source_info_decorator()
    def get_l0a_buffer_size():
        """
        return l0a_buffer buffer size for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:l0a_buffer_size
        """
        return _get_l0a_size()

    @staticmethod
    @source_info_decorator()
    def get_l0b_buffer_size():
        """
        return l0b_buffer buffer size for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:l0a_buffer_size
        """
        return _get_l0b_size()

    @staticmethod
    @source_info_decorator()
    def get_l0c_buffer_size():
        """
        return l0c_buffer buffer size for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:l0c_buffer_size
        """
        return _get_l0c_size()

    @staticmethod
    @source_info_decorator()
    def get_vector_reg_size():
        """
        return vreg size for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:vector_reg size
        """
        return _get_vreg_size()

    @staticmethod
    @source_info_decorator()
    def get_predicate_reg_size():
        """
        return predicate reg size for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:predicate_reg size
        """
        return _get_preg_size()

    @staticmethod
    @source_info_decorator()
    def get_address_reg_size():
        """
        return address reg size for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:address_reg size
        """
        return ADDRESS_REG_SIZE

    @staticmethod
    @source_info_decorator()
    def get_alignment_reg_size():
        """
        return alignment reg size for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:alignment_reg size
        """
        return ALIGNMENT_REG_SIZE

    @staticmethod
    @source_info_decorator()
    def get_wide_reg_size():
        """
        return wreg size for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:vector_reg size
        """
        return _get_wreg_size()

    @staticmethod
    @source_info_decorator()
    def get_product_name():
        """
        return product_name for specify ai core
        Parameters
        ----------

        Returns
        -------
        return:product_name
        """
        return _get_product_name()

    def buffer_size_query(self, buffer_scope=None):
        """
        according the AI core params, get the buffer params, for_example:LOA/B/C,L01,UB buffer
        Parameters
        ----------
        buffer_scope: value is scope_cbuf, scope_ubuf, scope_ca, scope_cb, scope_cc

        Returns
        -------
        return:ai_core buffer params
        """
        key_map = {scope_cbuf: L1_BUFFER,
                   scope_ubuf: UB_BUFFER,
                   scope_ca: L0A_BUFFER,
                   scope_cb: L0B_BUFFER,
                   scope_cc: LOC_BUFFER,
                   scope_smask: SMASK_BUFFER,
                   scope_fb0: FB0_BUFFER,
                   scope_bt: BT_BUFFER}
        key_name = get_soc_name() + get_soc_core_type()
        buffer_arch_list = self.ai_core_buffer.get(key_name)
        buffer_arch = _get_buffers_parameter(buffer_arch_list)
        if buffer_scope is None:
            buffer_map = {scope_cbuf: 0, scope_ubuf: 0, scope_ca: 0,
                          scope_cb: 0, scope_cc: 0, scope_smask: 0, scope_fb0: 0, scope_bt: 0}
            for scope in key_map:
                buffer_map[scope] = buffer_arch.get(key_map.get(scope))
            return buffer_map
        TikCheckUtil.check_var_in_list(
            buffer_scope, key_map.keys(), "buffer_scope value is not correct!")
        return buffer_arch.get(key_map.get(buffer_scope))

    def reg_size_query(self, reg_scope=None):
        """
        according the AI core params, get the reg params, for_example:vector/address/predicate reg
        Parameters
        ----------
        reg_scope:value is scope_vreg, scope_areg, scope_preg

        Returns
        -------
        return:reg params
        """
        key_map = {scope_vreg: VECTOR_REG,
                   scope_preg: PREDICATE_REG,
                   scope_areg: ADDRESS_REG,
                   scope_ureg: ALIGNMENT_REG,
                   scope_wreg: WIDE_REG}
        key_name = get_soc_name() + get_soc_core_type()
        reg_arch_list = self.ai_core_reg.get(key_name)
        reg_arch = _get_regs_parameter(reg_arch_list)
        if reg_scope is None:
            reg_map = {scope_vreg: 0, scope_preg: 0, scope_areg: 0,
                       scope_ureg: 0, scope_wreg: 0}
            for scope in key_map:
                reg_map[scope] = reg_arch.get(key_map.get(scope))
            return reg_map
        TikCheckUtil.check_var_in_list(
            reg_scope, key_map.keys(), "reg_scope value is not correct!")
        return reg_arch[key_map[reg_scope]]

    def registe(self):
        """
        ai_core register configure
        Parameters
        ----------

        Returns
        -------
        return:no return
        """
        # get the device buffer info
        _smask_map = {
            AIC_610: 256,
            AIC_310P: 256,
            VEC_610: 0,
            VEC_310P: 0,
            HI3796CV300ESAIC: 256,
            HI3796CV300CSAIC: 256,
            SD3403AIC: 256,
            ASCEND_310AIC: 0,
            ASCEND_910AIC: 0,
            ASCEND_910BAIC: 0,
            ASCEND_910BVEC: 0,
            ASCEND_910_93AIC: 0,
            ASCEND_910_93VEC: 0,
            AIC_BS9SX1A: 256,
            VEC_BS9SX1A: 0,
            AIC_031: 0,
            VEC_031: 0,
            VEC_310B: 0,
            AIC_310B: 0,
            VEC_310M: 0,
            AIC_310M: 0,
            AIC_610L: 0,
            AIC_BS9SX2A: 0,
            AIC_MC61AM21A: 0,
            ASCEND_035AIC: 0,
        }
        l1_buffer = _get_l1_size()
        ub_buffer = _get_ub_size()
        l0a_buffer = _get_l0a_size()
        l0b_buffer = _get_l0b_size()
        l0c_buffer = _get_l0c_size()
        key_name = get_soc_name() + get_soc_core_type()
        smask_buffer = _smask_map.get(key_name)
        vreg_size = _get_vreg_size()
        preg_size = _get_preg_size()
        areg_size = ADDRESS_REG_SIZE
        ureg_size = ALIGNMENT_REG_SIZE
        wreg_size = _get_wreg_size()
        fb0_size = _get_fb0_size()
        bt_size = _get_bt_size()

        # save the device buffer info into the map
        self.ai_core_buffer[key_name] = ["L1_Buffer: " + str(l1_buffer // KB_SIZE) + "KB",
                                         "Unified_Buffer: " + str(ub_buffer // KB_SIZE) + "KB",
                                         "L0A_Buffer: " + str(l0a_buffer // KB_SIZE) + "KB",
                                         "L0B_Buffer: " + str(l0b_buffer // KB_SIZE) + "KB",
                                         "L0C_Buffer: " + str(l0c_buffer // KB_SIZE) + "KB",
                                         "SMASK_Buffer: " + str(smask_buffer) + "B",
                                         "FB0_Buffer: " + str(fb0_size // KB_SIZE) + "KB",
                                         "BT_Buffer: " + str(bt_size // KB_SIZE) + "KB"]
        # save the reg info into the map
        self.ai_core_reg[key_name] = ["Vector_Reg: " + str(vreg_size) + "B",
                                      "Predicate_Reg: " + str(preg_size) + "B",
                                      "Address_Reg: " + str(areg_size) + "B",
                                      "Alignment_Reg: " + str(ureg_size) + "B",
                                      "Wide_Reg: " + str(wreg_size) + "B"]


def _get_product_name():
    """
    return a tuple, include version and product name

    Returns
    -------
    return:a tuple represents current product, like v100, mini
    """
    # product version to product name
    ai_core_version_map_to_product = {
        ASCEND_310AIC: "mini",
        ASCEND_910AIC: "cloud",
        AIC_310P: "aic",
        HI3796CV300ESAIC: "hisi-es",
        VEC_610: "vec",
        VEC_BS9SX1A: "aiv"
    }
    product_name = get_soc_name() + get_soc_core_type()
    if product_name in ai_core_version_map_to_product:
        return ai_core_version_map_to_product.get(product_name)
    return TikCheckUtil.raise_error(
        "Not valid product version for tik:" + product_name)


def set_product_version(version):
    """
    set version info

    Parameters
    ----------
    version: str
    -        product name
    -        format: <major>.<middle>.<minor>.<point>
    -        major: 1xx or 2xx or 3xx
    """
    # need TikSourceInfo() init function to set source_info None first
    TikSourceInfo().register_source_info()
    set_current_compile_soc_info(version)
    SET_PRODUCT_FLAG["is_set_product_version"] = True
    TikSourceInfo.clear_source_info()


def unset_product_version():
    """
    unset SET_PRODUCT_FLAG to false
    """
    # need TikSourceInfo() init function to set source_info None first
    TikSourceInfo().register_source_info()
    SET_PRODUCT_FLAG["is_set_product_version"] = False
    TikSourceInfo.clear_source_info()


def _get_ub_size():
    return get_soc_spec("UB_SIZE")


def _get_l0a_size():
    return get_soc_spec("L0A_SIZE")


def _get_l0b_size():
    return get_soc_spec("L0B_SIZE")


def _get_l0c_size():
    return get_soc_spec("L0C_SIZE")


def _get_l1_size():
    return get_soc_spec("L1_SIZE")


def _get_vreg_size():
    return get_soc_spec("VECTOR_REG_WIDTH")


def _get_preg_size():
    return get_soc_spec("PRIDCATE_REG_WIDTH")


def _get_wreg_size():
    return get_soc_spec("WIDE_REG_WIDTH")


def _get_fb0_size():
    """
    get fb0 size of fixpipe
    :return:
    the size of fb0
    """
    return get_soc_spec("FB0_SIZE")


def _get_bt_size():
    """
    get bt buffer size of fixpipe
    :return:
    the size of bt buffer
    """
    return get_soc_spec("BT_SIZE")


def _gen_version(arch, version):
    """
    gen version
    Parameters
    ----------
    arch
    version

    Returns
    -------
    string ddk version
    """
    ascend_310p1 = ASCEND_310P + '1'
    ascend_310b1 = ASCEND_310B + '1'
    bs9sxaa = BS9SX1A + 'A'
    arch_type_dict = {
        "v100": {
            "mini": (ASCEND_310, "AiCore"),
            "cloud": (ASCEND_910, "AiCore")
        },
        "v200": {
            "aic": (ascend_310p1, "AiCore"),
            "hisi-es": (HI3796CV300ES, "AiCore"),
            "hisi-cs": (HI3796CV300CS, "AiCore"),
            "hisi-sd3403": (SD3403, "AiCore"),
            "sd3403": (SD3403, "AiCore"),
            "vec": (ASCEND_610, "VectorCore")
        },
        "v210": {
            "aiv": (bs9sxaa, "VectorCore"),
            "aic": (bs9sxaa, "AiCore")
        },
        "v300": {
            "aiv": (ascend_310b1, "VectorCore")
        }
    }

    chip_info = None

    try:
        chip_info = arch_type_dict[arch][version]
    except KeyError:
        TikCheckUtil.raise_error("Error chip!")
    return chip_info


def set_context_global_variable_link():
    """
    set context config: global_variable_link
    :return: None
    """
    context = get_context()
    if context is None:
        context = OpContext()
        context.__enter__()
    get_context().add_compile_info("global_variable_link", True)
