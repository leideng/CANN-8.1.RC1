#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_load_image_operation_inner_.py
DESC:     tik_load_image_operation_inner_
CREATED:  2021-11-17 7:09 AM
MODIFIED: 2021-11-17 7:09 AM
"""
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.common_util import check_dict_and_not_none
from tbe.tik.common.common_util import float16format2uint16
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import SCALE_COF
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AIPP_ENABLE
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AIPP_DISABLE
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AIPP_FORMAT_CONVERT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AIPP_INIT_FLOAT_VALUE_ZERO
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AIPP_INIT_FLOAT_VALUE_ONE
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AIPP_INIT_VALUE
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_format_convert
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import check_list_type_and_range
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_csc_info
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_dtc_mean
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_swap
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_raw_info
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_crop_info
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import check_param_info_type
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_pre_clip
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_scf
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_post_clip
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_dtc_raw_info
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_cpad
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import aipp_check_area_pad


def _cal_dtc_mean_by_type(dtc_mean):
    """
    calculate dtc mean
    """
    if Expr(dtc_mean).eval_value() is None:
        if dtc_mean.dtype == 'float16':
            dtc_mean_uint32 = dtc_mean.reinterpret_cast_to('uint16')
        else:
            dtc_mean_uint32 = dtc_mean
    else:
        if isinstance(dtc_mean, float):
            dtc_mean_uint32 = float16format2uint16(dtc_mean)
        else:
            dtc_mean_uint32 = dtc_mean

    return dtc_mean_uint32


def _cal_param_by_type(param):
    imm_param = Expr(param).eval_value()
    if imm_param is None:
        param_value_uint32 = param.reinterpret_cast_to('uint16')
    else:
        param_value_uint32 = float16format2uint16(imm_param)

    return param_value_uint32


def _aipp_get_channel_pad_value(dst_type, channel_pad_value_list):
    """
    get channel pad value
    """
    if dst_type == 'float16':
        channel0_pad_value_uint32 = _cal_param_by_type(channel_pad_value_list[0])
        channel1_pad_value_uint32 = _cal_param_by_type(channel_pad_value_list[1])
        channel2_pad_value_uint32 = _cal_param_by_type(channel_pad_value_list[2])
        channel3_pad_value_uint32 = _cal_param_by_type(channel_pad_value_list[3])
    else:
        channel0_pad_value_uint32 = channel_pad_value_list[0]
        channel1_pad_value_uint32 = channel_pad_value_list[1]
        channel2_pad_value_uint32 = channel_pad_value_list[2]
        channel3_pad_value_uint32 = channel_pad_value_list[3]

    return [channel0_pad_value_uint32, channel1_pad_value_uint32, channel2_pad_value_uint32, channel3_pad_value_uint32]


def _handle_crop_info(crop_info, params_val):
    # crop info
    if params_val.get('crop_enbale') == AIPP_DISABLE:
        crop_horizontal_size = params_val.get('src_horizontal_size')
        crop_vertical_size = params_val.get('src_vertical_size')
        crop_horizontal_start = AIPP_INIT_VALUE
        crop_vertical_start = AIPP_INIT_VALUE
        single_line_mode = AIPP_INIT_VALUE
    else:
        check_dict_and_not_none(crop_info, 'crop_info')
        crop_horizontal_size = crop_info.get('dst_horizontal_size')
        crop_vertical_size = crop_info.get('dst_vertical_size')
        crop_horizontal_start = crop_info.get('crop_horizontal_start')
        crop_vertical_start = crop_info.get('crop_vertical_start')
        single_line_mode = crop_info.get('single_line_enable')

    return [crop_horizontal_size, crop_vertical_size,
            crop_horizontal_start, crop_vertical_start, single_line_mode]


def _handle_crop_info_with_scalar(tik_instance, crop_info, params_val):
    """
    handle the crop_info with crop_enable is Scalar type.
    """
    with tik_instance.context.freeze():
        src_horizontal_size = params_val.get('src_horizontal_size')
        src_vertical_size = params_val.get('src_vertical_size')
        crop_horizontal_size = tik_instance.Scalar("uint16", "crop_horizontal_size", init_value=src_horizontal_size)
        crop_vertical_size = tik_instance.Scalar("uint16", "crop_vertical_size", init_value=src_vertical_size)
        crop_horizontal_start = tik_instance.Scalar("uint16", "crop_horizontal_start", init_value=AIPP_INIT_VALUE)
        crop_vertical_start = tik_instance.Scalar("uint16", "crop_vertical_start", init_value=AIPP_INIT_VALUE)
        single_line_mode = tik_instance.Scalar("uint16", "single_line_mode", init_value=AIPP_INIT_VALUE)

        if crop_info is None or not isinstance(crop_info, dict):
            return [crop_horizontal_size, crop_vertical_size, crop_horizontal_start,
                    crop_vertical_start, single_line_mode]
        with tik_instance.if_scope(params_val.get('crop_enable') != AIPP_DISABLE):
            crop_horizontal_size.set_as(crop_info.get('dst_horizontal_size', src_horizontal_size))
            crop_vertical_size.set_as(crop_info.get('dst_vertical_size', src_vertical_size))
            crop_horizontal_start.set_as(crop_info.get('crop_horizontal_start', AIPP_INIT_VALUE))
            crop_vertical_start.set_as(crop_info.get('crop_vertical_start', AIPP_INIT_VALUE))
            single_line_mode.set_as(crop_info.get('single_line_enable', AIPP_INIT_VALUE))

        return [crop_horizontal_size, crop_vertical_size, crop_horizontal_start,
                crop_vertical_start, single_line_mode]


def aipp_set_crop_info(tik_instance, input_format, crop_info, params_val):
    """
    set crop info to params_val
    """
    is_scalar = params_val.get('is_scalar')
    if is_scalar:
        crop_list = _handle_crop_info_with_scalar(tik_instance, crop_info, params_val)
    else:
        crop_list = _handle_crop_info(crop_info, params_val)

    params_val['crop_horizontal_size'] = crop_list[0]
    params_val['crop_vertical_size'] = crop_list[1]
    params_val['crop_horizontal_start'] = crop_list[2]
    params_val['crop_vertical_start'] = crop_list[3]
    params_val['single_line_mode'] = crop_list[4]

    if not is_scalar:
        aipp_check_crop_info(input_format, params_val)


def _handle_csc_info(csc_enable, csc_info):
    if csc_enable == AIPP_DISABLE:
        csc_matrix, csc_out_bias, csc_in_bias = [[AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE],
                                                 [AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE],
                                                 [AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE]], \
                                                [AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE], \
                                                [AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE]
    else:
        check_dict_and_not_none(csc_info, 'csc_info')
        format_convert = csc_info.get('format_convert')
        aipp_check_format_convert(format_convert)
        if format_convert == 0:
            csc_matrix = csc_info.get('csc_matrix')
            csc_out_bias = csc_info.get('csc_out_bias')
            csc_in_bias = csc_info.get('csc_in_bias')
            aipp_check_csc_info(csc_matrix, csc_out_bias, csc_in_bias)
        else:
            csc_para = AIPP_FORMAT_CONVERT.get(format_convert)
            csc_matrix = csc_para.get('csc_matrix')
            csc_out_bias = csc_para.get('csc_out_bias')
            csc_in_bias = csc_para.get('csc_in_bias')

    return [csc_matrix, csc_out_bias, csc_in_bias]


def _get_csc_info_value(tik_instance, csc_enable, format_convert, csc_info, csc_list):
    csc_matrix, csc_out_bias, csc_in_bias = csc_list
    with tik_instance.if_scope(csc_enable != AIPP_DISABLE):
        if format_convert == 0:
            csc_matrix_val = csc_info.get('csc_matrix', None)
            csc_out_bias_val = csc_info.get('csc_out_bias', None)
            csc_in_bias_val = csc_info.get('csc_in_bias', None)
            aipp_check_csc_info(csc_matrix_val, csc_out_bias_val, csc_in_bias_val)
        else:
            csc_para = AIPP_FORMAT_CONVERT.get(format_convert, None)
            if csc_para is None:
                return csc_matrix, csc_out_bias, csc_in_bias
            csc_matrix_val = csc_para.get('csc_matrix', None)
            csc_out_bias_val = csc_para.get('csc_out_bias', None)
            csc_in_bias_val = csc_para.get('csc_in_bias', None)
        if csc_matrix_val is not None:
            csc_matrix_val_tmp = []
            for j in csc_matrix_val:
                csc_matrix_val_tmp.extend(j)
            csc_matrix.set_as(csc_matrix_val_tmp)
        if csc_out_bias_val is not None:
            csc_out_bias.set_as(csc_out_bias_val)
        if csc_in_bias_val is not None:
            csc_in_bias.set_as(csc_in_bias_val)

    return csc_matrix, csc_out_bias, csc_in_bias


def _handle_csc_info_with_scalar(tik_instance, csc_enable, csc_info):
    """
    handle csc_info with csc_enable is Scalar type
    """
    with tik_instance.context.freeze():
        csc_matrix = tik_instance.ScalarArray(dtype="int16", length=9)
        csc_out_bias = tik_instance.ScalarArray(dtype="uint8", length=3)
        csc_in_bias = tik_instance.ScalarArray(dtype="uint8", length=3)

        csc_matrix.set_as([AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE,
                           AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE,
                           AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE])
        csc_out_bias.set_as([AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE])
        csc_in_bias.set_as([AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE])
        if csc_info is None or not isinstance(csc_info, dict):
            return csc_matrix, csc_out_bias, csc_in_bias

        format_convert = csc_info.get('format_convert', None)
        if format_convert is None:
            return csc_matrix, csc_out_bias, csc_in_bias
        else:
            aipp_check_format_convert(format_convert, is_scalar=True)

        csc_matrix, csc_out_bias, csc_in_bias = _get_csc_info_value(
            tik_instance, csc_enable, format_convert, csc_info, (csc_matrix, csc_out_bias, csc_in_bias))

        return csc_matrix, csc_out_bias, csc_in_bias


def aipp_set_csc_info(tik_instance, csc_info, params_val):
    """
    set crop info to params_val
    """
    csc_enable = params_val.get('csc_enable')
    is_scalar = params_val.get('is_scalar')
    if is_scalar:
        csc_list = _handle_csc_info_with_scalar(tik_instance, csc_enable, csc_info)
    else:
        csc_list = _handle_csc_info(csc_enable, csc_info)

    params_val['csc_matrix'] = csc_list[0]
    params_val['csc_out_bias'] = csc_list[1]
    params_val['csc_in_bias'] = csc_list[2]


def _handle_swap_info(input_format, swap_enable, swap_list):
    if swap_enable == AIPP_DISABLE:
        rb_swap, uv_swap, ax_swap = AIPP_INIT_VALUE,  AIPP_INIT_VALUE, AIPP_INIT_VALUE
    else:
        check_list_type_and_range(swap_list, 3, (int, Scalar, Expr), (0, 2), 'swap')
        rb_swap = swap_list[0]
        uv_swap = swap_list[1]
        ax_swap = swap_list[2]

        aipp_check_swap(input_format, rb_swap, uv_swap, ax_swap)

    return rb_swap, uv_swap, ax_swap


def _handle_swap_info_with_scalar(tik_instance, swap_enable, swap_list):
    """
    handle swap_info with swap_enable is Scalar type
    """
    with tik_instance.context.freeze():
        rb_swap = tik_instance.Scalar(dtype="uint8", name="rb_swap", init_value=AIPP_INIT_VALUE)
        uv_swap = tik_instance.Scalar(dtype="uint8", name="uv_swap", init_value=AIPP_INIT_VALUE)
        ax_swap = tik_instance.Scalar(dtype="uint8", name="ax_swap", init_value=AIPP_INIT_VALUE)
        if swap_list is None or not isinstance(swap_list, list) or len(swap_list) != 3:
            return rb_swap, uv_swap, ax_swap
        with tik_instance.if_scope(swap_enable != AIPP_DISABLE):
            rb_swap.set_as(swap_list[0])
            uv_swap.set_as(swap_list[1])
            ax_swap.set_as(swap_list[2])
        return rb_swap, uv_swap, ax_swap


def aipp_set_swap_info(tik_instance, input_format, swap_info, params_val):
    """
    set swap info to params_val
    """
    swap_enable = params_val.get('swap_enable')
    is_scalar = params_val.get('is_scalar')
    if is_scalar:
        swap_list = _handle_swap_info_with_scalar(tik_instance, swap_enable, swap_info)
    else:
        swap_list = _handle_swap_info(input_format, swap_enable, swap_info)

    params_val['rb_swap'] = swap_list[0]
    params_val['uv_swap'] = swap_list[1]
    params_val['ax_swap'] = swap_list[2]


def _handle_pre_clip_info(pre_clip_enable, pre_clip_info,
                          crop_vertical_size):
    if pre_clip_enable == AIPP_DISABLE:
        pre_top_clip_number = AIPP_INIT_VALUE
        pre_botton_clip_number = AIPP_INIT_VALUE
    else:
        check_dict_and_not_none(pre_clip_info, 'pre_clip_info')
        pre_top_clip_number = pre_clip_info.get('pre_top_clip_number')
        pre_botton_clip_number = pre_clip_info.get('pre_botton_clip_number')
        aipp_check_pre_clip(pre_top_clip_number, pre_botton_clip_number, crop_vertical_size)
    return pre_top_clip_number, pre_botton_clip_number


def _handle_pre_clip_info_with_scalar(tik_instance, pre_clip_enable, pre_clip_info):
    """
    handle pre_info with pre_clip_enable is Scalar type
    """
    with tik_instance.context.freeze():
        pre_top_clip_number = tik_instance.Scalar(
            dtype="uint8", name="pre_top_clip_number", init_value=AIPP_INIT_VALUE)
        pre_botton_clip_number = tik_instance.Scalar(
            dtype="uint8", name="pre_botton_clip_number", init_value=AIPP_INIT_VALUE)
        if pre_clip_info is None or not isinstance(pre_clip_info, dict):
            return pre_top_clip_number, pre_botton_clip_number

        with tik_instance.if_scope(pre_clip_enable != AIPP_DISABLE):
            pre_top_clip_number_val = pre_clip_info.get('pre_top_clip_number', AIPP_INIT_VALUE)
            pre_botton_clip_number_val = pre_clip_info.get('pre_botton_clip_number', AIPP_INIT_VALUE)
            pre_top_clip_number.set_as(pre_top_clip_number_val)
            pre_botton_clip_number.set_as(pre_botton_clip_number_val)
        return pre_top_clip_number, pre_botton_clip_number


def aipp_set_pre_clip_info(tik_instance, pre_clip_info, params_val):
    """
    set swap info to params_val
    """
    pre_clip_enable = params_val.get('pre_clip_enable')
    crop_vertical_size = params_val.get('crop_vertical_size')
    is_scalar = params_val.get('is_scalar')
    if is_scalar:
        pre_clip_list = _handle_pre_clip_info_with_scalar(tik_instance, pre_clip_enable, pre_clip_info)
    else:
        pre_clip_list = _handle_pre_clip_info(pre_clip_enable, pre_clip_info, crop_vertical_size)

    params_val['pre_top_clip_number'] = pre_clip_list[0]
    params_val['pre_botton_clip_number'] = pre_clip_list[1]


def _get_order_hori_vert_filter(tik_instance, scf_horizontal_size, scf_horizontal_size_def):
    imm_scf_horizontal_size = Expr(scf_horizontal_size).eval_value()
    imm_pre_scf_horizontal_size = Expr(scf_horizontal_size_def).eval_value()
    if imm_scf_horizontal_size is not None and imm_pre_scf_horizontal_size is not None:
        if imm_scf_horizontal_size > imm_pre_scf_horizontal_size:
            order_hori_vert_filter = AIPP_ENABLE
        else:
            order_hori_vert_filter = AIPP_DISABLE
    else:
        with tik_instance.context.freeze():
            order_hori_vert_filter = tik_instance.scalar_(
                'uint16', 'order_hori_vert_filter', AIPP_ENABLE)
            with tik_instance.if_scope(scf_horizontal_size < scf_horizontal_size_def):
                order_hori_vert_filter.set_as(AIPP_DISABLE)

    return order_hori_vert_filter


def _handle_scf_info(tik_instance, scf_enable, scf_info, scf_horizontal_size_def, scf_vertical_size_def):
    if scf_enable == AIPP_DISABLE:
        scf_list = [scf_horizontal_size_def, scf_vertical_size_def, AIPP_INIT_VALUE, AIPP_INIT_VALUE,
                    AIPP_INIT_VALUE,  AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE,
                    AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE]
    else:
        check_dict_and_not_none(scf_info, 'scf_info')
        # scf_info
        scf_horizontal_size = scf_info.get('scf_horizontal_size')
        scf_vertical_size = scf_info.get('scf_vertical_size')
        scf_horizontal_start = scf_info.get('scf_horizontal_start')
        scf_vertical_start = scf_info.get('scf_vertical_start')
        scaling_mode = scf_info.get('scaling_mode')

        aipp_check_scf(scf_horizontal_size, scf_vertical_size, scf_horizontal_start, scf_vertical_start, scaling_mode)
        scf_list = [scf_horizontal_size, scf_vertical_size]

        # spr13
        # append alpha_hori_scaling_mode, hori_scaling_mode, alpha_vert_scaling_mode, vert_scaling_mode to scf_list
        scf_list.extend([scaling_mode, scaling_mode, scaling_mode, scaling_mode])

        order_hori_vert_filter = _get_order_hori_vert_filter(tik_instance, scf_horizontal_size, scf_horizontal_size_def)
        # append order_hori_vert_filter, vertical_scaling_enable, hori_scaling_enable to scf_list
        scf_list.extend([order_hori_vert_filter, AIPP_ENABLE, AIPP_ENABLE])

        # SPR16
        hori_scaling = scf_info.get(
            'scf_horizontal_scale', (scf_horizontal_size_def - 1) * SCALE_COF // (scf_horizontal_size - 1) // 4 * 4)
        check_param_info_type({'scf_horizontal_scale': hori_scaling})
        vert_scaling = scf_info.get(
            'scf_vertical_scale', (scf_vertical_size_def - 1) * SCALE_COF // (scf_vertical_size - 1) // 4 * 4)
        check_param_info_type({'scf_vertical_scale': vert_scaling})

        # append vert_scaling, hori_scaling, init_vert_phase, init_hori_phase to scf_list
        scf_list.extend([vert_scaling, hori_scaling, scf_vertical_start, scf_horizontal_start])

    return scf_list


def _get_scf_info_value(scf_info):
    name_list = ['scf_horizontal_size', 'scf_vertical_size',
                 'scf_horizontal_start', 'scf_vertical_start', 'scaling_mode']
    return [scf_info.get(name, None) for name in name_list]


def _get_scf_info_value_with_scalar(tik_instance):
    name_list = ["alpha_hori_scaling_mode", "hori_scaling_mode", "alpha_vert_scaling_mode", "vert_scaling_mode",
                 "order_hori_vert_filter", "vertical_scaling_enable", "hori_scaling_enable", "vert_scaling",
                 "hori_scaling", "init_vert_phase", "init_hori_phase"]
    return [tik_instance.Scalar('int32', name, AIPP_INIT_VALUE) for name in name_list]


def _handle_scf_info_with_scalar(tik_instance, scf_enable, scf_info, scf_horizontal_size_def, scf_vertical_size_def):
    """
    handle scf_info with scf_enable is Scalar type
    """
    with tik_instance.context.freeze():
        scf_horizontal_size = tik_instance.Scalar(
            dtype="int32", name="scf_horizontal_size", init_value=scf_horizontal_size_def)
        scf_vertical_size = tik_instance.Scalar(
            dtype="int32", name="scf_vertical_size", init_value=scf_vertical_size_def)
        scf_list = _get_scf_info_value_with_scalar(tik_instance)
        scf_list.insert(0, scf_horizontal_size)
        scf_list.insert(1, scf_vertical_size)
        if scf_info is None or not isinstance(scf_info, dict):
            return scf_list

        # scf_info
        scf_list_val = _get_scf_info_value(scf_info)
        if any(val is None for val in scf_list_val):
            return scf_list
        if isinstance(scf_list_val[0], (Scalar, Expr)):
            check_scalar_dtype(scf_list_val[0], "scf_horizontal_size should be a scalar of int/uint")
        with tik_instance.if_scope(scf_enable != AIPP_DISABLE):
            scf_list[0].set_as(scf_list_val[0])
            scf_list[1].set_as(scf_list_val[1])
            # SPR12
            pre_scf_horizontal_size = tik_instance.Scalar(dtype="int32", name="pre_scf_horizontal_size")
            pre_scf_vertical_size = tik_instance.Scalar(dtype="int32", name="pre_scf_vertical_size")
            pre_scf_horizontal_size.set_as(scf_horizontal_size_def)
            pre_scf_vertical_size.set_as(scf_vertical_size_def)

            # spr13
            scf_list[2].set_as(scf_list_val[4])
            scf_list[3].set_as(scf_list_val[4])
            scf_list[4].set_as(scf_list_val[4])
            scf_list[5].set_as(scf_list_val[4])

            scf_list[7].set_as(AIPP_ENABLE)
            scf_list[8].set_as(AIPP_ENABLE)

            scf_list[6].set_as(AIPP_ENABLE)
            with tik_instance.if_scope(scf_list_val[0] < pre_scf_horizontal_size):
                scf_list[6].set_as(AIPP_DISABLE)

            # SPR16
            scf_list[10].set_as(
                scf_info.get('scf_horizontal_scale',
                             (pre_scf_horizontal_size - 1) * SCALE_COF // (scf_list_val[0] - 1) // 4 * 4))
            scf_list[9].set_as(
                scf_info.get('scf_vertical_scale',
                             (pre_scf_vertical_size - 1) * SCALE_COF // (scf_list_val[1] - 1) // 4 * 4))

            scf_list[11].set_as(scf_list_val[3])
            scf_list[12].set_as(scf_list_val[2])

        return scf_list


def aipp_set_scf_info(tik_instance, scf_info, params_val):
    """
    set scf info to params_val
    """
    scf_enable = params_val.get('scf_enable')
    crop_vertical_size = params_val.get('crop_vertical_size')
    crop_horizontal_size = params_val.get('crop_horizontal_size')
    pre_top_clip_number = params_val.get('pre_top_clip_number')
    pre_botton_clip_number = params_val.get('pre_botton_clip_number')
    is_scalar = params_val.get('is_scalar')
    scf_vertical_size_def = crop_vertical_size - pre_top_clip_number - pre_botton_clip_number
    if is_scalar:
        scf_list = _handle_scf_info_with_scalar(
            tik_instance, scf_enable, scf_info, crop_horizontal_size, scf_vertical_size_def)
    else:
        scf_list = _handle_scf_info(
            tik_instance, scf_enable, scf_info, crop_horizontal_size, scf_vertical_size_def)

    params_val['scf_horizontal_size'] = scf_list[0]
    params_val['scf_vertical_size'] = scf_list[1]
    params_val['alpha_hori_scaling_mode'] = scf_list[2]
    params_val['hori_scaling_mode'] = scf_list[3]
    params_val['alpha_vert_scaling_mode'] = scf_list[4]
    params_val['vert_scaling_mode'] = scf_list[5]
    params_val['order_hori_vert_filter'] = scf_list[6]
    params_val['vertical_scaling_enable'] = scf_list[7]
    params_val['hori_scaling_enable'] = scf_list[8]
    params_val['vert_scaling'] = scf_list[9]
    params_val['hori_scaling'] = scf_list[10]
    params_val['init_vert_phase'] = scf_list[11]
    params_val['init_hori_phase'] = scf_list[12]


def _handle_post_clip_info(post_clip_enable, post_clip_info):
    if post_clip_enable == AIPP_DISABLE:
        post_botton_clip_number = AIPP_INIT_VALUE
        post_top_clip_number = AIPP_INIT_VALUE
        post_right_clip_number = AIPP_INIT_VALUE
        post_left_clip_number = AIPP_INIT_VALUE
    else:
        check_dict_and_not_none(post_clip_info, 'post_clip_info')
        post_botton_clip_number = post_clip_info.get('post_botton_clip_number')
        post_top_clip_number = post_clip_info.get('post_top_clip_number')
        post_right_clip_number = post_clip_info.get('post_right_clip_number')
        post_left_clip_number = post_clip_info.get('post_left_clip_number')

        aipp_check_post_clip(post_botton_clip_number, post_top_clip_number,
                             post_right_clip_number, post_left_clip_number)
    return [post_botton_clip_number, post_top_clip_number, post_right_clip_number, post_left_clip_number]


def _handle_post_clip_info_with_scalar(tik_instance, post_clip_enable, post_clip_info):
    """
    handle post_clip_info with post_clip_enable is Scalar type
    """
    with tik_instance.context.freeze():
        post_botton_clip_number = tik_instance.Scalar(
            dtype="int32", name="post_botton_clip_number", init_value=AIPP_INIT_VALUE)
        post_top_clip_number = tik_instance.Scalar(
            dtype="int32", name="post_top_clip_number", init_value=AIPP_INIT_VALUE)
        post_right_clip_number = tik_instance.Scalar(
            dtype="int32", name="post_right_clip_number", init_value=AIPP_INIT_VALUE)
        post_left_clip_number = tik_instance.Scalar(
            dtype="int32", name="post_left_clip_number", init_value=AIPP_INIT_VALUE)
        if post_clip_info is None or not isinstance(post_clip_info, dict):
            return [post_botton_clip_number, post_top_clip_number, post_right_clip_number, post_left_clip_number]
        with tik_instance.if_scope(post_clip_enable != AIPP_DISABLE):
            post_botton_clip_number_val = post_clip_info.get('post_botton_clip_number', None)
            post_top_clip_number_val = post_clip_info.get('post_top_clip_number', None)
            post_right_clip_number_val = post_clip_info.get('post_right_clip_number', None)
            post_left_clip_number_val = post_clip_info.get('post_left_clip_number', None)
            if post_botton_clip_number_val is not None:
                post_botton_clip_number.set_as(post_botton_clip_number_val)
            if post_top_clip_number_val is not None:
                post_top_clip_number.set_as(post_top_clip_number_val)
            if post_right_clip_number_val is not None:
                post_right_clip_number.set_as(post_right_clip_number_val)
            if post_left_clip_number_val is not None:
                post_left_clip_number.set_as(post_left_clip_number_val)
        return [post_botton_clip_number, post_top_clip_number, post_right_clip_number, post_left_clip_number]


def aipp_set_post_clip_info(tik_instance, post_clip_info, params_val):
    """
    set post_clip info to params_val
    """
    post_clip_enable = params_val.get('post_clip_enable')
    is_scalar = params_val.get('is_scalar')
    if is_scalar:
        post_clip_list = _handle_post_clip_info_with_scalar(tik_instance, post_clip_enable, post_clip_info)
    else:
        post_clip_list = _handle_post_clip_info(post_clip_enable, post_clip_info)
    params_val['post_botton_clip_number'] = post_clip_list[0]
    params_val['post_top_clip_number'] = post_clip_list[1]
    params_val['post_right_clip_number'] = post_clip_list[2]
    params_val['post_left_clip_number'] = post_clip_list[3]


def _aipp_get_dtc_value(dtc_list=None, value=None, is_mean=False):
    """
    get dtc mean
    """
    if is_mean:
        func = _cal_dtc_mean_by_type
    else:
        func = _cal_param_by_type

    if dtc_list is None:
        value_list = [value, value, value, value]
    else:
        value_list = [func(dtc_list[i]) for i in range(4)]

    return value_list


def _handle_dtc_info(dtc_enable, dtc_info):
    if dtc_enable == AIPP_DISABLE:
        dtc_mean_type = AIPP_INIT_VALUE
        dtc_mean_uint32_list = _aipp_get_dtc_value(value=AIPP_INIT_VALUE)
        dtc_min_uint32_list = _aipp_get_dtc_value(value=float16format2uint16(AIPP_INIT_FLOAT_VALUE_ZERO))
        dtc_var_uint32_list = _aipp_get_dtc_value(value=float16format2uint16(AIPP_INIT_FLOAT_VALUE_ONE))
        raw_to_f16_n = AIPP_INIT_VALUE
    else:
        check_dict_and_not_none(dtc_info, 'dtc_info')
        dtc_mean_type = dtc_info.get('dtc_mean_type')
        dtc_mean = dtc_info.get('dtc_mean')
        aipp_check_dtc_mean(dtc_mean_type, dtc_mean)
        dtc_mean_uint32_list = _aipp_get_dtc_value(dtc_mean, is_mean=True)

        dtc_min = dtc_info.get('dtc_min')
        check_list_type_and_range(dtc_min, 4, (float, Scalar, Expr), None, 'dtc_min')

        dtc_min_uint32_list = _aipp_get_dtc_value(dtc_min)

        dtc_var = dtc_info.get('dtc_var')
        check_list_type_and_range(dtc_var, 4, (float, Scalar, Expr), None, 'dtc_var')

        dtc_var_uint32_list = _aipp_get_dtc_value(dtc_var)

        raw_to_f16_n = dtc_info.get('raw_to_f16_n')
        aipp_check_dtc_raw_info(raw_to_f16_n)

    return [dtc_mean_type, dtc_mean_uint32_list, dtc_min_uint32_list, dtc_var_uint32_list, raw_to_f16_n]


def _aipp_get_dtc_value_with_scalar(tik_instance, name, value):
    return [tik_instance.Scalar("uint16", "dtc_%s%s_uint32" % (name, i), value) for i in range(4)]


def _handle_dtc_info_with_scalar(tik_instance, dtc_enable, dtc_info):
    """
    handle dtc_info with dtc_enable is Scalar type
    """
    with tik_instance.context.freeze():
        dtc_mean_type = tik_instance.Scalar(dtype="int32", name="dtc_mean_type", init_value=AIPP_INIT_VALUE)
        dtc_mean_uint32_list = _aipp_get_dtc_value_with_scalar(tik_instance, 'mean', value=AIPP_INIT_VALUE)
        dtc_min_uint32_list = _aipp_get_dtc_value_with_scalar(
            tik_instance, 'min', value=float16format2uint16(AIPP_INIT_FLOAT_VALUE_ZERO))
        dtc_var_uint32_list = _aipp_get_dtc_value_with_scalar(
            tik_instance, 'var', value=float16format2uint16(AIPP_INIT_FLOAT_VALUE_ONE))

        raw_to_f16_n = tik_instance.Scalar(dtype="int32", name="raw_to_f16_n", init_value=AIPP_INIT_VALUE)
        if dtc_info is None or not isinstance(dtc_info, dict):
            return [dtc_mean_type, dtc_mean_uint32_list, dtc_min_uint32_list, dtc_var_uint32_list, raw_to_f16_n]

        dtc_mean_type_val = dtc_info.get('dtc_mean_type', None)
        dtc_mean_val = dtc_info.get('dtc_mean', None)
        dtc_min_val = dtc_info.get('dtc_min', None)
        dtc_var_val = dtc_info.get('dtc_var', None)
        raw_to_f16_n_val = dtc_info.get('raw_to_f16_n', None)
        if any(v is None for v in (dtc_mean_type_val, dtc_mean_val, dtc_min_val, dtc_var_val, raw_to_f16_n_val)):
            return [dtc_mean_type, dtc_mean_uint32_list, dtc_min_uint32_list, dtc_var_uint32_list, raw_to_f16_n]

        with tik_instance.if_scope(dtc_enable != AIPP_DISABLE):
            dtc_mean_type.set_as(dtc_mean_type_val)

            dtc_uint32_list_val = _aipp_get_dtc_value(dtc_mean_val, is_mean=True)
            dtc_mean_uint32_list[0].set_as(dtc_uint32_list_val[0])
            dtc_mean_uint32_list[1].set_as(dtc_uint32_list_val[1])
            dtc_mean_uint32_list[2].set_as(dtc_uint32_list_val[2])
            dtc_mean_uint32_list[3].set_as(dtc_uint32_list_val[3])

            dtc_uint32_list_val = _aipp_get_dtc_value(dtc_min_val)
            dtc_min_uint32_list[0].set_as(dtc_uint32_list_val[0])
            dtc_min_uint32_list[1].set_as(dtc_uint32_list_val[1])
            dtc_min_uint32_list[2].set_as(dtc_uint32_list_val[2])
            dtc_min_uint32_list[3].set_as(dtc_uint32_list_val[3])

            dtc_uint32_list_val = _aipp_get_dtc_value(dtc_var_val)
            dtc_var_uint32_list[0].set_as(dtc_uint32_list_val[0])
            dtc_var_uint32_list[1].set_as(dtc_uint32_list_val[1])
            dtc_var_uint32_list[2].set_as(dtc_uint32_list_val[2])
            dtc_var_uint32_list[3].set_as(dtc_uint32_list_val[3])

            raw_to_f16_n.set_as(raw_to_f16_n_val)

        return [dtc_mean_type, dtc_mean_uint32_list, dtc_min_uint32_list, dtc_var_uint32_list, raw_to_f16_n]


def aipp_set_dtc_info(tik_instance, dtc_info, params_val):
    """
    set dtc info to params_val
    """
    dtc_enable = params_val.get('dtc_enable')
    is_scalar = params_val.get('is_scalar')
    if is_scalar:
        dtc_list = _handle_dtc_info_with_scalar(tik_instance, dtc_enable, dtc_info)
    else:
        dtc_list = _handle_dtc_info(dtc_enable, dtc_info)

    params_val['dtc_mean_type'] = dtc_list[0]
    params_val['dtc_mean0_uint32'] = dtc_list[1][0]
    params_val['dtc_mean1_uint32'] = dtc_list[1][1]
    params_val['dtc_mean2_uint32'] = dtc_list[1][2]
    params_val['dtc_mean3_uint32'] = dtc_list[1][3]
    params_val['dtc_min0_uint32'] = dtc_list[2][0]
    params_val['dtc_min1_uint32'] = dtc_list[2][1]
    params_val['dtc_min2_uint32'] = dtc_list[2][2]
    params_val['dtc_min3_uint32'] = dtc_list[2][3]
    params_val['dtc_var0_uint32'] = dtc_list[3][0]
    params_val['dtc_var1_uint32'] = dtc_list[3][1]
    params_val['dtc_var2_uint32'] = dtc_list[3][2]
    params_val['dtc_var3_uint32'] = dtc_list[3][3]
    params_val['raw_to_f16_n'] = dtc_list[4]


def _handle_channel_pad_info(channel_pad_enable, channel_pad_info, dst_type):
    if channel_pad_enable == AIPP_DISABLE:
        channel_pad_mode = 0
        channel_pad_value_uint32 = 0
    else:
        check_dict_and_not_none(channel_pad_info, 'channel_pad_info')
        channel_pad_mode = channel_pad_info.get('channel_pad_mode')
        channel_pad_value = channel_pad_info.get('channel_pad_value')
        aipp_check_cpad(dst_type, channel_pad_value, channel_pad_mode)

        if dst_type == 'float16':
            if Expr(channel_pad_value).eval_value() is None:
                channel_pad_value_uint32 = channel_pad_value.reinterpret_cast_to('uint16')
            else:
                channel_pad_value_uint32 = float16format2uint16(channel_pad_value)
        else:
            channel_pad_value_uint32 = channel_pad_value

    return channel_pad_mode, channel_pad_value_uint32


def _handle_channel_pad_info_with_scalar(tik_instance, channel_pad_enable, channel_pad_info, dst_type):
    """
    handle channel_pad_info with channel_pad_enable is Scalar type
    """
    with tik_instance.context.freeze():
        channel_pad_mode = tik_instance.Scalar(dtype="int32", name="channel_pad_mode", init_value=0)
        channel_pad_value_uint32 = tik_instance.Scalar(dtype="uint16", name="channel_pad_value_uint32", init_value=0)

        if channel_pad_info is None or not isinstance(channel_pad_info, dict):
            return channel_pad_mode, channel_pad_value_uint32

        channel_pad_mode_val = channel_pad_info.get('channel_pad_mode', None)
        channel_pad_value_val = channel_pad_info.get('channel_pad_value', None)
        if any(val is None for val in [channel_pad_mode_val, channel_pad_value_val]):
            return channel_pad_mode, channel_pad_value_uint32

        with tik_instance.if_scope(channel_pad_enable != AIPP_DISABLE):
            channel_pad_mode.set_as(channel_pad_mode_val)
            if dst_type != 'float16':
                channel_pad_value_uint32.set_as(channel_pad_value_val)
            elif Expr(channel_pad_value_val).eval_value() is None:
                channel_pad_value_uint32.set_as(channel_pad_value_val.reinterpret_cast_to('uint16'))
            else:
                channel_pad_value_uint32.set_as(float16format2uint16(channel_pad_value_val))

        return channel_pad_mode, channel_pad_value_uint32


def aipp_set_channel_pad_info(tik_instance, channel_pad_info, dst_type, params_val):
    """
    set channel_pad info to params_val
    """
    channel_pad_enable = params_val.get('channel_pad_enable')
    is_scalar = params_val.get('is_scalar')
    if is_scalar:
        channel_pad_list = _handle_channel_pad_info_with_scalar(
            tik_instance, channel_pad_enable, channel_pad_info, dst_type)
    else:
        channel_pad_list = _handle_channel_pad_info(
            channel_pad_enable, channel_pad_info, dst_type)

    params_val['channel_pad_mode'] = channel_pad_list[0]
    params_val['channel_pad_value_uint32'] = channel_pad_list[1]


def _handle_area_pad_info(input_format, area_pad_enable, area_pad_info, dst_type):
    if area_pad_enable == AIPP_DISABLE:
        area_pad_list = [AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE,
                         AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE, AIPP_INIT_VALUE]
    else:

        check_dict_and_not_none(area_pad_info, 'area_pad_info')
        # area pad value
        area_pad_list = [
            area_pad_info.get('area_pad_mode'),
            area_pad_info.get('top_pad_rows'),
            area_pad_info.get('botton_pad_rows'),
            area_pad_info.get('left_pad_cols'),
            area_pad_info.get('right_pad_cols')
        ]

        # channel pad value
        channel0_pad_value = area_pad_info.get('channel0_pad_value')
        channel1_pad_value = area_pad_info.get('channel1_pad_value')
        channel2_pad_value = area_pad_info.get('channel2_pad_value')
        channel3_pad_value = area_pad_info.get('channel3_pad_value')

        aipp_check_area_pad(input_format, dst_type, area_pad_list,
                            [channel0_pad_value, channel1_pad_value, channel2_pad_value, channel3_pad_value])

        channel_value_uint32 = _aipp_get_channel_pad_value(
                dst_type, [channel0_pad_value, channel1_pad_value, channel2_pad_value, channel3_pad_value])
        area_pad_list.extend(channel_value_uint32)

    return area_pad_list


def _get_area_pad_list(area_pad_info, name_list):
    return [area_pad_info.get(name, None) for name in name_list]


def _get_area_pad_list_with_scalar(tik_instance, name_list):
    return [tik_instance.Scalar("uint16", name, AIPP_INIT_VALUE) for name in name_list]


def _handle_area_pad_info_with_scalar(tik_instance, area_pad_enable, area_pad_info, dst_type):
    """
    handle area_pad_info with area_pad_enable is Scalar type
    """
    name_list = ["area_pad_mode", "top_pad_rows", "botton_pad_rows", "left_pad_cols", "right_pad_cols",
                 "channel0_pad_value", "channel1_pad_value",
                 "channel2_pad_value", "channel3_pad_value"]
    with tik_instance.context.freeze():
        area_pad_list = _get_area_pad_list_with_scalar(tik_instance, name_list)
        if area_pad_info is None or not isinstance(area_pad_info, dict):
            return area_pad_list

        # area pad value
        area_pad_list_val = _get_area_pad_list(area_pad_info, name_list)

        if any(v is None for v in area_pad_list_val):
            return area_pad_list

        channel_pad_value = _aipp_get_channel_pad_value(dst_type, area_pad_list_val[5:])
        with tik_instance.if_scope(area_pad_enable != AIPP_DISABLE):
            area_pad_list[0].set_as(area_pad_list_val[0])
            area_pad_list[1].set_as(area_pad_list_val[1])
            area_pad_list[2].set_as(area_pad_list_val[2])
            area_pad_list[3].set_as(area_pad_list_val[3])
            area_pad_list[4].set_as(area_pad_list_val[4])
            area_pad_list[5].set_as(channel_pad_value[0])
            area_pad_list[6].set_as(channel_pad_value[1])
            area_pad_list[7].set_as(channel_pad_value[2])
            area_pad_list[8].set_as(channel_pad_value[3])

        return area_pad_list


def aipp_set_area_pad_info(tik_instance, input_format, area_pad_info, dst_type, params_val):
    """
    set area_pad info to params_val
    """
    area_pad_enable = params_val.get('area_pad_enable')
    is_scalar = params_val.get('is_scalar')
    if is_scalar:
        area_pad_list = _handle_area_pad_info_with_scalar(tik_instance, area_pad_enable, area_pad_info, dst_type)
    else:
        area_pad_list = _handle_area_pad_info(input_format, area_pad_enable, area_pad_info, dst_type)

    params_val['area_pad_mode'] = area_pad_list[0]
    params_val['top_pad_rows'] = area_pad_list[1]
    params_val['botton_pad_rows'] = area_pad_list[2]
    params_val['left_pad_cols'] = area_pad_list[3]
    params_val['right_pad_cols'] = area_pad_list[4]
    params_val['channel0_pad_value_uint32'] = area_pad_list[5]
    params_val['channel1_pad_value_uint32'] = area_pad_list[6]
    params_val['channel2_pad_value_uint32'] = area_pad_list[7]
    params_val['channel3_pad_value_uint32'] = area_pad_list[8]


def _handle_raw_info(raw_enable, raw_info):
    if raw_enable == AIPP_DISABLE:
        raw_image_channel = AIPP_INIT_VALUE
        raw_start_channel = AIPP_INIT_VALUE
    else:
        check_dict_and_not_none(raw_info, 'raw_info')
        raw_image_channel = raw_info.get('raw_image_channel')
        raw_start_channel = raw_info.get('raw_start_channel')
        aipp_check_raw_info(raw_image_channel, raw_start_channel)

    return raw_image_channel, raw_start_channel


def _handle_raw_info_with_scalar(tik_instance, raw_enable, raw_info):
    """
    handle raw_info with raw_enable is Scalar type
    """
    with tik_instance.context.freeze():
        raw_image_channel = tik_instance.Scalar(dtype="int32", name="raw_image_channel", init_value=AIPP_INIT_VALUE)
        raw_start_channel = tik_instance.Scalar(dtype="int32", name="raw_start_channel", init_value=AIPP_INIT_VALUE)

        if raw_info is None:
            return raw_image_channel, raw_start_channel
        raw_image_channel_val = raw_info.get('raw_image_channel', None)
        raw_start_channel_val = raw_info.get('raw_start_channel', None)
        if any(v is None for v in (raw_image_channel_val, raw_start_channel_val)):
            return raw_image_channel, raw_start_channel
        with tik_instance.if_scope(raw_enable != AIPP_DISABLE):
            raw_image_channel.set_as(raw_image_channel_val)
            raw_start_channel.set_as(raw_start_channel_val)
        return raw_image_channel, raw_start_channel


def aipp_set_raw_info(tik_instance, raw_info, params_val):
    """
    set raw info to params_val
    """
    raw_enable = params_val.get('raw_enable')
    is_scalar = params_val.get('is_scalar')
    if is_scalar:
        raw_list = _handle_raw_info_with_scalar(tik_instance, raw_enable, raw_info,)
    else:
        raw_list = _handle_raw_info(raw_enable, raw_info)

    params_val['raw_image_channel'] = raw_list[0]
    params_val['raw_start_channel'] = raw_list[1]
