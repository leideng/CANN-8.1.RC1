#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_scalar.py
DESC:     scalar
CREATED:  2019-04-18 18:53:42
MODIFIED: 2019-07-18 21:29:18
"""

from tbe import tvm
from tbe.common.platform import scope_reg


from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.tik_lib.tik_expr import BasicExpr
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_util import need_check_out_of_scope
from tbe.tik.tik_lib.tik_basic_data import BasicData
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_check_util import print_error_msg

_SCALAR_EXTENTS = (1,)


class ScalarInner(BasicExpr, BasicData):
    """
    hint:scalar expression
    """
    # @cond

    def __init__(self, ir_generator):
        """
        scalar register initialization
        Parameters
        ----------
        ir_generator:Halide IR generator

        Returns
        ----------
        return:no return
        """
        BasicExpr.__init__(self)
        BasicData.__init__(self, "Scalar")
        self.ir_generator = ir_generator
        self.reg_buffer = None
        self._available = True

    @source_info_decorator()
    def __eq__(self, other):
        if self.dtype == "bfloat16":
            print_error_msg("When the scalar type is bfloat16, comparison calculation are not supported")
        if isinstance(other, BasicExpr):
            if isinstance(other, ScalarInner):
                if isinstance(other.offset, int):
                    right = other.reg_buffer[other.offset]
                else:
                    right = other.reg_buffer[Expr(other.offset).get()]
            else:  # Expr type
                right = other.get()
        elif isinstance(other, tvm.ir.PrimExpr):
            right = other
        else:  # imm type
            right = tvm.const(other, self.dtype)
        self.float_operation_ban([self, right])
        tmp_node = tvm.tir.EQ(self.get(), right)
        return self.class_type(tmp_node)

    def __hash__(self):
        return hash((self.reg_buffer, self.offset))

    @property
    def name(self):
        """
        get scalar register name
        Parameters
        ----------

        Returns
        ----------
        return:scalar register name
        """
        msg = "Scalar %s is not defined in this scope." % self._name
        if need_check_out_of_scope(self.ir_generator):
            TikCheckUtil.check_equality(self._available, True, msg)
        return self._name

    @property
    def if_global_scope(self):
        """
        judging whether is global scope
        Parameters
        ----------

        Returns
        ----------
        return:judging whether is global scope
        """
        msg = "Scalar %s is not defined in this scope." % self._name
        if need_check_out_of_scope(self.ir_generator):
            TikCheckUtil.check_equality(self._available, True, msg)
        return self._if_global_scope

    @staticmethod
    def eval_value():
        """
        return expression value
        Parameters
        ----------

        Returns
        ----------
        return:no return
        """

    def get(self):
        """
        get buffer
        Parameters
        ----------

        Returns
        ----------
        return:return top register buffer
        """
        msg = "Scalar %s is not defined in this scope." % self._name
        if need_check_out_of_scope(self.ir_generator):
            TikCheckUtil.check_equality(self._available, True, msg)
        if isinstance(self.offset, int):
            return self.reg_buffer[self.offset]
        return self.reg_buffer[Expr(self.offset).get()]

    def merge_scalar(self, body):
        """
        merge scalar
        Parameters
        ----------
        body: body

        Returns
        -------
        body
        """
        msg = "Scalar %s is not defined in this scope." % self._name
        if need_check_out_of_scope(self.ir_generator):
            TikCheckUtil.check_equality(self._available, True, msg)
        if self.instance_func is not None:
            return self.instance_func(body)
        return body

    def disable_scalar(self):
        """
        when this scalar lifecycle is in the end,
        this scalar condition parameter should be changed from true to false.
        Parameters
        ----------
        parameter:No parameter

        Returns
        ----------
        return:no return
        """
        self._available = False

    def as_tensor_ptr(self, ptr_dtype, tensor):
        """
        Sets the scalar value.
        """
        tensor_offset = Expr(tensor.addr_offset*DTYPE_SIZE[ptr_dtype]).get()
        TikCheckUtil.check_not_contains("float", tensor_offset.dtype,
                                        "The tensor_addr offset cannot be float,"
                                        " but get %s." % tensor_offset.dtype)
        msg = "Scalar %s is not defined in this scope." % self._name
        if need_check_out_of_scope(self.ir_generator):
            TikCheckUtil.check_equality(self._available, True, msg)
        return tvm.call_extern(ptr_dtype, "scalar_to_address", ptr_dtype, self.get(), tensor_offset)

    def _set_reg_buffer(self, init_value, dtype):
        """
        Sets the reg_buffer for Scalar.
        Parameters
        ----------
        init_value: Value to be assigned from:
        -     An immediate of type int or float
        -     A Scalar variable
        -     A Tensor value
        -     An Expr (consisting of a Scalar variable and an immediate)
        dtype: Scalar dtype

        Returns
        -------
        no return
        """
        with self.ir_generator.context.freeze():
            self.reg_buffer = self.ir_generator.allocate(
                (dtype, _SCALAR_EXTENTS, self._name), scope=scope_reg)
            if init_value is not None:
                self.set_as(init_value)

    def _check_param_for_set(self, value):
        """

        Parameters
        ----------
        value: Value to be assigned from:
        -     An immediate of type int or float
        -     A Scalar variable
        -     A Tensor value
        -     An Expr (consisting of a Scalar variable and an immediate)

        Returns
        -------
        no return
        """
        if isinstance(value, ScalarInner) and (TikSocManager.is_mini_soc()):
            if value.dtype == "float16" and self.dtype == "float32":
                TikCheckUtil.raise_error("Do not support set_as "
                                         "from Scalar(float16) to Scalar(float32).")
            if value.dtype == "float32" and self.dtype == "float16":
                TikCheckUtil.raise_error("Do not support set_as "
                                         "from Scalar(float32) to Scalar(float16).")
            if value.dtype.startswith(("int", "uint")) and self.dtype.startswith("float"):
                TikCheckUtil.raise_error("Do not support set_as "
                                         "from Scalar(int/uint) to Scalar(float).")
            if value.dtype.startswith("float") and self.dtype.startswith(("int", "uint")):
                TikCheckUtil.raise_error("Do not support set_as "
                                         "from Scalar(float) to Scalar(int/uint).")


class InputScalarInner(Expr):
    """
    only use to buildcce's input
    """

    def __init__(self, ir_generator):
        super(InputScalarInner, self).__init__(expr_="nouse")
        self.ir_generator = ir_generator

    @property
    def name(self):
        """
        get scalar name
        """
        return self._name

    def get(self):
        """
        get buffer
        """
        return self._var
# @endcond
