#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_new_api_inner_base.py
DESC:     Api Inner Base
CREATED:  2021-11-24 17:45
MODIFIED: 2021-11-24 17:45
"""

from tbe import tvm
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.common.platform import scope_ubuf
from tbe.common.platform import intrinsic_check_support
from tbe.common.platform import scope_preg
from tbe.tik.common.common_util import check_param_type_range
from tbe.tik.common.common_util import check_address_align
from tbe.tik.common.common_util import check_extent_overflow
from tbe.tik.common.util import TikCheckUtil
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_check_params_v210 import VectorOpsCheck
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.api.tik_vector import Vector
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_soc_core_type


class TikVectorNewApiInnerBase(TikIRBuilder):
    """
    Api Inner Base
    """
    def __init__(self):
        super(TikVectorNewApiInnerBase, self).__init__()
        self.check_params_obj = VectorOpsCheck()

    @staticmethod
    def check_mode_name(name, mode, dst):
        """
        check mode name
        Parameters
        ----------
        name
        mode
        dst

        Returns
        -------

        """
        if dst.scope == scope_preg:
            name = name.replace("vectorized_v", "vectorized_p")
            mode = None
        return name, mode, dst

    @staticmethod
    def check_vselr_params(name, dst, src0, src1):
        """
        check whether instruction params are legal

        Parameters
        ----------
        name : instruction name
        dst : destination tensor
        src0 : source tensor
        src1 : source tensor

        Returns
        -------
        None
        """
        # get api_name
        api_name = name.replace("vectorized_", "vector_")
        # check vector
        TikCheckUtil.check_type_match(src0, Vector, "%s's src0 should be Vector" % api_name)
        TikCheckUtil.check_type_match(src1, Vector, "%s's src1 should be Vector" % api_name)
        TikCheckUtil.check_type_match(dst, Vector, "%s's dst should be Vector" % api_name)
        # check scope
        dtype_str = DTYPE_MAP.get(dst.dtype) + DTYPE_MAP.get(src0.dtype) + DTYPE_MAP.get(src1.dtype)
        dtype_str_error = "src0 " + src0.dtype + " src1 " + src1.dtype + " dst " + dst.dtype
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + name, dtype_str), True,
            gen_api_check_statement(dtype_str_error, name))

    @staticmethod
    def _gen_vector_vfcvt_dtype_f2s_or_s2f(src, dst, mask, vfcvt_name, args):
        preg = mask
        instr = tvm.call_extern(dst.dtype, vfcvt_name, type_convert(dst),
                                type_convert(src), type_convert(preg), *args)
        return instr

    @staticmethod
    def _store_check_overflow(dst, mask, st_mode, vlen):
        # check overflow
        extent_map = {
            None: vlen * DTYPE_SIZE.get(dst.dtype),
            'NORM': vlen * DTYPE_SIZE.get(dst.dtype),
            'ONEPT': DTYPE_SIZE.get(dst.dtype),
            'PK': vlen * DTYPE_SIZE.get(dst.dtype) // 2,
            'INTLV': vlen * DTYPE_SIZE.get(dst.dtype) * 2,
        }
        if st_mode == 'NORM':
            if mask is None:
                extent = extent_map.get(st_mode)
                check_extent_overflow(dst, extent, Expr(dst.offset).eval_value(), 'dst')
            elif isinstance(mask, int):
                extent = mask * DTYPE_SIZE.get(dst.dtype)
                check_extent_overflow(dst, extent, Expr(dst.offset).eval_value(), 'dst')
        elif st_mode == 'PK':
            if mask is None:
                extent = extent_map.get(st_mode)
                check_extent_overflow(dst, extent, Expr(dst.offset).eval_value(), 'dst')
            elif isinstance(mask, int):
                extent = mask * DTYPE_SIZE.get(dst.dtype) // 2
                check_extent_overflow(dst, extent, Expr(dst.offset).eval_value(), 'dst')
        else:
            check_extent_overflow(dst, extent_map.get(st_mode), Expr(dst.offset).eval_value(), 'dst')

    def _check_filter_params(self, filter_params):
        if not TikSocManager.is_v210_soc():
            soc_name = get_soc_name()
            core_type = get_soc_core_type()
            msg = "current chip: %s %s doesn't support %s" % (soc_name, core_type, filter_params.api_name)
            TikCheckUtil.raise_error(msg)
        TikCheckUtil.check_type_match(filter_params.dst, Tensor,
                                      "%s's dst should be Tensor, but input type: %s" %
                                      (filter_params.api_name, type(filter_params.dst)))
        TikCheckUtil.check_type_match(filter_params.src, Tensor,
                                      "%s's src should be Tensor, but input type: %s" %
                                      (filter_params.api_name, type(filter_params.src)))
        TikCheckUtil.check_equality(filter_params.dst.scope, scope_ubuf,
                                    "%s's dst's scope should be %s, but get %s" %
                                    (filter_params.api_name, scope_ubuf, filter_params.dst.scope))
        TikCheckUtil.check_equality(filter_params.src.scope, scope_ubuf,
                                    "%s's src's scope should be %s, but get %s" %
                                    (filter_params.api_name, scope_ubuf, filter_params.src.scope))
        dtype_str = DTYPE_MAP[filter_params.src.dtype] + DTYPE_MAP[filter_params.dst.dtype]
        msg = "src: " + filter_params.src.dtype + ", dst: " + filter_params.dst.dtype
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + filter_params.name, dtype_str), True,
            gen_api_check_statement(msg, filter_params.api_name))
        # dst and src need 32 byte align
        check_address_align([filter_params.dst, filter_params.src],
                            ["%s's dst" % filter_params.api_name, "%s's src" % filter_params.api_name])
        # check window_size
        # ccec not support window_size scalar currently
        TikCheckUtil.check_type_match(filter_params.window_size, int, "%s's window_size should be type of int,"
                                                                      " but get type %s" %
                                      (filter_params.api_name, type(filter_params.window_size)))
        window_size_range = [0, 1]
        TikCheckUtil.check_in_range_by_dtype(
            filter_params.window_size, msg="%s's window_size should be in range of [%d, %d], input value is %s"
            % (filter_params.api_name, window_size_range[0], window_size_range[1], filter_params.window_size),
            var_range=window_size_range)

        line_num_min = (3, 5)
        # check line_num, dst_stride, src_stride
        check_param_type_range([filter_params.line_num, filter_params.dst_stride, filter_params.src_stride],
                               [line_num_min[filter_params.window_size], 0, 0], [255, 255, 255],
                               ["%s's line_num should not be less than window_size's correspond number value, "
                                "line_num" % filter_params.api_name, "%s's dst_stride" % filter_params.api_name,
                                "%s's src_stride" % filter_params.api_name],
                               filter_params.api_name)

        # check overflow
        self.check_params_obj.check_fifr_overflow(filter_params)

    def _gen_vector_vdup_instruction_code(self, vdup_params, mode):
        with self.new_scope():
            load_mode = tvm.tir.StringImm("MODE_ZEROING")
            if mode == 0:
                load_mode = tvm.tir.StringImm("MODE_MERGING")
            if vdup_params.name == "vectorized_vdupi":
                if DTYPE_MAP[vdup_params.dst.dtype] in ["u8", "s8"]:
                    self._gen_vector_vdupi_b8(vdup_params)
                else:
                    self._gen_vector_vdupi_b16(vdup_params, mode)
            elif vdup_params.name == "vectorized_vdups":
                self._gen_vector_vdups_code(vdup_params, load_mode)
            elif vdup_params.name in ["vectorized_vdup", "vectorized_vdupm"]:
                self._gen_vector_vdup_code(vdup_params, load_mode)
            else:
                TikCheckUtil.raise_error("instruction name %s is error" % vdup_params.name)

    def _vector_pack_unpack(self, unpack_params, merge_mode=None):
        api_name = unpack_params.name.replace("vectorized_", "vector_")
        self.check_params_obj.check_vector_one_dst_one_src_params(
            unpack_params.name, unpack_params.dst, unpack_params.src)
        TikCheckUtil.check_type_match(unpack_params.part_mode, bool, "%s's part_mode should be bool" % api_name)
        if unpack_params.dst.scope == scope_preg:
            instr_name = unpack_params.name.replace("vectorized_v", "vectorized_p")
            return self._mask_pack_unpack_make_code(instr_name, unpack_params)
        # for scope_vreg
        return self._vector_pack_unpack_func(unpack_params, merge_mode=merge_mode)

    def _vector_reg_binary_tenary_elewise_func(self, vector_reg_params, rnd_mode=None, mode=None):
        """
        do <op> by single element
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        if TikSocManager.is_v300_610l_soc() and vector_reg_params.name == "vectorized_vxor":
            mode = None
        self.check_params_obj.check_vector_one_dst_two_src_params(vector_reg_params.name, vector_reg_params)
        if vector_reg_params.dst.scope == scope_preg:
            instr_name = vector_reg_params.name.replace("vectorized_v", "vectorized_p")
            self._vector_preg_binary_tenary_elewise_code(instr_name, vector_reg_params)
        else:
            self._vector_reg_binary_tenary_elewise_code(vector_reg_params, rnd_mode, mode)
