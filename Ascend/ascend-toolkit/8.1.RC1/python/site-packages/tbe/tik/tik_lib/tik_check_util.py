#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_check_util.py
DESC:     tik tensor explanation
CREATED:  2019-04-18 18:53:42
MODIFIED: 2020-12-7 14:04:45
"""
import inspect
import re
import threading
import linecache
import os
import sys
import copy

from tbe.dsl.instrinsic.cce_intrin_md import TIKCallbackManager
from tbe.common.platform import set_current_compile_soc_info
from tbe.common.platform import scope_gm

from tbe.tik.common.tik_api_map import arch_version_mode
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.tik_lib.tik_params import CUR_FRAME_IDX
from tbe.tik.tik_lib.tik_params import MIN_START_LINE_NO
from tbe.tik.tik_lib.tik_params import INSPECT_RANGE
from tbe.tik.tik_lib.tik_params import DTYPE_IMM_MIN
from tbe.tik.tik_lib.tik_params import DTYPE_IMM_MAX
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager

TIK_CONTROL = threading.local()
TIK_CONTROL.is_user_call = True
# when api_source_info is None, node loc could be invalid,
# set "True" means raise RuntimeError, otherwise warning.
TIK_CONTROL.if_loc_invalid_raise_error = True

ERROR_MSG_LEVEL = threading.local()
ERROR_MSG_LEVEL.err_msg_level = 0


class SpanManager:
    """
    span information manager for IR
    """
    def __init__(self):
        self._span_info = {}

    def set_span(self, node, span):
        self._span_info[node] = span

    def get_span(self, node=None):
        if node:
            span = self._span_info[node]
        else:
            span = list(self._span_info.values())[-1]
        return span

    def clear(self):
        self._span_info = {}


TIK_ERROR_MSG = threading.local()
TIK_ERROR_MSG.api_source_info = None
TIK_ERROR_MSG.span_manager = SpanManager()


def canonic(filename):
    """
    to canonic file path
    """
    if filename is None:
        return ''

    if filename == ("<" + filename[1:-1] + ">"):
        return filename
    canonic_ = os.path.realpath(filename)
    canonic_ = os.path.normcase(canonic_)
    return canonic_


def read_context_from_file(filename, line_no, context_len=INSPECT_RANGE):
    """
    read code and context according to file path

    Parameters
    ----------
    filename : file absolutely path
    line_no : line number corresponding to code
    context_len : code context len

    Returns
    -------
    code and context
    """
    start_lineno = line_no - context_len // 2
    start_lineno = max(start_lineno, MIN_START_LINE_NO)
    print_lines = []
    for i in range(context_len):
        code = linecache.getline(filename, start_lineno + i)
        if code == "":
            break
        text = repr(i + start_lineno).rjust(3)
        if start_lineno + i == line_no:
            text = '%s -> ' % text
        else:
            text = '%s    ' % text
        text = text + code
        print_lines.append(text)
    return ''.join(print_lines).rstrip() + "\n"


@TIKCallbackManager.register("get_context_msg")
def get_context_msg(source_file, line_no, msg=None):
    """
    get context msg list contains error, file path and code context

    Parameters
    ----------
    source_file : file absolutely path
    line_no : line number corresponding to code
    msg : error msg

    Returns
    -------
    context msg list
    """
    msg_list = ["File path: %s, line %s" % (canonic(source_file), line_no),
                "The context code cause the exception is:",
                read_context_from_file(source_file, line_no)]
    if msg is None:
        return msg_list
    cont = os.getenv('CONTEXT_MODELCOMPILING')
    if cont and cont.upper() == "TRUE":
        msg_list.insert(0, "%s" % msg)
    else:
        msg_list.insert(0, "Error: %s" % msg)
    return msg_list


def get_traceback_msg(stack_list, err_msg_level):
    """
    get traceback msg list according to stack

    Parameters
    ----------
    stack_list : user call stack
    err_msg_level: if err_msg_level is 0, only show user's code stack info

    Returns
    -------
    traceback msg list str
    """
    msg_list = ["Traceback:"]
    stack_list.reverse()
    for info in stack_list:
        if err_msg_level == 0:
            if "/tbe/tik/" in info["filename"] or "/te/tik/" in info["filename"]:
                break
        msg_list.append("  File %s, line %s, in %s\n %s" % (
            canonic(info["filename"]), info["line_no"], info["function"],
            linecache.getline(info["filename"], info["line_no"]).rstrip("\n")))
    return "\n".join(msg_list)


def clear_tik_error_msg():
    """
    clear TIK_ERROR_MSG
    """
    TIK_ERROR_MSG.api_source_info = None
    TIK_CONTROL.is_user_call = True
    TIK_ERROR_MSG.span_manager = SpanManager()


@TIKCallbackManager.register("get_traceback_inspect_msg")
def get_traceback_inspect_msg():
    """
    get code_context and traceback msg list according to stack

    Returns:
    -------
    code_context and traceback msg list
    """
    # Return a list of records for the stack above the caller's frame.
    inspect_stack = inspect.stack()[1:]
    source_file = inspect_stack[0][1]
    line_no = inspect_stack[0][2]
    msg_list = [[source_file, line_no], ["Traceback:"]]

    for info in inspect_stack:
        msg_list[1].append("  File {info_1}, line {info_2}, in {info_3}\n {info_1_2}\n".format(
            info_1=canonic(info[1]), info_2=info[2], info_3=info[3],
            info_1_2=linecache.getline(info[1], info[2]).rstrip("\n")))
    # finally, change Traceback list to string.
    msg_list[1] = "\n".join(msg_list[1]).replace("\n\n", "\n")
    return msg_list


@TIKCallbackManager.register("get_span_msg")
def get_span_msg():
    """
    Get Current Span

    Returns:
    -------
    Current Span
    """
    return TIK_ERROR_MSG.span_manager.get_span()


def get_error_dict_args(msg):
    """
    get runtime error dict
    """
    cont = os.getenv('CONTEXT_MODELCOMPILING')
    if cont and cont.upper() == "TRUE":
        dict_arg = {}
        dict_arg['errCode'] = 'EA0000'
        # message_traceback[0]:code_context msg, [1]:traceback msg.
        message_traceback = get_traceback_inspect_msg()
        dict_arg['message'] = "\n".join(get_context_msg(*message_traceback[0], msg))
        dict_arg['traceback'] = message_traceback[1]
        raise RuntimeError(dict_arg)
    raise RuntimeError(msg)


def get_frame_info(frame):
    """
    get particular information from stack frame

    Parameters
    ----------
    frame : frame object from the call stack
    """
    filename = frame.f_code.co_filename
    return {"filename": filename, "line_no": frame.f_lineno,
            "function": frame.f_code.co_name,
            "sym_table": copy.copy(frame.f_locals)
           }


def current_frame(depth=0):
    """
    get current frame information

    Parameters
    ----------
    depth : stack depth

    Return
    ----------
    current frame information
    """
    return [get_frame_info(sys._getframe(depth + 1))]


def stack(depth=0):
    """
    get stack information after depth

    Parameters
    ----------
    depth : stack depth

    Return
    ----------
    list of frame info
    """
    frame = sys._getframe(depth + 1)
    frame_list = []
    while frame:
        frame_list.append(get_frame_info(frame))
        frame = frame.f_back
    return frame_list


def print_error_msg(msg, exception_type=RuntimeError):
    """
    cause exception message according to source info and err_msg_level

    Parameters
    ----------
    msg : exception msg
    exception_type : type of exception, such as ValueError

    Returns
    -------
    None
    """

    cont = os.getenv('CONTEXT_MODELCOMPILING')
    if cont and cont.upper() == "TRUE":
        dict_arg = {}
        dict_arg['errCode'] = 'EA0000'
        # message_traceback[0]:code_context msg, [1]:traceback msg.
        message_traceback = get_traceback_inspect_msg()
        if TIK_ERROR_MSG.api_source_info is None:
            dict_arg['message'] = "\n".join(get_context_msg(*message_traceback[0], msg))
            dict_arg['traceback'] = message_traceback[1]
            raise RuntimeError(dict_arg)
        context_msg_list = get_context_msg(
            TIK_ERROR_MSG.api_source_info[CUR_FRAME_IDX].get("filename"),
            TIK_ERROR_MSG.api_source_info[CUR_FRAME_IDX].get("line_no"), msg)
        dict_arg['message'] = "\n".join(context_msg_list)
        if ERROR_MSG_LEVEL.err_msg_level == 1:
            # clear TIK_ERROR_MSG before exit
            clear_tik_error_msg()
            dict_arg['traceback'] = message_traceback[1]
            raise RuntimeError(dict_arg)
        dict_arg['traceback'] = get_traceback_msg(
            TIK_ERROR_MSG.api_source_info, ERROR_MSG_LEVEL.err_msg_level)
        # clear TIK_ERROR_MSG before exit
        clear_tik_error_msg()
        raise RuntimeError(dict_arg)
    if TIK_ERROR_MSG.api_source_info is None:
        raise RuntimeError("please register source info first\n")

    context_msg_list = get_context_msg(
        TIK_ERROR_MSG.api_source_info[CUR_FRAME_IDX].get("filename"),
        TIK_ERROR_MSG.api_source_info[CUR_FRAME_IDX].get("line_no"), msg)
    print("\n".join(context_msg_list))
    if ERROR_MSG_LEVEL.err_msg_level == 1:
        # clear TIK_ERROR_MSG before exit
        clear_tik_error_msg()
        raise exception_type(msg)

    traceback_msg_list = get_traceback_msg(stack(), ERROR_MSG_LEVEL.err_msg_level)
    clear_tik_error_msg()
    raise SystemExit(traceback_msg_list)


def float_in_range(var, dtype, rel_tol, dtype_range=None):
    """
    Check whether float var in range
    Parameters
    ----------
    var: the float var
    dtype: float16 or float32
    rel_tol: accuracy error
    dtype_range: special data range

    Returns
    -------
    True or False
    """
    result = True
    if dtype_range is None:
        dtype_range = [DTYPE_IMM_MIN[dtype], DTYPE_IMM_MAX[dtype]]
    if var > dtype_range[1] and var - dtype_range[1] > rel_tol:
        result = False
    elif var < dtype_range[0] and dtype_range[1] - var > rel_tol:
        result = False
    return result


def set_init_global_variables():
    """
    set err message level and default soc info
    """
    ERROR_MSG_LEVEL.err_msg_level = 0
    set_current_compile_soc_info('Ascend310')


class TikCheckUtil:
    """
    Provide check util function
    """

    @staticmethod
    def check_type_match(var, var_type, msg="Variable's type error"):
        """
        check var's type if correct
        Parameters
        ----------
        var: variable
        var_type: var's correct type
        msg: exception msg

        Returns
        -------
        None. If type not match, raise error.
        """
        if not isinstance(var, var_type):
            print_error_msg(msg)

    @staticmethod
    def check_var_in_list(var, var_list, msg="Variable out of range"):
        """
        check var if in correct range
        Parameters
        ----------
        var: variable
        var_list: var's correct range
        msg: exception msg

        Returns
        -------
        None. If not in range, raise error.
        """
        if var not in var_list:
            print_error_msg(msg)

    @staticmethod
    def check_in_range_by_dtype(var, dtype=None, msg="Variable out of range", var_range=None):
        """
        check var if in correct range according input dtype
        Parameters
        ----------
        var: variable
        dtype: var's dtype
        msg: exception msg
        var_range: specified var range

        Returns
        -------
        None. If not in range, raise error.
        """
        if not isinstance(var, (float, int)):
            return
        if var_range is None:
            var_range = [DTYPE_IMM_MIN[dtype], DTYPE_IMM_MAX[dtype]]
        if dtype is None:
            dtype = "int32"

        if dtype in ["int8", "uint8", "int16", "uint16", "int32", "uint32"]:
            if var < var_range[0] or var > var_range[1]:
                print_error_msg(msg)
        elif dtype == "float16" or dtype == "bfloat16":
            rel_tol = 1e-5
            if not float_in_range(var, dtype, rel_tol, var_range):
                print_error_msg(msg)
        elif dtype == "float32":
            rel_tol = 1e-9
            if not float_in_range(var, dtype, rel_tol, var_range):
                print_error_msg(msg)
        else:
            print_error_msg("Unsupported dtype for check_in_dtype_range")

    @staticmethod
    def check_equality(var1, var2, msg="Variables is not equal to each other"):
        """
        check if var1 == var2
        Parameters
        ----------
        var1: variable1
        var2: variable2
        msg: exception msg

        Returns
        -------
        None. If var1 != var2, raise error.
        """
        if var1 != var2:
            print_error_msg(msg)

    @staticmethod
    def check_not_equality(var1, var2, msg="Variables is equal to each other"):
        """
        check if var1 == var2
        Parameters
        ----------
        var1: variable1
        var2: variable2
        msg: exception msg

        Returns
        -------
        None. If var1 == var2, raise error.
        """
        if var1 == var2:
            print_error_msg(msg)

    @staticmethod
    def check_ge(var1, var2, msg="Variable1 should be more than or equal to variable2"):
        """
        check if var1 >= var2
        Parameters
        ----------
        var1: variable1
        var2: variable2
        msg: exception msg

        Returns
        -------
        None. If var1 < var2, raise error.
        """
        if isinstance(var1, (int, float)) and isinstance(var2, (int, float)) and var1 < var2:
            print_error_msg(msg)

    @staticmethod
    def check_le(var1, var2, msg="Variable1 should be less than or equal to  variable2"):
        """
        check if var1 <= var2
        Parameters
        ----------
        var1: variable1
        var2: variable2
        msg: exception msg

        Returns
        -------
        None. If var1 > var2, raise error.
        """
        if isinstance(var1, (int, float)) and isinstance(var2, (int, float)) and var1 > var2:
            print_error_msg(msg)

    @staticmethod
    def check_lt(var1, var2, msg="Variable1 should be less than variable2"):
        """
        check if var1 < var2
        Parameters
        ----------
        var1: variable1
        var2: variable2
        msg: exception msg

        Returns
        -------
        None. If var1 > var2, raise error.
        """
        if isinstance(var1, (int, float)) and isinstance(var2, (int, float)) and var1 >= var2:
            print_error_msg(msg)

    @staticmethod
    def check_even(var, msg="Variable should be even"):
        """
        check if var&1 == 1
        Parameters
        ----------
        var: variable1
        msg: exception msg

        Returns
        -------
        None. If var&1 == 1, raise error
        """
        if var & 1:
            print_error_msg(msg)

    @staticmethod
    def check_is(var1, var2, msg="Variables is not the other one"):
        """
        check if var1 is var2
        Parameters
        ----------
        var1: variable1
        var2: variable2
        msg: exception msg

        Returns
        -------
        None. If var1 is not var2, raise error.
        """
        if var1 is not var2:
            print_error_msg(msg)

    @staticmethod
    def check_not_is(var1, var2=None, msg="Variables is None"):
        """
        check if var1 is not var2
        Parameters
        ----------
        var1: variable1
        var2: variable2
        msg: exception msg

        Returns
        -------
        None. If var1 is var2, raise error.
        """
        if var1 is var2:
            print_error_msg(msg)

    @staticmethod
    def check_name_str_valid(name):
        """
        check name is str and only contains 0-9,a-z,A-Z,_
        Parameters
        ----------
        name: obj name

        Returns
        -------
        None. If name not match, raise error.
        """
        TikCheckUtil.check_type_match(name, str, "name must be str")
        if name[0].isdigit():
            print_error_msg("name cannot start with a digit.")
        if not re.match("^[0-9A-Za-z_]+$", name):
            print_error_msg("name should only contain 0-9, a-z, A-Z, _")

    @staticmethod
    def check_not_contains(var1, var2, msg="Variables is in the other one"):
        """
        check if var1 is in var2
        Parameters
        ----------
        var1: variable1
        var2: variable2
        msg: exception msg

        Returns
        -------
        None. If var1 is not in var2, raise error.
        """
        if var1 in var2:
            print_error_msg(msg)

    @staticmethod
    def check_atomic_add(mode, dst):
        """
        Check atomic_add_value matches dtype.
        """
        atomic_add_value_and_dtype = {
            1: 'float32',
            2: 'float16',
            3: 'int16',
            4: 'int32',
            5: 'int8',
            6: 'bfloat16'
        }

        soc_name = get_soc_name()
        if not TikSocManager.is_mini_soc() and isinstance(mode, int):
            if mode in arch_version_mode[soc_name][1:] and dst.scope == scope_gm:
                TikCheckUtil.check_equality(atomic_add_value_and_dtype.get(mode), dst.dtype,
                                            msg="set_atomic_add(%s), dst's dtype must be %s, "
                                                "but get dst's dtype is %s." %
                                            (mode, atomic_add_value_and_dtype.get(mode), dst.dtype))

    @staticmethod
    def raise_error(msg, exception_type=RuntimeError):
        """
        raise exception directly

        Parameters
        ----------
        exception_type : type of exception, such as ValueError
        msg : exception msg

        Returns
        -------
        None
        """
        print_error_msg(msg, exception_type)

    @staticmethod
    def raise_warning(msg):
        """
        raise warning directly

        Parameters
        ----------
        msg : exception msg

        Returns
        -------
        None
        """
        print("Warning: %s" % msg)
