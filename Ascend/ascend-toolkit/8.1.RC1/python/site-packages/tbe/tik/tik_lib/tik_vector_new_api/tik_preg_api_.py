#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_preg_api.py
DESC:     provide vector instructions
CREATED:  2020-03-10 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""
from tbe import tvm
from tbe.tvm import call_extern
from tbe.tvm import call_cce_pure_intrin
from tbe.common.platform import scope_areg
from tbe.common.platform import scope_preg
from tbe.tik.common.common_util import check_address_align
from tbe.tik.common.common_util import check_extent_overflow
from tbe.tik.debug.decorators_preg_v210 import vector_mask_set_decorator
from tbe.tik.debug.decorators_preg_v210 import vector_mask_load_decorator
from tbe.tik.debug.decorators_preg_v210 import vector_mask_store_decorator
from tbe.tik.debug.decorators_preg_v210 import vector_mask_gen_decorator
from tbe.tik.debug.decorators_v210 import vector_vpd_mask_decorator
from tbe.tik.debug.decorators_preg_v210 import vector_mask_ele_wise_decorator
from tbe.tik.debug.decorators_preg_v210 import vector_mask_pack_unpack_decorator
from tbe.tik.debug.decorators_preg_v210 import vector_mask_intlv_dintlv_decorator
from tbe.tik.debug.decorators_preg_v210 import vector_mask_mov_decorator
from tbe.tik.debug.decorators_preg_v210 import vector_mask_slide_decorator
from tbe.tik.common.util import TikCheckUtil
from tbe.tik.common.util import TikUtil
from tbe.tik.tik_lib.tik_check_util import print_error_msg
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_vector import Vector
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_params import PAT_STR_MODE
from tbe.tik.tik_lib.tik_params import PAT_MODE_MASK
from tbe.tik.tik_lib.tik_params import PAT_MODE_MASK_B32
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.common.platform import intrinsic_check_support


class TikPregApiInner(TikIRBuilder):
    """
    Vector, Serialization, Spr Operation Api
    """
    def __init__(self):
        super(TikPregApiInner, self).__init__()
        self.core_arch = None
        self.core_version = None

    def gen_preg_according_to_soc_version(self, dtype):
        """
        get soc version
        :param dtype:
        :return:
        """
        if TikSocManager.is_v210_soc():
            preg = self.gen_vpd_mask(dtype)
        if TikSocManager.is_v300_610l_soc():
            preg = self._vector_mask_gen(dtype, "ALL")
        return preg

    def gen_vpd_mask(self, dtype):
        """
        gen vpd mask
        :param dtype:
        :return:
        """
        preg = Vector(self, 'bool', name="predicate_buf_", scope=scope_preg)
        self._gen_vpd_mask_code(preg, dtype)
        return preg

    def _vector_mask_gen(self, dtype, init_mode="ALL"):
        """
        generate preg instruction according init_mode
        Parameters
        ----------
        dtype: data type of Vector Register, available bits of mask depend dtype
        init_mode: preg init mode, default all bit to true

        Returns
        -------
        new preg, save mask
        """
        instr_name = "vectorized_pge"
        TikCheckUtil.check_type_match(
            init_mode, (str,),
            "Instruction _vector_mask_gen's init_mode should string, input type of init_mode: %s" % type(init_mode))

        TikCheckUtil.check_var_in_list(
            init_mode, PAT_STR_MODE, "Instruction _vector_mask_gen's init_mode must be in [%s]" % PAT_STR_MODE.keys())

        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + instr_name, dtype), True,
            gen_api_check_statement(dtype, "_vector_mask_gen"))

        preg = Vector(self, dtype="bool", name="predicate_buf_", scope=scope_preg)

        str_part_mode = PAT_STR_MODE[init_mode]
        self._vector_pge_code_make(preg, dtype, str_part_mode)

        return preg

    @vector_mask_load_decorator
    def _vector_mask_load(self, mask_load_params):
        """
        load data from src as mask
        Parameters
        ----------
        dst: dst preg
        src: src ub tensor
        ld_mode: data load mode, can be "NORM", "DS", "US".

        Returns
        -------
        None
        """
        instr_name = "vectorized_pld"
        # check ld_mode
        TikCheckUtil.check_var_in_list(mask_load_params.ld_mode, ['NORM', 'US', 'DS'],
                                       "When dst's dtype is bool, ld_mode should be 'NORM' or 'US' or 'DS', "
                                       "but input ld_mode: %s" % mask_load_params.ld_mode)
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + instr_name, mask_load_params.src.dtype), True,
            gen_api_check_statement(mask_load_params.src.dtype, "vector_load"))

        # check src's align and overflow info
        align_map = {"NORM": 32, "US": 16, "DS": 64}
        check_address_align([mask_load_params.src], ["src"], align_map.get(mask_load_params.ld_mode))
        check_extent_overflow(mask_load_params.src, align_map.get(mask_load_params.ld_mode),
                              Expr(mask_load_params.src.offset).eval_value(), 'src')

        with self.new_scope():
            with self.context.freeze():
                areg = Vector(self, dtype="uint32", name='address_buf_', scope=scope_areg)
            pld_instr = call_extern(
                mask_load_params.src.dtype, instr_name, type_convert(mask_load_params.dst),
                mask_load_params.src.access_ptr("r", cast_dtype="uint32",
                                                extent=align_map.get(mask_load_params.ld_mode)),
                type_convert(areg), call_cce_pure_intrin('handle', 'tvm_cce_string_print',
                                                         tvm.tir.StringImm(mask_load_params.ld_mode)))
            self.emit(pld_instr)

    @vector_mask_store_decorator
    def _vector_mask_store(self, mask_store_params):
        """
        store the mask to dst ub
        Parameters
        ----------
        dst: dst ub tensor
        src: dst preg
        st_mode: data store mode, can be "NORM", "PK".

        Returns
        -------
        None
        """
        instr_name = "vectorized_pst"
        # check ld_mode
        TikCheckUtil.check_var_in_list(mask_store_params.st_mode, ['NORM', 'PK'],
                                       "When src's dtype is bool, st_mode should be 'NORM' or'PK', "
                                       "but input st_mode: %s " % mask_store_params.st_mode)

        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + instr_name, mask_store_params.dst.dtype), True,
            gen_api_check_statement(mask_store_params.dst.dtype, "vector_store"))

        # check src's align and overflow info
        align_map = {"NORM": 32, "PK": 16}
        check_address_align([mask_store_params.dst], ["dst"], align_map.get(mask_store_params.st_mode))
        check_extent_overflow(mask_store_params.dst,
                              align_map.get(mask_store_params.st_mode),
                              Expr(mask_store_params.dst.offset).eval_value(), 'dst')

        with self.new_scope():
            with self.context.freeze():
                areg = Vector(self, dtype="int32", name='address_buf_', scope=scope_areg)
            pst_instr = call_extern(
                mask_store_params.dst.dtype, instr_name, type_convert(mask_store_params.src),
                mask_store_params.dst.access_ptr("w", cast_dtype="uint32",
                                                 extent=align_map.get(mask_store_params.st_mode)),
                type_convert(areg), call_cce_pure_intrin('handle', 'tvm_cce_string_print',
                                                         tvm.tir.StringImm(mask_store_params.st_mode)))
            self.emit(pst_instr)

    @vector_mask_gen_decorator
    def _vector_pge_code_make(self, preg, dtype, str_part_mode):
        instr_name = "vectorized_pge" + TikUtil.bit_type(dtype)
        with self.new_scope():
            part_indicator_exp = call_cce_pure_intrin(
                'handle', 'tvm_cce_string_print', tvm.tir.StringImm(str_part_mode))
            pge_intr = call_extern(preg.dtype, instr_name, type_convert(part_indicator_exp))
            pge_stmt = tvm.tir.Store(type_convert(preg), pge_intr, 0)
            self.emit(pge_stmt)

    @vector_mask_set_decorator
    def _vector_pset_code_make(self, preg_params):
        """
        pset code tvm.tir
        :param preg_params: contains dtype str_part_mode mask
        :return:
        """
        instr_name = "vectorized_pset" + TikUtil.bit_type(preg_params.dtype)
        preg = preg_params.mask
        str_part_mode = preg_params.set_mode
        with self.new_scope():
            part_indicator_exp = call_cce_pure_intrin(
                'handle', 'tvm_cce_string_print', tvm.tir.StringImm(str_part_mode))
            pge_intr = call_extern(preg.dtype, instr_name, type_convert(part_indicator_exp))
            pge_stmt = tvm.tir.Store(type_convert(preg), pge_intr, 0)
            self.emit(pge_stmt)

    @vector_vpd_mask_decorator
    def _gen_vpd_mask_code(self, preg, dtype):
        with self.new_scope():
            vpd_name = "vectorized_vpd" + TikUtil.bit_type(dtype)
            vpd_intr = call_extern(preg.dtype, vpd_name)
            vpd_stmt = tvm.tir.Store(type_convert(preg), vpd_intr, 0)
        self.emit(vpd_stmt)

    def _gen_mask_imm(self, mask, dtype, vl_t):
        # needn't to check mask, pslide will check mask
        if mask == vl_t:
            preg_src0 = self.gen_preg_according_to_soc_version(dtype)
        elif TikUtil.dtype_is_b32(dtype) and mask in PAT_MODE_MASK_B32:
            pat_mode = PAT_MODE_MASK_B32[mask]
            preg_src0 = self._vector_mask_gen(dtype, pat_mode)
        elif not TikUtil.dtype_is_b32(dtype) and mask in PAT_MODE_MASK:
            pat_mode = PAT_MODE_MASK[mask]
            preg_src0 = self._vector_mask_gen(dtype, pat_mode)
        else:
            # according the mask value to create preg
            move_slide = vl_t - mask
            # src0 all bits set to 1
            preg_src0 = self._vector_mask_gen(dtype, "ALL")
            # src1 all bits set to 0
            preg_src1 = self._vector_mask_gen(dtype, "ALLF")
            # dst reuse src0
            self.vector_vslide(preg_src0, preg_src0, preg_src1, move_slide, dtype)
        return preg_src0

    def _gen_mask_scalar(self, mask, dtype, vl_t):
        # according the mask value to create preg
        move_slide = self.Scalar(dtype=mask.dtype,
                                 init_value=0)
        move_slide.set_as(vl_t - mask)
        # src0 all bits set to 1
        preg_src0 = self._vector_mask_gen(dtype, "ALL")
        # src1 all bits set to 0
        preg_src1 = self._vector_mask_gen(dtype, "ALLF")
        # dst reuse src0
        self.vector_vslide(preg_src0, preg_src0, preg_src1, move_slide, dtype)
        return preg_src0

    def _gen_mask(self, mask, dtype):
        vl_t = self.get_vector_length(dtype)
        return_mask = None
        with self.context.freeze():
            if isinstance(mask, Vector) and mask.scope == scope_preg:
                return_mask = mask
            elif mask is None:
                return_mask = self.gen_preg_according_to_soc_version(dtype)
            elif isinstance(mask, int):
                if mask < 0 or mask > vl_t:
                    print_error_msg("mask should be in range [0, %d] for dtype %s, but input value: %d" %
                                    (vl_t, dtype, mask))
                return_mask = self._gen_mask_imm(mask, dtype, vl_t)
            elif isinstance(mask, (Scalar, Expr)):
                if mask.dtype == "int16":
                    return_mask = self._gen_mask_scalar(mask, dtype, vl_t)
                else:
                    print_error_msg("Only support None, imm(int), Scalar(int16), Expr(int16), Vector(bool) mask, "
                                    "don't support type %s(%s) mask" % (type(mask), mask.dtype))
            else:
                if isinstance(mask, Vector):
                    print_error_msg("Only support None, imm(int), Scalar(int16), Expr(int16), Vector(bool) mask, "
                                    "don't support type %s(%s) mask" % (type(mask), mask.dtype))
                else:
                    print_error_msg("Only support None, imm(int), Scalar(int16), Expr(int16), Vector(bool) mask, "
                                    "don't support type %s mask" % type(mask))
        return return_mask

    @vector_mask_intlv_dintlv_decorator
    def _mask_intlv_pintlv_make_code(self, intlv_params, dtype):
        instr_name = intlv_params.name + TikUtil.bit_type(dtype)
        with self.new_scope():
            instr = call_extern(dtype, instr_name, type_convert(intlv_params.dst0),
                                type_convert(intlv_params.dst1),
                                type_convert(intlv_params.src0), type_convert(intlv_params.src1))
            self.emit(instr)

    @vector_mask_pack_unpack_decorator
    def _mask_pack_unpack_make_code(self, name, unpack_params):
        with self.new_scope():
            load_mode = tvm.tir.StringImm("HIGHER")
            if not unpack_params.part_mode:
                load_mode = tvm.tir.StringImm("LOWER")
            instr = call_extern(unpack_params.dst.dtype, name, type_convert(unpack_params.dst),
                                type_convert(unpack_params.src),
                                call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            self.emit(instr)

    @vector_mask_ele_wise_decorator
    def _vector_preg_binary_tenary_elewise_code(self, name, vec_preg_params):
        """
        do <op> by single element
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        with self.new_scope():
            preg = self._gen_mask(vec_preg_params.mask, "uint8")
            instr = call_extern(vec_preg_params.dst.dtype, name, type_convert(vec_preg_params.dst),
                                type_convert(vec_preg_params.src0),
                                type_convert(vec_preg_params.src1), type_convert(preg))
            self.emit(instr)

    @vector_mask_mov_decorator
    def _vector_mask_mov_make_code(self, make_code_params):
        """
        gen vector_mask_mov code
        """
        with self.new_scope():
            preg = self._gen_mask(make_code_params.mask, "uint8")
            instr = call_extern(make_code_params.dst.dtype, make_code_params.name,
                                type_convert(make_code_params.dst), type_convert(make_code_params.src),
                                type_convert(preg))
            self.emit(instr)

    @vector_mask_slide_decorator
    def _vector_mask_slide_gen_code(self, vec_params):
        """
        set dst preg value accroding src0 src1
        Parameters
        ----------
        vec_mask_dst: dst preg
        vec_mask_src0: src preg
        vec_mask_src1: src preg
        dtype: data type for preg
        slide_size: right slide size, slide size must in [0, VL/8]

        Returns
        -------
        None
        """

        with self.new_scope():
            instr = call_extern(vec_params.dtype, vec_params.name, type_convert(vec_params.dst),
                                type_convert(vec_params.src0),
                                type_convert(vec_params.src1), type_convert(vec_params.slide_size))
            self.emit(instr)
