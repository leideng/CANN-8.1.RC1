#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_expr.py
DESC:     expr
CREATED:  2019-04-18 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""
from itertools import groupby
import numpy as np

from tbe import tvm
from tbe.tvm.tir import Simplify
from tbe.tvm.tir.generic import cast
from tbe.tik.common.debug_api import is_large_uint
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_params import MAX_INT32_VALUE
from tbe.tik.tik_lib.tik_params import MIN_INT32_VALUE
from tbe.tik.tik_lib.tik_params import MAX_INT64_VALUE
from tbe.tik.tik_lib.tik_params import MIN_INT64_VALUE
from tbe.tik.tik_lib.tik_params import MAX_FLOAT16_VALUE
from tbe.tik.tik_lib.tik_params import MIN_FLOAT16_VALUE

# tvm expr node type
_TVM_EXPR_MAP = (tvm.tir.IntImm, tvm.tir.FloatImm, tvm.tir.Cast, tvm.tir.Var, tvm.tir.Add,
                 tvm.tir.Sub, tvm.tir.Mul, tvm.tir.Mod, tvm.tir.FloorMod, tvm.tir.Min, tvm.tir.Max,
                 tvm.tir.EQ, tvm.tir.NE, tvm.tir.LT, tvm.tir.LE, tvm.tir.GT, tvm.tir.GE, tvm.tir.And,
                 tvm.tir.Or, tvm.tir.Not, tvm.tir.Load, tvm.tir.Div, tvm.tir.FloorDiv)


def invalid_dtype_for_version():
    """
    get invalid dtype for version
    Returns
    -------

    """
    if TikSocManager.is_mini_soc():
        return "float16", "float32"
    return ("float16",)


def check_and_update_dtype_float16(left_op, right_op):
    """
    keep left and right operators of BasicExpr having same dtype

    Parameters
    ----------
    left_op: left operator of BasicExpr operation, type: BasicExpr
    right_op: right operator of BasicExpr operation, type: BasicExpr

    Returns
    -----
    left_op: left operator of BasicExpr after processed, type: Expr
    right_op: right operator of BasicExpr after processed, type: Expr
    """
    if left_op.dtype == "float16" and right_op.dtype == "float16" and TikSocManager.is_v210_vec_soc():
        left_op = cast(left_op, "float32")
        right_op = cast(right_op, "float32")
        return left_op, right_op

    return left_op, right_op


def get_float16_range_value(value):
    """
    get float16 range value
    Parameters
    ----------
    value: value

    Returns
    -------
    value
    """
    if value < MIN_FLOAT16_VALUE:
        return MIN_FLOAT16_VALUE
    if value > MAX_FLOAT16_VALUE:
        return MAX_FLOAT16_VALUE
    return value


def is_basic_expr(data_list):
    """
    judging BasicExpr data type

    Parameters
    ----------
    data_list : data list

    Returns
    -------
    bool, BasicExpr data type judge result
    """
    # If you import at the top of the file, it causes a loop
    if not isinstance(data_list, (tuple, list)):
        data_list = [data_list]
    for data in data_list:
        if not isinstance(data, BasicExpr):
            return False
    return True


def has_tik_var(data_list):
    """
    judge whether has tik expr, tik scalar or tvm var
    Parameters
    ----------
    data_list: input data list to check

    Returns
    -------
    bool, True: has var, False: no var

    """
    var_type_list = (BasicExpr, tvm.ir.PrimExpr)
    if not isinstance(data_list, (tuple, list)):
        data_list = [data_list]
    for data in data_list:
        if isinstance(data, var_type_list):
            return True
    return False


class BasicExpr():
    """
    hint: basic expression
    """
    def __init__(self):
        self.class_type = Expr

    @source_info_decorator()
    def __add__(self, other):
        """
        add
        Parameters
        ----------
        other:is added
        Returns
        ----------
        add result
        """
        return self._add(other)

    @source_info_decorator()
    def __radd__(self, other):
        """
        reverse add
        Parameters
        ----------
        other:add
        Returns
        ----------
        add result
        """
        return self._add(other)



    @source_info_decorator()
    def __sub__(self, other):
        """
        subtraction
        Parameters
        ----------
        other:is subtracted
        Returns
        ----------
        subtraction result
        """
        return self._sub(other)

    @source_info_decorator()
    def __rsub__(self, other):
        """
        reverse subtraction
        Parameters
        ----------
        other:subtract
        Returns
        ----------
        subtraction result
        """
        return self._rsub(other)

    @source_info_decorator()
    def __mul__(self, other):
        """
        multiplication
        Parameters
        ----------
        other:is multiplied
        Returns
        ----------
        multiplication result
        """
        return self._mul(other)

    @source_info_decorator()
    def __rmul__(self, other):
        """
        reverse multiplication
        Parameters
        ----------
        other:multiplied
        Returns
        ----------
        multiplication result
        """
        return self._mul(other)

    @source_info_decorator()
    def __div__(self, other):
        """
        divide
        Parameters
        ----------
        other:is divided
        Returns
        ----------
        divide result
        """
        return self._div(other)

    @source_info_decorator()
    def __rdiv__(self, other):
        """
        reverse divide
        Parameters
        ----------
        other:divide
        Returns
        ----------
        divide result
        """
        return self._rdiv(other)

    @source_info_decorator()
    def __truediv__(self, other):
        """
        true divide
        Parameters
        ----------
        other:divide
        Returns
        ----------
        true divide result
        """
        return self._div(other)

    @source_info_decorator()
    def __rtruediv__(self, other):
        """
        reverse true divide
        Parameters
        ----------
        other:is divided
        Returns
        ----------
        true divide result
        """
        return self._rdiv(other)

    @source_info_decorator()
    def __floordiv__(self, other):
        """
        floor divide
        Parameters
        ----------
        other:is operated
        Returns
        ----------
        floor divide result
        """
        return self._div(other)

    @source_info_decorator()
    def __rfloordiv__(self, other):
        """
        reverse floor divide
        Parameters
        ----------
        other:is operating
        Returns
        ----------
        floor divide result
        """
        return self._rdiv(other)

    @source_info_decorator()
    def __mod__(self, other):
        """
        modulus operator
        Parameters
        ----------
        other:is operated
        Returns
        ----------
        modulus operator result
        """
        return self._mod(other)

    @source_info_decorator()
    def __rmod__(self, other):
        """
        reverse modulus operator
        Parameters
        ----------
        other:is operating
        Returns
        ----------
        modulus operator result
        """
        return self._rmod(other)

    @source_info_decorator()
    def __neg__(self):
        """
        negative operator
        Parameters
        ----------
        Returns
        ----------
        negative operator result
        """
        if self.dtype[:4].lower() == "uint":
            TikCheckUtil.raise_error("uint don't support negative.")
        return self._mul(Expr(-1, self.dtype))

    @source_info_decorator()
    def __lshift__(self, other):
        """
        shift operator
        Parameters
        ----------
        other:is operated
        Returns
        ----------
        shift operator result
        """
        return self._lshift(other)

    @source_info_decorator()
    def __rshift__(self, other):
        """
        reverse shift operator
        Parameters
        ----------
        other:is operated
        Returns
        ----------
        shift operator result
        """
        return self._rshift(other)

    @source_info_decorator()
    def __and__(self, other):
        """
        and operator
        Parameters
        ----------
        other:is Anded
        Returns
        ----------
        And result
        """
        othert = Expr(other, self.dtype)
        tmp_node = tvm.call_intrin(self.dtype, "tir.bitwise_and", self.get(), othert.get())
        return self.class_type(tmp_node)

    @source_info_decorator()
    def __or__(self, other):
        """
        or operator
        Parameters
        ----------
        other:is operated
        Returns
        ----------
        or result
        """
        othert = Expr(other, self.dtype)
        tmp_node = tvm.call_intrin(self.dtype, "tir.bitwise_or", self.get(), othert.get())
        return self.class_type(tmp_node)

    @source_info_decorator()
    def __xor__(self, other):
        """
        xor operator
        Parameters
        ----------
        other:is operated
        Returns
        ----------
        xor result
        """
        othert = Expr(other, self.dtype)
        tmp_node = tvm.call_intrin(self.dtype, "tir.bitwise_xor", self.get(), othert.get())
        return self.class_type(tmp_node)

    @source_info_decorator()
    def __invert__(self):
        """
        invert operator
        Parameters
        ----------
        Returns
        ----------
        invert result
        """
        tmp_node = tvm.call_intrin(self.dtype, "tir.bitwise_not", self.get())
        return self.class_type(tmp_node)

    @source_info_decorator()
    def __lt__(self, other):
        """
        less than comparison
        Parameters
        ----------
        other:target object
        Returns
        ----------
        comparison result
        """
        return self._lt(other)

    @source_info_decorator()
    def __le__(self, other):
        """
        less than or equal comparison
        Parameters
        ----------
        other:target object
        Returns
        ----------
        comparison result
        """
        return self._le(other)

    @source_info_decorator()
    def __eq__(self, other):
        """
        equal comparison
        Parameters
        ----------
        other:target object

        Returns
        ----------
        comparison result
        """
        return self._eq(other)

    @source_info_decorator()
    def __ne__(self, other):
        """
        Don't equal comparison
        Parameters
        ----------
        other:target object

        Returns
        ----------
        return:comparison result
        """
        return self._ne(other)

    @source_info_decorator()
    def __gt__(self, other):
        """
        greater than comparison
        Parameters
        ----------
        other:target object

        Returns
        ----------
        return:comparison result
        """
        return self._gt(other)

    @source_info_decorator()
    def __ge__(self, other):
        """
        greater than or equal comparison
        Parameters
        ----------
        other:target object

        Returns
        ----------
        return:comparison result
        """
        return self._ge(other)

    @source_info_decorator()
    def __nonzero__(self):
        """
        non zero comparison
        Parameters
        ----------

        Returns
        ----------
        return:comparison result
        """
        self_value = self.eval_value()
        if self_value is None:
            TikCheckUtil.raise_error(
                "Cannot use python and/or/not/if/elif operator to tik Expr, "
                "please use tik.all/tik.any/tik.negate/if_scope/elif_scope to replace")
        return bool(self_value)

    @source_info_decorator()
    def __bool__(self):
        """
        bool type judement
        Parameters
        ----------

        Returns
        ----------
        return:judement result
        """
        return self.__nonzero__()

    def __hash__(self):
        """
        return hash value
        Parameters
        ----------

        Returns
        ----------
        return:hash value
        """
        return hash(self.get())

    def __str__(self):
        """
         return string value
         Parameters
         ----------

         Returns
         ----------
         return:string value
         """
        return str(self.get())

    def __repr__(self):
        """
         get repr value
         Parameters
         ----------

         Returns
         ----------
         return:repr() value
         """
        return str(self.get())

    @property
    def dtype(self):
        """
        get data type
        Parameters
        ----------

        Returns
        ----------
        data type
        """
        return self.get().dtype

    @staticmethod
    def float_operation_ban(operation_list):
        """
        float operation check, some core type cannot support float16 or float32 operator
        Parameters
        ----------
        operation_list: operators' list

        Returns
        -------

        """
        value_a = operation_list[0]
        value_b = operation_list[1]
        if hasattr(value_a, "dtype"):
            if value_a.dtype in invalid_dtype_for_version():
                TikCheckUtil.raise_error("floating-point operation is not allowed in"
                                         " compare, left operation is %s" % value_a.dtype)
        else:
            if hasattr(value_b, "dtype"):
                if value_b.dtype in invalid_dtype_for_version():
                    TikCheckUtil.raise_error("floating-point operation is not allowed in"
                                             " compare, right operation is %s" % value_b.dtype)

    @staticmethod
    def expr_cast(dtype, expr_):
        """
        get expr cast
        Parameters
        ----------
        dtype:data type
        expr_:expr

        Returns
        -------
        expr
        """
        return cast(expr_, dtype)

    def get(self):
        """
        get error information
        Parameters
        ----------

        Returns
        ----------
        error information
        """
        TikCheckUtil.raise_error("This is a BASIC type of Scalar ad expr : %s" % self)

    def equal(self, other):
        """
        equal comparison
        Parameters
        ----------
        other:target object

        Returns
        ----------
        comparison result
        """
        left_op, othert = self.change_dtype_of_expr_op(other)
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.EQ(left_op, othert))

    @source_info_decorator()
    def astype(self, dtype):
        """
        set data type
        Parameters
        ----------
        dtype:data type

        Returns
        ----------
        return:result
        """
        return self.class_type(self.expr_cast(dtype, self.get()))

    def reinterpret_cast_to(self, dtype):
        """
        transform  data type
        Parameters
        ----------
        dtype: transform data type

        Returns
        ----------
        return:result
        """
        tmp_node = tvm.call_intrin(dtype, "tir.reinterpret", self.get())
        return self.class_type(tmp_node)

    def change_dtype_of_expr_op(self, right_op):
        """
        keep left and right operators of BasicExpr having same dtype

        Parameters
        ----------
        self: left operator of BasicExpr operation, type: BasicExpr
        right_op: right operator of BasicExpr operation, type: BasicExpr,tvm.expr or imm

        Returns
        -----
        left_op: left operator of BasicExpr after processed
        right_op: right operator of BasicExpr after processed
        """
        left_op = self.get()
        if isinstance(right_op, (BasicExpr, _TVM_EXPR_MAP)):
            # left_op and right_op should be BasicExpr
            if isinstance(right_op, BasicExpr):
                right_op = right_op.get()  # Expr to tvm expr

            left_dtype = left_op.dtype
            right_dtype = right_op.dtype

            if left_dtype == right_dtype:
                return left_op, right_op

            # get dtype str and number, eg: "int16" is ["int", "16"]
            a_str_list = [''.join(list(g)) for k, g in groupby(left_dtype, key=lambda x: x.isdigit())]
            b_str_list = [''.join(list(g)) for k, g in groupby(right_dtype, key=lambda x: x.isdigit())]

            # based on src/lang/expr_oprator.cc, when an expr computation is
            # composed of int and float, trans int to float.
            # int->float
            if "float" in left_dtype and "float" not in right_dtype:
                right_op = self.expr_cast(left_dtype, right_op)

            # int->float
            elif "float" not in left_dtype and "float" in right_dtype:
                left_op = self.expr_cast(right_dtype, left_op)

            # int8->uint8
            elif (left_dtype, right_dtype) in [("int8", "uint8"), ("int16", "uint16"),
                                               ("int32", "uint32"), ("int64", "uint64")]:
                left_op = self.expr_cast(right_dtype, left_op)
            elif (right_dtype, left_dtype) in [("int8", "uint8"), ("int16", "uint16"),
                                               ("int32", "uint32"), ("int64", "uint64")]:
                right_op = self.expr_cast(left_dtype, right_op)
            else:  # not raise error when left dtype is different from right. choose larger bitwidth
                if int(a_str_list[1]) >= int(b_str_list[1]):
                    right_op = self.expr_cast(left_dtype, right_op)
                else:
                    left_op = self.expr_cast(right_dtype, left_op)
            return left_op, right_op
        # left: expr, right: imm
        if 'int' in left_op.dtype and isinstance(right_op, float) and right_op % 1 != 0:
            right_op = tvm.const(right_op, 'float32')
        else:
            right_op = tvm.const(right_op, left_op.dtype)
        return left_op, right_op

    def _add(self, other):
        left_op, othert = self.change_dtype_of_expr_op(other)
        # here self.get() + othert.get() return tvm BinaryOpNode.Add
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.Add(left_op, othert))

    def _sub(self, other):
        left_op, othert = self.change_dtype_of_expr_op(other)
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.Sub(left_op, othert))

    def _rsub(self, other):
        left_op, othert = self.change_dtype_of_expr_op(other)
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.Sub(othert, left_op))

    def _mul(self, other):
        left_op, othert = self.change_dtype_of_expr_op(other)
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.Mul(left_op, othert))

    def _div(self, other):
        left_op, othert = self.change_dtype_of_expr_op(other)
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.Div(left_op, othert))

    def _rdiv(self, other):
        left_op, othert = self.change_dtype_of_expr_op(other)
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.Div(othert, left_op))

    def _mod(self, other):
        left_op, othert = self.change_dtype_of_expr_op(other)
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.Mod(left_op, othert))

    def _rmod(self, other):
        left_op, othert = self.change_dtype_of_expr_op(other)
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.Mod(othert, left_op))

    def _lshift(self, other):
        """left shift operator"""
        othert = Expr(other, self.dtype)
        tmp_node = tvm.call_intrin(self.dtype, "tir.shift_left", self.get(), othert.get())
        return self.class_type(tmp_node)

    def _rshift(self, other):
        """right shift operator"""
        othert = Expr(other, self.dtype)
        tmp_node = tvm.call_intrin(self.dtype, "tir.shift_right", self.get(), othert.get())
        return self.class_type(tmp_node)

    def _lt(self, other):
        """less than comparison"""
        left_op, othert = self.change_dtype_of_expr_op(other)
        self.float_operation_ban([left_op, othert])
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.LT(left_op, othert))

    def _le(self, other):
        """less than or equal comparison"""
        left_op, othert = self.change_dtype_of_expr_op(other)
        self.float_operation_ban([left_op, othert])
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.LE(left_op, othert))

    def _eq(self, other):
        left_op, othert = self.change_dtype_of_expr_op(other)
        self.float_operation_ban([left_op, othert])
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.EQ(left_op, othert))

    def _ne(self, other):
        """not equal comparison"""
        left_op, othert = self.change_dtype_of_expr_op(other)
        self.float_operation_ban([left_op, othert])
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.NE(left_op, othert))

    def _gt(self, other):
        """greater than comparison"""
        left_op, othert = self.change_dtype_of_expr_op(other)
        self.float_operation_ban([left_op, othert])
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.GT(left_op, othert))

    def _ge(self, other):
        """greater than or equal comparison"""
        left_op, othert = self.change_dtype_of_expr_op(other)
        self.float_operation_ban([left_op, othert])
        left_op, othert = check_and_update_dtype_float16(left_op, othert)
        return self.class_type(tvm.tir.GE(left_op, othert))


class Expr(BasicExpr):
    """
    hint:basic expression
    """
    None_value = None

    def __init__(self, expr_, dtype=None):
        """
        class initilalization
        Parameters
        ----------
        expr_:expression data type
        dtype:basic expression data type

        Returns
        ----------
        return:no result
        """
        super(Expr, self).__init__()

        if isinstance(expr_, int):
            self.expr_ = expr_
        elif isinstance(expr_, BasicExpr):
            if dtype is None:
                self.expr_ = expr_.get()
            else:
                self.expr_ = self.expr_cast(dtype, expr_.get())
        elif isinstance(expr_, (np.int8, np.uint8, np.int16, np.uint16, np.int32, np.uint32, np.int64, np.uint64)):
            # if expr_ is LargeUInt, tvm.cast Bitwise operations are involved,
            # Bitwise operations cannot be performed between the np dtype and the int.
            self.expr_ = self._get_expr_int_imm(int(expr_), dtype)
        elif isinstance(expr_, float):
            self._expr_float(dtype, expr_)
        elif isinstance(expr_, _TVM_EXPR_MAP):
            if dtype is None:
                self.expr_ = expr_
            else:
                self.expr_ = self.expr_cast(dtype, expr_)
        elif isinstance(expr_, tvm.expr.Call) and expr_.op.name == "tir.tvm_access_ptr":
            if dtype is None:
                self.expr_ = expr_
            else:
                self.expr_ = self.expr_cast(dtype, expr_)
        else:
            self.expr_ = expr_
        self.class_type = Expr
        self.dtype_in = dtype
        self.get_expr_ = None

    def __hash__(self):
        # don't use hash self.expr_, hash self.expr_ cost more time
        return id(self.expr_)

    @property
    def dtype(self):
        """
        get data type
        Parameters
        ----------

        Returns
        ----------
        return: expression data type
        """
        if isinstance(self.expr_, int):
            if self.dtype_in is None:
                if self.expr_ > MAX_INT64_VALUE or self.expr_ < MIN_INT64_VALUE:
                    return "uint64"
                if self.expr_ > MAX_INT32_VALUE or self.expr_ < MIN_INT32_VALUE:
                    return "int64"
                return "int32"
            return self.dtype_in

        return self.get().dtype

    @staticmethod
    def _get_expr_int_imm(expr_, dtype):
        """
        expr_ is int imm, get expr
        Parameters
        ----------
        expr_: int imm
        dtype: data type

        Returns
        ----------
        return: expr_int
        """
        if dtype is None:
            if expr_ > MAX_INT64_VALUE or expr_ < MIN_INT64_VALUE:
                return tvm.const(expr_, "uint64")
            if expr_ > MAX_INT32_VALUE or expr_ < MIN_INT32_VALUE:
                return tvm.const(expr_, "int64")
            return tvm.const(expr_, "int32")

        return tvm.const(expr_, dtype)

    def get(self):
        """
        get expr return -> expression
        """
        if isinstance(self.expr_, int):
            if self.get_expr_ is None:
                self.get_expr_ = tvm.const(self.expr_, self.dtype)
            return self.get_expr_
        return self.expr_

    def eval_value(self):
        """
        return expression value
        Parameters
        ----------

        Returns
        ----------
        return: expression value

        """
        if isinstance(self.expr_, int):
            return self.expr_
        if isinstance(self.expr_, (tvm.tir.IntImm, tvm.tir.FloatImm)):
            return self.expr_.value
        if is_large_uint(self.expr_):
            return self.expr_.args[1].value << 32 | self.expr_.args[0].value

        tmp_expr = Simplify(self.expr_)
        if isinstance(tmp_expr, (tvm.tir.IntImm, tvm.tir.FloatImm)):
            return tmp_expr.value
        return Expr.None_value

    def _expr_float(self, dtype, expr_):
        """
        if expr is float
        """
        if dtype is None:
            self.expr_ = tvm.const(expr_, "float32")
        else:
            if dtype == "float16":
                expr_ = get_float16_range_value(expr_)
            self.expr_ = tvm.const(expr_, dtype)
