#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_data_move_operation_.py
DESC:     tik data_move related operation api
CREATED:  2021-10-25 14:04:45
MODIFIED: 2021-10-27 14:04:45
"""
from collections import namedtuple
import numpy as np
from tbe import tvm
from tbe.common.platform import scope_ubuf
from tbe.common.platform import scope_gm
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.api.tik_tensor_addr_list import TensorAddrList
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.tik.common.common_util import is_tensor
from tbe.tik.common.common_util import check_extent_overflow
from tbe.tik.common.common_util import is_tensor_addr_list
from tbe.tik.common.common_util import set_tensor_addr_list_valid_idx
from tbe.tik.common.common_util import check_tensor_addr_list_valid_idx
from tbe.tik.common.expr_bound_analyzer import analysis_args_check_overflow
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import TikUtil
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_compatible_blk_size
from tbe.tik.debug.data_move_decorators import datamove_decorator
from tbe.tik.debug.data_move_decorators import dma_dquant_decorator
from tbe.tik.debug.data_move_decorators import mov_pad_decorator
from tbe.tik.debug.data_move_decorators import mov_nd2nz_decorator
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_util import type_convert
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import PIPE_MTE3
from tbe.tik.tik_lib.tik_params import PIPE_MTE2
from tbe.tik.tik_lib.tik_params import PIPE_S
from tbe.tik.tik_lib.tik_params import SCALE_ADDR_BIT_POS
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import CONV_RELU_VECTOR_QUANT
from tbe.tik.tik_lib.tik_params import CONV_RELU_QUANT
from tbe.tik.tik_lib.tik_params import BYTE_SIZE
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_ub_to_ub import data_move_vec_ub_to_ub
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import FROM_TENSOR_TO_TENSOR
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import FROM_TENSORADDRLIST_TO_TENSORADDRLIST
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import FROM_TENSORADDRLIST_TO_TENSOR
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import FROM_TENSOR_TO_TENSORADDRLIST
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import calculate_extent
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import get_scope_str
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_check import DataMoveCheck


def _extend_args(param_key, args, argv):
    """
    extend args

    Parameters
    ----------
    param_key : param name
    args : to extend args
    argv : to extend args

    Returns
    -------
    the extended args
    """
    if args:
        if argv:
            TikCheckUtil.raise_error("argv should be None")
        TikCheckUtil.check_equality(len(args), 1, "args length should be 1")
        return args
    if argv:
        if not ((len(argv.keys()) == 1) and (argv.get(param_key))):
            TikCheckUtil.raise_error("argv value error")
        TikCheckUtil.check_type_match(
            argv.get(param_key), (int, bool), "argv value of %s should be int or bool" % param_key)
        return [argv.get(param_key)]
    return [0]


def _get_key_and_e_args(src_key_str, dst_key_str, dma_ins):
    """
    get extent args
    Parameters
    ----------
    src_key_str: src key string
    dst_key_str: dst key string
    dma_ins: data move class ins

    Returns
    -------
    key, e_args
    """
    key = src_key_str + " " + dst_key_str
    if key == "OUT L1":
        e_args = _extend_args("PadMode", dma_ins.args, dma_ins.argv)
    elif key in ["UB L0C", "L0C UB"]:
        e_args = _extend_args("ConvReluMode", dma_ins.args, dma_ins.argv)
    elif is_tensor_addr_list(dma_ins.src) and src_key_str == "UB" and dst_key_str == "L1":
        e_args = _extend_args("PadMode", dma_ins.args, dma_ins.argv)
    else:
        e_args = []

    return key, e_args


def _create_access_ptr(ins, dtype, tensor):
    if isinstance(tensor.data, int) and ins.tik_instance.tensor_addr_list_valid_idx.get(tensor.buffer):
        check_tensor_addr_list_valid_idx(tensor.data,
                                         ins.tik_instance.tensor_addr_list_valid_idx.get(tensor.buffer),
                                         tensor.buffer.name)
    addr = ins.tik_instance.Scalar(tensor.dtype)
    with ins.tik_instance.new_scope():
        addr.set_as(tensor)
    return addr.as_tensor_ptr(dtype, tensor)


def get_access_ptr(tik_ins, key, src_key_str, dst_key_str, gap_ls):
    dst_gap, src_gap, spec_byte_size = gap_ls
    scope_str = get_scope_str("", tik_ins.src, tik_ins.dst)
    burst = tik_ins.burst
    if tik_ins.name == "data_move_pad" and dst_key_str == "UB" and src_key_str == "OUT":
        burst = (tik_ins.burst + 31) // 32 * 32
    dst_access_ptr = tik_ins.dst.access_ptr("w", extent=calculate_extent(
        scope_str, tik_ins.src, [tik_ins.nburst, burst, dst_gap, spec_byte_size,
                                 tik_ins.name, tik_ins.dst.scope], False))

    src_access_ptr = tik_ins.src.access_ptr("r", extent=calculate_extent(
        scope_str, tik_ins.src, [tik_ins.nburst, tik_ins.burst, src_gap, spec_byte_size,
                                 tik_ins.name, tik_ins.src.scope], True))
    if tik_ins.data_move_mode == FROM_TENSOR_TO_TENSORADDRLIST:
        key = "%s OUT" % src_key_str
        dst_access_ptr = _create_access_ptr(tik_ins, tik_ins.src.dtype, tik_ins.dst)
    elif tik_ins.data_move_mode == FROM_TENSORADDRLIST_TO_TENSOR:
        key = "OUT %s" % dst_key_str
        src_access_ptr = _create_access_ptr(tik_ins, tik_ins.dst.dtype, tik_ins.src)
    return key, src_access_ptr, dst_access_ptr


class DataMoveApi(TikIRBuilder):
    """
    DataMove Ops
    """

    def __init__(self, tik_instance, dm_api, args, argv):
        super().__init__()
        self.name = "data_move"
        self.tik_instance = tik_instance
        self.src = dm_api.src
        self.dst = dm_api.dst
        self.sid = dm_api.sid
        self.nburst = dm_api.nburst
        self.burst = dm_api.burst
        self.src_stride = dm_api.src_stride
        self.dst_stride = dm_api.dst_stride
        self.args = args
        self.argv = argv
        self.data_move_mode = self.get_data_move_mode()
        self.check = DataMoveCheck(dm_api, 'data_move')
        self.for_var = set()
        self.block_size = get_compatible_blk_size()

    def get_data_move_mode(self):
        """
        get data_move mode
        """
        if is_tensor(self.src) and is_tensor(self.dst):
            data_move_mode = FROM_TENSOR_TO_TENSOR
        elif is_tensor_addr_list(self.src) and is_tensor_addr_list(self.dst):
            data_move_mode = FROM_TENSORADDRLIST_TO_TENSORADDRLIST
        elif is_tensor_addr_list(self.src) and is_tensor(self.dst):
            data_move_mode = FROM_TENSORADDRLIST_TO_TENSOR
        elif is_tensor(self.src) and is_tensor_addr_list(self.dst):
            data_move_mode = FROM_TENSOR_TO_TENSORADDRLIST
        else:
            data_move_mode = None

        return data_move_mode

    def code_gen(self, dma_list):
        """
        data move code gen
        Parameters
        ----------
        dma_list: dma list

        Returns
        -------

        """
        src_key_str = TikUtil.get_storage_scope(self.src.scope)
        dst_key_str = TikUtil.get_storage_scope(self.dst.scope)
        key, e_args = _get_key_and_e_args(src_key_str, dst_key_str, self)
        if TikSocManager.is_310b_610l_soc():
            soc_name = get_soc_name()
            TikCheckUtil.check_not_equality(
                src_key_str, "L0C",
                "%s: data_move doesn't support L1OUT to UB, Please using the fixpipe api." % soc_name)
            TikCheckUtil.check_not_equality(
                dst_key_str, "L0C", "%s: data_move doesn't support UB to L1OUT." % soc_name)
        TikCheckUtil.check_not_is(dma_list.get(key), None,
                                  "data_move doesn't support %s to %s" % (src_key_str, dst_key_str))
        spec_byte_size = None
        with self.tik_instance.context.freeze():
            is_all_tensor = all(isinstance(t, Tensor) for t in (self.dst, self.src))
            is_all_ub = all(t.scope == scope_ubuf for t in (self.dst, self.src))
            is_v200_vec = TikSocManager.is_v200_soc() and TikSocManager.is_vector_core()
            if is_all_tensor and is_v200_vec and is_all_ub:
                data_move_vec_ub_to_ub(self.tik_instance, self)

            elif self.src.dtype != "int32" or self.dst.dtype != "float16":
                key, src_access_ptr, dst_access_ptr = get_access_ptr(
                    self, key, src_key_str, dst_key_str, [self.dst_stride, self.src_stride, spec_byte_size])
                with self.tik_instance.new_scope():
                    if TikSocManager.is_310b_610l_soc() and\
                            self.src.scope == scope_ubuf and self.dst.scope == scope_ubuf:
                        self.tik_instance.add_source_id()
                    pipe_line, intrin_name = dma_list.get(key)
                    self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", pipe_line)
                    instr = tvm.call_extern(
                        self.dst.dtype, intrin_name, dst_access_ptr, src_access_ptr,
                        *(type_convert([self.sid, self.nburst, self.burst, self.src_stride, self.dst_stride]
                                       + list(e_args))))
                    # one ir is call_extern
                    self.tik_instance.emit(instr)

    @source_info_decorator(depth=2)
    @datamove_decorator
    def run_all(self):
        """
        data_move run all
        """
        dma_list = {
            "L0C UB": (2, 'copy_matrix_cc_to_ubuf'),  # V
            "UB L0C": (2, 'copy_matrix_ubuf_to_cc'),  # special
            "UB UB": (2, 'copy_ubuf_to_ubuf'),
            "L1 UB": (4, 'copy_cbuf_to_ubuf'),
            "OUT L1": (5, 'copy_gm_to_cbuf'),  # LSU2
            "OUT UB": (5, 'copy_gm_to_ubuf'),
            "UB OUT": (6, 'copy_ubuf_to_gm'),  # LSU3
            "UB L1": (6, 'copy_ubuf_to_cbuf'),
            "L1 OUT": (6, 'copy_cbuf_to_gm')
        }
        # set atomic_add_value
        TikCheckUtil.check_atomic_add(self.tik_instance.atomic_add_value, self.dst)

        # check inputs params
        self.check.check_all()
        analysis_args_check_overflow(self)

        # set tensor_addr_list_valid_idx
        if self.data_move_mode == 1 and self.dst.scope == scope_ubuf:
            if isinstance(self.dst.data, int) and isinstance(self.nburst, int) and isinstance(self.burst, int):
                set_tensor_addr_list_valid_idx(self.tik_instance.tensor_addr_list_valid_idx,
                                               int(self.dst.data), self.dst.buffer,
                                               self.nburst * self.burst * self.block_size)

        # tiling_gm to tiling_ub
        if self.data_move_mode == FROM_TENSOR_TO_TENSOR and self.src._get_last_tensor().is_tiling_tensor and \
                self.dst.scope == scope_ubuf and self.src.scope == scope_gm:
            # only deal when index of dst and src are const value
            if isinstance(self.dst.old_data, int) and isinstance(self.src.old_data, int):
                dst_last = self.dst._get_last_tensor()
                tiling_gm_addr = self.src.old_data * DTYPE_SIZE[self.src.dtype]
                tiling_ub_addr = self.dst.old_data * DTYPE_SIZE[self.dst.dtype]
                self.tik_instance.tiling_addr_map[dst_last.name] = [tiling_gm_addr, tiling_ub_addr]
                dst_last.is_tiling_tensor = True
                self.tik_instance._has_tiling_ub = True

        is_all_tensor_addr_list = all(is_tensor_addr_list(t) for t in (self.src, self.dst))
        if is_all_tensor_addr_list and (self.src.is_value is True or self.dst.is_value is True):
            TikCheckUtil.raise_error("data_move doesn't support OUT to OUT")
        src_key_str = TikUtil.get_storage_scope(self.src.scope)
        dst_key_str = TikUtil.get_storage_scope(self.dst.scope)
        key = src_key_str + " " + dst_key_str
        if TikSocManager.is_610l_soc() and key in ("UB OUT", "OUT UB", "L1 OUT"):
            if self.src.dtype != self.dst.dtype:
                self.src = self.src.reinterpret_cast_to(self.dst.dtype)
            self._compatible_v310_data_move(src_key_str, dst_key_str)
        else:
            self.code_gen(dma_list)

    def _compatible_v310_data_move(self, src_key_str, dst_key_str):
        """
        v310 aic data move not support ub2out out2ub l12out, so call data_move_pad to be compatible.
        Parameters
        ----------
        src_key_str: src scope str
        dst_key_str: dst scope str

        Returns
        -------
        None
        """
        data_move_pad_api = namedtuple('DataMovePadApi',
                                       ['dst', 'src', 'nburst', 'burst', 'dst_gap', 'src_gap',
                                        'right_padding', 'left_padding', 'padding_value'])

        right_padding = 0
        left_padding = 0
        padding_value = None
        block_size_num = 32
        if src_key_str == "OUT":
            src_gap = self.src_stride * block_size_num
        else:
            src_gap = self.src_stride
        if dst_key_str == "OUT":
            dst_gap = self.dst_stride * block_size_num
        else:
            dst_gap = self.dst_stride
        # 610l data move pad not support b64, so dst src need to convert the type
        if self.dst.dtype in ("int64", "uint64"):
            self.dst = self.dst.reinterpret_cast_to("int32")
            self.src = self.src.reinterpret_cast_to("int32")
        dmp_api = data_move_pad_api(self.dst, self.src,
                                    self.nburst,
                                    self.burst * block_size_num, dst_gap, src_gap,
                                    right_padding, left_padding, padding_value)
        dmp_obj = DataMovePadApi(self.tik_instance, dmp_api)
        # The mapping name uses data_mov_pad because some logic takes effect only for pads.
        dmp_obj.name = "data_move_pad"
        # Use data_move as the name of the exception check to facilitate location.
        dmp_obj.check.name = self.name
        dmp_obj.run_all()


class DataMoveQuantApi(TikIRBuilder):
    """
    Move tensor from tik.cbuf to tik.ubuf
    """

    def __init__(self, tik_instance, dmq_obj):
        super().__init__()
        self.tik_instance = tik_instance
        self.src = dmq_obj.src
        self.dst = dmq_obj.dst
        self.sid = dmq_obj.sid
        self.nburst = dmq_obj.nburst
        self.burst = dmq_obj.burst
        self.src_stride = dmq_obj.src_stride
        self.dst_stride = dmq_obj.dst_stride
        self.quant_param = dmq_obj.quant_param
        self.relu_flag = dmq_obj.relu_flag
        self.check = DataMoveCheck(dmq_obj)

    def cheak_all(self):
        """
        check all params
        Returns
        -------
        no return
        """
        TikCheckUtil.check_not_is(TikSocManager.is_vector_core(), True, "VectorCore not support data_move_quant.")
        self.check.check_all()

    @source_info_decorator(depth=2)
    @dma_dquant_decorator
    def run_all(self):
        """
        deta_move_quant api run_all
        """
        self.cheak_all()
        if isinstance(self.quant_param, Tensor):
            cr_mode = self._dma_quant_set_deqscale_tensor()
        else:
            cr_mode = CONV_RELU_QUANT  # 3
            with self.new_scope():
                self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
                self.tik_instance.emit(tvm.call_extern("float16", "set_deqscale", self.quant_param))
        with self.new_scope():
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            args = type_convert([self.sid, self.nburst, self.burst, self.src_stride, self.dst_stride, cr_mode])
            scope_str = get_scope_str("", self.src, self.dst)
            instr = tvm.call_extern(self.dst.dtype, "copy_matrix_cc_to_ubuf",
                                    self.dst.access_ptr("w", extent=calculate_extent(
                                        scope_str, self.src, [self.nburst, self.burst, self.dst_stride], False)),
                                    self.src.access_ptr("r", extent=calculate_extent(
                                        scope_str, self.src, [self.nburst, self.burst, self.src_stride], True)),
                                    *args)
            self.tik_instance.emit(instr)

    def _dma_quant_set_deqscale_tensor(self):

        cr_mode = CONV_RELU_VECTOR_QUANT  # 7
        with self.tik_instance.context.freeze():
            scale_addr = self.tik_instance.scalar_(dtype="int64")
            # lsb: 32B
            self.tik_instance.emit(tvm.call_extern(scale_addr.dtype, "reg_set", scale_addr.get(),
                                                   tvm.expr.Cast("int64", self.quant_param.access_ptr("r")) //
                                                   BYTE_SIZE))
            if self.relu_flag:
                scale_addr.set_as(scale_addr | (1 << SCALE_ADDR_BIT_POS - 1))
            with self.new_scope():
                self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
                self.tik_instance.emit(
                    tvm.call_extern("float16", "set_deqscale",
                                    tvm.call_intrin("float16", "tir.reinterpret", scale_addr.get())))
        return cr_mode


class DataMovePadApi(TikIRBuilder):
    """
    DataMovePadApi class
    """
    data_move_params = namedtuple(
        'DataMoveParams', ['tik_instance', 'for_var', 'dst', 'src', 'nburst', 'burst', 'dst_stride'])

    def __init__(self, tik_instance, dmp_obj):
        super(DataMovePadApi, self).__init__()
        self.name = "data_move_pad"
        self.tik_instance = tik_instance
        self.dst = dmp_obj.dst
        self.src = dmp_obj.src
        self.nburst = dmp_obj.nburst
        self.burst = dmp_obj.burst
        self.dst_gap = dmp_obj.dst_gap
        self.src_gap = dmp_obj.src_gap
        self.right_padding = dmp_obj.right_padding
        self.left_padding = dmp_obj.left_padding
        self.padding_value = dmp_obj.padding_value
        self.check = DataMoveCheck(self, 'data_move_pad')
        self.for_var = set()
        self.block_size = get_compatible_blk_size()
        self.data_move_mode = self.get_data_move_mode()

    @source_info_decorator(depth=2)
    @mov_pad_decorator
    def run_all(self):
        """
        data_move_pad run_all
        """
        TikCheckUtil.check_atomic_add(self.tik_instance.atomic_add_value, self.dst)

        self.check.check_mov_pad_tensor_dtype()
        key = self.get_mov_pad_instr_key()
        self.check.check_mov_pad_instr_params()

        self._check_overflow()
        data_move_quant_api_ins = self.data_move_params(self.tik_instance, self.for_var, self.dst,
                                                        self.src, self.nburst, self.burst, self.dst_gap)
        analysis_args_check_overflow(data_move_quant_api_ins)

        with self.tik_instance.context.freeze():
            # check padding value
            with self.tik_instance.new_scope():
                if self.padding_value is not None:
                    self._set_padding_value_val()
            src_key_str = TikUtil.get_storage_scope(self.src.scope)
            dst_key_str = TikUtil.get_storage_scope(self.dst.scope)
            spec_byte_size = 1
            with self.tik_instance.new_scope():
                key, src_access_ptr, dst_access_ptr = get_access_ptr(
                    self, key, src_key_str, dst_key_str, [self.dst_gap, self.src_gap, spec_byte_size])
                pipe_line, intrin_name, type_args = self._gen_intrin_infos(key)
                self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", pipe_line)
                instr = tvm.call_extern(
                    self.dst.dtype, intrin_name,
                    dst_access_ptr,
                    src_access_ptr,
                    *(type_convert(type_args)))
                # one ir is call_extern
                self.tik_instance.emit(instr)

    def get_data_move_mode(self):
        """
        get data_move mode
        """
        if is_tensor(self.src) and is_tensor(self.dst):
            data_move_mode = FROM_TENSOR_TO_TENSOR
        elif is_tensor_addr_list(self.src) and is_tensor_addr_list(self.dst):
            data_move_mode = FROM_TENSORADDRLIST_TO_TENSORADDRLIST
        elif is_tensor_addr_list(self.src) and is_tensor(self.dst):
            data_move_mode = FROM_TENSORADDRLIST_TO_TENSOR
        elif is_tensor(self.src) and is_tensor_addr_list(self.dst):
            data_move_mode = FROM_TENSOR_TO_TENSORADDRLIST
        else:
            data_move_mode = None

        return data_move_mode

    def _gen_intrin_infos(self, scope_key):
        sid = 0
        # current don't distinguish VEC and AIC
        if TikSocManager.is_910b_soc() or TikSocManager.is_v300_610l_soc():
            mov_pad_list = {
                "UB OUT": (PIPE_MTE3, "copy_ubuf_to_gm_align"),
                "OUT UB": (PIPE_MTE2, "copy_gm_to_ubuf_align")
            }
            type_args = [sid, self.nburst, self.burst, self.left_padding, self.right_padding,
                         self.src_gap, self.dst_gap]
        else:
            mov_pad_list = {
                "UB OUT": (PIPE_MTE3, "copy_ubuf_to_gm_pad"),
                "OUT UB": (PIPE_MTE2, "copy_gm_to_ubuf_pad")
            }
            type_args = [sid, self.nburst, self.burst, self.src_gap, self.dst_gap, self.left_padding,
                         self.right_padding]
        if TikSocManager.is_610l_soc():
            mov_pad_list.update({
                "L1 OUT": (PIPE_MTE3, "copy_cbuf_to_gm_align"),
                "OUT L1": (PIPE_MTE2, "copy_gm_to_cbuf_align")
            })
        self.check.check_inter_key(scope_key, mov_pad_list)
        if isinstance(self.dst, TensorAddrList):
            scope_key = "UB OUT"
        elif isinstance(self.src, TensorAddrList):
            scope_key = "OUT UB"
        pipe_line, intrin_name = mov_pad_list[scope_key]
        if not TikSocManager.is_v300_610l_soc():
            if DTYPE_MAP[self.dst.dtype] in ["u8", "s8"]:
                intrin_name = intrin_name + "_b8"
            elif DTYPE_MAP[self.dst.dtype] in ["u16", "s16", "f16", "bf16"]:
                intrin_name = intrin_name + "_b16"
            else:
                intrin_name = intrin_name + "_b32"
        else:
            if scope_key in ["UB OUT", "L1 OUT"]:
                type_args = [sid, self.nburst, self.burst, self.src_gap, self.dst_gap]
        return pipe_line, intrin_name, type_args

    def get_mov_pad_instr_key(self):
        """
        get key for data_move_pad_check_all
        """
        src_key_str = TikUtil.get_storage_scope(self.src.scope)
        dst_key_str = TikUtil.get_storage_scope(self.dst.scope)
        key = src_key_str + " " + dst_key_str
        return key

    def get_mov_pad_tensor_extent(self, is_src=False):
        """
        cla tensor extent
        """
        if is_src:
            stride = self.src_gap
            tensor = self.src
            burst_len = self.burst
        else:
            stride = self.dst_gap
            tensor = self.dst
            burst_len = self.burst + (self.left_padding + self.right_padding) * DTYPE_SIZE[tensor.dtype]

        tensor_scope = TikUtil.get_storage_scope(tensor.scope)
        if tensor_scope == "UB":
            gap_b_size = self.block_size
            gap_t_size = (self.nburst - 1) * stride * gap_b_size
            # if UB->OUT, a burst needs read ((burst  1)/block_size + 1)*block_size Bytes data.
            burst_len_align = ((burst_len - 1) // gap_b_size) + 1
            extent = Expr(self.nburst * burst_len_align * gap_b_size + gap_t_size)
        else:
            extent = Expr(self.nburst * self.burst + (self.nburst - 1) * stride)
        return extent

    def _check_overflow(self):
        """
        check overflow
        Returns dst src extent
        """
        dst_extent = self.get_mov_pad_tensor_extent()
        src_extent = self.get_mov_pad_tensor_extent(is_src=True)
        dst_offset = Expr(self.dst.offset).eval_value()
        src_offset = Expr(self.src.offset).eval_value()
        # The 610lite data move instruction is implemented through the data move pad,
        # and overflow interception is not required.
        if not (TikSocManager.is_610l_soc() and self.check.name in ("data_move", "tensor_mov")):
            if isinstance(self.dst, Tensor):
                check_extent_overflow(self.dst, dst_extent.eval_value(), dst_offset, "dst")
            if isinstance(self.src, Tensor):
                check_extent_overflow(self.src, src_extent.eval_value(), src_offset, "src")

    def _set_padding_value_val(self):
        pad_value = self.padding_value
        if self.dst.dtype == "float32":
            pad_value = np.float32(self.padding_value)
            pad_value = pad_value.view(np.uint32)
        elif self.dst.dtype == "float16":
            pad_value = np.float16(self.padding_value)
            pad_value = pad_value.view(np.uint16)
        elif self.dst.dtype == "bfloat16":
            pad_value = np.float32(self.padding_value)
            pad_value = pad_value.view(np.uint32) >> 16
        self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_S)
        self.tik_instance.emit(tvm.call_extern("int64", "set_mov_pad_val", pad_value))


class DataMoveMultiNd2NzApi(TikIRBuilder):
    """
    Move tensor from tik.gm to tik.l1
    """
    def __init__(self, tik_instance, dmq_obj):
        super().__init__()
        self.tik_instance = tik_instance
        self.sid = 0
        self.dst = dmq_obj.dst
        self.src = dmq_obj.src
        self.nd_num = dmq_obj.nd_num
        self.nd_n = dmq_obj.nd_n
        self.nd_d = dmq_obj.nd_d
        self.src_nd_stride = dmq_obj.src_nd_stride
        self.src_n_stride = dmq_obj.src_n_stride
        self.dst_c0_stride = dmq_obj.dst_c0_stride
        self.dst_n_stride = dmq_obj.dst_n_stride
        self.dst_nd_stride = dmq_obj.dst_nd_stride
        self.check = DataMoveCheck(dmq_obj, 'data_move_multi_nd2nz')

    @source_info_decorator(depth=2)
    @mov_nd2nz_decorator
    def run_all(self):
        """
        deta_move_quant api run_all
        """
        self.check.check_all()
        instr_list = {
            1: "copy_gm_to_cbuf_multi_nd2nz_b8",
            2: "copy_gm_to_cbuf_multi_nd2nz_b16",
            4: "copy_gm_to_cbuf_multi_nd2nz_b32s",
        }
        instr_name = instr_list[DTYPE_SIZE[self.src.dtype]]

        with self.new_scope():
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_MTE2)
            args = type_convert([self.sid, self.nd_num, self.nd_n, self.nd_d, self.src_nd_stride, self.src_n_stride,
                                 self.dst_c0_stride, self.dst_n_stride, self.dst_nd_stride])
            instr = tvm.call_extern(
                self.dst.dtype, instr_name,
                self.dst.access_ptr("w", extent=self._calculate_extent_nz(args)),
                self.src.access_ptr("r", extent=self._calculate_extent_multi_nd(args)),
                *args)
            self.tik_instance.emit(instr)

    def _calculate_extent_nz(self, args):
        """
        calculate extent of multi nd matrix
        :param args: args
        :return: extent
        """
        _, nd_num, nd_n, nd_d, _, _, dst_c0_stride, dst_n_stride, dst_nd_stride = args
        # Byte
        c0_size = 32
        dtype_bytes = DTYPE_SIZE[self.dst.dtype]
        c0 = c0_size // dtype_bytes
        c0_num = Expr((nd_d + c0 - 1) // c0).get()
        extent = Expr((nd_num - 1) * dst_nd_stride * dtype_bytes +
                      (nd_n - 1) * dst_n_stride * c0_size +
                      (c0_num - 1) * dst_c0_stride * c0_size +
                      c0_size).get()
        return extent

    def _calculate_extent_multi_nd(self, args):
        """
        calculate extent of multi nd matrix
        :param args: args
        :return: extent
        """
        _, nd_num, nd_n, nd_d, src_nd_stride, src_n_stride, _, _, _ = args
        # Byte
        dtype_bytes = DTYPE_SIZE[self.src.dtype]
        extent = Expr((nd_num - 1) * src_nd_stride * dtype_bytes +
                      (nd_n - 1) * src_n_stride * dtype_bytes +
                      nd_d * dtype_bytes).get()
        return extent
