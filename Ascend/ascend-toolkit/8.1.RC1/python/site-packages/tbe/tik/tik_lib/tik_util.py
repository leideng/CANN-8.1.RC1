#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_util.py
DESC:     util file for tik
CREATED:  2019-04-18 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""
from __future__ import print_function

from tbe import tvm
from tbe.tvm.tir import IntImm
from tbe.tvm.tir import Evaluate

from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import is_immediate_number
from tbe.tik.tik_lib.tik_params import MIN_RET
from tbe.tik.tik_lib.tik_params import SIX_STRIDE_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import SIX_STRIDE_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import FOUR_STRIDE_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import FOUR_STRIDE_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import THREE_STRIDE_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import THREE_STRIDE_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import TWO_STRIDE_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import TWO_STRIDE_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import PIPE_S
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import DEQSCALE_46BIT_MASK
from tbe.tik.tik_lib.tik_params import DEQSCALE_46BIT_SHIFT_POS
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import FOUR_STRIDE
from tbe.tik.tik_lib.tik_params import SIX_STRIDE
from tbe.tik.tik_lib.tik_params import THREE_STRIDE
from tbe.tik.tik_lib.tik_params import TWO_STRIDE
from tbe.tik.tik_lib.tik_params import MAX_RET
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_expr import BasicExpr


def list_cmp(lhl, rhl):
    """
    two list compare

    Parameters
    ----------
    lhl : compare list
    rhl : be compared list

    Returns
    -------
    return : bool, compare result
    """
    if len(lhl) != len(rhl):
        return False
    for data in zip(lhl, rhl):
        if data[0] != data[1]:
            return False
    return True


def non_stmt_judge(s_value):

    """
    judging whether is Empty Procedure

    Parameters
    ----------
    s_value : string value

    Returns
    -------
    return : bool, judging result

    """
    return (isinstance(s_value, Evaluate) and isinstance(s_value.value, IntImm) and (s_value.value.value == 0))


def warning_info(value_str):
    """
    print warning information

    Parameters
    ----------
    value_str : print warming string

    Returns
    -------
    return : warning information
    """
    print("WARNING:%s" % value_str)


def dtype_convert(value, dtype):
    """
    Get target's scope

    Parameters
    ----------
    name : str, The scope name

    Returns
    -------
    str : the key of scope
    """
    ret = type_convert(value)
    return ret.astype(dtype)


def concat_params(params, offset_list=None, segment_list=None, dtype="int64"):
    """
    concat params
    Parameters
    ----------
    params
    offset_list
    segment_list
    dtype

    Returns
    -------
    convert(Expr)
    """
    # disable it because it's to support python3
    if offset_list is None:
        offset_list = [1]*len(params)
    if segment_list is None:
        segment_list = [1]*len(params)
    TikCheckUtil.check_equality(len(params), len(offset_list))
    TikCheckUtil.check_equality(len(params), len(segment_list))
    py_value = Expr(0, dtype)
    tvm_value = Expr(0, dtype)
    for (value, offset, segment) in zip(params, offset_list, segment_list):
        TikCheckUtil.check_type_match(offset, int)
        TikCheckUtil.check_type_match(segment, int)
        if isinstance(offset, int):
            if isinstance(value, (float, int)):
                py_value |= (value & (2 ** segment - 1)) << offset
            else:
                tvm_value |= (Expr(value).astype(dtype) & (2 ** segment - 1)) << Expr(offset, dtype)
        else:
            offset_v = Expr(offset, dtype)
            if isinstance(value, (float, int)):
                py_value |= Expr((value & (2**segment - 1)), dtype) << offset_v
            else:
                tvm_value |= (Expr(value).astype(dtype) & (2**segment - 1)) << Expr(offset, dtype)
    return type_convert(Expr(py_value, dtype) | tvm_value)


def vector_config_encoding(repeat_times, strides):
    """
    [dst_blk_stride, src0_blk_stride, src1_blk_stride, dst_rep_stride, src0_rep_stride, src1_rep_stride]
    """
    # disable it because it's to support python3
    # [dst_blk_stride, src0_blk_stride, src1_blk_stride,
    #     dst_rep_stride, src0_rep_stride, src1_rep_stride]
    if len(strides) == SIX_STRIDE:
        args = list(strides) + [repeat_times]
        offset_list = SIX_STRIDE_OFFSET_LIST
        segment_list = SIX_STRIDE_SEGMENT_LIST
        ret = concat_params(args, offset_list, segment_list)
    # the variable ret is [dst_blk_stride, src_blk_stride, dst_rep_stride, src_rep_stride]
    elif len(strides) == FOUR_STRIDE:
        args = list(strides) + [repeat_times]
        offset_list = FOUR_STRIDE_OFFSET_LIST
        segment_list = FOUR_STRIDE_SEGMENT_LIST
        ret = concat_params(args, offset_list, segment_list)
    # the variable ret is [dst_rep_stride, src_blk_stride, src_rep_stride]/[dst_rep_stride,
    # src0_rep_stride, src1_rep_stride]
    elif len(strides) == THREE_STRIDE:
        args = list(strides) + [repeat_times]
        offset_list = THREE_STRIDE_OFFSET_LIST
        segment_list = THREE_STRIDE_SEGMENT_LIST
        ret = concat_params(args, offset_list, segment_list)
    # the variable ret is [dst_rep_stride, src_rep_stride]
    elif len(strides) == TWO_STRIDE:
        args = list(strides) + [repeat_times]
        offset_list = TWO_STRIDE_OFFSET_LIST
        segment_list = TWO_STRIDE_SEGMENT_LIST
        ret = concat_params(args, offset_list, segment_list)
    else:
        TikCheckUtil.raise_error("only support vector")

    if isinstance(ret, int):
        TikCheckUtil.check_in_range_by_dtype(
            ret, msg="result should be in the range of [%d, %d]" % (MIN_RET, MAX_RET), var_range=[MIN_RET, MAX_RET])
    return ret


def vector_encode_args(self, repeat_times, strides):
    """
    vector encode args
    """
    debug_mode = bool(
        hasattr(self, "debug_mode") and getattr(self, "debug_mode"))
    if debug_mode:
        return [repeat_times] + list(strides)
    return [vector_config_encoding(repeat_times, strides)]


def insert_set_deqscale_attr(tik_instance, deqscale, dtype_str, dst_dtype):
    """
    insert a set deqscale attr in IR
    Parameters
    ----------
    tik_instance: tik object
    deqscale
    dtype_str: string
    dst_dtype: dst data type

    Returns
    -------
    no return
    """
    # If you import at the top of the file, it causes a loop
    if dtype_str == "deq":
        with tik_instance.new_scope():
            tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            tik_instance.emit(
                tvm.call_extern("float16", "set_deqscale", type_convert(Expr(deqscale, dtype="float16"))))
    elif dtype_str == "deqs162b8":
        deq_46 = (deqscale & DEQSCALE_46BIT_MASK) >> DEQSCALE_46BIT_SHIFT_POS
        if dst_dtype == "int8" and is_immediate_number(deqscale):
            # check deqscale[46]: 1
            TikCheckUtil.check_equality(
                deq_46, 1, "deqscale[46] bit should be 1 when converting int16 to int8")
        elif dst_dtype == "uint8" and is_immediate_number(deqscale):
            # check deqscale[46]: 0
            TikCheckUtil.check_equality(
                deq_46, 0, "deqscale[46] bit should be 0 when converting int16 to uint8")
        with tik_instance.new_scope():
            tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            tik_instance.emit(tvm.call_extern(
                "uint64", "set_deqscale", type_convert(Expr(deqscale, dtype="uint64"))))
    elif dtype_str == "vdeqs162b8":
        with tik_instance.context.freeze():
            scale_addr = tik_instance.scalar_("int64")
            set_tensor_addr_to_scalar(tik_instance, scale_addr, deqscale)
            with tik_instance.new_scope():
                tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
                tik_instance.emit(tvm.call_extern(
                    "uint64", "set_deqscale",
                    tvm.call_intrin("int64", "tir.reinterpret", scale_addr.get())))


def set_deqscale_attr_nano(tik_instance, deqscale):
    """
    insert a set deqscale attr in IR for nano soc
    """
    # hardware takes it as in format of 1, 8, 10
    # for computation that is 1 sign bit, 8 exponent bits and 10 mantissa bits.
    if not isinstance(deqscale, BasicExpr):
        deqscale = tik_instance.scalar_("float16", init_value=deqscale)
    temp_deq = tik_instance.scalar_("float32", init_value=deqscale)
    with tik_instance.new_scope():
        tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
        tik_instance.emit(
            # float32 has 23 mantissa bits, nano soc requires 10 bits.
            tvm.call_extern("uint64", "set_deqscale", temp_deq.reinterpret_cast_to("uint32").get() >> 13))


def need_check_out_of_scope(tik_instance):
    """
    if this isn't debug or building cce,tensor or scalar state variable
    should be checked in the scope.
    Parameters
    ----------
    tik_instance: tik obj

    Returns
    -------
    True: tensor or scalar should be checked
    False: tensor or scalar shouldn't be checked
    """
    return not tik_instance.is_in_debug and not tik_instance.is_building_cce


def change_dtype_str(dst):
    """
    change dtype_str based on dtype of dst

    Parameters
    ----------
    dst : destination tensor

    Returns
    -------
    dtype_str
    """
    bit_len = get_bit_len(dst.dtype)
    if bit_len == 8:
        dtype_str = "uint8"
    elif bit_len == 16:
        dtype_str = "uint16"
    else:
        dtype_str = "uint32"

    return dtype_str


def emit_scatter_instr(tik_instance, instr_block):
    """
    emit scatter instruction

    Parameters
    ----------
    tik_instance: tik object
    instr_block: instruction stmt block

    Returns
    -------
    orig_ctrl: original value of CTRL
    """
    tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
    tik_instance.scope_attr(tvm.thread_axis("cce"), "mem_access_scope",
                            tvm.call_cce_pure_intrin("int64", "__dummy__", "VA_reg_set"))
    tik_instance.emit(instr_block)


def set_tensor_addr_to_scalar(tik_instance, scale_addr, tensor):
    """
    set tensor addr to scalar, for set_deqscale

    Parameters
    ----------
    tik_instance: tik instance
    scale_addr: int64 scalar, src of set_deqscale
    tensor: input tensor

    Returns
    -------
    scale_addr: scalar stored tensor addr
    """
    with tik_instance.new_scope():
        tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_S)
        tmp_const = tvm.const(ONE_BLK_SIZE, "int64")
        tmp_cast = tvm.tir.Cast("int64", tvm.call_extern("handle", "", tensor.access_ptr("r")))
        scale_addr.set_as(tmp_cast // tmp_const)
