#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     intrinsic_v210_common.py
DESC:     v210 class common var
CREATED:  2021-11-24 15:58
MODIFIED: 2021-11-24 15:58
"""
import copy
import math
import numpy as np
from tbe.tik.api.tik_vector import Vector
from tbe.common.platform import scope_preg
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import WDTYPE_TO_DTYPE
from tbe.tik.debug.util import cvt_float_to_uint
from tbe.tik.common.common_util import is_predicate
from tbe.tik.tik_lib.tik_params import VL_T_MAP
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager

FIFR1_TYPE = {
    'uint8': 0b00,
    'int8': 0b01,
    'uint16': 0b10,
    'int16': 0b11
}

VLOOPN_TYPE = {
    'uint8': 0b000,
    'int8': 0b000,
    'uint16': 0b001,
    'int16': 0b001,
    'float16': 0b001,
    'uint32': 0b010,
    'int32': 0b010,
    'float32': 0b010,
    'int64': 0b11,
    'uint64': 0b11,
    'float64': 0b11,
}

VEC_TYPE_BITS = {
    'uint8': 0b00,
    'int8': 0b00,
    'uint16': 0b01,
    'int16': 0b01,
    'float16': 0b01,
    'bfloat16': 0b01,
    'uint32': 0b10,
    'int32': 0b10,
    'float32': 0b10
}

VMADD_TYPE_BITS = {
    'float16': 0b10,
    'float32': 0b11
}

VAVG_TYPE_BITS = {
    "uint8": 0b00,
    "int8": 0b01,
    "uint16": 0b10,
    "int16": 0b11
}

VCI_TYPE_BITS = {
    'int8': 0b11,
    'int16': 0b00,
    'int32': 0b01,
    'float16': 0b10,
    'float32': 0b11
}

VRND_VRNDS_TYPE_BITS = {
    'int16': 0b10,
    'int32': 0b11,
}

VEC_SCALAR_ELEWISE_TYPE_BITS = {
    "int16": 0b10,
    "float16": 0b10,
    "int32": 0b11,
    "float32": 0b11,
}

VEC_TYPE_THREE_BITS = {
    'uint8': 0b000,
    'int8': 0b001,
    'uint16': 0b010,
    'int16': 0b011,
    'uint32': 0b100,
    'int32': 0b101,
    'float16': 0b110,
    'float32': 0b111
}

WIDE_TYPE_THREE_BITS = {
    'vectorized_wadd': 0b000,
    'vectorized_wadda': 0b100,
    'vectorized_waddsub': 0b000,
    'vectorized_wsub_int8': 0b000,
    'vectorized_wsub_int16': 0b001,
    'vectorized_wsuba_int8': 0b010,
    'vectorized_wsuba_int16': 0b011,
    'vectorized_wsub_uint8': 0b000,
    'vectorized_wsub_uint16': 0b001,
    'vectorized_wsuba_uint8': 0b010,
    'vectorized_wsuba_uint16': 0b011,
}

WIDE_VD_INDEX_BITS = {
    'vectorized_wadd': 0b00000,
    'vectorized_wadda': 0b00000,
    'vectorized_waddsub': 0b10000,
    'vectorized_wsub_int8': 0b01000,
    'vectorized_wsub_int16': 0b01000,
    'vectorized_wsuba_int8': 0b01000,
    'vectorized_wsuba_int16': 0b01000,
    'vectorized_wsub_uint8': 0b11000,
    'vectorized_wsub_uint16': 0b11000,
    'vectorized_wsuba_uint8': 0b11000,
    'vectorized_wsuba_uint16': 0b11000,
}

VPACK_TYPE_BITS = {
    'int16': 0b0,
    'uint16': 0b0,
    'int32': 0b1,
    'uint32': 0b1,
}

VUNPACK_TYPE_BITS = {
    'int8': 0b0,
    'uint8': 0b0,
    'int16': 0b1,
    'uint16': 0b1,
}

LOOP_MODES = {
    'MODE_MERGING': 0,
    'MODE_ZEROING': 1
}

V300_VM_IDX = {
    'vectorized_vabs_int': 0,
    'vectorized_vabs_float': 0,
    'vectorized_vrelu': 1,
    'vectorized_vsqz': 0,
    'vectorized_vcadd': 0,
    'vectorized_vnot': 0,
    'vectorized_vneg': 0,
    'vectorized_vcmax': 0,
    'vectorized_vcmin': 0,
    'vectorized_vcls': 0,
    'vectorized_vbcnt': 0,
    'vectorized_vrsqrt': 1,
    'vectorized_vrec': 1,
    'vectorized_vsqrt': 0,
    'vectorized_vln': 0,
    'vectorized_vexp': 0,
}

SOURCE_REGISTER1 = {
    'vectorized_vdup': 0b01100,
    'vectorized_vdupm': 0b11000,
    'vectorized_vbr': 0b00001,
    'vectorized_vci_int8': 0b00001,
    'vectorized_vci_int16': 0b00010,
    'vectorized_vci_int32': 0b00010,
    'vectorized_vci_float16': 0b00010,
    'vectorized_vci_float32': 0b00010,
    'vectorized_vabs': 0b00000,
    'vectorized_vcls': 0b00001,
    'vectorized_vneg': 0b00010,
    'vectorized_vcadd': 0b00011,
    'vectorized_vcmax': 0b00100,
    'vectorized_vcmin': 0b00101,
    "vectorized_vrsqrt": 0b00110,
    "vectorized_vsqrt": 0b00110,
    "vectorized_vrec": 0b00111,
    "vectorized_vln": 0b00111,
    "vectorized_vbcnt": 0b01000,
    "vectorized_vrelu": 0b01001,
    "vectorized_vexp": 0b01001,
    "vectorized_vnot": 0b01101,
    "vectorized_vsqz": 0b01110,
    "vectorized_vusqz": 0b01110,
    "vectorized_vmov": 0b11001,
    "vectorized_pnot": 0b10110,
    "vectorized_vpack": 0b10001,
    "vectorized_vunpack": 0b10010,
}

PARAMETERS = {
    "vectorized_pand": 0b000,
    "vectorized_pmov": 0b000,
    "vectorized_por": 0b001,
    "vectorized_pxor": 0b010,
    "vectorized_pnand": 0b011,
    "vectorized_psel": 0b100,
    "vectorized_vintlv": 0b000,
    "vectorized_vdintlv": 0b100,
    "vectorized_vsadd": 0b010,
    "vectorized_vssub": 0b100,
    "vectorized_vsel": 0b000,
    "vectorized_vrnd": 0b000,
    "vectorized_vmadd": 0b100,
    "vectorized_vprelu": 0b100,
    "vectorized_vand": 0b000,
    "vectorized_vor": 0b100,
    "vectorized_vxor": 0b000,
    "vectorized_vnand": 0b100,
    "vectorized_vrsqrt": 0b000,
    "vectorized_vsqrt": 0b100,
    "vectorized_vrec": 0b000,
    "vectorized_vln": 0b100,
    "vectorized_vbcnt": 0b100,
    "vectorized_vrelu": 0b000,
    "vectorized_vexp": 0b100,
    "vectorized_vnot": 0b000,
    "vectorized_vsqz": 0b000,
    "vectorized_vmov": 0b000,
    "vectorized_vaxpy": 0b100,
    "vectorized_vrnds": 0b000,
    "vectorized_vlrelu": 0b100,
    "vectorized_vsadds": 0b000,
    "vectorized_vscvt": 0b100,
    "vectorized_vcvt": 0b000,
    "vectorized_ppack": 0b000,
    "vectorized_punpack": 0b100,
    "vectorized_vslide": 0b000,
}

DIST_VLD = {
    'NORM': 0,
    'BRC_B8': 1,
    'BRC_B16': 2,
    'BRC_B32': 3,
    'RPT2_B8': 4,
    'RPT2_B16': 5,
    'US_B8': 6,
    'US_B16': 7,
    'DS_B8': 8,
    'DS_B16': 9,
    'BDINTLV': 10,
    'DINTLV_B8': 11,
    'DINTLV_B16': 12,
    'UNPK_B8': 13,
    'UNPK_B16': 14,
    'BLK': 15,
    'E2B_B16': 16,
    'US': 17,  # pld
    'DS': 18,  # pld
    'PK': 19  # pst
}

DIST_VLD_ALIGN = {
    'NORM': 32,
    'BRC_B8': 1,
    'BRC_B16': 2,
    'BRC_B32': 4,
    'RPT2_B8': 2,
    'RPT2_B16': 4,
    'US_B8': 32,
    'US_B16': 32,
    'DS_B8': 32,
    'DS_B16': 32,
    'BDINTLV': 32,
    'DINTLV_B8': 32,
    'DINTLV_B16': 32,
    'UNPK_B8': 32,
    'UNPK_B16': 32,
    'BLK': 32,
    'E2B_B16': 16,
}

DIST_VST = {
    'NORM_B8': 0,
    'NORM_B16': 1,
    'NORM_B32': 2,
    'ONEPT_B8': 3,
    'ONEPT_B16': 4,
    'ONEPT_B32': 5,
    'PK_B16': 6,
    'PK_B32': 7,
    'INTLV_B8': 8,
    'INTLV_B16': 9
}

DIST_VST_ALIGN = {
    'NORM_B8': 32,
    'NORM_B16': 32,
    'NORM_B32': 32,
    'ONEPT_B8': 1,
    'ONEPT_B16': 2,
    'ONEPT_B32': 4,
    'PK_B16': 32,
    'PK_B32': 32,
    'INTLV_B8': 32,
    'INTLV_B16': 32
}

VEC_CMP_TYPE_V300 = {
    "vectorized_vcmp_eq": 0b000,
    "vectorized_vcmp_ne": 0b001,
    "vectorized_vcmp_gt": 0b011,
    "vectorized_vcmp_ge": 0b100,
    "vectorized_vcmp_lt": 0b010,
    "vectorized_vcmp_le": 0b101,
    "vectorized_vcmps_eq": 0b000,
    "vectorized_vcmps_ne": 0b0001,
    "vectorized_vcmps_lt": 0b010,
    "vectorized_vcmps_gt": 0b011,
    "vectorized_vcmps_ge": 0b100,
    "vectorized_vcmps_le": 0b101
}

VEC_CMP_TYPE = {
    "vectorized_vcmp_eq": 0,
    "vectorized_vcmp_ne": 1,
    "vectorized_vcmp_gt": 2,
    "vectorized_vcmp_ge": 3,
    "vectorized_vcmp_lt": 0,
    "vectorized_vcmp_le": 1,
    "vectorized_vcmps_eq": 0,
    "vectorized_vcmps_ne": 1,
    "vectorized_vcmps_gt": 2,
    "vectorized_vcmps_ge": 3,
    "vectorized_vcmps_lt": 0,
    "vectorized_vcmps_le": 1
}

V300_INSTR_REGTYPE_CODE = {
    "vectorized_vprelu": 0b00,
    "vectorized_vand": 0b00,
    "vectorized_vor": 0b00,
    "vectorized_vxor": 0b01,
    "vectorized_vnot": 0b01,
    "vectorized_vneg": 0b01,
    "vectorized_pand": 0b01,
    "vectorized_por": 0b01,
    "vectorized_pxor": 0b00,
    "vectorized_pnot": 0b00,
    "vectorized_vmul": 0b00,
    "vectorized_vmula": 0b00,
    "vectorized_vadd": 0b10,
    "vectorized_vadd3": 0b10,
    "vectorized_vsub": 0b10,
    "vectorized_vmax": 0b10,
    "vectorized_vmin": 0b10,
    "vectorized_vdiv": 0b01,
    "vectorized_vabs_int": 0b10,
    "vectorized_vabs_float": 0b00,
    "vectorized_vrelu": 0b01,
    "vectorized_vsqz": 0b00,
    "vectorized_vcadd": 0b00,
    "vectorized_vcmax": 0b00,
    "vectorized_vcmin": 0b00,
    "vectorized_vcls": 0b00,
    "vectorized_pmov": 0b01,
    "vectorized_psel": 0b01,
    "vectorized_vexp": 0b01,
    "vectorized_vsqrt": 0b00,
    "vectorized_vln": 0b00,
    "vectorized_vrsqrt": 0b00,
    "vectorized_vrec": 0b00,
    "vectorized_vbcnt": 0b01,
    "vectorized_vshr": 0b10,
    "vectorized_wadd": 0b00,
    "vectorized_wadda": 0b00,
    "vectorized_waddsub": 0b00,
    "vectorized_wsub": 0b00,
    "vectorized_wsuba": 0b00,
    "vectorized_vshl": 0b10,
    "vectorized_vabsdif": 0b10,
    "vectorized_vsad": 0b10,
    "vectorized_vsel": 0b0,
    "vectorized_vrnd": 0b10,
    "vectorized_vavg": 0b10,
    "vectorized_vmadd": 0b0,
}

V300_INSTR_OP1_CODE = {
    "vectorized_vadd": 0x00,
    "vectorized_vsub": 0x01,
    "vectorized_vmax": 0x02,
    "vectorized_vmin": 0x03,
    "vectorized_vadd3": 0x06,
    "vectorized_vabs_int": 0x09,
    "vectorized_vadds": 0x28,
    "vectorized_vmaxs": 0x29,
    "vectorized_vmins": 0x2A,
    "vectorized_vmul": 0x40,
    "vectorized_vmula": 0x41,
    "vectorized_vprelu": 0x43,
    "vectorized_vmuls": 0x48,
    "vectorized_vlrelu": 0x4A,
    "vectorized_vand": 0x50,
    "vectorized_vxor": 0x50,
    "vectorized_vor": 0x51,
    "vectorized_vnot": 0x51,
    "vectorized_pand": 0x52,
    "vectorized_por": 0x53,
    "vectorized_pxor": 0x54,
    "vectorized_pnot": 0x55,
    "vectorized_vdiv": 0x5B,
    "vectorized_vneg": 0x5C,
    "vectorized_vabs_float": 0x5C,
    "vectorized_vrelu": 0x5C,
    "vectorized_vdup": 0x64,
    "vectorized_vdupm": 0x65,
    "vectorized_vcbmax": 0x70,
    "vectorized_vcbmin": 0x71,
    "vectorized_vcadd": 0x72,
    "vectorized_vsqz": 0x79,
    "vectorized_vcmax": 0x73,
    "vectorized_vcmin": 0x74,
    "vectorized_vcls": 0x5D,
    "vectorized_pmov": 0x52,
    "vectorized_psel": 0x54,
    "vectorized_vexp": 0x5A,
    "vectorized_vsqrt": 0x5A,
    "vectorized_vln": 0x5B,
    "vectorized_vrsqrt": 0x5D,
    "vectorized_vrec": 0x5C,
    "vectorized_vbcnt": 0x5D,
    "vectorized_vshrs": 0x4E,
    "vectorized_vshls": 0x4D,
    "vectorized_vaxpy": 0x49,
    "vectorized_vrnds": 0x4F,
    "vectorized_vshr": 0x44,
    "vectorized_wadd": 0x0,
    "vectorized_wadda": 0x1,
    "vectorized_waddsub": 0x4,
    "vectorized_wsub": 0x2,
    "vectorized_wsuba": 0x3,
    "vectorized_vshl": 0x43,
    "vectorized_vabsdif": 0x4,
    "vectorized_vsad": 0x8,
    "vectorized_vmov": 0x53,
    "vectorized_vavg": 0x5,
    "vectorized_vmadd": 0x42,
    "vectorized_vrnd": 0x45,
    "vectorized_vsel": 0x52,
    "vectorized_ppack": 0x2,
    "vectorized_punpack": 0x3,
    "vectorized_vintlv": 0x60,
    "vectorized_vdintlv": 0x61,
    "vectorized_wmul": 0x44,
    "vectorized_wmuls": 0x4B,
    "vectorized_wmula": 0x45,
    "vectorized_wmulas": 0x4C,
    "vectorized_wmul_v2": 0x44,
    "vectorized_wmula_v2": 0x45,
}

V210_INSTR_OP1_CODE = {
    "vectorized_vnop": 0,
    "vectorized_vadd": 1,
    "vectorized_vsub": 2,
    "vectorized_vmul": 3,
    "vectorized_vmula": 4,
    "vectorized_vmax": 5,
    "vectorized_vmin": 6,
    "vectorized_vshl": 7,
    "vectorized_vshr": 8,
    "vectorized_vabsdif": 9,
    "vectorized_vadif": 10,
    "vectorized_vadd3": 11,
    "vectorized_vsad": 12,
    "vectorized_vrnd": 13,
    "vectorized_vmadd": 13,
    "vectorized_vdiv": 14,
    "vectorized_vaddrelu": 15,
    "vectorized_vsubrelu": 15,
    "vectorized_vprelu": 16,
    "vectorized_vavg": 17,
    "vectorized_vcbmax": 18,
    "vectorized_vand": 19,
    "vectorized_vor": 19,
    "vectorized_vxor": 20,
    "vectorized_vnand": 20,
    "vectorized_vslide": 22,
    "vectorized_vaxpy": 22,
    "vectorized_vcmp_eq": 24,
    "vectorized_vcmp_ne": 24,
    "vectorized_vcmp_gt": 24,
    "vectorized_vcmp_ge": 24,
    "vectorized_vcmp_lt": 25,
    "vectorized_vcmp_le": 25,
    "vectorized_vadds": 26,
    "vectorized_vmuls": 28,
    "vectorized_vmaxs": 30,
    "vectorized_vmins": 32,
    "vectorized_vshls": 34,
    "vectorized_vshrs": 36,
    "vectorized_vrnds": 38,
    "vectorized_vlrelu": 38,
    "vectorized_vcmps_eq": 40,
    "vectorized_vcmps_ne": 40,
    "vectorized_vcmps_gt": 40,
    "vectorized_vcmps_ge": 40,
    "vectorized_vcmps_lt": 42,
    "vectorized_vcmps_le": 42,
    "vectorized_vsadd": 47,
    "vectorized_vssub": 47,
    "vectorized_vsel": 48,
    "vectorized_vcbmin": 50,
    "vectorized_vsadds": 52,
    "vectorized_wadd": 103,
    "vectorized_wadda": 103,
    "vectorized_wsub_int8": 103,
    "vectorized_wsub_int16": 103,
    "vectorized_wsuba_int8": 103,
    "vectorized_wsuba_int16": 103,
    "vectorized_wsub_uint8": 107,
    "vectorized_wsub_uint16": 107,
    "vectorized_wsuba_uint8": 107,
    "vectorized_wsuba_uint16": 107,
    "vectorized_waddsub": 104,
    "vectorized_wmul": 103,
    "vectorized_wmula_u8u8": 103,
    "vectorized_wmula_u8s8": 103,
    "vectorized_wmula": 104,
    "vectorized_wmuls": 105,
    "vectorized_wmuls_s16s32": 106,
    "vectorized_wmulas": 106,
    "vectorized_wmulas_s16u32": 107,
    "vectorized_wmulas_s16s32": 107,
    "vectorized_vscatter": 148,
}

VFCVT_VSFCVT_RND_TYPE = ["f322s32", "f162s8", "f162u8", "f162s32"]

VFCVT_VSFCVT_PART_TYPE = ["f322f16", "f322s16", "f162f32", "f162s8", "f162u8",
                          "f162s32", "u82f16", "s82f16", "s162f32"]

_VCVT_VSCVT_OP2_CODE = {
    "u82u16": 0b00000,
    "u82u32": 0b00001,
    "s82s16": 0b00010,
    "s82s32": 0b00011,
    "u162u8": 0b00100,
    "u162u32": 0b00101,
    "s162u8": 0b00110,
    "s162u32": 0b00111,
    "s162s32": 0b01000,
    "u322u8": 0b01001,
    "u322u16": 0b01010,
    "u322s16": 0b01011,
    "s322u8": 0b01100,
    "s322u16": 0b01101,
    "s322s16": 0b01110,
}

VCVT_TYPE_V300 = {
    "f32": 0b00,
    "f16": 0b01,
    "bf16": 0b10,
    "u8": 0b000,
    "s8": 0b001,
    "u16": 0b010,
    "s16": 0b011,
    "u32": 0b100,
    "s32": 0b101,
    "s4": 0b110,
    "s64": 0b111
}

VCVT_PART_V300 = {

    "PART_EVEN": 0b0,
    "PART_ODD": 0b1,
    "PART_P0": 0b00,
    "PART_P1": 0b01,
    "PART_P2": 0b10,
    "PART_P3": 0b11
}

VCVT_VFCVT_PART = {
    "PART_EVEN": 0b0,
    "PART_ODD": 0b1,
}

VCVT_VFCVT_PP = {
    "PART_P0": 0b00,
    "PART_P1": 0b01,
    "PART_P2": 0b10,
    "PART_P3": 0b11,
}

VFCVT_VSFCVT_R_O_Z = {
    "ROUND_R": 0b0,
    "ROUND_O": 0b1,
    "ROUND_Z": 0b1,
}

VFCVT_VSFCVT_RND = {
    "ROUND_R": 0b000,
    "ROUND_A": 0b001,
    "ROUND_F": 0b010,
    "ROUND_C": 0b011,
    "ROUND_Z": 0b100,
}

VTRC_OP2_TYPE = {
    "float16": 0b10011,
    "float32": 0b10100
}

BIT2_TYPE_16_32 = {
    'uint16': 0b00,
    'int16': 0b01,
    'uint32': 0b10,
    'int32': 0b11,
}


def dst_merging_mode(context, dst_params, mask, is_merging):
    """
    dst merging_mode
    Parameters
    ----------
    dst_params: dst, dst_vd_idx, vec_type
    context: context
    mask: Converts MODE_ZEROING to MODE_MERGING based on the mask.
    is_merging: if is_merging is False, will be keep zeroing mode, don't change merging
    Returns
    -------
    None
    """
    dst, dst_vd_idx, vec_type = dst_params
    value_buffer1 = context.get_vector_value(dst).buffer
    flatten_np = value_buffer1.reshape(-1)
    if mask is None or not is_merging:
        context.model.read_vec_register_by_idx(vec_type, dst_vd_idx, flatten_np.ctypes.data,
                                               len(flatten_np) * DTYPE_SIZE[dst.dtype])
        return
    # Copy the original data.
    flatten_np2 = copy.deepcopy(flatten_np)
    context.model.read_vec_register_by_idx(vec_type, dst_vd_idx, flatten_np.ctypes.data,
                                           len(flatten_np) * DTYPE_SIZE[dst.dtype])
    if isinstance(mask, Vector) and mask.scope == scope_preg:
        _changes_value_mask_vector(context, mask, dst, flatten_np, flatten_np2)
    else:
        # The valid bit remains unchanged. The invalid bit changes to the original value.
        mask = context.evaluate_expr(mask)
        if dst.scope == "local.WREG":
            dst_dtype_w = WDTYPE_TO_DTYPE.get(dst.dtype)
            mask *= DTYPE_SIZE[dst.dtype]//DTYPE_SIZE[dst_dtype_w]
        flatten_np[mask:] = flatten_np2[mask:]


def _changes_value_mask_vector(context, mask, dst, flatten_np, flatten_np2):
    # get the mask value.
    mask_buffer = context.get_vector_value(mask).buffer
    mask_np = mask_buffer.reshape(-1)
    mask_str = ""
    # Converts the mask value to binary.
    for i in mask_np:
        mask_str += bin(i)[2:].zfill(8)[::-1]
        # The invalid value of mask is assigned to the original value.
    for j in range(0, len(mask_str), DTYPE_SIZE.get(dst.dtype)):
        if j // DTYPE_SIZE.get(dst.dtype) == len(flatten_np2):
            break
        if mask_str[j] == "0":
            flatten_np[j // DTYPE_SIZE.get(dst.dtype)] = flatten_np2[j // DTYPE_SIZE.get(dst.dtype)]


def vcmax_vcmin_merging_v300(context, mask, flatten_np, flatten_np2):
    # get the mask value.
    if isinstance(mask, Vector) and mask.scope == scope_preg:
        mask_buffer = context.get_vector_value(mask).buffer
        mask_np = mask_buffer.reshape(-1)
        if mask_np.any() == 0:
            flatten_np[1:] = flatten_np2[1:]
        else:
            flatten_np[2:] = flatten_np2[2:]
    elif mask is None:
        flatten_np[2:] = flatten_np2[2:]
    else:
        mask = context.evaluate_expr(mask)
        if mask == 0:
            flatten_np[1:] = flatten_np2[1:]
        else:
            flatten_np[2:] = flatten_np2[2:]


def dst_register(context, dst_params, mask=None, is_merging=True, name=None):
    """
    dst register
    Parameters
    ----------
    dst_params: dst, dst_vd_idx, vec_type
    context
    mask
    is_merging
    name

    Returns
    -------

    """
    dst, dst_vd_idx, vec_type = dst_params
    if TikSocManager.is_v300_610l_soc():
        dst_merging_mode(context, (dst, dst_vd_idx, vec_type), mask, is_merging)
        return
    value_buffer1 = context.get_vector_value(dst).buffer
    flatten_np = value_buffer1.reshape(-1)
    context.model.read_vec_register_by_idx(vec_type, dst_vd_idx, flatten_np.ctypes.data,
                                           len(flatten_np) * DTYPE_SIZE[dst.dtype])


def dst_register_vcvt(context, dst_params, mask):
    """
    dst register vcvt
    Parameters
    ----------
    dst_params: dst, dst_vd_idx, vec_type
    context: context
    mask: Converts MODE_ZEROING to MODE_MERGING based on the mask.
    Returns
    -------

    """
    dst, dst_vd_idx, vec_type = dst_params
    value_buffer1 = context.get_vector_value(dst).buffer
    flatten_np = value_buffer1.reshape(-1)
    if mask is None:
        context.model.read_vec_register_by_idx(vec_type, dst_vd_idx, flatten_np.ctypes.data,
                                               len(flatten_np) * DTYPE_SIZE[dst.dtype])
        return
    context.model.read_vec_register_by_idx(vec_type, dst_vd_idx, flatten_np.ctypes.data,
                                           len(flatten_np) * DTYPE_SIZE[dst.dtype])


def _set_vcvt_mask(context, mask, dst, src, part_indicator):
    """
    According to the part_indicator to set mask
    context: context
    dst: dst
    src: src
    mask: Converts MODE_ZEROING to MODE_MERGING based on the mask.
    part_indicator: part_indicator
    """
    mask = context.evaluate_expr(mask)
    if DTYPE_SIZE.get(src.dtype) < DTYPE_SIZE.get(dst.dtype):
        if part_indicator == "PART_EVEN":
            mask = math.ceil(mask * DTYPE_SIZE.get(src.dtype) / DTYPE_SIZE.get(dst.dtype))
        elif part_indicator == "PART_ODD":
            mask = mask * DTYPE_SIZE.get(src.dtype) // DTYPE_SIZE.get(dst.dtype)
        elif part_indicator == "PART_P0":
            mask = math.ceil(mask * DTYPE_SIZE.get(src.dtype) / DTYPE_SIZE.get(dst.dtype))
        elif part_indicator == "PART_P1":
            mask = math.ceil((mask + 1) * DTYPE_SIZE.get(src.dtype) / DTYPE_SIZE.get(dst.dtype))
        elif part_indicator == "PART_P2":
            mask = math.ceil((mask + 2) * DTYPE_SIZE.get(src.dtype) / DTYPE_SIZE.get(dst.dtype))
        elif part_indicator == "PART_P3":
            mask = math.ceil((mask + 3) * DTYPE_SIZE.get(src.dtype) / DTYPE_SIZE.get(dst.dtype))
    elif DTYPE_SIZE.get(src.dtype) > DTYPE_SIZE.get(dst.dtype):
        mask = mask * DTYPE_SIZE.get(src.dtype) // DTYPE_SIZE.get(dst.dtype)

    return mask


def set_vdup_param(context, param, vdup):
    """
    set vdup vdups param
    Parameters
    ----------
    vdup
    context
    param

    Returns
    -------

    """
    pg_idx = context.alloc_p_register(vdup.mask, dtype=vdup.dst.dtype)
    param.pgIdx = pg_idx

    param.type = VEC_TYPE_BITS.get(vdup.dst.dtype)
    load_mode = context.evaluate_expr(vdup.load_mode)
    param.pm = LOOP_MODES.get(load_mode)

    vd_idx = context.alloc_v_register(vdup.dst)
    param.vdIdx = vd_idx
    return param, vd_idx


def eval_expr_seq(context, expr_seq):
    """
    for loop eval expr
    Parameters
    ----------
    context
    expr_seq

    Returns
    -------

    """
    tmp_seq = []
    for i in expr_seq:
        tmp_seq.append(context.evaluate_expr(i))
    return tmp_seq


def get_mask_bit_len(context, mask, dtype):
    """
    get mask bit length
    Parameters
    ----------
    context: tik context
    mask: mask
    dtype: data type

    Returns
    -------
    bit length
    """
    if not is_predicate(mask) and mask is not None:
        mask_value = context.evaluate_expr(mask)
        return mask_value
    if mask is None:
        return VL_T_MAP.get(dtype)

    value_buffer = context.get_vector_value(mask).buffer
    if DTYPE_SIZE.get(dtype) == 1:
        # 0b11111111
        valid_buffer = value_buffer.copy()
    elif DTYPE_SIZE.get(dtype) == 2:
        # 0b01010101
        valid_buffer = np.full((32,), 85, dtype=np.uint8)
        valid_buffer = np.bitwise_and(valid_buffer, value_buffer)
    else:  # dtype is b32
        # 0b00010001
        valid_buffer = np.full((32,), 17, dtype=np.uint8)
        valid_buffer = np.bitwise_and(valid_buffer, value_buffer)

    valid_buffer_unpk = np.unpackbits(valid_buffer)
    valid_buffer_unpk = np.flip(valid_buffer_unpk.reshape(32, 8), 1) \
        .reshape(-1)
    mask_list = valid_buffer_unpk[::DTYPE_SIZE.get(dtype)].copy()

    for idx, mask_bit in enumerate(np.flip(mask_list)):
        if mask_bit:
            return len(mask_list) - idx

    return 0


def get_and_write_share_spr(context, init_value, dtype):
    """
    get and write share spr
    Parameters
    ----------
    context: tik context
    init_value: expr init value
    dtype: data type

    Returns
    -------
    mo return
    """
    add_value = context.evaluate_expr(init_value)
    new_value = add_value

    if "float" in dtype:
        new_value = cvt_float_to_uint(dtype, add_value)
    else:
        new_value = int(new_value)

    sm_idx, sn_nums = context.alloc_s_register(dtype)

    for i in range(sn_nums):
        add_value = (new_value >> 16 * i) & 0xFFFF
        context.model.write_spr('VPR_SHARED_{}'.format(sm_idx + i), add_value)
    return sm_idx


def gen_vag_instr(context, dtype):
    """
    generate vag instr
    Parameters
    ----------
    context: context
    dtype: data type

    Returns
    -------
    vag instr
    """
    param = context.encoder.new_vec_param()
    # stIdx is loop4 index
    param.stIdx = get_and_write_share_spr(
        context, VL_T_MAP.get(dtype), "uint16")
    # smIdx is loop3 index
    param.smIdx = get_and_write_share_spr(context, 0, "uint16")
    # snIdx is loop2 index
    param.snIdx = get_and_write_share_spr(context, 0, "uint16")
    # sdIdx is loop1 index
    param.sdIdx = get_and_write_share_spr(context, 0, "uint16")
    vag_instr = context.encoder.gen_vag(param)
    return vag_instr


def set_param_loop_vex_num_dtype(context, dtype, loop, vex_num):
    """
    set param var loop vec_num dtype
    Parameters
    ----------
    context
    loop
    vex_num
    dtype

    Returns
    -------

    """
    param = context.encoder.new_vec_param()
    # add vloopn instr
    param.loop = loop
    param.vexNum = vex_num
    param.vloopnType = VLOOPN_TYPE.get(dtype)
    if TikSocManager.is_v300_610l_soc():
        param.isV300 = 1

    return param


def create_vloop_info(context, param, vld_loop_num=0, vst_loop_num=0):
    """
    create vloop info
    Parameters
    ----------
    param
    context: tik context
    vld_loop_num: vld loop num
    vst_loop_num: vst loop num

    Returns
    -------
    instr list
    """
    instr_list = []
    if TikSocManager.is_v300_610l_soc():
        return instr_list

    instr = context.encoder.gen_vloopn_gen(param)
    instr_list.append(instr)

    # add loop ctrl VLOOP_PARAM1 instr
    param.vldOnceNum = 0
    param.vldLoop1Num = 0
    param.vldLoop2Num = 0
    param.ctrlInstrNum = 0
    instr = context.encoder.gen_vloop_param1(param)
    instr_list.append(instr)

    # add loop ctrl VLOOP_PARAM2 instr
    param.vldLoop2Num = 0
    param.vldLoop3Num = 0
    param.vldLoop4Num = vld_loop_num
    param.vstLoop4Num = vst_loop_num
    param.vstLoop3Num = 0
    instr = context.encoder.gen_vloop_param2(param)
    instr_list.append(instr)

    # add loop ctrl VLOOP_PARAM3 instr
    param.vstLoop3Num = 0
    param.vstLoop2Num = 0
    param.vstLoop1Num = 0
    param.vstOnceNum = 0
    instr = context.encoder.gen_vloop_param3(param)
    instr_list.append(instr)
    return instr_list


def execute_all_instr(context, instr_list, instr):
    """
    execute all instr
    Parameters
    ----------
    context
    instr_list
    instr

    Returns
    -------

    """
    instr_list.append(instr)
    context.model.step_all(context, instr_list, len(instr_list))
