#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     mmad_other_intrinsic.py
DESC:     mmad_other_intrinsic
CREATED:  2021-12-08 12:20 PM
MODIFIED: 2021-12-08 12:20 PM
"""
from tbe.tik.common.util import TikUtil
from tbe.tik.common.util import ceil_div
from tbe.tik.common.common_util import get_l0c_align
from tbe.tik.common.common_util import check_param_type_range
from tbe.tik.common.common_util import reduce_mul
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.util import copy_tensor_to_model
from tbe.tik.debug.util import get_dtype_size
from tbe.tik.debug.util import get_dtype_bit_width
from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.tik_lib.tik_params import ALIGN_TENSOR
from tbe.tik.tik_lib.tik_params import ALIGN_SRC
from tbe.tik.tik_lib.tik_params import MIN_NBURST
from tbe.tik.tik_lib.tik_params import MAX_NBURST_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import MIN_BURST_LEN
from tbe.tik.tik_lib.tik_params import MAX_BURST_LEN_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_BLK_STRIDE_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import DST_BLK_STRIDE_IDX
from tbe.tik.tik_lib.tik_params import SRC_BLK_STRIDE_IDX
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_32
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_59
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_56
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_55
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_54
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_52
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_48
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_20
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_16
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_8
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_63
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_24
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_api_constants import WINO_PAD_MAP
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_44
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_mmad_param_type_range

_BRC_DST_TYPE_ID = {'float16': 0, 'float32': 1, 'int32': 1}

_BURST_LEN_SHIFT_BIT_POS = 8
_SRC_GAP_SHIFT_BIT_POS = 16
_DST_GAP_SHIFT_BIT_POS = 24

_BRC_DST_ALIGN = {
    'L0C16': 512,
    'L0C32': 1024
}
_BRC_SRC_ID = {
    'UB': 0,
    'L1': 1,
}
_BRC_DST_ID = {
    'L0C16': 0,
    'L0C32': 1
}

_WINO_TYPE_ID = {
    'int8': 0,
    'uint8': 1,
    "float16": 2
}

_WINO_V2_TYPE_ID = {
    'int8': 0,
    'uint8': 1,
    "int16": 2
}


class BroadcastUB(STMT):
    """
    BroadcastUB instruction
    """

    def __init__(self, source_info, b_ubl0c_obj):
        super(BroadcastUB, self).__init__(source_info, b_ubl0c_obj.tik_instance.context.tik_debugger)
        self.obj = b_ubl0c_obj

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        src_dtype = self.obj.src.dtype
        dst_dtype = self.obj.dst.dtype

        temp_env = TempEnv()

        xn_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.obj.src, ALIGN_SRC, access_mode='r')

        dst_align = get_l0c_align(self.obj.dst)
        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.obj.dst, dst_align, access_mode='w')

        conv = 0
        if _BRC_DST_TYPE_ID.get(dst_dtype) and src_dtype != dst_dtype:
            conv = 1

        param = context.encoder.new_param()
        param.dstMemId = _BRC_DST_TYPE_ID.get(dst_dtype)
        param.srcMemId = 0
        param.conv = conv
        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = self.create_gpr_x_m(context, temp_env)

        instr = context.encoder.gen_dma_brc(param)

        context.model.step(instr)
        temp_env.check_mem_access(context.model, True)
        context.model.read_memory(dst_addr, self.obj.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_m(self, context, temp_env):
        """
        create general purpose register x_m

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        nburst = context.evaluate_expr(self.obj.nburst)
        burst_len = context.evaluate_expr(self.obj.burst_len)
        dst_gap = context.evaluate_expr(self.obj.strides[DST_BLK_STRIDE_IDX])
        src_gap = context.evaluate_expr(self.obj.strides[SRC_BLK_STRIDE_IDX])

        # check params
        check_mmad_param_type_range('nburst', nburst, MIN_NBURST, MAX_NBURST_SINGLE_BYTE, is_debug=True)
        check_mmad_param_type_range('burst_len', burst_len, MIN_BURST_LEN, MAX_BURST_LEN_SINGLE_BYTE, is_debug=True)
        check_mmad_param_type_range('src_blk_stride', src_gap, end=MAX_BLK_STRIDE_SINGLE_BYTE, is_debug=True)
        check_mmad_param_type_range('dst_blk_stride', dst_gap, end=MAX_BURST_LEN_SINGLE_BYTE, is_debug=True)

        xm_idx = temp_env.alloc_register()

        x_m = nburst
        x_m |= burst_len << _BURST_LEN_SHIFT_BIT_POS
        x_m |= src_gap << _SRC_GAP_SHIFT_BIT_POS
        x_m |= dst_gap << _DST_GAP_SHIFT_BIT_POS

        context.model.write_gpr(xm_idx, x_m)

        return xm_idx


class MmadBrc(STMT):
    """
    mmad_broadcast instruction
    """

    def __init__(self, source_info, mmad_b_obj):
        super(MmadBrc, self).__init__(source_info, mmad_b_obj.tik_instance.context.tik_debugger)
        self.obj = mmad_b_obj

    def eval_(self, context):
        """
        eval the printf statement.
        Parameters
        ----------
        context: the stack context.

        Returns
        -------
        no return
        """
        src_scope = TikUtil.get_storage_scope(self.obj.src.scope)
        dst_scope = TikUtil.get_storage_scope(self.obj.dst.scope) + get_dtype_bit_width(self.obj.src.dtype)

        src_align = 32
        if TikSocManager.is_v200_soc() or TikSocManager.is_v210_soc():
            src_align = get_dtype_size(self.obj.src.dtype)

        temp_env = TempEnv()

        xn_idx, _, _, _ = copy_tensor_to_model(context, temp_env, self.obj.src, src_align)

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.obj.dst, _BRC_DST_ALIGN.get(dst_scope), access_mode='w')

        param = context.encoder.new_param()
        param.dstMemId = _BRC_DST_ID.get(dst_scope)
        param.srcMemId = _BRC_SRC_ID.get(src_scope)
        param.conv = 0
        if _BRC_DST_ID.get(dst_scope) and self.obj.src.dtype != self.obj.dst.dtype:
            param.conv = 1
        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = self.create_gpr_x_m(context, temp_env)

        instr = context.encoder.gen_dma_brc(param)

        context.model.step(instr)
        temp_env.check_mem_access(context.model, True)
        context.model.read_memory(dst_addr, self.obj.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_m(self, context, temp_env):
        """
        create register x_m

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        dst_gap = context.evaluate_expr(self.obj.dst_gap)
        src_gap = context.evaluate_expr(self.obj.src_gap)
        nburst = context.evaluate_expr(self.obj.nburst)
        nburst = max(nburst, 1)
        burst_len = context.evaluate_expr(self.obj.burst_repeat)
        burst_len = max(burst_len, 1)
        repeat_mode = context.evaluate_expr(self.obj.repeat_mode)

        xm_idx = temp_env.alloc_register()

        x_m = nburst
        x_m |= burst_len << SHIFT_BIT_POS_8
        x_m |= src_gap << SHIFT_BIT_POS_16
        x_m |= dst_gap << SHIFT_BIT_POS_24
        x_m |= repeat_mode << SHIFT_BIT_POS_63

        context.model.write_gpr(xm_idx, x_m)

        return xm_idx


class LoadWinoFeatureMap(STMT):
    """
    winograd_feature_map_transform instruction
    """

    def __init__(self, source_info, load_w_fm_obj):
        super(LoadWinoFeatureMap, self).__init__(source_info, load_w_fm_obj.tik_instance.context.tik_debugger)
        self.obj = load_w_fm_obj

    def eval_(self, context):
        """
        eval the printf statement.
        Parameters
        ----------
        context: the stack context.

        Returns
        -------
        no return
        """
        temp_env = TempEnv()
        xn_idx, _, _, _ = copy_tensor_to_model(context, temp_env, self.obj.src, ALIGN_SRC, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.obj.dst, ALIGN_TENSOR, access_mode='w')

        param = context.encoder.new_param()
        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = self.create_gpr_x_m(context, temp_env)
        param.xt = self.create_gpr_x_t(context, temp_env)
        param.type = _WINO_V2_TYPE_ID.get(self.obj.src.dtype)

        instr = context.encoder.gen_dma_winograd_l0av2(param)

        context.model.step(instr)
        temp_env.check_mem_access(context.model, True)
        context.model.read_memory(
            dst_addr, self.obj.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_m(self, context, temp_env):
        """
        create register x_m

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        pad_left, pad_right, pad_top, pad_bottom = self.obj.pad
        _, src_c1, l1_h, l1_w, src_c0 = self.obj.src.shape
        xm_idx = temp_env.alloc_register()
        x_m = context.evaluate_expr(l1_w)
        x_m |= context.evaluate_expr(l1_h) << SHIFT_BIT_POS_16
        x_m |= context.evaluate_expr(src_c0 * src_c1) << SHIFT_BIT_POS_32
        x_m |= WINO_PAD_MAP[pad_left, pad_right] << SHIFT_BIT_POS_56
        x_m |= WINO_PAD_MAP[pad_top, pad_bottom] << SHIFT_BIT_POS_59
        context.model.write_gpr(xm_idx, x_m)

        return xm_idx

    def create_gpr_x_t(self, context, temp_env):
        """
        create register x_t

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xt_idx
        """
        k_ext = context.evaluate_expr(self.obj.k_extension)
        k_start = context.evaluate_expr(self.obj.k_start_pt)
        m_ext = context.evaluate_expr(self.obj.m_extension)
        m_start = context.evaluate_expr(self.obj.m_start_pt)
        self._check_src_shape(k_ext, k_start, m_ext, m_start)

        dst_expected_ele = k_ext * ceil_div(m_ext, 16) * 16 * 16 + self.obj.dst.offset
        dst_actual_ele = reduce_mul(self.obj.dst.original_shape)
        TikCheckUtil.check_ge(
            dst_actual_ele, dst_expected_ele,
            "dst tensor overflow, expected dst shape: {}, actual dst shape: {}"
                .format(dst_expected_ele, dst_actual_ele))
        xt_idx = temp_env.alloc_register()
        x_t = 0
        x_t |= k_ext << SHIFT_BIT_POS_8
        x_t |= k_start << SHIFT_BIT_POS_20
        x_t |= m_ext << SHIFT_BIT_POS_32
        x_t |= m_start << SHIFT_BIT_POS_44
        context.model.write_gpr(xt_idx, x_t)

        return xt_idx

    def _check_src_shape(self, k_ext, k_start, m_ext, m_start):
        _, src_c1, l1_h, l1_w, src_c0 = self.obj.src.shape
        l1_h_num = l1_h + self.obj.pad[2] + self.obj.pad[3] - 2
        l1_w_num = l1_w + self.obj.pad[0] + self.obj.pad[1] - 2
        max_m_num = l1_h_num * l1_w_num // 4
        check_param_type_range(
            [k_ext, k_start, m_ext, m_start], [1, 0, 1, 0], [4095, 4095, 4095, 4095],
            ["k_extension", "k_start_pt", "m_extension", "m_start_pt"], "load_winograd_fm")
        # k should be multiple of c0
        if k_ext % src_c0 != 0:
            TikCheckUtil.raise_error(
                "k_extension should be multiple of C0, input k_extension: {}, C0: {}".format(k_ext, src_c0))
        if k_start % src_c0 != 0:
            TikCheckUtil.raise_error(
                "k_start_pt should be multiple of C0, input k_start_pt: {}, C0: {}".format(k_start, src_c0))
        if m_start % 16 != 0:
            TikCheckUtil.raise_error(
                "m_start_pt should be multiple of 16, input m_start_pt: {}".format(m_start))
        TikCheckUtil.check_le(
            k_start + k_ext, src_c1 * src_c0,
            "k_start_pt + k_extension should less than max_k_num:{}".format(src_c1 * src_c0))
        TikCheckUtil.check_le(
            ceil_div(m_ext, 16) * 16 + m_start, max_m_num,
            "ceil(m_extension, 16)*16 + m_start_pt should less than max_m_num:{}".format(max_m_num))


class LoadWinoWeight(STMT):
    """
    winograd_weight_transform instruction
    """

    def __init__(self, source_info, load_w_we_obj):
        super(LoadWinoWeight, self).__init__(source_info, load_w_we_obj.tik_instance.context.tik_debugger)
        self.obj = load_w_we_obj

    def eval_(self, context):
        """
        eval the printf statement.
        Parameters
        ----------
        context: the stack context.

        Returns
        -------
        no return
        """
        temp_env = TempEnv()
        xn_idx, _, _, _ = copy_tensor_to_model(context, temp_env, self.obj.src, ALIGN_SRC, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.obj.dst, ALIGN_TENSOR, access_mode='w')

        param = context.encoder.new_param()
        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = self.create_gpr_x_m(context, temp_env)
        param.type = _WINO_TYPE_ID.get(self.obj.src.dtype)

        instr = context.encoder.gen_dma_winograd_l0bv2(param)

        context.model.step(instr)
        temp_env.check_mem_access(context.model, True)
        context.model.read_memory(
            dst_addr, self.obj.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_m(self, context, temp_env):
        """
        create register x_m

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        src_c1, eight_multi_channel, _, _, src_c0 = self.obj.src.shape
        _, sixteen_multi_nb, _, _, _ = self.obj.dst.shape
        input_channel_size = src_c0 * src_c1
        input_kernel_num = eight_multi_channel * 8
        output_kernel_num = sixteen_multi_nb * 16
        xm_idx = temp_env.alloc_register()
        x_m = input_channel_size
        x_m |= context.evaluate_expr(input_kernel_num) << SHIFT_BIT_POS_16
        x_m |= context.evaluate_expr(output_kernel_num) << SHIFT_BIT_POS_32
        x_m |= context.evaluate_expr(self.obj.dtype_mode) << SHIFT_BIT_POS_48

        context.model.write_gpr(xm_idx, x_m)

        return xm_idx


class LoadL1ToL0AWinograd(STMT):
    """
    winograd_feature_map_transform instruction
    """

    def __init__(self, source_info, w_fm_tf_obj):
        super(LoadL1ToL0AWinograd, self).__init__(source_info, w_fm_tf_obj.tik_instance.context.tik_debugger)
        self.obj = w_fm_tf_obj

    def eval_(self, context):
        """
        eval the LoadL1ToL0AWinograd statement.
        Parameters
        ----------
        context: the stack context.

        Returns
        -------
        no return
        """
        temp_env = TempEnv()
        xn_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.obj.src, ALIGN_SRC, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.obj.dst, ALIGN_TENSOR, access_mode='w')

        param = context.encoder.new_param()
        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = self.create_gpr_x_m(context, temp_env)
        param.xt = self.create_gpr_x_t(context, temp_env)
        param.type = _WINO_TYPE_ID.get(self.obj.src.dtype)

        instr = context.encoder.gen_dma_winograd_l0a(param)

        context.model.step(instr)
        temp_env.check_mem_access(context.model, True)
        context.model.read_memory(
            dst_addr, self.obj.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_m(self, context, temp_env):
        """
        create register x_m

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        pad_left = context.evaluate_expr(self.obj.pad_left)
        pad_right = context.evaluate_expr(self.obj.pad_right)
        pad_top = context.evaluate_expr(self.obj.pad_top)
        pad_bottom = context.evaluate_expr(self.obj.pad_bottom)

        xm_idx = temp_env.alloc_register()
        x_m = context.evaluate_expr(self.obj.l1_w)
        x_m |= context.evaluate_expr(self.obj.l1_h) << SHIFT_BIT_POS_16
        x_m |= context.evaluate_expr(self.obj.l1_c) << SHIFT_BIT_POS_32
        x_m |= context.evaluate_expr(self.obj.dst_stride) << SHIFT_BIT_POS_48
        x_m |= context.evaluate_expr(self.obj.column_indicator) << SHIFT_BIT_POS_54
        x_m |= WINO_PAD_MAP[pad_left, pad_right] << SHIFT_BIT_POS_56
        x_m |= WINO_PAD_MAP[pad_top, pad_bottom] << SHIFT_BIT_POS_59
        context.model.write_gpr(xm_idx, x_m)

        return xm_idx

    def create_gpr_x_t(self, context, temp_env):
        """
        create register x_t

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xt_idx
        """
        xt_idx = temp_env.alloc_register()
        x_t = 0
        x_t |= context.evaluate_expr(self.obj.k_extension) << SHIFT_BIT_POS_8
        x_t |= context.evaluate_expr(self.obj.k_start_pt) << SHIFT_BIT_POS_20
        x_t |= context.evaluate_expr(self.obj.m_extension) << SHIFT_BIT_POS_32
        x_t |= context.evaluate_expr(self.obj.m_start_pt) << SHIFT_BIT_POS_48
        context.model.write_gpr(xt_idx, x_t)

        return xt_idx


class LoadL1ToL0BWinograd(STMT):
    """
    winograd_weight_transform instruction
    """

    def __init__(self, source_info, w_we_tf_obj):
        super(LoadL1ToL0BWinograd, self).__init__(source_info, w_we_tf_obj.tik_instance.context.tik_debugger)
        self.obj = w_we_tf_obj

    def eval_(self, context):
        """
        eval the LoadL1ToL0BWinograd statement.
        Parameters
        ----------
        context: the stack context.

        Returns
        -------
        no return
        """
        temp_env = TempEnv()
        xn_idx, _, _, _ = copy_tensor_to_model(context, temp_env, self.obj.src, ALIGN_SRC, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.obj.dst, ALIGN_TENSOR, access_mode='w')

        param = context.encoder.new_param()
        param.xn = xn_idx
        param.xd = xd_idx
        param.xm = self.create_gpr_x_m(context, temp_env)
        param.type = _WINO_TYPE_ID.get(self.obj.src.dtype)

        instr = context.encoder.gen_dma_winograd_l0b(param)

        context.model.step(instr)
        temp_env.check_mem_access(context.model, True)
        context.model.read_memory(
            dst_addr, self.obj.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_m(self, context, temp_env):
        """
        create register x_m

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        xm_idx = temp_env.alloc_register()
        x_m = 0
        x_m |= context.evaluate_expr(self.obj.dst_blk_stride) << SHIFT_BIT_POS_8
        x_m |= context.evaluate_expr(self.obj.src_rep_stride) << SHIFT_BIT_POS_16
        x_m |= context.evaluate_expr(self.obj.dst_rep_stride) << SHIFT_BIT_POS_32
        # TIK doesn't support SMASK now
        x_m |= context.evaluate_expr(self.obj.column_indicator) << SHIFT_BIT_POS_52
        x_m |= context.evaluate_expr(self.obj.repeat_dir) << SHIFT_BIT_POS_54
        x_m |= context.evaluate_expr(int(self.obj.en_weight_offset)) << SHIFT_BIT_POS_55
        x_m |= context.evaluate_expr(self.obj.repeat_times) << SHIFT_BIT_POS_56

        context.model.write_gpr(xm_idx, x_m)

        return xm_idx
