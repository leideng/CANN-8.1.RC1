#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_spr_debug_.py
DESC:     provide vector instructions
CREATED:  2021-12-3 16:03:10
MODIFIED: 2021-12-3 16:03:10
"""

import numpy as np
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.util import get_flatten_idx
from tbe.tik.debug.util import cvt_float_to_uint
from tbe.tik.debug.util import make_tvm_imm
from tbe.tik.debug.util import get_dtype_bit_width
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import UINT64_BIT


class MoveCMPMASK2Tensor(STMT):
    """
    Class MoveCMPMASK2Tensor inherits STMT
    Move cmpmask to tensor
    """

    def __init__(self, source_info, dst, tik_ins):
        """
        Initialize class MoveCMPMASK2Tensor

        Parameter
        ----------
        source_info:source code information, It represents the relationship of current node with source code
        dst:tensor, destination of tensor
        src_cmpmask:source cmpmask

        Returns
        ----------
        No returns
        """
        super(MoveCMPMASK2Tensor, self).__init__(source_info, tik_ins.context.tik_debugger)
        self.dst = dst
        if TikSocManager.is_v300_610l_soc():
            self.source_id = tik_ins.context.debug_source_id

    def eval_(self, context):
        """
        Eval function
        evaluate all of self.function

        Parameters
        ----------
        context:information of debugger, store all of debugger's information

        Returns
        ----------
        No returns
        """
        if TikSocManager.is_v300_610l_soc():
            context.step_next(self.source_id)
            return
        mask_low = context.model.read_spr('CMPMASK0')
        mask_high = context.model.read_spr('CMPMASK1')
        tensor_buffer = context.tensor_buffer.get_npbuffer_by_tvmbuffer(self.dst.buffer).buffer
        flatten_np = tensor_buffer.reshape(-1).view(self.dst.dtype)
        mask_arr = np.array([mask_low, mask_high], dtype='uint64')
        dst_bitwidth = int(get_dtype_bit_width(str(flatten_np.dtype)))
        extent = 2 * UINT64_BIT // dst_bitwidth
        flatten_idx = self.check_dst_tensor(context, extent, flatten_np)
        flatten_np[flatten_idx: flatten_idx + extent] = mask_arr.view(str(flatten_np.dtype))

    def check_dst_tensor(self, context, extent, flatten_np):
        """

        Parameters
        ----------
        context: tik debug context
        extent: extent
        flatten_np: flatten np

        Returns
        -------

        """
        flatten_idx = get_flatten_idx(self.dst, context)
        if flatten_idx + extent > len(flatten_np):
            TikCheckUtil.raise_error('AccessViolation: write dst tensor out of range')
        return flatten_idx


class MoveTensor2CMPMASK(STMT):
    """
    Class MoveTensor2CMPMASK inherits from STMT.
    Move tensor to cmpmask
    """

    def __init__(self, source_info, src, tik_ins):
        """
        Initialize class MoveTensor2CMPMASK

        Parameters
        ----------
        source_info:source code information, It represents the relationship of current node with source code

        src:source tensor

        Returns
        ----------
        No returns
        """
        super(MoveTensor2CMPMASK, self).__init__(source_info, tik_ins.context.tik_debugger)
        self.src = src
        if TikSocManager.is_v300_610l_soc():
            self.source_id = tik_ins.context.debug_source_id

    def eval_(self, context):
        """
        Eval function
        evaluate all of self.function

        Parameters
        ----------
        context:information of debugger, store all of debugger's information

        Returns
        ----------
        No returns
        """
        if TikSocManager.is_v300_610l_soc():
            context.step_next(self.source_id)
            return
        mask_arr = self.get_mask_arr(context)
        mask_l = mask_arr[0]
        mask_h = mask_arr[1]
        context.model.write_spr('CMPMASK0', mask_l)
        context.model.write_spr('CMPMASK1', mask_h)

    def get_mask_arr(self, context):
        """
        get mask arr
        Parameters
        ----------
        context: tik context

        Returns
        -------

        """
        cmp_bit_len = 8
        cmp_mask_count = 2
        tensor_buffer = context.tensor_buffer.get_npbuffer_by_tvmbuffer(self.src.buffer).buffer
        flatten_np = tensor_buffer.reshape(-1).view(self.src.dtype)
        flatten_idx = get_flatten_idx(self.src, context)

        TikCheckUtil.check_type_match(flatten_np.dtype, np.dtype, "Tensor buffer in debug flow should be numpy.ndarray")

        # each CMPMASK is 8-byte long, we need to fullfill two CMPMASK

        extent = cmp_mask_count * cmp_bit_len // flatten_np.dtype.itemsize
        TikCheckUtil.check_le(flatten_idx + extent, flatten_np.size, "AccessViolation: read src tensor out of range")

        mask_arr = flatten_np[flatten_idx:flatten_idx + extent].view(dtype=np.uint64)
        TikCheckUtil.check_equality(len(mask_arr), cmp_mask_count, "Bitwidth not match!")
        return mask_arr


class VMS4SR2Scalar(STMT):
    """
    VMS4SR2Scalar instruction
    """

    def __init__(self, source_info, scalar_arr, tik_debugger):
        super(VMS4SR2Scalar, self).__init__(source_info, tik_debugger)
        self.scalar_arr = scalar_arr

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        self.update_debug_var(context)

    def update_debug_var(self, context):
        """
        update debug var
        Parameters
        ----------
        context: context

        Returns
        -------

        """
        sr_value = context.model.read_spr('VMS4_SR')
        # vms4 bit shift
        value = 2 ** 13 - 1
        # bit shift unit for vms4 is 13
        bit_len = 13
        for i, scalar in enumerate(self.scalar_arr):
            temp_value = (sr_value >> (i * bit_len)) & value
            offset = context.evaluate_expr(scalar.offset)
            context.update_var(scalar.debug_var[offset], temp_value)
            tvm_temp_value = make_tvm_imm(scalar.dtype, temp_value)
            context.update_var_to_vm(scalar.reg_buffer.asobject(), tvm_temp_value, offset=offset)


class WriteSPR(STMT):
    """
    WriteSPR instruction
    """

    def __init__(self, source_info, spr_name, value, tik_debugger):
        super(WriteSPR, self).__init__(source_info, tik_debugger)
        self.spr_name = spr_name
        self.value = value

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        self.write_spr(context)

    def write_spr(self, context):
        """
        write value to spr
        Parameters
        ----------
        context

        Returns
        -------

        """
        value = context.evaluate_expr(self.value)
        np_value = np.asarray(value)
        value = cvt_float_to_uint(str(np_value.dtype), np_value)
        context.model.write_spr(self.spr_name, value)


class SetRpnOffset(STMT):
    """
    Set rpn offset debug evaluate
    """
    def __init__(self, source_info, rpn_offset, offset_dtype, tik_debugger):
        super(SetRpnOffset, self).__init__(source_info, tik_debugger)
        self.rpn_offset = rpn_offset
        self.offset_dtype = offset_dtype

    @staticmethod
    def set_rpn_offset(offset_dtype, rpn_offset, context):
        """
        Set rpn offset
        """
        rpn_offset = context.evaluate_expr(rpn_offset)
        bin_value = cvt_float_to_uint(offset_dtype, rpn_offset)
        # if RPN_OFFSET support float32, float32 in RPN_OFFSET[48:16] bits
        if offset_dtype == 'float32':
            bin_value = bin_value << 16

        context.model.write_spr('RPN_OFFSET', bin_value)

    def eval_(self, context):
        """
        run the SetRpnOffset eval_
        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        self.set_rpn_offset(self.offset_dtype, self.rpn_offset, context)
