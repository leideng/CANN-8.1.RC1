#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     pvmodel_common.py
DESC:     common function for tik pvmodel
CREATED:  2021-08-29 19:02:50
MODIFIED: 2020-08-30 15:03:50
"""
import os

from ctypes import Structure
from ctypes import c_int
from ctypes import c_bool
from ctypes import c_uint64
from ctypes import POINTER
from ctypes import cdll

from tbe.common.platform import scope_cc
from tbe.common.platform import scope_cbuf
from tbe.common.platform import scope_cb
from tbe.common.platform import scope_ca
from tbe.common.platform import scope_ubuf
from tbe.common.platform import scope_gm
from tbe.common.platform import scope_fb0
from tbe.common.platform import scope_bt

from tbe.tik.common.tik_api_map import ASCEND_910
from tbe.tik.common.tik_api_map import BS9SX1A
from tbe.tik.common.tik_api_map import ASCEND_310P
from tbe.tik.common.tik_api_map import ASCEND_910B
from tbe.tik.common.tik_api_map import ASCEND_910_93
from tbe.tik.common.tik_api_map import ASCEND_310B
from tbe.tik.common.tik_api_map import ASCEND_310M
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil


def _get_soc_model_path(soc_name):
    if soc_name in [ASCEND_910, BS9SX1A]:
        soc_path = soc_name + "A"
    elif soc_name in [ASCEND_310P, ASCEND_910B, ASCEND_310B, ASCEND_310M]:
        soc_path = soc_name + '1'
    elif soc_name == ASCEND_910_93:
        soc_path = ASCEND_910B + '1'
    else:
        soc_path = soc_name
    return soc_path


class PVModelBase:
    """
    parent class of pvmodel
    """

    def __init__(self):
        self._config_file = None
        self._dll = None

    @staticmethod
    def get_access_list_depthwise_conv(mem_access_list):
        """
        Get the access list according the pvmodel access result for depthewise_conv
        Parameters
        ----------
        mem_access_list: pvmodel access result

        Returns
        -------
        access_list: a list record the write buffer info

        """
        ret = mem_access_list.contents
        num = ret.len
        ret_list = ret.list
        ret_access_list = []

        access_list = []
        last_mem_scope = ""
        # for improve the debug performance, here only get the first and last read buffer info
        for index in range(0, num):
            c_ptr = ret_list[index]
            new_mem_scope = c_ptr.mem_scope
            if last_mem_scope != new_mem_scope:
                if last_mem_scope != "":
                    last_c_ptr = ret_list[index - 1]
                    access_list.append(
                        PyMemAccess(last_mem_scope, last_c_ptr.is_read, last_c_ptr.addr, last_c_ptr.size))
                    ret_access_list.append(access_list)
                    access_list = []

                access_list.append(PyMemAccess(new_mem_scope, c_ptr.is_read, c_ptr.addr, c_ptr.size))
                last_mem_scope = new_mem_scope
        if last_mem_scope != "":
            last_c_ptr = ret_list[num - 1]
            access_list.append(PyMemAccess(last_mem_scope, last_c_ptr.is_read, last_c_ptr.addr, last_c_ptr.size))
            ret_access_list.append(access_list)
        return ret_access_list

    @staticmethod
    def _merge_access_list(tensor_nums, first_list, last_list, access_list):
        """
        merge the two access info list
        Parameters
        ----------
        tensor_nums: dst or src tensor nums of one instruction
        first_list: access info list
        last_list: access info list
        access_list: access info save result

        Returns
        -------
        None
        """
        if len(last_list) == len(first_list) and len(last_list) == tensor_nums:
            for index, item in enumerate(first_list):
                access_list.append([item, last_list[tensor_nums - 1 - index]])
        else:
            for index, item in enumerate(first_list):
                access_list.append([item])

    @staticmethod
    def _get_write_access_list(mem_access_list, access_list):
        """
        Get the write access list according the pvmodel access result
        Parameters
        ----------
        mem_access_list: pvmodel access result
        access_list: result for save access info

        Returns
        -------

        """
        ret = mem_access_list.contents
        num = ret.len
        ret_list = ret.list
    
        write_list = []
        # for improve the debug performance, here only get the first and last write buffer info
        # get first write info
        for index in range(num):
            c_ptr = ret_list[index]
            if c_ptr.is_read is False:
                write_list.append(PyMemAccess(c_ptr.mem_scope, c_ptr.is_read, c_ptr.addr, c_ptr.size))
                break
    
        # get last write info
        for index in range(num - 1, 0, -1):
            c_ptr = ret_list[index]
            if c_ptr.is_read is False:
                write_list.append(PyMemAccess(c_ptr.mem_scope, c_ptr.is_read, c_ptr.addr, c_ptr.size))
                break
        access_list.append(write_list)
    
    def get_access_list(self, mem_access_list, check_read, src_tensor_nums):
        """
        Get the access list according the pvmodel access result
        Parameters
        ----------
        mem_access_list: pvmodel access result
        check_read: whether check read mem access info
        src_tensor_nums: src tensor nums of the instruction

        Returns
        -------
        access_list: a list record the write buffer info

        """
        access_list = []
        if check_read is True:
            self._get_read_access_list(mem_access_list, src_tensor_nums, access_list)
        self._get_write_access_list(mem_access_list, access_list)
        return access_list

    def get_access_list_vnchwconv(self, mem_access_list, tensor_nums_list):
        """
        Get the access list according the pvmodel access result for vnchwconv
        Parameters
        ----------
        mem_access_list: pvmodel access result
        tensor_nums_list: [src_tensor_nums, dst_tensor_nums]

        Returns
        -------
        access_list: a list record the write buffer info

        """
        access_list = []
        src_tensor_nums, dst_tensor_nums = tensor_nums_list
        self._get_read_access_list(mem_access_list, src_tensor_nums, access_list)
        self._get_write_access_list_vnchwconv(mem_access_list, dst_tensor_nums, access_list)
        return access_list

    def get_pvmodel_path(self, config_file_name, llt_pvmodel_name):
        """
        get pvmodel path

        Parameters
        ----------
        config_file_name: config file
        llt_pvmodel_name: lib file's name

        Returns
        -------
        pvmodel_name
        """
        pvmodel_name = 'lib_pvmodel.so'
        pvmodel_path = ""
        toolchain_home = os.environ.get("TOOLCHAIN_HOME", None)
        if toolchain_home is not None:
            toolchain_home = os.path.realpath(toolchain_home)
            if not os.path.isdir(toolchain_home):
                TikCheckUtil.raise_warning(
                    'System environment variable \'TOOLCAHIN_HOME\' is not a directory, please set it with '
                    'toolkit install root dir: export TOOLCHAIN_HOME=/xxx/yyy/toolkit, will use %s '
                    'in \'LD_LIBRARY_PATH\'' % llt_pvmodel_name)
            else:
                soc_version = _get_soc_model_path(get_soc_name())
                pvmodel_path = "%s%s%s%s" % (toolchain_home, "/tools/simulator/", soc_version, "/lib/")
                self._config_file = "%s%s" % (pvmodel_path, config_file_name)
                # check whether the config file is exist
                if not os.path.isfile(self._config_file):
                    self._config_file = None
                # check the pvmodel whether is exist
                if os.path.isfile("%s%s" % (pvmodel_path, llt_pvmodel_name)):
                    pvmodel_name = llt_pvmodel_name
                elif not os.path.isfile("%s%s" % (pvmodel_path, pvmodel_name)):
                    pvmodel_path = ""
                    TikCheckUtil.raise_warning(
                        "Cannot find %s in system environment variable \'TOOLCHAIN_HOME\', "
                        "will use lib_pvmodel.so in \'LD_LIBRARY_PATH\'" % llt_pvmodel_name)
        pvmodel_name = "%s%s" % (pvmodel_path, pvmodel_name)
        return pvmodel_name

    def load_pvmodel_capture(self, config_file_name, llt_pvmodel_name):
        """
        capture error when load pvmodel

        Parameters
        ----------
        config_file: config file
        lib_name: lib file's name

        Returns
        -------
        None
        """
        pvmodel_name = self.get_pvmodel_path(config_file_name, llt_pvmodel_name)

        for name in (pvmodel_name, llt_pvmodel_name):
            try:
                self._dll = cdll.LoadLibrary(name)
            except OSError:
                # load current pvmodel_so fail, continue to next
                continue
            else:
                # load pvmodel_so success, end
                break
        else:
            # all load pvmodel_so fail, raise error
            TikCheckUtil.raise_error('%s: cannot open shared object file, cannot find it in system '
                                     'environment variable \'TOOLCHAIN_HOME\' or \'LD_LIBRARY_PATH\''
                                     % llt_pvmodel_name,
                                     exception_type=OSError)

    def _get_read_access_list(self, mem_access_list, src_tensor_nums, access_list):
        """
        get the mem access info of read
        Parameters
        ----------
        mem_access_list: mem access result of pvmodel
        src_tensor_nums: src tensor nums
        access_list: result for save access info

        Returns
        -------

        """
        ret = mem_access_list.contents
        num = ret.len
        ret_list = ret.list
        first_read_list = []
        get_read_nums = 0
        # for improve the debug performance, here only get the first and last read buffer info
        for index in range(0, num):
            c_ptr = ret_list[index]
            if c_ptr.is_read is True:
                first_read_list.append(PyMemAccess(c_ptr.mem_scope, c_ptr.is_read, c_ptr.addr, c_ptr.size))
                get_read_nums += 1
            if get_read_nums >= src_tensor_nums:
                break

        last_read_list = []
        get_read_nums = 0
        for index in range(num - 1, src_tensor_nums, -1):
            c_ptr = ret_list[index]
            if c_ptr.is_read is True:
                last_read_list.append(PyMemAccess(c_ptr.mem_scope, c_ptr.is_read, c_ptr.addr, c_ptr.size))
                get_read_nums += 1
            if get_read_nums >= src_tensor_nums:
                break

        # merge read access info list
        self._merge_access_list(src_tensor_nums, first_read_list, last_read_list, access_list)

    def _get_write_access_list_vnchwconv(self, mem_access_list, dst_tensor_nums, access_list):
        """
        Get the write access list for vnchwconv
        Parameters
        ----------
        mem_access_list: pvmodel access result
        dst_tensor_nums: dst tensor nums of vnchwconv
        access_list: result for save access info

        Returns
        -------

        """
        ret = mem_access_list.contents
        num = ret.len
        ret_list = ret.list
        first_write_list = []
        get_write_nums = 0
        # for improve the debug performance, here only get the first and last write buffer info
        # get first write info
        for index in range(0, num, 8):
            c_ptr = ret_list[index]
            if c_ptr.is_read is False:
                first_write_list.append(PyMemAccess(c_ptr.mem_scope, c_ptr.is_read, c_ptr.addr, c_ptr.size))
                get_write_nums += 1
            if get_write_nums >= dst_tensor_nums:
                break

        last_write_list = []
        get_write_nums = 0
        # get last write info
        for index in range(num - 1, 0, -8):
            c_ptr = ret_list[index]
            if c_ptr.is_read is False:
                last_write_list.append(PyMemAccess(c_ptr.mem_scope, c_ptr.is_read, c_ptr.addr, c_ptr.size))
                get_write_nums += 1
            if get_write_nums >= dst_tensor_nums:
                break

        # merge write list
        self._merge_access_list(dst_tensor_nums, first_write_list, last_write_list, access_list)


class PvMemAccess(Structure):
    """
    memory object
    """
    _fields_ = [
        ('mem_scope', c_int),
        ('is_read', c_bool),
        ('addr', c_uint64),
        ('size', c_uint64)
    ]


class PVMemAccessList(Structure):
    """
    memory object list
    """
    _fields_ = [
        ('list', POINTER(PvMemAccess)),
        ('len', c_int)
    ]


class PyMemAccess:
    """
    python memory object
    """
    def __init__(self, scope, mode, addr, size):
        if TikSocManager.is_910b_soc() or TikSocManager.is_310b_610l_soc():
            r_scope_mapping = {
                0: scope_gm,
                1: scope_cbuf,
                2: scope_ca,
                3: scope_cb,
                4: scope_cc,
                5: scope_ubuf,
                6: scope_fb0,
                10: scope_bt,
            }
        else:
            r_scope_mapping = {
                0: scope_gm,
                1: scope_cbuf,
                2: scope_ca,
                3: scope_cb,
                4: scope_cc,
                5: scope_ubuf,
                6: 'local.SB',
                7: 'local.L0A_WINO',
                8: 'local.L0B_WINO'
            }
        self.scope = r_scope_mapping[scope]
        self.mode = 'r' if mode else 'w'
        self.addr = addr
        self.size = size

    def __str__(self):
        return '[MemAccess]scope:%s mode:%s addr:%s size:%s'\
            % (self.scope, self.mode, self.addr, self.size)
