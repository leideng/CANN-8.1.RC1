#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     intrinsic_cube.py
DESC:     debug intrinsic for cube api
CREATED:  2022-4-30 10:12:13
MODIFIED: 2022-4-30 10:53:13
"""
from collections import namedtuple
import numpy as np
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.util import copy_tensor_to_model
from tbe.tik.debug.util import model_with_env
from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.common.common_util import dma_align_fn
from tbe.tik.common.util import reduce_mul, DTYPE_SIZE
from tbe.tik.debug.intrinsic import get_src_dst_mem_id
from tbe.tik.debug.intrinsic import get_dst_mem_id
from tbe.tik.debug.data_move_intrinsic import NBURST_SHIFT_BIT_POS
from tbe.tik.debug.data_move_intrinsic import BURST_SHIFT_BIT_POS
from tbe.tik.debug.data_move_intrinsic import SRC_STRIDE_SHIFT_BIT_POS
from tbe.tik.tik_lib.tik_check_util import TIK_ERROR_MSG
from tbe.tik.tik_lib.tik_source_info import TikSourceInfo
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager


class MoveBiasToBt(STMT):
    """
    GetStatusSPR instruction
    """
    move_bias_args = namedtuple('MoveBiasArg', ["bias_l1", "bias_bt", "extent", "conv_control"])

    def __init__(self, source_info, move_args, tik_debugger):
        super(MoveBiasToBt, self).__init__(source_info, tik_debugger)
        self.bias = move_args.bias_l1
        self.bias_tensor_bt = move_args.bias_bt
        self.extent = move_args.extent
        self.conv_control = move_args.conv_control

    def _generate_instruction(self, param):
        instr = 0x70000000
        # 610l, instr[1:0] -> type f32: 2'b00, s32: 2'b01
        if TikSocManager.is_610l_soc() and self.bias_tensor_bt.dtype == "int32":
            instr = 0x70000001
        instr |= param.srcMemId << 23
        instr |= param.xd << 17
        instr |= param.xn << 12
        instr |= param.xm << 7
        instr |= param.dstMemId << 3
        return instr

    def create_gpr_xn_xd(self, context, temp_env):
        """
        create_gpr_xn_xd
        """
        src_align = 32  # src is L1, L1 align is 32Bytes
        dst_align = 64  # dst is BT, bt align is 64Bytes
        xn_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.bias, src_align, access_mode='r')
        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.bias_tensor_bt, dst_align, access_mode='w')
        return [xn_idx, xd_idx, dst_addr, dst_alloc_size, dst_ptr]

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        is_set_source_info = False
        if TIK_ERROR_MSG.api_source_info is None:
            TikSourceInfo.register_source_info(source_info=self.source_info)
            is_set_source_info = True

        temp_env = TempEnv(is_aic_api=True)
        xn_idx, xd_idx, dst_addr, dst_alloc_size, dst_ptr = self.create_gpr_xn_xd(context, temp_env)
        src_mem_id, dst_mem_id, _ = get_src_dst_mem_id(self.bias, self.bias_tensor_bt)
        encoder = context.encoder
        param = encoder.new_param()
        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = self._create_gpr_xm(context, temp_env)
        param.srcMemId = src_mem_id
        param.dstMemId = dst_mem_id

        instr = self._generate_instruction(param)
        model_with_env(context.model.step, temp_env, instr)
        dst_scope = self._get_dst_scope(temp_env, context)
        model_with_env(context.model.read_memory, temp_env, dst_addr, dst_scope, dst_ptr, dst_alloc_size)

        if is_set_source_info:
            TikSourceInfo.clear_source_info()

    def _create_gpr_xm(self, context, temp_env):
        xm_idx = temp_env.alloc_register()
        # burst length is in unit of 64B on v220/v300, and 32B on 610l
        burst_len_unit = 64 if not TikSocManager.is_610l_soc() else 32
        burst_len = context.evaluate_expr(self.extent) // burst_len_unit
        xm_v = 0
        xm_v |= self.conv_control << 3 # conv control bit
        xm_v |= 1 << 4  # burst number
        xm_v |= burst_len << 16
        model_with_env(context.model.write_gpr, temp_env, xm_idx, xm_v)
        return xm_idx

    def _get_dst_scope(self, temp_env, context):
        dst_scope = self.bias_tensor_bt.scope
        temp_env.check_mem_access(context.model, True)
        return dst_scope


def _convert_deqvalue_to_uint64(deq_value):
    """
    convert input deq value of float32 to uint64, DEQ_PRE buffer save the value is uint64 format
    :param deq_value: input deq value of fp32
    :return: deq value of uint64
    """
    deq_value_int32 = np.float32(deq_value).view("uint32")
    deq_value_uint64 = np.uint64(deq_value_int32)
    # deq factor of uint64 bits describe: bits[0:31] is deq value of fp32,
    # bits[32:35] is right move size, bits[36] is mcd control bit
    deq_value_uint64 = deq_value_uint64 & 0xFFFFFFE0FFFFFFFF
    return deq_value_uint64


class FixpipeV2(STMT):
    """
    GetStatusSPR instruction
    """

    def __init__(self, source_info, fixpipe_vdeq_params, tik_debugger):
        super(FixpipeV2, self).__init__(source_info, tik_debugger)
        self.fixpipe_config = fixpipe_vdeq_params.fixpipe_config
        self.fixpipe_api = fixpipe_vdeq_params.fixpipe_api
        self.n_size = fixpipe_vdeq_params.n_size
        self.src_offset = fixpipe_vdeq_params.src_offset
        self.dst_offset = fixpipe_vdeq_params.dst_offset

    @staticmethod
    def _generate_instruction(param):
        instr_code = 0b110000 << 26
        instr_code |= param.dstMemId << 24
        instr_code |= param.xd << 17
        instr_code |= param.xn << 12
        instr_code |= param.xm << 7
        instr_code |= param.xt << 2
        instr_code |= param.type
        return instr_code

    def create_gpr_xn_xd(self, context, temp_env):
        """
        create_gpr_xn_xd
        """
        src_align, dst_align = dma_align_fn(self.fixpipe_api.src, self.fixpipe_api.dst)
        src_start_index = context.evaluate_expr(self.src_offset)
        dst_start_index = context.evaluate_expr(self.dst_offset)
        xn_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.fixpipe_api.src[src_start_index:], src_align, access_mode='r')
        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.fixpipe_api.dst[dst_start_index:], dst_align, access_mode='w')

        return [xn_idx, xd_idx, dst_addr, dst_alloc_size, dst_ptr]

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        is_set_source_info = False
        if TIK_ERROR_MSG.api_source_info is None:
            TikSourceInfo.register_source_info(source_info=self.source_info)
            is_set_source_info = True
        params_value = self._get_value(context)
        self.fixpipe_config.evaluate_expr(context)
        # check params
        from tbe.tik.debug.data_move_intrinsic import _get_locked, _release_lock
        temp_env = TempEnv(is_aic_api=True)
        locked = False
        try:
            locked = _get_locked(context, self.fixpipe_api.dst)
            xn_idx, xd_idx, dst_addr, dst_alloc_size, dst_ptr = self.create_gpr_xn_xd(context, temp_env)
            encoder = context.encoder
            param = encoder.new_param()
            param.xd = xd_idx
            param.xn = xn_idx
            param.xm = self._create_gpr_x_m(context, temp_env)
            param.xt = self._create_gpr_xt(context, temp_env)
            param.dstMemId = get_dst_mem_id(self.fixpipe_api.dst)
            dtype_map = {"float32": 0, "int32": 1, "float16": 2}
            param.type = dtype_map.get(self.fixpipe_api.src.dtype)

            instr = self._generate_instruction(param)
            model_with_env(context.model.step, temp_env, instr)
            dst_scope = self._get_dst_scope(temp_env, context)
            model_with_env(context.model.read_memory, temp_env, dst_addr, dst_scope, dst_ptr, dst_alloc_size)
            from tbe.tik.debug.data_move_intrinsic import context_append_access_list
            context_append_access_list(
                context, locked, self.fixpipe_api.dst, [params_value.get('cburst_num'),
                                                        params_value.get('burst_len'),
                                                        params_value.get('dst_stride')])
        finally:
            _release_lock(context, locked)
            if is_set_source_info:
                TikSourceInfo.clear_source_info()

    def _get_value(self, context):
        cburst_num = context.evaluate_expr(self.fixpipe_api.cburst_num)
        burst_len = context.evaluate_expr(self.fixpipe_api.burst_len)
        if TikSocManager.is_310b_610l_soc():
            # is 310b soc, dst_stride in unit of element, input dst_stride in unit of 32B.
            dst_stride = context.evaluate_expr(self.fixpipe_api.dst_stride *
                                               ONE_BLK_SIZE // DTYPE_SIZE[self.fixpipe_api.dst.dtype])
        else:
            # is 910b soc, dst_stride in unit of 32B, input dst_stride in unit of 32B.
            dst_stride = context.evaluate_expr(self.fixpipe_api.dst_stride)
        src_stride = context.evaluate_expr(self.fixpipe_api.src_stride)
        input_params = {"cburst_num": cburst_num, "burst_len": burst_len,
                        "dst_stride": dst_stride, "src_stride": src_stride}
        return input_params

    def _create_gpr_x_m(self, context, temp_env):
        """
        create register x_m

        Parameters
        ----------
        context : the stack context
        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        xm_idx = temp_env.alloc_register()
        xm_v = 0
        xm_v |= self.fixpipe_config.sid
        xm_v |= context.evaluate_expr(self.n_size) << NBURST_SHIFT_BIT_POS
        xm_v |= self.fixpipe_config.m_size << BURST_SHIFT_BIT_POS
        if TikSocManager.is_310b_610l_soc():
            # is 310b soc, dst_stride in unit of element, input dst_stride in unit of 32B.
            xm_v |= self.fixpipe_config.dst_stride * ONE_BLK_SIZE // \
                    DTYPE_SIZE[self.fixpipe_api.dst.dtype] << SRC_STRIDE_SHIFT_BIT_POS
        else:
            # is 910b soc, dst_stride in unit of 32B, input dst_stride in unit of 32B.
            xm_v |= self.fixpipe_config.dst_stride << SRC_STRIDE_SHIFT_BIT_POS
        model_with_env(context.model.write_gpr, temp_env, xm_idx, xm_v)
        return xm_idx

    def _get_deq_mode(self):
        deq_mode = self.fixpipe_config.quant_mode
        deq_mode_value = {"NoQuant": 0, "F322F16": 1, "VDEQF16": 10, "DEQF16": 11}
        return deq_mode_value.get(deq_mode, 0)

    def _create_gpr_xt(self, context, temp_env):
        """
        create register x_m

        Parameters
        ----------
        context : the stack context
        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        xt_idx = temp_env.alloc_register()
        unit_flag_pos = 32
        deq_pos = 34
        relu_pos = 39
        split_pos = 42
        nz2nd_pos = 43

        xt_v = 0
        xt_v |= self.fixpipe_config.src_stride
        xt_v |= self.fixpipe_config.unit_flag_mode << unit_flag_pos
        xt_v |= self._get_deq_mode() << deq_pos
        xt_v |= self.fixpipe_config.relu << relu_pos
        xt_v |= self.fixpipe_config.channel_split << split_pos
        xt_v |= self.fixpipe_config.nz2nd_mode << nz2nd_pos
        model_with_env(context.model.write_gpr, temp_env, xt_idx, xt_v)
        return xt_idx

    def _get_dst_scope(self, temp_env, context):
        dst_scope = self.fixpipe_api.dst.scope
        temp_env.check_mem_access(context.model, True)
        return dst_scope


class SetQuantPre(STMT):
    """
    set quant pre
    """
    def __init__(self, source_info, fixpipe_config, tik_debugger):
        super(SetQuantPre, self).__init__(source_info, tik_debugger)
        self.fixpipe_config = fixpipe_config

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        temp_env = TempEnv(is_aic_api=True)
        deq_value = context.evaluate_expr(self.fixpipe_config.deq_value)
        deq_value = _convert_deqvalue_to_uint64(deq_value)
        model_with_env(context.model.write_spr, temp_env, "QUANT_PRE", deq_value)


class Cbuf2Fbuf(STMT):
    """
    move tensor GM->FB0, copy tensor to model, write FPC
    """

    def __init__(self, source_info, copy_deq_tensor_params, deq_value_offset, tik_debugger):
        super(Cbuf2Fbuf, self).__init__(source_info, tik_debugger)
        self.fixpipe_tensor = copy_deq_tensor_params.fixpipe_tensor
        self.fixpipe_config = copy_deq_tensor_params.fixpipe_config
        self.n_size = copy_deq_tensor_params.n_size
        self.n_iter_index = copy_deq_tensor_params.n_iter_index
        self.deq_value_offset = deq_value_offset

    def create_gpr_xn_xd(self, context, temp_env):
        """
        create_gpr_xn_xd
        """
        src_align, dst_align = 32, 128
        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.fixpipe_tensor, dst_align, access_mode='w')
        return [xd_idx, dst_addr, dst_alloc_size, dst_ptr]

    def check_deq(self, context, deq_tensor):
        cburst_num = context.evaluate_expr(self.fixpipe_config.fixpipe_api.cburst_num)
        extent_ele = cburst_num * 16
        total_ele = context.evaluate_expr(reduce_mul(deq_tensor.original_shape))
        deq_offset = context.evaluate_expr(deq_tensor.offset)
        need_ele = context.evaluate_expr(deq_offset + extent_ele)
        if total_ele is not None and need_ele is not None:
            TikCheckUtil.check_ge(
                total_ele, need_ele,
                "deq tensor overflow, expected elements: %s, "
                "actual elements: %s" % (need_ele, total_ele))

    def eval_(self, context):
        """
        :param context:
        :return:
        """
        temp_env = TempEnv(is_aic_api=True)
        deq_tensor = self.fixpipe_config.deq_value
        self.check_deq(context, deq_tensor)
        deq_tensor = self.fixpipe_config.deq_value
        deq_buffer = context.tensor_buffer.get_npbuffer_by_tvmbuffer(deq_tensor.buffer).buffer.reshape(-1)
        fixpipe_buffer = context.tensor_buffer.get_npbuffer_by_tvmbuffer(self.fixpipe_tensor.buffer).buffer.reshape(-1)
        n_size = context.evaluate_expr(self.n_size)
        n_iter_index = context.evaluate_expr(self.n_iter_index)
        if self.deq_value_offset is None:
            deq_value_offset = n_size * n_iter_index
        else:
            deq_value_offset = context.evaluate_expr(self.deq_value_offset)
        for i in range(n_size):
            fixpipe_buffer[i] = _convert_deqvalue_to_uint64(deq_buffer[i + deq_value_offset])
        src_align, dst_align = 32, 128
        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.fixpipe_tensor, dst_align, access_mode='w')
        model_with_env(context.model.write_spr, temp_env, "FPC", dst_addr)