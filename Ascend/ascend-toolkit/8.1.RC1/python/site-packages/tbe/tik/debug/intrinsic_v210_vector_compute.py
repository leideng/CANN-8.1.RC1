#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     intrinsic_v210_vector_compute.py
DESC:     v210 vector compute class
CREATED:  2021-11-25 20:37
MODIFIED: 2021-11-25 20:37
"""
import copy
from tbe.tik.api.tik_vector import Vector
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.common_util import check_extent_overflow
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_check_util import print_error_msg
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.util import copy_tensor_to_model
from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.debug.util import get_flatten_idx
from tbe.tik.debug.util import VecRegType
from tbe.tik.debug.intrinsic_v210_common import VLOOPN_TYPE
from tbe.tik.debug.intrinsic_v210_common import dst_register_vcvt
from tbe.tik.debug.intrinsic_v210_common import V300_INSTR_OP1_CODE
from tbe.tik.debug.intrinsic_v210_common import VEC_TYPE_BITS
from tbe.tik.debug.intrinsic_v210_common import FIFR1_TYPE
from tbe.tik.debug.intrinsic_v210_common import VMADD_TYPE_BITS
from tbe.tik.debug.intrinsic_v210_common import VAVG_TYPE_BITS
from tbe.tik.debug.intrinsic_v210_common import VCI_TYPE_BITS
from tbe.tik.debug.intrinsic_v210_common import VRND_VRNDS_TYPE_BITS
from tbe.tik.debug.intrinsic_v210_common import VEC_TYPE_THREE_BITS
from tbe.tik.debug.intrinsic_v210_common import VPACK_TYPE_BITS
from tbe.tik.debug.intrinsic_v210_common import VUNPACK_TYPE_BITS
from tbe.tik.debug.intrinsic_v210_common import SOURCE_REGISTER1
from tbe.tik.debug.intrinsic_v210_common import PARAMETERS
from tbe.tik.debug.intrinsic_v210_common import V210_INSTR_OP1_CODE
from tbe.tik.debug.intrinsic_v210_common import V300_INSTR_REGTYPE_CODE
from tbe.tik.debug.intrinsic_v210_common import VFCVT_VSFCVT_RND_TYPE
from tbe.tik.debug.intrinsic_v210_common import VFCVT_VSFCVT_PART_TYPE
from tbe.tik.debug.intrinsic_v210_common import _VCVT_VSCVT_OP2_CODE
from tbe.tik.debug.intrinsic_v210_common import VCVT_VFCVT_PART
from tbe.tik.debug.intrinsic_v210_common import VCVT_VFCVT_PP
from tbe.tik.debug.intrinsic_v210_common import VFCVT_VSFCVT_R_O_Z
from tbe.tik.debug.intrinsic_v210_common import VFCVT_VSFCVT_RND
from tbe.tik.debug.intrinsic_v210_common import VTRC_OP2_TYPE
from tbe.tik.debug.intrinsic_v210_common import get_and_write_share_spr
from tbe.tik.debug.intrinsic_v210_common import gen_vag_instr
from tbe.tik.debug.intrinsic_v210_common import set_param_loop_vex_num_dtype
from tbe.tik.debug.intrinsic_v210_common import create_vloop_info
from tbe.tik.debug.intrinsic_v210_common import execute_all_instr
from tbe.tik.debug.intrinsic_v210_common import dst_register
from tbe.tik.debug.intrinsic_v210_common import V300_VM_IDX
from tbe.tik.debug.intrinsic_v210_common import VCVT_PART_V300
from tbe.tik.debug.intrinsic_v210_common import VCVT_TYPE_V300
from tbe.tik.debug.intrinsic_v210_common import vcmax_vcmin_merging_v300


vcvt_type_tuple = ("f322s64", "f322s32", "f322s16", "f162s32", "f162s16", "f162s8", "f162u8", "f162s4",
                   "bf162s32", "f322bf16", "f322bf16", "s162f16", "s322f32", "s642f32")


class VectorVpackVunpack(STMT):
    """
    Vector vpack/vzunpack/vsunpack instruction
    """

    def __init__(self, source_info, unpack_params, tik_debugger):
        super(VectorVpackVunpack, self).__init__(source_info, tik_debugger)
        self.dst = unpack_params.dst  # Vd
        self.src = unpack_params.src  # Vn
        self.part_mode = 0
        if unpack_params.part_mode is True:
            self.part_mode = 1
        self.instr_name = unpack_params.name

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param

        Returns
        -------

        """

        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx

        vn_idx = context.alloc_v_register(self.src)
        param.vnIdx = vn_idx

        # vmIdx is not real register index, only for pass parameter
        param.vmIdx = SOURCE_REGISTER1.get(self.instr_name)
        return param, vd_idx

    def eval_(self, context):
        """
        Vector VpackVunpack eval
        Parameters
        ----------
        context: tik context

        Returns
        -------
        no returns
        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.src.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)
        if TikSocManager.is_v300_610l_soc():
            param.part = self.part_mode
            if self.instr_name == "vectorized_vpack":
                param.type = VEC_TYPE_BITS.get(self.src.dtype)
                param.op1 = 0b0110
            else:
                if self.src.dtype in ["uint8", "uint16"]:
                    param.type = VEC_TYPE_BITS.get(self.src.dtype)
                    param.op1 = 0b1000
                elif self.src.dtype in ["int8", "int16"]:
                    param.type = FIFR1_TYPE.get(self.src.dtype)
                    param.op1 = 0b1001
        else:
            if self.instr_name == "vectorized_vpack":
                param.type = VPACK_TYPE_BITS.get(self.src.dtype) | self.part_mode << 1
            else:
                param.type = VUNPACK_TYPE_BITS.get(self.src.dtype) | self.part_mode << 1
                if self.src.dtype in ["int8", "int16"]:
                    param.type |= 0b100
        param, vd_idx = self.set_param(context, param)

        instr = context.encoder.gen_vector_vpack_vunpack(param)
        execute_all_instr(context, instr_list, instr)
        if TikSocManager.is_v300_610l_soc() and self.instr_name == "vectorized_vpack":
            one_repeat_max_num = 256 // DTYPE_SIZE[self.dst.dtype] // 2
            self.vpack_v300_merging_mode(context, vd_idx, VecRegType.V_REG, one_repeat_max_num)
        elif TikSocManager.is_v300_610l_soc():
            dst_register(context, (self.dst, vd_idx, VecRegType.V_REG), is_merging=False)
        else:
            dst_register(context, (self.dst, vd_idx, VecRegType.V_REG))
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()

    def vpack_v300_merging_mode(self, context, vd_idx, vec_type, mask):
        """
        the merging mode if in v300
        Parameters
        ----------
        context: context
        vd_idx: dst register
        vec_type: register type
        mask: element of one repeat

        Returns
        -------
        None
        """
        dst_dtype_red = self.dst.dtype
        value_buffer1 = context.get_vector_value(self.dst).buffer
        flatten_np = value_buffer1.reshape(-1)

        value_buffer2 = copy.deepcopy(value_buffer1)
        flatten_np2 = value_buffer2.reshape(-1)
        context.model.read_vec_register_by_idx(vec_type, vd_idx, flatten_np.ctypes.data,
                                               len(flatten_np) * DTYPE_SIZE[dst_dtype_red])
        if self.part_mode:
            flatten_np[:mask] = flatten_np2[:mask]
        else:
            flatten_np[mask:] = flatten_np2[mask:]


class VectorVgather(STMT):
    """
    Vector vcmp instruction
    """

    def __init__(self, source_info, vgather_params, tik_debugger):
        super(VectorVgather, self).__init__(source_info, tik_debugger)
        self.dst = vgather_params.dst  # Pd
        self.src0 = vgather_params.src0  # Vn
        self.src1 = vgather_params.src1  # Vm
        self.instr_name = vgather_params.name
        self.src0_offset = None
        self.am_idx = None
        self.align = 32

    def set_param(self, context, param, temp_env):
        """
        set param
        Parameters
        ----------
        context
        param
        temp_env

        Returns
        -------

        """
        if self.instr_name == "vectorized_vgather2":
            src1_offset = get_flatten_idx(self.src1, context)
            old_check_align = temp_env.check_align
            temp_env.check_align = False
            _, src1_addr, _, _ = copy_tensor_to_model(context, temp_env, self.src1, self.align, access_mode='r')
            temp_env.check_align = old_check_align
            vl_t = 256 // DTYPE_SIZE.get(self.src0.dtype)
            check_extent_overflow(self.src0,
                                  vl_t * DTYPE_SIZE.get(self.src0.dtype),
                                  self.src0_offset, "src0")
            st_idx = get_and_write_share_spr(
                context, src1_addr + src1_offset * DTYPE_SIZE.get(self.src1.dtype),
                "uint32")
            param.stIdx = st_idx
            param.amIdx = self.am_idx << 2 | VEC_TYPE_BITS.get(self.src1.dtype)

        else:
            vl_t = 8
            check_extent_overflow(self.src0,
                                  vl_t * DTYPE_SIZE.get(self.src0.dtype),
                                  self.src0_offset, "src0")
            src1_value = context.evaluate_expr(self.src1)
            st_idx = get_and_write_share_spr(context, src1_value, "uint32")
            param.stIdx = st_idx
            param.amIdx = self.am_idx << 2 | 0b11

        return param

    def eval_(self, context):
        """
        Vector Vgather
        Parameters
        ----------
        context: tik context
        Returns
        -------
        no returns
        """
        temp_env = TempEnv(require_xt=False)
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 2)
        instr_list = create_vloop_info(context, param)

        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx

        for buffer, _ in context.buffer_cache.items():
            old_check_align = temp_env.check_align
            temp_env.check_align = False
            copy_tensor_to_model(context, temp_env, buffer, self.align, access_mode='r')
            temp_env.check_align = old_check_align
        self.src0_offset = get_flatten_idx(self.src0, context)
        _, src0_addr, _, _ = copy_tensor_to_model(
            context, temp_env, self.src0, self.align, access_mode='r')

        sn_idx = get_and_write_share_spr(
            context, src0_addr + self.src0_offset * DTYPE_SIZE.get(self.src0.dtype),
            "uint32")
        param.snIdx = sn_idx

        self.am_idx = context.alloc_a_register(self.src0)

        # gen vag instr for vloop
        vag_instr = gen_vag_instr(context, self.src0.dtype)
        instr_list.append(vag_instr)

        param = self.set_param(context, param, temp_env)

        instr = context.encoder.gen_vector_vgather(param)
        execute_all_instr(context, instr_list, instr)
        dst_register(context, (self.dst, vd_idx, VecRegType.V_REG), is_merging=False)
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()


class VectorVgatherV2(STMT):
    """
    Vector vcmp instruction
    """

    def __init__(self, source_info, vgather_params, tik_debugger):
        super(VectorVgatherV2, self).__init__(source_info, tik_debugger)
        self.dst = vgather_params.dst  # Pd
        self.src0 = vgather_params.src0  # Vn
        self.src1 = vgather_params.src1  # Vm
        self.instr_name = vgather_params.name
        self.src0_offset = None
        self.mask = vgather_params.mask
        self.align = 32

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param
        temp_env

        Returns
        -------

        """
        if self.instr_name == "vectorized_vgather2":
            pg_idx = context.alloc_p_register(self.mask, dtype=self.src1.dtype)
            param.pgIdx = pg_idx
            param.type = VEC_TYPE_BITS.get(self.src0.dtype)
            param.op1 = 0b00
        else:
            param.pgIdx = 0b000
            param.type = 0b00
            param.op1 = 0b10

        return param

    def eval_(self, context):
        """
        Vector Vgather
        Parameters
        ----------
        context: tik context
        Returns
        -------
        no returns
        """
        # check mask value
        if not isinstance(self.mask, Vector) and self.mask is not None:
            mask_value = context.evaluate_expr(self.mask)
            elements_per_repeat = 256 // DTYPE_SIZE.get(self.src1.dtype)
            if mask_value < 0 or mask_value > elements_per_repeat:
                print_error_msg("mask value is error, the value should be in range[0, %s]" % elements_per_repeat)

        temp_env = TempEnv(require_xt=False)
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 2)
        instr_list = create_vloop_info(context, param)

        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx

        for buffer, _ in context.buffer_cache.items():
            old_check_align = temp_env.check_align
            temp_env.check_align = False
            copy_tensor_to_model(context, temp_env, buffer, self.align, access_mode='r')
            temp_env.check_align = old_check_align
        self.src0_offset = get_flatten_idx(self.src0, context)
        _, src0_addr, _, _ = copy_tensor_to_model(
            context, temp_env, self.src0, self.align, access_mode='r')

        sn_idx = get_and_write_share_spr(
            context, src0_addr + self.src0_offset * DTYPE_SIZE.get(self.src0.dtype), "uint32")
        param.snIdx = sn_idx

        vn_idx = context.alloc_v_register(self.src1)
        param.vnIdx = vn_idx
        param = self.set_param(context, param)
        instr = context.encoder.gen_vector_vgather(param)

        execute_all_instr(context, instr_list, instr)
        dst_register(context, (self.dst, vd_idx, VecRegType.V_REG))
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()


class VectorRegTenaryElewise(STMT):
    """
    Vector vand/vor/vxor/vnand/vsel/vrnd/vmadd/vavg/vprelu/vsadd/vssub instruction
    """

    def __init__(self, source_info, vector_reg_params, rnd_mode, tik_debugger):
        super(VectorRegTenaryElewise, self).__init__(source_info, tik_debugger)

        self.dst = vector_reg_params.dst  # Vd
        self.src0 = vector_reg_params.src0  # Vn
        self.src1 = vector_reg_params.src1  # Vm
        self.mask = vector_reg_params.mask  # Pg
        instr_name = vector_reg_params.name
        if instr_name == "vectorized_vlrelu":
            instr_name = "vectorized_vprelu"
        self.instr_name = instr_name
        self.rnd = rnd_mode

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        if self.rnd is None:
            if self.instr_name == "vectorized_vprelu":
                # vprelu is different with others
                if TikSocManager.is_v300_610l_soc():
                    param.type = VEC_TYPE_THREE_BITS.get(self.dst.dtype)
                else:
                    param.type = VCI_TYPE_BITS.get(self.dst.dtype) | PARAMETERS.get(self.instr_name)
            elif self.instr_name == "vectorized_vmadd":
                param.type = VMADD_TYPE_BITS.get(self.dst.dtype) | PARAMETERS.get(self.instr_name)
            elif self.instr_name == "vectorized_vrnd" or self.instr_name == "vectorized_vrnds":
                param.type = VRND_VRNDS_TYPE_BITS.get(self.dst.dtype) | PARAMETERS.get(self.instr_name)
            else:
                param.type = VEC_TYPE_BITS.get(self.dst.dtype) | PARAMETERS.get(self.instr_name)
        else:
            if self.instr_name == "vectorized_vavg":
                param.type = VAVG_TYPE_BITS.get(self.dst.dtype) | (self.rnd << 2)
            else:
                param.type = VEC_TYPE_BITS.get(self.dst.dtype) | (self.rnd << 2)

        if TikSocManager.is_v300_610l_soc():
            #  just use part and op1 to pass param to encoder mode, not real index
            param.op1 = V300_INSTR_OP1_CODE.get(self.instr_name)
            param.regType = V300_INSTR_REGTYPE_CODE.get(self.instr_name)
        else:
            param.op1 = V210_INSTR_OP1_CODE.get(self.instr_name)
        pg_idx = context.alloc_p_register(self.mask, dtype=self.src0.dtype)
        param.pgIdx = pg_idx

        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx

        return param, vd_idx

    def eval_(self, context):
        """
        Vector RegTenaryElewise eval
        Parameters
        ----------
        context: context

        Returns
        -------
        no returns
        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)
        param, vd_idx = self.set_param(context, param)
        vn_idx = context.alloc_v_register(self.src0)
        param.vnIdx = vn_idx
        vm_idx = context.alloc_v_register(self.src1)
        param.vmIdx = vm_idx

        if TikSocManager.is_v300_610l_soc() and self.instr_name == "vectorized_vrnd":
            param.type = VCI_TYPE_BITS.get(self.dst.dtype)
        elif TikSocManager.is_v300_610l_soc() and self.instr_name == "vectorized_vavg":
            param.type = FIFR1_TYPE.get(self.dst.dtype) + (self.rnd << 2)
        elif TikSocManager.is_v300_610l_soc() and self.instr_name == "vectorized_vmadd":
            param.type = VEC_TYPE_THREE_BITS.get(self.dst.dtype)

        instr = context.encoder.gen_vector_reg_tenary_elewise(param)
        execute_all_instr(context, instr_list, instr)
        dst_register(context, (self.dst, vd_idx, VecRegType.V_REG), self.mask)
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()


class VectorIntlvDintlv(STMT):
    """
    Vector vintlv/vdintlv instruction
    """

    def __init__(self, source_info, intlv_params, tik_debugger):
        super(VectorIntlvDintlv, self).__init__(source_info, tik_debugger)
        self.dst0 = intlv_params.dst0  # Vd
        self.dst1 = intlv_params.dst1  # Vd+1
        self.src0 = intlv_params.src0  # Vn
        self.src1 = intlv_params.src1  # Vm
        self.instr_name = intlv_params.name

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        param.type = VEC_TYPE_BITS.get(self.dst0.dtype) | PARAMETERS.get(self.instr_name)

        vd0_idx, vd1_idx = context.alloc_v_register(self.dst0, is_even=True)
        context.init_vreg_according_cache(self.dst1, vd1_idx)
        param.vdIdx = vd0_idx

        vn_idx = context.alloc_v_register(self.src0)
        param.vnIdx = vn_idx
        vm_idx = context.alloc_v_register(self.src1)
        param.vmIdx = vm_idx
        return param, vd0_idx, vd1_idx

    def eval_(self, context):
        """
        Vector IntlvDintlv eval
        Parameters
        ----------
        context: tik context

        Returns
        -------
        no returns
        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.dst0.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)

        param, vd0_idx, vd1_idx = self.set_param(context, param)
        # v300
        if TikSocManager.is_v300_610l_soc():
            param.type = VEC_TYPE_BITS.get(self.dst0.dtype)
            param.op1 = V300_INSTR_OP1_CODE.get(self.instr_name)

        instr = context.encoder.gen_vector_intlv_dintlv(param)
        instr_list.append(instr)
        context.model.step_all(context, instr_list, len(instr_list))
        if TikSocManager.is_v300_610l_soc():
            dst_register(context, (self.dst0, vd0_idx, VecRegType.V_REG))
            dst_register(context, (self.dst1, vd1_idx, VecRegType.V_REG))
        else:
            value_buffer0 = context.get_vector_value(self.dst0).buffer
            flatten_np0 = value_buffer0.reshape(-1)
            vd0_idx_rename = context.model.get_vec_register_index(vd0_idx, VecRegType.V_REG)
            context.model.read_vec_register(vd0_idx_rename, flatten_np0.ctypes.data,
                                            len(flatten_np0) * DTYPE_SIZE.get(self.dst0.dtype))

            value_buffer1 = context.get_vector_value(self.dst1).buffer
            flatten_np1 = value_buffer1.reshape(-1)
            vd1_idx_rename = context.model.get_vec_register_index(vd1_idx, VecRegType.V_REG)
            context.model.read_vec_register(vd1_idx_rename, flatten_np1.ctypes.data,
                                            len(flatten_np1) * DTYPE_SIZE.get(self.dst1.dtype))
        context.set_vector_state(self.dst0, is_valid=True)
        context.set_vector_state(self.dst1, is_valid=True)
        context.free_all_register()


class VectorWholeReduce(STMT):
    """
    Vector vabs/vcls/vneg/vcadd/vcmax/vcmin instruction
    """

    def __init__(self, source_info, vec_whole_params, tik_debugger):
        super(VectorWholeReduce, self).__init__(source_info, tik_debugger)
        self.dst = vec_whole_params.dst  # Vd
        self.mask = vec_whole_params.mask  # Pg
        self.src = vec_whole_params.src  # Vn
        self.instr_name = vec_whole_params.name

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        pg_idx = context.alloc_p_register(self.mask, dtype=self.src.dtype)
        param.pgIdx = pg_idx
        param.type = VEC_TYPE_THREE_BITS.get(self.src.dtype)
        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx
        vn_idx = context.alloc_v_register(self.src)

        return param, vd_idx, vn_idx

    def eval_(self, context):
        """
        VectorWholeReduce eval
        Parameters
        ----------
        context: tik context

        Returns
        -------
        no returns
        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)
        param, vd_idx, vn_idx = self.set_param(context, param)
        param.vnIdx = vn_idx
        # just use vmIdx to pass param to encoder mode, not real Vm's index
        if TikSocManager.is_v300_610l_soc():
            if self.instr_name == "vectorized_vabs" and self.dst.dtype in ["float16", "float32"]:
                self.instr_name = "vectorized_vabs_float"
            elif self.instr_name == "vectorized_vabs":
                self.instr_name = "vectorized_vabs_int"
            if self.instr_name in ["vectorized_vneg"] and "int" in self.dst.dtype:
                param.op1 = V300_INSTR_OP1_CODE.get(self.instr_name) >> 2
                param.regType = V300_INSTR_REGTYPE_CODE.get(self.instr_name) << 1
            else:
                param.op1 = V300_INSTR_OP1_CODE.get(self.instr_name)
                param.regType = V300_INSTR_REGTYPE_CODE.get(self.instr_name)
            param.vmIdx = V300_VM_IDX.get(self.instr_name)
        else:
            param.vmIdx = SOURCE_REGISTER1.get(self.instr_name)
        instr = context.encoder.gen_vector_whole_reduce(param)
        execute_all_instr(context, instr_list, instr)
        if self.instr_name in ("vectorized_vcadd", "vectorized_vcmax", "vectorized_vcmin") and \
                TikSocManager.is_v300_610l_soc():
            self._reduce_merging(context, vd_idx, VecRegType.V_REG)
        else:
            dst_register(context, (self.dst, vd_idx, VecRegType.V_REG), self.mask, name=self.instr_name)
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()

    def _reduce_merging(self, context, vd_idx, vec_type):
        """
        v300 compatible merging mode for vcadd vcmin vcmax
        Parameters
        ----------
        context: debug context
        vd_idx: vd idx
        vec_type: vector type

        Returns
        -------

        """
        value_buffer1 = context.get_vector_value(self.dst).buffer
        flatten_np = value_buffer1.reshape(-1)
        flatten_np2 = copy.deepcopy(flatten_np)
        context.model.read_vec_register_by_idx(vec_type, vd_idx, flatten_np.ctypes.data,
                                               len(flatten_np) * DTYPE_SIZE[self.dst.dtype])
        if self.instr_name == "vectorized_vcadd":
            flatten_np[1:] = flatten_np2[1:]
        elif self.instr_name == "vectorized_vcmax" or self.instr_name == "vectorized_vcmin":
            vcmax_vcmin_merging_v300(context, self.mask, flatten_np, flatten_np2)


class VectorFcvtSfcvt(STMT):
    """
    Vector vfcvt/vsfcvt instruction
    """

    def __init__(self, source_info, fcvt_params, literal_value, tik_debugger):
        super(VectorFcvtSfcvt, self).__init__(source_info, tik_debugger)
        self.dst = fcvt_params.dst  # Vd
        self.mask = fcvt_params.mask  # Pg
        self.src = fcvt_params.src  # Vn
        self.saturate_index = fcvt_params.saturate_flag
        self.part_indicator = fcvt_params.part_indicator
        self.mode = fcvt_params.round_mode
        self.literal_value = literal_value

    def eval_(self, context):
        """
        Vector Fcvt/Sfcvt eval
        Parameters
        ----------
        context: tik context

        Returns
        -------
        no returns
        """
        if not TikSocManager.is_v300_610l_soc():
            intr_encoder_map = {
                "vfcvt_f322f16": context.encoder.gen_vector_vfcvt_f322f16,
                "vfcvt_f322s32": context.encoder.gen_vector_vfcvt_f322s32,
                "vsfcvt_f322s32": context.encoder.gen_vector_vsfcvt_f322s32,
                "vfcvt_f322s16": context.encoder.gen_vector_vfcvt_f322s16,
                "vsfcvt_f322s16": context.encoder.gen_vector_vsfcvt_f322s16,
                "vfcvt_f162f32": context.encoder.gen_vector_vfcvt_f162f32,
                "vfcvt_f162s8": context.encoder.gen_vector_vfcvt_f162s8,
                "vsfcvt_f162s8": context.encoder.gen_vector_vsfcvt_f162s8,
                "vfcvt_f162u8": context.encoder.gen_vector_vfcvt_f162u8,
                "vsfcvt_f162u8": context.encoder.gen_vector_vsfcvt_f162u8,
                "vfcvt_f162s32": context.encoder.gen_vector_vfcvt_f162s32,
                "vfcvt_f162s16": context.encoder.gen_vector_vfcvt_f162s16,
                "vsfcvt_f162s16": context.encoder.gen_vector_vsfcvt_f162s16,
                "vfcvt_u82f16": context.encoder.gen_vector_vfcvt_u82f16,
                "vfcvt_s82f16": context.encoder.gen_vector_vfcvt_s82f16,
                "vfcvt_s162f16": context.encoder.gen_vector_vfcvt_s162f16,
                "vfcvt_s162f32": context.encoder.gen_vector_vfcvt_s162f32,
                "vfcvt_s322f32": context.encoder.gen_vector_vfcvt_s322f32,
            }

        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)
        pg_idx = context.alloc_p_register(self.mask, dtype=self.src.dtype)
        param.pgIdx = pg_idx

        conv_type = DTYPE_MAP.get(self.src.dtype) + "2" + DTYPE_MAP.get(self.dst.dtype)
        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx
        vn_idx = context.alloc_v_register(self.src)
        param.vnIdx = vn_idx
        if TikSocManager.is_v300_610l_soc():
            instr_name = "vcvt"
            self._get_params_v300(param, conv_type)
        else:
            self.deal_with_mode(param, conv_type)
            if self.saturate_index is True:
                instr_name = "vsfcvt"
            else:
                instr_name = "vfcvt"
            if conv_type in VFCVT_VSFCVT_PART_TYPE:
                param.part = VCVT_VFCVT_PART.get(self.part_indicator)

        instr_name_type = instr_name + "_" + conv_type
        if TikSocManager.is_v300_610l_soc():
            instr = self._get_instr_encoder_v300(context, param, instr_name_type)
        else:
            instr = intr_encoder_map.get(instr_name_type)(param)

        execute_all_instr(context, instr_list, instr)
        dst_register_vcvt(context, (self.dst, vd_idx, VecRegType.V_REG), self.mask)
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()

    def deal_with_mode(self, param, conv_type):
        """
        deal with mode
        Parameters
        ----------
        param: params
        conv_type: conv type

        Returns
        -------
        no returns
        """
        if conv_type == "f322f16":
            param.ro = VFCVT_VSFCVT_R_O_Z.get(self.mode)
        if conv_type == "f322s16":
            param.rz = VFCVT_VSFCVT_R_O_Z.get(self.mode)
        if conv_type in VFCVT_VSFCVT_RND_TYPE:
            param.rnd = VFCVT_VSFCVT_RND.get(self.mode)

    def _get_params_v300(self, param, conv_type):
        if self.part_indicator:
            param.part = VCVT_PART_V300.get(self.part_indicator)
        else:
            param.part = 0b00
        if conv_type in vcvt_type_tuple:
            if self.mode and self.mode != 'none':
                param.rnd = VFCVT_VSFCVT_RND.get(self.mode)
            else:
                param.rnd = 0b000
        if self.saturate_index is True:
            # vmIdx is not real register index, only for #sat
            param.vmIdx = 1
        else:
            param.vmIdx = 0

    def _get_instr_encoder_v300(self, context, param, instr_name_type):
        if instr_name_type in ("vcvt_s42f16", "vcvt_u82f16", "vcvt_s82f16", "vcvt_s162f16", "vcvt_s162f32",
                               "vcvt_s322f32", "vcvt_s642f32"):
            instr_type = 0b00000
            instr_type += VCVT_TYPE_V300.get(DTYPE_MAP.get(self.dst.dtype))
            instr_type += VCVT_TYPE_V300.get(DTYPE_MAP.get(self.src.dtype)) << 2
            param.type = instr_type
            param.op1 = 2
        elif instr_name_type in ("vcvt_f322f16", "vcvt_f32bf16", "vcvt_f162f32", "vcvt_bf16f32"):
            instr_type = 0b0000
            instr_type += VCVT_TYPE_V300.get(DTYPE_MAP.get(self.dst.dtype))
            instr_type += VCVT_TYPE_V300.get(DTYPE_MAP.get(self.src.dtype)) << 2
            param.type = instr_type
            param.op1 = 1
        elif instr_name_type in ("vcvt_f322s64", "vcvt_f322s32", "vcvt_f322s16", "vcvt_f162s32", "vcvt_f162s16",
                                 "vcvt_f162s8", "vcvt_f162u8", "vcvt_f162s4", "vcvt_bf162s32"):
            instr_type = 0b00000
            instr_type += VCVT_TYPE_V300.get(DTYPE_MAP.get(self.dst.dtype))
            instr_type += VCVT_TYPE_V300.get(DTYPE_MAP.get(self.src.dtype)) << 3
            param.type = instr_type
            param.op1 = 0
        instr = context.encoder.gen_vector_vfcvt_v300(param)
        return instr


class VectorTrc(STMT):
    """
    Vector vtrc instruction
    """

    def __init__(self, source_info, trc_params, mode, tik_debugger):
        super(VectorTrc, self).__init__(source_info, tik_debugger)
        self.dst = trc_params.dst  # Vd
        self.mask = trc_params.mask  # Pg
        self.src = trc_params.src  # Vn
        self.mode = mode

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        pg_idx = context.alloc_p_register(self.mask, dtype=self.src.dtype)
        param.pgIdx = pg_idx

        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx
        vn_idx = context.alloc_v_register(self.src)
        param.vnIdx = vn_idx

        param.rnd = VFCVT_VSFCVT_RND.get(self.mode)
        param.vmIdx = VTRC_OP2_TYPE.get(self.src.dtype)
        return param, vd_idx

    def eval_(self, context):
        """
        VectorTrc eval
        Parameters
        ----------
        context: tik context

        Returns
        -------
        no returns
        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)
        param, vd_idx = self.set_param(context, param)
        if TikSocManager.is_v300_610l_soc():
            param.type = VEC_TYPE_THREE_BITS.get(self.dst.dtype)
        instr = context.encoder.gen_vector_vtrc(param)
        execute_all_instr(context, instr_list, instr)
        dst_register(context, (self.dst, vd_idx, VecRegType.V_REG))
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()


class VectorCvtScvt(STMT):
    """
    Vector vcvt/vscvt instruction
    """

    def __init__(self, source_info, cvtscvt_params, tik_debugger):
        super(VectorCvtScvt, self).__init__(source_info, tik_debugger)
        self.dst = cvtscvt_params.dst  # Vd
        self.src = cvtscvt_params.src  # Vn
        self.mask = cvtscvt_params.mask
        self.saturate_index = cvtscvt_params.saturate_flag
        self.part_indicator = cvtscvt_params.part_indicator

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        conv_type = DTYPE_MAP.get(self.src.dtype) + "2" + DTYPE_MAP.get(self.dst.dtype)
        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx
        vn_idx = context.alloc_v_register(self.src)
        param.vnIdx = vn_idx

        if TikSocManager.is_v300_610l_soc():
            if self.saturate_index is True:
                param.sat = 1
            else:
                param.sat = 0

            param.part = VCVT_PART_V300.get(self.part_indicator)
            pg_idx = context.alloc_p_register(self.mask, dtype=self.src.dtype)
            param.pgIdx = pg_idx
            instr_type = 0b000000
            instr_type += VCVT_TYPE_V300.get(DTYPE_MAP.get(self.dst.dtype))
            instr_type += VCVT_TYPE_V300.get(DTYPE_MAP.get(self.src.dtype)) << 3
            param.type = instr_type
            param.op1 = 0b0010011
        else:
            # vmIdx is not real register index, only for pass paramter
            param.vmIdx = _VCVT_VSCVT_OP2_CODE.get(conv_type)
            if self.saturate_index is True:
                instr_name = "vectorized_vscvt"
            else:
                instr_name = "vectorized_vcvt"

            if conv_type in ["u82u32", "s82s32", "u322u8", "s322u8"]:
                param.part = PARAMETERS.get(instr_name) | \
                             VCVT_VFCVT_PP.get(self.part_indicator)
            else:
                param.part = PARAMETERS.get(instr_name) | \
                             VCVT_VFCVT_PART[self.part_indicator]
        return param, vd_idx

    def eval_(self, context):
        """
        Vector Cvt/Scvt eval
        Parameters
        ----------
        context: tik context

        Returns
        -------
        no returns
        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)
        param, vd_idx = self.set_param(context, param)

        instr = context.encoder.gen_vector_vcvt_vscvt(param)
        execute_all_instr(context, instr_list, instr)
        dst_register_vcvt(context, (self.dst, vd_idx, VecRegType.V_REG), self.mask)
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()


class VectorVselr(STMT):
    """
    Vector vselr instruction
    """

    def __init__(self, source_info, vselr_params, tik_debugger):
        super(VectorVselr, self).__init__(source_info, tik_debugger)
        self.dst = vselr_params.dst
        self.src0 = vselr_params.src0
        self.src1 = vselr_params.src1

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        param.type = VLOOPN_TYPE.get(self.dst.dtype)

        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx
        vn_idx = context.alloc_v_register(self.src0)
        param.vnIdx = vn_idx
        vm_idx = context.alloc_v_register(self.src1)
        param.vmIdx = vm_idx
        return param, vd_idx

    def eval_(self, context):
        """
        Vector Vselr eval
        Parameters
        ----------
        context: tik context

        Returns
        -------
        no returns
        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)
        param, vd_idx = self.set_param(context, param)
        instr = context.encoder.gen_vector_vselr(param)
        execute_all_instr(context, instr_list, instr)
        dst_register(context, (self.dst, vd_idx, VecRegType.V_REG), is_merging=False)
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()


class VectorSingleElewise(STMT):
    """
    Vector vrsqrt/vsqrt/vrec/vln/vbcnt/vrelu/vexp/vnot/vsqz/pnot instruction
    """

    def __init__(self, source_info, vec_single_params, tik_debugger):
        super(VectorSingleElewise, self).__init__(source_info, tik_debugger)
        self.dst = vec_single_params.dst  # Vd or Pd
        self.mask = vec_single_params.mask  # None, imm, Scalar, Expr, Preg
        self.src = vec_single_params.src  # Vn or Pn
        self.instr_name = vec_single_params.name

    def eval_(self, context):
        """
        Vector SingleElewise eval
        Parameters
        ----------
        context: tik context
        Returns
        -------
        no returns
        """
        TempEnv()
        if self.instr_name == "vectorized_pnot":
            param = set_param_loop_vex_num_dtype(context, "uint8", 0, 1)
            instr_list = create_vloop_info(context, param)
            pg_idx = context.alloc_p_register(self.mask, dtype="uint8")
        else:
            param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 1)
            instr_list = create_vloop_info(context, param)
            pg_idx = context.alloc_p_register(self.mask, dtype=self.src.dtype)
        param.pgIdx = pg_idx

        if self.instr_name == "vectorized_pnot":
            self.eval_pnot(context, param, instr_list)
            return

        if self.instr_name in ["vectorized_vrelu", "vectorized_vln",
                               "vectorized_vexp", "vectorized_vrsqrt",
                               "vectorized_vrec", "vectorized_vsqrt"]:
            if TikSocManager.is_v300_610l_soc():
                param.type = VEC_TYPE_THREE_BITS.get(self.dst.dtype)
            else:
                param.type = VCI_TYPE_BITS.get(self.dst.dtype) | PARAMETERS.get(self.instr_name)
        else:
            param.type = VEC_TYPE_BITS.get(self.dst.dtype) | PARAMETERS.get(self.instr_name)

        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx
        vn_idx = context.alloc_v_register(self.src)
        param.vnIdx = vn_idx
        # just use vmIdx to pass param to encoder mode, not real Vm's index
        if TikSocManager.is_v300_610l_soc():
            param.vmIdx = V300_VM_IDX.get(self.instr_name)
            param.op1 = V300_INSTR_OP1_CODE.get(self.instr_name)
            param.regType = V300_INSTR_REGTYPE_CODE.get(self.instr_name)
        else:
            param.vmIdx = SOURCE_REGISTER1.get(self.instr_name)

        if TikSocManager.is_v300_610l_soc() and self.instr_name == "vectorized_vbcnt":
            param.type = VEC_TYPE_BITS.get(self.dst.dtype)

        instr = context.encoder.gen_vector_single_elewise(param)
        instr_list.append(instr)
        context.model.step_all(context, instr_list, len(instr_list))
        if TikSocManager.is_v300_610l_soc():
            if self.instr_name == "vectorized_vsqz":
                dst_register(context, (self.dst, vd_idx, VecRegType.V_REG), self.mask, is_merging=False)
            else:
                dst_register(context, (self.dst, vd_idx, VecRegType.V_REG), self.mask)

        else:
            value_buffer = context.get_vector_value(self.dst).buffer
            flatten_np = value_buffer.reshape(-1)
            vd_idx_rename = context.model.get_vec_register_index(vd_idx, VecRegType.V_REG)
            context.model.read_vec_register(
                vd_idx_rename, flatten_np.ctypes.data, len(flatten_np) * DTYPE_SIZE.get(self.dst.dtype))
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()

    def eval_pnot(self, context, param, instr_list):
        """
        eval pnot
        Parameters
        ----------
        context
        param
        instr_list

        Returns
        -------

        """
        param.type = 0
        pd_idx = context.alloc_p_register(self.dst)
        param.vdIdx = pd_idx
        vn_idx = context.alloc_p_register(self.src, dtype=self.src.dtype)
        param.vnIdx = vn_idx
        # just use vmIdx to pass param to encoder mode, not real Vm's index
        if TikSocManager.is_v300_610l_soc():
            param.op1 = V300_INSTR_OP1_CODE.get(self.instr_name)
            param.part = V300_INSTR_REGTYPE_CODE.get(self.instr_name)
        else:
            param.vmIdx = SOURCE_REGISTER1.get(self.instr_name)

        instr = context.encoder.gen_vector_single_elewise(param)
        execute_all_instr(context, instr_list, instr)
        dst_register(context, (self.dst, pd_idx, VecRegType.P_REG), self.mask, is_merging=False)
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()


class VectorVusqz(STMT):
    """
    Vector vusqz instruction
    """

    def __init__(self, source_info, vusqz_params, tik_debugger):
        super(VectorVusqz, self).__init__(source_info, tik_debugger)
        self.dst = vusqz_params.dst  # vd
        self.src = vusqz_params.src  # pg
        self.instr_name = vusqz_params.name

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        param.type = VEC_TYPE_BITS.get(self.dst.dtype) | 0b100

        vd_idx = context.alloc_v_register(self.dst)
        param.vdIdx = vd_idx
        pg_idx = context.alloc_p_register(self.src)
        param.pgIdx = pg_idx
        param.vnIdx = 0
        # just use vmIdx to pass param to encoder mode, not real Vm's index
        if not TikSocManager.is_v300_610l_soc():
            param.vmIdx = SOURCE_REGISTER1.get(self.instr_name)
        return param, vd_idx

    def eval_(self, context):
        """
        Vector Vusqz eval
        Parameters
        ----------
        context: tik context
        Returns
        -------
        no returns
        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)
        param, vd_idx = self.set_param(context, param)
        if TikSocManager.is_v300_610l_soc():
            param.type = VEC_TYPE_BITS.get(self.dst.dtype)
            param.op1 = 0x7A
        instr = context.encoder.gen_vector_single_elewise(param)
        execute_all_instr(context, instr_list, instr)
        dst_register(context, (self.dst, vd_idx, VecRegType.V_REG))
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()
