#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     context.py
DESC:     debug context
CREATED:  2019-7-04 20:12:13
MODIFIED: 2019-7-24 10:54:23
"""

from __future__ import absolute_import
from __future__ import print_function
import ctypes
import multiprocessing
import sys
import threading
from tbe.tvm._ffi import register_object
from tbe.tvm.runtime import Object
from tbe.tik.common.util import DTYPE_INT_VALUE
from tbe.tik.common.util import get_check_feed_dict
from tbe.tik.common.debug_api import DebugVm
from tbe.tik.debug.context_tensor import ContextTensor
from tbe.tik.debug.context_var import ContextVar
from tbe.tik.debug.context_vector import ContextVector
from tbe.tik.debug.sim import PVModelV1
from tbe.tik.debug.sim import Encoder
from tbe.tik.debug.sim import PVModelV2
from tbe.tik.debug.statement import DebugReturnException
from tbe.tik.debug.intrinsic_flow_control import Block
from tbe.tik.debug.util import make_tvm_imm
from tbe.tik.tik_lib.tik_source_info import TikSourceInfo
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager


class SPRProxy:
    """
    special_register proxy
    """

    def __init__(self, context):
        self.context = context

    def __getitem__(self, name):
        self.check_context_model()
        return self.context.model.read_spr(name)

    def check_context_model(self):
        """
        check context model
        Returns
        -------

        """
        TikCheckUtil.check_not_is(
            self.context.model, None, "self.context.model is None")


class FrozenContext:
    """
    frozen context
    """

    def __init__(self, context):
        self.context = context

    def __enter__(self):
        self.context.frozen += 1
        self.context.curr_scope().frozen += 1

    def __exit__(self, ptype, value, trace):
        self.context.frozen -= 1
        self.context.curr_scope().frozen -= 1


_SCOPE_LENGTH = 1
_LAST_SCOPE = -1


_TIK_CONTEXT_ID = threading.local()
_TIK_CONTEXT_ID.ctx_id = 0
_TIK_CONTEXT_ID.ctx_id_lock = threading.Lock()


@register_object
class DebugContext(Object):
    """
    for pass parameters c++ api with python
    """


class Context(ContextVar, ContextTensor, ContextVector):
    """
    Data binding:
    tensor ->  NumpyBuffer (buffer_mapping)
    var    ->  callback_handle (var_table)
    SPR    ->  a proxy to PVModel
    """
    def __init__(self, dprofile):
        ContextVar.__init__(self)
        ContextTensor.__init__(self)
        ContextVector.__init__(self)
        self.dprofile = dprofile
        self.scope = []
        top_block = Block()
        top_block.traceable = False
        self.scope.append(top_block)
        self.placeholders = {}

        self.outs = []
        self.store_stmt = []
        self.spr_proxy = SPRProxy(self)
        self.model = None
        self.encoder = Encoder()
        self.interactive = True
        self.frozen = False

        self.init_mode = 'random'
        self.init_value = None
        self.tensor_list = []
        self.vector_list = []
        self.reuse_dict = {}
        # for save all input tensor's numpy array
        self.feed_dict_tensor = {}
        # record for_range info
        self.cur_for_loop = None
        self.for_loop_times_map = {}

        self.buffer_cache = {}
        self.buffer_list = []

        # for save all gm access address extend info
        self.gm_tensor_access_info = None
        # gm tensor access lock for multi-core multi process
        self.gm_lock = None

        self.tik_debugger = None
        self.tik_debug = None
        # use to save atomic add value, value is Scalar.
        self.atomic_add_value = 0
        # use to save the valid index range of tensoraddrlist.
        self.tensor_addr_list_valid_idx = {}

        self.sym_table_storage = None
        self.debug_map = {}
        self.is_debug_break = False
        self.is_debug_continue = False
        # used for multi-core block_barrier
        # when code run at block_barrier(), append a num to list
        # when all block_id are at block_barrier, list's length shound equal to block_num
        self.blk_barrier_flag = None
        self.blk_barrier_lock = None

        # sqzn_count is store sqzn's count
        self.sqzn_count = 0
        # all_sqzn_count is vsqz all count
        self.all_sqzn_count = 0

        # Check whether Tik goes code has gone to BuildCCE.
        self.is_build_cce = False
        # must check attr, if no, must create once,
        # parallel compilation may cause _TIK_CONTEXT_ID has not the attr
        if not hasattr(_TIK_CONTEXT_ID, "ctx_id"):
            _TIK_CONTEXT_ID.ctx_id = 0

        if not hasattr(_TIK_CONTEXT_ID, "ctx_id_lock"):
            _TIK_CONTEXT_ID.ctx_id_lock = threading.Lock()

        # add lock to ctx_id, wait 10s
        if _TIK_CONTEXT_ID.ctx_id_lock.acquire(timeout=10) is True:
            self.ctx_id = _TIK_CONTEXT_ID.ctx_id
            _TIK_CONTEXT_ID.ctx_id += 1
            _TIK_CONTEXT_ID.ctx_id_lock.release()
        else:
            TikCheckUtil.raise_error('Create debug context failed, cannot get the ctx_id_lock')

        self.debug_vm_ctx = DebugVm.create(self.ctx_id)
        self.tik_version = "1.0"  # default tik version is "1.0"
        self.debug_source_id = 1  # for attr stmt_source
        self.actual_source_num = 0  # attr stmt_source num after pass simplify
        self.arch = "v1"  # pvmodel api v1, lib_pvmodel.so
        if TikSocManager.is_910b_soc() or TikSocManager.is_v300_610l_soc():
            self.arch = "v2"  # pvmodel api v2, libpem_davinci.so

    def free(self):
        """
        For free the NumpyBuffer memory
        """
        self.set_tensor_buffer()
        self.set_vector_buffer()
        self.feed_dict_tensor = {}  # free input tensor buffer
        if self.debug_vm_ctx is not None:
            DebugVm.free(self.ctx_id)
            self.debug_vm_ctx = None

    def free_debug_vm(self):
        """
        free the debug vm context object
        Returns
        -------
        None

        """
        if self.debug_vm_ctx is not None:
            DebugVm.free(self.ctx_id)
            self.debug_vm_ctx = None

    def step_next(self, source_id):
        """
        run instruction with debug source id
        Parameters
        ----------
        source_id: debug source id of the instruction

        Returns
        -------
        None

        """
        if self.debug_vm_ctx is not None and self.actual_source_num > 0:
            DebugVm.run_with_source_id(self.debug_vm_ctx, source_id)

    def get_actual_source_num_from_vm(self):
        """
        get actual debug source id num after simplify by pass
        Parameters
        ----------

        Returns
        -------
        num of actual debug stmt_source

        """
        if self.debug_vm_ctx is not None and self.debug_source_id > 1:
            self.actual_source_num = DebugVm.get_actual_source_num(self.debug_vm_ctx)

    def get_cur_for_loop_times(self):
        """
        get current for loop times

        Returns
        -------
        times
        """
        # if cur_for_loop is None, think no for loop, so return 0
        loop_times = self.for_loop_times_map.get(self.cur_for_loop)
        if self.cur_for_loop is None:
            loop_times = 0
        if loop_times is None:
            TikCheckUtil.raise_error("cannot find current for loop")
        return loop_times

    def freeze(self):
        """
        Get frozen context

        Returns
        -------
        frozen context
        """
        return FrozenContext(self)

    def add_scope(self, scope):
        """
        add scope to stmt

        Parameters
        ----------
        scope : which ub
        """
        if self.frozen:
            return
        self.curr_scope().add_stmt(scope)
        self.scope.append(scope)

    def pop_scope(self):
        """
        pop scope
        """
        if self.frozen:
            return
        self.scope.pop()

    def curr_scope(self):
        """
        return cur scope

        Returns
        -------
        the last scope
        """
        return self.scope[_LAST_SCOPE]

    def eval_(self, feed_dict, tik_version="1.0"):
        """
        debug context run entry

        Parameters
        ----------
        feed_dict : symbol dict
        tik_version: tik version of "1.0", "1.5"

        Returns
        -------
        the result
        """
        TikCheckUtil.check_type_match(
            feed_dict, dict, "feed_dict should be type of dict, input feed_dict"
                             " type is %s" % type(feed_dict))
        # check feed_dict with placeholder
        build_cce_input_tensor_names = " ".join(list(self.placeholders.keys()))
        build_cce_input_var_names = " ".join(list(self.feed_var_table.keys()))
        build_cce_input_names = build_cce_input_tensor_names + " " + build_cce_input_var_names
        build_list_tensor = set(
            self.placeholders.keys()).union(set(self.feed_var_table.keys()))
        self.feed_dict_tensor, feed_dict_var = get_check_feed_dict(
            feed_dict, self.placeholders.keys(), self.feed_var_table.keys(), build_list_tensor,
            (build_cce_input_names, build_cce_input_tensor_names, build_cce_input_var_names))

        TikCheckUtil.check_equality(len(self.scope), _SCOPE_LENGTH,
                                    "self.scope length must equal to 1")

        self.tik_version = tik_version  # update tik version according the compile result
        for key, value in feed_dict_var.items():
            build_cce_input_var = self._get_cce_input_var(key, value)
            self.update_var(build_cce_input_var, value)
            self.update_var_to_vm(build_cce_input_var, make_tvm_imm(build_cce_input_var.dtype, value))

        if self.tik_debugger:
            self.tik_debug.force_interactive = True
        if self.arch == "v1":
            self.model = PVModelV1(self.dprofile)
        else:
            self.model = PVModelV2()

        # update model to VM debug
        if self.debug_vm_ctx is not None and self.actual_source_num > 0:
            handle = getattr(self.model.get_dll(), "_handle")
            DebugVm.set_pv_model(self.debug_vm_ctx, self.model.get_chip_version(), self.arch,
                                      0, ctypes.c_void_p(handle))

        # before evaluate stmt, clear source info, such as start_debug
        TikSourceInfo.clear_source_info()

        success_code = 0
        scope = self.curr_scope()
        try:
            scope.evaluate(self)
        except SystemExit as exception:
            # success_code means user quit
            if exception.code == success_code:
                sys.exit(success_code)
            # print the exception message
            print(exception)
            # raise SystemExit for user
            sys.exit(exception)
        except DebugReturnException:
            pass
        finally:
            self.model = None

        return self.get_outputs()

    def add_tvm_store_stmt(self, stmt):
        """
        add tvm to store stmt

        Parameters
        ----------
        stmt: statement

        Returns
        -------
        no return
        """
        self.store_stmt.append(stmt)

    def record_ins(self, ins):
        """
        record instruction

        Parameters
        ----------
        ins : instruction
        """
        self.placeholders = {i.name: i.buffer for i in ins}

    def record_outs(self, outs):
        """
        record the outs

        Parameters
        ----------
        outs : the outs
        """
        self.outs = outs

    def _get_cce_input_var(self, key, value):
        """


        Parameters
        ----------
        key : key
        value: value

        Returns
        -------
        build_cce_input_var
        """
        build_cce_input_var = self.get_feed_var_by_name(key)
        if build_cce_input_var.dtype.startswith("int") or \
                build_cce_input_var.dtype.startswith("uint"):
            TikCheckUtil.check_type_match(value, int, key + " is " +
                                          build_cce_input_var.dtype +
                                          ", but value is float!")
            TikCheckUtil.check_in_range_by_dtype(
                value, msg="{} is {} type, should in [{}, {}], but get {}".format(
                    key, build_cce_input_var.dtype, DTYPE_INT_VALUE.get(build_cce_input_var.dtype)[0],
                    DTYPE_INT_VALUE.get(build_cce_input_var.dtype)[1], value),
                var_range=[DTYPE_INT_VALUE.get(build_cce_input_var.dtype)[0],
                           DTYPE_INT_VALUE.get(build_cce_input_var.dtype)[1]])
        if build_cce_input_var.dtype.startswith("float"):
            TikCheckUtil.check_type_match(
                value, float,
                key + " is " + build_cce_input_var.dtype +
                ", but value is int!")
        return build_cce_input_var
