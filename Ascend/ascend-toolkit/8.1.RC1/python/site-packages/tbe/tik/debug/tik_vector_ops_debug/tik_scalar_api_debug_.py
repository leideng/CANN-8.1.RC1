#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_scalar_api_debug_.py
DESC:     this file contains many decorator
CREATED:  2021-12-09 10:53:13
MODIFIED: 2021-12-09 10:53:13
"""
import numpy as np

from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.util import make_tvm_imm
from tbe.tik.debug.util import get_dtype_bit_width
from tbe.tik.tik_lib.tik_params import UINT64_BIT
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil

_SCALAR_CONV_ID = {
    ('float32', 'int32', 'away-zero'): 0b00000,
    ('float32', 'int32', 'floor'): 0b00001,
    ('float32', 'int32', 'ceil'): 0b00010,
    ('float32', 'int32', 'to-zero'): 0b00011,
    ('float32', 'int32', 'round'): 0b00100,
    ('int32', 'float32'): 0b00101,
    ('float32', 'float16'): 0b00110,
    ('float16', 'float32'): 0b00111,
    ('float32', 'float16', 'odd'): 0b01000,
}


class ScalarSingleOp(STMT):
    """
    ScalarSingleOp instruction

    Parameters
    ----------
    Returns
    -------
    None
    """

    def __init__(self, source_info, scalar_single_api, tik_debugger):
        super(ScalarSingleOp, self).__init__(source_info, tik_debugger)
        self.name = scalar_single_api.name
        self.dst = scalar_single_api.dst
        self.src = scalar_single_api.src

    @staticmethod
    def _ones_cnt(value, dtype):
        """
        count bit number of one

        Parameters
        ----------
        value : count value
        dtype: value dtype

        Returns
        -------
        nums_ones: number of bit one
        """
        tmp_arr = np.asarray([value], dtype=dtype)
        tmp_arr = tmp_arr.view('uint8')
        bits_arr = np.unpackbits(tmp_arr)
        num_ones = bits_arr.sum().item()
        return num_ones

    def debug_bcnt0(self, src_value):
        """
        debug for bitcount0 instruction

        Parameters
        ----------
        src_value : the value of src

        Returns
        -------
        dst_value: the value of dst
        """
        if isinstance(self.src, (int, float)):
            dst_value = UINT64_BIT - self._ones_cnt(int(src_value), 'uint64')
        else:
            dst_value = UINT64_BIT - self._ones_cnt(src_value, self.src.dtype)
        return dst_value

    def debug_bcnt1(self, src_value):
        """
        debug for bitcount0 instruction

        Parameters
        ----------
        src_value : the value of src

        Returns
        -------
        dst_value: the value of dst
        """
        if isinstance(self.src, (int, float)):
            dst_value = self._ones_cnt(int(src_value), 'uint64')
        else:
            dst_value = self._ones_cnt(src_value, self.src.dtype)
        return dst_value

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        src_value = context.evaluate_expr(self.src)
        dst_value = ''
        try:
            if self.name == 'sqrt':
                dst_value = np.sqrt(np.abs(src_value)).item()
            elif self.name == 'abs':
                dst_value = np.abs(src_value).item()
            elif self.name == 'bcnt0':
                dst_value = self.debug_bcnt0(src_value)
            elif self.name == 'bcnt1':
                dst_value = self.debug_bcnt1(src_value)
            elif self.name == 'clz':
                if isinstance(self.src, (int, float)):
                    dst_value = format(int(src_value), '064b').find('1')
                else:
                    dst_value = format(src_value, '064b').find('1')
                if dst_value <= -1:
                    # '1' is not found, thus all 64 bits are 0
                    dst_value = UINT64_BIT
            else:
                TikCheckUtil.raise_error('unsupported op {}'.format(self.name))
        except FloatingPointError:
            TikCheckUtil.raise_error(
                'got float point error in %s with value %s' % (
                    self.name, str(src_value)))
        offset = context.evaluate_expr(self.dst.offset)
        context.update_var(self.dst.debug_var[offset], dst_value)
        tvm_dst_value = make_tvm_imm(self.dst.dtype, dst_value)
        context.update_var_to_vm(self.dst.reg_buffer.asobject(), tvm_dst_value, offset=offset)


class ScalarBinaryOp(STMT):
    """
    ScalarBinary instruction for debug

    Parameters
    ----------
    Returns
    -------
    None
    """

    def __init__(self, source_info, scalar_binary_api, tik_debugger):

        super(ScalarBinaryOp, self).__init__(source_info, tik_debugger)
        self.name = scalar_binary_api.name
        self.dst = scalar_binary_api.dst
        self.src0 = scalar_binary_api.src0
        self.src1 = scalar_binary_api.src1

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """

        dst_value = self.set_dst_value(context)
        offset = context.evaluate_expr(self.dst.offset)
        context.update_var(self.dst.debug_var[offset], dst_value)
        tvm_dst_value = make_tvm_imm(self.dst.dtype, dst_value)
        context.update_var_to_vm(self.dst.reg_buffer.asobject(), tvm_dst_value, offset=offset)

    def set_dst_value(self, context):
        """
        set dst value
        Parameters
        ----------
        context: tik context

        Returns
        -------

        """
        src0_value = context.evaluate_expr(self.src0)
        src1_value = context.evaluate_expr(self.src1)
        dst_value = ''
        try:
            if self.name == 'max':
                dst_value = np.max([src0_value, src1_value]).item()
            elif self.name == 'min':
                dst_value = np.min([src0_value, src1_value]).item()
            else:
                TikCheckUtil.raise_error('unsupported op {}'.format(self.name))
        except FloatingPointError:
            TikCheckUtil.raise_error(
                'got float point error in {} with value {}, {}'.format(
                    self.name, src0_value, src1_value))
        return dst_value


class ScalarConv(STMT):
    """
    ScalarConv instruction

    Parameters
    ----------
    Returns
    -------
    None
    """

    def __init__(self, source_info, scalar_conv_api, tik_debugger):
        super(ScalarConv, self).__init__(source_info, tik_debugger)
        self.round_mode = scalar_conv_api.round_mode
        if self.round_mode == 'ceiling':
            self.round_mode = 'ceil'
        self.dst = scalar_conv_api.dst
        self.src = scalar_conv_api.src

        if self.round_mode in ('', 'none'):
            self.conv_id = _SCALAR_CONV_ID.get((self.src.dtype, self.dst.dtype))
        else:
            self.conv_id = _SCALAR_CONV_ID.get((self.src.dtype, self.dst.dtype, self.round_mode))

        TikCheckUtil.check_not_equality(self.conv_id, None, "The current round_mode is '%s'. The mode is not support "
                                                            "dtype conversion from the src's %s to the dst's %s."
                                        % (self.round_mode, self.src.dtype, self.dst.dtype))

    def set_param(self, context):
        """
        set param attr
        Parameters
        ----------
        context: tik context

        Returns
        -------

        """
        src_value = context.evaluate_expr(self.src)
        temp_env = TempEnv()
        xn_idx = temp_env.alloc_register()
        # conv src to uint values
        src_bit_width = get_dtype_bit_width(self.src.dtype)
        uint_value = getattr(np, self.src.dtype)(src_value).view('uint' + src_bit_width).item()
        context.model.write_gpr(xn_idx, uint_value)

        xd_idx = temp_env.alloc_register()

        param = context.encoder.new_param()
        param.type = self.conv_id
        param.xd = xd_idx
        param.xn = xn_idx

        instr = context.encoder.gen_conv(param)
        return instr, xd_idx

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        instr, xd_idx = self.set_param(context)
        context.model.step(instr)

        dst_value_uint = context.model.read_gpr(xd_idx)
        dst_bit_width = get_dtype_bit_width(self.dst.dtype)
        # it is safe to cast fp16 in python, since fp16 to fp32 is round trip safe
        dst_value = getattr(np, 'uint' + dst_bit_width)(dst_value_uint).view(self.dst.dtype).item()

        offset = context.evaluate_expr(self.dst.offset)
        context.update_var(self.dst.debug_var[offset], dst_value)
        tvm_dst_value = make_tvm_imm(self.dst.dtype, dst_value)
        context.update_var_to_vm(self.dst.reg_buffer.asobject(), tvm_dst_value, offset=offset)
