#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     intrinsic_spec_v210.py
DESC:     debug intrinsic_spec_v210
CREATED:  2019-7-04 20:12:13
MODIFIED: 2019-7-24 10:54:23
"""
import copy
from collections import namedtuple
from tbe.common.platform import scope_wreg
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import WDTYPE_TO_DTYPE
from tbe.tik.common.util import get_instr_name_by_acc_mode
from tbe.tik.common.util import WMUL_NO_PG_DTYPE_LIST
from tbe.tik.common.util import WFIFR2_OFFSET_LIST
from tbe.tik.common.util import WFIFR2_BITWIDE_LIST
from tbe.tik.common.common_util import check_param_type_range
from tbe.tik.debug.intrinsic_v210_common import create_vloop_info
from tbe.tik.debug.intrinsic_v210_common import get_and_write_share_spr
from tbe.tik.debug.intrinsic_v210_common import V210_INSTR_OP1_CODE
from tbe.tik.debug.intrinsic_v210_common import FIFR1_TYPE
from tbe.tik.debug.intrinsic_v210_common import BIT2_TYPE_16_32
from tbe.tik.debug.intrinsic_v210_common import set_param_loop_vex_num_dtype
from tbe.tik.debug.intrinsic_v210_common import dst_register
from tbe.tik.debug.intrinsic_v210_common import V300_INSTR_OP1_CODE
from tbe.tik.debug.intrinsic_v210_common import VEC_TYPE_THREE_BITS
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.debug.util import VecRegType
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_params import WREG_START_INDEX
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_util import concat_params
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_check_params_v210 import VectorOpsCheck

_DHIST_CHIST_TYPE = {
    "vectorized_dhist0": 0b000,
    "vectorized_dhist1": 0b001,
    "vectorized_dhist2": 0b010,
    "vectorized_dhist3": 0b011,
    "vectorized_chist0": 0b100,
    "vectorized_chist1": 0b101,
    "vectorized_chist2": 0b110,
    "vectorized_chist3": 0b111,
}

_DHIST_CHIST_TYPE_V300 = {
    "vectorized_dhistv20": 0b0000,
    "vectorized_dhistv21": 0b0001,
    "vectorized_chistv20": 0b0000,
    "vectorized_chistv21": 0b0001,
}

_WPACK_WAPCKS_TYPE = {
    "vectorized_wpack_s24s8": 0b000,
    "vectorized_wpack_s24u8": 0b010,
    "vectorized_wpack_s48s16": 0b100,
    "vectorized_wpack_s48u16": 0b110,
    "vectorized_wpack_s64s32": 0b000,
    "vectorized_wpack_s24s16": 0b100,
    "vectorized_wpack_s24u16": 0b000,
    "vectorized_wpack_s48s32": 0b100,
    "vectorized_wpacks_s24s8": 0b000,
    "vectorized_wpacks_s24u8": 0b010,
    "vectorized_wpacks_s48s16": 0b000,
    "vectorized_wpacks_s48u16": 0b010,
    "vectorized_wpacks_s64s32": 0b000,
    "vectorized_wpacks_s24s16": 0b000,
    "vectorized_wpacks_s24u16": 0b000,
    "vectorized_wpacks_s48s32": 0b000,
}

_WPACK_WAPCKS_WN_IDX = {
    "vectorized_wpack_s24s8": 0b00000,
    "vectorized_wpack_s24u8": 0b00000,
    "vectorized_wpack_s48s16": 0b00000,
    "vectorized_wpack_s48u16": 0b00000,
    "vectorized_wpack_s64s32": 0b01000,
    "vectorized_wpack_s24s16": 0b01000,
    "vectorized_wpack_s24u16": 0b10000,
    "vectorized_wpack_s48s32": 0b10000,
    "vectorized_wpacks_s24s8": 0b00000,
    "vectorized_wpacks_s24u8": 0b00000,
    "vectorized_wpacks_s48s16": 0b01000,
    "vectorized_wpacks_s48u16": 0b01000,
    "vectorized_wpacks_s64s32": 0b10000,
    "vectorized_wpacks_s24s16": 0b11000,
    "vectorized_wpacks_s24u16": 0b00000,
    "vectorized_wpacks_s48s32": 0b01000,
}

_WPACK_WAPCKS_PG_IDX = {
    "vectorized_wpack_s24s8": 0b000,
    "vectorized_wpack_s24u8": 0b000,
    "vectorized_wpack_s48s16": 0b000,
    "vectorized_wpack_s48u16": 0b000,
    "vectorized_wpack_s64s32": 0b000,
    "vectorized_wpack_s24s16": 0b000,
    "vectorized_wpack_s24u16": 0b000,
    "vectorized_wpack_s48s32": 0b000,
    "vectorized_wpacks_s24s8": 0b001,
    "vectorized_wpacks_s24u8": 0b001,
    "vectorized_wpacks_s48s16": 0b001,
    "vectorized_wpacks_s48u16": 0b001,
    "vectorized_wpacks_s64s32": 0b001,
    "vectorized_wpacks_s24s16": 0b001,
    "vectorized_wpacks_s24u16": 0b010,
    "vectorized_wpacks_s48s32": 0b010,
}

_WMUL_WMULS_WD_IDX = {
    "vectorized_wmul_u8u8": 0b01000,
    "vectorized_wmul_u8s8": 0b01000,
    "vectorized_wmul_s8s8": 0b01000,
    "vectorized_wmul_u16u16": 0b01000,
    "vectorized_wmul_u16s16": 0b10000,
    "vectorized_wmul_s16s16": 0b10000,
    "vectorized_wmul_u8s16": 0b10000,
    "vectorized_wmul_s8s16": 0b10000,
    "vectorized_wmul_u16u32": 0b10000,
    "vectorized_wmul_u16s32": 0b11000,
    "vectorized_wmul_s16u32": 0b11000,
    "vectorized_wmul_s16s32": 0b11000,
    "vectorized_wmula_u8u8": 0b11000,
    "vectorized_wmula_u8s8": 0b11000,
    "vectorized_wmula_s8s8": 0b00000,
    "vectorized_wmula_u16u16": 0b00000,
    "vectorized_wmula_u16s16": 0b00000,
    "vectorized_wmula_s16s16": 0b00000,
    "vectorized_wmula_u8s16": 0b00000,
    "vectorized_wmula_s8s16": 0b00000,
    "vectorized_wmula_u16u32": 0b01000,
    "vectorized_wmula_u16s32": 0b01000,
    "vectorized_wmula_s16u32": 0b01000,
    "vectorized_wmula_s16s32": 0b01000,
    "vectorized_wmuls_u8u8": 0b00000,
    "vectorized_wmuls_u8s8": 0b00000,
    "vectorized_wmuls_s8s8": 0b00000,
    "vectorized_wmuls_u16u16": 0b00000,
    "vectorized_wmuls_u16s16": 0b01000,
    "vectorized_wmuls_s16s16": 0b01000,
    "vectorized_wmuls_u8s16": 0b01000,
    "vectorized_wmuls_s8s16": 0b10000,
    "vectorized_wmuls_u16u32": 0b10000,
    "vectorized_wmuls_u16s32": 0b11000,
    "vectorized_wmuls_s16u32": 0b11000,
    "vectorized_wmuls_s16s32": 0b00000,
    "vectorized_wmulas_u8u8": 0b00000,
    "vectorized_wmulas_u8s8": 0b00000,
    "vectorized_wmulas_s8s8": 0b01000,
    "vectorized_wmulas_u16u16": 0b01000,
    "vectorized_wmulas_u16s16": 0b01000,
    "vectorized_wmulas_s16s16": 0b01000,
    "vectorized_wmulas_u8s16": 0b10000,
    "vectorized_wmulas_s8s16": 0b10000,
    "vectorized_wmulas_u16u32": 0b11000,
    "vectorized_wmulas_u16s32": 0b11000,
    "vectorized_wmulas_s16u32": 0b00000,
    "vectorized_wmulas_s16s32": 0b00000,
}

_WMUL_WMULS_TYPE = {
    "vectorized_wmul_u8u8": 0b100,
    "vectorized_wmul_u8s8": 0b101,
    "vectorized_wmul_s8s8": 0b110,
    "vectorized_wmul_u16u16": 0b111,
    "vectorized_wmul_u16s16": 0b000,
    "vectorized_wmul_s16s16": 0b001,
    "vectorized_wmul_u8s16": 0b010,
    "vectorized_wmul_s8s16": 0b100,
    "vectorized_wmul_u16u32": 0b110,
    "vectorized_wmul_u16s32": 0b000,
    "vectorized_wmul_s16u32": 0b010,
    "vectorized_wmul_s16s32": 0b100,
    "vectorized_wmula_u8u8": 0b110,
    "vectorized_wmula_u8s8": 0b111,
    "vectorized_wmula_s8s8": 0b000,
    "vectorized_wmula_u16u16": 0b001,
    "vectorized_wmula_u16s16": 0b010,
    "vectorized_wmula_s16s16": 0b011,
    "vectorized_wmula_u8s16": 0b100,
    "vectorized_wmula_s8s16": 0b110,
    "vectorized_wmula_u16u32": 0b000,
    "vectorized_wmula_u16s32": 0b010,
    "vectorized_wmula_s16u32": 0b100,
    "vectorized_wmula_s16s32": 0b110,
    "vectorized_wmuls_u8u8": 0b000,
    "vectorized_wmuls_u8s8": 0b001,
    "vectorized_wmuls_s8s8": 0b010,
    "vectorized_wmuls_u16u16": 0b011,
    "vectorized_wmuls_u16s16": 0b000,
    "vectorized_wmuls_s16s16": 0b001,
    "vectorized_wmuls_u8s16": 0b010,
    "vectorized_wmuls_s8s16": 0b000,
    "vectorized_wmuls_u16u32": 0b010,
    "vectorized_wmuls_u16s32": 0b000,
    "vectorized_wmuls_s16u32": 0b010,
    "vectorized_wmuls_s16s32": 0b000,
    "vectorized_wmulas_u8u8": 0b010,
    "vectorized_wmulas_u8s8": 0b011,
    "vectorized_wmulas_s8s8": 0b000,
    "vectorized_wmulas_u16u16": 0b001,
    "vectorized_wmulas_u16s16": 0b010,
    "vectorized_wmulas_s16s16": 0b011,
    "vectorized_wmulas_u8s16": 0b000,
    "vectorized_wmulas_s8s16": 0b010,
    "vectorized_wmulas_u16u32": 0b000,
    "vectorized_wmulas_u16s32": 0b010,
    "vectorized_wmulas_s16u32": 0b000,
    "vectorized_wmulas_s16s32": 0b010,
}

_WFIFR2_TYPE = {
    "vectorized_wfifr2": 0b000,
    "vectorized_wfifr2a": 0b100,
    "vectorized_wfifr2s": 0b000,
}

_WFIFR2_WD_IDX = {
    "vectorized_wfifr2": 0b01000,
    "vectorized_wfifr2a": 0b01000,
    "vectorized_wfifr2s": 0b10000,
}

VecWmulWmuls = namedtuple("Wmul", "name mask dst src0 src1 acc_mode part_mode api_name src1_dtype")


class VectorDhistChist(STMT):
    """
    Vector dhist/chist instruction
    """
    def __init__(self, source_info, hist_params, tik_debugger):
        super(VectorDhistChist, self).__init__(source_info, tik_debugger)
        self.mask = hist_params.mask
        if TikSocManager.is_v300_610l_soc():
            self.dst_list = [hist_params.dst0, hist_params.dst1]
        else:
            self.dst_list = [hist_params.dst0, hist_params.dst1, hist_params.dst2, hist_params.dst3]
        self.src = hist_params.src  # Vn
        self.instr_name = hist_params.name

    @staticmethod
    def _eval_load_variables(context, instr_name, params_dict, dst, is_v300):
        """
        load variables

        Parameters
        ----------
        context: debug context
        instr_name: instr name
        params_dict: dict of params
        dst: the dst tensor
        is_v300: is v300 version soc

        Returns
        -------
        return:vd_index
        """
        if is_v300:
            params_dict.get("param").type = _DHIST_CHIST_TYPE_V300.get(instr_name)
        else:
            params_dict.get("param").type = _DHIST_CHIST_TYPE.get(instr_name)
        vd_index = context.alloc_v_register(dst)
        params_dict.get("param").vdIdx = vd_index
        # vmIdx is not a real register, it is a variable that controls different instructions.
        params_dict.get("param").vmIdx = 0 if "dhistv2" in instr_name else 1
        instr = context.encoder.gen_vector_dhist_chist(params_dict.get("param"))
        params_dict.get("instr_list").append(instr)
        return vd_index

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.src.dtype, 0, 4)
        instr_list = create_vloop_info(context, param)
        param.vnIdx = context.alloc_v_register(self.src)
        param.pgIdx = context.alloc_p_register(self.mask, dtype=self.src.dtype)

        params_dict = {"param": param,  "instr_list": instr_list}
        vd_index_list = []
        for index, dst in enumerate(self.dst_list):
            instr_name = self.instr_name + str(index)
            vd_index = self._eval_load_variables(context, instr_name, params_dict, dst, param.isV300)
            vd_index_list.append(vd_index)

        context.model.step_all(context, instr_list, len(instr_list))

        for index, dst in enumerate(self.dst_list):
            # read instruction result from model
            value_buffer = context.get_vector_value(dst).buffer
            flatten_np = value_buffer.reshape(-1)
            context.model.read_vec_register_by_idx(
                VecRegType.V_REG, vd_index_list[index],
                flatten_np.ctypes.data, len(flatten_np) * DTYPE_SIZE[dst.dtype])

            # cache the result and free the register
            context.set_vector_state(dst, is_valid=True)
        context.free_all_register()


class WpackWpacks(STMT):
    """
    Vector wpack/wpacks instruction
    """
    def __init__(self, source_info, wpack_params, tik_debugger):
        super(WpackWpacks, self).__init__(source_info, tik_debugger)
        self.mask = wpack_params.mask  # None, imm, scalar, expr, vector
        self.dst = wpack_params.dst  # Vd
        self.src0 = wpack_params.src0  # Wn
        self.src1 = wpack_params.src1  # Vm, Scalar, Expr, int
        self.rs_mode = wpack_params.rs_mode  # True, False
        self.part_mode = wpack_params.part_mode  # None, "EVEN", "ODD"
        self.instr_name = wpack_params.name  # "vectorized_wpack/vectorized_wpacks"

    def set_params(self, context, param, vd_index):
        """
        set params
        Parameters
        ----------
        vd_index
        context
        param

        Returns
        -------

        """
        instr_name = self.instr_name + "_" + DTYPE_MAP.get(self.src0.dtype) + DTYPE_MAP.get(self.dst.dtype)
        param.vdIdx = vd_index

        # wide reigster
        param.vnIdx = context.alloc_v_register(self.src0) | _WPACK_WAPCKS_WN_IDX.get(instr_name)

        # may no mask
        if self.mask is not None:
            param.pgIdx = context.alloc_p_register(self.mask, dtype=self.dst.dtype)
        else:
            param.pgIdx = _WPACK_WAPCKS_PG_IDX.get(instr_name)

        # instr type
        param.type = _WPACK_WAPCKS_TYPE.get(instr_name)
        if self.rs_mode is True:
            param.type = param.type | 0b001
        if self.part_mode == "ODD":
            param.type = param.type | 0b010

        # src1 can be Imm/Scalar/Expr/Vector
        if self.instr_name == "vectorized_wpack":
            param.vmIdx = context.alloc_v_register(self.src1)
            if self.mask is not None:
                param.op1 = 0x64
            else:
                param.op1 = 0x6C
        else:
            # scalar only support uint16
            sm_idx = get_and_write_share_spr(context, self.src1, "uint16")
            param.vmIdx = sm_idx >> 1
            param.type = param.type | ((sm_idx & 0b1) << 3)
            if self.mask is not None:
                param.op1 = 0x65
            else:
                param.op1 = 0x6C

        return param

    def set_params_wpack(self, context, param):
        """
        set params
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        param.vmIdx = context.alloc_v_register(self.src1)
        if self.part_mode is None and self.mask is not None:
            param.op1 = 0b1101
            param.pgIdx = context.alloc_p_register(self.mask, dtype=self.dst.dtype)
            param.type = FIFR1_TYPE.get(self.dst.dtype)
        if self.part_mode is None and self.mask is None:
            param.op1 = 0b1110
            param.pgIdx = 0
            param.type = FIFR1_TYPE.get(self.dst.dtype)
        if self.part_mode is not None:
            param.op1 = 0b1111
            param.pgIdx = 0 if self.part_mode == "EVEN" else 1
            param.type = BIT2_TYPE_16_32.get(self.dst.dtype)
        return param

    def set_params_wpacks(self, context, param):
        """
        set params
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        param.smIdx = get_and_write_share_spr(context, self.src1, "uint16")
        if self.part_mode is None and self.mask is not None:
            param.op1 = 0b101101
            param.pgIdx = context.alloc_p_register(self.mask, dtype=self.dst.dtype)
            param.type = FIFR1_TYPE.get(self.dst.dtype)
        if self.part_mode is None and self.mask is None:
            param.op1 = 0b101110
            param.pgIdx = 0
            param.type = FIFR1_TYPE.get(self.dst.dtype)
        if self.part_mode is not None:
            param.op1 = 0b101111
            param.pgIdx = 0 if self.part_mode == "EVEN" else 1
            param.type = BIT2_TYPE_16_32.get(self.dst.dtype)
        return param

    def set_params_v300(self, context, param, vd_index):
        """
        set params
        Parameters
        ----------
        vd_index
        context
        param

        Returns
        -------

        """
        param.vdIdx = vd_index

        # wide reigster
        param.vnIdx = context.alloc_v_register(self.src0)
        if self.instr_name == "vectorized_wpack":
            param = self.set_params_wpack(context, param)
        elif self.instr_name == "vectorized_wpacks":
            param = self.set_params_wpacks(context, param)
        if self.rs_mode is True:
            param.type |= 0b100
        return param

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)

        # vector register
        vd_index = context.alloc_v_register(self.dst)
        if TikSocManager.is_v300_610l_soc():
            param = self.set_params_v300(context, param, vd_index)
        else:
            param = self.set_params(context, param, vd_index)
        if TikSocManager.is_v300_610l_soc() and self.instr_name == "vectorized_wpack":
            param.smIdx = 0b10
            instr = context.encoder.gen_vector_elewise_wpackv300(param)
        elif TikSocManager.is_v300_610l_soc() and self.instr_name == "vectorized_wpacks":
            param.vmIdx = param.smIdx & 0x1f
            param.smIdx = param.smIdx >> 5
            instr = context.encoder.gen_vector_elewise_wpackv300(param)
        else:
            instr = context.encoder.gen_vector_elewise(param)
        instr_list.append(instr)

        context.model.step_all(context, instr_list, len(instr_list))

        # read instruction result from model
        if not TikSocManager.is_v300_610l_soc():
            value_buffer = context.get_vector_value(self.dst).buffer
            flatten_np = value_buffer.reshape(-1)
            vd_index_rename = context.model.get_vec_register_index(vd_index, VecRegType.V_REG)
            context.model.read_vec_register(vd_index_rename, flatten_np.ctypes.data,
                                            len(flatten_np)*DTYPE_SIZE[self.dst.dtype])
        else:
            dst_register(context, (self.dst, vd_index, VecRegType.V_REG), self.mask)
        # cache the result and free the register
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()


class WmulWmuls(STMT):
    """
    Vector wmul/wmuls instruction
    """
    def __init__(self, source_info, wmul_params, tik_debugger, is_double=True):
        super(WmulWmuls, self).__init__(source_info, tik_debugger)
        self.mask = wmul_params.mask  # None, imm, scalar, expr, vector
        self.dst = wmul_params.dst  # Vd
        self.src0 = wmul_params.src0  # Wn
        self.src1 = wmul_params.src1  # Vm, Scalar, Expr, int
        self.src1_dtype = wmul_params.src1_dtype
        self.acc_mode = wmul_params.acc_mode  # True, False
        self.part_mode = wmul_params.part_mode  # None, True, False
        # "x_wmul/x_wmula/x_wmuls/x_wmulas"
        self.instr_name = get_instr_name_by_acc_mode(wmul_params.acc_mode, wmul_params.name)
        self.is_double = is_double

    def _set_src1_param(self, context, param):
        # src1 can be Imm/Scalar/Expr/Vector
        if (self.instr_name == "vectorized_wmuls" or self.instr_name == "vectorized_wmulas")\
                and TikSocManager.is_v300_610l_soc():
            vmidx = get_and_write_share_spr(context, self.src1, self.src1_dtype)
            param.vmIdx = vmidx & 0x1F
            param.regType = vmidx >> 5
        elif (self.instr_name == "vectorized_wmuls" or self.instr_name == "vectorized_wmulas")\
                and TikSocManager.is_v210_soc():
            sm_idx = get_and_write_share_spr(context, self.src1, self.src1_dtype)
            param.vmIdx = sm_idx >> 1
            param.type = param.type | ((sm_idx & 0b1) << 2)
        else:
            param.vmIdx = context.alloc_v_register(self.src1)
        return param

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        dtype_str = DTYPE_MAP.get(self.src0.dtype) + DTYPE_MAP.get(self.src1_dtype)
        instr_name = self.instr_name + "_" + dtype_str
        if TikSocManager.is_v300_610l_soc():
            param.op1 = V300_INSTR_OP1_CODE.get(self.instr_name)
        elif TikSocManager.is_v210_soc() and instr_name in V210_INSTR_OP1_CODE:
            param.op1 = V210_INSTR_OP1_CODE.get(instr_name)
        else:
            param.op1 = V210_INSTR_OP1_CODE.get(self.instr_name)

        # wide reigster
        vd_index = context.alloc_v_register(self.dst)
        if TikSocManager.is_v300_610l_soc():
            param.vdIdx = vd_index
        else:
            param.vdIdx = vd_index | _WMUL_WMULS_WD_IDX.get(instr_name)

        # vector register
        param.vnIdx = context.alloc_v_register(self.src0)

        # may no mask
        if dtype_str in WMUL_NO_PG_DTYPE_LIST:
            param.pgIdx = 0
        else:
            param.pgIdx = context.alloc_p_register(self.mask, dtype=self.src0.dtype)

        # instr type
        if TikSocManager.is_v210_soc():
            param.type = _WMUL_WMULS_TYPE.get(instr_name)
            if self.part_mode == "ODD":
                param.type = param.type | 0b001
        elif TikSocManager.is_v300_610l_soc():
            part = 0 if self.part_mode == "EVEN" else 1
            param.type = VEC_TYPE_THREE_BITS.get(self.src1_dtype)
            """
            part: [29]
            type: [27:28]
            vdIdx: [25:26]
            """
            param.vdIdx = param.vdIdx + (FIFR1_TYPE.get(self.src0.dtype) << 2) + (part << 4)

        param = self._set_src1_param(context, param)

        return param, vd_index

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.src0.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)

        param, vd_index = self.set_param(context, param)
        instr = context.encoder.gen_vector_elewise(param)
        instr_list.append(instr)

        context.model.step_all(context, instr_list, len(instr_list))

        # read instruction result from model
        value_buffer = context.get_vector_value(self.dst).buffer
        flatten_np = value_buffer.reshape(-1)
        if self.dst.scope == scope_wreg:
            vd_idx_rename = vd_index + WREG_START_INDEX
            dst_dtype = WDTYPE_TO_DTYPE[self.dst.dtype]
        else:
            vd_idx_rename = context.model.get_vec_register_index(vd_index, VecRegType.V_REG)
            dst_dtype = self.dst.dtype
        if TikSocManager.is_v300_610l_soc():
            if self.is_double:
                self.wmul_v300_double_mode(context, vd_index, VecRegType.W_REG)
            else:
                dst_register(context, (self.dst, vd_index, VecRegType.W_REG), self.mask, is_merging=False)
        else:
            context.model.read_vec_register(vd_idx_rename, flatten_np.ctypes.data,
                                            len(flatten_np) * DTYPE_SIZE[dst_dtype])

        # cache the result and free the register
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()

    def wmul_v300_double_mode(self, context, vd_idx, vec_type):
        """
        the merging mode if in v300
        Parameters
        ----------
        context: context
        vd_idx: dst register
        vec_type: register type

        Returns
        -------
        None
        """
        value_buffer1 = context.get_vector_value(self.dst).buffer
        flatten_np = value_buffer1.reshape(-1)
        flatten_np2 = copy.deepcopy(flatten_np)
        context.model.read_vec_register_by_idx(vec_type, vd_idx, flatten_np.ctypes.data,
                                               len(flatten_np) * DTYPE_SIZE[self.dst.dtype])
        # Three numbers indicate an int48 number, and 384 numbers indicate 128 int48 numbers.
        if self.part_mode == "ODD" and DTYPE_SIZE[self.src0.dtype] == 2:
            for i in range(0, 384, 3):
                if i % 2 == 0:
                    flatten_np[i:i+3] = flatten_np2[i:i+3]
        elif self.part_mode == "EVEN" and DTYPE_SIZE[self.src0.dtype] == 2:
            for i in range(0, 384, 3):
                if i % 2 == 1:
                    flatten_np[i:i+3] = flatten_np2[i:i+3]


class WmulV2(STMT):
    """
    Vector wmul_v2 instruction
    """
    def __init__(self, source_info, wmul_params, tik_instance):
        super(WmulV2, self).__init__(source_info, tik_instance.context.tik_debugger)
        self.dst = wmul_params.dst  # Vd
        self.src0 = wmul_params.src0  # Wn
        self.src1 = wmul_params.src1  # Vm1
        self.src2 = wmul_params.src2  # Vm2
        self.acc_mode = wmul_params.acc_mode  # True, False
        # "x_wmul/x_wmula/x_wmuls/x_wmulas"
        self.instr_name = wmul_params.name # vectorized_wmul
        self.check_params_obj = VectorOpsCheck()
        self.api_name = wmul_params.api_name

    def wmul_v2_in_v300_s8(self, context):
        """
        Implementing wmul with combined instructions
        Parameters
        ----------
        context

        Returns
        -------

        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.src0.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)

        param.type = VEC_TYPE_THREE_BITS.get(self.src1.dtype)
        """
        type: [27:28]
        vdIdx: [25:26]
        """
        vd_index = context.alloc_v_register(self.dst)

        param.vdIdx = vd_index + (FIFR1_TYPE.get(self.src0.dtype) << 2)

        param.vnIdx = context.alloc_v_register(self.src0)

        vm0_idx, vm1_idx = context.alloc_v_register(self.src1, is_even=True)
        context.init_vreg_according_cache(self.src2, vm1_idx)
        param.vmIdx = vm0_idx

        param.op1 = V300_INSTR_OP1_CODE.get(self.instr_name)

        instr = context.encoder.gen_vector_elewise(param)
        instr_list.append(instr)

        context.model.step_all(context, instr_list, len(instr_list))

        dst_register(context, (self.dst, vd_index, VecRegType.W_REG))

        # cache the result and free the register
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()

    def wmul_v2_in_v300_s16(self, context):
        """
        Implementing wmul with combined instructions
        Parameters
        ----------
        context

        Returns
        -------

        """
        src1_dtype = self.check_params_obj.get_and_check_wmul_src1_dtype(
            self.src0.dtype, self.src1, "EVEN", self.api_name)
        # wmul even
        wmul_enev = VecWmulWmuls(
            "vectorized_wmul", None, self.dst, self.src0, self.src1,
            self.acc_mode, "EVEN", "vectorized_wmul", src1_dtype)
        wmul_even_obj = WmulWmuls(self.source_info, wmul_enev, context.tik_debugger, is_double=True)
        wmul_even_obj.eval_(context)
        # wmul odd
        wmul_odd = VecWmulWmuls(
            "vectorized_wmul", None, self.dst, self.src0, self.src2,
            self.acc_mode, "ODD", "vectorized_wmul", src1_dtype)
        wmul_odd_obj = WmulWmuls(self.source_info, wmul_odd, context.tik_debugger, is_double=True)
        wmul_odd_obj.eval_(context)

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """

        if TikSocManager.is_v300_610l_soc():
            if self.src0.dtype in ['uint8', 'int8']:
                self.wmul_v2_in_v300_s8(context)
            else:
                self.wmul_v2_in_v300_s16(context)


class WmulsV2(STMT):
    """
    Vector wmul_v2 instruction
    """
    def __init__(self, source_info, wmul_params, src1_dtype, tik_instance):
        super(WmulsV2, self).__init__(source_info, tik_instance.context.tik_debugger)
        self.dst = wmul_params.dst  # Vd
        self.src0 = wmul_params.src0  # Wn
        self.src1 = wmul_params.src1  # Vm1
        self.src1_dtype = src1_dtype
        self.acc_mode = wmul_params.acc_mode  # True, False
        # "x_wmul/x_wmula/x_wmuls/x_wmulas"
        self.instr_name = wmul_params.name # vectorized_wmul

    def wmuls_v2_in_v300_s8(self, context):
        """
        Implementing wmul with combined instructions
        Parameters
        ----------
        context

        Returns
        -------

        """
        wmul_odd = VecWmulWmuls(
            "vectorized_wmuls", None, self.dst, self.src0, self.src1,
            self.acc_mode, "EVEN", "vectorized_wmuls", self.src1_dtype)
        wmul_odd_obj = WmulWmuls(self.source_info, wmul_odd, context.tik_debugger, is_double=False)
        wmul_odd_obj.eval_(context)

    def wmuls_v2_in_v300_s16(self, context):
        """
        Implementing wmul with combined instructions
        Parameters
        ----------
        context

        Returns
        -------

        """
        # wmul even
        wmul_enev = VecWmulWmuls(
            "vectorized_wmuls", None, self.dst, self.src0, self.src1,
            self.acc_mode, "EVEN", "vectorized_wmuls", self.src1_dtype)
        wmul_even_obj = WmulWmuls(self.source_info, wmul_enev, context.tik_debugger, is_double=True)
        wmul_even_obj.eval_(context)
        # wmul odd
        wmul_odd = VecWmulWmuls(
            "vectorized_wmuls", None, self.dst, self.src0, self.src1,
            self.acc_mode, "ODD", "vectorized_wmuls", self.src1_dtype)
        wmul_odd_obj = WmulWmuls(self.source_info, wmul_odd, context.tik_debugger, is_double=True)
        wmul_odd_obj.eval_(context)

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """

        if TikSocManager.is_v300_610l_soc():
            if self.src0.dtype in ['uint8', 'int8']:
                self.wmuls_v2_in_v300_s8(context)
            else:
                self.wmuls_v2_in_v300_s16(context)


class Wfifr2(STMT):
    """
    Vector wmul/wmuls instruction
    """
    def __init__(self, source_info, wfifr2_params, tik_debugger):
        super(Wfifr2, self).__init__(source_info, tik_debugger)
        self.dst = wfifr2_params.dst  # Wd
        self.src0 = wfifr2_params.src0  # Vn
        self.src1 = wfifr2_params.src1  # Vn+1
        self.coef0 = wfifr2_params.coef0
        self.coef1 = wfifr2_params.coef1
        self.coef2 = wfifr2_params.coef2
        self.coef3 = wfifr2_params.coef3
        self.coef4 = wfifr2_params.coef4
        self.instr_name = wfifr2_params.name  # "x_wfifr2/x_wfifr2a/x_wfifr2s"

    def set_param(self, context, param, coef_list):
        """
        set param
        Parameters
        ----------
        coef_list
        context
        param

        Returns
        -------

        """
        # instr type
        param.type = FIFR1_TYPE.get(self.src0.dtype) | _WFIFR2_TYPE.get(self.instr_name)

        # wide reigster
        wd_index = context.alloc_v_register(self.dst)
        param.vdIdx = wd_index | _WFIFR2_WD_IDX.get(self.instr_name)

        # vector register, Vn idx must be even
        if self.src1 is None:
            param.vnIdx, _ = context.alloc_v_register(self.src0, is_even=True)
        else:
            param.vnIdx, vd1_idx = context.alloc_v_register(self.src0, is_even=True)
            context.init_vreg_according_cache(self.src1, vd1_idx)

        # concat the input coefficient to a uint32 data
        dtype = "uint32"
        filter_coef = concat_params(coef_list,
                                    WFIFR2_OFFSET_LIST, WFIFR2_BITWIDE_LIST, dtype)
        sm_idx = get_and_write_share_spr(context, filter_coef, dtype)
        param.vmIdx = sm_idx >> 1
        param.op1 = 0x6B  # instr encode

        return param, wd_index

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.src0.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)

        # check coefficient, cx must be in range [-16, 15]
        coef0_value = context.evaluate_expr(self.coef0)
        coef1_value = context.evaluate_expr(self.coef1)
        coef2_value = context.evaluate_expr(self.coef2)
        coef3_value = context.evaluate_expr(self.coef3)
        coef4_value = context.evaluate_expr(self.coef4)
        check_param_type_range(
            [coef0_value, coef1_value, coef2_value, coef3_value, coef4_value],
            [-16, -16, -16, -16, -16], [15, 15, 15, 15, 15],
            ["coef0", "coef1", "coef2", "coef3", "coef4"], "vector_vfilter")

        param, wd_index = self.set_param(context, param,
                                         [coef0_value, coef1_value, coef2_value, coef3_value, coef4_value])

        instr = context.encoder.gen_vector_elewise(param)
        instr_list.append(instr)

        context.model.step_all(context, instr_list, len(instr_list))

        # read instruction result from model
        value_buffer = context.get_vector_value(self.dst).buffer
        flatten_np = value_buffer.reshape(-1)
        wd_idx_rename = wd_index + WREG_START_INDEX
        dst_dtype = WDTYPE_TO_DTYPE.get(self.dst.dtype)
        context.model.read_vec_register(wd_idx_rename, flatten_np.ctypes.data,
                                        len(flatten_np) * DTYPE_SIZE[dst_dtype])

        # cache the result and free the register
        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()
