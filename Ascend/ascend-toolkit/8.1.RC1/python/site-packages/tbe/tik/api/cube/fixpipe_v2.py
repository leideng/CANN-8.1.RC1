#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     fixpipe_v2.py
DESC:     provide tiling method
CREATED:  2022-6-9 11:12:13
MODIFIED: 2022-6-9 11:12:13
"""
from collections import namedtuple
import numpy as np

from tbe import tvm
from tbe.common.platform.platform_info import scope_gm
from tbe.common.platform.platform_info import scope_fb0
from tbe.common.platform.platform_info import scope_cbuf
from tbe.tik.api.cube.fixpipe import FixpipeImpl
from tbe.tik.api.cube.fixpipe_info import FixpipeInfoV2
from tbe.tik.tik_lib.tik_api_constants import SCOPE_MAP
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_params import PIPE_S
from tbe.tik.tik_lib.tik_params import PIPE_FIX
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.common.util import reduce_mul
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.api.tik_check_api import is_tik_var
from tbe.tik.debug.decorators_cube import fixpipe_v2_deq_decorator
from tbe.tik.debug.decorators_cube import fixpipe_v2_vdeq_decorator
from tbe.tik.debug.decorators_cube import cbuf2fbuf_decorator
from tbe.tik.debug.decorators_cube import set_quant_pre_decorator


def gen_fixpipe_tiling(fixpipe_config):
    """
    get fixpipe tiling
    """
    n_size = fixpipe_config.n_size
    max_deq_nums = 256
    fixpipe_tiling = namedtuple("FixpipeTiling", ["n_iter_num", "n_size", "is_db", "tail_n_size"])
    if n_size < max_deq_nums:
        best_tiling = fixpipe_tiling(1, n_size, False, 0)
    else:
        is_db = True
        db_max_deq_nums = max_deq_nums // 2
        n_iter_num = n_size // db_max_deq_nums
        tail_n_size = n_size % db_max_deq_nums
        best_tiling = fixpipe_tiling(n_iter_num, db_max_deq_nums, is_db, tail_n_size)
    return best_tiling


class FixPipeImplV2(FixpipeImpl):
    """
    implement class of fixpipe
    """
    FixpipeV2Params = namedtuple("FixpipeV2Params", ["fixpipe_config", "fixpipe_api", "fixpipe_tensor", "n_size",
                                                     "src_offset", "dst_offset"])
    CopyDeqTensorParams = namedtuple("CopyDeqTensorParams", ["fixpipe_config", "fixpipe_tensor", "gm_tensor", "n_size",
                                                             "n_iter_index"])

    fixpipe_dma_info = {
        # l0c16/l0c32-ub
        ("cc_m", "ubuf"): (PIPE_FIX, 'copy_matrix_cc_to_ub'),
        # l0c16/l0c32-gm
        ("cc_m", "gm"): (PIPE_FIX, 'copy_matrix_cc_to_gm'),
    }

    @staticmethod
    def _check_deqtype_tensor(quantize_params):
        if isinstance(quantize_params.get("mode_param"), Tensor):
            TikCheckUtil.check_equality(
                    quantize_params.get("mode_param").dtype, "float32",
                    "quantize_params 'mode_param' should be tensor of float32.")
            TikCheckUtil.check_equality(
                quantize_params.get("mode_param").scope, scope_gm,
                "quantize_params 'mode_param' tensor's scope should be scope_gm.")
            deq_tensor_shape = quantize_params.get("mode_param").shape
            actual_ele = Expr(reduce_mul(quantize_params.get("mode_param").original_shape)).eval_value()
            expected_ele = Expr(quantize_params.get("mode_param").offset + 16).eval_value()
            if actual_ele is not None and expected_ele is not None:
                TikCheckUtil.check_ge(
                    actual_ele, expected_ele,
                    "deqscale tensor overflow, expected elements: %d, actual elements: %d." %
                    (expected_ele, actual_ele))

    @staticmethod
    def _check_fixpipe_relu_params(extend_params, fixpipe_config):
        relu = extend_params.get("relu")
        if "relu" not in extend_params:
            return
        TikCheckUtil.check_type_match(relu, bool, "extend_params 'relu' should be bool type.")

    def check_all(self, fixpipe_api):
        """
        check fixpipe to param
        """
        self._check_operator(fixpipe_api)
        self._check_dtype_burst(fixpipe_api)
        self._check_stride(fixpipe_api)
        fixpipe_config = self._check_extend_params(fixpipe_api)
        self._check_fixpipe_tensor_overflow(fixpipe_api.dst, fixpipe_api.src,
                                            fixpipe_api.cburst_num, fixpipe_api.burst_len)
        return fixpipe_config

    def execute(self, fixpipe_api, fixpipe_config):
        """
        execute of fixpipe to gen code
        """
        self._make_fixpipe_code_v2(fixpipe_config, fixpipe_api)
        self.tik_instance.set_high_level_api_state()

    def _check_deqscale(self, quantize_params, fixpipe_config, dtype_str):
        if dtype_str not in ("s32f16",):
            TikCheckUtil.check_is(
                quantize_params.get("mode_param"), None,
                "quantize_params 'mode_param' should be None when src and dst dtype is %s" % dtype_str)
        else:
            TikCheckUtil.check_type_match(
                quantize_params.get("mode_param"), (float, Scalar, Tensor, np.float32),
                "Please specify your quantize_params 'mode_param': immediate/Scalar/Tensor for deq mode.")

            if isinstance(quantize_params.get("mode_param"), Scalar):
                TikCheckUtil.check_equality(
                    quantize_params.get("mode_param").dtype, "float32",
                    "quantize_params 'mode_param' should be a scalar of float32.")
            self._check_deqtype_tensor(quantize_params)

    def _check_extend_params(self, fixpipe_api):
        """
        check extend_params
        """
        dtype_str = DTYPE_MAP.get(fixpipe_api.src.dtype) + DTYPE_MAP.get(fixpipe_api.dst.dtype)
        if fixpipe_api.extend_params is not None:
            TikCheckUtil.check_type_match(
                fixpipe_api.extend_params, dict,
                "extend_params should be dict, input type is %s" % type(fixpipe_api.extend_params))
            if not set(fixpipe_api.extend_params.keys()).issubset(
                    {"quantize_params", "relu"}):
                TikCheckUtil.raise_error("input extend_params dict contains invalid key, please check!")

        fixpipe_config = FixpipeInfoV2(fixpipe_api)
        # check extend_params
        if dtype_str in ("s32f16", "f32f16"):
            TikCheckUtil.check_not_is(
                fixpipe_api.extend_params, None,
                "extend_params should not be None when src and dst dtype is %s" % dtype_str)
            TikCheckUtil.check_equality(
                fixpipe_config.has_deq(), True,
                "extend_params 'quantize_params' should not be None when src and dst dtype is %s" % dtype_str)
        if fixpipe_api.extend_params is not None:
            self._check_fixpipe_deq_params(dtype_str, fixpipe_api.extend_params, fixpipe_api.cburst_num,
                                           fixpipe_config)
            self._check_fixpipe_relu_params(fixpipe_api.extend_params, fixpipe_config)
        return fixpipe_config

    @set_quant_pre_decorator
    def _set_quant_pre(self, fixpipe_config):
        # deq factor of uint64 bits describe: bits[0:31] is deq value of fp32,
        if is_tik_var(fixpipe_config.deq_value):
            temp_scalar = self.tik_instance.ScalarArray(dtype='float32', length=2,
                                                        init_value=(fixpipe_config.deq_value, 0))
            deq_value_uint64 = temp_scalar[0].reinterpret_cast_to("uint64")
        else:
            # conversion from float to bit
            deq_value_uint32 = np.float32(fixpipe_config.deq_value).view("uint32")
            deq_value_uint64 = np.uint64(deq_value_uint32)

        self.tik_instance.emit(tvm.call_extern("uint64", "set_quant_pre",
                                               type_convert(deq_value_uint64, dtype="uint64")))

    def _emit_dcci(self, gm_tensor):
        """
        emit a dcci for flush the DDR cache
        :param gm_tensor: the dst tensor
        :return: None
        """
        str_entire_type = tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print',
                                                   tvm.expr.StringImm("ENTIRE_DATA_CACHE"))
        str_cacheline_type = tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print',
                                                      tvm.expr.StringImm("CACHELINE_OUT"))
        instr_dcci = tvm.call_extern(
            gm_tensor.dtype, "dcci", gm_tensor.access_ptr("w"), str_entire_type, str_cacheline_type)
        self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_S)
        self.tik_instance.emit(instr_dcci)

    @cbuf2fbuf_decorator
    def _copy_deq_tensor_to_fbuf(self, copy_deq_tensor_params, deq_value_offset=None):
        with self.tik_instance.context.freeze():
            deqscale = self.tik_instance.Tensor("int64", (copy_deq_tensor_params.n_size,),
                                                name='deqscale_l1', scope=scope_cbuf)
            if deq_value_offset is None:
                deq_value_offset = self.tik_instance.Scalar(
                    "int32",  init_value=copy_deq_tensor_params.n_iter_index * copy_deq_tensor_params.n_size)
            with self.tik_instance.for_range(0, copy_deq_tensor_params.n_size//16, thread_num=0) as index:
                for i in range(16):
                    value = copy_deq_tensor_params.fixpipe_config.deq_value[deq_value_offset + index*16 + i]
                    deq_scalar = self.tik_instance.ScalarArray(dtype='float32', length=2, init_value=(value, 0))
                    copy_deq_tensor_params.gm_tensor[index*16+i].set_as(deq_scalar[0].reinterpret_cast_to("uint64"))

                # flust the ddr cache before read data from GM to L1
                # must insert one dcci with 16 int64
                self._emit_dcci(copy_deq_tensor_params.gm_tensor[index*16:])

            deq_data_size = copy_deq_tensor_params.n_size * DTYPE_SIZE[copy_deq_tensor_params.fixpipe_tensor.dtype]
            self.tik_instance.data_move(deqscale, copy_deq_tensor_params.gm_tensor, 0, 1,
                                        deq_data_size // ONE_BLK_SIZE, 0, 0)
            deq_copy_intrin_name = "copy_cbuf_to_fbuf"
            # copy from cbuf to fbuf, burst_len unit is 128Bytes, 610l soc unit is 64Bytes
            fbuf_burst_unit = 64 if TikSocManager.is_610l_soc() else 128
            fb_burst_len = deq_data_size // fbuf_burst_unit
            instr_data_to_fb = tvm.call_extern(
                copy_deq_tensor_params.fixpipe_tensor.dtype, deq_copy_intrin_name,
                copy_deq_tensor_params.fixpipe_tensor.access_ptr("w", extent=deq_data_size),
                deqscale.access_ptr("r", extent=deq_data_size), *(type_convert([1, fb_burst_len, 0, 0])))
            self.tik_instance.emit(instr_data_to_fb)

            fixpipe_tensor_addr = type_convert(copy_deq_tensor_params.fixpipe_tensor.access_ptr("r"), dtype="uint64_t")
            # FPC of fixpipe buffer for Quant_PRE is FPC[15:8], unit is 128Bytes
            fixpipe_tensor_addr = fixpipe_tensor_addr // 128 << 8
            instr_set_fpc = tvm.call_extern("uint64_t", "set_fpc", fixpipe_tensor_addr)
            self.tik_instance.emit(instr_set_fpc)

    @fixpipe_v2_vdeq_decorator
    def _fixpipe_vdeq_code_gen(self, fixpipe_vdeq_params):
        """
        move data L0C->gm
        :param fixpipe_vdeq_params: fixpipe_config, fixpipe_api, fixpipe_tensor, n_size, src_offset, dst_offset
        """
        src_scope = SCOPE_MAP.get(fixpipe_vdeq_params.fixpipe_api.src.scope)
        dst_scope = SCOPE_MAP.get(fixpipe_vdeq_params.fixpipe_api.dst.scope)
        if src_scope == "cc":
            src_scope = src_scope + "_m"
        str_deq_mode = tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print',
                                                tvm.expr.StringImm(fixpipe_vdeq_params.fixpipe_config.quant_mode))
        if TikSocManager.is_310b_610l_soc():
            # is 310b soc, dst_stride in unit of element, input dst_stride in unit of 32B.
            dst_stride = fixpipe_vdeq_params.fixpipe_config.dst_stride * ONE_BLK_SIZE \
                         // DTYPE_SIZE[fixpipe_vdeq_params.fixpipe_api.dst.dtype]
            params = [fixpipe_vdeq_params.fixpipe_config.sid, fixpipe_vdeq_params.n_size,
                      fixpipe_vdeq_params.fixpipe_config.m_size, dst_stride,
                      fixpipe_vdeq_params.fixpipe_config.src_stride,
                      fixpipe_vdeq_params.fixpipe_config.clip_relu_pre,
                      fixpipe_vdeq_params.fixpipe_config.unit_flag_mode,
                      str_deq_mode, fixpipe_vdeq_params.fixpipe_config.relu,
                      fixpipe_vdeq_params.fixpipe_config.channel_split,
                      fixpipe_vdeq_params.fixpipe_config.nz2nd_mode,
                      *fixpipe_vdeq_params.fixpipe_config.disable_params]
        else:
            # is 910b soc, dst_stride in unit of 32B, input dst_stride in unit of 32B.
            params = [fixpipe_vdeq_params.fixpipe_config.sid, fixpipe_vdeq_params.n_size,
                      fixpipe_vdeq_params.fixpipe_config.m_size, fixpipe_vdeq_params.fixpipe_config.dst_stride,
                      fixpipe_vdeq_params.fixpipe_config.src_stride, fixpipe_vdeq_params.fixpipe_config.unit_flag_mode,
                      str_deq_mode, fixpipe_vdeq_params.fixpipe_config.relu,
                      fixpipe_vdeq_params.fixpipe_config.channel_split, fixpipe_vdeq_params.fixpipe_config.nz2nd_mode]

        pipe_line, intrin_name = self.fixpipe_dma_info.get((src_scope, dst_scope))
        deq_data_size = reduce_mul(fixpipe_vdeq_params.fixpipe_tensor.shape) * DTYPE_SIZE.get(
            fixpipe_vdeq_params.fixpipe_tensor.dtype)
        cburst_num = fixpipe_vdeq_params.n_size // 16

        dst_extent = ((cburst_num - 1) * fixpipe_vdeq_params.fixpipe_config.dst_stride +
                      fixpipe_vdeq_params.fixpipe_api.burst_len) * 32
        src_extent = (cburst_num - 1) * fixpipe_vdeq_params.fixpipe_config.src_stride * \
                     fixpipe_vdeq_params.fixpipe_config.c_0 * \
                     DTYPE_SIZE.get(fixpipe_vdeq_params.fixpipe_config.src_dtype) + \
                     fixpipe_vdeq_params.fixpipe_api.burst_len * 32

        # fixpipe_tensor set implicit, l0c to gm depends the data in FB
        instr = tvm.call_extern(fixpipe_vdeq_params.fixpipe_api.dst.dtype, intrin_name,
                                fixpipe_vdeq_params.fixpipe_api.dst[fixpipe_vdeq_params.dst_offset:].access_ptr(
                                    "w", extent=dst_extent),
                                fixpipe_vdeq_params.fixpipe_api.src[fixpipe_vdeq_params.src_offset:].access_ptr(
                                    "r", extent=src_extent),
                                *type_convert(params),
                                fixpipe_vdeq_params.fixpipe_tensor.access_ptr(
                                    "r", extent=deq_data_size, is_implicit=True))

        self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", pipe_line)
        self.tik_instance.emit(instr)

    @fixpipe_v2_deq_decorator
    def _fixpipe_deq_code_gen(self, fixpipe_config, fixpipe_api):
        """
        move data L0C->gm
        :param fixpipe_api:
        :param fixpipe_config:
        :return:
        """
        src_scope = SCOPE_MAP[fixpipe_api.src.scope]
        dst_scope = SCOPE_MAP[fixpipe_api.dst.scope]
        if src_scope == "cc":
            src_scope = src_scope + "_m"
        str_deq_mode = tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print',
                                                tvm.expr.StringImm(fixpipe_config.quant_mode))
        if TikSocManager.is_310b_610l_soc():
            # is 310b soc, dst_stride in unit of element, input dst_stride in unit of 32B.
            dst_stride = fixpipe_config.dst_stride * ONE_BLK_SIZE // DTYPE_SIZE[fixpipe_api.dst.dtype]
            params = [fixpipe_config.sid, fixpipe_config.n_size, fixpipe_config.m_size, dst_stride,
                      fixpipe_config.src_stride, fixpipe_config.clip_relu_pre, fixpipe_config.unit_flag_mode,
                      str_deq_mode, fixpipe_config.relu, fixpipe_config.channel_split, fixpipe_config.nz2nd_mode,
                      *fixpipe_config.disable_params]
        else:
            # is 910b soc, dst_stride in unit of 32B, input dst_stride in unit of 32B.
            params = [fixpipe_config.sid, fixpipe_config.n_size, fixpipe_config.m_size, fixpipe_config.dst_stride,
                      fixpipe_config.src_stride, fixpipe_config.unit_flag_mode, str_deq_mode,
                      fixpipe_config.relu, fixpipe_config.channel_split, fixpipe_config.nz2nd_mode]

        pipe_line, intrin_name = self.fixpipe_dma_info.get((src_scope, dst_scope))

        dst_extent = ((fixpipe_api.cburst_num - 1) * fixpipe_config.dst_stride + fixpipe_api.burst_len) * 32
        src_extent = (fixpipe_api.cburst_num - 1) * fixpipe_config.src_stride * \
                      fixpipe_config.c_0 * DTYPE_SIZE[fixpipe_config.src_dtype] + fixpipe_api.burst_len * 32

        instr = tvm.call_extern(fixpipe_api.dst.dtype, intrin_name,
                                fixpipe_api.dst.access_ptr("w", extent=dst_extent),
                                fixpipe_api.src.access_ptr("r", extent=src_extent),
                                *type_convert(params))
        self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", pipe_line)
        self.tik_instance.emit(instr)

    def _make_fixpipe_code_v2(self, fixpipe_config, fixpipe_api):
        """
        create fixpipe code according the input params
        :param fixpipe_config: fixpipe config info
        :param fixpipe_api: fixpipe input params
        :return: None
        """
        with self.tik_instance.new_scope():
            """
            make code for VDEQF16 mode:
            1. generate best tiling
            2. copy deq tensor from gm to fb0
            3. code gen: move data from l0c to gm 
            """
            if fixpipe_config.quant_mode == "VDEQF16":
                best_tiling = gen_fixpipe_tiling(fixpipe_config)
                thread_nums = 2 if best_tiling.is_db else 1
                gm_tensor = self.tik_instance.Tensor(dtype="int64", shape=[best_tiling.n_size, ], scope=scope_gm,
                                                     name="temp_gm_tensor", is_workspace=True)
                cburst_num = best_tiling.n_size // 16
                with self.tik_instance.for_range(0, best_tiling.n_iter_num, thread_num=thread_nums) as n_iter_index:
                    fixpipe_tensor = self.tik_instance.Tensor(
                        dtype="uint64", shape=[best_tiling.n_size, ], scope=scope_fb0, name="fixpipe_deq_tensor")
                    copy_deq_tensor_params = FixPipeImplV2.CopyDeqTensorParams(
                        fixpipe_config, fixpipe_tensor, gm_tensor, best_tiling.n_size, n_iter_index)
                    self._copy_deq_tensor_to_fbuf(copy_deq_tensor_params)
                    src_offset = cburst_num * n_iter_index * fixpipe_config.src_stride * fixpipe_config.c_0
                    dst_offset = cburst_num * n_iter_index * fixpipe_config.dst_stride * 32 // DTYPE_SIZE[
                        fixpipe_config.dst_dtype]
                    fixpipe_vdeq_params = FixPipeImplV2.FixpipeV2Params(fixpipe_config, fixpipe_api, fixpipe_tensor,
                                                                        best_tiling.n_size, src_offset, dst_offset)
                    self._fixpipe_vdeq_code_gen(fixpipe_vdeq_params)

                """
                deal with the tail, it also need copy deq tensor from gm to fb0 and code gen: move data from l0c to gm 
                """
                if best_tiling.tail_n_size > 0:
                    fixpipe_tensor = self.tik_instance.Tensor(
                        dtype="uint64", shape=[best_tiling.tail_n_size, ], scope=scope_fb0,
                        name="fixpipe_deq_tensor_tail")
                    src_offset = cburst_num * best_tiling.n_iter_num * fixpipe_config.src_stride * fixpipe_config.c_0
                    dst_offset = cburst_num * best_tiling.n_iter_num * fixpipe_config.dst_stride * 32 // DTYPE_SIZE[
                        fixpipe_config.dst_dtype]
                    copy_deq_tensor_params = FixPipeImplV2.CopyDeqTensorParams(
                        fixpipe_config, fixpipe_tensor, gm_tensor, best_tiling.tail_n_size, best_tiling.n_iter_num)
                    self._copy_deq_tensor_to_fbuf(copy_deq_tensor_params,
                                                  deq_value_offset=best_tiling.n_iter_num*best_tiling.n_size)
                    fixpipe_vdeq_params = FixPipeImplV2.FixpipeV2Params(fixpipe_config, fixpipe_api, fixpipe_tensor,
                                                                        best_tiling.tail_n_size, src_offset, dst_offset)
                    self._fixpipe_vdeq_code_gen(fixpipe_vdeq_params)

            else:
                """
                make code for DEQF16 mode:
                it is a scalar, only need move scalar and move data from l0c to gm 
                """
                if fixpipe_config.quant_mode == "DEQF16":  # set deq value to QUANT_PRE register
                    self._set_quant_pre(fixpipe_config)
                self._fixpipe_deq_code_gen(fixpipe_config, fixpipe_api)
