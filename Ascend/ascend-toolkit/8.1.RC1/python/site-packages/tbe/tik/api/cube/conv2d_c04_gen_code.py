#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     conv2d_c04_gen_code
DESC:     provide code gen method for conv2d with c0=4
CREATED:  2022-4-10 17:35:36
MODIFIED: 2022-4-12 19:17:00
"""

from tbe.common.platform import scope_ca
from tbe.common.platform import scope_cb

from tbe.tik.api.cube.cube_common import CubeModeTiling
from tbe.tik.api.cube.cube_common import CubeCodeMake
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager


class CubeCodeMakeC04(CubeCodeMake):
    """
    class for conv2d or matmul to make code for load3d, load2d, mmad with c0=4
    """

    @staticmethod
    def make_load_l0a_code(param_cls):
        """
        create code of load3d, load data from L1 to L0A
        Parameters
        ----------
        param_cls.cin_actual: k tile block num
        param_cls.cin_i: index of k tile block
        param_cls.hw_actual_size: m tile block num
        param_cls.hw_i: index of m tile block
        param_cls.tiling : data struct save tiling info
        param_cls.param: others params, input fm shape, kernel info, dilations
        Returns
        -------
        data_l0a: tensor of load3d result
        """
        inst = param_cls.param.tik_instance
        # data l0a size only need hw_actual_size * cin_actual blocks,
        # but for performance of ping pong with tail block, apply m_tile_block * cin_actual blocks
        data_l0a = inst.Tensor(param_cls.param.fm_desc.input_dtype,
                               (param_cls.tiling.m_tile_block, param_cls.cin_actual,
                                param_cls.tiling.block_size, param_cls.tiling.c_0),
                               name=param_cls.param.feature_map.tensor.buffer.name + "L0A", scope=scope_ca)

        k_start_pt = param_cls.cin_i * param_cls.tiling.k_tile_block * param_cls.tiling.c_0
        m_start_pt = param_cls.hw_i * param_cls.tiling.m_tile_nums
        channel_size = param_cls.param.fm_desc.cin
        inst.load3dv2(data_l0a, param_cls.param.feature_map.flat_access(0), param_cls.param.fm_desc.pad_list,
                      param_cls.param.fm_desc.h_i, param_cls.param.fm_desc.w_i, channel_size,
                      param_cls.cin_actual * param_cls.tiling.c_0,
                      param_cls.hw_actual_size,
                      k_start_pt, m_start_pt,
                      param_cls.param.fm_desc.stride_w, param_cls.param.fm_desc.stride_h,
                      param_cls.param.k_w, param_cls.param.k_h,
                      param_cls.param.dilation_w, param_cls.param.dilation_h,
                      pad_value=param_cls.param.pad_value)
        return data_l0a

    @staticmethod
    def make_load_l0b_code(param_cls):
        """
        create code of load2d, load data from L1 to L0B
        Parameters
        ----------
        param_cls.cin_actual: k tile block num
        param_cls.cout_actual: n tile block num
        param_cls.cout_i: index of n tile block
        param_cls.cin_i: index of k tile block
        param_cls.tiling : data struct save tiling info
        param_cls.param: others params, input fm shape, kernel info, dilations
        Returns
        -------
        data_l0b: tensor of load2d result
        """
        inst = param_cls.param.tik_instance
        fractal_size = param_cls.tiling.block_size * param_cls.tiling.c_0
        l0b_size = param_cls.cin_actual * param_cls.cout_actual * fractal_size
        data_l0b = inst.Tensor(param_cls.param.weight.dtype, (l0b_size,),
                               name=param_cls.param.weight.tensor.buffer.name + "L0B", scope=scope_cb)

        if TikSocManager.is_610l_soc():
            inst.load2dv3(data_l0b, param_cls.param.weight.flat_access(0),
                          param_cls.cout_i * param_cls.tiling.n_tile_block,
                          param_cls.cin_i * param_cls.tiling.k_tile_block,
                          param_cls.tiling.n_block_num, param_cls.cout_actual,
                          param_cls.cout_actual, param_cls.cin_actual, 0)
            return data_l0b

        row_size = param_cls.tiling.n_block_num * fractal_size
        weight_l1_start_addr = param_cls.cin_i * param_cls.tiling.k_tile_block * row_size + \
                               param_cls.cout_i * param_cls.tiling.n_tile_block * fractal_size

        if param_cls.tiling.n_iter_num == 1:
            inst.load2dv2(data_l0b, param_cls.param.weight.flat_access(weight_l1_start_addr), 0,
                          param_cls.cout_actual * param_cls.cin_actual, 0, 1, 0)
        else:
            # load row by row
            if param_cls.cin_actual < param_cls.cout_actual:  # work ok
                with inst.for_range(0, param_cls.cin_actual) as sub_cin_idx:
                    l0b_idx = sub_cin_idx * param_cls.cout_actual * fractal_size
                    w_idx = weight_l1_start_addr + sub_cin_idx*row_size
                    inst.load2dv2(data_l0b[l0b_idx:], param_cls.param.weight.flat_access(w_idx), 0,
                                  param_cls.cout_actual, 0, 1, 0)
            else:  # load by column, work ok
                with inst.for_range(0, param_cls.cout_actual) as sub_cout_idx:
                    l0b_idx = sub_cout_idx * fractal_size
                    w_idx = l0b_idx + weight_l1_start_addr
                    inst.load2dv2(data_l0b[l0b_idx:], param_cls.param.weight.flat_access(w_idx), 0,
                                  param_cls.cin_actual, (param_cls.cout_actual-1), param_cls.tiling.n_block_num, 0)

        return data_l0b


class CubeModeTilingC04(CubeCodeMakeC04, CubeModeTiling):
    """
    class for conv2d and matmul for deal with mn, nm, kn, nk tiling mode
    """

    def __init__(self):
        super(CubeModeTilingC04, self).__init__()
        self.tik_instance = None

    @staticmethod
    def _check_num(tiling, has_tail, iter_num, thread_num):
        """
        check the iter num, whether is odd, if iter num is odd,
        """
        return iter_num > 2 and thread_num > 1 and iter_num & 1
