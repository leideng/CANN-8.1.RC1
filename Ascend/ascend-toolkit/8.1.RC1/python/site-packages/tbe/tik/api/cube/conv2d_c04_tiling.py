#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     conv2d.py
DESC:     provide tiling method
CREATED:  2020-4-23 21:12:13
MODIFIED: 2020-12-7 19:17:00
"""

import math
import itertools

from tbe.common.platform.platform_info import get_soc_spec
from tbe.tik.api.cube.cube_common import CubeTilingMake
from tbe.tik.api.cube.conv2d import ValidTilingInfo
from tbe.tik.api.cube.conv2d import ConvTileInfo
from tbe.tik.api.cube.conv2d import TilingParams
from tbe.tik.api.cube.load3dv2_cycles import TilingCyclesEvalParams, eval_load3dv2_cycles
from tbe.tik.common.common_util import DTYPE_SIZE
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_params import BYTE_PER_C0


class ConvTileInfoC04(ConvTileInfo):
    """
    Conv Tiling Info
    """

    def __init__(self, conv_tile, cube_size, valid_tiling_info):
        super(ConvTileInfoC04, self).__init__(conv_tile, cube_size)
        self.is_conv2d_c04 = True

        # current diff chip version, cube n size is diff, for example, SD3403, cube n is 8
        self.cube_n_size = cube_size[1]
        self.cube_k_size = cube_size[2]
        self.valid_tiling_info = valid_tiling_info

    def __str__(self):
        """
        for print tiling info
        """
        return "HoWo: tile_block {} thread {} iter {} has tail {} tail_block {}\n" \
               "Cin: tile_block {} thread {} iter {} has tail {}\n" \
               "Cout tile_block {} thread {} iter {} has tail {}\n" \
               "loop mode {} \ntotal_cycles {}\n" \
            .format(self.m_tile_block, self.m_thread_num, self.m_iter_num, self.m_has_tail, self.m_tail_nums,
                    self.k_tile_block, self.k_thread_num, self.k_iter_num, self.k_has_tail, self.n_tile_block,
                    self.n_thread_num, self.n_iter_num, self.n_has_tail, self.loop_mode, self.total_cycles)

    def get_load_l0a_cycles(self, m_tile_block, k_tile_block, load_l0b_cycles=0):
        """
        get load3d cycles
        Parameters
        ----------
        m_tile_block: M block nums
        k_tile_block: K block nums
        load_l0b_cycles: load2d cycles before load3d instruction

        Returns
        ----------
        load_l0a_cycles: load3d needed cycles
        """
        # DMA latency is 15 ~ 16
        head_cost = 15
        times_key = str(m_tile_block) + "_" + str(k_tile_block)
        if times_key in self.valid_tiling_info.load3dv2_cycles_map:
            load3dv2_cycles = self.valid_tiling_info.load3dv2_cycles_map[times_key]
        else:
            tiling_cycles_eval_params = TilingCyclesEvalParams(
                self.fm_desc, self.filter_desc, m_tile_block, k_tile_block, self.c_0)
            load3dv2_times = eval_load3dv2_cycles(tiling_cycles_eval_params)
            # if soc is 910b, both fp16 and int8 use cycles = times * 1.1 + 32
            if TikSocManager.is_910b_soc():
                load3dv2_cycles = load3dv2_times * 1.1 + 32
            # if soc is sd3403, fp16 and int8 is not same;
            elif self.c_0 == 16:
                load3dv2_cycles = load3dv2_times * 1.1 + 35
            else:
                load3dv2_cycles = load3dv2_times * 1.8 + 35  # int8 diff with float16 load
            self.valid_tiling_info.load3dv2_cycles_map[times_key] = load3dv2_cycles

        if self.loop_mode == "nm" and self.m_iter_num > 1 and self.m_thread_num > 1 and self.k_tile_block > 1 and \
                load3dv2_cycles >= head_cost:
            load3dv2_cycles -= head_cost
        elif self.loop_mode == "mn" and self.m_iter_num > 1 and self.m_thread_num > 1 and load_l0b_cycles >= head_cost:
            load3dv2_cycles -= head_cost
        return load3dv2_cycles

    def get_cube_cycles(self, m_tile_block, k_tile_block, n_tile_block):
        """
        cal mmad cycles
        """
        # M/K/N is block nums
        # theroy cycles: float16: M*16*K*16*N*16/cube_m_size/cube_k_size/cube_n_size -> M*K*N
        #                int8:    M*16*K*32*N*16/cube_m_size/cube_k_size/cube_n_size -> M*K*N
        cube_cycles = m_tile_block * k_tile_block * n_tile_block * self.c_0 * self.block_size // \
                      self.cube_k_size // self.cube_n_size

        # load head-tail cost, instruction lines is 12,
        # so head-tail cost is 12 - 1
        # but camodel log result is 15
        head_cost = 15
        cube_cycles += head_cost
        return cube_cycles

    def get_load_l0b_cycles(self, k_tile_block, n_tile_block):
        """
        cal load2d cycles
        """
        # DMA latency is 10 ~ 11
        head_cost = 22

        # SD3403 l1 -> l0b bw is 128B
        # load cycles is k_tile_block * c_0 * n_tile_block * block_size // 128
        if self.n_iter_num != 1:
            if k_tile_block < n_tile_block:
                load_l0b_cycles = k_tile_block * (n_tile_block * 4 + head_cost)
            else:
                load_l0b_cycles = n_tile_block * (k_tile_block * 4 + head_cost)
        else:
            # l0b mode is 1 or (l0b mode is 0 and n_iter_num is 1)
            load_l0b_cycles = k_tile_block * n_tile_block * 4 + head_cost

        if self.loop_mode == "mn" and self.n_iter_num > 1 and \
                (self.n_thread_num > 1 or self.m_thread_num > 1 or self.k_thread_num > 1):
            load_l0b_cycles -= 11
        return load_l0b_cycles


class ValidTilingInfoC04(ValidTilingInfo, CubeTilingMake):
    """
    valid tiling info
    """
    def __init__(self, fm_desc, filter_desc, cube_size, tik_instance):
        super(ValidTilingInfoC04, self).__init__(fm_desc, filter_desc, cube_size, tik_instance)
        self.cube_size = cube_size
        self.load3dv2_cycles_map = {}

    def get_loop_modes(self, m_block_num, n_block_num, k_block_num, modes):
        """
        according the block num and modes to create loop modes
        """
        m_thread_nums, n_thread_nums = self._get_m_n_thread_nums(m_block_num, n_block_num)

        if k_block_num >= 8:
            k_thread_nums = [2]
        elif k_block_num > 1:
            k_thread_nums = [2, 1]
        else:
            k_thread_nums = [1]

        loop_modes = []
        for num in itertools.product(m_thread_nums, n_thread_nums, k_thread_nums, modes):
            loop_modes.append(num)
        return loop_modes

    def create_tiling_info(self, tile_block_list, iter_num_list, thread_num_list, loop_mode):
        """
        create tiling info object and save to tiling list
        """
        m_tile_block, k_tile_block, n_tile_block = tile_block_list
        m_thread_num, k_thread_num, n_thread_num = thread_num_list
        m_iter_num, k_iter_num, n_iter_num = iter_num_list

        tiling_params = TilingParams(self.fm_desc, self.filter_desc,
                                     self.m_block_num, m_tile_block, m_thread_num, m_iter_num,
                                     self.k_block_num, k_tile_block, k_thread_num, k_iter_num,
                                     self.n_block_num, n_tile_block, n_thread_num, n_iter_num,
                                     self.c_0, loop_mode)
        tile_info = ConvTileInfoC04(tiling_params, self.cube_size, self)
        tile_info.cal_cycles()
        self.valid_solution.append(tile_info)


def gen_best_tiling_c04(fm_desc, filter_desc, tik_instance, bias=None):
    """
    generate best tiling
    """
    cube_size = get_soc_spec("CUBE_SIZE")  # this api cost more time, remove to high level api
    if fm_desc.input_dtype == "int8":
        cube_size[2] = cube_size[2] * 2

    valid_tiling = ValidTilingInfoC04(fm_desc, filter_desc, cube_size, tik_instance)
    # create tiling of nk kn mode
    valid_tiling.gen_nk_tiling(bias)
    # create tiling of nm mn mode
    valid_tiling.gen_mn_tiling()

    # if not find valid tiling, return the default tiling
    if not valid_tiling.valid_solution:
        tile_block = 1
        thread_num = 1
        c_0 = BYTE_PER_C0 // DTYPE_SIZE.get(fm_desc.input_dtype)
        # default mode cannot be nk kn, can only be mn or nm
        loop_mode = "mn"
        block_size = 16
        ho_wo = fm_desc.h_o * fm_desc.w_o
        m_block_num = math.ceil(ho_wo / 16)

        k_block_num = math.ceil(filter_desc.cin * filter_desc.height * filter_desc.width / c_0)
        n_block_num = math.ceil(filter_desc.cout / block_size)

        tiling_params = TilingParams(fm_desc, filter_desc,
                                     m_block_num, tile_block, thread_num, m_block_num // tile_block,
                                     k_block_num, tile_block, thread_num, k_block_num // tile_block,
                                     n_block_num, tile_block, thread_num, n_block_num // tile_block,
                                     c_0, loop_mode)
        tile_info = ConvTileInfoC04(tiling_params, cube_size, valid_tiling)
        tile_info.cal_cycles()
        return tile_info
    valid_tiling.valid_solution.sort()
    return valid_tiling.valid_solution[0]
