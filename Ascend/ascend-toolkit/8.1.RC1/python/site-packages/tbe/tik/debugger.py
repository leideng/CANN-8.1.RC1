#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     debugger.py
DESC:     some explanation
CREATED:  2019-04-18 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""
from __future__ import print_function
import sys
import os
import re
import copy

from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import CUR_FRAME_IDX
from tbe.tik.tik_lib.tik_params import RUN_CMD_FINISHED
from tbe.tik.tik_lib.tik_expr import BasicExpr
from tbe.tik.common.common_util import is_scalar_array
from tbe.tik.common.common_util import is_tensor
from tbe.tik.debug.debugger_inner import get_block_nums
from tbe.tik.debug.debugger_inner import TikQuitDebugLoop
from tbe.tik.debug.debugger_inner import TikDebuggerInner
from tbe.tik.debug.statement import TikBreakPoint

_MIN_LINE_NO = 0


class TikDebugger(TikDebuggerInner):
    """
    Class TikDebugger instance
    """
    def __init__(self):
        """
        Initialize class TikDebugger
        """
        super(TikDebugger, self).__init__()
        # record of event
        self.event = ""
        # cmd is running or not running
        self.running = True
        self.last_ide_cmd = None
        self.next_id = 0
        self.num_trace_event = 0

        self.last_cmd = ""  # last run cmd, after create multi-core thread, run this cmd again
        self.break_block_map_disabled = {}  # save the disabled info of bind breakpoint_id with block index
        self.prompt = ""
        self.args = None
        self.cmdqueue = []
        self.stdin = sys.stdin
        self.stdout = sys.stdout
        self.current_ast_node = None
        self.current_ast_context = None
        self.current_for_range_eval = False

    def __del__(self):
        self.debug_info.clear()
        self.fncache.clear()
        self.break_block_map.clear()
        self.break_block_map_disabled.clear()

    @staticmethod
    def _conversion_type_form_list_to_tuple_set(obj, obj_list):
        if isinstance(obj, tuple):
            new_obj = tuple(obj_list)
        elif isinstance(obj, set):
            new_obj = set(obj_list)
        else:
            new_obj = obj_list
        return new_obj

    def register_debug_info(self, source_info, ast_node):
        """
        registe debugger information

        Parameters
        -----------
        source_info:file's information.
        This is a CallerContext Class instance.

        ast_node:Node of Abstract Syntax Trees.
        This is a STMT Class instance.

        Returns
        -----------
        No returns
        """
        if not source_info:
            return

        cano_filename = self.canonic(source_info[CUR_FRAME_IDX].get("filename"))
        if cano_filename in self.debug_info.keys():
            self.debug_info[cano_filename].append((source_info, ast_node))
        else:
            self.debug_info[cano_filename] = [(source_info, ast_node)]

    def get_cmd(self):
        """
        according Cmd::cmdloop to read the cmd from user input, use_rawinput default is 1, completekey default is Tab,
        readline is very useful, can be enable left, right, tab features

        Returns
        -----------
        the input cmd
        """
        old_completer = self._get_completer_for_cmd()
        try:
            if self.use_rawinput:
                try:
                    line = input(self.prompt)
                except EOFError:
                    line = 'EOF'
            else:
                self.stdout.write(self.prompt)
                self.stdout.flush()
                line = self.stdin.readline()
                if not line:
                    line = 'EOF'
                else:
                    line = line.rstrip('\r\n')
            return line
        finally:
            self._set_completer_for_cmd(old_completer)

    def force_interactive(self, prompt="[TIK]>"):
        """
        Force stop interactive

        Parameters
        ----------
        prompt:Display in console with "[TIK]>"

        Returns
        ----------
        No returns
        """
        success_code = 0
        self.prompt = prompt
        try:
            self._set_stdin_stdout()
        except TikQuitDebugLoop as tik_except:
            if tik_except.quit_tik:
                print("[INFO]: 'quit' command stops TIK process")
                if self.tik_debug.resp_msg_queue is not None and self.tik_debug.resp_msg_queue.empty():
                    self.tik_debug.resp_msg_queue.put(RUN_CMD_FINISHED)
                sys.exit(success_code)
        except KeyboardInterrupt:
            print("[INFO]: keyboard interrupt")
            if self.tik_debug.resp_msg_queue is not None and self.tik_debug.resp_msg_queue.empty():
                self.tik_debug.resp_msg_queue.put(RUN_CMD_FINISHED)
            sys.exit(success_code)

    def do_list_ide(self, args):
        """
        Debug command list to show current line for IDE

        Parameters
        ----------
        args:Argument of list_ide, Input an argument of list_ide command on console.

        Returns
        ----------
        None
        """
        self.args = args
        if self.last_ide_cmd is None:
            return

        print("**<%s> start**" % self.last_ide_cmd)
        TikCheckUtil.check_not_is(self.current_ast_node, None)
        ast_node = self.current_ast_node
        while ast_node:
            source_info = ast_node.source_info
            if not source_info:
                break
            if isinstance(source_info, list):
                if ast_node.break_point is not None:
                    break_point_id = ast_node.break_point.id
                    msg = "[INFO]: reach breakpoint with id=%d at %s:%d" \
                          % (break_point_id, self.canonic(source_info[CUR_FRAME_IDX].get("filename")),
                             source_info[CUR_FRAME_IDX].get("line_no"))
                else:
                    msg = "[INFO]: reach line at %s:%d" \
                          % (self.canonic(source_info[CUR_FRAME_IDX].get("filename")),
                             source_info[CUR_FRAME_IDX].get("line_no"))
                self.print_msg(msg)
                break  # only print current stack now
            ast_node = ast_node.parent
        print("**<%s> end**" % self.last_ide_cmd, flush=True)
        self.last_ide_cmd = None

    def trace(self, ast_context, ast_node, event, allow_print=True):
        """
        The trace function provided to AST evaluator

        Parameters
        ----------
        ast_context:Context of abstract syntax trees. This is a Class Context instance.
        ast_node:Node of Abstract Syntax Trees. This is a STMT Class instance.
        event:Record of event, This is an argument for exception.
        allow_print:If allow print current line info for next/continue

        Returns
        ----------
        no return
        """
        self.event = event
        self.num_trace_event += 1
        self.current_ast_node = ast_node
        self.current_ast_context = ast_context

        if ast_node.break_point and ast_node.break_point.enabled:
            # for multi-core debug, if set is_interactive to False, ignore the breakpoint
            if self.tik_debug.is_interactive is False:
                return
            if self.tik_debug.is_interactive is not None:
                self.tik_debug.is_interactive.value = 1
            self.tik_debug.force_interactive = True
            if allow_print:
                self.do_list_ide("")
            self.force_interactive()
            return

        if self.tik_debug.force_interactive:
            if allow_print:
                self.do_list_ide("")
            self.force_interactive()
            return

        if event == 'exception':
            if self.tik_debug.is_interactive is not None:
                self.tik_debug.is_interactive.value = 1
            self.tik_debug.force_interactive = True
            self.force_interactive()
            return

    # Interactive commands:
    def do_break(self, args):
        """
        Debug command break for printing infomation of break_points

        Parameters
        ----------
        args:Argument of break, Input an argument of break command on console.

        Returns
        ----------
        None
        """
        if not args:
            print("Num Type         Enb   Where")
            # use the tmp id to filter duplicate breakpoint id.
            tmp_id = -1
            for break_point in self.break_points:
                if break_point.id == tmp_id:
                    continue
                tmp_id = break_point.id
                break_point.show_msg(self.tik_debug.is_single_core,
                                     self.break_block_map[break_point.id], self.tik_debug.block_end)
            return

        if not self.debug_info:
            self.print_msg("[WARNING]: no debug info registered during building TIK AST")
            return

        filename, lineno, block_nums_result = self._get_breakpoint_info(args)
        if filename is None or lineno is None:
            return

        # 2) Validate the parsing result
        # invalid line number and filename
        if not filename or lineno < _MIN_LINE_NO:
            msg = "[ERROR]: Invalid arugment( filename=%s lineno=%d )" % (filename, lineno)
            print(msg)
            return

        cano_filename = self.canonic(filename)
        if cano_filename not in self.debug_info.keys():
            print("[ERROR]: Failed to set breakpoint to %s:%d, " \
                  "because it's not a TIK primitive" % (cano_filename, lineno))
            return

        # accroding input cmd set breakpoint
        set_bp = self._set_break_point(cano_filename, lineno, block_nums_result)
        if not set_bp:
            print("[ERROR]: Failed to set breakpoint to %s:%d, "
                  "because it's not a TIK primitive" % (cano_filename, lineno))

    def do_b(self, args):
        """
        Debug command break for printing infomation of break_points

        Parameters
        ----------
        args:Argument of break, Input an argument of break command on console.

        Returns
        ----------
        do_break
        """
        return self.do_break(args)

    def do_break_ide(self, args):
        """
        Debug command break for printing infomation of break_points for IDE

        Parameters
        ----------
        args:Argument of break_ide, Input an argument of break_ide command on console.

        Returns
        ----------
        no return
        """
        print("**<break_ide> start**")
        self.do_break(args)
        print("**<break_ide> end**", flush=True)

    def do_continue(self, args):
        """
        Continue the TIK execution

        Parameters
        ----------
        args:Argument of continue, Input an argument of continue command on console.

        Returns
        ----------
        no return
        """
        ret_msg = None
        self.args = args
        if self.running:
            self.tik_debug.force_interactive = False
            if self.tik_debug.is_interactive is not None:
                self.tik_debug.is_interactive.value = 0
            ret_msg = "do_continue"
        else:
            self.print_msg("[ERROR]: invalid command `continue` when an exception occured")
        return ret_msg

    def do_c(self, args):
        """
        Continue the TIK execution

        Parameters
        ----------
        args:Argument of continue, Input an argument of continue command on console.

        Returns
        ----------
        do_continue
        """
        return self.do_continue(args)

    def do_continue_ide(self, args):
        """
        Continue the TIK execution for IDE

        Parameters
        ----------
        args:Argument of continue_ide, Input an argument of continue_ide command on console.

        Returns
        ----------
        no return
        """
        self.last_ide_cmd = "continue_ide"
        return self.do_continue(args)

    def do_block(self, args):
        """
        command block function
        Parameters
        ----------
        args: args is block index or ""

        Returns
        ----------
        no return
        """
        self.args = args
        if isinstance(self.tik_debug.block_end, int):
            print("Block\t Status\t  Current")
            for i in range(self.tik_debug.block_end):
                print("  %d\tStepping   True" % i)
        else:
            print("Block\t Status\t  Current")
            print("  %d\tStepping   True" % 0)

    def do_switch_block(self, args):
        """
        command switch block function: block index
        Parameters
        ----------
        args: the block index to switch

        Returns
        ----------
        no return
        """
        if not self.debug_info:
            self.print_msg("[WARNING]: no debug info registered during building TIK AST")
            return

        # 1) parse the argument
        re_block_command = re.compile(r"\d+")
        args_result = re_block_command.findall(args)
        if len(args_result) == 0:
            print("[ERROR]: Invalid argument(%s), expected form 'block id1'" % args)
            return

        block_idx_result = int(args_result[0])
        if block_idx_result not in self.tik_debug.block_idx_list:
            print("[ERROR]: block %d not in interactive status, cannot switch to" % block_idx_result)
            return

        self.tik_debug.cur_block_idx.value = block_idx_result
        self.tik_debug.force_interactive = True
        if self.tik_debug.is_interactive is not None:
            self.tik_debug.is_interactive.value = 1
        print("[INFO]: Switch to block %d" % block_idx_result)

    def do_next(self, args):
        """
        Stop at the next TIK primitives evaluation

        Parameters
        ----------
        args : Argument of next, Input an argument of next command on console.

        Returns
        ----------
        no return
        """
        ret_msg = None
        self.args = args
        if self.running:
            self.tik_debug.force_interactive = True
            if self.tik_debug.is_interactive is not None:
                self.tik_debug.is_interactive.value = 1
            ret_msg = "do_next"
        else:
            msg = "[ERROR]: invalid command `next` execute when an exception occured"
            self.print_msg(msg)
        return ret_msg

    def do_n(self, args):
        """
        Stop at the next TIK primitives evaluation

        Parameters
        ----------
        args : Argument of next, Input an argument of next command on console.

        Returns
        ----------
        do_next
        """
        return self.do_next(args)

    def do_next_ide(self, args):
        """
        Stop at the next TIK primitives evaluation for IDE

        Parameters
        ----------
        args : Argument of next_ide, Input an argument of next_ide command on console.

        Returns
        ----------
        no return
        """
        self.last_ide_cmd = "next_ide"
        return self.do_next(args)

    def do_list(self, args):
        """
        Print current code and context

        Parameters
        ----------
        args:Argument of list, Input an argument of list on console.

        Returns
        ----------
        no return
        """
        self.do_where(args)

    def do_l(self, args):
        """
        Print current code and context

        Parameters
        ----------
        args:Argument of list, Input an argument of list on console.

        Returns
        ----------
        do_list
        """
        return self.do_list(args)

    def do_clear(self, args):
        """
        Debug command to delete a breakpoint by id

        Parameters
        ----------
        args:Argument of clear, Input an argument of clear on console, to clear break points.

        Returns
        ----------
        no return
        """
        if args is None or args == '':
            self._clear_all_breakpoint()
            return
        # clear all breakpoint for some blocks, clear block 1 2
        re_block_str = r"^\s*(block )\s*(\d+)\s*"
        block_value_position = 1  # block info's index in cmd
        match_result = re.compile(re_block_str).match(args.strip())
        if not match_result:  # cannot find result according the re_block_str
            re_all_block_str = r"^\s*(\d+)$"  # demo cmd: clear 0
            match_result = re.compile(re_all_block_str).match(args.strip())
            if not match_result:
                args = self._get_clear_info_with_block(args)
                if args is None:
                    return
            else:
                breakpoint_id = int(args)
                if breakpoint_id in self.break_block_map.keys():
                    del self.break_block_map[breakpoint_id]
        else:
            # get the blocks info
            block_nums_result, _ = self._get_valid_block_nums(args, match_result, block_value_position)
            for key, value in self.break_block_map.items():
                target_bp = self._get_breakpoint_by_id(key)
                self._print_clear_info_with_block(block_nums_result, target_bp, key, value)
            self._clear_breakpoint_by_block()
            return

        self._print_clear_breakpoint(args)

    def do_clear_ide(self, args):
        """
        Debug command to clear a breakpoint by id for IDE

        Parameters
        ----------
        args:Argument of clear_ide, Input an argument of clear_ide on console, to clear break points.

        Returns
        ----------
        no return
        """
        print("**<clear_ide> start**")
        self.do_clear(args)
        print("**<clear_ide> end**", flush=True)

    def do_mi(self, args):
        """
        Debug command to show all variables for IDE

        Parameters
        ----------
        args:Argument of mi, Input an argument of mi on console.

        Returns
        ----------
        no return
        """
        self.args = args
        if not self.current_ast_node:
            msg = "[ERROR]: Invalid current AST node"
            self.print_msg(msg)
            return

        TikCheckUtil.check_not_is(self.current_ast_node, None)
        TikCheckUtil.check_not_is(self.current_ast_context, None)
        TikCheckUtil.check_not_is(
            self.current_ast_node.source_info[CUR_FRAME_IDX].get("sym_table"), None)

        symtable = copy.copy(self.current_ast_node.source_info[CUR_FRAME_IDX].get("sym_table"))

        mi_variables = []
        if 'self' in symtable:
            mi_variables.append({'self': self._collect_variable_info(vars(symtable['self']))})
        else:
            mi_variables.append({'self': []})
        mi_variables.append({'other': self._collect_variable_info(symtable)})
        print("**<mi> start**")
        print(mi_variables)
        print("**<mi> end**", flush=True)

    def do_enable(self, args):
        """
        Debug command for enabling a breakpoint

        Parameters
        ----------
        args:Argument of enable, Input an argument of enable on console.

        Returns
        ----------
        no return
        """
        # 1) first check whether assign block infos
        re_enable_block = r"^\s*(\d+)\s*( block )\s*(\d+)\s*"
        block_num_list, args = self._run_enable_disable(
            args, re_enable_block, (self.break_block_map_disabled, self.break_block_map), "enable")
        if block_num_list is not None:
            break_point = self.manipulate_break_point(args, "enable")
            if break_point:
                break_point.debug_print("[INFO]: Enabling ")

    def do_disable(self, args):
        """
        Debug command to disable a breakpoint by id

        Parameters
        ----------
        args:Argument of disable, Input an argument of disable on console.

        Returns
        ----------
        no return
        """
        # 1) first check whether assign block infos
        re_disable_block = r"^\s*(\d+)\s*( block )\s*(\d+)\s*"
        block_num_list, args = self._run_enable_disable(
            args, re_disable_block, (self.break_block_map, self.break_block_map_disabled), "disable")
        if block_num_list is not None:
            break_point = self.manipulate_break_point(args, "disable")
            if break_point:
                break_point.debug_print("[INFO]: Disabling ")

    def _run_enable_disable_without_blocks(self, args, break_block_map_from, break_block_map_to, op_str):
        """
        run the enable or disable cmd with block info
        """
        block_num_list = None
        # try to get breakpoint id
        re_command = re.compile(r"^\s*(\d+)$")
        # 2) parse the argument without block
        match_result = re_command.match(args)
        if not match_result:
            msg = "[ERROR]: Invalid %s cmd:'%s'" % (op_str, args)
            self.print_msg(msg)
            return None, args
        breakpoint_id = int(args)
        # if only has breakpoint id, enable or disable the breakpoint for all blocks
        if breakpoint_id in break_block_map_from.keys() and len(break_block_map_from[breakpoint_id]) > 0:
            break_block_map_to[breakpoint_id] = break_block_map_from[breakpoint_id]
            block_num_list = break_block_map_to[breakpoint_id]
            break_block_map_from[breakpoint_id] = []
        else:
            if breakpoint_id in break_block_map_to.keys():
                msg = "[WARNING]: No need %s again, breakpoint %d has been %sd" % (op_str, breakpoint_id, op_str)
            else:
                msg = "[WARNING]: breakpoint %d is invalid" % breakpoint_id
            self.print_msg(msg)
        return block_num_list, args

    def _run_enable_disable_with_blocks(self, args, match_result, break_block_maps, op_str):
        """
        run enable disable cmd with block info
        """
        break_block_map_from, break_block_map_to = break_block_maps
        block_num_list = None
        block_value_position = 2  # block info's index in cmd
        block_nums_result, args = self._get_valid_block_nums(args, match_result, block_value_position)
        # if no block, do nothing, return directly
        if len(block_nums_result) == 0:
            return None, args
        breakpoint_id = int(args)
        # only the breakpoint has been enabled/disabled, need to disable/enable it
        if breakpoint_id in break_block_map_from.keys():
            block_num_list = get_block_nums(breakpoint_id, block_nums_result, break_block_map_from,
                                            break_block_map_to, op_str)
            if len(block_num_list) == 0:
                return None, args
            if op_str == "enable":
                # if no block enabled of this breakpoint, no need to enable the breakpoint
                if len(break_block_map_to[breakpoint_id]) == 0:
                    return None, args
            else:
                # if has block not disabled of this breakpoint, no need to disable the breakpoint
                if len(break_block_map_from[breakpoint_id]) != 0:
                    return None, args
        elif breakpoint_id in break_block_map_to.keys():
            for i in block_nums_result:
                if i in break_block_map_to[breakpoint_id]:
                    print("[WARNING]: No need %s again, breakpoint %d has been %sd" % (op_str, breakpoint_id, op_str))
                else:
                    print("[WARNING]: breakpoint %d not set on block %d, cannot %s it" % (breakpoint_id, i, op_str))
        else:
            print("[WARNING]: breakpoint %d is invalid" % breakpoint_id)
        return block_num_list, args

    def _run_enable_disable(self, args, re_block_str, break_block_maps, op_str):
        """
        used to run enable/disable cmd
        Parameters
        ----------
        args: user input cmd
        re_block_str: re str used to find block info
        break_block_maps:
        -                 break_block_map_from: self.break_block_map_disabled/self.break_block_map
        -                 break_block_map_to: self.break_block_map/self.break_block_map_disabled
        op_str: "enable" or "disable"

        Returns
        ----------
        block_num_list: valid block num
        args: breakpoint id
        """
        break_block_map_from, break_block_map_to = break_block_maps
        re_command = re.compile(re_block_str)
        match_result = re_command.match(args.strip())
        if not match_result:  # cannot find block info according the re_block_str
            return self._run_enable_disable_without_blocks(args, break_block_map_from, break_block_map_to, op_str)
        return self._run_enable_disable_with_blocks(args, match_result,
                                                    (break_block_map_from, break_block_map_to), op_str)

    def _clear_all_breakpoint(self):
        """
        clear all breakpoint
        """
        bp_temp = self.break_points[:]
        for target_bp in bp_temp:
            break_point_id = target_bp.ast_node.break_point.id
            target_bp.ast_node.break_point = None
            self.break_points.remove(target_bp)
            source_info = target_bp.ast_node.source_info
            msg = "[INFO]: clear breakpoint with id=%d at %s:%d" % \
                  (break_point_id, self.canonic(source_info[CUR_FRAME_IDX].get("filename")),
                   source_info[CUR_FRAME_IDX].get("line_no"))
            self.print_msg(msg, self.break_block_map[break_point_id])
            self.break_block_map[break_point_id] = []
        self.break_block_map.clear()

    def _clear_breakpoint_by_block(self):
        """
        clear the breakpoint only all the blocks cleared on the breakpoint
        """
        bp_temp = self.break_points[:]
        for target_bp in bp_temp:
            break_point_id = target_bp.ast_node.break_point.id
            if len(self.break_block_map[break_point_id]) == 0:
                target_bp.ast_node.break_point = None
                self.break_points.remove(target_bp)
                self.break_block_map[break_point_id] = []
                del self.break_block_map[break_point_id]

    def _print_clear_info_with_block(self, block_nums_result, target_bp, key, value):
        """
        print clear info
        """
        for i in block_nums_result:
            if i in value:
                self.break_block_map[key].remove(i)
                source_info = target_bp.ast_node.source_info
                print("[INFO]: clear breakpoint with id=%d at %s:%d of block %d" %
                      (key, self.canonic(source_info[CUR_FRAME_IDX].get("filename")),
                       source_info[CUR_FRAME_IDX].get("line_no"), i))
            else:
                print("[WARNING]: No breakpoint %d for block %d" % (key, i))

    def _get_clear_info_with_block(self, args):
        """
        according the user input cmd, get the breakpoint id and block info
        """
        # breakpoint clear cmd for some blocks, clear 1 block 1 2
        re_str = r"^\s*(\d+)\s*( block )\s*(\d+)\s*"
        block_value_position = 2  # block info's index in cmd
        re_break_command = re.compile(re_str)
        match_result = re_break_command.match(args.strip())
        if match_result:
            block_nums_result, args = self._get_valid_block_nums(args, match_result, block_value_position)
            if len(block_nums_result) == 0:
                return None
            breakpoint_id = int(args)
            target_bp = self._get_breakpoint_by_id(breakpoint_id)
            if breakpoint_id in self.break_block_map.keys():
                self._print_clear_info_with_block(block_nums_result, target_bp, breakpoint_id,
                                                  self.break_block_map[breakpoint_id])
                if len(self.break_block_map[breakpoint_id]) == 0:
                    del self.break_block_map[breakpoint_id]
                else:
                    return None
            else:
                print("[ERROR]: Failed to find breakpoint with id=%d" % breakpoint_id)
                return None
        else:
            print("[Error]: Invalid input cmd: 'clear %s'" % str(args))
            return None
        return args

    def _print_clear_breakpoint(self, args):
        break_point = self.manipulate_break_point(args, "delete")
        if break_point:
            source_info = break_point.ast_node.source_info
            print("[INFO]: clear breakpoint with id=%d at %s:%d" %
                  (break_point.id, self.canonic(source_info[CUR_FRAME_IDX].get("filename")),
                   source_info[CUR_FRAME_IDX].get("line_no")))

    def _get_other_variable_value(self, obj):
        """
        get other variable's value
        """
        new_obj = obj
        if isinstance(obj, (list, tuple, set)):
            new_obj_list = []
            for v in obj:
                if isinstance(v, BasicExpr):
                    v = self.current_ast_context.evaluate_expr(v, default_value=True)
                elif isinstance(v, (list, tuple, dict, set)):
                    v = self._get_other_variable_value(v)
                new_obj_list.append(v)
            new_obj = self._conversion_type_form_list_to_tuple_set(obj, new_obj_list)
        elif isinstance(obj, dict):
            new_obj = {}
            for k, v in obj.items():
                if isinstance(v, BasicExpr):
                    v = self.current_ast_context.evaluate_expr(v, default_value=True)
                elif isinstance(v, (list, tuple, dict, set)):
                    v = self._get_other_variable_value(v)
                new_obj[k] = v

        return new_obj

    def _collect_variable_info(self, table):
        """
        Collect the value of Scalar/Expr/Tensor in table

        Parameters
        ----------
        table: symbol table

        Returns
        ----------
        A list of value
        """
        variable_info = []
        for name, obj in table.items():
            if isinstance(obj, BasicExpr):
                ret = self.current_ast_context.evaluate_expr(obj, default_value=True)
                variable_info.append({name: {'dtype': obj.dtype, 'value': str(ret),
                                             'shape': 'None', 'scope': 'local.REG', 'type': 'Scalar'}})
            elif is_scalar_array(obj):
                ret = [self.current_ast_context.evaluate_expr(obj[i], default_value=True)
                       for i in range(obj.length)]
                variable_info.append({name: {'dtype': obj.dtype, 'value': str(ret),
                                             'shape': str(len(ret)), 'scope': 'local.REG', 'type': 'ScalarArray'}})
            elif is_tensor(obj):
                npbuf = self.current_ast_context.get_value(obj)
                if npbuf is not None:
                    ret = npbuf.buffer
                    variable_info.append({name: {'dtype': obj.dtype, 'value': str(ret.tolist()),
                                                 'shape': str(list(ret.shape)),
                                                 'scope': str(obj.scope), 'type': 'Tensor'}})
                else:
                    variable_info.append({name: {'dtype': obj.dtype, 'value': 'None',
                                                 'shape': 'None', 'scope': 'None', 'type': 'Tensor'}})
            elif isinstance(obj, (list, tuple, dict, set, str, int, float, bool)):
                new_obj = self._get_other_variable_value(obj)
                variable_info.append(
                    {name: {'dtype': 'None', 'value': str(new_obj), 'shape': 'None',
                            'scope': 'None', 'type': str(type(obj))}})
        return variable_info

    def _get_valid_block_nums(self, args, match_result, block_value_position):
        # # get the blocks info by group(block_value_position)
        cmd_split_result = args.split(match_result.group(block_value_position))
        # get all block nums from the str, cmd_split_result[1] is block nums list
        input_block_nums = list(map(int, re.compile(r"\d+").findall(cmd_split_result[1])))
        block_nums_result = []
        for i in input_block_nums:
            if isinstance(self.tik_debug.block_end, int) and not self.current_for_range_eval:
                if i not in range(self.tik_debug.block_begin, self.tik_debug.block_end):
                    print("[WARNING]: block %d is invalid, block should be in range [%d, %d]" %
                          (i, self.tik_debug.block_begin, self.tik_debug.block_end - 1))
                    continue
            if i not in block_nums_result:
                block_nums_result.append(i)

        args = cmd_split_result[0]
        return block_nums_result, args

    def _get_breakpoint_info(self, args):
        """
        according user input cmd to get the breakpoint info
        """
        # 1) first check whether assign block infos
        re_break_block = r"^\s*(\S+)\s*:\s*(\d+)\s*( block )\s*(\d+)\s*"
        re_break_command = re.compile(re_break_block)
        match_result = re_break_command.match(args.strip())
        block_nums_result = []

        if not match_result:  # cannot find result according the re_break_block
            re_break_command = re.compile(r"^\s*(\S+)\s*:\s*(\d+)\s*$")
            # 2) parse the argument without block
            match_result = re_break_command.match(args)
            if not match_result:
                msg = "[ERROR]: Invalid argument(%s), expected form '<filename>:<lineno> [block block_idx]'" % args
                print(msg)
                return None, None, None
            if not isinstance(self.tik_debug.block_end, int):
                block_nums_result.append("all")
            else:
                for i in range(self.tik_debug.block_begin, self.tik_debug.block_end):
                    block_nums_result.append(i)
        else:
            block_value_position = 2  # block info's index in cmd
            block_nums_result, _ = self._get_valid_block_nums(args, match_result, block_value_position)
            # if no block, add all block to break_block_map
            if len(block_nums_result) == 0:
                print("[WARNING]: No valid block, set breakpoint failed, please try again")
                return None, None, None

        filename = match_result.group(1)
        lineno = int(match_result.group(2))
        return filename, lineno, block_nums_result

    def _print_breakpoints_set_msg(self, break_point_id, is_new_breakpoint, msg, block_nums_result):
        self.break_block_map[break_point_id] = block_nums_result
        if is_new_breakpoint:
            self.print_msg(msg, block_nums_result)

    def _set_break_point(self, cano_filename, lineno, block_nums_result):
        """
        accroding the filename and line num set the breakpoint
        """
        set_bp = False
        # 3) go through TIK primitives in the file and set the break point
        tik_primitive_list = self.debug_info.get(cano_filename)
        # Use first_breakpoint variable to save the first breakpoint corresponding to the interface.
        first_breakpoint = None
        # This variable ensures that information is printed only once.
        is_new_breakpoint = True
        for source_info, ast_node in tik_primitive_list:
            if source_info[CUR_FRAME_IDX].get("line_no") == lineno and ast_node.traceable:
                # For the following 4 lines of code, Solve special scenarios, for example
                # tik_instance.printf => as a debug block, This interface can be invoked by multiple Tik interfaces.
                # like data_move, For the printf interface, multiple blocks with the same lineno are collected.
                # 9  def print_common():
                # 10    tik_instance.printf()
                # 11
                # 12 print_common()
                # 13 print_common()
                #        ||
                #        \/   Two printf interfaces generate four blocks.
                #             Actually, only two printf blocks are required. Therefore,
                #             use the following 4 lines of python code to filter out data_move block.
                # printf -> a block enable break  lineno 10
                #    data_move -> a block enable break  lineno 10
                # printf -> a block enable break  lineno 10
                #    data_move -> a block enable break  line 10
                if not first_breakpoint:
                    first_breakpoint = ast_node
                if not isinstance(ast_node, type(first_breakpoint)):
                    continue
                set_bp = True
                if ast_node.break_point in self.break_points:
                    break_point_id = ast_node.break_point.id
                    msg = "[INFO]: set breakpoint with id=%d at %s:%d has been done" \
                          % (break_point_id, cano_filename, lineno)
                    self._print_breakpoints_set_msg(break_point_id, is_new_breakpoint, msg, block_nums_result)
                    is_new_breakpoint = False
                    continue
                point = TikBreakPoint(ast_node, self.next_id)
                ast_node.break_point = point
                self.break_points.append(ast_node.break_point)
                break_point_id = ast_node.break_point.id
                self.break_block_map[break_point_id] = block_nums_result

        # Ensure that the id of breakpoints with the same lineno are the same.
        if set_bp and is_new_breakpoint:
            msg = "[INFO]: set breakpoint with id=%d at %s:%d" % (
                first_breakpoint.break_point.id, cano_filename, lineno)
            self.print_msg(msg, block_nums_result)
            self.next_id += 1
        return set_bp

    def _run_cmd(self, cmd):
        """
        call Cmd::onecmd to run the cmd function, if the cmd is unsupported, must be call get_cmd here

        Parameters
        -----------
        cmd: user input cmd

        Returns
        -----------
        No returns
        """
        try:
            stop = None
            while not stop:
                self.last_cmd = cmd
                stop = self.onecmd(cmd)
                # if no cmd, need to read again here, if return directly will run next tik line
                if stop is None:
                    cmd = self.get_cmd()
        finally:
            pass

    def _set_stdin_stdout(self):
        # for current thread, the fd self.tik_debug.stdin can only be open once
        if self.tik_debug.cmd_queue is not None:
            self.cmdqueue = self.tik_debug.cmd_queue
            self._run_cmd_of_cmdqueue()
        else:
            if self.tik_debug.stdin is not None:
                self.stdin = os.fdopen(self.tik_debug.stdin)
                self.tik_debug.stdin = None
            if self.tik_debug.stdout is not None:
                self.stdout = os.fdopen(self.tik_debug.stdout, 'w')
                self.tik_debug.stdout = None
            cmd = self.get_cmd()
            self._run_cmd(cmd)

    def _run_cmd_of_cmdqueue(self):
        """
        Repeatedly issue a prompt, accept input, parse an initial prefix
        off the received input, and dispatch to action methods, passing them
        the remainder of the line as argument.
        """
        stop = None
        while not stop:
            line = ""
            if self.cmdqueue:
                # get msg from father process
                line = self.cmdqueue.get()

            line = line.rstrip('\r\n')
            stop = self.onecmd(line)  # run the cmd function
            if self.tik_debug.resp_msg_queue is not None and self.tik_debug.resp_msg_queue.empty():
                self.tik_debug.resp_msg_queue.put(RUN_CMD_FINISHED)

    def _get_completer_for_cmd(self):
        old_completer = None
        if self.use_rawinput and self.completekey:
            try:
                import readline
            except ImportError:
                return old_completer
            old_completer = readline.get_completer()
            readline.set_completer(self.complete)
            readline.parse_and_bind(self.completekey + ": complete")
        return old_completer

    def _set_completer_for_cmd(self, old_completer):
        if self.use_rawinput and self.completekey:
            try:
                import readline
            except ImportError:
                return
            readline.set_completer(old_completer)
