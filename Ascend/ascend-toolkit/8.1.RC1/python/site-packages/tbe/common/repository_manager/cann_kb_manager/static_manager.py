#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2022. Huawei Technologies Co., Ltd. All rights reserved.
cann knowledege static manager
"""
import json
from tbe.common.repository_manager.utils.define import RepoMgrRetStatus
from tbe.common.repository_manager.utils.multiprocess_util import GlobalMgr
from tbe.common.repository_manager.utils.file_sys_util import FileSysUtil
from tbe.common.repository_manager.utils.repository_manager_log import LOG_INSTANCE
from tbe.common.repository_manager.cann_kb_manager.base_manager import BaseManager


class StaticManager(BaseManager):
    """Knowledge base management module for static shapes"""
    def __init__(self, communicate_mgr: GlobalMgr, sys_config: dict, load_config: dict = {}, option: dict = {}):
        """__init__ for StaticManager

        Description:
        initialize StaticManager object

        Parameters:
        communicate_mgr(GlobalMgr): multiprocessing manager
        sys_config(dict): System Configuration For Software Such As soc_version
        load_config(dict): Additional Load Knowledge Bank Configuration Such As kb_path
        option(dict): Reserved Configuration Item
        """
        super().__init__(communicate_mgr, sys_config, load_config, option)

    @staticmethod
    def check_str_change_2_dict(content: str) -> tuple:
        """
        Check the input str can be changed to dict by json loads
        """
        flag = True
        info_dict = {}
        try:
            info_dict = json.loads(content)
        except (ValueError, TypeError) as e:
            LOG_INSTANCE.warn("check_str_change_2_dict: str loads failed: %s" % e)
            info_dict = {}
            flag = False
        finally:
            pass
        return flag, info_dict

    def search(self, info_dict: str, op_type: str, additional: dict = None) -> list:
        """search from kb mem"""
        md5 = self.abstract(info_dict)
        search_type = additional.get("search_type", None)
        LOG_INSTANCE.debug("StaticManager search[%s]" % info_dict)
        LOG_INSTANCE.debug("StaticManager search md5[%s]" % md5)
        LOG_INSTANCE.debug("StaticManager search_type[%s]" % search_type)
        LOG_INSTANCE.debug("StaticManager search op_type[%s]" % op_type)
        if search_type not in (None, "user", "built_in", "graph_built_in"):
            raise RuntimeError("Bad Search Type[%s]" % str(search_type))
        res = list()
        soc_alternative = self.get_all_soc_versions(search_type)
        for soc_version in soc_alternative:
            hit_bank_type = None
            search_bank_type = None
            file_name = self.get_repo_file_name(op_type, soc_version)
            if search_type == "graph_built_in":
                file_name = file_name.lower()
            if search_type is None:
                res = self.user_search(file_name, md5, soc_version)
                if res:
                    search_bank_type = "user"
                else:
                    res = self.built_in_search(file_name, md5, soc_version)
                    search_bank_type = "built-in"
            else:
                res = getattr(self, search_type + "_search")(file_name, md5, soc_version)
                search_bank_type = search_type

            origin = "UNKNOWN"
            if res and isinstance(res[0], dict):
                origin = res[0].get("origin", "UNKNOWN")
                hit_bank_type = search_bank_type
            try:
                ret = [
                    {"knowledge": kb["knowledge"], "cost_time": kb["cost_time"]} if
                    additional.get("full_info") else {"knowledge": kb["knowledge"]} for kb in res
                ]
            except (ValueError, TypeError) as e:
                LOG_INSTANCE.warn("Parsing knowledge[%s] failed: %s" % (md5, str(e)))
                ret = []
            finally:
                if ret:
                    ret[0]["knowledge"] = json.dumps(ret[0]["knowledge"]) if \
                        additional.get("return_type", "") == "str" else ret[0]["knowledge"]
            LOG_INSTANCE.debug("StaticManager search: hit_bank_type:%s, file_name:%s.json, origin:%s"\
                % (hit_bank_type, file_name, origin))
            LOG_INSTANCE.debug("StaticManager search ret: %s" % (ret))
            if ret:
                break
        return ret

    def write(self,
        info_dict: str,
        op_type: str,
        knowledge: str,
        additional: dict = None) -> RepoMgrRetStatus:
        """write to user kb mem"""
        md5 = self.abstract(info_dict)
        # info_dict must be a json str or md5 str
        flag, info_dict_tmp = self.check_str_change_2_dict(info_dict)
        if flag:
            info_dict = info_dict_tmp # info_dict is a dict after loads operation
        else: # if info_dict str is not json str, try to change str to json str and loads again
            info_dict_tmp = FileSysUtil.content_to_stand_str(info_dict)
            flag, info_dict_tmp = self.check_str_change_2_dict(info_dict_tmp)
            if flag:
                info_dict = info_dict_tmp

        content = [{
            "knowledge": knowledge,
            "info_dict": info_dict,
            "cost_time": additional.get("cost_time", -1),
            "origin": additional.get("origin", "UNKNOWN")
        }]

        file_name = self.get_repo_file_name(op_type)
        flush = additional.get("flush", False)

        LOG_INSTANCE.debug("StaticManager write[%s]" % info_dict)
        LOG_INSTANCE.debug("StaticManager write md5[%s]" % md5)
        LOG_INSTANCE.debug("StaticManager write file_name[%s]" % file_name)
        LOG_INSTANCE.debug("StaticManager write content[%s]" % str(knowledge))
        LOG_INSTANCE.debug("StaticManager write flush[%s]" % str(flush))
        res = self.user_write(file_name, md5, content)
        if res != RepoMgrRetStatus.SUCCESS:
            return res
        if flush:
            return self.user_flush(file_name)
        return RepoMgrRetStatus.SUCCESS

    def delete(self,
        info_dict: str,
        op_type: str,
        flush: bool = False,
        additional: dict = None) -> RepoMgrRetStatus:
        """delete user kb mem"""
        md5 = self.abstract(info_dict)
        file_name = self.get_repo_file_name(op_type)
        LOG_INSTANCE.debug("StaticManager delete[%s]" % info_dict)
        LOG_INSTANCE.debug("StaticManager delete md5[%s]" % md5)
        LOG_INSTANCE.debug("StaticManager delete file_name[%s]" % file_name)
        LOG_INSTANCE.debug("StaticManager delete flush[%s]" % str(flush))
        res = self.user_delete(file_name, md5)
        if res != RepoMgrRetStatus.SUCCESS:
            return res
        if flush:
            return self.user_flush(file_name)
        return RepoMgrRetStatus.SUCCESS
