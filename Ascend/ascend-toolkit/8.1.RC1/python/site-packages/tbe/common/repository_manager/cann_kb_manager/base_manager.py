#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2022. Huawei Technologies Co., Ltd. All rights reserved.
cann knowledege base manager
"""
import os
import copy
import json
import hashlib
import functools
from typing import TextIO

from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.repository_manager.utils.define import RepoMgrRetStatus
from tbe.common.repository_manager.utils.file_sys_util import FileSysUtil
from tbe.common.repository_manager.utils.file_sys_util import LockedOpen
from tbe.common.repository_manager.utils.multiprocess_util import get_resource
from tbe.common.repository_manager.utils.common import generate_unique
from tbe.common.repository_manager.utils.repository_manager_log import LOG_INSTANCE


SEEK_END = 2
CUSTOMER_HOME_PATH = "HOME"
CUSTOMER_REPO_PATH = "Ascend/latest/data/aoe/custom/op/"
TUNE_BANK_PATH = "TUNE_BANK_PATH"
ASCEND_CACHE_PATH = "ASCEND_CACHE_PATH"
AOE_DATA = "aoe_data/"
ASCEND_OPP_PATH = "ASCEND_OPP_PATH"
BUILT_IN_RELATIVE_PATH = ["built-in/data/op", "data/built_in/op"]
GRAPH_BUILT_IN_RELATIVE_PATH = "../data/fusion_strategy/built-in"
UNIFIED_DIR = "unified_bank"
DIRECTORY_ERROR_CODE = "EC0006"

# soc dict for alternative bank
SOC_ALTERNATIVE = {
    "Ascend910PremiumA": ["Ascend910ProA", "Ascend910A"],
    "Ascend910ProA": ["Ascend910A", "Ascend910PremiumA"],
    "Ascend910A": ["Ascend910ProA", "Ascend910PremiumA"],
    "Ascend910ProB": ["Ascend910B"],
    "Ascend910B": ["Ascend910ProB"],
    "Ascend910B1": ["Ascend910B2"],
    "Ascend910B2": ["Ascend910B1"],
    "Ascend910B2C": ["Ascend910B2", "Ascend910B1"],
    "Ascend910B3": ["Ascend910B4", "Ascend910B5"],
    "Ascend910B4": ["Ascend910B5", "Ascend910B3"],
    "Ascend910B4-1": ["Ascend910B4", "Ascend910B5", "Ascend910B3"],
    "Ascend910B5": ["Ascend910B4", "Ascend910B3"],
    "Ascend310B2": ["Ascend310B1"],
    "Ascend310B3": ["Ascend310B1"],
    "Ascend310B4": ["Ascend310B1"],
    "Ascend910_9391": ["Ascend910_9381", "Ascend910_9392", "Ascend910_9382", "Ascend910B1", "Ascend910B2"],
    "Ascend910_9381": ["Ascend910_9391", "Ascend910_9392", "Ascend910_9382", "Ascend910B1", "Ascend910B2"],
    "Ascend910_9392": ["Ascend910_9391", "Ascend910_9381", "Ascend910_9382", "Ascend910B1", "Ascend910B2"],
    "Ascend910_9382": ["Ascend910_9391", "Ascend910_9381", "Ascend910_9392", "Ascend910B1", "Ascend910B2"],
    "Ascend910_9372": ["Ascend910_9362", "Ascend910B3", "Ascend910B4"],
    "Ascend910_9362": ["Ascend910_9372", "Ascend910B3", "Ascend910B4"],
    "Ascend610Lite": ["BS9SX2AA", "MC61AM21AA", "BS9SX2AB", "MC61AM21AB"],
    "BS9SX2AA": ["Ascend610Lite", "MC61AM21AA", "BS9SX2AB", "MC61AM21AB"],
    "MC61AM21AA": ["Ascend610Lite", "BS9SX2AA", "BS9SX2AB", "MC61AM21AB"],
    "BS9SX2AB": ["Ascend610Lite", "BS9SX2AA", "MC61AM21AA", "MC61AM21AB"],
    "MC61AM21AB": ["Ascend610Lite", "BS9SX2AA", "BS9SX2AB", "MC61AM21AA"],
}

SOC_ALTERNATIVE_GRAPH = {
    "Ascend910B1": ["Ascend910B2"],
    "Ascend910B2": ["Ascend910B1"],
    "Ascend910B2C": ["Ascend910B2", "Ascend910B1"],
    "Ascend910B3": ["Ascend910B4", "Ascend910B5"],
    "Ascend910B4": ["Ascend910B5"],
    "Ascend910B4-1": ["Ascend910B4", "Ascend910B5"],
    "Ascend910B5": ["Ascend910B4"],
}


def lock_exists_check(func):
    """Checking Whether A Specific Lock Exists"""
    @functools.wraps(func)
    def wrapper(self, name, bank_type, *args, **kwargs):
        lock_for_creating_lock = getattr(self, "lock_for_creating_lock")
        lock_dict = getattr(self, bank_type + "_kb_lock")
        if name not in lock_dict.keys():
            lock_for_creating_lock.acquire()
            if name not in lock_dict.keys():
                lock_dict[name] = getattr(self, "_get_resource")("lock")
            lock_for_creating_lock.release()
        return func(self, name, bank_type, *args, **kwargs)
    return wrapper


class BaseManager:
    """Base class for cann knowledge base management

    Description:
    Provides basic methods to manage the knowledge bank, such as load, search, and write.
    """
    def __init__(self, resource_proxy: dict, sys_config: dict, load_config: dict = {}, option: dict = {}) -> None:
        """__init__ for BaseManager

        Description:
        initialize BaseManager object

        Parameters:
        resource_proxy(dict): dict content resource proxy object
        sys_config(dict): System Configuration For Software Such As soc_version and core_num
        load_config(dict): Additional Load Knowledge Bank Configuration Such As kb_path
        option(dict): Reserved Configuration Item
        """
        self.task_q = resource_proxy["task_q"]
        self.res_d = resource_proxy["res_d"]
        self.resource_l = resource_proxy["resource_l"]
        self.lock_for_creating_lock = resource_proxy["task_lock"]
        self.user_kb = resource_proxy["dict_list"][0]
        self.write_kb = resource_proxy["dict_list"][1]
        self.built_in_kb = resource_proxy["dict_list"][2]
        self.graph_built_in_kb = resource_proxy["dict_list"][3]
        self.user_kb_lock = resource_proxy["dict_list"][4]
        self.write_kb_lock = resource_proxy["dict_list"][5]
        self.built_in_kb_lock = resource_proxy["dict_list"][6]
        self.graph_built_in_kb_lock = resource_proxy["dict_list"][7]

        if sys_config.get("soc_version", ""):
            self.soc_version = sys_config["soc_version"]
        else:
            self.soc_version = get_soc_spec("FULL_SOC_VERSION")
        self.soc_version = self.soc_version if self.soc_version else "Ascend310"

        self.user_bank_path = self.__user_kb_path(load_config.get("op_bank_path", None))
        self.built_in_bank_path = self.__built_in_kb_path()
        self.graph_built_in_bank_path = self.__graph_built_in_kb_path()


    @staticmethod
    def abstract(s: str) -> str:
        """Obtains the digest of a character string. The digest algorithm is MD5."""
        return hashlib.md5(s.encode(encoding="utf-8")).hexdigest()

    @staticmethod
    def merge_content_with_kb(kb: dict, tmp_content: dict) -> None:
        """
        merge content with kb and update tmp_content
        """
        del_item = list()
        for item in kb:
            if kb[item] is None:
                del_item.append(item)
        for item in del_item:
            kb.pop(item, None)
            tmp_content.pop(item, None)
        tmp_content.update(kb)

    def write_merge(self, file_name: str, kb: dict, tmp_content: dict) -> tuple:
        """merge write knowledge to file"""
        ret = RepoMgrRetStatus.SUCCESS
        load_flag = True
        new_content = {}
        self.merge_content_with_kb(kb, tmp_content)
        try:
            with open(file_name, "a+") as file_handle:
                FileSysUtil.write_json_file(file_handle, tmp_content)
                load_flag, new_content = self.json_file_get_content_by_handle(file_handle)
        except (OSError, IOError) as e:
            LOG_INSTANCE.warn("Can not flush knowledge bank file[%s]: %s." % (file_name, str(e)))
            return RepoMgrRetStatus.FILE_FLUSH_FAIL, {}
        finally:
            pass
        if not load_flag:
            LOG_INSTANCE.warn("Can not load knowledge bank file[%s] after flush." % file_name)
            return RepoMgrRetStatus.FILE_LOAD_FAIL, {}
        return ret, new_content

    @staticmethod
    def __built_in_kb_path() -> str:
        """get built-in kb path

        Description:
        Obtaining the built-in Knowledge Bank Path

        Return:
        built_in_kb_path(str): Knowledge Bank Path
        """
        opp_path = os.getenv(ASCEND_OPP_PATH, default="")
        if opp_path == "":
            LOG_INSTANCE.error("The ASCEND_OPP_PATH environment variable must be set.")
            raise RuntimeError({"errCode": "EC0008", "env_name": ASCEND_OPP_PATH})
        for built_in_relative_path in BUILT_IN_RELATIVE_PATH:
            built_in = os.path.realpath(os.path.join(opp_path, built_in_relative_path))
            if os.path.isdir(built_in):
                break
        LOG_INSTANCE.debug("built_in_kb_path[%s]." % str(built_in))
        return built_in

    @staticmethod
    def __graph_built_in_kb_path() -> str:
        """get graph built-in kb path

        Description:
        Obtaining the graph built-in Knowledge Bank Path

        Return:
        graph_built_in_kb_path(str): Knowledge Bank Path
        """
        ld_path = os.environ["LD_LIBRARY_PATH"].split(":")
        if not ld_path:
            LOG_INSTANCE.error("The LD_LIBRARY_PATH environment variable must be set.")
            raise RuntimeError({"errCode": "EC0008", "env_name": "LD_LIBRARY_PATH"})
        compiler_path = ""
        for path in ld_path:
            if os.path.exists(os.path.join(path, "libcann_kb.so")):
                compiler_path = path
                break
        if compiler_path == "":
            LOG_INSTANCE.error("The CANN installation environment is not initialized normally,"
                "or the compiler package installation failed.")
            raise RuntimeError({"errCode": "EC0008", "env_name": "LD_LIBRARY_PATH"})
        LOG_INSTANCE.debug("graph_built_in_kb_path[%s].", os.path.join(compiler_path, GRAPH_BUILT_IN_RELATIVE_PATH))
        return os.path.realpath(os.path.join(compiler_path, GRAPH_BUILT_IN_RELATIVE_PATH))

    @staticmethod
    def __user_kb_path(op_bank_path: str) -> str:
        """get user kb path

        Description:
        Obtaining the User Knowledge Bank Path

        Parameters:
        op_bank_path(str): Path of the user knowledge bank transferred by the user.

        Return:
        user_kb_path(str): Knowledge Bank Path
        """
        def raise_err(reason: str) -> None:
            """
            raise runtime error
            """
            err_dict = {}
            err_dict["errCode"] = DIRECTORY_ERROR_CODE
            err_dict["reason"] = reason
            raise RuntimeError(err_dict)

        def check_path_validity(path: str) -> None:
            """check path validity

            Description:
            as same as func name

            Parameters:
            path(str): Validity path to be checked

            Return:
            None: if failed raise RuntimeError
            """
            real_path = os.path.realpath(path)
            if not os.path.isdir(real_path):
                LOG_INSTANCE.error("Path:[%s] does not exist, please check it!" % path)
                raise_err("Directory [{}] does not exist".format(path))
            if not os.access(real_path, os.R_OK | os.W_OK | os.X_OK):
                LOG_INSTANCE.error("No permission for path[%s], please check it!" % path)
                raise_err("No permission for directory [{}]".format(path))

        def get_base_custom_path(op_bank_path: str) -> str:
            # Use tune_bank_path if tune_bank_path is available.
            tune_bank_path = os.getenv(TUNE_BANK_PATH, "")
            if tune_bank_path:
                check_path_validity(tune_bank_path)
                return tune_bank_path

            # Use op_bank_path if op_bank_path is available.
            if op_bank_path:
                check_path_validity(op_bank_path)
                return op_bank_path
            ascend_cache_path = os.getenv(ASCEND_CACHE_PATH, "")
            if ascend_cache_path:
                check_path_validity(ascend_cache_path)
                ascend_cache_path = os.path.join(ascend_cache_path, AOE_DATA)
                if FileSysUtil.create_folder_recursively(ascend_cache_path) == RepoMgrRetStatus.SUCCESS:
                    return ascend_cache_path

            # Use the default path.
            LOG_INSTANCE.warn("Cannot find custom path. Check default HOME path instead.")
            user_home = os.environ.get(CUSTOMER_HOME_PATH, "")
            if not user_home:
                LOG_INSTANCE.error("environ[%s] is empty!" % CUSTOMER_HOME_PATH)
                raise RuntimeError({"errCode": "EC0008", "env_name": CUSTOMER_HOME_PATH})
            return os.path.join(user_home, CUSTOMER_REPO_PATH)

        path = os.path.realpath(get_base_custom_path(op_bank_path))
        return path

    @staticmethod
    def file_recovery(tmp_name: str, file_name: str) -> bool:
        """
        recovery file
        """
        if not FileSysUtil.rename_file(tmp_name, file_name):
            LOG_INSTANCE.error("Recover knowledge bank file failed, the original file is most likely corrupted, "
                "please recover the knowledge bank file manually via renaming [%s] to [%s]." % (tmp_name, file_name))
            return False
        return True

    def built_in_search(self, name: str, abstract: str, soc_version: str = "") -> list:
        """search from built_in kb mem"""
        return self.__search(name, "built_in", {"abstract": abstract, "soc_version": soc_version})

    def graph_built_in_search(self, name: str, abstract: str, soc_version: str = "") -> list:
        """search from graph built_in kb mem"""
        return self.__search(name, "graph_built_in", {"abstract": abstract, "soc_version": soc_version})

    def user_search(self, name: str, abstract: str, soc_version: str = "") -> list:
        """search from user kb mem"""
        write_search = self.write_search(name, abstract, soc_version)
        if write_search is None:
            return []
        if isinstance(write_search, list) and len(write_search) > 0:
            return write_search
        return self.__search(name, "user", {"abstract": abstract, "soc_version": soc_version})

    def write_search(self, name: str, abstract: str, soc_version: str) -> list:
        """search from user kb mem"""
        return self.__search(name, "write", {"abstract": abstract, "soc_version": soc_version}, load=False)

    def user_write(self, name: str, abstract: str, content: object) -> RepoMgrRetStatus:
        """write to user kb mem"""
        return self.__write(name, "write", abstract, content)

    def user_delete(self, name: str, abstract: str) -> RepoMgrRetStatus:
        """delete user kb mem"""
        return self.__write(name, "write", abstract, None)

    def user_flush(self, name: str) -> RepoMgrRetStatus:
        """flush user kb to file"""
        return self.__flush(name, "user")

    def close(self) -> None:
        """To close the cann kb manager service
        Description:
        Stop the service, for example, flush the modified file or clear the existing object.
        """
        for name in copy.deepcopy(self.write_kb.keys()):
            self.user_flush(name)
        self.lock_for_creating_lock.acquire()
        self.user_kb = None
        self.write_kb = None
        self.built_in_kb = None
        self.graph_built_in_kb = None
        self.user_bank_path = None
        self.built_in_bank_path = None
        self.graph_built_in_bank_path = None
        self.user_kb_lock = None
        self.write_kb_lock = None
        self.built_in_kb_lock = None
        self.graph_built_in_kb_lock = None
        self.lock_for_creating_lock.release()
        self.lock_for_creating_lock = None

    def get_repo_file_name(self, name: str, soc_ver_str: str = "") -> str:
        """get repo file name"""
        return "_".join([str(soc_ver_str), name]) if soc_ver_str else "_".join([getattr(self, "soc_version"), name])

    @staticmethod
    def json_file_get_content_by_handle(file_handle: TextIO) -> tuple:
        '''
        try to load json file content
        return tuple:
        1. is file valid
        2. file content
        '''
        file_handle.seek(0, SEEK_END)
        tmp_content = {}
        ret = True
        if not file_handle.tell() == 0: # file is not empty
            file_handle.seek(0)
            try:
                tmp_content = json.load(file_handle)
            except (ValueError, TypeError) as e:
                LOG_INSTANCE.warn("Can not load knowledge bank file: %s." % str(e))
                ret = False
                tmp_content = {}
            finally:
                pass
        file_handle.seek(0)
        return ret, tmp_content

    def json_file_get_content(self, file_name: str) -> tuple:
        """
        json file get content by file name
        """
        with open(file_name, "r+") as file_handle:
            return self.json_file_get_content_by_handle(file_handle)

    def backup_repo_file(self, file_name: str, tmp_name: str) -> tuple:
        """
        backup repo file by backup file
        """
        origin_valid, tmp_content = self.json_file_get_content(file_name)
        # if origin file is valid, use it and return success
        if origin_valid:
            if not FileSysUtil.copy_file(file_name, tmp_name):
                LOG_INSTANCE.error("Copy knowledge bank file [%s] to backup file [%s] failed." % (file_name, tmp_name))
                return RepoMgrRetStatus.FILE_COPY_FAIL, {}
            return RepoMgrRetStatus.SUCCESS, tmp_content
        # if origin file is invalid, try to use backup file
        if os.path.isfile(tmp_name):
            tmp_valid, tmp_content = self.json_file_get_content(tmp_name)
            # tmp file is illegal, del it
            if not tmp_valid:
                LOG_INSTANCE.error("Knowledge bank file[%s] and backup file[%s] are invalid." % (file_name, tmp_name))
                FileSysUtil.remove_file(tmp_name)
                return RepoMgrRetStatus.FILE_LOAD_FAIL_USE_ALT_FAIL, {}
            # try to use backup file failed
            if not FileSysUtil.copy_file(tmp_name, file_name):
                LOG_INSTANCE.error(
                    "Copy knowledge bank file [%s] to backup file [%s], copy tmp file failed." % (file_name, tmp_name))
                return RepoMgrRetStatus.FILE_COPY_FAIL, {}
            # Success to recover bank file
            LOG_INSTANCE.info("Success to recover bank file [%s] by using backup file." % file_name)
            return RepoMgrRetStatus.FILE_LOAD_FAIL_USE_ALT_SUCC, tmp_content
        return RepoMgrRetStatus.FILE_LOAD_FAIL, {}

    @lock_exists_check
    def __load(self, name: str, bank_type: str, soc_version: str = "") -> None:
        """load kb from file

        Description:
        Load the knowledge bank file and return the knowledge bank dictionary.

        Parameters:
        name(str): knowledege bank file name
        bank_type(str): Knowledge bank type (user/built_in)
            for mapping intra-class attribute (self.user_bank_path/self.built_in_bank_path)

        Return: None
        """
        if bank_type not in ("user", "built_in", "graph_built_in"):
            err_msg = "Attempt to load wrong knowledge bank type"
            LOG_INSTANCE.error(err_msg)

        # Obtains the own variables of an object.
        kb = getattr(self, bank_type + "_kb")
        kb_path = getattr(self, bank_type + "_bank_path")
        if bank_type != "graph_built_in":
            kb_path = os.path.join(kb_path, soc_version if soc_version else self.soc_version, UNIFIED_DIR)
        kb_lock = getattr(self, bank_type + "_kb_lock")
        file_name = os.path.join(kb_path, name + ".json")

        # Check whether multiple loadings are performed.
        if name in kb.keys():
            LOG_INSTANCE.info("File [%s] has been loaded. You do not need to load it again." % file_name)
            return
        content = self._get_resource("dict")
        # If the target knowledge bank file does not exist, leave it blank and exit.
        if FileSysUtil.file_exist_mode_check(file_name) != RepoMgrRetStatus.SUCCESS:
            with kb_lock[name]:
                if name not in kb.keys():
                    kb[name] = content
            return

        LOG_INSTANCE.info("Load knowledge bank type [%s] File name [%s]." % (bank_type, file_name))
        # The target knowledge bank file exists and is being loaded.
        if "built_in" in bank_type:
            new_load, tmp_content = self._load_bank_content(name, file_name, kb)
        else:
            with LockedOpen(file_name, mode="a"):
                new_load, tmp_content = self._load_bank_content(name, file_name, kb)

        if new_load:
            content.update(tmp_content)
            with kb_lock[name]:
                kb[name] = content
                LOG_INSTANCE.debug("Loading knowledge bank file [%s] ends." % str(file_name))

    def _load_bank_content(self, name: str, file_name: str, kb: dict) -> tuple:
        """
        load bank content
        """
        tmp_content = {}
        with open(file_name, "r") as file_handle:
            if name in kb.keys():
                LOG_INSTANCE.info("File [%s] has been loaded. You do not need to load it again." % file_name)
                return False, {}
            LOG_INSTANCE.debug("Start loading knowledge bank file [%s]." % str(file_name))
            load_flag, tmp_content = self.json_file_get_content_by_handle(file_handle)
            if not load_flag:
                tmp_content = {}
                LOG_INSTANCE.error("Load knowledge bank file[%s] failed." % str(file_name))
        return True, tmp_content


    @lock_exists_check
    def __search(self, name: str, bank_type: str, search_info: dict, load: bool = True) -> list:
        """search from kb mem

        Description:
        Query whether the abstract exists in the knowledge bank.

        Parameters:
        name(str): knowledge bank file name
        bank_type(str): Knowledge bank type (user/built_in)
        search_info:{
                for mapping intra-class attribute (self.user_bank_path/self.built_in_bank_path)
            abstract(str): Keyword for lookup
            soc_version(str): Soc Version}
        load(bool): Whether to load unload data when the data is not loaded

        Return: Knowledges
        """
        abstract = search_info["abstract"]
        soc_version = search_info["soc_version"]
        kb = getattr(self, bank_type + "_kb")
        kb_lock = getattr(self, bank_type + "_kb_lock")
        if name not in kb.keys() and load:
            self.__load(name, bank_type, soc_version)
        with kb_lock[name]:
            if name not in kb:
                return []
            res = kb[name].get(abstract, [])
            if res:
                LOG_INSTANCE.info("Has found knowledge abstract[%s] from [%s] [%s]." % (abstract, bank_type, name))
            return res

    @lock_exists_check
    def __write(self, name: str, bank_type: str, abstract: str, content: object) -> RepoMgrRetStatus:
        """write to kb mem

        Description:
        Overwrite or add knowledge bank entries.

        Parameters:
        name(str): knowledge bank file name
        bank_type(str): Knowledge bank type (user/built_in)
            for mapping intra-class attribute (self.user_bank_path/self.built_in_bank_path)
        abstract(str): Keyword for lookup
        content(object): Knowledge Corresponding to Abstract

        Return: RepoMgrRetStatus
        """
        kb = getattr(self, bank_type + "_kb")
        kb_lock = getattr(self, bank_type + "_kb_lock")
        with kb_lock[name]:
            if name not in kb:
                kb[name] = self._get_resource("dict")
            kb[name][abstract] = content
        return RepoMgrRetStatus.SUCCESS

    @lock_exists_check
    def __flush(self, name: str, bank_type: str) -> RepoMgrRetStatus:
        """flush kb to file

        Description:
        Flsh the knowledge bank dictionary to the knowledge bank file.

        Parameters:
        name(str): knowledege bank file name
        bank_type(str): Knowledge bank type (user/built_in)
            for mapping intra-class attribute (self.user_bank_path/self.built_in_bank_path)

        Return: None
        """
        kb = getattr(self, "write_kb")
        kb_path = getattr(self, bank_type + "_bank_path")
        kb_path = os.path.join(kb_path, self.soc_version, UNIFIED_DIR)
        kb_lock = getattr(self, "write_kb_lock")
        file_name = os.path.join(kb_path, name + ".json")
        tmp_name = os.path.join(file_name + ".aoe")
        LOG_INSTANCE.info("Start to flush Knowledge bank, type [%s] File name [%s]." % (bank_type, file_name))

        if name not in kb:
            LOG_INSTANCE.info("The knowledge bank[%s] is not modified and does not need to be flushed." % file_name)
            return RepoMgrRetStatus.SUCCESS

        if FileSysUtil.create_folder_recursively(kb_path) != RepoMgrRetStatus.SUCCESS:
            LOG_INSTANCE.error("Create folder recursively failed.")
            return RepoMgrRetStatus.FAIL

        if FileSysUtil.create_file(file_name, FileSysUtil.FILE_MODE_640) != RepoMgrRetStatus.SUCCESS:
            LOG_INSTANCE.warn("Can not create repo file %s." % file_name)

        with LockedOpen(file_name, mode="a+"):
            ret, tmp_content = self.backup_repo_file(file_name, tmp_name)
            if ret != RepoMgrRetStatus.SUCCESS and ret != RepoMgrRetStatus.FILE_LOAD_FAIL_USE_ALT_SUCC:
                return ret

            with kb_lock[name]:
                LOG_INSTANCE.debug("Start flushing knowledge bank file [%s]." % str(file_name))
                if name in kb:
                    ret, merged = self.write_merge(file_name, kb[name].copy(), tmp_content)
                    if ret != RepoMgrRetStatus.SUCCESS:
                        LOG_INSTANCE.warn("Flush knowledge bank file [%s] meets something, ret: %s. "
                            "Now try to recovery bank file." % (str(file_name), ret))
                        ret = ret if self.file_recovery(tmp_name, file_name) else RepoMgrRetStatus.FILE_RECOVERY_FAIL
                        return ret
                    if not FileSysUtil.remove_file(tmp_name):
                        LOG_INSTANCE.error("Remove backup file [%s] failed." % str(file_name))
                    self._refresh_kb_content(name, bank_type, merged)
                    kb.pop(name)
                    LOG_INSTANCE.info("Flushing knowledge bank file [%s] ends." % str(file_name))
                else:
                    LOG_INSTANCE.debug("The knowledge bank[%s] has been flushed. "
                        "You do not need to flush it multiple times." % file_name)

        return RepoMgrRetStatus.SUCCESS

    def _get_resource(self, func: str, *args: tuple, **kwargs: dict) -> object:
        """Encapsulation of Method get_resource"""
        return get_resource(self.task_q, self.res_d, self.resource_l, (generate_unique(), func, args, kwargs))

    def _refresh_kb_content(self, name: str, bank_type: str, merged: dict) -> None:
        """
        refresh kb content
        """
        refresh_kb_lock = getattr(self, bank_type + "_kb_lock")
        refresh_kb = getattr(self, bank_type + "_kb")
        with refresh_kb_lock[name]:
            if name not in refresh_kb:
                refresh_kb[name] = self._get_resource("dict")
            refresh_kb[name].clear()
            refresh_kb[name].update(merged)

    def get_all_soc_versions(self, search_type: str) -> list:
        """
        get all altervative soc version
        """
        alter_soc_versions = [self.soc_version]
        soc_alternative = SOC_ALTERNATIVE_GRAPH if search_type == "graph_built_in" else SOC_ALTERNATIVE
        if self.soc_version in soc_alternative:
            alter_soc_versions.extend(soc_alternative[self.soc_version])
        return alter_soc_versions
