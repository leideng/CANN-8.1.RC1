#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2022. Huawei Technologies Co., Ltd. All rights reserved.
External facade of the knowledge base management module
"""
import os
from tbe.common.repository_manager.utils.define import RepoMgrRetStatus
from tbe.common.repository_manager.cann_kb_manager.dynamic_manager import DynamicManager
from tbe.common.repository_manager.cann_kb_manager.static_manager import StaticManager
from tbe.common.repository_manager.utils.repository_manager_log import LOG_INSTANCE


class CannKbManager():
    """cann knowledge manager

    Description:
    External facade of the knowledge base management module.
    """
    def __init__(self, resource_proxy: dict, sys_config: dict, load_config: dict = {}, option: dict = {}) -> None:
        """__init__ for CannKbManager

        Description:
        initialize CannKbManager object

        Parameters:
        resource_proxy(dict): dict content resource proxy object
        sys_config(dict): System Configuration For Software Such As soc_version and core_num
        load_config(dict): Additional Load Knowledge Bank Configuration Such As kb_path
        option(dict): Reserved Configuration Item
        """
        self.__dynamic_mgr = DynamicManager(resource_proxy, sys_config, load_config, option)
        self.__static_mgr = StaticManager(resource_proxy, sys_config, load_config, option)

    def finalize(self) -> None:
        """Finalize Cann Knowledge Bank Service

        Parameters: None
        Return: None
        """
        self.__dynamic_mgr.close()
        self.__static_mgr.close()

    def cann_kb_search(self, info_dict: str, search_config: dict, option: dict = None) -> list:
        """Cann Knowledge Search

        Parameters:
        info_dict(str): Operator Info To Search Knowledge
        search_config(dict): Additional Configuration Items for Knowledge Search
        option(dict): Reserved Configuration Item

        Return: Knowledge List
        """
        if not search_config.get("op_type") or not search_config.get("core_num"):
            LOG_INSTANCE.warn("Search bank proc exit, because op_type or core_num is none.")
            return []
        impl_class = self.__dynamic_mgr if search_config.get("op_mode", "static") == "dynamic" else self.__static_mgr
        searce_file_name = "_".join([search_config.get("core_num"),
                                     search_config.get("core_type", "AiCore"),
                                     search_config.get("op_type")])
        return impl_class.search(info_dict, searce_file_name, {
            "option": option,
            "search_type": search_config.get("search_type", None),
            "full_info": search_config.get("full_info", False),
            "return_type": search_config.get("return_type", "")
        })

    def cann_kb_write(self,
        info_dict: str,
        knowledge: str,
        write_config: dict,
        flush: bool = False,
        option: dict = None) -> RepoMgrRetStatus:
        """Cann Knowledge write(include add and replace)

        Parameters:
        info_dict(str): Operator Info ToSearch Knowledge
        knowledege(str): Operator Knowledge
        write_config(dict): Knowledge Write Config
        flush(bool): force flush knowledege to file
        option(dict): Reserved Configuration Item

        Return:
        RepoMgrRetStatus
        """
        if not write_config.get("op_type") or not write_config.get("core_num"):
            return RepoMgrRetStatus.FAIL
        impl_class = self.__dynamic_mgr if write_config.get("op_mode", "static") == "dynamic" else self.__static_mgr
        write_file_name = "_".join([write_config.get("core_num"),
                                    write_config.get("core_type", "AiCore"),
                                    write_config.get("op_type")])
        return impl_class.write(info_dict, write_file_name, knowledge, {
            "flush": flush,
            "option": option,
            "cost_time": write_config.get("cost_time", -1),
            "origin": write_config.get("origin", "UNKNOWN")
        })

    def cann_kb_delete(self,
        info_dict: str,
        delete_config: dict,
        flush: bool = False,
        option: dict = None) -> RepoMgrRetStatus:
        """Cann Knowledge delete custom repo

        Parameters:
        info_dict(str): Operator Info ToSearch Knowledge
        knowledege(str): Operator Knowledge
        delete_config(dict): Knowledge Write Config
        flush(bool): force flush knowledege to file
        option(dict): Reserved Configuration Item

        Return:
        RepoMgrRetStatus
        """
        impl_class = self.__dynamic_mgr if delete_config.get("op_mode", "static") == "dynamic" else self.__static_mgr
        delete_file_name = "_".join([delete_config.get("core_num"),
                                     delete_config.get("core_type", "AiCore"),
                                     delete_config.get("op_type")])
        return impl_class.delete(info_dict, delete_file_name, flush, {
            "option": option
        })
