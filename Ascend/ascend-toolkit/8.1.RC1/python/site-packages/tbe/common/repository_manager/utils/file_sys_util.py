#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2022. Huawei Technologies Co., Ltd. All rights reserved.

file system util
"""
import os
import re
import fcntl
import shutil
from tbe.common.repository_manager.utils.define import RepoMgrRetStatus
from tbe.common.repository_manager.utils.repository_manager_log import LOG_INSTANCE


PAIR_STEP_NUM = 2


class LockedOpen(object):
    """
    Class for opening file oprator with locked
    lock is valiable when copy or rename file
    """
    def __init__(self, file_name: str, *args: object, **kwargs: object):
        """
        __init__ for class LockedOpen
        """
        self.file_name = file_name
        self.open_args = args
        self.open_kwargs = kwargs
        self.file_obj = None

    def __enter__(self):
        """
        __enter__ for class LockedOpen
        open file after get the lock
        """
        f = open(self.file_name, *self.open_args, **self.open_kwargs)
        while True:
            fcntl.flock(f, fcntl.LOCK_EX)
            fnew = open(self.file_name, *self.open_args, **self.open_kwargs)
            if os.path.sameopenfile(f.fileno(), fnew.fileno()):
                fnew.close()
                break
            f.close()
            f = fnew
        self.file_obj = f
        return f

    def __exit__(self, _exc_type, _exc_val, _traceback):
        """
        __enter__ for class LockedOpen
        close file
        """
        self.file_obj.close()


class FileSysUtil:
    """file system util
    """
    FILE_MODE_777 = 0o777
    FILE_MODE_640 = 0o640
    DIR_MODE_750 = 0o750
    FILE_FLAG = os.O_RDONLY | os.O_WRONLY | os.O_CREAT

    @classmethod
    def create_file(cls, file_path: str, file_mode: int = 0o600) -> RepoMgrRetStatus:
        """create an empty file for abs file_path

        Parameters:
        file_path(str): file path to create an empty file
        """
        tmp_file_path = os.path.realpath(file_path)
        if os.path.exists(tmp_file_path):
            file_stat = oct(os.stat(tmp_file_path).st_mode)[-3:]
            object_stat = oct(file_mode)[-3:]
            if file_stat != object_stat:
                LOG_INSTANCE.warn("[{}] exists.But file mode[{}] does not equal to [{}]".format(
                    tmp_file_path, file_stat, object_stat))
                return RepoMgrRetStatus.FILE_PATTERN_MISMATCH
            return RepoMgrRetStatus.SUCCESS
        try:
            os.mknod(tmp_file_path, file_mode)
        except OSError as exception:
            LOG_INSTANCE.warn('Can not create {}, '
                 'exception: {}'.format(tmp_file_path, str(exception)))
            return RepoMgrRetStatus.FAIL
        finally:
            LOG_INSTANCE.debug("FileSysUtil try to create file[{}]".format(tmp_file_path))
        return RepoMgrRetStatus.SUCCESS

    @classmethod
    def file_exist_mode_check(cls, file, file_mode: int = None) -> RepoMgrRetStatus:
        """check file exists and mode equal to file_mode"""
        if os.path.exists(file):
            if file_mode is None:
                return RepoMgrRetStatus.SUCCESS
            file_stat = oct(os.stat(file).st_mode)[-3:]
            object_stat = oct(file_mode)[-3:]
            if file_stat != object_stat:
                return RepoMgrRetStatus.FAIL
            return RepoMgrRetStatus.SUCCESS
        return RepoMgrRetStatus.FAIL

    @classmethod
    def create_folder_recursively(cls, path: str, mode: int = 0o750) -> RepoMgrRetStatus:
        """Create Folder Recursively

        Description:
        as same as func name

        Parameters:
        path(str): Path of the folder to be created
        mode(int): Folder Creation Permissions

        Returns: RepoMgrRetStatus
        """
        LOG_INSTANCE.debug("create_folder_recursively try to create [%s]." % path)
        real_path = os.path.realpath(path)
        if os.path.exists(real_path):
            return RepoMgrRetStatus.SUCCESS
        each_level_paths = real_path.split(os.sep)
        base_path = os.sep
        for item in each_level_paths:
            base_path = os.path.join(base_path, item)
            if not item or os.path.exists(base_path):
                continue
            try:
                os.makedirs(base_path, mode, exist_ok=True)
            except OSError as e:
                LOG_INSTANCE.error("An error happened while creating [%s], error is[%s]" % (base_path, str(e)))
                raise RuntimeError({"errCode": "EC0006", "reason": str(e)})
            finally:
                pass
        return RepoMgrRetStatus.SUCCESS

    @classmethod
    def remove_file(cls, file_path: str) -> bool:
        """
        remove file
        file_path: file path
        """
        ret = True
        if not os.path.isfile(file_path):
            LOG_INSTANCE.warn("Failed to remove file[%s], inputs is illegal.", file_path)
            return False
        try:
            os.remove(file_path)
        except (FileNotFoundError, IOError):
            ret = False
            LOG_INSTANCE.warn("Operator of remove file[%s] raise except.", file_path)
        finally:
            pass
        return ret

    @classmethod
    def copy_file(cls, file_path_src: str, file_path_dst: str) -> bool:
        """
        copy file from file_path_src to file_path_dst
        file_path_src: file path
        file_path_dst: file path
        """
        ret = True
        if not os.path.isfile(file_path_src):
            LOG_INSTANCE.warn("Failed to copy file[%s] to [%s], inputs is illegal.", file_path_src, file_path_dst)
            return False
        try:
            shutil.copy(file_path_src, file_path_dst)
        except (FileNotFoundError, IOError):
            ret = False
            LOG_INSTANCE.warn("Operator of copy file[%s] to [%s] raise except.", file_path_src, file_path_dst)
        finally:
            pass
        return ret

    @classmethod
    def rename_file(cls, file_path_src: str, file_path_dst: str) -> bool:
        """
        rename file from file_path_src to file_path_dst
        file_path_src: file path
        file_path_dst: file path
        """
        ret = True
        if not os.path.isfile(file_path_src):
            LOG_INSTANCE.warn("Failed to rename file[%s] to [%s], inputs is illegal.", file_path_src, file_path_dst)
            return False
        try:
            os.rename(file_path_src, file_path_dst)
        except (FileNotFoundError, IOError):
            ret = False
            LOG_INSTANCE.warn("Operator of rename file[%s] to [%s] raise except.", file_path_src, file_path_dst)
        finally:
            pass
        return ret

    @classmethod
    def str_insert(cls, str_origin: str, pos: int, str_add: str) -> str:
        """
        insert sub str to origin str in pos:
        str_origin: origin str.
        pos: insert position.
        str_add: sub str to be insert.
        return: string after inserting sub str
        """
        str_list = list(str_origin)
        str_list.insert(pos, str_add)
        str_out = ''.join(str_list)
        return str_out

    @classmethod
    def content_to_stand_str(cls, content: object) -> str:
        """
        change content (dict / list / str) to an standerd str without "'"
        json_handle: json file handle
        tiling_dict: tiling_dict
        return: None
        """
        str_double = []
        str_single = []
        str_case = str(content)
        str_double = [substr.start() for substr in re.finditer('"', str_case)]
        str_single = [substr.start() for substr in re.finditer('\'', str_case)]
        str_all_invalid = [substr.start() + 1 for substr in re.finditer("\\\\'", str_case)]
        str_all = str_double + str_single
        str_all_valid = list(filter(lambda x: x not in str_all_invalid, str_all))
        str_all_valid.sort()
        str_double.sort()
        str_single.sort()
        str_single_except = list(filter(lambda x: x in str_all_valid, str_single))
        str_double_except = list(filter(lambda x: x in str_all_valid, str_double))

        str_double_change = []
        for idx in range(1, len(str_single_except), PAIR_STEP_NUM):
            index_start = str_all_valid.index(str_single_except[idx - 1])
            index_end = str_all_valid.index(str_single_except[idx])
            if index_end != index_start + 1:
                str_all_change = str_all_valid[index_start + 1 : index_end]
                str_double_change.extend(list(filter(lambda x: x in str_double_except, str_all_change)))
        for idx in range(1, len(str_double_except), PAIR_STEP_NUM):
            index_start = str_all_valid.index(str_double_except[idx - 1])
            index_end = str_all_valid.index(str_double_except[idx])
            if index_end != index_start + 1:
                str_all_change = str_all_valid[index_start + 1 : index_end]
                str_double_change.extend(list(filter(lambda x: x in str_single_except, str_all_change)))
        str_double_change.sort()
        for i in reversed(str_double_change):
            str_case = cls.str_insert(str_case, i, "\\")
        str_case = str_case.replace('\'', '\"')
        str_case = str_case.replace('None', 'null').replace('False', 'false').replace('True', 'true')
        return str_case

    @classmethod
    def write_json_file(cls, json_handle: object, content: object) -> None:
        """
        write json content to file
        """
        json_handle.seek(0)
        json_handle.truncate()
        json_handle.write("{\n")
        md5_keys = list(content.keys())
        for key in md5_keys:
            line_content = cls.content_to_stand_str(content.get(key))
            final_case = f'\"{str(key)}\": {line_content}'
            json_handle.write(final_case)
            json_handle.write("\n" if key == md5_keys[-1] else ",\n")
        json_handle.write("}")
        json_handle.flush()
