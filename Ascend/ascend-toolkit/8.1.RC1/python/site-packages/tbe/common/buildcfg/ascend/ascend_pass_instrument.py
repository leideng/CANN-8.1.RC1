#!/usr/bin/env python
# coding: utf-8
# Copyright 2019-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================

from tbe.common.buildcfg.buildcfg_mapping import *
from tbe.tvm.ir.instrument import pass_instrument
from tbe.tvm.tir import IsTikHybrid
from tbe.tvm.tir.expr import IntImm


@pass_instrument
class PrintIRInstrument:
    def __init__(self, passes=[], after=True, save_file=False, one_file=False):
        self.passes = passes
        self.after = after  # otherwise print before pass
        self.save_file = save_file  # whether or not save in files
        self.one_file = one_file
        self._index = 0
        self._file_name = "ir.cc"
        if self.save_file and self.one_file:
            f = open(self._file_name, "w")
            f.write("// IRList:\n")
            f.close()

    @staticmethod
    def _print_to_stream(prefix, mod, stream):
        print(prefix, file=stream)
        print(mod, file=stream)

    def _print(self, mark, mod, info):
        if info.name not in self.passes:
            return
        pass_mark = "%d_%s_%s" % (self._index, mark, info.name)
        prefix = "// ***********************%s***********************" % pass_mark
        if self.save_file:
            try:
                if self.one_file:
                    file_name = self._file_name
                    f = open(file_name, "a")
                else:
                    file_name = "%s.cc" % pass_mark
                    f = open(file_name, "w")
                self._print_to_stream(prefix, mod, f)
                f.close()
            except IOError:
                print("file open failed %s" % file_name)
        else:
            self._print_to_stream(prefix, mod, None)

    def run_after_pass(self, mod, info):
        if self.after:
            self._print("after", mod, info)
        self._index += 1

    def run_before_pass(self, mod, info):
        if not self.after:
            self._print("before", mod, info)


def _update_tik_hybrid(instrument, mod, info):
    # the reason that add this condition is to avoid
    # IsTikHybrid executing multiple times
    if info.name == Pass_TextureFlatten:
        for var in mod.get_global_vars():
            func = mod[var.name_hint]
            if IsTikHybrid(func.body):
                instrument.tik_hybrid = True
                break


def _update_skip_pass_list(instrument, info):
    if info.name == Pass_ReorderProcess:
        instrument.skip_pass_list.clear()


@pass_instrument
class RegbaseV2ListInstrument:
    def __init__(self, config):
        self.tik_hybrid = False
        self.canonical_simplify_cnt = 0
        self.constant_folding_cnt = 0
        self.set_spr_optimizer_cnt = 0
        self.align_leaf_iter_var_cnt = 0
        self.is_need_rollback = True
        self.skip_pass_list = []
        # we cannot set value to tvm.ir.container.Map directly,
        # so we should change it as dict.
        config_of_instrument = dict(config)
        for c in config:
            if isinstance(config[c], IntImm):
                config_of_instrument[c] = config[c].value
        self.config = config_of_instrument

    def should_run(self, mod, info):
        if info.name in self.skip_pass_list and not self.is_need_rollback:
            return False
        if info.name == Pass_ConstantFolding:
            self.constant_folding_cnt = self.constant_folding_cnt + 1
            if self.constant_folding_cnt == 2:
                return self.config[enable_const_fold] and not self.config[dynamic_shape]
        if info.name == Pass_AlignLeafIterVars:
            self.align_leaf_iter_var_cnt = self.align_leaf_iter_var_cnt + 1
            if self.align_leaf_iter_var_cnt == 1:
                return self.config[enable_loop_partition] or not self.config[dynamic_shape]
            if self.align_leaf_iter_var_cnt == 2:
                return self.config[dynamic_shape]
        if info.name == Pass_ExtractExtent or \
           info.name == Pass_EliminateBranch or \
           info.name == Pass_InjectValidator or info.name == Pass_ExtractComplexExpr or \
           info.name == Pass_LoopUnswitch or info.name == Pass_OptimizeSetIntrin or \
           info.name == Pass_EnableTempBufferDb or info.name == Pass_ExtractLetStmt or \
           info.name == Pass_AdjustExtent or info.name == Pass_InjectStrideInfoIntoForLoop or \
           info.name == Pass_MergeSameIfCondition or \
           info.name == Pass_HoistKernelInvariantVar or info.name == Pass_Int64Prompt:
            return self.config[dynamic_shape]
        if info.name == Pass_RemoveDuplicatesInLoad:
            return self.config[remove_duplicates_in_load]
        if info.name == Pass_FullySplitLoopPartition or info.name == Pass_SinglePointManager:
            return self.config[enable_loop_partition] or not self.config[dynamic_shape]
        if info.name == Pass_PartitionSpecifiedRange or info.name == Pass_Select2If:
            return not self.config[enable_loop_partition] and self.config[dynamic_shape]
        if info.name == Pass_BranchMotion or info.name == Pass_SequenceSprInsn or \
           info.name == Pass_InjectVirtualThread or info.name == Pass_ReorderProcess or \
           info.name == Pass_SetCacheMode or info.name == Pass_GMConflictElimination or \
           info.name == Pass_GmAddrPrompt:
            return not self.config[dynamic_shape]
        if info.name == Pass_DebugTikPreprocess:
            return self.config[tik_debug_context_id] != -1
        if info.name == Pass_SetSPROptimizer:
            self.set_spr_optimizer_cnt = self.set_spr_optimizer_cnt + 1
            if self.set_spr_optimizer_cnt == 1:
                return self.config[dynamic_shape]
            if self.set_spr_optimizer_cnt == 2:
                return not self.config[dynamic_shape] and not (self.config[tik] or self.tik_hybrid)
        if info.name == Pass_DeSequenceSprInsn:
            return not self.config[dynamic_shape] and not (self.config[tik] or self.tik_hybrid)
        if info.name == Pass_CanonicalSimplify:
            self.canonical_simplify_cnt = self.canonical_simplify_cnt + 1
            if self.canonical_simplify_cnt == 4:
                return not self.config[dynamic_shape] and not (self.config[tik] or self.tik_hybrid)
        if info.name == Pass_TikDynamicShapeAllocMem:
            return not self.config[dynamic_shape] and self.config[tik] and not self.tik_hybrid and \
                self.config[dynamic_tik]
        return True

    def run_after_pass(self, mod, info):
        # To check if need rollback in StorageRewriteCCE. If need rollback, run FuseLoopInVF
        # and following pass again. If not, skip middle pass.
        if info.name == Pass_StorageRewriteCCE:
            for var in mod.get_global_vars():
                func = mod[var.name_hint]
                if need_rollback in func.attrs and not func.attrs.need_rollback:
                    self.is_need_rollback = False

    def run_before_pass(self, mod, info):
        _update_tik_hybrid(self, mod, info)
        _update_skip_pass_list(self, info)
