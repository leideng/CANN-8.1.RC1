#!/usr/bin/env python
# coding: utf-8
# Copyright 2021 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
This module provides the functions about build_config.
"""
import warnings

from tbe import tvm
from tbe.tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE
from tbe.tvm.ir.container import type_convert

from .ascend import AscendPassContext
from .buildcfg_mapping import dynamic_shape, disable_vectorize, instrument_bound_checkers, ub_fusion_tensors, ub_fusion_buffers
from .default_buildcfg import cce_default_static_build_config
from .global_info import GlobalInfoContainer


def _check_kwargs(kwargs):
    if "tbe_debug_level" in kwargs.keys():
        if kwargs["tbe_debug_level"] not in (0, 1, 2):
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, "Unsupported tbe_debug_level: %s, it must be \
                               one of (0, 1, 2) and the data type \
                               must be int " % kwargs["tbe_debug_level"])

    if "vector_fp_ceiling" in kwargs.keys():
        if kwargs["vector_fp_ceiling"] not in (0, 1, 2):
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, "Unsupported vector_fp_ceiling. it must be \
                               one of (0, 1, 2) and the data type \
                               must be int.")

    if "compatible" in kwargs:
        if not isinstance(kwargs["compatible"], bool):
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                 "'%s' should be a boolean variable" % (kwargs["compatible"]))


def _update_config_dict(kwargs, config_dict):
    """Use kwargs to update current build config dict."""
    for key in kwargs.keys():
        if key == "dynamic_shape":
            new_key = dynamic_shape
        elif "tir." in key:
            new_key = key
        else:
            new_key = "tir." + key
        if new_key in config_dict:
            config_dict[new_key] = kwargs[key]
            if key in GlobalInfoContainer.global_info:
                GlobalInfoContainer.global_info[key] = kwargs[key]
        elif key != "compatible":
            warnings.warn("build_config cannot set attribute '%s'" % key)

    """initialize config which do not expose to user"""
    config_dict[disable_vectorize] = False
    config_dict[instrument_bound_checkers] = False
    config_dict[ub_fusion_tensors] = []
    config_dict[ub_fusion_buffers] = []


def build_config(**kwargs):
    """Configure the build behavior by setting config variables.

    Parameters
    ----------
    compatible: bool, default=False
        If compatible = True, update build_config in cce_build.py

    Returns
    -------
    pass context: AscendPassContext
        The build configuration
    """
    _check_kwargs(kwargs)
    config_dict = cce_default_static_build_config.copy()
    if AscendPassContext.get_scope_size() > 0:
        config_dict = type_convert(AscendPassContext.current().config)
    _update_config_dict(kwargs, config_dict)
    return AscendPassContext(config=config_dict)


def _get_config_dict_without_tir(config_dict):
    res = {}
    for key in config_dict:
        value = config_dict.get(key)
        if isinstance(value, tvm.tir.IntImm):
            value = value.value
        if isinstance(value, tvm.runtime.String):
            value = str(value)

        if isinstance(key, tvm.runtime.String):
            key = str(key)

        if key.startswith("tir."):
            res[key[len("tir."):]] = value

    return res


def get_config_value(key, config_dict):
    if key == "dynamic_shape":
        return config_dict.get(dynamic_shape)
    elif key in config_dict:
        return config_dict.get(key)
    elif ("tir." + key) in config_dict:
        return config_dict.get("tir." + key)
    elif key == "all":
        return _get_config_dict_without_tir(config_dict)
    return None


def get_current_build_config(key="all"):
    """Get the current build configuration."""
    cur_conf = AscendPassContext.current().config

    if len(cur_conf) == 0:
        cur_conf = cce_default_static_build_config.copy()
        return get_config_value(key, cur_conf)

    value = None

    if key == "dynamic_shape":
        value = cur_conf.get(dynamic_shape)
    elif key in cur_conf:
        value = cur_conf.get(key)
    elif ("tir." + key) in cur_conf:
        value = cur_conf.get("tir." + key)

    if value is not None:
        if isinstance(value, tvm.tir.IntImm):
            return value.value
        if isinstance(value, tvm.runtime.String):
            return str(value)
        return value

    if key == "all":
        return _get_config_dict_without_tir(cur_conf)

    return None


def get_default_build_config(key="all"):
    """Get the default build configuration."""
    config_dict = cce_default_static_build_config
    return get_config_value(key, config_dict)


def set_current_build_config(key, value):
    """set cce build config just for compatible with old ops."""
    if AscendPassContext.get_scope_size() > 0:
        target_pass_context = AscendPassContext.current()
        config = dict(target_pass_context.config)
        if key == "dynamic_shape":
            config[dynamic_shape] = value
        elif key in config:
            config[key] = value
        elif ("tir." + key) in config:
            config["tir." + key] = value
        target_pass_context.override_config(config)
    else:
        if key in GlobalInfoContainer.global_info:
            GlobalInfoContainer.global_info[key] = value
