#!/usr/bin/env python
# coding: utf-8
# Copyright 2019-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================

from tbe import tvm
from tbe.common.buildcfg.buildcfg_mapping import *
from tbe.tvm.tir.transform.transform import VectorizeLoop, StorageFlatten
from tbe.common.platform import get_soc_spec, ASCEND_310B, AS31XM1, BS9SX1A, ASCEND_031, \
    ASCEND_610LITE, BS9SX2A, MC61AM21A, ASCEND_910_95
from tbe.tvm.ir import _ffi_instrument_api
from tbe.tvm.ir.transform import PassContext
from tbe.tvm.ir.transform import _ffi_transform_api

from . import base_static_list, base_dynamic_list, regbase_v2_unified_list
from .ascend_pass_instrument import RegbaseV2ListInstrument


@tvm._ffi.register_object("transform.PassContext")
class AscendPassContext(PassContext):
    """The basis where a Relay optimization/analysis runs on.
    Each pass context contains a number of auxiliary information that is used
    to help an optimization pass. Such information includes the error reporter
    to record the errors of during the optimization, etc.

    opt_level : Optional[int]
        The optimization level of this pass.

    required_pass : Optional[Union[List[str], Set[str], Tuple[str]]]
        The list of passes that are required by a certain pass.

    disabled_pass : Optional[Union[List[str], Set[str], Tuple[str]]]
        The list of passes that are disabled.

    instruments : Optional[Sequence[PassInstrument]]
        The list of pass instrument implementations.

    config : Optional[Dict[str, Object]]
        Additional configurations for specific passes.
    """

    def __init__(
            self,
            opt_level=2,
            required_pass=None,
            disabled_pass=None,
            instruments=None,
            config=None,
    ):
        self.skip_pass_list = []
        cce_instruments = None
        if (config != None) and \
                (dynamic_shape in config.keys()) and \
                (add_lower_pass in config.keys()):
            if apply_tbe_pass in config.keys() and config[apply_tbe_pass]:
                config[add_lower_pass], cce_instruments = self._get_pass_instrument_list(
                    config)
                if cce_instruments is not None:
                    cce_instruments.skip_pass_list = self.skip_pass_list
            else:
                if config[add_lower_pass] is not None:
                    config[add_lower_pass] = []

        required = list(required_pass) if required_pass else []
        if not isinstance(required, (list, tuple)):
            raise TypeError(
                "required_pass is expected to be the type of " + "list/tuple/set.")

        disabled = list(disabled_pass) if disabled_pass else []
        if not isinstance(disabled, (list, tuple)):
            raise TypeError(
                "disabled_pass is expected to be the type of " + "list/tuple/set.")

        instruments = list(instruments) if instruments else []
        if cce_instruments is not None:
            instruments.append(cce_instruments)
        else:
            instruments.append(_ffi_instrument_api.MakeTBEPassInstrument())
        if dump_ir in config and config[dump_ir]:
            instruments.append(_ffi_instrument_api.MakeDumpIRInstrument("./ir_stmt"))
        if not isinstance(instruments, (list, tuple)):
            raise TypeError(
                "instruments is expected to be the type of " + "list/tuple/set.")

        self.__init_handle_by_constructor__(
            _ffi_transform_api.PassContext, opt_level, required, disabled, instruments, config
        )

    def _update_static_pass_list(self, config):
        for index, value in enumerate(base_static_list):
            pass_func = value[1]
            if pass_func.pass_info.name == Pass_StorageFlatten:
                cache_line_size = 64
                base_static_list[index] = (value[0], StorageFlatten(
                    cache_line_size, config[instrument_bound_checkers]))
            if pass_func.pass_info.name == Pass_VectorizeLoop:
                base_static_list[index] = (
                    value[0], VectorizeLoop(not config[disable_vectorize]))
                break
        return base_static_list

    def _update_dynamic_pass_list(self, config):
        for index, value in enumerate(base_dynamic_list):
            pass_func = value[1]
            if pass_func.pass_info.name == Pass_StorageFlatten:
                cache_line_size = 64
                base_static_list[index] = (value[0], StorageFlatten(
                    cache_line_size, config[instrument_bound_checkers]))
                break
        return base_dynamic_list

    def _get_pass_instrument_list(self, config):
        is_dynamic = config[dynamic_shape]
        version = get_soc_spec("SHORT_SOC_VERSION")
        aicore_type = get_soc_spec("AICORE_TYPE")
        is_reg = (version == ASCEND_310B) or (version == ASCEND_031) \
            or ((version == BS9SX1A) and (aicore_type == "VectorCore")) \
            or (version == ASCEND_610LITE) or (version == BS9SX2A) or (version == MC61AM21A) \
            or (version == AS31XM1) or (version == ASCEND_910_95)
        if is_reg:
            return self._get_modified_regbase_v2_list(), RegbaseV2ListInstrument(config)
        if is_dynamic and (not is_reg):
            new_base_dynamic_list = self._update_dynamic_pass_list(config)
            return new_base_dynamic_list, None
        if (not is_dynamic) and (not is_reg):
            new_base_static_list = self._update_static_pass_list(config)
            return new_base_static_list, None

    def _get_modified_regbase_v2_list(self):
        start_idx = 0
        end_idx = 0
        duplicate = []
        begin_record = False
        for index, value in enumerate(regbase_v2_unified_list):
            pass_func = value[1]
            if pass_func.pass_info.name == Pass_FuseLoopInVF:
                start_idx = index
                begin_record = True
            if begin_record:
                duplicate.append((2, pass_func))
                self.skip_pass_list.append(pass_func.pass_info.name)
            if pass_func.pass_info.name == Pass_StorageRewriteCCE:
                end_idx = index + 1
                break
        modified_list = regbase_v2_unified_list[0:end_idx] + duplicate * 3 \
            + regbase_v2_unified_list[end_idx::]
        return modified_list
