#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
Copyright (C) 2022. Huawei Technologies Co., Ltd. All rights reserved.

Description: common function of cube operators
"""
from tbe.common.platform import platform_info


CONV2D_BACKPROP_FILTER_OP_NAME = "conv2d_backprop_filter"


def del_dict_key(dicts):
    """
    delete dict key
    """
    del_key_list = ["CUB_matrix", "AUB_channel_wise_flag", "BUB_channel_wise_flag", "CUB_channel_wise_flag",
                    "A_overhead_opt_flag", "B_overhead_opt_flag", "n_bef_batch_flag",
                    "n_bef_group_flag", "CUB_pbuffer"]
    for key_name in del_key_list:
        if key_name in dicts.keys():
            del dicts[key_name]
    return dicts


def decode_tiling(tiling):
    """ adjust tiling items for schedule
    """
    if not platform_info.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out"):
        return
    exponent_base = 2
    index_n_bef_batch = 1
    index_n_bef_group = 2
    index_batch_bef_group = 3
    len_tiling = 5
    if len(tiling.get("block_dim")) == len_tiling:
        tiling["block_dim"] = tiling.get("block_dim")[:-1]
        # default L1_shape from query_repository is none
        # full load L1_shape is a empty list
        if tiling.get("AL1_shape"):
            # add check for change_full_load_to_value function in gemm_tilingcase
            if len(tiling.get("AL1_shape")) == len_tiling:
                tiling["AL1_shape"] = tiling.get("AL1_shape")[:-1]
        if tiling.get("BL1_shape"):
            if len(tiling.get("BL1_shape")) == len_tiling:
                tiling["BL1_shape"] = tiling.get("BL1_shape")[:-1]
        # full load L0_matrix is a empty list
        if tiling.get("AL0_matrix"):
            tiling["AL0_matrix"] = tiling.get("AL0_matrix")[:-1]
        if tiling.get("BL0_matrix"):
            tiling["BL0_matrix"] = tiling.get("BL0_matrix")[:-1]
        tiling["CL0_matrix"] = tiling.get("CL0_matrix")[:-1]

        tiling["CUB_matrix"] = tiling.get("L0C_OUTPUT_matrix")
        pb_l0c_output = tiling.get("manual_pingpong_buffer").get("L0C_OUTPUT_pbuffer")
        tiling["manual_pingpong_buffer"]["CUB_pbuffer"] = pb_l0c_output
        del tiling["L0C_OUTPUT_matrix"]
        del tiling["manual_pingpong_buffer"]["L0C_OUTPUT_pbuffer"]

        (tiling["AUB_channel_wise_flag"],
         tiling["BUB_channel_wise_flag"],
         tiling["CUB_channel_wise_flag"]) = tiling.get("UB_channel_wise_input")
        tiling["A_overhead_opt_flag"] = tiling.get("special_optimize_flag") % exponent_base
        tiling["B_overhead_opt_flag"] = tiling.get("special_optimize_flag") // exponent_base % exponent_base
        tiling["n_bef_batch_flag"] = 0
        tiling["n_bef_group_flag"] = 0
        tiling["batch_bef_group_flag"] = 0
        if tiling.get("control_reorder_flag") == index_n_bef_batch:
            tiling["n_bef_batch_flag"] = 1
        elif tiling.get("control_reorder_flag") == index_n_bef_group:
            tiling["n_bef_group_flag"] = 1
        elif tiling.get("control_reorder_flag") == index_batch_bef_group:
            tiling["batch_bef_group_flag"] = 1
        del tiling["UB_channel_wise_input"]
        del tiling["control_reorder_flag"]


def decode_tiling_v1_to_v2(tiling):
    """
    adjust tiling items for schedule
    """
    index_n_bef_batch = 1
    index_n_bef_group = 2
    index_batch_bef_group = 3
    len_tiling = 4
    if len(tiling.get("block_dim")) == len_tiling:
        tiling["block_dim"] = list(tiling["block_dim"]) + [1]
        # default L1_shape from query_repository is none
        # full load L1_shape is a empty list
        if tiling.get("AL1_shape"):
            # add check for change_full_load_to_value function in gemm_tilingcase
            if len(tiling.get("AL1_shape")) == len_tiling:
                tiling["AL1_shape"] = list(tiling.get("AL1_shape")) + [1]
        if tiling.get("BL1_shape"):
            if len(tiling.get("BL1_shape")) == len_tiling:
                tiling["BL1_shape"] = list(tiling.get("BL1_shape")) + [1]
        # full load L0_matrix is a empty list
        if tiling.get("AL0_matrix"):
            tiling["AL0_matrix"] = list(tiling.get("AL0_matrix")) + [1]
        if tiling.get("BL0_matrix"):
            tiling["BL0_matrix"] = list(tiling.get("BL0_matrix")) + [1]
        tiling["CL0_matrix"] = list(tiling.get("CL0_matrix")) + [1]

        tiling["L0C_OUTPUT_matrix"] = tiling.get("CUB_matrix")
        pb_l0c_output = tiling.get("manual_pingpong_buffer").get("CUB_pbuffer")
        tiling["manual_pingpong_buffer"]["L0C_OUTPUT_pbuffer"] = pb_l0c_output

        tiling["UB_channel_wise_input"] = [tiling.get("AUB_channel_wise_flag"), tiling.get("BUB_channel_wise_flag"),
                                           tiling.get("CUB_channel_wise_flag")]

        tiling["special_optimize_flag"] = tiling.get(
            "A_overhead_opt_flag") + (tiling.get("B_overhead_opt_flag") << 1)

        if tiling.get("n_bef_batch_flag"):
            tiling["control_reorder_flag"] = index_n_bef_batch
        elif tiling.get("n_bef_group_flag"):
            tiling["control_reorder_flag"] = index_n_bef_group
        elif tiling.get("batch_bef_group_flag"):
            tiling["control_reorder_flag"] = index_batch_bef_group

        tiling = del_dict_key(tiling)
        tiling = del_dict_key(tiling["manual_pingpong_buffer"])
