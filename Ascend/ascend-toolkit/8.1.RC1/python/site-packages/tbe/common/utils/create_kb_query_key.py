#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
provides the function of generating the tiling key for tik optimization
"""

import hashlib
import json
from tbe.common.utils import log


def _check_unique_key_params(name, params):
    """
    check get_op_compile_unique_key func params
    """
    if not isinstance(params, (list, tuple)) and params:
        raise RuntimeError("The get_op_compile_unique_key api param %s must be list or tuple,"
                           " but get %s" % (name, type(params)))


def _sort_unique_key_params(params):
    """
    sort_unique_key_params
    """
    if not isinstance(params, dict):
        log.warn("The get_op_compile_unique_key api param must be nest dict, but get %s" % params)
        return params

    new_params = {}
    for k in sorted(params.keys()):
        if k == "name":
            continue
        new_params[k] = params.get(k)
    return new_params


def _is_dynamic(op_info):
    """
    check whether this op's shape is dynamic
    """
    dynamic_dim_value = (-2, -1)

    shape = op_info.get("shape")
    if shape is None:
        return False

    for dim in shape:
        if dim in dynamic_dim_value:
            return True
    return False


def _add_inputs_outputs_default_key(name, param_info, add_field=False):
    """
    The inputs and outputs of the op, adds default fields
    """
    # When add_field False, no fields are added
    if not (isinstance(add_field, bool) and add_field):
        return
    shape = param_info.get("shape")
    default_keys = {
        "L1_addr_offset": 0,
        "L1_fusion_type": -1,
        "L1_workspace_size": -1,
        "addr_type": 0,
        "ori_format": "ND",
        "ori_shape": shape,
        "slice_offset": [],
        "split_index": 0,
        "sub_format": 0,
        "total_shape": shape,
        "valid_shape": []
    }

    # The 'ori_range' in the output does not need to be added when static op.
    if not (not _is_dynamic(param_info) and name == "outputs"):
        default_keys["ori_range"] = param_info.get("range")

    # The 'peer_out_param_index' and 'sgt_slice_shape' in the outputs don't need to be added.
    if name == "inputs":
        default_keys["sgt_slice_shape"] = []
        # When the input.shape is (1,), the values of 'ori_range' and 'ori_shape' are [].
        if shape in [[1], (1,)]:
            default_keys["ori_range"] = []
            default_keys["ori_shape"] = []

    for m_key in default_keys:
        if m_key not in param_info.keys():
            param_info[m_key] = default_keys.get(m_key)


def _get_new_inputs_outputs(name, params, add_field=False):
    """
    Delete unnecessary keys
    """
    if not params:
        log.warn("The get_op_compile_unique_key api param %s is empty.", name)
        return params

    new_params = []
    for param in params:
        # param may be None, (), {}, at this param no process.
        if not param:
            new_params.append(param)
        # param is dict, need sort the param
        elif isinstance(param, dict):
            _add_inputs_outputs_default_key(name, param, add_field)
            new_param = _sort_unique_key_params(param)
            new_params.append(new_param)
        # param is list or tuple, get nest dict
        elif isinstance(param, (list, tuple)):
            new_param_inner = []
            for param_i in param:
                # param_i must be dict, need sort the param_i
                if isinstance(param_i, dict):
                    _add_inputs_outputs_default_key(name, param_i, add_field)
                    new_param_i = _sort_unique_key_params(param_i)
                    new_param_inner.append(new_param_i)
                else:
                    log.warn("The get_op_compile_unique_key api param %s, must be (dict, (dict, ...))", name)
            new_params.append(new_param_inner)
        else:
            log.warn("The get_op_compile_unique_key api param %s,"
                     " must be (dict, dict,...) or (dict, (dict, ...))", name)
            return []
    return new_params


def _get_new_attrs(attrs):
    new_attrs = []
    mandatory_attrs = []
    last_mandatory_idx = -1  # mandatory attrs doesn't exist.
    first_optional_idx = len(attrs)  # optional attrs doesn't exist.
    # attrs must be list or tuple.
    for idx, attr in enumerate(attrs):
        # attr must be dict, need sort attr.
        if isinstance(attr, dict):
            new_attr = _sort_unique_key_params(attr)
            is_default_value = attr.get("is_default_value")
            new_attr.pop("is_default_value", "The is_default_value key doesn't exist in the attr.")
            if is_default_value:
                first_optional_idx = idx if idx < first_optional_idx else first_optional_idx
            else:
                mandatory_attrs.append(new_attr)
                last_mandatory_idx = idx
            new_attrs.append(new_attr)
        else:
            log.warn("The get_op_compile_unique_key api param attrs, must be (dict, dict,...)")

    return [new_attrs, mandatory_attrs, last_mandatory_idx, first_optional_idx]


def _get_new_extra_params(extra_params):
    new_extra_params = {}
    # extra_params must be dict, need sort the extra_params.
    for k in sorted(extra_params.keys()):
        v = extra_params.get(k)
        if isinstance(v, dict):
            new_v = _sort_unique_key_params(v)
            new_extra_params[k] = new_v
        else:
            new_extra_params[k] = v
    return new_extra_params


def _create_result(op_type, op_compile_params, is_sha):
    log.debug("kb_query_key_params_str: %s:%s", op_type, str(op_compile_params))
    if is_sha:
        # json dumps
        op_compile_params_json = json.dumps(op_compile_params)
        op_compile_params_json_sha = hashlib.sha256(op_compile_params_json.encode("utf-8")).hexdigest()
        kb_query_key_json = "%s_%s" % (op_type, op_compile_params_json_sha)
        # string
        op_compile_params_str = str(op_compile_params).replace("'", "\"")
        op_compile_params_str_sha = hashlib.sha256(op_compile_params_str.encode("utf-8")).hexdigest()
        kb_query_key_str = "%s_%s" % (op_type, op_compile_params_str_sha)
    else:
        op_compile_params["op_type"] = op_type
        kb_query_key_json = json.dumps(op_compile_params)
        kb_query_key_str = str(op_compile_params).replace("'", "\"")
    return kb_query_key_json, kb_query_key_str


def _get_all_possible_attrs(attrs):
    if not attrs:
        return [None]
    _check_unique_key_params("attrs", attrs)
    all_attrs, mandatory_attrs, last_mandatory_idx, first_optional_idx = _get_new_attrs(attrs)
    # Only mandatory attrs
    all_possible_attrs = [mandatory_attrs]
    # First attr to last mandatory attr.
    if first_optional_idx < last_mandatory_idx:
        all_possible_attrs.append(all_attrs[:last_mandatory_idx + 1])
    # Accumulate all the last optional attrs.
    if last_mandatory_idx + 1 < len(all_attrs):
        optional_attrs = all_attrs[last_mandatory_idx + 1:]
        for idx in range(len(optional_attrs)):
            all_possible_attrs.append(mandatory_attrs + optional_attrs[:idx+1])
    return all_possible_attrs


def get_op_compile_unique_key(op_type, inputs, outputs, attrs, extra_params, is_sha=True, add_field=False):
    """
    get_op_compile_unique_key
    """
    if isinstance(op_type, str):
        op_type = op_type.lower()
    else:
        raise RuntimeError("The get_op_compile_unique_key api param op_type must be str, but get %s" % type(op_type))

    op_compile_params = {}
    if inputs:
        _check_unique_key_params("inputs", inputs)
        op_compile_params["inputs"] = _get_new_inputs_outputs("inputs", inputs, add_field)
    if outputs:
        _check_unique_key_params("outputs", outputs)
        op_compile_params["outputs"] = _get_new_inputs_outputs("outputs", outputs, add_field)

    all_possible_attrs = _get_all_possible_attrs(attrs)

    results_json, results_str = [], []
    for possible_attrs in all_possible_attrs:
        if possible_attrs:
            op_compile_params.pop("op_type", "Ensure that attrs is before the op_type.")
            op_compile_params.pop("extra_params", "Ensure that attrs is before the extra_params.")
            op_compile_params["attrs"] = possible_attrs
        if extra_params and isinstance(extra_params, dict):
            op_compile_params["extra_params"] = _get_new_extra_params(extra_params)

        key_json, key_str = _create_result(op_type, op_compile_params, is_sha)
        results_json.append(key_json)
        results_str.append(key_str)
    results = results_json + results_str
    return results
