#!/usr/bin/env python
# coding: utf-8
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
register the cce buffer info
"""
from __future__ import absolute_import as _abs

import tbe.common.platform as cce_conf
from tbe.common.platform import get_soc_spec
from tbe.common.platform import set_current_compile_soc_info
import tbe.tvm as tvm

# Example: pylint: disable=invalid-name
# add default product, default value is Ascend310
# get the CceProductParams instance
cur_cce_product_params = set_current_compile_soc_info("Ascend310")


def is_v310_version():
    """
    check if soc version is arch v310
    ----------

    Returns
    -------
    True:  Ascend610Lite, BS9SX2A, MC61AM21A version
    False: Other version
    """
    short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
    if short_soc_version in ("Ascend610Lite", "BS9SX2A", "MC61AM21A"):
        return True
    return False


@tvm.register_func("te.cce.cur_buf_params")
def cur_product_params(name):
    """ api for c++ pass to get current product params"""
    ret = cur_cce_product_params.getParams(name)
    return tvm.const(ret, 'int32')


# The memory information for the compiler
# ub 32B aligned, L1 32B aligned, L0 2*16^2B aligned
L1_UNIT_BITS = 2 * 16 * 8
L1_MAX_SIMD_BITS = 2 * 16 * 8


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_cbuf)
def mem_info_l1_buffer():
    """
    make node info L1 buffer
    """
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=L1_UNIT_BITS,
                            max_simd_bits=L1_MAX_SIMD_BITS,
                            max_num_bits=get_soc_spec(cce_conf.L1_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_cbuf_fusion)
def mem_info_l1_fusion_buffer():
    """
    make node info L1 buffer
    """
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=L1_UNIT_BITS,
                            max_simd_bits=L1_MAX_SIMD_BITS,
                            max_num_bits=get_soc_spec(cce_conf.L1_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))

@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_ubuf_fusion)
def mem_info_ub_fusion_buffer():
    """
    make node info ub_fusion buffer
    """
    UB_UNIT_BITS = 16 * 8
    UB_MAX_SIMD_BITS = 16 * 8
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=UB_UNIT_BITS,
                            max_simd_bits=UB_MAX_SIMD_BITS,
                            max_num_bits=get_soc_spec(cce_conf.UB_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))

def get_platform_info():
    version = get_soc_spec("SHORT_SOC_VERSION")
    UB_UNIT_BITS = 32 * 8
    UB_MAX_SIMD_BITS = 32 * 8
    if (version == "Ascend035" or version == "Ascend035A" or version == "Ascend035B"):
        UB_UNIT_BITS = 16 * 8
        UB_MAX_SIMD_BITS = 16 * 8
        return [UB_UNIT_BITS, UB_MAX_SIMD_BITS]
    return [UB_UNIT_BITS, UB_MAX_SIMD_BITS]


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_ubuf)
def mem_info_ub_buffer():
    """
    make node info UB buffer
    """
    UB_UNIT_BITS = get_platform_info()[0]
    UB_MAX_SIMD_BITS = get_platform_info()[1]
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=UB_UNIT_BITS,
                            max_simd_bits=UB_MAX_SIMD_BITS,
                            max_num_bits=get_soc_spec(cce_conf.UB_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


# The memory information for the compiler
# smask 32B aligned
SMASK_UNIT_BITS = 32 * 8
SMASK_MAX_SIMD_BITS = 32 * 8


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_smask)
def mem_info_smask_buffer():
    """
    make node info SMASK buffer
    """
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=SMASK_UNIT_BITS,
                            max_simd_bits=SMASK_MAX_SIMD_BITS,
                            max_num_bits=get_soc_spec(cce_conf.SMASK_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


# The memory information for the FIXPIPE BUFFER
FB_ADDR_ALIGN_UNIT_V310 = 64
FB_ADDR_ALIGN_UNIT_PRE_V310 = 128
FB_UNIT_BITS = lambda align_unit: align_unit * 8
FB_MAX_SIMD_BITS = lambda align_unit: align_unit * 8


def get_mem_info_fb_buffer_align_unit():
    """
    get fixpipe buffer alignment unit based on platform
    """
    return FB_ADDR_ALIGN_UNIT_V310 if is_v310_version() else FB_ADDR_ALIGN_UNIT_PRE_V310


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_fb)
def mem_info_fb_buffer():
    """
    make node info FB buffer, total size of FB0 ~ FB3
    """
    fb_addr_align_unit = get_mem_info_fb_buffer_align_unit()
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=FB_UNIT_BITS(fb_addr_align_unit),
                            max_simd_bits=FB_MAX_SIMD_BITS(fb_addr_align_unit),
                            max_num_bits=get_soc_spec(cce_conf.FB_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_fb0)
def mem_info_fb0_buffer():
    """
    make node info FB0 buffer
    """
    fb_addr_align_unit = get_mem_info_fb_buffer_align_unit()
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=FB_UNIT_BITS(fb_addr_align_unit),
                            max_simd_bits=FB_MAX_SIMD_BITS(fb_addr_align_unit),
                            max_num_bits=get_soc_spec(cce_conf.FB0_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_fb1)
def mem_info_fb1_buffer():
    """
    make node info FB1 buffer
    """
    fb_addr_align_unit = get_mem_info_fb_buffer_align_unit()
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=FB_UNIT_BITS(fb_addr_align_unit),
                            max_simd_bits=FB_MAX_SIMD_BITS(fb_addr_align_unit),
                            max_num_bits=get_soc_spec(cce_conf.FB1_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_fb2)
def mem_info_fb2_buffer():
    """
    make node info FB2 buffer
    """
    fb_addr_align_unit = get_mem_info_fb_buffer_align_unit()
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=FB_UNIT_BITS(fb_addr_align_unit),
                            max_simd_bits=FB_MAX_SIMD_BITS(fb_addr_align_unit),
                            max_num_bits=get_soc_spec(cce_conf.FB2_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_fb3)
def mem_info_fb3_buffer():
    """
    make node info FB3 buffer
    """
    fb_addr_align_unit = get_mem_info_fb_buffer_align_unit()
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=FB_UNIT_BITS(fb_addr_align_unit),
                            max_simd_bits=FB_MAX_SIMD_BITS(fb_addr_align_unit),
                            max_num_bits=get_soc_spec(cce_conf.FB3_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


# The memory information for the Bias Table Buffer
BT_ADDR_ALIGN_UNIT_V310 = 32
BT_ADDR_ALIGN_UNIT_PRE_V310 = 64
BT_UNIT_BITS = lambda align_unit: align_unit * 8
BT_MAX_SIMD_BITS = lambda align_unit: align_unit * 8


def get_mem_info_bt_buffer_align_unit():
    """
    get bias table buffer alignment unit based on platform
    """
    return BT_ADDR_ALIGN_UNIT_V310 if is_v310_version() else BT_ADDR_ALIGN_UNIT_PRE_V310


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_bt)
def mem_info_bt_buffer():
    """
    make node info BT buffer
    """
    bt_addr_align_unit = get_mem_info_bt_buffer_align_unit()
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=BT_UNIT_BITS(bt_addr_align_unit),
                            max_simd_bits=BT_MAX_SIMD_BITS(bt_addr_align_unit),
                            max_num_bits=get_soc_spec(cce_conf.BT_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


L0A_UNIT_BITS = 2 * 16 * 16 * 8
L0A_MAX_SIMD_BITS = 2 * 16 * 16 * 8


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_ca)
def mem_info_l0a_buffer():
    """
    make node info L0A buffer
    """
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=L0A_UNIT_BITS,
                            max_simd_bits=L0A_MAX_SIMD_BITS,
                            max_num_bits=get_soc_spec(cce_conf.L0A_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


L0B_UNIT_BITS = 2 * 16 * 16 * 8
L0B_MAX_SIMD_BITS = 2 * 16 * 16 * 8


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_cb)
def mem_info_l0b_buffer():
    """
    make node info L0B buffer
    """
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=L0B_UNIT_BITS,
                            max_simd_bits=L0B_MAX_SIMD_BITS,
                            max_num_bits=get_soc_spec(cce_conf.L0B_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


L0C_UNIT_BITS = 2 * 16 * 16 * 8
L0C_MAX_SIMD_BITS = 2 * 16 * 16 * 8


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_cc)
def mem_info_l0c_buffer():
    """
    make node info L0C buffer
    """
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=L0C_UNIT_BITS,
                            max_simd_bits=L0C_MAX_SIMD_BITS,
                            max_num_bits=get_soc_spec(cce_conf.L0C_SIZE) * 8,
                            head_address=tvm.const(0, 'int32'))


REG_UNIT_BITS = 16
REG_MAX_SIMD_BITS = 64
REG_MAX_NUM_BITS = 64 * 3200


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_reg)
def mem_info_reg_buffer():
    """
    make node info Reg buffer
    """
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=REG_UNIT_BITS,
                            max_simd_bits=REG_MAX_SIMD_BITS,
                            max_num_bits=REG_MAX_NUM_BITS,
                            head_address=tvm.const(0, 'int32'))


AICPU_UNIT_BITS = 16
AICPU_MAX_SIMD_BITS = 64
AICPU_MAX_NUM_BITS = 16 * 1024 * 1024  # AICPU stack memory limit is 2M


@tvm.register_func("tvm.info.mem.%s" % cce_conf.scope_aicpu)
def mem_info_ai_cpu():
    """
    make node info Ai_CPU
    """
    return tvm.ir.make_node("MemoryInfo",
                            unit_bits=AICPU_UNIT_BITS,
                            max_simd_bits=AICPU_MAX_SIMD_BITS,
                            max_num_bits=AICPU_MAX_NUM_BITS,
                            head_address=tvm.const(0, 'int32'))
