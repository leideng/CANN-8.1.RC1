#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     run_model.py
DESC:     run ops, camodel, pvmodel
CREATED:  2019-10-22 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""

import os
from ctypes import cdll
from ctypes import c_uint64
from ctypes import c_uint32
from ctypes import c_void_p
from ctypes import c_char_p
from ctypes import c_int64
from ctypes import c_double
from ctypes import c_bool
import collections
import numpy as np

from tbe.common.testing.analysis_printf_data import DTYPE_SIZE
from tbe.common.testing.analysis_printf_data import print_analysis_value
from tbe.common.testing.analysis_printf_data import try_mkdir

DTYPE_FOR_INPUT_SCALAR = {"uint8": 0, "int8": 1, "uint16": 2, "int16": 3, "uint32": 4,
                          "int32": 5, "uint64": 6,
                          "int64": 7, "float16": 8, "float32": 9}

IS_RUN_OPS = 0
IS_CAMODEL = 1
IS_PVMODEL = 2

IS_TENSOR = 0
IS_INPUTSCALAR = 1
IS_TENSOR_ADDR_LIST = 2
IS_TENSOR_ADDR = 3
IS_FT_TENSOR = 4
IS_FT_SCALAR = 5
IS_DESC_TENSOR = 6

# too many arguments, too many statements
_MAX_INPUT_OUTPUT_NUM = 64

IOListApi = collections.namedtuple('IOListApi', ['feed_data_array', 'feed_data_nbytes_array',
                                                 'output_data_nbytes_array', 'output_data_to_c',
                                                 'output_value_array'])
ScalarListApi = collections.namedtuple("ScalarListApi", ["scalar_value_array_uint64", "scalar_value_array_int64",
                                                         "scalar_value_array_double", "scalar_dtype_number_list"])


class RunModel():
    """
    Represents .
    """

    def __init__(self, kernel_name, config=None):
        """
        init RunTesting
        :param kernel_name: which .o file name
        """
        self.dll = None
        self.kernel_path = None
        self.simulatorlog_abs_path = None
        self.is_vector_core = False
        self.is_mix_core = False
        self.feed_data = []
        self.feed_data_type_list = []
        self.scalar_dtype_list = []
        self.scalar_value_list = []
        self.flowtable_scalar_dtype_list = []
        self.flowtable_scalar_value = []
        self.flowtable_tensor_data = []
        self.output_spec = []
        self.output_need_init_list = []
        self.need_dump_print_wksp = False
        self.print_wksp_index = 0
        self.is_printf_to_screen = True
        self.printf_file_path = None
        self.enable_l2 = False

        self.kernel_name = kernel_name
        if config is None:
            config = {}
        self.analysis_config_path(config)
        self.analysis_config_core_type(config)
        self.analysis_config_printf(config)
        self.analysis_config_output_need_init(config)

    def execute(self, mode, input_args, output_args):
        """
        send inputNum, outputNum, input data to execute
        :param mode: will set whether profiling or not
        :param input_args: input type, data
        :param output_args: output dtype, size, shape
        :return: output value array
        """

        self.analysis_inputs(input_args)
        self.analysis_outputs(output_args)
        if (len(input_args) > _MAX_INPUT_OUTPUT_NUM) or (len(output_args) > _MAX_INPUT_OUTPUT_NUM):
            raise RuntimeError("Input and output num should either less than 64!")

        self.load_dll(mode)
        self.save_build_bin_path()
        self.save_enable_l2()
        self.save_tensor_var_list()
        self.save_input_scalar_value()
        self.save_output_need_init_list()
        self.save_ft_value()
        self.save_ft_tensor()
        self.save_dump_print_info()
        self.save_core_type_info()

        io_list = _gen_input_output_list(self.feed_data, self.output_spec)

        _two_num_uint_array = c_uint32 * 2
        self.dll_func("InitAndReadAndExecute", bool,
                      [c_uint64 * len(self.feed_data),
                       c_uint64 * len(self.output_spec),
                       _two_num_uint_array,
                       c_void_p * len(self.feed_data),
                       c_void_p * len(self.output_spec)],
                      (c_uint64 * len(self.feed_data))(*io_list.feed_data_nbytes_array),
                      (c_uint64 * len(self.output_spec))(*io_list.output_data_nbytes_array),
                      _two_num_uint_array(len(self.feed_data), len(self.output_spec)),
                      (c_void_p * len(self.feed_data))(*io_list.feed_data_array),
                      (c_void_p * len(self.output_spec))(*io_list.output_data_to_c))

        if not io_list.output_value_array:
            raise RuntimeError("Failed to run model!")
        if mode in (IS_RUN_OPS, IS_CAMODEL) and self.need_dump_print_wksp:
            print_analysis_value(self.kernel_name, self.is_printf_to_screen, self.printf_file_path)
        return io_list.output_value_array

    def load_dll(self, mode):
        """
        load dll
        :param mode:0 run_ops, 1 camodel, 2 pvmodel
        :return:
        """
        if mode == IS_RUN_OPS:
            self.dll = cdll.LoadLibrary('libtik_run_ops.so')
        elif mode == IS_CAMODEL:
            self.dll = cdll.LoadLibrary('libtik_profiling.so')
        elif mode == IS_PVMODEL:
            self.dll = cdll.LoadLibrary('libtik_run_pvmodel.so')
        else:
            raise RuntimeError("mode should be in {0, 1, 2}")

    def analysis_inputs(self, input_args):
        """
        analysis input_args
        :param input_args:
        :return:
        """
        for input_type, data in input_args:
            if input_type == IS_TENSOR:
                self.feed_data.append(data)
                self.feed_data_type_list.append(input_type)
            elif input_type == IS_TENSOR_ADDR_LIST:
                self.feed_data.append(np.zeros(len(data), dtype=np.int64))
                self.feed_data_type_list.append(input_type)
                for tensor_addr in data:
                    self.feed_data.append(tensor_addr)
                    self.feed_data_type_list.append(IS_TENSOR_ADDR)
            elif input_type == IS_FT_TENSOR:
                self.flowtable_tensor_data.append(data)
            elif input_type == IS_DESC_TENSOR:
                # for description Tensor, first element is GM Tensor Addr, others is Gm Tensor info,
                # for example, shape, dtype, dims
                if len(data) != 2:
                    raise RuntimeError("when feed_dict's key in desc_tensor, it's value's data len must be 2")
                self.feed_data.append(data[0])
                self.feed_data_type_list.append(input_type)
                self.feed_data.append(data[1])
                self.feed_data_type_list.append(IS_TENSOR_ADDR)
            elif input_type == IS_FT_SCALAR:
                self.flowtable_scalar_dtype_list.append(data.dtype)
                self.flowtable_scalar_value.append(data)
            else:
                self.scalar_dtype_list.append(data.dtype)
                self.scalar_value_list.append(data[0])

    def analysis_outputs(self, output_args):
        """
        analysis output_args
        :param output_args:
        :return:
        """
        for shape, dtype in output_args:
            size = np.multiply.reduce(shape) * DTYPE_SIZE[dtype]
            self.output_spec.append({"size": size, "shape": shape, "dtype": dtype})
        if len(self.output_need_init_list) == 0:
            self.output_need_init_list = [0] * len(output_args)
        elif len(self.output_need_init_list) != len(output_args):
            raise RuntimeError("output_args length is not equal to output_need_init_list length!")

    def analysis_config_path(self, config):
        """
        analysis config param
        :param config:
        :return:
        """
        if config.get("kernel_path") is not None:
            self.kernel_path = config.get("kernel_path")
        else:
            self.kernel_path = 'kernel_meta'
        if config.get("simulatorlog_path") is not None:
            self.simulatorlog_abs_path = os.path.join(os.path.realpath(config.get("simulatorlog_path")), 'simulatorlog')
        else:
            self.simulatorlog_abs_path = os.path.join(os.path.realpath(self.kernel_path), 'simulatorlog')

    def analysis_config_core_type(self, config):
        """
        analysis config param
        :param config:
        :return:
        """
        if config.get("is_vector_core") is not None:
            self.is_vector_core = config.get("is_vector_core")
        if config.get("is_mix_core") is not None:
            self.is_mix_core = config.get("is_mix_core")

    def analysis_config_printf(self, config):
        """
        analysis config param
        :param config:
        :return:
        """
        if config.get("need_dump_print_wksp") is not None:
            self.need_dump_print_wksp = config.get("need_dump_print_wksp")
        if config.get("print_wksp_index") is not None:
            self.print_wksp_index = config.get("print_wksp_index")
        if config.get("is_printf_to_screen") is not None:
            self.is_printf_to_screen = config.get("is_printf_to_screen")
        if config.get("printf_file_path") is not None:
            self.printf_file_path = config.get("printf_file_path")

    def analysis_config_output_need_init(self, config):
        """
        analysis config param
        :param config:
        :return:
        """
        if config.get("output_need_init_list") is not None:
            self.output_need_init_list = config.get("output_need_init_list")

    def dll_func(self, func, restype, argtypes, *args):
        """
        load functions from dll
        :param func: function name
        :param restype: return dtype
        :param argtypes: args dtype
        :param args: args value
        :return: None
        """
        _dll_func = getattr(self.dll, func)
        _dll_func.restype = restype
        _dll_func.argtypes = argtypes
        _dll_func(*args)

    def save_tensor_var_list(self):
        """
        save input params type to CAModel
        :return: None
        """
        input_num = len(self.feed_data)
        feed_data_type_list_array = []
        for tmp_value in self.feed_data_type_list:
            feed_data_type_list_array.append((c_uint32(tmp_value)))
        feed_data_type_list_to_c = (c_uint32 * input_num)(*feed_data_type_list_array)

        self.dll_func("SaveTensorVarList", None, [c_uint32 * input_num, c_uint32],
                      feed_data_type_list_to_c, (c_uint32(input_num)))

    def save_input_scalar_value(self):
        """
        save input params scalar to CAModel
        :return: None
        """
        scalar_list = _gen_scalar_list(self.scalar_dtype_list, self.scalar_value_list)

        input_scalar_value_uint64_to_c = \
            (c_uint64 * len(scalar_list.scalar_value_array_uint64))(*scalar_list.scalar_value_array_uint64)
        input_scalar_value_int64_to_c = \
            (c_int64 * len(scalar_list.scalar_value_array_int64))(*scalar_list.scalar_value_array_int64)
        input_scalar_value_double_to_c = \
            (c_double * len(scalar_list.scalar_value_array_double))(*scalar_list.scalar_value_array_double)
        input_scalar_dtype_list_to_c = \
            (c_uint32 * len(scalar_list.scalar_dtype_number_list))(*scalar_list.scalar_dtype_number_list)

        self.dll_func("SaveInputScalarValueUint", None,
                      [c_uint64 * len(scalar_list.scalar_value_array_uint64), c_uint32],
                      input_scalar_value_uint64_to_c, (c_uint32(len(scalar_list.scalar_value_array_uint64))))

        self.dll_func("SaveInputScalarValueInt", None,
                      [c_int64 * len(scalar_list.scalar_value_array_int64), c_uint32],
                      input_scalar_value_int64_to_c, (c_uint32(len(scalar_list.scalar_value_array_int64))))

        self.dll_func("SaveInputScalarValueDouble", None,
                      [c_double * len(scalar_list.scalar_value_array_double), c_uint32],
                      input_scalar_value_double_to_c, (c_uint32(len(scalar_list.scalar_value_array_double))))

        self.dll_func("SaveInputScalarValue", None,
                      [c_uint32 * len(scalar_list.scalar_dtype_number_list), c_uint32],
                      input_scalar_dtype_list_to_c, (c_uint32(len(scalar_list.scalar_dtype_number_list))))

    def save_ft_value(self):
        """
        save input params flowtable scalar to CAModel
        :return: None
        """
        scalar_list = _gen_scalar_list(self.flowtable_scalar_dtype_list, self.flowtable_scalar_value)

        ft_value_uint64_to_c = (c_uint64 * len(scalar_list.scalar_value_array_uint64))(
            *scalar_list.scalar_value_array_uint64)
        ft_value_int64_to_c = (c_int64 * len(scalar_list.scalar_value_array_int64))(
            *scalar_list.scalar_value_array_int64)
        ft_value_double_to_c = (c_double * len(scalar_list.scalar_value_array_double))(
            *scalar_list.scalar_value_array_double)
        ft_dtype_list_to_c = (c_uint32 * len(self.flowtable_scalar_dtype_list))(
            *scalar_list.scalar_dtype_number_list)

        self.dll_func("SaveFtValueUint", None,
                      [c_uint64 * len(scalar_list.scalar_value_array_uint64), c_uint32],
                      ft_value_uint64_to_c, (c_uint32(len(scalar_list.scalar_value_array_uint64))))

        self.dll_func("SaveFtValueInt", None,
                      [c_int64 * len(scalar_list.scalar_value_array_int64), c_uint32],
                      ft_value_int64_to_c, (c_uint32(len(scalar_list.scalar_value_array_int64))))

        self.dll_func("SaveFtValueDouble", None,
                      [c_double * len(scalar_list.scalar_value_array_double), c_uint32],
                      ft_value_double_to_c, (c_uint32(len(scalar_list.scalar_value_array_double))))

        self.dll_func("SaveFtValue", None,
                      [c_uint32 * len(scalar_list.scalar_dtype_number_list), c_uint32],
                      ft_dtype_list_to_c, (c_uint32(len(scalar_list.scalar_dtype_number_list))))

    def save_output_need_init_list(self):
        """
        save whether each output need to init, for atomic_add
        :return: None
        """
        output_num = len(self.output_spec)
        output_init_to_c = (c_uint32 * output_num)(*self.output_need_init_list)
        self.dll_func("SaveOutputNeedInitList", None, [c_uint32 * output_num, c_uint32],
                      output_init_to_c, (c_uint32(output_num)))

    def save_enable_l2(self):
        """
        save enable l2 to CAModel
        :return: None
        """
        self.dll_func("SaveEnableL2", None, [c_bool], c_bool(self.enable_l2))

    def save_ft_tensor(self):
        """
        save flowtable tensor to CAModel
        :return: None
        """
        ft_tensor_num = len(self.flowtable_tensor_data)
        flowtable_nbytes_array = []
        flowtable_data_array = []
        for tmp_feed_data in self.flowtable_tensor_data:
            flowtable_nbytes_array.append(c_uint64(np.ascontiguousarray(tmp_feed_data).nbytes))
            flowtable_data_array.append(c_void_p(np.ascontiguousarray(tmp_feed_data).ctypes.data))
        flowtable_data_bytes_array = (c_uint64 * ft_tensor_num)(*flowtable_nbytes_array)
        flowtable_data_array_to_c = (c_void_p * ft_tensor_num)(*flowtable_data_array)

        self.dll_func("SaveFlowTableTensor", None,
                      [c_uint32, c_uint64 * ft_tensor_num, c_void_p * ft_tensor_num],
                      ft_tensor_num, flowtable_data_bytes_array, flowtable_data_array_to_c)

    def save_dump_print_info(self):
        """
        save dump print info to CAModel
        :return: None
        """
        self.dll_func("SaveDumpPrintInfo", None, [c_bool, c_uint32],
                      c_bool(self.need_dump_print_wksp), c_uint32(self.print_wksp_index))

    def save_core_type_info(self):
        """
        save core type info to CAModel
        :return: None
        """
        self.dll_func("SaveCoreTypeInfo", None, [c_bool, c_bool],
                      c_bool(self.is_vector_core), c_bool(self.is_mix_core))

    def save_build_bin_path(self):
        """
        save build bin path
        :return: None
        """
        try_mkdir(self.simulatorlog_abs_path)
        os.environ["CAMODEL_LOG_PATH"] = self.simulatorlog_abs_path
        absolute_kernel_path = os.path.join(os.path.realpath(self.kernel_path), self.kernel_name)
        self.dll_func("BuildBinPath", None, [c_char_p],
                      c_char_p(bytes(absolute_kernel_path, encoding="utf-8")))


def _gen_scalar_list(scalar_dtype_list, scalar_value_list):
    """
    generate each value for scalar
    :param feed_data: save scalar dtype list
    :param feed_data_type_list: save scalar value list
    :return:
    """
    scalar_value_array_uint64 = []
    scalar_value_array_int64 = []
    scalar_value_array_double = []
    scalar_dtype_number_list = []
    for scalar_dtype_np, scalar_value in zip(scalar_dtype_list, scalar_value_list):
        scalar_dtype = scalar_dtype_np.name
        if scalar_dtype.startswith("uint"):
            scalar_value_array_uint64.append(c_uint64(scalar_value.reshape(-1)[0]))
        elif scalar_dtype.startswith("int"):
            scalar_value_array_int64.append(c_int64(scalar_value.reshape(-1)[0]))
        elif scalar_dtype.startswith("float"):
            scalar_value_array_double.append(c_double(scalar_value.reshape(-1)[0]))
        scalar_dtype_number_list.append(c_uint32(DTYPE_FOR_INPUT_SCALAR.get(scalar_dtype)))
    return ScalarListApi(scalar_value_array_uint64, scalar_value_array_int64,
                         scalar_value_array_double, scalar_dtype_number_list)


def _gen_input_output_list(feed_data, output_spec):
    """
    generate each value for scalar
    :param feed_data: save scalar dtype list
    :param output_spec: output data type,size,shape
    :return:
    """
    feed_data_array = []
    feed_data_nbytes_array = []
    output_data_nbytes_array = []
    output_data_to_c = []
    output_value_array = []

    for tmp_feed_data in feed_data:
        feed_data_array.append(c_void_p(np.ascontiguousarray(tmp_feed_data).ctypes.data))
        feed_data_nbytes_array.append(c_uint64(np.ascontiguousarray(tmp_feed_data).nbytes))
    for tmp_output_data in output_spec:
        output_data_nbytes_array.append(c_uint64(tmp_output_data.get("size")))
        dtype = tmp_output_data['dtype']
        # numpy cannot recognize "bfloat16", use tf.bfloat16.as_numpy_dtype so that numpy can understand
        if str(tmp_output_data['dtype']) == "bfloat16":
            import tensorflow as tf
            dtype = tf.bfloat16.as_numpy_dtype
        output_data_zero = np.zeros(tmp_output_data['shape'], dtype=dtype)
        output_value_array.append(output_data_zero)
        output_data_to_c.append(c_void_p(output_data_zero.ctypes.data))

    return IOListApi(feed_data_array, feed_data_nbytes_array,
                     output_data_nbytes_array, output_data_to_c, output_value_array)


def run_model(kernel_name, mode, input_args, output_args, config=None):
    """
    run op, run op with camodel pvmodel
    :param kernel_name: which .o file name
    :param mode: 0 run op, 1 camodel, 2 pvmodel
    :param input_args: inputs data
    :param output_args: outputs information
    :param config: config dict
    :return: outputs data
    """
    testing = RunModel(kernel_name, config)
    return testing.execute(mode, input_args, output_args)
