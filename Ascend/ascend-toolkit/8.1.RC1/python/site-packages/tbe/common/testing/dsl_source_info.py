#!/usr/bin/env python
# coding: utf-8
"""
Copyright (R) @huawei.com, all rights reserved
-*- coding:utf-8 -*-
FILE:     dsl_source_info.py
DESC:     handle source information
"""
# disabling:
# `W0212: protected-access`
import inspect
import sys
import copy
from functools import wraps
import threading
import linecache
import os

SOURCE_INFO = threading.local()
SOURCE_INFO.api_source_info = None


def source_info_decorator(depth=1):
    """bind this decorator with func that need register source info

    Parameters
    ----------
    depth : stack depth

    Returns
    -------
    function
    """

    def get_source_info_decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            """bind this decorator with func that need register source info"""
            DslSourceInfo.register_source_info(depth)
            f_return = func(*args, **kwargs)
            return f_return

        return wrapper

    return get_source_info_decorator


def get_span_info():
    """get location corresponding to node"""
    file_name = "Unknown"
    line_co = 0
    if not hasattr(SOURCE_INFO, "api_source_info"):
        SOURCE_INFO.api_source_info = None
    if SOURCE_INFO.api_source_info is None:
        msg = '''location is invalid, please check!!!\n
                "There are two reasons for the error:\n"
                "If it is an open interface, please "
                "register source at the beginning;\n"
                "If it is an unopened interface,"
                " please correct this mistake;'''
        get_error_dict_args(msg, None)
        return file_name, line_co
    file_name = str(SOURCE_INFO.api_source_info[0].get("filename"))
    line_co = str(SOURCE_INFO.api_source_info[0].get("line_no"))
    return file_name, line_co


def get_frame_info(frame):
    """get particular information from stack frame

    Parameters
    ----------
    frame : frame object from the call stack
    """
    filename = frame.f_code.co_filename
    return {"filename": filename, "line_no": frame.f_lineno,
            "function": frame.f_code.co_name,
            "sym_table": copy.copy(frame.f_locals)}


def stack(depth=0):
    """get stack information after depth

    Parameters
    ----------
    depth : stack depth

    Return
    ----------
    list of frame info
    """
    frame = sys._getframe(depth + 1)  # 'pylint: disable=W0212
    frame_list = []
    while frame:
        frame_list.append(get_frame_info(frame))
        frame = frame.f_back
    return frame_list


def most_recent_traceback():
    """get system's exc info that contains type, exception, traceback"""
    trace = sys.exc_info()[2]
    trace_list = []
    while trace:
        trace_list.append({"filename": trace.tb_frame.f_code.co_filename,
                           "line_no": trace.tb_lineno,
                           "function": trace.tb_frame.f_code.co_name})
        trace = trace.tb_next
    trace_list.reverse()
    return trace_list


def current_frame(depth=0):
    """get current frame information

    Parameters
    ----------
    depth : stack depth

    Return
    ----------
    current frame information
    """
    return [get_frame_info(sys._getframe(depth + 1))]  # 'pylint: disable=W0212


def canonic(filename):
    """to canonic file path"""
    if filename is None:
        return ''

    if filename == ("<" + filename[1:-1] + ">"):
        return filename
    canonic_ = os.path.realpath(filename)
    canonic_ = os.path.normcase(canonic_)
    return canonic_


def read_context_from_file(filename, line_no, context_len=7):
    """read code and context according to file path

    Parameters
    ----------
    filename : file absolutely path
    line_no : line number corresponding to code
    context_len : code context len

    Returns
    -------
    code and context
    """
    start_lineno = line_no - context_len // 2
    start_lineno = max(start_lineno, 1)
    print_lines = []
    for i in range(context_len):
        code = linecache.getline(filename, start_lineno + i)
        if code == "":
            break
        print_lines.append(repr(i + start_lineno).rjust(3))
        if start_lineno + i == line_no:
            print_lines.append(' -> ')
        else:
            print_lines.append('    ')
        print_lines.append(code)
    return ''.join(print_lines).rstrip() + "\n"


def get_traceback_inspect_msg():
    """get code_context and traceback msg list according to stack

    Returns:
    -------
    code_context and traceback msg list
    """
    # Return a list of records for the stack above the caller's frame.
    inspect_stack = inspect.stack()[1:]
    source_file = inspect_stack[0][1]
    line_no = inspect_stack[0][2]
    msg_list = [[source_file, line_no], ["Traceback:"]]

    for info in inspect_stack:
        if len(info) < 4:
            raise Exception('len(info)<4,len(info)=: {}'.format(len(info)))
        msg_list[1].append("  File {}, line {}, in {}\n {}\n".format(
            canonic(info[1]), info[2], info[3],
            linecache.getline(info[1], info[2]).rstrip("\n")))

    # finally, change Traceback list to string.
    msg_list[1] = "\n".join(msg_list[1]).replace("\n\n", "\n")
    return msg_list


def get_context_msg(span, msg=None):
    """get context msg list contains error, file path and code context

    Parameters
    ----------
    source_file : file absolutely path
    line_no : line number corresponding to code
    msg : error msg

    Returns
    -------
    context msg list
    """
    msg_list = []
    msg_list += ["File path: {}, line {}".format(canonic(span.source_name.name), int(span.line)),
                 "The context code cause the exception is:",
                 read_context_from_file(span.source_name.name, int(span.line))]
    msg = ["FrontEnd Traceback(most recent call last):"]
    msg_list += msg
    source_file = span.source_name.name
    line_no = int(span.line)
    msg_list += ['    File "{}", line {}, in \n\t->  {}'.format(
        canonic(source_file), line_no, linecache.getline(source_file, line_no).strip())]
    msg_list += ["==============================================================================\n"]
    msg_list.insert(0, "An error happens.")
    return msg_list


def get_error_dict_args(msg, loc):
    """get runtime error dict"""
    error_context = ""
    if loc is not None:
        error_context = "\n".join(get_context_msg(loc, msg))
    return error_context


def clear_dsl_source_info():
    """clear DSL_ERROR_MSG"""
    SOURCE_INFO.api_source_info = None


class DslSourceInfo():
    """
    handle dsl api source information
    """

    def __init__(self):
        SOURCE_INFO.api_source_info = None

    @staticmethod
    def register_source_info(depth=1, source_info=None):
        """register source information

        Parameters
        ----------
        depth : stack depth
        source_info : source information

        Returns
        -------
        None
        """
        if not hasattr(SOURCE_INFO, "api_source_info"):
            SOURCE_INFO.api_source_info = None
        if SOURCE_INFO.api_source_info is not None:
            msg = "please clear source info before register, previous info:" \
                  " \n{}".format(SOURCE_INFO.api_source_info[0])
            get_error_dict_args(msg, None)
        # set debug module info or for_range/if_scope/else_scope
        if source_info is not None:
            SOURCE_INFO.api_source_info = source_info
            return
        depth += 1
        SOURCE_INFO.api_source_info = stack(depth)

    @staticmethod
    def clear_source_info():
        """clear source information"""
        SOURCE_INFO.api_source_info = None

    @staticmethod
    def get_source_info():
        """get source information"""
        if not hasattr(SOURCE_INFO, "api_source_info"):
            SOURCE_INFO.api_source_info = None
        return SOURCE_INFO.api_source_info

    @staticmethod
    def end_and_clear():
        """when dsl end, clear DSL_ERROR_MSG"""
        clear_dsl_source_info()
