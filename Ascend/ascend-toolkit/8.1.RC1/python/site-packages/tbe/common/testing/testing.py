#!/usr/bin/env python
# coding: utf-8
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
tbe testing for tbe DSL testing on CPU, Model, Board
"""
import numpy as np
import _warnings
from tbe import tvm
RUN_MODES = ["ascend_onboard", "ascend_performance_model", "ascend_precision_model", "cpu"]

def _print_line(length=60):
    print("-" * length)


def is_debug_mode():
    return _Testing.is_debug_mode()


def get_ctx():
    return tvm.cpu(0)


def print_tensor(tensor, ofile=None):
    _Testing.print(tensor, ofile)


# 'pylint: disable=dangerous-default-value
def assert_allclose(tensor=None, desired=None, tol=[1e-7, 1e-7]):
    _Testing.assert_allclose(tensor, desired, tol)


def build(inputs,
          args=None,
          name="default_function"):
    _Testing.build(inputs,
                   args=args,
                   target="c",
                   target_host="llvm",
                   name=name,
                   tiling_keys=None,
                   binds=None,
                   evaluates=None)


def run(*args):
    _Testing.run(*args)


def _check_schedule_type(sch):
    if not isinstance(sch, (list, tuple, tvm.schedule.Schedule)):
        raise TypeError("schedule should be a list or a tuple or a schedule.\n")


class _Testing:
    target = None
    print_tensor = []
    print_tensor_file = []
    assert_map = {}  # Tensor: desired, tol, actual
    build_input = []  # Tensors
    build_input_actual = []  # nd arrays
    output_tensor_ind = {}
    input_tensor_ind = {}
    func = None
    is_debug = False
    schedules = None
    name = None

    @classmethod
    def is_debug_mode(cls):
        return cls.is_debug

    @classmethod
    def print(cls, tensor, ofile=None):
        if cls.target != RUN_MODES[3]:
            if ofile:
                _warnings.warn("ofile is not supported in Non-cpu mode")
            cls.print_tensor.append(tensor)
            return
        if ofile is None:
            if tensor in cls.print_tensor:
                cls.print_tensor_file[cls.print_tensor.index(tensor)] = None
            else:
                cls.print_tensor.append(tensor)
                cls.print_tensor_file.append(None)
        else:
            if tensor in cls.print_tensor:
                if cls.print_tensor_file[cls.print_tensor.index(tensor)] is None:
                    cls.print_tensor_file[cls.print_tensor.index(tensor)] = [ofile, ]
                else:
                    cls.print_tensor_file[cls.print_tensor.index(tensor)].append(ofile)
            else:
                cls.print_tensor.append(tensor)
                cls.print_tensor_file.append([ofile, ])

    @classmethod
    # 'pylint: disable=dangerous-default-value
    def assert_allclose(cls, tensor=None, desired=None, tol=[1e-7, 1e-7]):
        if cls.target == RUN_MODES[3]:
            cls.assert_map[tensor] = [desired, tol, None]
        else:
            _warnings.warn("assert_allclose takes effect only in cpu mode")

    @classmethod
    # 'pylint: disable=too-many-arguments
    def build(cls,
              inputs,
              args=None,
              target=None,
              target_host=None,
              name="default_function",
              tiling_keys=None,
              binds=None,
              evaluates=None):
        _check_schedule_type(inputs)
        cls.schedules = inputs
        cls.name = name
        # append all inputs in args
        for i in args:
            cls.build_input.append(i)
            if i.op.input_tensors:
                cls.output_tensor_ind[i] = args.index(i)
            else:
                cls.input_tensor_ind[i] = args.index(i)
        if cls.target == RUN_MODES[3]:
            # append all assert_map
            # 'pylint:disable=unused-argument,unused-variable
            for (k, v) in cls.assert_map.items():
                if k not in cls.build_input:
                    cls.build_input.append(k)
            # append all in print_tensor
            for i in cls.print_tensor:
                if i not in cls.build_input:
                    cls.build_input.append(i)

            cls.func = tvm.build(inputs, cls.build_input, target, target_host, name,
                                  tiling_keys, binds, evaluates)
            cls.build_input = args
        else:
            cls.build_ascend_modes(binds, evaluates, tiling_keys)

    @classmethod
    def build_ascend_modes(cls, binds, evaluates, rules):
        """
        build for mode: ascend_precision_model, ascend_performance_model and ascend_onboard
        """
        def build_mode():
            from tbe.common.buildcfg import build_config
            context.add_compile_info("global_variable_link", True)
            with build_config(enable_multicore_sync_with_atomic=True):
                tvm.build(cls.schedules, cls.build_input, "cce", None, cls.name, rules, binds,
                          evaluates)
        for tensor in cls.build_input:
            if tensor in cls.schedules.outputs and tensor not in cls.output_tensor_ind.keys():
                cls.output_tensor_ind[tensor] = cls.build_input.index(tensor)
        if cls.target == RUN_MODES[2]:
            cls.enable_trace_store()
        import tbe.common.context.op_context as op_context
        context = op_context.get_context()
        if context:
            build_mode()
            return
        with op_context.OpContext("static"):
            context = op_context.get_context()
            build_mode()

    @classmethod
    def enable_trace_store(cls):
        if isinstance(cls.schedules, list):
            for s in cls.schedules:
                for t in cls.print_tensor:
                    s[t].trace_store()
        else:
            for t in cls.print_tensor:
                cls.schedules[t].trace_store()

    @classmethod
    def append_assert_map(cls, l):
        # append all assert_map
        # 'pylint:disable=unused-argument,unused-variable
        for (k, v) in cls.assert_map.items():
            if k not in cls.build_input:
                shape = []
                for j in k.shape:
                    if isinstance(j, tvm.expr.Var):  # dynamic shape n
                        if j in cls.build_input:
                            shape.append(cls.build_input_actual[cls.build_input.index(j)])
                        else:
                            # 'pylint: disable=undefined-variable
                            from tbe.tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE
                            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, \
                                                 ("Var in shape of Tensor %s is not find! " % k.op.name))
                    else:
                        shape.append(j.value)
                cls.assert_map.get(k)[2] = tvm.nd.array(np.random.uniform(size=shape).astype(
                    k.dtype), get_ctx())
                l.append(cls.assert_map.get(k)[2])
                cls.build_input.append(k)
                cls.build_input_actual.append(cls.assert_map.get(k)[2])
            else:
                cls.assert_map.get(k)[2] = cls.build_input_actual[cls.build_input.index(k)]
        return l

    @classmethod
    def append_print_tensor(cls, l):
        if cls.target != "cpu":
            return
        for i in cls.print_tensor:
            if i not in cls.build_input:
                shape = []
                for j in i.shape:
                    if isinstance(j, tvm.expr.Var):  # dynamic shape n
                        if j in cls.build_input:
                            shape.append(cls.build_input_actual[cls.build_input.index(j)])
                        else:
                            from tbe.tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE
                            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                                 "Var in shape of Tensor %s is not find! ")
                    else:
                        shape.append(j.value)
                cls.assert_map[i] = [None, None, tbe.tvm.nd.array(np.random.uniform(
                    size=shape).astype(i.dtype), get_ctx())]
                cls.build_input.append(i)
                cls.build_input_actual.append(cls.assert_map.get(i)[2])
                l.append(cls.assert_map.get(i)[2])
            else:
                if i in cls.assert_map:
                    cls.assert_map.get(i)[2] = cls.build_input_actual[cls.build_input.index(i)]
                else:
                    cls.assert_map[i] = [None, None, cls.build_input_actual[cls.build_input.index(i)]]
        return l

    @classmethod
    def run(cls, *args):
        l = []
        # append all inputs in args
        for i in args:
            l.append(i)
            cls.build_input_actual.append(i)
        if cls.target != RUN_MODES[3]:
            result = cls.run_ascend(l)
            for i, ind in enumerate(cls.output_tensor_ind.values()):
                args[ind][:] = result[i][:]
            return
        # append all assert_map
        l = cls.append_assert_map(l)
        # append all in print_tensor
        l = cls.append_print_tensor(l)
        # Run func
        # 'pylint: disable=not-callable
        cls.func(*l)
        # debug print
        for i in cls.print_tensor:
            file = cls.print_tensor_file[cls.print_tensor.index(i)]
            if file is None:
                _print_line()
                print("print_tensor(Tensor %s):" % i.op.name)
                print("\t", cls.assert_map.get(i)[2])
            else:
                for j in file:
                    if j is not None:
                        print("Tensor %s is saved to file %s." % (i.op.name, j.name))
                        print(cls.assert_map.get(i)[2].asnumpy, file=j)

        # debug assert
        for (k, v) in cls.assert_map.items():
            msg = None
            if v[0] is not None:
                try:
                    from tbe.tvm.testing import utils
                    utils.assert_allclose(v[2].asnumpy(), v[0], v[1][0], v[1][1])
                except Exception as e:
                    msg = "\nassert_allclose(Tensor %s) is incorrect!" % k.op.name + e.args[0]
                finally:
                    if msg is not None:
                        from tbe.tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE
                        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, msg)

    @classmethod
    def run_ascend(cls, l):
        """
        Call function run_model when mode is model or onboard.
        """
        from tbe.common.utils import shape_util
        from tbe.common.testing.run_model import run_model
        target2mode = {RUN_MODES[0]: 0,
                       RUN_MODES[1]: 1,
                       RUN_MODES[2]: 2}
        feed_data = l[0:len(l) - len(cls.schedules.outputs)]
        input_args = []
        output_args = []
        for i, ele in enumerate(feed_data):
            input_arg_ = []
            if isinstance(cls.build_input[i], tvm.te.tensor.Tensor):
                input_arg_.append(0)
            else:
                input_arg_.append(1)
            input_arg_.append(ele)
            input_args.append(input_arg_)
        for out in cls.schedules.outputs:
            for ind in range(out.num_outputs):
                out_shape_ = tuple(shape_util.shape_to_list(out.output(ind).shape))
                out_arg_ = [out_shape_, out.output(ind).dtype]
                output_args.append(out_arg_)
        return run_model(cls.name, target2mode.get(cls.target), input_args, output_args)

    @classmethod
    def __init__(cls, target):
        cls.print_tensor = []
        cls.print_tensor_file = []
        cls.assert_map = {}
        cls.tol = []
        cls.build_input = []
        cls.build_input_actual = []
        cls.func = None
        cls.is_debug = False
        cls.target = target

    @classmethod
    def __enter__(cls):
        if cls.target == "cpu":
            cls.is_debug = True
        print("======================== debug enter =======================")
        return cls

    @classmethod
    # 'pylint: disable=redefined-builtin
    def __exit__(cls, type, value, traceback):
        cls.is_debug = False
        print("======================== debug exit ========================")


def debug(target="cpu"):
    """
    Create a dsl debug object.
    Parameters
    ----------
    target : String
        Four RUN_MODES to choose: cpu, ascend_precision_model, ascend_performance_model, ascend_onboard.
    """
    if target not in RUN_MODES:
        raise ValueError(f"target: {target} not in target list:"
                         f" 'cpu', 'ascend_precision_model', 'ascend_performance_model', "
                         f"'ascend_onboard'")
    return _Testing(target)
