#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     analysis_printf_data.py
DESC:     analysis workspace.data for printf
CREATED:  2019-7-04 20:12:13
MODIFIED: 2022-1-18 10:54:23
"""
import os
import errno
import copy
import numpy as np

MAGIC_WORD_FOR_CORE_HEAD = 0x6844
MAGIC_WORD_FOR_PRINT_HEAD = 0x6845
PRINT_CORE_HEAD_BYTES = 64
EACH_PRINT_HEAD_BYTES = 32
MAGIC_TL_TAG = 0x111

DISCARD_PRINT_COUNT_OFFSET = 2
FIRST_PRINT_OFFSET_OFFSET = 4
LAST_PRINT_OFFSET_OFFSET = 5
PRINT_COUNT_OFFSET = 6
EACH_CORE_BYTES_LENGTH_OFFSET = 1
SINGLE_PRINT_MAX_LENGTH_OFFSET = 3
STRING_LENGTH_OFFSET = 1
ARGS_LENGTH_OFFSET = 2

ONE_BYTE_BIT_LEN = 8
ONE_BLK_SIZE = 32

actual_dtype_for_args = {0: "uint8",
                         1: "int8",
                         2: "uint16",
                         3: "int16",
                         4: "float16",
                         5: "uint32",
                         6: "int32",
                         7: "float32",
                         8: "uint64",
                         9: "int64",
                         10: "uint8",
                         11: "int8",
                         12: "uint16",
                         13: "int16",
                         14: "float16",
                         15: "uint32",
                         16: "int32",
                         17: "float32",
                         18: "uint64",
                         19: "int64"}

DTYPE_SIZE = {
    'bool': 1,
    'uint8': 1,
    'int8': 1,
    'uint16': 2,
    'int16': 2,
    'int24': 3,
    'uint32': 4,
    'int32': 4,
    'float16': 2,
    'bfloat16': 2,
    'float32': 4,
    'int48': 6,
    'int64': 8,
    'uint64': 8,
    'float64': 8
}


def ceil_div(a_value, b_value):
    """
    ceil division
    Parameters
    ----------
    a_value :operator
    b_value :division value

    Returns
    -------
    computational results
    """
    return (a_value + b_value - 1) // b_value


def try_mkdir(path):
    """
    use to make dir
    :param path: where to mkdir
    :return: None
    """
    try:
        os.makedirs(path, 0o750)
    except OSError as os_exception:
        # ignore error if it is making existing dir
        if os_exception.errno != errno.EEXIST:
            if os_exception.errno == errno.EACCES:
                raise RuntimeError("No permission to create %s" % path) from os_exception
            if os_exception.errno == errno.ENOSPC:
                raise RuntimeError("No space left to create %s" % path) from os_exception
            # raise other all error to runtime error.
            raise RuntimeError("Failed to create %s" % path) from os_exception
    finally:
        pass


def _print_with_config(print_str, config):
    is_printf_to_screen, printf_file_handle = config
    if is_printf_to_screen:
        print(print_str, end="")
    if printf_file_handle is not None:
        print(print_str, end="", file=printf_file_handle)


def _print_value_for_fmt_remain(format_string, start_index, prev, printf_config):
    fmt_len = len(format_string)
    if prev != "":
        _print_with_config(format_string, printf_config)
        return
    if start_index >= fmt_len:
        return
    remain_format = format_string[start_index:].replace("%%", "%")
    _print_with_config(remain_format, printf_config)


def _print_value_for_printf(value, prev_str, format_str, printf_config):
    """
    print the value
    Parameters
    ----------
    value : the value it will be print
    prev_str : the string in print format string which
    not include %d and so on
    format_str : the string include %d and so on.
    context : the stack context

    Returns
    -------
    None
    """
    _print_with_config(prev_str, printf_config)
    target_str = ''
    for ele in value:
        target_str += '{} '.format(format_str % ele)
    _print_with_config(target_str[:-1], printf_config)


def _combine_str_data(format_string, data_list, args_length, printf_config):
    """
    print the prev_str
    :param format_string: format_string
    :param data_list: data_list
    :param args_length: args_length
    :param printf_file_handle: where to put printf text
    :return: None
    """
    format_str = ''
    prev_str = ""
    format_contrl = False
    arg_index = 0

    if args_length > len(data_list):
        # we will add warning at head.
        warning_head = "warning: discard {}".format(str(args_length - len(data_list))) + " args,"
        format_string = warning_head + format_string
    for i, _ in enumerate(format_string):
        character = format_string[i]
        if character != "%" and format_contrl is False:
            prev_str = prev_str + character
        elif format_contrl is True:
            ret_str = _get_prev_str(character, format_string, (i, arg_index),
                                    (data_list, format_str, prev_str, format_contrl), printf_config)
            if ret_str is None:
                return
            format_str, prev_str, format_contrl, arg_index = ret_str
            if character == '%':
                prev_str = prev_str + character
                format_contrl = False
                continue
        elif character == "%":
            format_contrl = True
            format_str = ''
    _print_with_config(prev_str, printf_config)


def _get_prev_str(character, format_string, idx, list_str, printf_config):
    """
    get prev_str for format_contrl is True

    :param character:
    :param format_string: the string include %d and so on.
    :param i: i
    :param list_str: data_list, prev_str, format_str
    :return: prev_str, format_str
    """
    data_list, format_str, prev_str, format_contrl = list_str
    i, arg_index = idx
    result = None
    if character in ('0', '#'):
        format_str = format_str + character
    if character in ('.', '1', '2', '3', '4', '5', '6', '7', '8', '9'):
        format_str = format_str + character
    if character in ('d', 'f', 'o', 'x', 's', 'c'):
        format_str = format_str + character
        if arg_index == len(data_list):
            # we will deal remain format and return
            _print_value_for_fmt_remain(format_string, i + 1, prev_str, printf_config)
            return result
        _print_value_for_printf(data_list[arg_index], prev_str,
                                '%{}'.format(format_str), printf_config)

        arg_index += 1
        if arg_index == len(data_list):
            # we will deal remain format and return
            _print_value_for_fmt_remain(format_string, i + 1, "", printf_config)
            return result
        prev_str = ""
        format_contrl = False
    result = format_str, prev_str, format_contrl, arg_index
    return result


def _gen_final_string(print_start_offset_in_u64, string_length, workspace_data):
    print_start_offset_in_u8 = print_start_offset_in_u64 * ONE_BYTE_BIT_LEN
    string_start_length = print_start_offset_in_u8 + EACH_PRINT_HEAD_BYTES
    final_string = ""
    for i in range(string_length):
        final_string += chr(workspace_data[i + string_start_length])
    return final_string


def deal_each_print(print_start_offset, workspace_data, printf_config):
    """
    deal each print

    Parameters
    ----------
    print_start_offset : offset size of print_start
    workspace_data : workspace data
    printf_file_handle : where to put printf text

    Returns
    -------
    None
    """
    print_data_array, print_data_type_array = [], []

    workspace_in_int64 = _gen_diff_dtype_numpy(workspace_data, "int64")
    magic_word_for_print = _gen_diff_dtype_numpy(workspace_data, "uint16")[print_start_offset // 2]

    if magic_word_for_print != MAGIC_WORD_FOR_PRINT_HEAD:
        raise RuntimeError("Not a valid print head for printf.", magic_word_for_print)
    _deal_each_print(print_start_offset, workspace_data,
                     (print_data_array, print_data_type_array), workspace_in_int64, printf_config)


def _deal_each_print_for(workspace_in_int64, start_data_offset_in_u8, workspace_data):
    actual_arg_type = int(workspace_in_int64[start_data_offset_in_u8 // ONE_BYTE_BIT_LEN])
    start_data_offset_in_u8 += ONE_BYTE_BIT_LEN
    real_data_length = int(workspace_in_int64[start_data_offset_in_u8 // ONE_BYTE_BIT_LEN])
    start_data_offset_in_u8 += ONE_BYTE_BIT_LEN
    tl_magic_tag = int(workspace_in_int64[start_data_offset_in_u8 // ONE_BYTE_BIT_LEN])
    start_data_offset_in_u8 += ONE_BYTE_BIT_LEN + ONE_BYTE_BIT_LEN

    if actual_arg_type not in actual_dtype_for_args:
        return False
    if tl_magic_tag != MAGIC_TL_TAG:
        return False

    arg_type_in_str = actual_dtype_for_args.get(actual_arg_type)
    type_numpy = _gen_diff_dtype_numpy(workspace_data, arg_type_in_str)

    arg_in_str = \
        type_numpy[start_data_offset_in_u8 // DTYPE_SIZE.get(arg_type_in_str):
                   (real_data_length + start_data_offset_in_u8) // DTYPE_SIZE.get(arg_type_in_str)]
    start_data_offset_in_u8 += ceil_div(real_data_length, ONE_BLK_SIZE) * ONE_BLK_SIZE
    return start_data_offset_in_u8, arg_in_str, arg_type_in_str


def _deal_each_print(print_start_offset, workspace_data, print_array, workspace_in_int64, printf_config):

    string_length = int(workspace_in_int64[print_start_offset // ONE_BYTE_BIT_LEN + STRING_LENGTH_OFFSET])
    args_length = int(workspace_in_int64[print_start_offset // ONE_BYTE_BIT_LEN + ARGS_LENGTH_OFFSET])
    print_data_array, print_data_type_array = print_array

    # we will use start_data_offset to gen print data array.
    start_data_offset_in_u8 = print_start_offset + EACH_PRINT_HEAD_BYTES + \
                              ceil_div(string_length, ONE_BLK_SIZE) * ONE_BLK_SIZE
    for _ in range(args_length):
        ret = _deal_each_print_for(workspace_in_int64, start_data_offset_in_u8, workspace_data)
        if not ret:
            break
        start_data_offset_in_u8, arg_in_str, arg_type_in_str = ret

        print_data_array.append(arg_in_str)
        print_data_type_array.append(arg_type_in_str)
    _combine_str_data(_gen_final_string(print_start_offset // ONE_BYTE_BIT_LEN, string_length, workspace_data),
                      print_data_array, args_length, printf_config)


def _gen_diff_dtype_numpy(numpy_array, dtype):
    """
    use to return diff dtype of numpy
    """
    temp_numpy = copy.deepcopy(numpy_array)
    temp_numpy.dtype = dtype
    return temp_numpy


def _deal_printf_with_discard(workspace_in_int64, start_offset, workspace_data, print_length, printf_config):
    each_core_bytes_length, single_print_max_length = print_length
    discard_print_count = int(workspace_in_int64[start_offset // ONE_BYTE_BIT_LEN + DISCARD_PRINT_COUNT_OFFSET])
    first_print_offset = int(workspace_in_int64[start_offset // ONE_BYTE_BIT_LEN + FIRST_PRINT_OFFSET_OFFSET])
    last_print_offset = int(workspace_in_int64[start_offset // ONE_BYTE_BIT_LEN + LAST_PRINT_OFFSET_OFFSET])
    print_count = int(workspace_in_int64[start_offset // ONE_BYTE_BIT_LEN + PRINT_COUNT_OFFSET])
    new_start_offset = int(start_offset + PRINT_CORE_HEAD_BYTES)
    # here means only can contains one print stmt
    need_print_num = int(print_count - discard_print_count)
    if first_print_offset != last_print_offset:
        if need_print_num != 1:
            raise RuntimeError("Can only print 1 statement, check data value is correct!")
        deal_each_print(new_start_offset, workspace_data, printf_config)
    else:
        # we will print [0 -- last_offset/first_offset ----  end]
        start_print_count = int(
            (each_core_bytes_length - last_print_offset - PRINT_CORE_HEAD_BYTES) // single_print_max_length)
        if int(last_print_offset // single_print_max_length) + start_print_count != need_print_num:
            raise RuntimeError("end_print_count + start_print_count is not equal to need_print_num!")
        for i in range(start_print_count):
            deal_each_print(int(new_start_offset + last_print_offset + i * single_print_max_length),
                            workspace_data, printf_config)
        for i in range(start_print_count):
            deal_each_print(int(new_start_offset + i * single_print_max_length), workspace_data, printf_config)


def start_analysis(workspace_data, workspace_in_int64, printf_config):
    """
    start analysis workspace.data
    :param workspace_data:
    :param workspace_in_int64:
    :param printf_config: is_printf_to_file, printf_file_handle
    :return:
    """
    each_core_bytes_length = int(workspace_in_int64[EACH_CORE_BYTES_LENGTH_OFFSET])
    single_print_max_length = int(workspace_in_int64[SINGLE_PRINT_MAX_LENGTH_OFFSET])
    for start_offset in range(0, len(workspace_data), int(each_core_bytes_length)):
        discard_print_count = int(workspace_in_int64[start_offset // ONE_BYTE_BIT_LEN + DISCARD_PRINT_COUNT_OFFSET])
        print_count = int(workspace_in_int64[start_offset // ONE_BYTE_BIT_LEN + PRINT_COUNT_OFFSET])
        # we will start to read from start_offset + 8 shape head
        if print_count <= 0:
            continue
        new_start_offset = int(start_offset + PRINT_CORE_HEAD_BYTES)
        if discard_print_count > 0:
            _deal_printf_with_discard(workspace_in_int64, start_offset, workspace_data,
                                      (each_core_bytes_length, single_print_max_length),
                                      printf_config)
        else:
            for i in range(print_count):
                deal_each_print(new_start_offset + i * single_print_max_length, workspace_data, printf_config)


def print_analysis_value(kernel_name, is_printf_to_file=True, printf_file_path=None):
    """
    analysis the printf result
    Parameters
    ----------
    kernel_name: the build kernel's name
    is_printf_to_file: whether printf to file
    printf_file_path: where to put printf text

    Returns
    -------
    None

    """
    workspace_data = np.fromfile(kernel_name + "_workspace.data", dtype="uint8")
    workspace_in_uint16 = _gen_diff_dtype_numpy(workspace_data, "uint16")
    workspace_in_int64 = _gen_diff_dtype_numpy(workspace_data, "int64")
    if workspace_in_uint16[0] != MAGIC_WORD_FOR_CORE_HEAD:
        raise RuntimeError("Not a valid workspace for printf.")

    if printf_file_path is not None:
        abs_path = os.path.join(os.path.realpath(printf_file_path))
        try_mkdir(abs_path)
        file_path = os.path.join(abs_path, kernel_name + ".txt")
        with open(file_path, "w") as printf_file_handle:
            start_analysis(workspace_data, workspace_in_int64, (is_printf_to_file, printf_file_handle))
    else:
        start_analysis(workspace_data, workspace_in_int64, (is_printf_to_file, None))
    os.remove(kernel_name + "_workspace.data")
