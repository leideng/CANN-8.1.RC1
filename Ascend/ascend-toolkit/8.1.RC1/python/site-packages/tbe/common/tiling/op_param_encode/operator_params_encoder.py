#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
TBE operator param encoder
"""
import json

from tbe.common.context import get_context
from tbe.common.repository_manager.interface import cann_kb_search
from tbe.common.tiling.auto_tiling_log import AUTOTILINGLOG
from tbe.common.tiling.tiling_global_var_internal_use import AUTO_TILING_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import CUSTOM_TILING_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import MODEL_TILING_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import MODEL_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import REPOSITORY_TILING_TYPE
from tbe.common.tiling.tiling_helper import TILING_INSTANCE
from tbe.common.utils.errormgr.error_manager_cube import raise_err_message_cube

MAX_UINT32 = 4294967295
MAX_UINT16 = 65535

CUBE_VECTOR_SPLIT_V220_SPECIAL_MAP = {
    "INPUT_L1_BT_param": {0: None, 1: "slice", 2: "all"},
    "INPUT_L1_FB_param": {0: None, 1: "slice", 2: "all"},
    "INPUT_L1_eltwise_param": {0: None, 1: "slice"}
}

class BaseClassParamsEncoder():
    """
    Base class for Params Encoder
    """

    def __init__(self):
        """
        init the support param dict
        """
        # Encode the type of tensor data
        self.dtype_dict = {
            'uint8': 0,
            'int8': 1,
            'float16': 2,
            'int32': 3,
            'float32': 4,
            'int16': 5,
            'int4':6,
            'bfloat16':7,
            'hfloat32' : 8
        }

        self.eltwise_support_dtype = ["float16", "int8", "int4"]
        self.v220_bais_support_dtype = ["", "float16", "float32", "int32"]

        # fixpipe fused type dict
        self.pre_conv = ["", "F322F16", "F322B8", "F322S4", "F322BF16", "S322F16", "S322B8",
                        "S322S4", "VF322B8", "VF322S4", "VF322BF16", "VS322F16", "VS322B8",
                        "VS322S4", "VS322S16", "S322S16"]
        self.pre_act = ["", "NORMAL_RELU", "SCALAR_RELU", "VECTOR_RELU"]
        self.post_anti_quant = ["", "S4", "S8"]
        self.post_eltwise = ["", "ADD", "SUB"]
        self.post_act = ["", "NORMAL_RELU", "SCALAR_RELU", "VECTOR_RELU"]
        self.post_quant = ["", "F162S4", "F162B8", "VF162S4", "VF162B8", "F162S16", "VF162S16"]
        self.post_transform = ["", "NZ2ND", "WINO_POST"]

        # Encode the type of op
        self.op_type_dict = {
            'conv2d': 0,
            'conv2d_backprop_input': 1,
            'conv2d_backprop_filter': 2,
            'depthwise_conv2d_forward': 3,
            'depthwise_bp_input': 4,
            'depthwise_bp_filter': 5,
            'depthwise_conv2d_native_v200': 6,
            'matmul': 7,
            'convolution_3d': 8,
            'conv3d_backprop_input': 9,
            'conv3d_backprop_filter': 10
        }

        # Define the occupied memory of input data type
        self.input_data_byte_width = {
            'uint8': 1,
            'int8': 1,
            'float16': 2,
            'int4': 0.5,
            'bfloat16': 2,
            'float32': 4,
            'hfloat32' : 4,
            'int16' : 2
            }

        # Define the level of fm valid size
        # according to the convention, fm_l1_vaild_size should be
        # 1/2, 3/4, 1 times fm_shape
        # the level of fm valid size is designed as 1\2\3
        self.input_data_level = {1: 1, 0.75: 2, 0.5: 3}
        self.input_args = {}

    @staticmethod
    def get_kb_query_attr(info_dict_shape: dict) -> str:
        """
        get repo key in milan repository manager
        """
        raise NotImplementedError()

    def check_param_type(self, param, type_list):
        """check whether the type of param is correct

        Parameters
        ----------
        param: instance
            the instance to check
        type_list: type
            type of data
        """
        check_list = tuple(type_list)
        if not isinstance(param, check_list):
            raise_err_message_cube("the type of param is illegal, only support {}, "
                "but the type of param is {}.".format(type_list, type(param)))

    def check_param_length(self, param, length_list):
        """check whether the length of param is correct

        Parameters
        ----------
        param: instance
            the instance to check
        length_list: list
            length of data
        """
        if not len(param) in length_list:
            raise_err_message_cube(
                "the length of param is illegal, only support {}, "
                "but the length of param is {}.".format(length_list, len(param)))

    def check_support_range(self, param, support_range):
        """check whether the range of param is correct

        Parameters
        ----------
        param: instance
            the instance to check
        support_range: dict
            support context of data
        """
        if isinstance(support_range, list):
            if param not in support_range:
                raise_err_message_cube(
                    "the input param is illegal, only support {}, but the param is {}.".format(
                        support_range, param))

        if isinstance(support_range, dict):
            if param not in support_range.keys():
                raise_err_message_cube(
                    "the input param is illegal, only support {}, but the param is {}.".format(
                        support_range.keys(), param))

    def check_support_value(self, param, support_value):
        """check whether the param is correct

        Parameters
        ----------
        param: instance
            the instance to check
        support_value:
            support data
        """
        if param != support_value:
            raise_err_message_cube(
                "the input param is illegal, only support {}, but the param is {}.".format(
                    support_value, param))

    def check_illegal_value(self, param, illegal_value):
        """check whether the param is correct

        Parameters
        ----------
        param: instance
            the instance to check
        illegal_value:
            don't support data
        """
        if param == illegal_value:
            raise_err_message_cube(
                "the input param is illegal, don't support {}, but the param is {}.".format(
                    illegal_value, param))

    def encode_list(self, input_list, encode_list):
        """check whether the range of param is correct

        Parameters
        ----------
        input_list: input list
            input param
        encode_list: list
            encoded input param
        """
        encode_list.extend(input_list)
        return encode_list

    def encode(self, params):
        """encode the information of shape to the list of uint32 digit

        Parameters
        ----------
        params: dict of params
            include all information of shape

        Returns
        -------
        params_encode : list of encoded params
            The encoded params, include uint32 numbers
        """
        # encode the dict to list
        if not isinstance(params, dict):
            raise_err_message_cube("the type of param is illegal, only support {}, "
                "but the type of param is {}.".format("dict", type(params)))

        # append the common compile params
        self.add_compile_param(params)

        return json.dumps(params)

    def add_compile_param(self, info_dict):
        """
        get compile param from tbe context and add the param in info_dict

        Parameters
        ----------
        info_dict: dict
            input args

        Returns
        -------
        info_dict: dict
            add two new compile param:
            device_id: the compile param is set by user, only get the first number
            auto_tune_mode: the compile param is set by user, tiling only judge whether the scene is tuning
                tune scene: True; other scene: False
        """
        # when model_type config xgboost, don't add compile_param
        if info_dict.get("model_type", MODEL_TYPE[0]) is MODEL_TYPE[0]:
            return info_dict
        # get the device_id from context of te_fusion
        context = get_context()
        if context is None:
            # default config
            # no context, then read device_id from environment variable(ASCEND_DEVICE_ID)
            device_id = TILING_INSTANCE.get_device_id()
            # default scene: set device_id 0
            device_id = 0 if device_id is None else device_id
            auto_tune_mode = False
        else:
            device_id = context.get_addition("device_id")
            if device_id is None:
                # no compile param(device_id), then read device_id from environment variable(ASCEND_DEVICE_ID)
                device_id = TILING_INSTANCE.get_device_id()
                # default scene: set device_id 0
                device_id = 0 if device_id is None else device_id
            elif not isinstance(device_id, str):
                raise_err_message_cube(
                    "the type of param is illegal, only support {}, "
                    "but the type of param is {}.".format(str, type(device_id)))
            else:
                try:
                    device_id = int(device_id.strip().split(",", 1)[0])
                except (TypeError, ValueError):
                    raise_err_message_cube(
                        "the type of param is illegal, only support {}, "
                        "but the type of param is {}.".format(int, type(device_id)))

            # get the auto_tune_mode from context of te_fusion
            auto_tune_mode = context.get_addition("auto_tune_mode")
            if auto_tune_mode is None:
                # default config: set auto_tune_mode False
                auto_tune_mode = False
            elif not isinstance(auto_tune_mode, str):
                raise_err_message_cube(
                    "the type of param is illegal, only support {}, "
                    "but the type of param is {}.".format(str, type(auto_tune_mode)))
            else:
                auto_tune_mode = bool("GA" in auto_tune_mode or "RL" in auto_tune_mode)

        # add two params which is compile params
        info_dict["device_id"] = device_id
        info_dict["auto_tune_mode"] = auto_tune_mode

        return info_dict

    # using repository manager module to get tiling in repo in new tiling access
    def query_repository(self, info_dict: dict, tiling_type_num: int) -> (str, bool):
        """
        query repository according to different tiling type

        Parameters
        ----------
        info_dict: the input params
        tiling_type_num: get_tiling type

        Returns
        -------
        repo_tiling: tiling
        hit_repo_flag: flag whether repository hitted
        """
        hit_repo_flag = False
        attr = self.get_kb_query_attr(info_dict)
        search_config = {}
        search_config["op_type"] = info_dict.get("op_type")
        if tiling_type_num == CUSTOM_TILING_TYPE:
            search_config["serach_mode"] = "user"
        elif tiling_type_num == REPOSITORY_TILING_TYPE or tiling_type_num == AUTO_TILING_TYPE:
            search_config["serach_mode"] = "normal"
        elif tiling_type_num == MODEL_TILING_TYPE:
            # when model tiling, infer tiling by costmodel instead of repo, return empty string
            return "", hit_repo_flag
        else:
            # when tiling type is not supported, raise error
            raise_err_message_cube("the tiling_type is invalid for repository search.")
        search_config["dynamic"] = self.input_args.get("dynamic_shape_flag", False)
        # use repository manage to serach tiling in repo
        repo_tiling_list = cann_kb_search(attr, search_config)
        # if is dynamic, return list, else return str
        if self.input_args.get("dynamic_shape_flag", False):
            AUTOTILINGLOG.info("Repository search is invalid for dynamic shapes and it will return an empty list.")
            return repo_tiling_list, hit_repo_flag
        else:
            if repo_tiling_list:
                repo_tiling = json.dumps(repo_tiling_list[0].get("knowledge", {}))
                hit_repo_flag = True
            else:
                # when case cannot be found in repo for static, return empty string
                repo_tiling = json.dumps({'AL0_matrix': [0, 0, 0, 0, 0, 0, 0], 'AL1_shape': None, 'AUB_shape': None,
                    'BL0_matrix': [0, 0, 0, 0, 0, 0, 0], 'BL1_shape': None, 'BUB_shape': None,
                    'CL0_matrix': [0, 0, 0, 0, 0, 0, 0], 'INPUT_L1_BT_param': None, 'INPUT_L1_FB_param': None,
                    'INPUT_L1_eltwise_param': None, 'INPUT_L1_sparse_index': None,
                    'L0C_OUTPUT_matrix': [0, 0, 16, 16, 0, 0], 'UB_channel_wise_input': [None, None, False],
                    'block_dim': [0, 0, 0, 0, 0], 'control_reorder_flag': 'NM',
                    'manual_pingpong_buffer': {'AL0_pbuffer': 0, 'AL1_pbuffer': 0, 'AUB_pbuffer': 0,
                    'BL0_pbuffer': 0, 'BL1_pbuffer': 0, 'BUB_pbuffer': 0, 'CL0_pbuffer': 0, 'INPUT_L1_BT_pbuffer': 0,
                    'INPUT_L1_FB_pbuffer': 0, 'INPUT_L1_eltwise_pbuffer': 0, 'L0C_OUTPUT_pbuffer': 0,
                    'UBG_pbuffer': 0}, 'special_optimize_flag': 0, 'tbe_compile_para': 0, 'vector_block_num': 0})
        return repo_tiling, hit_repo_flag


def transfer_new_tiling_special_value_v220(tiling: dict) -> dict:
    if 'INPUT_L1_BT_param' in tiling.keys() and \
        'INPUT_L1_FB_param' in tiling.keys() and \
        'INPUT_L1_eltwise_param' in tiling.keys():
        if tiling.get('INPUT_L1_BT_param') not in CUBE_VECTOR_SPLIT_V220_SPECIAL_MAP.get('INPUT_L1_BT_param').keys():
            raise_err_message_cube("INPUT_L1_BT_param value is illegal.")
        else:
            tiling['INPUT_L1_BT_param'] = \
                CUBE_VECTOR_SPLIT_V220_SPECIAL_MAP.get('INPUT_L1_BT_param').get(
                    tiling.get('INPUT_L1_BT_param'))

        if tiling.get('INPUT_L1_FB_param') not in CUBE_VECTOR_SPLIT_V220_SPECIAL_MAP.get('INPUT_L1_FB_param').keys():
            raise_err_message_cube("INPUT_L1_FB_param value is illegal.")
        else:
            tiling['INPUT_L1_FB_param'] = \
                CUBE_VECTOR_SPLIT_V220_SPECIAL_MAP.get('INPUT_L1_FB_param').get(
                    tiling.get('INPUT_L1_FB_param'))

        if tiling.get('INPUT_L1_eltwise_param') not in \
            CUBE_VECTOR_SPLIT_V220_SPECIAL_MAP.get('INPUT_L1_eltwise_param').keys():
            raise_err_message_cube("INPUT_L1_eltwise_param value is illegal.")
        else:
            tiling['INPUT_L1_eltwise_param'] = \
                CUBE_VECTOR_SPLIT_V220_SPECIAL_MAP.get('INPUT_L1_eltwise_param').get(
                    tiling.get('INPUT_L1_eltwise_param'))
    if 'INPUT_L1_sparse_index' in tiling.keys():
        if tiling.get('INPUT_L1_sparse_index') == 0:
            tiling['INPUT_L1_sparse_index'] = None

    return tiling


def transfer_special_value(tiling: dict) -> dict:
    """
    transfer special value in tiling

    Parameters
    ----------
    tiling: the input params

    Returns
    -------
    dict: tiling
    """
    if "UB_channel_wise_input" in tiling.keys():
        # Note, AUB_channel_wise_flag and BUB_channel_wise_flag are not involved in tiling.
        # So, reset them to None.
        tiling["UB_channel_wise_input"][0] = None
        tiling["UB_channel_wise_input"][1] = None
        # Note, CUB_channel_wise_flag only has value [true-1, false-0] in cpp source code.
        # So, do not add a judgement, whether it is None.
        tiling["UB_channel_wise_input"][2] = bool(tiling["UB_channel_wise_input"][2] != 0)
    else:
        # default set  channel_wise_flag
        tiling["AUB_channel_wise_flag"] = None
        tiling["BUB_channel_wise_flag"] = None
        tiling["CUB_channel_wise_flag"] = bool(tiling["CUB_channel_wise_flag"] != 0)

    # AUB_shape support special value None
    if tiling["AUB_shape"][0] == 0:
        tiling["AUB_shape"] = None
    elif tiling["AUB_shape"][0] == MAX_UINT32:
        tiling["AUB_shape"] = []

    # BUB_shape support special value None
    if tiling["BUB_shape"][0] == 0:
        tiling["BUB_shape"] = None

    # AL1_shape support special value [] and None
    if tiling["AL1_shape"][0] == MAX_UINT32:
        tiling["AL1_shape"] = []
    elif tiling["AL1_shape"][0] == 0:
        tiling["AL1_shape"] = None

    # BL1_shape support special value [] and None
    if tiling["BL1_shape"][0] == 0:
        tiling["BL1_shape"] = None
    elif tiling["BL1_shape"][0] == MAX_UINT32:
        tiling["BL1_shape"] = []

    # BL0_matrix support special value []
    if tiling["BL0_matrix"][0] == MAX_UINT16:
        tiling['BL0_matrix'] = []

    # INPUT_L1_BT_param | INPUT_L1_FB_param | INPUT_L1_eltwise_param
    # new tiling access
    tiling = transfer_new_tiling_special_value_v220(tiling)
    return tiling