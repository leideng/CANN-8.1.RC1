#!/usr/bin/env python
# -*- coding: UTF-8 -*-
"""
Copyright (C) 2020. Huawei Technologies Co., Ltd. All rights reserved.

TBE operator param encoder
"""

import json
import math
from copy import deepcopy

from tbe.common.tiling.tiling_api_internal_use import is_support_fixpipe_flatform
from tbe.common.utils.errormgr.error_manager_cube import raise_err_message_cube
from tbe.common.tiling.op_param_encode.operator_params_encoder \
    import BaseClassParamsEncoder

# define const value
CONST_VALUE0 = 0
CONST_VALUE1 = 1

# define length of shape
SHAPE_LENGTH2 = 2
SHAPE_LENGTH3 = 3
SHAPE_LENGTH4 = 4
SHAPE_LENGTH5 = 5
SHAPE_LENGTH6 = 6

OP_TYPE = "conv2d_backprop_filter"
MAX_UINT32 = 4294967295
MAX_UINT16 = 65535


def decode_for_dynamic(tiling, input_args):
    """
    decode tiling params in dynamic mode.
    """
    #dynamic shape tiling
    tiling_result = []
    for tiling_res in tiling:
        c_shape = deepcopy(input_args["C_shape"])
        pad = [
            deepcopy(input_args["padl"]),
            deepcopy(input_args["padr"]),
            deepcopy(input_args["padu"]),
            deepcopy(input_args["padd"])
        ]

        if input_args.get("tiling_type") is None:
            c_shape[2] = tiling_res["C_shape"][0]
            c_shape[3] = tiling_res["C_shape"][1]
            pad = tiling_res["pad"]
        tiling_res["C_shape"] = deepcopy(c_shape)
        tiling_res["pad"] = deepcopy(pad)
        tiling_result.append(tiling_res)
    return tiling_result


class Conv2dBpFilterParamsEncoder(BaseClassParamsEncoder):
    """
    Child class for conv2d backprop input Params Encoder
    """
    def __init__(self):
        super(Conv2dBpFilterParamsEncoder, self).__init__()
        self.input_args = {}
        self.flag_new_tiling = False

    @staticmethod
    def get_kb_query_attr(info_dict):
        """
        get typical key for repository query

        Parameters
        ----------
        info_dict: input params

        Returns
        ----------
        attr_dict: input params string
        """
        attr_dict = {'op_type': 'conv2d_backprop_filter', 'A_shape': [], 'B_shape': [], 'C_shape': None,
                     'A_dtype': 'float16', 'B_dtype': 'float16', 'C_dtype': 'float16', 'mad_dtype': 'float32',
                     'padl': 0, 'padr': 0, 'padu': 0, 'padd': 0, 'strideH': 1, 'strideW': 1,
                     'strideH_expand': 1, 'strideW_expand': 1, 'dilationH': 1, 'dilationW': 1,
                     'group': 1, 'bias_flag': 0, 'fused_double_operand_num': 0,
                     'fusion_type': 1}
        for key, value in info_dict.items():
            if key in attr_dict:
                attr_dict[key] = value
        return json.dumps(attr_dict)

    def encode_array(self, input_args):
        """
        encode the input params to NDArray

        Parameters
        ----------
        input_args: input params

        Returns
        ----------
        NDArray: tvm.nd.array
        """
        self.flag_new_tiling = is_support_fixpipe_flatform(input_args.get("op_type"))
        params_in = deepcopy(input_args)
        self.input_args = params_in
        # check params
        self.check_info_dict(params_in)
        # preprocess params
        self.preprocess_info_dict(params_in)

        return self.encode(params_in)

    def decode(self, tiling_encode):
        """
        encode the input params to tvm.nd.array
        Parameters
        ----------
        input_args: the input params
        Returns
        -------
        tvm.nd.array: the NDArray
        """
        if not self.input_args["dynamic_shape_flag"] and not tiling_encode:
            raise_err_message_cube(
                "only support legal tiling, but the return value of tiling is [%s]." \
                    % tiling_encode)

        if self.input_args["dynamic_shape_flag"] and not tiling_encode:
            return []

        tiling = json.loads(tiling_encode)
        if isinstance(tiling, list):
            tiling = decode_for_dynamic(tiling, self.input_args)
        return tiling

    def check_info_dict(self, params_in):
        """
        check the type, length and support-range of input params

        Parameters
        ----------
        params_in: input params

        Returns
        """
        # check the type of param
        self.check_param_type(params_in, [dict])
        self.check_param_type(params_in.get('A_shape'), [list])
        self.check_param_type(params_in.get('B_shape'), [list])
        # check the type and value and C_shape
        if isinstance(params_in.get('C_shape'), list):
            if (len(params_in.get('C_shape')) not in [SHAPE_LENGTH4, SHAPE_LENGTH5, SHAPE_LENGTH6]):
                raise_err_message_cube("the length of param is error, only support [4, 5, 6]")
        elif params_in.get('C_shape') is not None:
            raise_err_message_cube("the type of param is error, \
                    only support list tuple or None, but the type of param \
                    is %s" % type(params_in.get('C_shape')))
        # check the type of param
        self.check_param_type(params_in.get('A_dtype'), [str])
        self.check_param_type(params_in.get('B_dtype'), [str])
        self.check_param_type(params_in.get('C_dtype'), [str])
        self.check_param_type(params_in.get('mad_dtype'), [str])
        self.check_param_type(params_in.get('padl'), [int])
        self.check_param_type(params_in.get('padr'), [int])
        self.check_param_type(params_in.get('padu'), [int])
        self.check_param_type(params_in.get('padd'), [int])
        self.check_param_type(params_in.get('strideH'), [int])
        self.check_param_type(params_in.get('strideW'), [int])
        self.check_param_type(params_in.get('strideH_expand'), [int])
        self.check_param_type(params_in.get('strideW_expand'), [int])
        self.check_param_type(params_in.get('dilationH'), [int])
        self.check_param_type(params_in.get('dilationW'), [int])
        self.check_param_type(params_in.get('group'), [int])
        self.check_param_type(params_in.get("fused_double_operand_num"),
                              [int, float])
        self.check_param_type(params_in.get('bias_flag'), [bool, int])
        self.check_param_type(params_in.get('op_type'), [str])
        if params_in.get('fusion_type'):
            self.check_param_type(params_in.get('fusion_type'), [int])
        self.check_param_type(params_in.get('kernel_name'), [str])

        # check the length of param
        self.check_param_length(params_in.get('A_shape'), [SHAPE_LENGTH5, SHAPE_LENGTH6])
        self.check_param_length(params_in.get('B_shape'), [SHAPE_LENGTH5, SHAPE_LENGTH6])
        self.check_support_range(params_in.get('A_dtype'), self.dtype_dict)
        self.check_support_range(params_in.get('B_dtype'), self.dtype_dict)
        self.check_support_range(params_in.get('C_dtype'), self.dtype_dict)
        self.check_support_range(params_in.get('mad_dtype'), self.dtype_dict)
        self.check_support_range(params_in.get('op_type'), self.op_type_dict)

    def preprocess_info_dict(self, params_in):
        """
        encode input params and set default value of input params

        Parameters
        ----------
        params_in: input params

        Returns
        """
        # set the defalut value of params
        if self.flag_new_tiling:
            params_in["op_type"] = params_in.get("op_type", OP_TYPE)
        else:
            params_in["op_type"] = self.op_type_dict.get(params_in.get("op_type", OP_TYPE))
        params_in["A_shape"] = params_in.get("A_shape")
        params_in["B_shape"] = params_in.get("B_shape")
        params_in["C_shape"] = params_in.get("C_shape")

        params_in["A_dtype"] = self.dtype_dict.get( \
                               params_in.get("A_dtype", "float16"))
        params_in["B_dtype"] = self.dtype_dict.get( \
                               params_in.get("B_dtype", "float16"))
        params_in["C_dtype"] = self.dtype_dict.get( \
                               params_in.get("C_dtype", "float16"))
        params_in["mad_dtype"] = self.dtype_dict.get( \
                                 params_in.get("mad_dtype", "float16"))

        params_in["padl"] = params_in.get("padl", CONST_VALUE0)
        params_in["padr"] = params_in.get("padr", CONST_VALUE0)
        params_in["padu"] = params_in.get("padu", CONST_VALUE0)
        params_in["padd"] = params_in.get("padd", CONST_VALUE0)
        params_in["strideH"] = params_in.get("strideH", CONST_VALUE1)
        params_in["strideW"] = params_in.get("strideW", CONST_VALUE1)
        params_in["strideH_expand"] = params_in.get("strideH_expand", \
                                                        CONST_VALUE1)
        params_in["strideW_expand"] = params_in.get("strideW_expand", \
                                                        CONST_VALUE1)
        params_in["dilationH"] = params_in.get("dilationH", CONST_VALUE1)
        params_in["dilationW"] = params_in.get("dilationW", CONST_VALUE1)
        params_in["group"] = params_in.get("group", CONST_VALUE1)
        bias_flag = params_in.get("bias_flag", False)
        params_in["bias_flag"] = 1 if bias_flag else 0
        params_in["fusion_type"] = params_in.get("fusion_type", CONST_VALUE0)

        # process fixed-point number (%2.f)
        fused_double_operand_num = params_in.get("fused_double_operand_num")
        params_in["fused_double_operand_num"] = math.ceil(100 * \
                                                fused_double_operand_num)
        params_in["kernel_name"] = params_in.get( \
                                   "kernel_name", OP_TYPE + "_kernel")
        #Determine whether it is dynamic shape or fixed shape
        params_in["dynamic_shape_flag"] = params_in.get("dynamic_shape_flag", False)
