#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
Get the tiling
"""
import copy
import ast
import json
from tbe.common.utils.errormgr.error_manager_cube import raise_err_message_cube
from tbe.common.tiling.tiling_helper import TILING_INSTANCE
from tbe.common.tiling.op_param_encode.params_encoder import ParamsEncoder
from tbe.common.tiling.auto_tiling_log import AUTOTILINGLOG, tiling_show_long_log
from tbe.common.tiling.auto_tiling_log import INFO, WARN, DEBUG, ERROR
from tbe.common.tiling.tiling_api_internal_use import get_op_bank_path
from tbe.common.tiling.tiling_api_internal_use import check_params
from tbe.common.tiling.tiling_api_internal_use import global_func_get_tiling
from tbe.common.tiling.tiling_api_internal_use import configure_model_type
from tbe.common.tiling.tiling_api_internal_use import process_repo_hit_info
from tbe.common.tiling.tiling_api_internal_use import is_support_fixpipe_flatform
from tbe.common.tiling.tiling_api_internal_use import dict_value_none_deepcopy
from tbe.common.utils.errormgr import error_manager_cube as err_man
from tbe.common.utils.op_tiling import do_op_tiling
from tbe.common.tiling.tiling_global_var_internal_use import MODEL_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import BANK_CACHE
from tbe.common.tiling.tiling_global_var_internal_use import AUTO_TILING_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import REPOSITORY_TILING_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import CUSTOM_TILING_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import MODEL_TILING_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import TUNING_TILING_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import DSL_CACHE_TILING_TYPE
from tbe.common.tiling.tiling_global_var_internal_use import SUPPORT_TILING_TYPE
from tbe.common.utils.op_util.op_util_conv2d import support_conv_instruction

DEFAULT_TILING_FLAG_NUM = 32
TILING_M0_IDX = 2

def bank_cache_get(tiling_type_num: int) -> tuple:
    """
    Get the tiling from bank_cache

    Parameters+
    ----------

    Returns
    -------
    ret : bool
    tiling : dict
        The result.
    """
    if tiling_type_num == MODEL_TILING_TYPE:
        return False, {}
    bank_cache_dict = {}
    if BANK_CACHE:
        try:
            bank_cache_dict = ast.literal_eval(BANK_CACHE)
            if bank_cache_dict.get("tuning_mode", "") == "GA":
                tiling = bank_cache_dict["tiling_dict"]
                # if in opat dynamic tune senario, return list
                if tiling.get("A_shape"):
                    tiling = [tiling]
                return True, tiling
        except SyntaxError:
            AUTOTILINGLOG.error(
                "GA BANK_CACHE: {} must be json format!".format(BANK_CACHE))

    return False, {}


def check_optiling_info_valid(optiling_info):
    for op_tiling_key in ["op_type", "compile_info", "inputs", "outputs", "attrs"]:
        if op_tiling_key not in optiling_info:
            AUTOTILINGLOG.error(f"{op_tiling_key} is not in optiling_info")
            return False
    return True


def get_cache_tiling_v2(info_dict, optiling_info, tiling_type_num, editor):
    hit_repo_flag = False
    if optiling_info is None:
        AUTOTILINGLOG.debug("optiling_info is None, return None")
        return None, hit_repo_flag

    # update optiling_info when nhwc fast tiling
    if optiling_info.get("fast_tiling") is not None:
        (new_fmap, new_weight, new_outputs, attrs) = optiling_info.get("fast_tiling")
        optiling_info["op_type"] = "Conv2D"
        optiling_info["inputs"] = (new_fmap, new_weight, None, None)
        optiling_info["outputs"] = (new_outputs, )
        optiling_info["attrs"] = attrs

    op_tiling_support = editor.check_op_tiling_supported(optiling_info, info_dict)
    if not op_tiling_support:
        AUTOTILINGLOG.info("op_tiling check return None.")
        return None, hit_repo_flag

    if not check_optiling_info_valid(optiling_info):
        err_man.raise_err_message_cube("optiling_info is invalid")

    run_info = do_op_tiling(optiling_info.get("op_type"),
                            optiling_info.get("compile_info"),
                            optiling_info.get("inputs"),
                            optiling_info.get("outputs"),
                            None, None,
                            optiling_info.get("attrs"))
    cache_tiling = editor.parse_optiling(run_info, info_dict)
    return cache_tiling, hit_repo_flag


def get_repo_tiling_v2(info_dict, optiling_info, tiling_type_num, editor):
    repo_tiling, hit_repo_flag = editor.encoder.query_repository(info_dict, tiling_type_num)
    # string to dict
    if (repo_tiling != []):
        repo_tiling = json.loads(repo_tiling)
    return repo_tiling, hit_repo_flag


def get_model_tiling_v2(info_dict, optiling_info, tiling_type_num, editor):
    hit_repo_flag = False
    op_bank_path = get_op_bank_path()
    input_str = editor.encode_array(info_dict)
    model_tiling = global_func_get_tiling(input_str, tiling_type_num, op_bank_path)
    model_tiling = editor.decode(model_tiling)
    return model_tiling, hit_repo_flag


def get_auto_tiling_v2(info_dict, optiling_info, tiling_type_num, editor):
    repo_tiling, hit_repo_flag = get_repo_tiling_v2(info_dict, optiling_info, tiling_type_num, editor)
    if hit_repo_flag:
        tiling_show_long_log(DEBUG, "[auto tiling] tiling is from repo_tiling, kernel name is ",
                             info_dict.get("kernel_name", ""))
        return repo_tiling, hit_repo_flag

    cache_tiling, hit_repo_flag = get_cache_tiling_v2(info_dict, optiling_info, tiling_type_num, editor)
    if cache_tiling is not None:
        tiling_show_long_log(DEBUG, "[auto tiling] tiling is from cache tiling, kernel name is ",
                             info_dict.get("kernel_name", ""))
        return cache_tiling, hit_repo_flag

    model_tiling, hit_repo_flag = get_model_tiling_v2(info_dict, optiling_info, tiling_type_num, editor)
    if model_tiling["AL0_matrix"][TILING_M0_IDX] != DEFAULT_TILING_FLAG_NUM:
        tiling_show_long_log(DEBUG, "[auto tiling] tiling is from cost model tiling, kernel name is ",
                             info_dict.get("kernel_name", ""))
    return model_tiling, hit_repo_flag


GET_TILING_MAP = {AUTO_TILING_TYPE: get_auto_tiling_v2, \
                  MODEL_TILING_TYPE: get_model_tiling_v2, \
                  DSL_CACHE_TILING_TYPE: get_cache_tiling_v2, \
                  REPOSITORY_TILING_TYPE: get_repo_tiling_v2, \
                  CUSTOM_TILING_TYPE: get_repo_tiling_v2}


def get_optiling_info(info_dict):
    optiling_info = None
    if "extra_param" in info_dict.keys() and info_dict.get("extra_param") and \
       "optiling_info" in info_dict["extra_param"].keys():
        optiling_info = info_dict.get("extra_param").get("optiling_info")
    return optiling_info


def get_tiling_v2(info_dict: dict, tiling_mode, tiling_type_num, editor) -> dict:
    optiling_info = get_optiling_info(info_dict)
    tiling = None
    hit_repo_flag = False

    if tiling_type_num in GET_TILING_MAP.keys():
        tiling, hit_repo_flag = GET_TILING_MAP[tiling_type_num](info_dict, optiling_info, tiling_type_num, editor)
    else:
        err_man.raise_err_message_cube("tiling_mode [{}] is invalid, "
                                       "valid tiling_mode is [{}]".format(tiling_mode, SUPPORT_TILING_TYPE))

    return tiling, hit_repo_flag


def get_tiling(info_dict: dict) -> dict:
    """
    Get the tiling from module

    Parameters
    ----------
    info_dict: dict
        the params of operator

    Returns
    -------
    tiling : dict
        The result.
    """
    # check the params
    check_params(info_dict)
    tiling_type = info_dict.get("tiling_type")
    if tiling_type not in [None, "cost_model_tiling"]:
        raise_err_message_cube(
            "the tiling_type is error, only support {}, but tiling_type is {}.".format(
                "None, cost_model_tiling", tiling_type))
    # Read the config of tiling type, get the type of tiling
    if tiling_type == "cost_model_tiling":
        mode_old = TILING_INSTANCE.get_tiling_type()
        TILING_INSTANCE.set_tiling_type("cost_model_tiling")
    mode = TILING_INSTANCE.get_tiling_type()

    # default mode is auto_tiling
    if mode is None:
        mode = "auto_tiling"
    if mode not in SUPPORT_TILING_TYPE.keys():
        raise_err_message_cube(
            "the tiling_type is error, only support {}, but tiling_type is {}.".format(
                SUPPORT_TILING_TYPE.keys(), mode))

    tiling_type_num = SUPPORT_TILING_TYPE.get(mode)
    ret, tiling = bank_cache_get(tiling_type_num)
    if ret:
        return tiling

    # process model_type information for operators that support auto_tiling2.0
    configure_model_type(info_dict, mode)
    # check the platform if support fixpipe
    op_type = copy.deepcopy(info_dict.get("op_type"))
    new_tiling_flag = is_support_fixpipe_flatform(op_type)

    # encode the params of operator
    editor = ParamsEncoder(op_type)
    input_str = editor.encode_array(info_dict)
    hit_repo_flag = False
    if tiling_type_num != TUNING_TILING_TYPE:
        if new_tiling_flag or tiling_type_num == DSL_CACHE_TILING_TYPE:
            tiling, hit_repo_flag = get_tiling_v2(info_dict, mode, tiling_type_num, editor)
        else:
            op_bank_path = get_op_bank_path()
            ret = global_func_get_tiling(input_str, tiling_type_num, op_bank_path)
            tiling = editor.decode(ret)
        if tiling_type == "cost_model_tiling":
            TILING_INSTANCE.set_tiling_type(mode_old)
            mode = TILING_INSTANCE.get_tiling_type()
        TILING_INSTANCE.set_params(info_dict)
    else:
        tiling = TILING_INSTANCE.get_tiling(info_dict)
    info_dict_without_extra_param = dict_value_none_deepcopy(info_dict)
    if info_dict_without_extra_param.get("extra_param"):
        info_dict_without_extra_param.pop("extra_param")
    tiling_show_long_log(INFO, "[auto_tiling]info_dict", info_dict_without_extra_param)
    tiling_show_long_log(INFO, "[auto_tiling]tiling", tiling)
    tiling_show_long_log(INFO, "[auto_tiling]tiling_type", mode)
    processed_tiling = process_repo_hit_info(tiling, info_dict.get("dynamic_shape_flag"), \
                                             info_dict.get("kernel_name"), hit_repo_flag)
    return processed_tiling
