#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
TBE operator param encoder
"""
from tbe.common.utils.errormgr.error_manager_cube import raise_err_message_cube
from tbe.common.tiling.op_param_encode.conv2d_params_encoder import Conv2dParamsEncoder
from tbe.common.tiling.op_param_encode.conv2d_bp_input_params_encoder import Conv2dBpInputParamsEncoder
from tbe.common.tiling.op_param_encode.conv2d_bp_filter_params_encoder import Conv2dBpFilterParamsEncoder
from tbe.common.tiling.op_param_encode.matmul_params_encoder import (
    MatmulParamsEncoder
)
from tbe.common.tiling.op_param_encode.conv3d_params_encoder import \
    Conv3dParamsEncoder
from tbe.common.tiling.tiling_api_internal_use import is_support_fixpipe_flatform
from tbe.common.tiling.op_param_encode.operator_params_encoder import transfer_special_value

# define the support encoder of operator
SUPPORT_ENCODER_MAP = {
    "conv2d": Conv2dParamsEncoder,
    "conv2d_backprop_input": Conv2dBpInputParamsEncoder,
    "conv2d_backprop_filter": Conv2dBpFilterParamsEncoder,
    "matmul": MatmulParamsEncoder,
    "convolution_3d": Conv3dParamsEncoder,
    "conv3d_backprop_input": Conv3dParamsEncoder,
    "conv3d_backprop_filter": Conv3dParamsEncoder
}
MAX_UINT32 = 4294967295
MAX_UINT16 = 65535

CUBE_VECTOR_SPLIT_V220_SPECIAL_MAP = {
    "INPUT_L1_BT_param": {0: None, 1: "slice", 2: "all"},
    "INPUT_L1_FB_param": {0: None, 1: "slice", 2: "all"},
    "INPUT_L1_eltwise_param": {0: None, 1: "slice"}
}


class ParamsEncoder():
    """
    factory class for conv2d Params Encoder
    """

    def __init__(self, op_type: str) -> None:
        """
        init the specific object
        """
        self.encoder = mapping_op_type(op_type)()

    @staticmethod
    def get_kb_query_attr(info_dict_shape: dict) -> str:
        """
        get repo key in milan repository manager
        """
        op_type = info_dict_shape.get("op_type")
        return mapping_op_type(op_type).get_kb_query_attr(info_dict_shape)

    def encode_array(self, info_dict: dict) -> list:
        """
        encode the info_dict

        Parameters
        ----------
        info_dict: the input params

        Returns
        -------
        tvm.nd.array: the NDArray
        """
        op_type = info_dict.get("op_type")
        new_tiling_flag = is_support_fixpipe_flatform(op_type)
        # flag for deciding which access in C
        if new_tiling_flag:
            info_dict['tiling_access_version'] = 1
        else:
            info_dict['tiling_access_version'] = 0
            self.encoder.check_info_dict(info_dict)
        return self.encoder.encode_array(info_dict)

    def decode(self, tiling_encode: list) -> dict:
        """
        encode the info_dict

        Parameters
        ----------
        info_dict: the input params

        Returns
        -------
        tvm.nd.array: the NDArray
        """
        tiling = self.encoder.decode(tiling_encode)
        # if the mode is dynamic shape tiling is a list
        if isinstance(tiling, list):
            # dynamic shape tiling
            for tiling_dict in tiling:
                transfer_special_value(tiling_dict["tiling"])
            return tiling

        return transfer_special_value(tiling)

    def check_op_tiling_supported(self, optiling_info, info_dict) -> bool:
        """
        check the input op_tiling_param_dict

        Parameters
        ----------
        op_tiling_param_dict: the input params

        Returns
        -------
        """
        return self.encoder.check_op_tiling_supported(optiling_info, info_dict)

    def parse_optiling(self, run_info: dict, info_dict: dict) -> str:
        """
        parse the tiling info from run_info
        Parameters
        ----------
        run_info: the input params
        info_dict: original info_dict

        Returns
        -------
        tiling: string
        """
        return self.encoder.parse_optiling(run_info, info_dict)


def mapping_op_type(op_type: str) -> type:
    """
    map the op_type to object of specific class

    Parameters
    ----------
    op_type: the input type of operator

    Returns
    -------
    class_name: the specific class
    """
    if op_type not in SUPPORT_ENCODER_MAP.keys():
        raise_err_message_cube(
            "only support: {}, but the input is {}.".format(SUPPORT_ENCODER_MAP.keys(), op_type))

    return SUPPORT_ENCODER_MAP[op_type]
