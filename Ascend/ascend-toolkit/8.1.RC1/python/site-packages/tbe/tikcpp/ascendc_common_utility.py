#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
ascendc common utility
"""
import os
import stat
import ctypes
import subprocess
import multiprocessing
import copy
import json
import hashlib
import re
import shutil
import enum
import sys
import struct
from tbe.tvm.contrib.ccec import _build_aicore_compile_cmd, switching_compilation_mode, CCECInfo
from tbe.common.buildcfg import get_current_build_config
from tbe.common.platform.platform_info import get_soc_spec, set_soc_spec
from tbe.tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE
from .get_op_tiling import load_lib, get_tiling_info, TilingInfo, is_static_shape,\
    get_tiling_declaration, OpInfo, get_tiling_info_v2
from .log_utils import LogUtil, AscendCLogLevel, CompileStage
from .global_storage import global_var_storage
from .ascendc_constants import CORE_TYPE_MIX, KernelMetaType

BIN_FILENAME_HASHED_FLAG_ENV = 'BIN_FILENAME_HASHED'


class CompileInfo:
    def __init__(self):
        self.src_file: str = ""
        self.dst_file: str = ""
        self.kernel_name: str = ""  # func_name with md5
        self.origin_func_name: str = ""  # func_name written by user, without md5
        self.op_type: str = ""
        self.code_channel: int = CORE_TYPE_MIX
        self.gen_kernel_func_file: str = ""
        self.tiling_key_list: list = None
        self.is_debug: bool = False
        self.compile_log_path = None
        self.hard_sync: bool = False
        self.enable_deterministic: bool = False
        self.tiling_key_kernel_type: dict = {}
        self.no_set_kernel_type: bool = True
        self.default_kernel_type: KernelMetaType = KernelMetaType.KERNEL_TYPE_MAX
        self.dump_info: dict = {}
        self.sub_core_type: int = -1
        self.template_tiling_info: dict = {}
        self.tiling_key_struct_map: dict = {}
        self.enable_final_super_kernel_compile: bool = False
        # if enable_final_super_kernel_compile is True and super_kernel_objs is empty
        # means no fatbin, dst_file is the final file
        self.super_kernel_objs:list = []
        self.super_kernel_early_start_set_flag: bool = False
        self.super_kernel_early_start_wait_flag: bool = False
        self.super_kernel_info: dict = {}


    def __str__(self):
        return ",".join("{}={}".format(key, getattr(self, key)) for key in self.__dict__.keys())

    def get_kernel_func_name(self):
        """add "__kernel0" for kernel func name, tbe-dsl do this in build_cce.cc
        """
        return self.kernel_name + "__kernel0"


def _trans_compile_cmds_to_precompile(cmds_i: list):
    if len(cmds_i) < 2:
        raise Exception(f"invalid compile cmds = {cmds_i}")
    compiler_index = 0
    for cmd_idx, cmd in enumerate(cmds_i):
        if cmd.endswith('.o'):
            cmds_i[cmd_idx] = cmd[:-2] + '.i'
        if compiler_index == 0 and \
            (cmd.endswith('bisheng') or cmd.endswith('ccec') or cmd.endswith('ascendc_compiler')):
            compiler_index = cmd_idx
    cmds_i.insert(compiler_index + 1, '-E')


def write_mk(tiling_key_list, cmds_list, dst, compile_log_path):
    file = f'{dst}.mk'
    try:
        with open(file, mode='wt') as f:
            os.chmod(file, stat.S_IRUSR + stat.S_IWUSR)
            i = 0
            f.write('ALL: ')
            for tiling_key in tiling_key_list:
                f.write(f'{dst}_{tiling_key} ')
            f.write('\n\n')
            for cmds in cmds_list:
                f.write(f'{dst}_{tiling_key_list[i]}:\n')
                if global_var_storage.get_variable("ascendc_compile_debug_config"):
                    cmds_i = copy.deepcopy(cmds)
                    _trans_compile_cmds_to_precompile(cmds_i)
                    cmds_i_str = ' '.join(cmds_i)
                    CommonUtility.dump_compile_log(cmds_i, CompileStage.DEBUG_PRECOMPILE, compile_log_path)
                    f.write(f'\t{cmds_i_str}\n')
                cmds_str = ' '.join(cmds)
                CommonUtility.dump_compile_log(cmds, CompileStage.COMPILE, compile_log_path)
                if CommonUtility.is_v200():
                    f.write(f'\t{cmds_str} 2>/dev/null || ')
                    cmds_list_long = ["-mllvm", "-cce-aicore-jump-expand=true"]
                    cmds_long = copy.deepcopy(cmds)
                    cmds_long.extend(cmds_list_long)
                    cmds_str_long = ' '.join(cmds_long)
                    f.write(f' {cmds_str_long}\n')
                    CommonUtility.dump_compile_log(cmds_long, CompileStage.COMPILE, compile_log_path)
                else:
                    f.write(f'\t{cmds_str}\n')
                i += 1
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write mk file failed, reason is:", err))


class CommonUtility:
    """
    This class defines some common tool function methods.
    """
    def __init__(self):
        pass
    
    # write the cmpile_cmd to log
    @staticmethod
    def dump_compile_log(compile_cmd, stage: CompileStage, log_file=None):
        LogUtil.dump_compile_log(compile_cmd, stage, log_file)
        return

    @staticmethod
    def dump_log(log_str, log_file=None, level="[INFO] : "):
        LogUtil.dump_log(log_str, log_file, level)
        return

    @staticmethod
    def print_compile_log(kernel_name: str, msg_info: str, log_level: AscendCLogLevel):
        LogUtil.print_compile_log(kernel_name, msg_info, log_level)
        return

    @staticmethod
    def remove_temp_file(file):
        if os.path.isfile(file):
            os.remove(file)

    @staticmethod
    def get_ascendc_compiler_path(op_info: OpInfo):
        if global_var_storage.get_variable("ascendc_compiler_path") is not None:
            return
        ascendc_enable_ccache = os.environ.get("ASCENDC_CCACHE_EXECUTABLE")
        if ascendc_enable_ccache is None or \
            (ascendc_enable_ccache is not None and (str(ascendc_enable_ccache).endswith("ccache")) is False):
            global_var_storage.set_variable("ascendc_compiler_path", shutil.which("bisheng"))
        else:
            global_var_storage.set_variable("ascendc_enable_ccache", True)
            global_var_storage.set_variable("ascendc_compiler_path", shutil.which("ascendc_compiler"))
        if global_var_storage.get_variable("ascendc_compiler_path") is None:
            raise Exception(f'cannot find bisheng or ascendc_compiler, please set cann pkg env bash.')


    @staticmethod
    def run_cmd_stack_spill_case_ascendc(cmd, cmd_type, cce_file=None):
        """Run a shell commond (only support linux) for stack spill case in
        aicore.

        Parameters
        ----------
        cmd : list
            Command to be run.

        cmd_type : str
            Comand type uesd in running.

        Return
        ------
        out : str
            Standard output.
        returncode : int
            success or fail
        """
        cmd.append("-mllvm")
        cmd.append("-disable-lsr")
        cmd.append("-fno-unroll-loops")
        proc = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        (out, _) = proc.communicate()
        return out, proc.returncode

    @staticmethod
    def run_cmd_stackoverflow_ascnendc(cmd, cmd_type, cce_file=None):
        """Run a shell commond (only support linux) for stack overflow case in
        aicore.
        The current compiler's hardware instructions are not friendly to large
        immediate Numbers.
        Add compile options "-mllvm", "-disable-machine-licm" can avoid this
        problem, but it can degrade performance.

        Parameters
        ----------
        cmd : list
            Command to be run.

        cmd_type : str
            Comand type uesd in running.

        Return
        ------
        out : str
            Standard output.
        returncode : int
            success or fail
        """
        from tbe.common.platform.platform_info import ASCEND_310P
        from tbe.common.platform.platform_info import ASCEND_310
        cmd.insert(3, "-mllvm")
        cmd.insert(4, "-disable-machine-licm")
        if "-cce-aicore-jump-expand=false" in cmd:
            cmd[cmd.index("-cce-aicore-jump-expand=false")] = "-cce-aicore-jump-expand=true"
        if get_soc_spec("SHORT_SOC_VERSION") == ASCEND_310P:
            cmd.insert(5, "-mllvm")
            cmd.insert(6, "-cce-aicore-function-stack-size=16000")
        elif get_soc_spec("SHORT_SOC_VERSION") == ASCEND_310:
            cmd.insert(5, "-mllvm")
            cmd.insert(6, "-cce-aicore-function-stack-size=8192")
        proc = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        (out, _) = proc.communicate()
        if proc.returncode != 0:
            (out, retcode) = CommonUtility.run_cmd_stack_spill_case_ascendc(cmd, cmd_type, cce_file)
            return out, retcode
        return out, proc.returncode

    @staticmethod
    def run_cmd_ascendc(cmd, cmd_type):
        """Run a shell commond (only support linux).

        Parameters
        ----------
        cmd : list
            Command to be run.

        cmd_type : str
            Comand type uesd in running.

        Return
        ------
        out : str
            Standard output.
        returncode : int
            success or fail
        """
        proc = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        (out, _) = proc.communicate()
        is_compile_cmd = cmd_type == "compile"
        if proc.returncode != 0:
            if is_compile_cmd and "-O0" in cmd and "-g" in cmd:
                switching_compilation_mode()
                cmd[cmd.index("-O0")] = "-O2"
                del cmd[cmd.index("-g")]
                proc_now = subprocess.Popen(
                    cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                (out, _) = proc_now.communicate()
                if proc_now.returncode != 0:
                    if "--cce-aicore-only" in cmd:
                        (out_tmp, retcode) = CommonUtility.run_cmd_stackoverflow_ascnendc(cmd, cmd_type)
                        return out_tmp, retcode
                return out, proc_now.returncode

            # stack overflow case for aicore compile
            if is_compile_cmd and "--cce-aicore-only" in cmd:
                (out_tmp, retcode) = CommonUtility.run_cmd_stackoverflow_ascnendc(cmd, cmd_type)
                if retcode != 0:
                    return out_tmp, retcode
        return out, proc.returncode

    @staticmethod
    def run_cmd_inner(cmds: list, stage: CompileStage, compile_log_path=None):
        if stage == CompileStage.COMPILE:
            if global_var_storage.get_variable("ascendc_compile_debug_config"):
                # common compile .o cmds -> .i cmds
                cmds_i = copy.deepcopy(cmds)
                _trans_compile_cmds_to_precompile(cmds_i)
                CommonUtility.dump_compile_log(cmds_i, CompileStage.DEBUG_PRECOMPILE, compile_log_path)
                CommonUtility.run_cmd_ascendc(cmds_i, "compile")
            output, ret_code = CommonUtility.run_cmd_ascendc(cmds, "compile")
            if CommonUtility.is_v200():
                if ret_code != 0:
                    cmds += ["-mllvm", "-cce-aicore-jump-expand=true"]
                    output_long, ret_code = CommonUtility.run_cmd_ascendc(cmds, "compile")
                    if ret_code == 0:
                        output = output_long
            CommonUtility.dump_compile_log(cmds, CompileStage.COMPILE, compile_log_path)
            CommonUtility.dump_build_log(output.decode(), cmds, stage, ret_code)
            if output.decode().find("unsupported API") != -1:
                CommonUtility.print_compile_log("", output.decode(), AscendCLogLevel.LOG_ERROR)
        elif stage == CompileStage.PRECOMPILE:
            CommonUtility.dump_compile_log(cmds, stage, compile_log_path)
            output, ret_code = CommonUtility.run_cmd_ascendc(cmds, "compile")
            CommonUtility.dump_build_log(output.decode(), cmds, stage, ret_code)
        elif stage == CompileStage.FATBIN:
            CommonUtility.dump_compile_log(cmds, stage, compile_log_path)
            output, ret_code = CommonUtility.run_cmd_ascendc(cmds, "compile")
            CommonUtility.dump_build_log(output.decode(), cmds, stage, ret_code)
        elif stage == CompileStage.LINKRELOCATE:
            CommonUtility.dump_compile_log(cmds, stage, compile_log_path)
            output, ret_code = CommonUtility.run_cmd_ascendc(cmds, "link")
            CommonUtility.dump_build_log(output.decode(), cmds, stage, ret_code)

    @staticmethod
    def get_distinct_filename_tag() -> str:
        if global_var_storage.get_variable("ascendc_enable_ccache") is True or \
            os.getenv(BIN_FILENAME_HASHED_FLAG_ENV) == "1":
            return ""
        return "_" + str(os.getpid())

    @staticmethod
    def ascendc_build_aicore_compile_cmd(src_file, dst_file, name=""):
        return _build_aicore_compile_cmd(src_file, dst_file, name)

    @staticmethod
    def ascendc_raise_python_err(err_code, msg):
        raise_tbe_python_err(err_code, msg)

    @staticmethod
    def ascendc_read_file(file_path: str):
        try:
            with open(file_path, 'r') as f:
                sources = f.readlines()
                return sources
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, \
                (f"read gen_kernel_func_file: {file_path} failed, reason is: {err}"))
        return ""

    @staticmethod
    def ascendc_write_file(file_path: str, context: str):
        try:
            with open(file_path, 'w') as f:
                f.writelines(context)
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, \
            (f"write gen_kernel_func_file: {file_path} failed, reason is: {err}"))


    @staticmethod
    def is_v220():
        """return if current soc version is V220

        Returns:
            res: True means V220
        """
        short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
        if short_soc_version in ["Ascend910B", "Ascend910_93"]:
            return True
        return False

    @staticmethod
    def is_v200():
        """return if current soc version is V200

        Returns:
            res: True means V200
        """
        short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
        if short_soc_version in ["Ascend310P", "Ascend610"]:
            return True
        return False

    @staticmethod
    def is_v100():
        """return if current soc version is V100

        Returns:
            res: True means V100
        """
        short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
        if short_soc_version in ["Ascend910"]:
            return True
        return False

    @staticmethod
    def is_regbase():
        """return if current soc version is V300

        Returns:
            res: True means V300
        """
        short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
        if short_soc_version in ["Ascend310B", "Ascend610Lite"]:
            return True
        return False

    @staticmethod
    def get_kernel_meta_dir():
        """assembly kernel meta directory, and create directory if not exists

        Returns:
            kernel_meta_dir (str): kernel meta directory
        """
        kernel_meta_dir = os.path.join(
            get_current_build_config("kernel_meta_parent_dir"), "kernel_meta")
        if not os.path.exists(kernel_meta_dir):
            try:
                os.makedirs(kernel_meta_dir, stat.S_IRWXU +
                            stat.S_IRGRP + stat.S_IXGRP, exist_ok=True)
            except OSError as err:
                raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, err)
        return kernel_meta_dir

    @staticmethod
    def remove_options(compile_options: list, to_be_removed: list):
        i = 0
        while i < len(compile_options):
            if compile_options[i] in to_be_removed:
                del compile_options[i]
            else:
                i += 1

    @staticmethod
    def check_debug_options(compile_options: list) -> bool:
        from tbe.common.buildcfg.buildcfg_mapping import op_debug_config
        op_debug_config_info = get_current_build_config(op_debug_config)
        if "ccec_O0" in op_debug_config_info:
            CommonUtility.remove_options(compile_options, ['-O2', '-O3'])
            compile_options.append('-O0')
        if "ccec_g" in op_debug_config_info:
            compile_options.append('-g')
            return True
        if '-g' in compile_options:
            return True
        return False

    @staticmethod
    def get_build_file_name(cmds: list, stage: CompileStage):
        target_name = None
        for cmd in cmds:
            if cmd.endswith('.o') or cmd.endswith('.i'):
                target_name = cmd[:-2]
                break
        if target_name is None:
            return None, None, None
        target_name = target_name.split('/')[-1]
        split_name = target_name.split('_')
        md5sum_pos = 0
        md5sum_len = 32
        # check the splited names from last to avoid kernel name length is 32
        for i in range(len(split_name))[::-1]:
            if len(split_name[i]) == md5sum_len and split_name[i].isalnum():
                md5sum_pos = i
        kernel_name = split_name[md5sum_pos - 1]
        hash_name = split_name[md5sum_pos]
        file_name = "{}_{}.log".format(kernel_name, hash_name)
        if global_var_storage.get_variable("ascendc_build_log_path") is not None:
            file_name = os.path.join(global_var_storage.get_variable("ascendc_build_log_path"), file_name)
        return file_name, kernel_name, hash_name

    @staticmethod
    def dump_build_log(output: str, cmds: list, stage: CompileStage, ret_code: int):
        file_name, kernel_name, hash_name = CommonUtility.get_build_file_name(cmds, stage)
        op_name = "{}_{}".format(kernel_name, hash_name)
        if ret_code != 0:
            LogUtil.print_compile_log(op_name, output, AscendCLogLevel.LOG_ERROR)
            if not global_var_storage.get_variable("ascendc_enable_build_log"):
                raise Exception("An error occurred during compile phases of {}, msg is {}".\
format(str(stage), output))
        else:
            if cmds[0] != "llvm-objdump" and output != "":
                if "WARNING" in output.upper():
                    LogUtil.print_compile_log(op_name, output, AscendCLogLevel.LOG_WARNING)
                else:
                    LogUtil.print_compile_log(op_name, output, AscendCLogLevel.LOG_INFO)
        if not global_var_storage.get_variable("ascendc_enable_build_log"):
            return
        open_mode = 'at'
        if global_var_storage.get_variable("ascendc_build_log_list").count(file_name) == 0:
            tmp_log_list = global_var_storage.get_variable("ascendc_build_log_list")
            tmp_log_list.append(file_name)
            global_var_storage.set_variable("ascendc_build_log_list", tmp_log_list)
            open_mode = 'wt'
        try:
            with open(file_name, mode=open_mode) as f:
                os.chmod(file_name, stat.S_IRUSR + stat.S_IWUSR)
                if stage == CompileStage.FATBIN or stage == CompileStage.LINKRELOCATE:
                    f.write("[LD] %s\n" % (" ".join(cmds)))
                else:
                    f.write("[CC] %s\n" % (" ".join(cmds)))
                if cmds[0] != "llvm-objdump":
                    f.write(output)
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write log failed, reason is:", err))

        if ret_code != 0:
            file_name_parts = file_name.split('.')
            new_file_name = file_name_parts[0] + "_error." + file_name_parts[-1]
            os.rename(file_name, new_file_name)
            LogUtil.print_compile_log("", "Operator {}_{}: errors occurred during compile phase \
of {}, See also \"{}\"".format(kernel_name, hash_name, \
str(stage), new_file_name), AscendCLogLevel.LOG_ERROR)
            raise Exception("An error occurred during compile phases of {}, msg is {}".\
format(str(stage), output))
        if stage == CompileStage.LINKRELOCATE and ret_code == 0:
            file_name_parts = file_name.split('.')
            new_file_name = file_name_parts[0] + "_success." + file_name_parts[-1]
            os.rename(file_name, new_file_name)

    @staticmethod
    def parser_uint64_hex_num(hex_num):
        def reverser_hex_str(data):
            hex_num_res = ""
            for i in range(0, len(data), 2):
                hex_num_res = data[i : i + 2] + hex_num_res
            return hex_num_res
        hex_num_str_list = list(map(reverser_hex_str, hex_num[::-1]))
        hex_num_str = ''.join(hex_num_str_list)
        return hex_num_str

    @staticmethod
    def get_tiling_info_by_tiling(op_info: OpInfo, infered_info_from_ifile):
        CommonUtility.print_compile_log(op_info.kernel_name, "get tiling info...", AscendCLogLevel.LOG_INFO)
        if infered_info_from_ifile.default_tiling_struct != "":
            return get_tiling_info_v2(op_info, infered_info_from_ifile.tiling_key_list,\
                infered_info_from_ifile.default_tiling_struct, infered_info_from_ifile.tiling_key_struct_map)
        else:
            return get_tiling_info(op_info, infered_info_from_ifile.tiling_key_list)


def is_enable_sanitizer(compile_options):
    """
    get whether enable sanitizer

    Args:
        compile_options (list): compile options for bisheng
    """

    from tbe.common.buildcfg.buildcfg_mapping import op_debug_config
    op_debug_config_val = get_current_build_config(op_debug_config)
    asan_op_debug_config = "sanitizer" in op_debug_config_val
    enable_compile_asan_option = "-sanitizer" in compile_options or asan_op_debug_config
    if "-sanitizer" in compile_options:
        CommonUtility.remove_options(compile_options, ["-sanitizer"])
    if enable_compile_asan_option is False:
        return False
    ascend_home_path = os.environ.get("ASCEND_HOME_PATH")
    config_json_path = ""
    if ascend_home_path is not None:
        config_json_path = os.path.join(ascend_home_path, "compiler/conf/compile_options_config.json")
    else:
        return False
    if os.path.exists(config_json_path) is False:
        return False
    short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
    pre_asan_obj_path = {}
    try:
        with open(config_json_path, 'r') as fd:
            js = json.load(fd)
            if "Sanitizer" in js:
                if len(js["Sanitizer"]) == 0:
                    return False
                else:
                    if short_soc_version in js["Sanitizer"][0]:
                        pre_asan_obj_path[short_soc_version] = js["Sanitizer"][0][short_soc_version]
                    else:
                        return False
            else:
                return False
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("open asan config file failed", err))

    soc_obj_path = []
    for obj_path in pre_asan_obj_path[short_soc_version]:
        tmp_path = obj_path.replace("${ASCEND_HOME_PATH}", ascend_home_path)
        if os.path.exists(tmp_path) is False:
            raise Exception("asan obj file not exist")
        soc_obj_path.append(tmp_path)
    global_var_storage.set_variable("ascendc_asan_obj_path", {short_soc_version : soc_obj_path})      
    return True


def is_enable_build_log():
    """
    get build log path from env
    """
    build_log_path = os.environ.get("ASCENDC_BUILD_LOG_DIR")
    if build_log_path is None:
        return False
    short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
    if short_soc_version is None:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("get soc version failed, reason is:", err))
    build_log_path = os.path.join(build_log_path, short_soc_version.lower())
    if not os.path.exists(build_log_path):
        try:
            os.makedirs(build_log_path, stat.S_IRWXU +
                        stat.S_IRGRP + stat.S_IXGRP, exist_ok=True)
        except OSError as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("make dir failed, reason is:", err))
    global_var_storage.set_variable("ascendc_build_log_path", build_log_path)
    return True


def is_enable_ascendc_cov():
    """
    get ascendc cov options from env
    """
    ascendc_cov_flag = os.environ.get("ASCENDC_COV")
    if ascendc_cov_flag is None:
        return False
    if int(ascendc_cov_flag) == 1:
        return True
    else:
        return False