#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
compile operator
"""

import os
import stat
import ctypes
import subprocess
import multiprocessing
import copy
import json
import hashlib
import re
import shutil
import enum
import sys
import struct
from collections import namedtuple
from functools import reduce
from datetime import datetime, timezone
from tbe.tvm.contrib.ccec import _build_aicore_compile_cmd, switching_compilation_mode, CCECInfo
from tbe.tvm.runtime.cce_runtime import tvm_callback_cce_postproc, tvm_callback_save_main_json
from tbe.tvm.runtime import cce_runtime
from tbe.common.buildcfg import get_current_build_config
from tbe.common.buildcfg.buildcfg_mapping import enable_vector_core
from tbe.common.platform.platform_info import get_soc_spec, set_soc_spec
from tbe.tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE
from tbe.tvm import var
from tbe.common.context import get_context
from .get_op_tiling import load_lib, get_tiling_info, TilingInfo, is_static_shape,\
    get_tiling_declaration, OpInfo, get_tiling_info_v2
from .template_tiling import extract_template_tiling_info, decode_tiling
from .log_utils import LogUtil, AscendCLogLevel, LOG_LEVEL_TO_STR, CompileStage
from .global_storage import global_var_storage
from .ascendc_constants import InferChannelParamsFromIFile, InferChannelParams, KernelMetaType,\
    STR_TO_KERNEL_TYPE_V220, STR_TO_KERNEL_TYPE_V200, KERNEL_TYPE_TO_STR, CompileOptionTuple,\
    CORE_TYPE_MIX, CORE_TYPE_CUBE, CORE_TYPE_VEC, INPUT_OUTPUT_DTYPE_LEN, TILING_KEY_MACRO,\
    ASCENDC_OOM, MIX_CORE_MACRO, SuperKernelLinkMode
from .ascendc_common_utility import CommonUtility, write_mk, CompileInfo, \
    is_enable_ascendc_cov, is_enable_build_log, is_enable_sanitizer
from .ascendc_compile_dfx import DFXParamType, DFXPointType, DFXArgInfo, DFXSectionGenerator
from .ascendc_compile_v220 import gen_compile_cmd_v220, get_v220_kernel_type_mix_flag, call_bisheng_v220,\
    compile_single_tiling_v220, get_ktype_section_variable
from .ascendc_compile_v200 import gen_compile_cmd_v200, call_bisheng_v200_static, call_bisheng_v200_dynamic
from .ascendc_compile_base import compile_multi_tilingkey, link_relocatable, fatbin_objs, SingleTilingKeyCompileParams
from .ascendc_compile_gen_code import get_code_for_l2_cache, gen_global_isolation_macro, \
    gen_usr_origin_kernel_function_call, gen_template_tiling_params, add_time_stamp_codes,\
    gen_init_dump_code, gen_tiling_strcut_section, add_op_param_to_workspace
from .ascendc_compile_base import compile_multi_tilingkey, link_relocatable, fatbin_objs,\
    gen_sub_kernel_name, add_sub_super_kernel_info, raise_error_for_sub_super_kernel,\
    SingleTilingKeyCompileParams, gen_super_kernel_compile_info, gen_super_kernel_link_obj_sequence,\
    localization_sub_op_func_sym, gen_sub_super_kernel_compile_options, get_actual_kernel_type


DEFAULT_TILING_KEY = '0'
COMPILE_INFO_KEY = 'compileInfo'
GEN_PLACE_HOLDER_STR = 'gen_placeholder'


class KernelInfoInfer:
    """
    This class is used for get tiling key list and some kernel info
    i.g. code channel, kernel type for v200 and v220
    """
    @staticmethod
    def get_hard_sync_instr_from_i_file(dst_i_file):
        """
        find whether used SyncAll instr in kernel func
        if so, return true
        otherwise, return false
        """
        try:
            with open(dst_i_file, 'r') as fd:
                content = fd.read()
                pattern = re.compile(r"SyncAll\s*<\w+>\s*\(\s*\)\s*;")
                result = pattern.findall(content)
                if len(result) != 0:
                    return True
                pattern = r'SyncAll\s*\(\s*\)\s*\;'
                match = re.findall(pattern, content)
                if len(match) > 2:
                    return True
                return False
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read dst_i_file failed, reason is:", err))
        return False

    @staticmethod
    def get_sync_task_start_end_instr_from_i_file(dst_i_file):
        """
        find whether used SetNextTaskStart WaitPreTaskEnd instr in kernel func
        if so, return true
        otherwise, return false
        """
        try:
            with open(dst_i_file, 'r') as fd:
                content = fd.read()
                set_pattern = r'SetNextTaskStart\s*\(\s*\)\s*\;'
                wait_pattern = r'WaitPreTaskEnd\s*\(\s*\)\s*\;'
                set_match = re.findall(set_pattern, content)
                wait_match = re.findall(wait_pattern, content)
                return len(set_match) > 2, len(wait_match) > 2
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read dst_i_file failed, reason is:", err))
        return False, False

    @staticmethod
    def get_enable_deterministic_var_from_i_file(dst_i_file):
        """
        find whether enable_deterministic in kernel func
        if so, return true
        otherwise, return false
        """
        try:
            with open(dst_i_file, 'r') as fd:
                content = fd.read()
                pattern = r"__enable_feature_for_compile_deterministic\s*=\s*(-?\d+)\s*;"
                match = re.search(pattern, content)
                if match and match.group(1) == "1":
                    return True
                return False
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read dst_i_file failed, reason is:", err))
        return False

    @staticmethod
    def find_kernel_type(s):
        match = re.search(r"__enable_feature_for_compile_default\s*=\s*([0-9a-zA-Z_]{1,})\s*;", s)
        if match:
            return None, match.group(1)
        else:
            match = re.search(r"__enable_feature_for_compile_(-?\d+)([a-zA-Z]*)\s*=\s*([0-9a-zA-Z_]{1,})\s*;", s)
            if match:
                return match.group(1), match.group(3)
            return None, None

    @staticmethod
    def find_tilingkey(s):
        if re.search(r"g_tilingKey == \(", s):
            matches = re.findall(r"g_tilingKey == \((-?\d+)", s)
            if matches:
                return matches
            else:
                matches = re.findall(r"g_tilingKey == \((.*?)\)", s)
                if matches:
                    CommonUtility.print_compile_log("", f"Var: {matches[0]} in TILING_KEY_IS({matches[0]}) can not be \
processed as numeric variables in the precompilation phase. please use numeric constants, macros or const variables.", \
AscendCLogLevel.LOG_ERROR)
                return None
        return None

    @staticmethod
    def find_tiling_struct_and_expression(s):
        if "__enable_custom_tiling" not in s:
            return None, None
        match = re.search(r"__enable_custom_tiling\s*([0-9a-zA-Z_:]{1,})\s*=\s*default;", s)
        if match:
            return match.group(1), None
        else:
            match = \
re.search(r"__enable_custom_tiling\s*([0-9a-zA-Z_:]{1,})\s*=\s*\"(.*)\";", s)
            if match:
                return match.group(1), match.group(2)
            else:
                raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                    ("tiling struct match expression is wrong. lines: " + s))
                return None, None

    @staticmethod
    def get_dump_info_from_i_file(dst_i_file):
        dump_info = {"dump_type" : "", "dump_size" : 1048576}
        try:
            with open(dst_i_file, 'r') as fd:
                content = fd.read()
                fd.close()
                match_printf = re.search(r"__enable_feature_for_compile_printf = 1", content)
                match_assert = re.search(r"__enable_feature_for_compile_assert = 1;", content)
                if match_printf and match_assert:
                    dump_info["dump_type"] = "printf,assert"
                elif match_printf:
                    dump_info["dump_type"] = "printf"
                elif match_assert:
                    dump_info["dump_type"] = "assert"

                if global_var_storage.get_variable("ascendc_time_stamp_compile_options"):
                    if dump_info["dump_type"] != "":
                        dump_info["dump_type"] = dump_info["dump_type"] + ",timestamp"
                    else:
                        dump_info["dump_type"] = "timestamp"
                else:
                    match = re.search(r"__enable_feature_for_compile_printfBufSize = \s*([0-9]{1,})", content)
                    if match:
                        dump_info["dump_size"] = int(match.group(1))
                    else:
                        match = re.search(r"__enable_feature_for_compile_assertBufSize = \s*([0-9]{1,})", content)
                        if match:
                            dump_info["dump_size"] = int(match.group(1))

        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read dst_i_file failed, reason is:", err))

        return dump_info

    @staticmethod
    def get_kernel_type_enum(kernel_type, compile_log_path):
        if CommonUtility.is_v220():
            if kernel_type in STR_TO_KERNEL_TYPE_V220.keys():
                return STR_TO_KERNEL_TYPE_V220[kernel_type]
            else:
                if kernel_type not in STR_TO_KERNEL_TYPE_V200.keys():
                    CommonUtility.print_compile_log("", \
                        "current kernel type: {} is not support in current core version".\
                        format(kernel_type), AscendCLogLevel.LOG_WARNING)
                return None
        elif CommonUtility.is_v200():
            if kernel_type in STR_TO_KERNEL_TYPE_V200.keys():
                return STR_TO_KERNEL_TYPE_V200[kernel_type]
            else:
                if kernel_type not in STR_TO_KERNEL_TYPE_V220.keys():
                    CommonUtility.print_compile_log("", \
                        "current kernel type: {} is not support in current core version".\
                        format(kernel_type), AscendCLogLevel.LOG_WARNING)
                return None
        else:
            raise Exception("current kernel type: {} is not support in current core version".format(kernel_type))
        return None

    @staticmethod
    def gen_tiling_struct_macro_src_file(tiling_key_list, tiling_struct_expr_map, src_file):
        file_contents = ""
        for key, value in tiling_struct_expr_map.items():
            for expression in value:
                for tiling_key in tiling_key_list:
                    new_expression = expression.replace(TILING_KEY_MACRO, TILING_KEY_MACRO + "_" + tiling_key)
                    file_contents += f"#if defined({TILING_KEY_MACRO}_{tiling_key}) && {new_expression}\n"
                    file_contents += f"    auto __ascendc_custom_tiling_struct = ({tiling_key}, {key});\n"
                    file_contents += "#endif\n"
        try:
            with open(src_file, 'w') as f:
                f.writelines(file_contents)
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,\
                                ("write tiling struct tmp file failed, reason is :", err))

    @staticmethod
    def get_tiling_key_corresponding_struct(tiling_key_list, default_tiling_struct,\
        src_tiling_file, dst_tiling_file, compile_log_path):
        tiling_key_struct_map = {}
        tiling_compile_cmd = [global_var_storage.get_variable("ascendc_compiler_path"), \
                              "-c", '-O3', '-std=c++17', '-E', src_tiling_file, '-o', dst_tiling_file]
        for tiling_key in tiling_key_list:
            tiling_compile_cmd.append(f"-D{TILING_KEY_MACRO}_{tiling_key}={tiling_key}UL")
        CommonUtility.run_cmd_inner(tiling_compile_cmd, CompileStage.PRECOMPILE, compile_log_path)
        match_tiling_struct = ""
        try:
            with open(dst_tiling_file, 'r') as f:
                lines = f.readlines()
                for line in lines:
                    if line.startswith("#"):
                        continue
                    match = \
re.search(r"auto __ascendc_custom_tiling_struct\s*=\s*\((-?\d+),\s([0-9a-zA-Z_:]{1,})\);", line)
                    if match:
                        if match.group(1) in tiling_key_struct_map and \
                            tiling_key_struct_map[match.group(1)] != match.group(2):
                            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, \
                                (f"tiling struct match is repeated which tiling key is {tiling_key}, satisfied struct\
 are:{tiling_key_struct_map[match.group(1)]}, {match.group(2)}"))
                        else:
                            tiling_key_struct_map[match.group(1)] = match.group(2)
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, \
                ("read tiling struct dump file failed, reason is :", err))
        for tiling_key in tiling_key_list:
            if tiling_key not in tiling_key_struct_map:
                tiling_key_struct_map[tiling_key] = default_tiling_struct
        return tiling_key_struct_map

    @staticmethod
    def check_func_name_exist(pattern: str, text: str):
        match = re.search(r"\b{}\b\s*\(".format(pattern), text)
        if match:
            return True
        else:
            return False

    @staticmethod
    def dfx_for_func_name(cce_file: str, origin_func_name: str, func_name_exist: bool):
        if not func_name_exist:
            cce_file = cce_file.split("/")[-1]
            CommonUtility.print_compile_log("", f"kernel entry `{origin_func_name}' not implement in `{cce_file}', \
please check whether the function name is correct in the kernel file.",
                AscendCLogLevel.LOG_ERROR)
            raise Exception("An error occurred during stage of infer compile info")

    @staticmethod
    def infer_info_from_ifile(dst_i_file: str, compile_log_path, cce_file: str, origin_func_name: str):
        tiling_key_list = []
        declare_param_str = ""
        select_param_str = ""
        decode_tiling_result = {}
        code_channel:int = -1
        no_kfc_server_flag = False
        find_kfc_server = False
        default_tiling_struct = ""
        tiling_struct_expr_map = {}
        if not CommonUtility.is_v220():
            code_channel = CORE_TYPE_MIX
        hard_sync = KernelInfoInfer.get_hard_sync_instr_from_i_file(dst_i_file)
        set_task_bar, wait_task_bar = KernelInfoInfer.get_sync_task_start_end_instr_from_i_file(dst_i_file)
        enable_deterministic = KernelInfoInfer.get_enable_deterministic_var_from_i_file(dst_i_file)
        tiling_key_kernel_type = {}
        default_kernel_type = KernelMetaType.KERNEL_TYPE_MAX
        dump_info = KernelInfoInfer.get_dump_info_from_i_file(dst_i_file)
        func_name_exist = False
        try:
            with open(dst_i_file, 'r') as f:
                lines = f.readlines()
                for line in lines:
                    if line.startswith("#"):
                        continue
                    func_name_exist = (func_name_exist or \
                        KernelInfoInfer.check_func_name_exist(origin_func_name, line))
                    if '@@ASCENDC_TPL_ARGS_DECL' in line:
                        declare_param_str = line
                    if '@@ASCENDC_TPL_LISTS' in line:
                        select_param_str = line
                    if 'AscendC::KfcServer' in line:
                        code_channel = CORE_TYPE_MIX
                        find_kfc_server = True
                    # process register tiling strcut and expression
                    tiling_struct, tiling_expression = KernelInfoInfer.find_tiling_struct_and_expression(line)
                    if tiling_struct is not None:
                        if tiling_expression is None:
                            if default_tiling_struct != "" and default_tiling_struct != tiling_struct:
                                raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                    ("Only one default tiling structure can be configured."))
                            else:
                                default_tiling_struct = tiling_struct
                        else:
                            if tiling_struct in tiling_struct_expr_map:
                                tiling_struct_expr_map[tiling_struct].add("(" + tiling_expression + ")")
                            else:
                                tiling_struct_expr_map[tiling_struct] = set([str("(" + tiling_expression + ")")])
                    tiling_key, kernel_type = KernelInfoInfer.find_kernel_type(line)
                    if tiling_key is None and kernel_type is not None:
                        cur_kernel_type = KernelInfoInfer.get_kernel_type_enum(kernel_type, compile_log_path)
                        if cur_kernel_type is not None:
                            default_kernel_type = cur_kernel_type
                    if tiling_key is not None and kernel_type is not None:
                        cur_kernel_type = KernelInfoInfer.get_kernel_type_enum(kernel_type, compile_log_path)
                        if cur_kernel_type is not None:
                            tiling_key_kernel_type[str(int(tiling_key))] = cur_kernel_type
                    numbers = KernelInfoInfer.find_tilingkey(line)
                    if numbers is None:
                        continue
                    for number in numbers:
                        if str(int(number)) not in tiling_key_list:
                            tiling_key_list.append(str(int(number)))
                if declare_param_str and select_param_str:
                    extract_template_tiling_info(declare_param_str, select_param_str)
                    decode_tiling_result = decode_tiling()
                    tiling_key_list = [str(k) for k in decode_tiling_result.keys()]
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read dst_i_file failed, reason is:", err))

        KernelInfoInfer.dfx_for_func_name(cce_file, origin_func_name, func_name_exist)

        if len(tiling_key_list) == 0:
            tiling_key_list = [DEFAULT_TILING_KEY]
        if not find_kfc_server:
            no_kfc_server_flag = True

        no_set_kernel_type = False
        if default_kernel_type == KernelMetaType.KERNEL_TYPE_MAX and not tiling_key_kernel_type:
            if get_current_build_config(enable_vector_core):
                CommonUtility.dump_log("Information Library Configuration Takes Effect", compile_log_path)
                for tiling_key in tiling_key_list:
                    tiling_key_kernel_type[tiling_key] = KernelMetaType.KERNEL_TYPE_MIX_VECTOR_CORE
            else:
                no_set_kernel_type = True
        else:
            if len(tiling_key_kernel_type) > 0 and len(tiling_key_kernel_type) != len(tiling_key_list) \
                and default_kernel_type == KernelMetaType.KERNEL_TYPE_MAX:
                raise Exception(f'must provide default kernel type')
            for tiling_key in tiling_key_list:
                if tiling_key not in tiling_key_kernel_type:
                    tiling_key_kernel_type[tiling_key] = default_kernel_type
            if get_current_build_config(enable_vector_core):
                CommonUtility.dump_log(\
                    "Information Library Configuration Does Not Take Effect After the Macro Is Enabled",\
                    compile_log_path, "[WARNING] : ")
        if not global_var_storage.get_variable("ascendc_compile_debug_config"):
            CommonUtility.remove_temp_file(dst_i_file)

        tiling_key_struct_map = {}
        if default_tiling_struct != "":
            if declare_param_str and select_param_str:
                for tiling_key, information in decode_tiling_result.items():
                    tiling_key_struct_map[str(tiling_key)] = information.get('tilingStruct', default_tiling_struct)
            else:
                src_tiling_file = dst_i_file[:-2] + "_tiling_key_tiling_struct.cpp"
                dis_tiling_i_file = dst_i_file[:-2] + "_tiling_key_tiling_struct" + dst_i_file[-2:]
                KernelInfoInfer.gen_tiling_struct_macro_src_file(tiling_key_list,\
                                                                tiling_struct_expr_map, src_tiling_file)
                tiling_key_struct_map = KernelInfoInfer.get_tiling_key_corresponding_struct(tiling_key_list, \
                    default_tiling_struct, src_tiling_file, dis_tiling_i_file, compile_log_path)
        else:
            if len(tiling_struct_expr_map) != 0:
                raise Exception(f'if use user-defined tiling structure, must provide default tiling struct, use macro \
REGISTER_TILING_DEFAULT')
            for _, information in decode_tiling_result.items():
                if 'tilingStruct' in information:
                    raise Exception(f'if use user-defined tiling structure, must provide default tiling struct,\
 use macro REGISTER_TILING_DEFAULT')

        return InferChannelParamsFromIFile(tiling_key_list, code_channel, hard_sync, no_kfc_server_flag, \
                                           enable_deterministic, tiling_key_kernel_type, no_set_kernel_type,\
                                           default_kernel_type, dump_info, decode_tiling_result,
                                           default_tiling_struct, tiling_struct_expr_map, tiling_key_struct_map,\
                                           set_task_bar, wait_task_bar)

    @staticmethod
    def get_tiling_key_list_and_simple_infer_code_channel(cce_file: str, dst_i_file: str, \
        compile_option_tuple: CompileOptionTuple, compile_log_path, origin_func_name):
        """
        get tiling key list and simple infer code channel
        :param cce_file:
        :return:InferedInfo
        """
        compile_option_tuple_pre = copy.deepcopy(compile_option_tuple)
        compile_option_tuple_pre.compile_options = compile_option_tuple_pre.compile_options\
            + ['-E'] + ['-D__CHECK_FEATURE_AT_PRECOMPILE'] + ['-includestdio.h']
        compile_option_tuple_pre.compile_options = compile_option_tuple_pre.compile_options + ['-DASCENDC_TPL_PRE']
        # generate .i file
        if CommonUtility.is_v220():
            arch = "dav-c220-cube"
            dis_i_file_cube = dst_i_file[:-2] + "_cube" + dst_i_file[-2:]
            pre_compile_cmd = gen_compile_cmd_v220(cce_file, dis_i_file_cube, \
                                    compile_option_tuple_pre, arch, '', False)
            CommonUtility.run_cmd_inner(pre_compile_cmd, CompileStage.PRECOMPILE, compile_log_path)
            arch = "dav-c220-vec"
            dis_i_file_vec = dst_i_file[:-2] + "_vec" + dst_i_file[-2:]
            pre_compile_cmd = gen_compile_cmd_v220(cce_file, dis_i_file_vec, \
                                    compile_option_tuple_pre, arch, '', False)
            CommonUtility.run_cmd_inner(pre_compile_cmd, CompileStage.PRECOMPILE, compile_log_path)
            with open(dis_i_file_cube, 'r') as f_cube, open(dis_i_file_vec, 'r') as f_vec:
                cube_content = f_cube.read()
                vec_content = f_vec.read()
            # merge sub core .i file in dst_i_file
            with open(dst_i_file, 'w') as f:
                f.write(cube_content + vec_content)
            # chmod sub core .i file permission
            os.chmod(dis_i_file_cube, stat.S_IRUSR + stat.S_IWUSR)
            os.chmod(dis_i_file_vec, stat.S_IRUSR + stat.S_IWUSR)
            if not global_var_storage.get_variable("ascendc_compile_debug_config"):
                CommonUtility.remove_temp_file(dis_i_file_cube)
                CommonUtility.remove_temp_file(dis_i_file_vec)
        else:
            pre_compile_cmd = _gen_compile_cmd(cce_file, dst_i_file, compile_option_tuple_pre, '', False)
            CommonUtility.run_cmd_inner(pre_compile_cmd, CompileStage.PRECOMPILE, compile_log_path)
        if not os.path.exists(dst_i_file):
            raise Exception(f"Geneate file {dst_i_file} failed, probably due to error in compile")
        os.chmod(dst_i_file, stat.S_IRUSR + stat.S_IWUSR)
        # get tiling key list and simpel infer code channel
        return KernelInfoInfer.infer_info_from_ifile(dst_i_file, compile_log_path, cce_file, origin_func_name)


def _check_if_gen_placehoder(op_info: OpInfo, is_input: bool) -> bool:
    context = get_context()
    input_output_info = op_info.inputs if is_input is True else op_info.outputs
    if is_input:
        option_mode = context.get_addition("optional_input_mode")
    else:
        option_mode = context.get_addition("optional_output_mode")
    if option_mode != GEN_PLACE_HOLDER_STR:
        return False
    if len(input_output_info) == 0:
        return False
    for param in input_output_info:
        if param is None:
            err_msg = f"[ERROR] : context is {GEN_PLACE_HOLDER_STR}, but have null input, " \
                            f"params are not full, inputs is: {input_output_info}"
            CommonUtility.print_compile_log(op_info.kernel_name, err_msg, AscendCLogLevel.LOG_ERROR)
            raise Exception(err_msg)
    return True


def _set_compile_info(op_info: OpInfo):
    """set compile info in order to let AOE tools set tune params into compile info
        only support static shape ops
    """
    context = get_context()
    if is_static_shape(op_info.inputs, op_info.outputs):
        from tbe.common.tiling import BANK_CACHE
        if BANK_CACHE is not None and len(BANK_CACHE) != 0:
            tiling = context.get_addition('tune_param')
            if tiling is None:
                from tbe.common.utils.create_kb_query_key import get_op_compile_unique_key
                from tbe.common.repository_manager.interface import cann_kb_search
                info_dict = get_op_compile_unique_key(op_info.op_type, op_info.inputs, op_info.outputs, op_info.attrs,\
                    op_info.impl_mode, False)
                tiling = cann_kb_search(info_dict, search_config={"op_type": op_info.op_type, "full_info": True}, \
                    option={})
            if tiling is not None:
                context.add_compile_info('tune_param', tiling)


def _json_post_process(compile_info: CompileInfo, op_info: OpInfo, tiling_info: TilingInfo,\
                        input_gen_placehoder: bool, output_gen_placehoder: bool, compile_log_path):
    kernel_meta_path = CommonUtility.get_kernel_meta_dir()
    json_path = os.path.join(kernel_meta_path, compile_info.kernel_name + '.json')
    obj_path = os.path.join(kernel_meta_path, compile_info.kernel_name + '.o')

    try:
        with open(json_path, 'r') as fd:
            js = json.load(fd)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read json file failed, reason is:", err))
    if input_gen_placehoder:
        js['optionalInputMode'] = GEN_PLACE_HOLDER_STR
    if output_gen_placehoder:
        js['optionalOutputMode'] = GEN_PLACE_HOLDER_STR
    if compile_info.enable_deterministic:
        if get_current_build_config("enable_deterministic_mode") == 1:
            js["deterministic"] = "true"
        else:
            js["deterministic"] = "false"

    if not global_var_storage.get_variable("ascendc_dump_disable_compile_options") \
        and compile_info.dump_info.get("dump_type", "") != "":
        js["debugOptions"] = compile_info.dump_info["dump_type"]
        js["debugBufSize"] = compile_info.dump_info["dump_size"] * 75

    # set tilingdata of mc2 operator when online static compile
    if tiling_info.static_shape_flag is True and op_info.mc2_ctx is not None and len(op_info.mc2_ctx) != 0:
        js["runInfo"] = tiling_info.raw_run_info

    # gen sub operator infos for super kernel feature
    js = add_sub_super_kernel_info(js)

    if compile_info.super_kernel_info.get("timestamp_option") is not None and\
         compile_info.super_kernel_info.get("timestamp_option"):
        js["debugOptions"] = "printf"
        js["debugBufSize"] = 1048576 * 75

    # get max tiling size when use tiling new
    if len(compile_info.tiling_key_struct_map) > 0:
        max_tiling_size = _get_tiling_struct_size(compile_info.dst_file, \
                                        compile_info.tiling_key_struct_map, compile_log_path)
    # get max tiling size when use tiling old
    else:
        max_tiling_size = tiling_info.tiling_data_size

    # updata op_param size by flag of oom
    if "oom" in get_current_build_config("tir.op_debug_config"):
        # tiling need align to 8 bytes, dfx need 8 bytes for dfx point,
        # oom need allocate 8 * (input + output + shape_tensor+ workspace)
        op_param_size = ((max_tiling_size + 7) // 8) * 8 \
                                    + 8 + 8 * DFXSectionGenerator().param_placeholder_num
    else:
        op_param_size = max_tiling_size + 8

    js["opParaSize"] = int(op_param_size)

    if COMPILE_INFO_KEY not in js:
        js[COMPILE_INFO_KEY] = {}
    if tiling_info.static_shape_flag:
        del js[COMPILE_INFO_KEY]
        # generate schedule_mode for static shape
        if tiling_info.static_shape_flag and tiling_info.schedule_mode != 0:
            js["schedule_mode"] = tiling_info.schedule_mode

    if "param_type_dynamic" in op_info._fields and op_info.param_type_dynamic:
        js["dynamicParamMode"] = "folded_with_desc"

    if op_info.init_value_list is not None:
        #generate clear output for atomic instrs
        param_of_init_values = [None for _ in op_info.inputs]
        if tiling_info.clear_atomic:
            for output, init_value in zip(op_info.outputs, op_info.init_value_list):
                if init_value is not None:
                    if init_value.isdigit() :
                        # generate init value for InitValue(uint64_t)
                        param_init_value = {'dtype': output['dtype'], 'init_value': int(init_value)}
                    else :
                        try:
                            init_value_json = json.loads(init_value)
                            # generate init value for InitValue(std::vector<ScalarVar>)
                            if init_value_json["is_list"]:
                                param_init_value = {'dtype': init_value_json[output['dtype']]['type'],
                                                    'init_value': init_value_json[output['dtype']]['value']}
                            else :
                            #  generate init value for InitValue(ScalarVar)
                                param_init_value = {'dtype': init_value_json['type'],
                                                    'init_value': init_value_json['value']}
                        except Exception as err:
                            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                ("read initValue error, reason is:", err))
                    param_of_init_values.append(param_init_value)
                else:
                    param_of_init_values.append(None)
        else:
            param_of_init_values += [None for _ in op_info.outputs]
        # generate null for workspace
        param_of_init_values.append(None)
        js["parameters"] = param_of_init_values

    try:
        with open(obj_path, 'rb') as obj_file:
            js['sha256'] = hashlib.sha256(obj_file.read()).hexdigest()
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read obj_file failed, reason is:", err))
    try:
        with open(json_path, 'w') as fd_write:
            os.chmod(json_path, stat.S_IRUSR + stat.S_IWUSR)
            json.dump(js, fd_write, indent=2)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write json file failed, reason is:", err))


def _gen_kernel_func_declare_head_with_workspace(tiling_info: TilingInfo, super_kernel_params):
    dfx_generator = DFXSectionGenerator()
    content = ""
    # static shape do not have tiling
    if CommonUtility.is_v100() or CommonUtility.is_v200():
        if tiling_info.static_shape_flag:
            content += "GM_ADDR workspace, GM_ADDR overflowStatus)\n"
        else:
            content += "GM_ADDR workspace, GM_ADDR tiling, GM_ADDR overflowStatus)\n"
            dfx_generator.insert_param(DFXArgInfo("tiling", DFXParamType.TILING))
    else:
        if tiling_info.static_shape_flag:
            content += "GM_ADDR workspace)\n"
            super_kernel_params.append("workspace")
        else:
            content += "GM_ADDR workspace, GM_ADDR tiling)\n"
            super_kernel_params.append("workspace")
            super_kernel_params.append("tiling")
            dfx_generator.insert_param(DFXArgInfo("tiling", DFXParamType.TILING))
    content += "{\n"
    return content, super_kernel_params


def _gen_kernel_func_declare_head(kernel_func_dec: str, is_mix: bool, is_single_and_using_hard_sync: bool, \
                                    opinfo: OpInfo, tiling_info: TilingInfo):
    # generate kernel function
    source = kernel_func_dec
    dfx_generator = DFXSectionGenerator()
    super_kernel_params = []
    if is_mix or is_single_and_using_hard_sync:
        source += "GM_ADDR ffts_addr, "
        super_kernel_params.append("ffts_addr")
        dfx_generator.insert_param(DFXArgInfo("ffts", DFXParamType.FFTS))

    if opinfo.mc2_ctx:
        for ctx_name in opinfo.mc2_ctx:
            source += "GM_ADDR {}, ".format(ctx_name)
            super_kernel_params.append(str(ctx_name))
            dfx_generator.insert_param(DFXArgInfo(ctx_name, DFXParamType.MC2CTX))

    for input in opinfo.inputs:
        if input is None:
            continue
        source += "GM_ADDR {}, ".format(input["param_name"])
        super_kernel_params.append(input["param_name"])
        dfx_generator.insert_param(DFXArgInfo(input["param_name"], DFXParamType.INPUT))

    for output in opinfo.outputs:
        if output is None:
            continue
        source += "GM_ADDR {}, ".format(output["param_name"])
        super_kernel_params.append(output["param_name"])
        dfx_generator.insert_param(DFXArgInfo(output["param_name"], DFXParamType.OUTPUT))

    if opinfo.output_shape_depend_on_compute is not None and len(opinfo.output_shape_depend_on_compute) > 0:
        source += "GM_ADDR __ascendc_output_shape, "
        super_kernel_params.append("__ascendc_output_shape")
        dfx_generator.insert_param(DFXArgInfo("shape_tensor", DFXParamType.SHAPE_TENSOR))
        # modify point type for OutputShapeDependOnCompute output
        for index in opinfo.output_shape_depend_on_compute:
            parameter: DFXArgInfo = dfx_generator.get_param(opinfo.outputs[index]["param_name"])
            parameter.point_type = DFXPointType.LEVEL_1_FOR_SHAPE_TENSOR
        # for static shape, set size to max value, len(OutputShapeDependOnCompute output) * mix dim(8) * uint64_t(8)
        if tiling_info.static_shape_flag:
            dfx_generator.set_size_of_dfx_info("shape_tensor", len(opinfo.output_shape_depend_on_compute) * 8 * 8)

    # dynamic: must add workspace, static: if workspace_size >= 0 add workspace
    if not tiling_info.static_shape_flag or tiling_info.static_workspace_size >= 0:
        dfx_generator.insert_param(DFXArgInfo("workspace", DFXParamType.WORKSPACE))

    content, super_kernel_params = _gen_kernel_func_declare_head_with_workspace(tiling_info, super_kernel_params)
    source += content
    if global_var_storage.get_variable("ascendc_enable_super_kernel") is True:
        global_var_storage.set_variable("ascendc_sub_super_kernel_params", super_kernel_params)
    return source


def _gen_set_workspace_codes(is_mix: bool, is_single_and_using_hard_sync: bool, \
    opinfo: OpInfo, tiling_info: TilingInfo, dump_size: int, \
    compile_options: list, compile_info: CompileInfo):
    # set workspace
    source = ""
    source += "    GM_ADDR usrWorkspace = AscendC::GetUserWorkspace(workspace);\n"
    if "oom" in get_current_build_config("tir.op_debug_config"):
        source = add_op_param_to_workspace(opinfo, tiling_info, source, dump_size, compile_options, compile_info)

    # set ffts_addr for ascend910b mix op or is_single_and_using_hard_sync scene
    if is_mix or is_single_and_using_hard_sync:
        source += "    icache_preload(1);\n"
        source += "    if (ffts_addr != nullptr) {\n"
        source += "        set_ffts_base_addr((uint64_t)ffts_addr);\n"
        source += "    }\n"
        source += add_time_stamp_codes('TIME_STAMP_WRAP_FFTS_ADDR')

    # restart enable begin position
    if global_var_storage.get_variable("ascendc_enable_aicore_exception_restart"):
        source += "do {\n"

    # is_single_and_using_hard_sync scene not need clear workspace
    if is_mix:
        source += f"#ifdef {MIX_CORE_MACRO} \n"
        source += "    if constexpr (g_coreType == AscendC::AIC) {\n"
        source += "        matmul::clearWorkspace(workspace);\n"
        source += add_time_stamp_codes('TIME_STAMP_WRAP_CLEAR_WK_SPAC', 2)
        source += "    }\n"
        source += "#endif\n"
    if "printf" in compile_info.dump_info["dump_type"]:
        source += "#ifdef ASCENDC_DUMP\n"
        source += "    uint64_t __ascendc_tStamp = 0;\n"
        source += "    uint64_t __ascendc_version = 0;\n"
        source += "     __gm__ char* __ascendc_versionStr = nullptr;\n"
        source += "    GetCannVersion(__ascendc_versionStr, __ascendc_version, __ascendc_tStamp);\n"
        source += "    if (__ascendc_tStamp == 0) {\n"
        source += "        AscendC::printf(\"[WARNING]: CANN TimeStamp is invalid, \
CANN TimeStamp is %u\\n\", __ascendc_tStamp);\n"
        source += "    } else {\n"
        source += "        AscendC::printf(\"CANN Version: %s, TimeStamp: %u\\n\", \
(__gm__ const char*)(__ascendc_versionStr), __ascendc_tStamp);\n"
        source += "    }\n"
        source += "#endif\n"
    return source


def _gen_set_mc2_ctx_param(opinfo: OpInfo):
    if opinfo.mc2_ctx is None:
        return ""
    source = ""
    index = 0
    for ctx_name in opinfo.mc2_ctx:
        source += f"    AscendC::SetHcclContext<{index}>({ctx_name});\n"
        index += 1
    return source


def gen_kernel_fun(compile_info: CompileInfo, func_name: str, opinfo: OpInfo, \
                    tiling_info: TilingInfo, compile_options: list):
    src_file = compile_info.src_file
    out_file = compile_info.gen_kernel_func_file
    dump_size = compile_info.dump_info["dump_size"]

    file_name = os.path.basename(src_file)
    file_name_without_ext = os.path.splitext(file_name)[0]
    # begin generate code
    # File Isolation Macro
    source = f"#ifndef __{file_name_without_ext.upper()}__KERNEL_FUN_H__\n"
    source += f"#define __{file_name_without_ext.upper()}__KERNEL_FUN_H__\n\n"
    # replace __global micro for usr kernel function, and recover after usr kernel function
    source += "#undef __global__\n"
    source += "#define __global__ inline\n"
    source += f"#include \"{src_file}\"\n"
    source += "#include \"kernel_utils.h\"\n"
    source += "#include \"inner_interface/inner_kernel_operator_intf.h\"\n"
    source += "#undef __global__\n"
    source += "#if ASCENDC_CPU_DEBUG\n"
    source += "#define __global__\n"
    source += "#else\n"
    source += "#define __global__ __attribute__((cce_kernel))\n"
    source += "#endif\n\n"

    # add template_param
    source += gen_template_tiling_params(compile_info)

    is_mix, is_single_and_using_hard_sync = get_v220_kernel_type_mix_flag(compile_info, tiling_info)

    # generate code for l2 cache
    if global_var_storage.get_variable("ascendc_enable_sanitizer") is False and \
        global_var_storage.get_variable("ascendc_debug_compile_options") is False and \
        global_var_storage.get_variable("ascendc_enable_super_kernel") is False:
        if CommonUtility.is_v220() or CommonUtility.is_v200():
            source = get_code_for_l2_cache(compile_info, source, tiling_info)

    # generate kernel function
    auto_gen_kernel_func = f'auto_gen_{func_name}_kernel'
    global_flag = "__attribute__((aligned(512)))" if \
        global_var_storage.get_variable("ascendc_enable_super_kernel") is True else "__global__"
    kernel_func_dec = f"extern \"C\" {global_flag} [aicore] void {auto_gen_kernel_func}("
    source += _gen_kernel_func_declare_head(kernel_func_dec, is_mix,\
        is_single_and_using_hard_sync, opinfo, tiling_info)
    # init dump and system workspace

    if global_var_storage.get_variable("ascendc_enable_super_kernel") is False:
        source += gen_init_dump_code(is_mix, dump_size)
        # set mc2 context
        source += _gen_set_mc2_ctx_param(opinfo)
        source += add_time_stamp_codes('TIME_STAMP_WRAP_MC2_CTX')
        # implicit add aicore exception restart begin position
        # set workspace
        source += _gen_set_workspace_codes(is_mix, is_single_and_using_hard_sync, opinfo, tiling_info, \
                                       dump_size, compile_options, compile_info)
    else:
        source += _gen_set_mc2_ctx_param(opinfo)
        source += "    AscendC::SetSysWorkspaceForce(workspace);\n"
        source += "    GM_ADDR usrWorkspace = AscendC::GetUserWorkspace(workspace);\n"

    need_ffts = is_mix or is_single_and_using_hard_sync

    # call usr kernel function call
    source += "#if defined(TEMPLATE_PARAMS_LEN) && TEMPLATE_PARAMS_LEN != 0\n"
    source += gen_usr_origin_kernel_function_call(
        func_name, opinfo, tiling_info, has_template=True)
    source += "#else\n"
    source += gen_usr_origin_kernel_function_call(
        func_name, opinfo, tiling_info, has_template=False)
    source += "#endif\n"

    # aicore exception restart main block
    if global_var_storage.get_variable("ascendc_enable_aicore_exception_restart"):
        for key in tiling_info.tiling_key_list:
            source += f"#if {TILING_KEY_MACRO} == {key}UL"
            source += "\n"

            actual_kernel_type = get_actual_kernel_type(key, compile_info, need_ffts, opinfo.kernel_name)

            if actual_kernel_type == CORE_TYPE_CUBE:
                source += "    if ASCEND_IS_AIC {\n"
                source += "        AscendC::PipeBarrier<PIPE_ALL>();\n"
                source += "        AscendC::CrossCoreSetFlag<0, PIPE_FIX>(AscendC::SYNC_AIC_FLAG);\n"
                source += "        AscendC::CrossCoreWaitFlag(AscendC::SYNC_AIC_FLAG);\n"
                source += "    }\n"
            elif actual_kernel_type == CORE_TYPE_VEC:
                source += "    AscendC::SyncAll();\n"
            elif actual_kernel_type == CORE_TYPE_MIX:
                source += "    AscendC::SyncAll<false>();\n"
            source += "#endif\n"

        ctx_num = 0
        if opinfo.mc2_ctx is not None:
            ctx_num = len(opinfo.mc2_ctx)
        source += f"    auto __ascendc_is_restart = AscendC::GetRestart({ctx_num});\n"
        source += "    if (__ascendc_is_restart > 0) {\n"
        source += "        AscendC::PipeBarrier<PIPE_ALL>();\n"
        source += "        dcci((__gm__ int64_t*)0, cache_line_t::ENTIRE_DATA_CACHE);\n"
        # add corresponding sync all by kernel type
        for key in tiling_info.tiling_key_list:
            source += f"#if {TILING_KEY_MACRO} == {key}UL"
            source += "\n"

            actual_kernel_type = get_actual_kernel_type(key, compile_info, need_ffts, opinfo.kernel_name)

            if actual_kernel_type == CORE_TYPE_CUBE:
                source += "        if ASCEND_IS_AIC {\n"
                source += "            AscendC::PipeBarrier<PIPE_ALL>();\n"
                source += "            AscendC::CrossCoreSetFlag<0, PIPE_FIX>(AscendC::SYNC_AIC_FLAG);\n"
                source += "            AscendC::CrossCoreWaitFlag(AscendC::SYNC_AIC_FLAG);\n"
                source += "        }\n"
            elif actual_kernel_type == CORE_TYPE_VEC:
                source += "        AscendC::SyncAll();\n"
            elif actual_kernel_type == CORE_TYPE_MIX:
                source += "        AscendC::SyncAll<false>();\n"
            source += "#endif\n"
        source += f"        AscendC::SetRestart({ctx_num});\n"
        source += "    } else {\n"
        source += "        break;\n"
        source += "    }\n"
        source += "} while(1);\n"

    from tbe.common.buildcfg.buildcfg_mapping import status_check
    if get_current_build_config(status_check) and (CommonUtility.is_v200() or CommonUtility.is_v100()):
        source += "    AscendC::WriteBackOverflow(overflowStatus);\n"

    if len(compile_info.tiling_key_struct_map) > 0:
        source += gen_tiling_strcut_section(compile_info, tiling_info)

    source += "}\n\n"
    source += "#endif\n"
    # write code into file
    try:
        with os.fdopen(os.open(out_file, os.O_RDWR | os.O_CREAT, stat.S_IWUSR | stat.S_IRUSR), 'w') as ofd:
            ofd.write(source)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("gen kernel func file failed, reason is:", err))


def _add_op_compile_options_by_customized_json(op_compile_option: str, compile_option_tuple: CompileOptionTuple):
    js = json.loads(op_compile_option)
    if '--cce-auto-sync=off' not in compile_option_tuple.compile_options and js.get('auto_sync') is not False:
        compile_option_tuple.compile_options.append('--cce-auto-sync')
        compile_option_tuple.compile_options.append('-mllvm')
        compile_option_tuple.compile_options.append('-api-deps-filter')
    short_soc_version = get_soc_spec("SHORT_SOC_VERSION").lower()
    compile_options_custom = js.get('compile_options')
    if compile_options_custom is not None:
        if '__ALL__' in compile_options_custom:
            for opt in compile_options_custom.get('__ALL__'):
                if opt.startswith('-mllvm'):
                    compile_option_tuple.mllvm_options.append('-mllvm')
                    compile_option_tuple.mllvm_options.append(opt[7:])
                else:
                    compile_option_tuple.compile_options.append(opt)
        if short_soc_version in compile_options_custom:
            for opt in compile_options_custom.get(short_soc_version):
                if opt.startswith('-mllvm'):
                    compile_option_tuple.mllvm_options.append('-mllvm')
                    compile_option_tuple.mllvm_options.append(opt[7:])
                else:
                    compile_option_tuple.compile_options.append(opt)


def _get_tiling_struct_size(bin_file_path, tiling_key_struct_map, compile_log_path):
    tiling_struct_set = set()
    tiling_struct_size_map = {}
    max_tiling_size = 0
    for _, tiling_struct in tiling_key_struct_map.items():
        new_tiling_struct = tiling_struct.split(":")[-1]
        tiling_struct_set.add(new_tiling_struct)
    for tiling_struct in tiling_struct_set:
        objdump_cmd = ['llvm-objdump', '-s', '-j',\
            '.ascendc_tiling.{}'.format(tiling_struct), '{}'.format(bin_file_path)]
        proc = subprocess.Popen(objdump_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        (out, _) = proc.communicate()
        lines = out.decode('utf-8').split('\n')
        '''
        e.g.
        Contents of section .ascend.meta.TilingData:
        0000 50000000 00000000                    P.......
        '''
        if len(lines) >= 5:
            hex_num = lines[3].split(' ')[2:4]
            hex_num_str = CommonUtility.parser_uint64_hex_num(hex_num)
            bytes_data = bytes.fromhex(hex_num_str)
            dec_data = struct.unpack('>Q', bytes_data)[0]
            tiling_struct_size_map[tiling_struct] = dec_data
            max_tiling_size = max(max_tiling_size, dec_data)
    #remove ascendc_tiling section
    objdump_cmd = ['llvm-objcopy', '--remove-section=.ascendc_tiling.*', '{}'.format(bin_file_path)]
    proc = subprocess.Popen(objdump_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    (out, _) = proc.communicate()
    return max_tiling_size


def super_kernel_compile(kernel_info):
    from tbe.common.buildcfg.buildcfg_mapping import op_debug_config
    op_info = OpInfo()
    compile_options = kernel_info["compile_option"]
    compile_options = compile_pre_process(op_info, compile_options)
    compile_log_path = None
    if global_var_storage.get_variable("ascendc_compile_debug_config"):
        kernel_meta_dir = CommonUtility.get_kernel_meta_dir()
        distinct_tag = CommonUtility.get_distinct_filename_tag()
        compile_log_path = os.path.join(kernel_meta_dir, kernel_info["kernel_name"] + distinct_tag + '.log')
    DFXSectionGenerator().is_support = False
    # if enable timestamp, need set workspace to generate workspace param
    if kernel_info["timestamp_option"]:
        get_context().add_workspace("total_workspace", size=1)
    compile_info, tiling_info = gen_super_kernel_compile_info(kernel_info, compile_log_path)
    compile_option_tuple = CompileOptionTuple([] if compile_options is None else compile_options, [])
    _compile_ascendc_cce_v220_with_kernel_type_for_static(compile_info, compile_option_tuple, tiling_info)
    sub_objs = gen_super_kernel_link_obj_sequence(compile_info, kernel_info["sub_operator"], kernel_info["link_mode"])
    fatbin_objs(sub_objs, compile_info.dst_file, compile_info.is_debug, compile_info.compile_log_path)
    op_info = OpInfo()
    link_relocatable(compile_info.dst_file, compile_info.compile_log_path)
    localization_sub_op_func_sym(compile_info.dst_file, kernel_info["sub_operator"])
    _json_post_process(compile_info, op_info, tiling_info, True, True, compile_log_path)


def _update_compile_option(kernel_name: str, compile_options: list, extend_options: dict):
    bisheng = os.environ.get('BISHENG_REAL_PATH')
    if bisheng is None:
        bisheng = shutil.which("bisheng")
    if bisheng is not None:
        bisheng_path = os.path.dirname(bisheng)
        tikcpp_path = os.path.realpath(
            os.path.join(bisheng_path, "..", "..", "tikcpp"))
    else:
        tikcpp_path = os.path.realpath(
            "/usr/local/Ascend/latest/compiler/tikcpp")
    cann_version_file_path = os.path.join(tikcpp_path, "..", "..",
                                          "include", "version", "cann_version.h")
    if os.path.exists(cann_version_file_path):
        compile_options.append("-include" + cann_version_file_path)
    else:
        CommonUtility.print_compile_log(
            kernel_name, "not found cann_version.h", AscendCLogLevel.LOG_WARNING)

    if extend_options.get('opp_kernel_hidden_dat_path', None) is not None:
        compile_options.append("-cce-vfs")
        compile_options.append(extend_options.get('opp_kernel_hidden_dat_path'))

def compile_pre_process(op_info: OpInfo, compile_options: list):
    cce_runtime.TBE_ATUO_ATOMIC_IND_LIST.local_list = []
    CommonUtility.get_ascendc_compiler_path(op_info)
    if global_var_storage.get_variable("ascendc_enable_ccache") == True:
        CommonUtility.remove_options(compile_options, ["-x", "cce"])
    from tbe.common.buildcfg.buildcfg_mapping import op_debug_config
    op_debug_config_val = get_current_build_config(op_debug_config)
    compile_options.append("--cce-disable-kernel-global-attr-check")
    global_var_storage.set_variable("ascendc_enable_super_kernel", False)
    global_var_storage.set_variable("ascendc_sub_super_kernel_params", "")
    global_var_storage.set_variable("ascendc_sub_super_kernel_type", "")
    global_var_storage.set_variable("ascendc_sub_super_kernel_fun_names", {})
    global_var_storage.set_variable("ascendc_compile_debug_config", "dump_cce" in op_debug_config_val)
    global_var_storage.set_variable("ascendc_dump_disable_compile_options", "-DASCENDC_DUMP=0" in compile_options)
    global_var_storage.set_variable("ascendc_debug_compile_options", "-DASCENDC_DEBUG" in compile_options)
    global_var_storage.set_variable("ascendc_enable_sanitizer", is_enable_sanitizer(compile_options))
    global_var_storage.set_variable("ascendc_enable_build_log", is_enable_build_log())
    global_var_storage.set_variable("ascendc_enable_coverage", is_enable_ascendc_cov())
    global_var_storage.set_variable("ascendc_time_stamp_compile_options", "-DASCENDC_TIME_STAMP_ON" in compile_options)
    global_var_storage.set_variable("ascendc_enable_super_kernel", \
      (bool(get_current_build_config("enable_super_kernel")) and CommonUtility.is_v220()))
    if global_var_storage.get_variable("ascendc_enable_super_kernel") is True:
        DFXSectionGenerator().is_support = False
    global_var_storage.set_variable(
        "ascendc_enable_aicore_exception_restart", "-DAICORE_EXCEPTION_RESTART" in compile_options)
    if global_var_storage.get_variable("ascendc_enable_coverage"):
        compile_options.append("-g")
    return compile_options


def compile_op(cce_file: str, origin_func_name: str, op_info: OpInfo, compile_options: list = None,
        code_channel: int = -1, op_compile_option: str = "{}", extend_options: dict = {}):
    """get tiling_data/ generate tiling_data file/ compile cce to .o / generate .json file
    Args:
        cce_file (str): cce file to be compiled
        origin_func_name (str): func_name written by user, without md5
        op_info (OpInfo): operator info
        compile_options (list): compile options for bisheng
        code_channel (int): one of CORE_TYPE_MIX/CORE_TYPE_CUBE/CORE_TYPE_VEC
    """
    # online compile reuses thread, dfx infos need to be reset.
    DFXSectionGenerator().dfx_info_reset(op_info)
    if extend_options.get('opp_kernel_hidden_dat_path', None) is None and not os.path.exists(cce_file):
        raise Exception(f"input cce file is not exists, file name: " + cce_file)

    compile_option_tuple = CompileOptionTuple([] if compile_options is None else compile_options, [])

    _add_op_compile_options_by_customized_json(op_compile_option, compile_option_tuple)

    compile_option_tuple.compile_options = compile_pre_process(op_info, compile_option_tuple.compile_options)

    _update_compile_option(op_info.kernel_name, compile_option_tuple.compile_options, extend_options)

    input_gen_placehoder = _check_if_gen_placehoder(op_info, True)
    output_gen_placehoder = _check_if_gen_placehoder(op_info, False)
    _set_compile_info(op_info)
    kernel_meta_dir = CommonUtility.get_kernel_meta_dir()

    compile_option_tuple.compile_options.append('-DASCENDC_TPL_KERNEL')
    distinct_tag =  CommonUtility.get_distinct_filename_tag()
    compile_log_path = None
    if global_var_storage.get_variable("ascendc_compile_debug_config"):
        compile_log_path = os.path.join(kernel_meta_dir, op_info.kernel_name + distinct_tag + '.log')
    no_kfc_server_flag = False
    # get tilingkeylist and simple infer code_channel
    CommonUtility.print_compile_log(op_info.kernel_name, \
        "precompile to get some simple kernel info...", AscendCLogLevel.LOG_INFO)
    infered_info_from_ifile = KernelInfoInfer.get_tiling_key_list_and_simple_infer_code_channel(cce_file, \
        os.path.join(kernel_meta_dir, op_info.kernel_name + ".i"), \
        compile_option_tuple, compile_log_path, origin_func_name)
    CommonUtility.print_compile_log(op_info.kernel_name, \
        "precompile to get some simple kernel info success", AscendCLogLevel.LOG_INFO)

    tiling_info: TilingInfo = CommonUtility.get_tiling_info_by_tiling(op_info, infered_info_from_ifile)

    CommonUtility.print_compile_log(op_info.kernel_name, "get tiling info success", AscendCLogLevel.LOG_INFO)

    file_name_tag = distinct_tag + "_tiling_data.h"
    tiling_data_file_path = os.path.join(kernel_meta_dir, op_info.kernel_name + file_name_tag)
    tiling_info.save_file(tiling_data_file_path)
    # replace tiling key when tiling_key is set in compile params
    tiling_key_list = infered_info_from_ifile.tiling_key_list
    context_tiling_key = get_context().get_addition("tiling_key")
    if context_tiling_key:
        new_tiling_keys = []
        for tiling_key in context_tiling_key:
            if tiling_key in tiling_key_list:
                new_tiling_keys.append(tiling_key)
            else:
                CommonUtility.print_compile_log(op_info.kernel_name,\
                f"given tiling key {tiling_key} is not in supported tiling_key list", AscendCLogLevel.LOG_WARNING)
        tiling_key_list = new_tiling_keys
        if len(tiling_key_list) == 0:
            msg_info = "None of the given tiling keys are in the supported list."
            LogUtil.log_print(op_info.kernel_name, msg_info, AscendCLogLevel.LOG_WARNING)
            sys.exit(1)
    code_channel = infered_info_from_ifile.code_channel
    hardware_sync_in_asm = False
    # code channel can not infer by .i neet infer by .o
    if code_channel == -1 and infered_info_from_ifile.no_set_kernel_type is True:
        dst_file_header = os.path.join(kernel_meta_dir, op_info.kernel_name + "_infer_channel")
        CommonUtility.print_compile_log(op_info.kernel_name, \
            "get kernel type by infer channel...", AscendCLogLevel.LOG_INFO)
        code_channel, hardware_sync_in_asm = get_code_channel_v220_by_first_tiling_key(
            InferChannelParams(cce_file, dst_file_header, compile_option_tuple, \
                               tiling_key_list[0], tiling_info, \
                               compile_log_path, infered_info_from_ifile.no_kfc_server_flag))
        CommonUtility.print_compile_log(op_info.kernel_name, \
            "get kernel type by infer channel success", AscendCLogLevel.LOG_INFO)

    compile_info = CompileInfo()
    compile_info.src_file = cce_file
    compile_info.dst_file = os.path.join(kernel_meta_dir, op_info.kernel_name + ".o")
    compile_info.kernel_name = op_info.kernel_name
    compile_info.origin_func_name = origin_func_name
    compile_info.op_type = op_info.op_type
    compile_info.code_channel = code_channel
    compile_info.tiling_key_list = tiling_key_list
    compile_info.compile_log_path = compile_log_path
    compile_info.hard_sync = infered_info_from_ifile.hard_sync or hardware_sync_in_asm
    compile_info.enable_deterministic = infered_info_from_ifile.enable_deterministic
    compile_info.tiling_key_kernel_type = infered_info_from_ifile.tiling_key_kernel_type
    compile_info.no_set_kernel_type = infered_info_from_ifile.no_set_kernel_type
    compile_info.default_kernel_type = infered_info_from_ifile.default_kernel_type
    compile_info.dump_info = infered_info_from_ifile.dump_info
    compile_info.template_tiling_info = infered_info_from_ifile.template_tiling_info
    compile_info.tiling_key_struct_map = infered_info_from_ifile.tiling_key_struct_map
    compile_info.super_kernel_early_start_set_flag = infered_info_from_ifile.super_kernel_early_start_set_flag
    compile_info.super_kernel_early_start_wait_flag = infered_info_from_ifile.super_kernel_early_start_wait_flag
    # generate kernel fun for ffts_addr, overflow, workspace
    file_name_tag = distinct_tag + "_kernel.cpp"
    compile_info.gen_kernel_func_file = os.path.join(kernel_meta_dir, op_info.kernel_name + file_name_tag)
    gen_kernel_fun(compile_info, origin_func_name, op_info, tiling_info, compile_option_tuple.compile_options)

    # generate compile option for sub operator, when enable super kernel
    if global_var_storage.get_variable("ascendc_enable_super_kernel") is True:
        gen_sub_super_kernel_compile_options(compile_option_tuple, tiling_info, compile_info)

    # check whether ccec_O0 or ccec_g opend in compile context
    compile_info.is_debug = CommonUtility.check_debug_options(compile_option_tuple.compile_options)
    compile_option_tuple.compile_options.append('-DONE_CORE_DUMP_SIZE=' + str(compile_info.dump_info["dump_size"]))
    if "assert" not in compile_info.dump_info["dump_type"] and "printf" not in compile_info.dump_info["dump_type"]:
        compile_option_tuple.compile_options.append('-DASCENDC_DUMP=0')
        length_before = len(compile_option_tuple.compile_options)
        CommonUtility.remove_options(compile_option_tuple.compile_options, ['-DASCENDC_DUMP', '-DASCENDC_DUMP=1'])
        length_after = len(compile_option_tuple.compile_options)
        if length_before != length_after:
            CommonUtility.print_compile_log(op_info.kernel_name, \
                "-DASCENDC_DUMP=1 is deleted because the feature is not used internally in src file", \
                AscendCLogLevel.LOG_WARNING)

    if global_var_storage.get_variable("ascendc_enable_sanitizer") is False and \
        global_var_storage.get_variable("ascendc_debug_compile_options") is False:
        compile_option_tuple.compile_options.append('-DL2_CACHE_HINT')

    if tiling_info.static_shape_flag:
        compile_option_tuple.compile_options.append('-DCONST_TILING')

    CommonUtility.print_compile_log(op_info.kernel_name, "start to compile cce file...", AscendCLogLevel.LOG_INFO)

    DFXSectionGenerator().generate_dfx_binary(compile_info, op_info, tiling_info)

    if CommonUtility.is_v220():
        if compile_info.no_set_kernel_type is True:
            _compile_ascendc_cce_v220(compile_info, compile_option_tuple, tiling_info)
        else:
            _compile_ascendc_cce_v220_with_kernel_type(compile_info, compile_option_tuple, tiling_info)
    elif CommonUtility.is_regbase():
        _compile_ascendc_cce_regbase(compile_info, compile_option_tuple, tiling_info)
    elif CommonUtility.is_v200() and compile_info.no_set_kernel_type is False:
        _compile_ascendc_cce_v200_with_kernel_type(compile_info, compile_option_tuple, tiling_info)
    else:
        _compile_ascendc_cce(compile_info, compile_option_tuple, tiling_info)
    CommonUtility.print_compile_log(op_info.kernel_name, "compile cce file success", AscendCLogLevel.LOG_INFO)
    if global_var_storage.get_variable("ascendc_enable_sanitizer"):
        _mssanitizer_link(compile_info.dst_file, compile_info.dst_file, compile_info.compile_log_path)
    CommonUtility.print_compile_log(op_info.kernel_name, \
        "start to link relocatable for dst obj...", AscendCLogLevel.LOG_INFO)
    if global_var_storage.get_variable("ascendc_enable_super_kernel") is False:
        link_relocatable(compile_info.dst_file, compile_info.compile_log_path)
    CommonUtility.print_compile_log(op_info.kernel_name, "link relocatable success", AscendCLogLevel.LOG_INFO)
    _json_post_process(compile_info, op_info, tiling_info, input_gen_placehoder, \
                       output_gen_placehoder, compile_log_path)
    if not global_var_storage.get_variable("ascendc_compile_debug_config"):
        tiling_info.remove_file()
        CommonUtility.remove_temp_file(compile_info.gen_kernel_func_file)
    CommonUtility.print_compile_log("", \
        "compile Ascend C operator {} success".format(op_info.op_type), AscendCLogLevel.LOG_INFO)



def _gen_compile_cmd(src_file: str, dst_file: str, compile_option_tuple, tiling_file: str, \
                            with_tiling_file: bool = True):
    """
    Generate the compile command for the v100/v200 compiler.
    :param src_file: the source file
    :param dst_file: the destination file
    :param extra_options: the extra options
    :param with_tiling_file: whether with the tiling file
    :return: the compile command
    """
    jump_expand_flag = '-cce-aicore-jump-expand=true' in compile_option_tuple.compile_options
    compile_cmd = CommonUtility.ascendc_build_aicore_compile_cmd(src_file, dst_file, "")
    if global_var_storage.get_variable("ascendc_enable_ccache") == True:
        compile_cmd = [os.environ.get("ASCENDC_CCACHE_EXECUTABLE")] + compile_cmd
    to_del_idx = []
    for cmd_idx, cmd in enumerate(compile_cmd):
        if '-fcce-vf-vl=256' in cmd:
            to_del_idx.append(cmd_idx - 1)
            to_del_idx.append(cmd_idx)
        if '-cce-aicore-fp-ceiling' in cmd:
            to_del_idx.append(cmd_idx - 1)
            to_del_idx.append(cmd_idx)
        # whether auto sync or not, it should be ascendc`s charge
        elif '--cce-auto-sync' in cmd:
            to_del_idx.append(cmd_idx)
        # if customize set op jump open, then change jump expand setting which was auto generated
        elif (jump_expand_flag or global_var_storage.get_variable("ascendc_enable_sanitizer")) and \
            '-cce-aicore-jump-expand=false' == cmd:
            compile_cmd[cmd_idx] = '-cce-aicore-jump-expand=true'
        elif cmd == 'ccec':
            compile_cmd[cmd_idx] = global_var_storage.get_variable("ascendc_compiler_path")
    for idx in reversed(to_del_idx):
        del compile_cmd[idx]

    # v100 / v200 add stack size compile_cmd = [cmd.replace('16000', '32000') for cmd in compile_cmd]
    compile_cmd_front = compile_cmd[:3]
    compile_cmd_backend = compile_cmd[3:]
    for option in compile_option_tuple.compile_options:
        compile_cmd_front += [option]
    compile_cmd = compile_cmd_front + compile_cmd_backend
    for opt in compile_option_tuple.mllvm_options:
        compile_cmd += [opt]
    if global_var_storage.get_variable("ascendc_enable_sanitizer"):
        compile_cmd += ["--cce-enable-sanitizer", "-g"]
        compile_cmd += ["-mllvm", "-cce-aicore-long-call", "-mllvm", "-cce-aicore-jump-expand=true"]
    if with_tiling_file:
        compile_cmd += ["-include", tiling_file]
    compile_cmd += ["-std=c++17"]
    compile_cmd += ["--cce-mask-opt"]
    if "oom" in get_current_build_config("tir.op_debug_config"):
        compile_cmd += [f"-D{ASCENDC_OOM}={1}"]
    return compile_cmd


def _compile_single_tiling(tiling_key, compile_info, tiling_info, compile_option_tuple):
    dst_file = compile_info.dst_file[:-2] + '_%s.o' % tiling_key
    compile_cmd = _gen_compile_cmd(compile_info.gen_kernel_func_file, dst_file, compile_option_tuple, \
                            tiling_info.tiling_data_file_path)
    compile_cmd += [f"-D{TILING_KEY_MACRO}={tiling_key}UL"]
    compile_cmd += [f"-D{compile_info.origin_func_name}={compile_info.origin_func_name}_{tiling_key}_tilingkey"]
    kernel_func_name = compile_info.kernel_name + '_%s' % tiling_key
    compile_cmd += [f"-Dauto_gen_{compile_info.origin_func_name}_kernel={kernel_func_name}"]
    section_content = DFXSectionGenerator().generate_dfx_section(tiling_key,\
                                                            tiling_info, kernel_func_name, compile_info, True)
    return compile_cmd, section_content


def _compile_ascendc_cce(compile_info: CompileInfo, compile_option_tuple, tiling_info: TilingInfo):
    """call cce-c to compile a AscendC.cce file, generate a binary file and a json file

    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
    """
    sources = CommonUtility().ascendc_read_file(compile_info.gen_kernel_func_file)

    new_sources = sources[:-1]
    if tiling_info.static_shape_flag:
        compile_cmd = _gen_compile_cmd(compile_info.gen_kernel_func_file, compile_info.dst_file, compile_option_tuple, \
                                            tiling_info.tiling_data_file_path)
        # tbe-pass add "__kernel0" in tbe-codegen and json, we use -D to change function name
        compile_cmd += [f"-Dauto_gen_{compile_info.origin_func_name}_kernel={compile_info.get_kernel_func_name()}"]
        compile_cmd += [f"-D{TILING_KEY_MACRO}={tiling_info.tiling_key}UL"]
        new_sources += DFXSectionGenerator().generate_dfx_section(str(tiling_info.tiling_key),\
                                            tiling_info, compile_info.get_kernel_func_name(), compile_info, True)
        new_sources += "#endif\n"
        # add dfx info section to sourse file
        CommonUtility().ascendc_write_file(compile_info.gen_kernel_func_file, new_sources)

        CommonUtility.run_cmd_inner(compile_cmd, CompileStage.COMPILE, compile_info.compile_log_path)
        target = "cce_core"
        tvm_callback_cce_postproc(target, compile_info.kernel_name, tiling_info.block_dim)
    else:
        obj_files = []
        for tiling_key in compile_info.tiling_key_list:
            dst_file = compile_info.dst_file[:-2] + '_%s.o' % tiling_key
            obj_files.append(dst_file)
        cmds_list = []
        for tiling_key in compile_info.tiling_key_list:
            compile_cmd, section_content = \
                    _compile_single_tiling(tiling_key, compile_info, tiling_info, compile_option_tuple)
            cmds_list.append(compile_cmd)
            new_sources += section_content
        new_sources += "#endif\n"
        # add dfx info section to sourse file
        CommonUtility().ascendc_write_file(compile_info.gen_kernel_func_file, new_sources)
        # compile binary
        compile_multi_tilingkey(compile_info.tiling_key_list, cmds_list,\
            os.path.basename(compile_info.dst_file)[:-2], compile_info.compile_log_path)
        fatbin_objs(obj_files, compile_info.dst_file, compile_info.is_debug, compile_info.compile_log_path)
        target = "cce_core"
        tvm_callback_cce_postproc(target, compile_info.kernel_name, tiling_info.block_dim)
        _dynamic_kernel_list_to_json(compile_info.kernel_name, compile_info.tiling_key_list, \
            compile_info.enable_deterministic)


def _gen_mix_json_from_seperate_json(kernel_name: str, task_ration_str: str, core_type: int, no_set_kernel_type: bool):
    kernel_meta_path = CommonUtility.get_kernel_meta_dir()
    core_type_marker = "_mix_aic" if core_type == CORE_TYPE_CUBE else "_mix_aiv"
    seperate_json_path = os.path.join(kernel_meta_path, kernel_name + f'{core_type_marker}.json')
    mix_json_path = os.path.join(kernel_meta_path, kernel_name + '.json')
    os.rename(seperate_json_path, mix_json_path)
    try:
        with open(mix_json_path, 'r') as fd:
            js = json.load(fd)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read json file failed, reason is:", err))
    js['binFileName'] = kernel_name
    js['kernelName'] = kernel_name
    js['coreType'] = 'MIX'
    if no_set_kernel_type is True:
        js['taskRation'] = task_ration_str
    try:
        with open(mix_json_path, 'w') as fd_write:
            os.chmod(mix_json_path, stat.S_IRUSR + stat.S_IWUSR)
            json.dump(js, fd_write, indent=2)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write json file failed, reason is:", err))


def _gen_mix_json_from_seperate_json_for_kernel_type(kernel_name: str, task_ration_str: str,\
    core_type: int, no_set_kernel_type: bool):
    kernel_meta_path = CommonUtility.get_kernel_meta_dir()
    json_path = os.path.join(kernel_meta_path, kernel_name + '.json')
    try:
        with open(json_path, 'r') as fd:
            js = json.load(fd)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read json file failed, reason is:", err))
    js['binFileName'] = kernel_name
    js['kernelName'] = kernel_name
    js['coreType'] = 'MIX'
    if no_set_kernel_type is True:
        js['taskRation'] = task_ration_str
    try:
        with open(json_path, 'w') as fd_write:
            os.chmod(json_path, stat.S_IRUSR + stat.S_IWUSR)
            json.dump(js, fd_write, indent=2)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write json file failed, reason is:", err))


def _dynamic_kernel_list_to_json(kernel_name: str, tiling_key_list: list, enable_deterministic: bool):
    kernel_meta_path = CommonUtility.get_kernel_meta_dir()
    dynamic_kernel_json_path = os.path.join(kernel_meta_path, kernel_name + '.json')
    try:
        with open(dynamic_kernel_json_path, 'r') as fd:
            js = json.load(fd)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read json file failed, reason is:", err))
    js['kernelName'] = kernel_name
    js['kernelList'] = []
    for tiling_key in tiling_key_list:
        if enable_deterministic:
            if get_current_build_config("enable_deterministic_mode") == 1:
                js['kernelList'].append({"deterministic": "true", "kernelName" : kernel_name + '_' + tiling_key})
            else:
                js['kernelList'].append({"deterministic": "false", "kernelName" : kernel_name + '_' + tiling_key})
        else:
            js['kernelList'].append({"kernelName" : kernel_name + '_' + tiling_key})
    try:
        with open(dynamic_kernel_json_path, 'w') as fd_write:
            os.chmod(dynamic_kernel_json_path, stat.S_IRUSR + stat.S_IWUSR)
            json.dump(js, fd_write, indent=2)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write json file failed, reason is:", err))


def _dynamic_regbase_kernel_list_to_json(kernel_name: str, tiling_key_list: list, enable_deterministic: bool,\
    enable_mix_for_profiling: bool):
    kernel_meta_path = CommonUtility.get_kernel_meta_dir()
    dynamic_kernel_json_path = os.path.join(kernel_meta_path, kernel_name + '.json')
    try:
        with open(dynamic_kernel_json_path, 'r') as fd:
            js = json.load(fd)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read json file failed, reason is:", err))
    js['kernelName'] = kernel_name
    js['kernelList'] = []
    js['magic'] = "RT_DEV_BINARY_MAGIC_ELF"
    if enable_mix_for_profiling:
        js['magic'] = "RT_DEV_BINARY_MAGIC_ELF"
    for tiling_key in tiling_key_list:
        if enable_deterministic:
            if get_current_build_config("enable_deterministic_mode") == 1:
                js['kernelList'].append({"deterministic": "true", "kernelName" : kernel_name + '_' + tiling_key})
            else:
                js['kernelList'].append({"deterministic": "false", "kernelName" : kernel_name + '_' + tiling_key})
        else:
            js['kernelList'].append({"kernelName" : kernel_name + '_' + tiling_key})
    try:
        with open(dynamic_kernel_json_path, 'w') as fd_write:
            os.chmod(dynamic_kernel_json_path, stat.S_IRUSR + stat.S_IWUSR)
            json.dump(js, fd_write, indent=2)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write json file failed, reason is:", err))


def _static_regbase_kernel_list_to_json(kernel_name: str):
    kernel_meta_path = CommonUtility.get_kernel_meta_dir()
    kernel_json_path = os.path.join(kernel_meta_path, kernel_name + '.json')
    try:
        with open(kernel_json_path, 'r') as fd:
            js = json.load(fd)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read json file failed, reason is:", err))
    js['magic'] = "RT_DEV_BINARY_MAGIC_ELF"
    try:
        with open(kernel_json_path, 'w') as fd_write:
            os.chmod(kernel_json_path, stat.S_IRUSR + stat.S_IWUSR)
            json.dump(js, fd_write, indent=2)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write json file failed, reason is:", err))

def _get_kernel_type_dict(compile_info: CompileInfo, tiling_key: int):
    kernel_type = compile_info.tiling_key_kernel_type[tiling_key]
    tiling_key_dict = {}
    if kernel_type.value == 0:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "MIX_AIC"
        tiling_key_dict["taskRation"] = "0:1"
        tiling_key_dict["crossCoreSync"] = 0
    elif kernel_type.value == 1:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "MIX_AIC"
        tiling_key_dict["taskRation"] = "1:0"
        tiling_key_dict["crossCoreSync"] = 0
    elif kernel_type.value == 2:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "MIX_AIC"
        tiling_key_dict["crossCoreSync"] = 1
        tiling_key_dict["taskRation"] = "0:1"
    elif kernel_type.value == 3:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "MIX_AIC"
        tiling_key_dict["crossCoreSync"] = 1
        tiling_key_dict["taskRation"] = "1:0"
    elif kernel_type.value == 4:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "MIX_AIC"
        tiling_key_dict["crossCoreSync"] = 1
        tiling_key_dict["taskRation"] = "0:1"
    elif kernel_type.value == 5:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "MIX_AIC"
        tiling_key_dict["crossCoreSync"] = 1
        tiling_key_dict["taskRation"] = "1:0"
    elif kernel_type.value == 6:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "MIX_AIC"
        tiling_key_dict["crossCoreSync"] = 1
        tiling_key_dict["taskRation"] = "1:1"
    elif kernel_type.value == 7:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "MIX_AIC"
        tiling_key_dict["crossCoreSync"] = 1
        tiling_key_dict["taskRation"] = "1:2"
    elif kernel_type.value == 8:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "AiCore"
        tiling_key_dict["taskRation"] = "1:0"
    elif kernel_type.value == 9:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "VectorCore"
        tiling_key_dict["taskRation"] = "0:1"
    elif kernel_type.value == 10:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "MIX_AICORE"
        tiling_key_dict["taskRation"] = "1:1"
    elif kernel_type.value == 11:
        tiling_key_dict["tilingKey"] = int(tiling_key)
        tiling_key_dict["kernelType"] = "MIX_VECTOR_CORE"
        tiling_key_dict["taskRation"] = "1:1"
    else:
        raise Exception(f"current kernel type is not suport {kernel_type}")
    return tiling_key_dict


def _dynamic_kernel_list_to_json_for_kernel_type(compile_info: CompileInfo, \
    kernel_name: str, tiling_key_list: list, enable_deterministic: bool, final_kernel_type: int):
    kernel_meta_path = CommonUtility.get_kernel_meta_dir()
    dynamic_kernel_json_path = os.path.join(kernel_meta_path, kernel_name + '.json')
    try:
        with open(dynamic_kernel_json_path, 'r') as fd:
            js = json.load(fd)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read json file failed, reason is:", err))
    js['kernelName'] = kernel_name
    js['kernelList'] = []
    if final_kernel_type != 0x1 and final_kernel_type != 0x2:
        js['taskRation'] = "tilingKey"
    for tiling_key in tiling_key_list:
        tiling_key_dict = {}
        if final_kernel_type != 0x1 and final_kernel_type != 0x2:
            tiling_key_dict = _get_kernel_type_dict(compile_info, tiling_key)
        if enable_deterministic:
            if get_current_build_config("enable_deterministic_mode") == 1:
                tiling_key_dict["deterministic"] = "true"
                tiling_key_dict["kernelName"] = kernel_name + '_' + tiling_key
                js['kernelList'].append(tiling_key_dict)
            else:
                tiling_key_dict["deterministic"] = "false"
                tiling_key_dict["kernelName"] = kernel_name + '_' + tiling_key
                js['kernelList'].append(tiling_key_dict)
        else:
            tiling_key_dict["kernelName"] = kernel_name + '_' + tiling_key
            js['kernelList'].append(tiling_key_dict)
    try:
        with open(dynamic_kernel_json_path, 'w') as fd_write:
            os.chmod(dynamic_kernel_json_path, stat.S_IRUSR + stat.S_IWUSR)
            json.dump(js, fd_write, indent=2)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write json file failed, reason is:", err))


def _get_sub_kernel_name(compile_info: CompileInfo, core_type: int):
    core_type_marker = "_mix_aic" if core_type == CORE_TYPE_CUBE else "_mix_aiv"
    # i.e. change demo_kernel.o to demo_kernel_mix_aic.o
    sub_kernel_name = compile_info.kernel_name + core_type_marker
    return sub_kernel_name


def _generate_section_content(kernel_name: str, tiling_key: str, \
                            kernel_type: KernelMetaType, tiling_info: TilingInfo, compile_info: CompileInfo):
    if global_var_storage.get_variable("ascendc_enable_super_kernel") is True:
        return ""
    section_content = ""
    section_content += f"\n#if {TILING_KEY_MACRO} == {tiling_key}UL\n"
    section_content += get_ktype_section_variable(f"{kernel_name}_section",
                                                  f"{kernel_name}", kernel_type)
    section_content += f"#endif\n"
    section_content += DFXSectionGenerator().generate_dfx_section(tiling_key, tiling_info, kernel_name, compile_info)
    return section_content


def _get_compile_cmd_and_section_content(compile_info: CompileInfo, arch: str, \
    compile_option_tuple, tiling_info: TilingInfo, tiling_key: str):
    compile_cmd = gen_compile_cmd_v220(compile_info.gen_kernel_func_file, compile_info.dst_file, \
        compile_option_tuple, arch, tiling_info.tiling_data_file_path)
    current_kernel_name = ""
    kernel_type = compile_info.tiling_key_kernel_type[str(tiling_key)]
    if tiling_info.static_shape_flag:
        if kernel_type.value >= 2:
            current_kernel_name = compile_info.kernel_name
            current_kernel_name = gen_sub_kernel_name(current_kernel_name, arch, kernel_type.name,\
                compile_info.dst_file)
            compile_cmd += [f"-Dauto_gen_{compile_info.origin_func_name}_kernel={current_kernel_name}"]
        else:
            current_kernel_name = compile_info.get_kernel_func_name()
            current_kernel_name = gen_sub_kernel_name(current_kernel_name, "AiCore", kernel_type.name,\
                compile_info.dst_file)
            compile_cmd += [f"-Dauto_gen_{compile_info.origin_func_name}_kernel={current_kernel_name}"]
    else:
        if kernel_type.value >= 2:
            current_kernel_name = compile_info.kernel_name[:-7] + tiling_key + compile_info.kernel_name[-8:]
            compile_cmd += [f"-Dauto_gen_{compile_info.origin_func_name}_kernel={current_kernel_name}"]
        else:
            current_kernel_name = compile_info.kernel_name + '_%s' % tiling_key
            compile_cmd += [f"-Dauto_gen_{compile_info.origin_func_name}_kernel={current_kernel_name}"]
    if kernel_type.value >= 6 and kernel_type.value <= 7:
        compile_cmd += [f"-D{MIX_CORE_MACRO}={1}"]
    if kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_1:
        compile_cmd += [f"-D__MIX_CORE_AIC_RATION__=1"]
    compile_cmd += [f"-D{TILING_KEY_MACRO}={tiling_key}UL"]
    compile_cmd += [f"-D{compile_info.origin_func_name}={compile_info.origin_func_name}_{tiling_key}_tilingkey"]
    section_content = _generate_section_content(current_kernel_name, tiling_key, kernel_type, tiling_info, compile_info)
    return compile_cmd, section_content


def _compile_ascendc_cce_v220_with_kernel_type_for_static(compile_info: CompileInfo, \
    compile_option_tuple, tiling_info: TilingInfo):
    """call cce-c to compile a AscendC.cce file, generate a binary file and a json file
       for staic shape
    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
    """
    sources = CommonUtility().ascendc_read_file(compile_info.gen_kernel_func_file)

    new_sources = sources[:-1]
    kernel_type = compile_info.tiling_key_kernel_type[str(tiling_info.tiling_key)]
    if kernel_type in [KernelMetaType.KERNEL_TYPE_MIX_AIC_1_1, KernelMetaType.KERNEL_TYPE_MIX_AIC_1_2]:
        cmds_list = []
        dst_file = compile_info.dst_file
        # build cube
        cube_compile_info = _get_sub_compile_info(compile_info, CORE_TYPE_CUBE)
        arch = "dav-c220-cube"
        compile_cmd, section_content = _get_compile_cmd_and_section_content(cube_compile_info, arch, \
            compile_option_tuple, tiling_info, tiling_info.tiling_key)
        new_sources += section_content
        cmds_list.append(compile_cmd)
        set_soc_spec("AiCore")
        # build vec
        set_soc_spec("VectorCore")
        vec_compile_info = _get_sub_compile_info(compile_info, CORE_TYPE_VEC)
        arch = "dav-c220-vec"
        compile_cmd, section_content = _get_compile_cmd_and_section_content(vec_compile_info, arch, \
            compile_option_tuple, tiling_info, tiling_info.tiling_key)
        new_sources += section_content
        cmds_list.append(compile_cmd)
        new_sources += "#endif\n"
        # add dfx info section to sourse file
        CommonUtility().ascendc_write_file(compile_info.gen_kernel_func_file, new_sources)
        for cmd in cmds_list:
            CommonUtility.run_cmd_inner(cmd, CompileStage.COMPILE, compile_info.compile_log_path)
        # fatbin 2o->1o
        mix_objs = [cube_compile_info.dst_file, vec_compile_info.dst_file]
        if compile_info.enable_final_super_kernel_compile is True:
            compile_info.super_kernel_objs = mix_objs
        else:
            fatbin_objs(mix_objs, dst_file, compile_info.is_debug, compile_info.compile_log_path)
        _gen_mix_sub_json(compile_info, tiling_info, CORE_TYPE_CUBE)
        if kernel_type.value == 6:
            tiling_info.task_ration = 1
        task_ration_str = f"1:{tiling_info.task_ration}"
        _gen_mix_json_from_seperate_json_for_kernel_type(compile_info.kernel_name, task_ration_str, CORE_TYPE_CUBE, \
            True)
        set_soc_spec("AiCore")
    elif kernel_type in [KernelMetaType.KERNEL_TYPE_MIX_AIV_HARD_SYNC, KernelMetaType.KERNEL_TYPE_MIX_AIC_HARD_SYNC, \
            KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0, KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0]:
        if kernel_type in [KernelMetaType.KERNEL_TYPE_MIX_AIC_HARD_SYNC, KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0]:
            arch = f"dav-c220-cube"
            code_type = CORE_TYPE_CUBE
        else:
            arch = f"dav-c220-vec"
            code_type = CORE_TYPE_VEC
        sub_compile_info =  _get_sub_compile_info(compile_info, code_type)
        compile_cmd, section_content = _get_compile_cmd_and_section_content(sub_compile_info, arch, \
            compile_option_tuple, tiling_info, tiling_info.tiling_key)
        new_sources += section_content
        new_sources += "#endif\n"
        # add dfx info section to sourse file
        CommonUtility().ascendc_write_file(compile_info.gen_kernel_func_file, new_sources)
        CommonUtility.run_cmd_inner(compile_cmd, CompileStage.COMPILE, compile_info.compile_log_path)
        _gen_mix_sub_json(sub_compile_info, tiling_info, code_type)
        mix_objs = [sub_compile_info.dst_file]
        if compile_info.enable_final_super_kernel_compile is True:
            compile_info.super_kernel_objs = mix_objs
        else:
            fatbin_objs(mix_objs, compile_info.dst_file, compile_info.is_debug, compile_info.compile_log_path)
        task_ration_str = f"1:0" if code_type == CORE_TYPE_CUBE else f"0:1"
        _gen_mix_json_from_seperate_json(compile_info.kernel_name, task_ration_str, code_type, \
            True)
        set_soc_spec("AiCore")
    elif kernel_type in [KernelMetaType.KERNEL_TYPE_AIV_ONLY, KernelMetaType.KERNEL_TYPE_AIC_ONLY]:
        arch = f"dav-c220-cube" if kernel_type == KernelMetaType.KERNEL_TYPE_AIC_ONLY else f"dav-c220-vec"
        sub_code_type = f"AIC" if kernel_type == KernelMetaType.KERNEL_TYPE_AIC_ONLY else f"AIV"
        optional_core = f"AiCore" if kernel_type == KernelMetaType.KERNEL_TYPE_AIC_ONLY else f"VectorCore"
        set_soc_spec(optional_core)
        compile_cmd, section_content = _get_compile_cmd_and_section_content(compile_info, \
            arch, compile_option_tuple, tiling_info, tiling_info.tiling_key)
        new_sources += section_content
        new_sources += "#endif\n"
        # add dfx info section to sourse file
        CommonUtility().ascendc_write_file(compile_info.gen_kernel_func_file, new_sources)
        CommonUtility.run_cmd_inner(compile_cmd, CompileStage.COMPILE, compile_info.compile_log_path)
        _gen_non_mix_sub_json(compile_info, tiling_info, sub_code_type)


def _generate_final_json(compile_info: CompileInfo, tiling_info: TilingInfo):
    """according to the kernel type of each tiling key, get the finel kernel type
    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        tiling_info (TilingInfo): tiling info
    """
    final_kernel_type = 0
    for tiling_key in compile_info.tiling_key_list:
        kernel_type = compile_info.tiling_key_kernel_type[tiling_key]
        if kernel_type == KernelMetaType.KERNEL_TYPE_AIV_ONLY:
            final_kernel_type = final_kernel_type | 0x1
        elif kernel_type == KernelMetaType.KERNEL_TYPE_AIC_ONLY:
            final_kernel_type = final_kernel_type | 0x2
        elif kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_HARD_SYNC or \
            kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0:
            final_kernel_type = final_kernel_type | 0x4
        else:
            final_kernel_type = final_kernel_type | 0x8
    if final_kernel_type == 0x1:
        sub_core_type = "AIV"
        optional_core = "VectorCore"
        set_soc_spec(optional_core)
        _gen_non_mix_sub_json(compile_info, tiling_info, sub_core_type)
    elif final_kernel_type == 0x2:
        sub_core_type = "AIC"
        optional_core = "AiCore"
        set_soc_spec(optional_core)
        _gen_non_mix_sub_json(compile_info, tiling_info, sub_core_type)
    elif final_kernel_type == 0x4 or final_kernel_type == 0x5:
        set_soc_spec("AiCore")
        _gen_mix_sub_json(compile_info, tiling_info, CORE_TYPE_VEC)
        task_ration_str = f"0:1"
        _gen_mix_json_from_seperate_json_for_kernel_type(compile_info.kernel_name, \
            task_ration_str, CORE_TYPE_VEC, False)
    else:
        set_soc_spec("AiCore")
        _gen_mix_sub_json(compile_info, tiling_info, CORE_TYPE_CUBE)
        task_ration_str = f"1:0"
        _gen_mix_json_from_seperate_json_for_kernel_type(compile_info.kernel_name,\
            task_ration_str, CORE_TYPE_CUBE, False)
    if not tiling_info.static_shape_flag:
        _dynamic_kernel_list_to_json_for_kernel_type(compile_info, compile_info.kernel_name, \
            compile_info.tiling_key_list, compile_info.enable_deterministic, final_kernel_type)


def _compile_ascendc_cce_v220_with_kernel_type_for_dynamic(compile_info: CompileInfo, \
    compile_option_tuple, tiling_info: TilingInfo):
    """call cce-c to compile a AscendC.cce file, generate a binary file and a json file
       for dynamic shape
    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
    """
    raise_error_for_sub_super_kernel()
    sources = CommonUtility().ascendc_read_file(compile_info.gen_kernel_func_file)
    new_sources = sources[:-1]
    obj_files = []
    cmds_list_vec = []
    tiling_key_vec = []
    cmds_list_cube = []
    tiling_key_cube = []
    for tiling_key in compile_info.tiling_key_list:
        kernel_type = compile_info.tiling_key_kernel_type[tiling_key]
        if kernel_type.value >= 6 and kernel_type.value <= 7:
            cube_compile_info = _get_sub_compile_info(compile_info, CORE_TYPE_CUBE)
            cube_compile_info.dst_file = cube_compile_info.dst_file[:-2] + "_%s.o" % tiling_key
            arch = "dav-c220-cube"
            compile_cmd, section_content = _get_compile_cmd_and_section_content(cube_compile_info, arch, \
                compile_option_tuple, tiling_info, tiling_key)
            new_sources += section_content
            cmds_list_cube.append(compile_cmd)
            obj_files.append(cube_compile_info.dst_file)
            tiling_key_cube.append(tiling_key)
            vec_compile_info = _get_sub_compile_info(compile_info, CORE_TYPE_VEC)
            vec_compile_info.dst_file = vec_compile_info.dst_file[:-2] + "_%s.o" % tiling_key
            arch = "dav-c220-vec"
            compile_cmd, section_content = _get_compile_cmd_and_section_content(vec_compile_info, arch, \
                compile_option_tuple, tiling_info, tiling_key)
            new_sources += section_content
            cmds_list_vec.append(compile_cmd)
            obj_files.append(vec_compile_info.dst_file)
            tiling_key_vec.append(tiling_key)
        elif kernel_type.value >= 2 and kernel_type.value <= 5:
            if kernel_type in [KernelMetaType.KERNEL_TYPE_MIX_AIC_HARD_SYNC, KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0]:
                arch = f"dav-c220-cube"
                code_type = CORE_TYPE_CUBE
            else:
                arch = f"dav-c220-vec"
                code_type = CORE_TYPE_VEC
            sub_compile_info =  _get_sub_compile_info(compile_info, code_type)
            sub_compile_info.dst_file = sub_compile_info.dst_file[:-2] + '_%s.o' % tiling_key
            compile_cmd, section_content = _get_compile_cmd_and_section_content(sub_compile_info, arch, \
                compile_option_tuple, tiling_info, tiling_key)
            new_sources += section_content
            if code_type == CORE_TYPE_CUBE:
                cmds_list_cube.append(compile_cmd)
                obj_files.append(sub_compile_info.dst_file)
                tiling_key_cube.append(tiling_key)
            else:
                cmds_list_vec.append(compile_cmd)
                obj_files.append(sub_compile_info.dst_file)
                tiling_key_vec.append(tiling_key)
        elif kernel_type.value >= 0 and kernel_type.value <= 1:
            arch = f"dav-c220-cube" if kernel_type == KernelMetaType.KERNEL_TYPE_AIC_ONLY else f"dav-c220-vec"
            sub_compile_info = copy.deepcopy(compile_info)
            sub_compile_info.dst_file = sub_compile_info.dst_file[:-2] + '_%s.o' % tiling_key
            compile_cmd, section_content = _get_compile_cmd_and_section_content(sub_compile_info, \
                arch, compile_option_tuple, tiling_info, tiling_key)
            new_sources += section_content
            if arch == f"dav-c220-cube":
                cmds_list_cube.append(compile_cmd)
                obj_files.append(sub_compile_info.dst_file)
                tiling_key_cube.append(tiling_key)
            else:
                cmds_list_vec.append(compile_cmd)
                obj_files.append(sub_compile_info.dst_file)
                tiling_key_vec.append(tiling_key)
        else:
            raise Exception(f"current kernel type is not suport {kernel_type}")
    new_sources += "#endif\n"
    # add dfx info section to sourse file
    CommonUtility().ascendc_write_file(compile_info.gen_kernel_func_file, new_sources)

    if len(cmds_list_vec) != 0:
        compile_multi_tilingkey(tiling_key_vec, cmds_list_vec, \
            os.path.basename(compile_info.dst_file)[:-2] + "_tmp_aiv", compile_info.compile_log_path)

    if len(cmds_list_cube) != 0:
        compile_multi_tilingkey(tiling_key_cube, cmds_list_cube, \
            os.path.basename(compile_info.dst_file)[:-2] + "_tmp_aic", compile_info.compile_log_path)
    fatbin_objs(obj_files, compile_info.dst_file, compile_info.is_debug, compile_info.compile_log_path)
    _generate_final_json(compile_info, tiling_info)


def _compile_ascendc_cce_v220_with_kernel_type(compile_info: CompileInfo, compile_option_tuple,\
    tiling_info: TilingInfo):
    """call cce-c to compile a AscendC.cce file, generate a binary file and a json file with kernel type

    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
    """
    if tiling_info.static_shape_flag:
        _compile_ascendc_cce_v220_with_kernel_type_for_static(compile_info, compile_option_tuple, tiling_info)
    else:
        _compile_ascendc_cce_v220_with_kernel_type_for_dynamic(compile_info, compile_option_tuple, tiling_info)


def _compile_ascendc_cce_v200_with_kernel_type_for_static(compile_info: CompileInfo, \
    compile_option_tuple, tiling_info: TilingInfo):
    """call cce-c to compile a AscendC.cce file, generate a binary file and a json file
       for staic shape
    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
    """
    kernel_type = compile_info.tiling_key_kernel_type[str(tiling_info.tiling_key)]
    if kernel_type in \
            [KernelMetaType.KERNEL_TYPE_MIX_AICORE, KernelMetaType.KERNEL_TYPE_MIX_VECTOR_CORE]:
        # build Aicore
        set_soc_spec("AiCore")
        dst_file = compile_info.dst_file
        aicore_compile_info = _get_sub_compile_info(compile_info, CORE_TYPE_CUBE)
        arch = "dav-m200"
        call_bisheng_v200_static(aicore_compile_info, compile_option_tuple, tiling_info, arch,\
            kernel_type)
        # build vector
        set_soc_spec("VectorCore")
        vec_compile_info = _get_sub_compile_info(compile_info, CORE_TYPE_VEC)
        arch = "dav-m200-vec"
        if kernel_type is KernelMetaType.KERNEL_TYPE_MIX_VECTOR_CORE:
            compile_option_tuple.compile_options.append('-D__ENABLE_VECTOR_CORE__')
        call_bisheng_v200_static(vec_compile_info, compile_option_tuple, tiling_info, arch, kernel_type)
        # fatbin 2o->1o
        mix_objs = [aicore_compile_info.dst_file, vec_compile_info.dst_file]
        fatbin_objs(mix_objs, dst_file, compile_info.is_debug, compile_info.compile_log_path)
        # gen main json
        _gen_static_json_for_mix_v200(compile_info, tiling_info, kernel_type)
    elif kernel_type in [KernelMetaType.KERNEL_TYPE_AICORE]:
        arch = "dav-m200"
        set_soc_spec("AiCore")
        call_bisheng_v200_static(compile_info, compile_option_tuple, tiling_info, arch, \
            kernel_type)
        # gen json for v200
        _gen_static_json_for_no_mix_v200(compile_info, tiling_info, kernel_type)
    else:
        raise Exception(f'current kernel core type is not support')
    return


def _compile_ascendc_cce_v200_with_kernel_type_for_dynamic(compile_info: CompileInfo, \
    compile_option_tuple, tiling_info: TilingInfo, final_kernel_type):
    """call cce-c to compile a AscendC.cce file, generate a binary file and a json file
       for dynamic shape
    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
    """
    obj_files = []
    cmds_list_vec = []
    tiling_key_vec = []
    cmds_list_aicore = []
    tiling_key_aicore = []
    sources = CommonUtility().ascendc_read_file(compile_info.gen_kernel_func_file)

    new_sources = sources[:-1]
    for tiling_key in compile_info.tiling_key_list:
        kernel_type = compile_info.tiling_key_kernel_type[tiling_key]
        if kernel_type in \
            [KernelMetaType.KERNEL_TYPE_MIX_AICORE, KernelMetaType.KERNEL_TYPE_MIX_VECTOR_CORE]:
            # build Aicore
            set_soc_spec("AiCore")
            dst_file = compile_info.dst_file
            aicore_compile_info = _get_sub_compile_info(compile_info, CORE_TYPE_CUBE)
            arch = "dav-m200"
            param = SingleTilingKeyCompileParams(tiling_key, aicore_compile_info, arch, \
                                                tiling_info, compile_info.code_channel, compile_option_tuple)
            dst_file, compile_cmd, section_content = call_bisheng_v200_dynamic(param, kernel_type)
            new_sources += section_content
            cmds_list_aicore.append(compile_cmd)
            obj_files.append(dst_file)
            tiling_key_aicore.append(tiling_key)
            # build vector
            set_soc_spec("VectorCore")
            vec_compile_info = _get_sub_compile_info(compile_info, CORE_TYPE_VEC)
            arch = "dav-m200-vec"
            if kernel_type is KernelMetaType.KERNEL_TYPE_MIX_VECTOR_CORE:
                compile_option_tuple.compile_options.append('-D__ENABLE_VECTOR_CORE__')
            param = SingleTilingKeyCompileParams(tiling_key, vec_compile_info, arch, \
                                                tiling_info, compile_info.code_channel, compile_option_tuple)
            dst_file, compile_cmd, section_content = call_bisheng_v200_dynamic(param, kernel_type)
            new_sources += section_content
            cmds_list_vec.append(compile_cmd)
            obj_files.append(dst_file)
            tiling_key_vec.append(tiling_key)
        elif kernel_type in [KernelMetaType.KERNEL_TYPE_AICORE]:
            arch = "dav-m200"
            set_soc_spec("AiCore")
            param = SingleTilingKeyCompileParams(tiling_key, compile_info, arch, \
                                                tiling_info, compile_info.code_channel, compile_option_tuple)
            dst_file, compile_cmd, section_content = call_bisheng_v200_dynamic(param, kernel_type)
            new_sources += section_content
            cmds_list_aicore.append(compile_cmd)
            obj_files.append(dst_file)
            tiling_key_aicore.append(tiling_key)
        else:
            raise Exception(f'current kernel core type is not support')
                # gen main json
    new_sources += "#endif\n"
    # add dfx info section to sourse file
    CommonUtility().ascendc_write_file(compile_info.gen_kernel_func_file, new_sources)

    if len(cmds_list_vec) != 0:
        compile_multi_tilingkey(tiling_key_vec, cmds_list_vec, \
            os.path.basename(compile_info.dst_file)[:-2] + "_tmp_aiv", compile_info.compile_log_path)

    if len(cmds_list_aicore) != 0:
        compile_multi_tilingkey(tiling_key_aicore, cmds_list_aicore, \
            os.path.basename(compile_info.dst_file)[:-2] + "_tmp_aic", compile_info.compile_log_path)

    fatbin_objs(obj_files, compile_info.dst_file, compile_info.is_debug, compile_info.compile_log_path)
    _gen_dynamic_json_for_v200(compile_info, tiling_info, final_kernel_type)
    return


def _compile_ascendc_cce_v200_with_kernel_type(compile_info: CompileInfo,\
                                                compile_option_tuple, tiling_info: TilingInfo):
    """call cce-c to compile a AscendC.cce file, generate a binary file and a json file

    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
    """
    from .ascendc_compile_v200 import judge_valid_for_v200
    final_kernel_type = judge_valid_for_v200(compile_info.tiling_key_kernel_type)
    if tiling_info.static_shape_flag:
        _compile_ascendc_cce_v200_with_kernel_type_for_static(compile_info, compile_option_tuple, tiling_info)
    else:
        _compile_ascendc_cce_v200_with_kernel_type_for_dynamic(compile_info, \
            compile_option_tuple, tiling_info, final_kernel_type)


def _compile_ascendc_cce_v220(compile_info: CompileInfo, compile_option_tuple, tiling_info: TilingInfo):
    """call cce-c to compile a AscendC.cce file, generate a binary file and a json file

    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
    """
    if compile_info.code_channel == CORE_TYPE_MIX:
        # build cube
        set_soc_spec("AiCore")
        dst_file = compile_info.dst_file
        cube_compile_info = _get_sub_compile_info(compile_info, CORE_TYPE_CUBE)
        arch = "dav-c220-cube"
        tiling_key_list = call_bisheng_v220(cube_compile_info, compile_option_tuple, tiling_info, arch,\
            compile_info.code_channel)
        _gen_mix_sub_json(cube_compile_info, tiling_info, CORE_TYPE_CUBE)
        # build vector
        set_soc_spec("VectorCore")
        vec_compile_info = _get_sub_compile_info(compile_info, CORE_TYPE_VEC)
        arch = "dav-c220-vec"
        call_bisheng_v220(vec_compile_info, compile_option_tuple, tiling_info, arch, compile_info.code_channel)
        # fatbin 2o->1o
        mix_objs = [cube_compile_info.dst_file, vec_compile_info.dst_file]
        fatbin_objs(mix_objs, dst_file, compile_info.is_debug, compile_info.compile_log_path)
        # gen main json
        task_ration_str = f"1:{tiling_info.task_ration}"
        _gen_mix_json_from_seperate_json(compile_info.kernel_name, task_ration_str, CORE_TYPE_CUBE, True)
        set_soc_spec("AiCore")
        if not tiling_info.static_shape_flag:
            _dynamic_kernel_list_to_json(compile_info.kernel_name, tiling_key_list, compile_info.enable_deterministic)
    elif compile_info.hard_sync and compile_info.code_channel in [CORE_TYPE_VEC, CORE_TYPE_CUBE]:
        dst_file = compile_info.dst_file
        single_side_compile_info = _get_sub_compile_info(compile_info, compile_info.code_channel)
        arch = "dav-c220-vec" if compile_info.code_channel == CORE_TYPE_VEC else "dav-c220-cube"
        tiling_key_list = call_bisheng_v220(single_side_compile_info, compile_option_tuple, \
            tiling_info, arch, compile_info.code_channel)
        _gen_mix_sub_json(single_side_compile_info, tiling_info, compile_info.code_channel)
        mix_objs = [single_side_compile_info.dst_file]
        fatbin_objs(mix_objs, dst_file, compile_info.is_debug, compile_info.compile_log_path)
        # gen main json
        task_ration_str = f"1:0" if compile_info.code_channel == CORE_TYPE_CUBE else f"0:1"
        _gen_mix_json_from_seperate_json(compile_info.kernel_name, task_ration_str, compile_info.code_channel, True)
        set_soc_spec("AiCore")
        if not tiling_info.static_shape_flag:
            _dynamic_kernel_list_to_json(compile_info.kernel_name, tiling_key_list, compile_info.enable_deterministic)
    else:
        if compile_info.code_channel == CORE_TYPE_CUBE:
            arch = "dav-c220-cube"
            sub_core_type = "AIC"
            optional_core = "AiCore"
        elif compile_info.code_channel == CORE_TYPE_VEC:
            arch = "dav-c220-vec"
            sub_core_type = "AIV"
            optional_core = "VectorCore"  # do the same work with SetOptionalCoreType in cpp
        else:
            raise Exception(f"invalid code_channel = {compile_info.code_channel}")
        set_soc_spec(optional_core)
        tiling_key_list = call_bisheng_v220(compile_info, compile_option_tuple, tiling_info, arch, \
            compile_info.code_channel)
        _gen_non_mix_sub_json(compile_info, tiling_info, sub_core_type)
        if not tiling_info.static_shape_flag:
            _dynamic_kernel_list_to_json(compile_info.kernel_name, tiling_key_list, compile_info.enable_deterministic)


def _compile_ascendc_cce_regbase(compile_info: CompileInfo, compile_option_tuple, tiling_info: TilingInfo):
    """call cce-c to compile a AscendC.cce file, generate a binary file and a json file

    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
    """
    soc_arch_map = {"Ascend310B": "dav-m300", "Ascend610Lite": "dav-m310"}
    arch = soc_arch_map.get(get_soc_spec("SHORT_SOC_VERSION"))
    value = get_soc_spec("cube_vector_combine")
    value_str_list = value.split(",")
    enable_mix_for_profiling = False
    if value_str_list[0] == 'unknown' or ("fuse" in value_str_list and len(value_str_list)) == 1:
        enable_mix_for_profiling = True
    if enable_mix_for_profiling:
        sub_core_type = "AIC"
        optional_core = "AiCore"
    else:
        sub_core_type = "AIV"
        optional_core = "VectorCore"  # do the same work with SetOptionalCoreType in cpp
    set_soc_spec(optional_core)
    tiling_key_list = _call_bisheng_regbase(compile_info, compile_option_tuple, tiling_info, arch, \
        compile_info.code_channel)
    _gen_non_mix_sub_json(compile_info, tiling_info, sub_core_type)
    if not tiling_info.static_shape_flag:
        _dynamic_regbase_kernel_list_to_json(compile_info.kernel_name, tiling_key_list, \
            compile_info.enable_deterministic, enable_mix_for_profiling)
    else:
        _static_regbase_kernel_list_to_json(compile_info.kernel_name)


def _get_sub_compile_info(compile_info: CompileInfo, core_type: int):
    sub_compile_info = copy.deepcopy(compile_info)
    core_type_marker = "_mix_aic" if core_type == CORE_TYPE_CUBE else "_mix_aiv"
    # i.e. change demo_kernel.o to demo_kernel_mix_aic.o
    sub_compile_info.dst_file = compile_info.dst_file[:-2] + core_type_marker + compile_info.dst_file[-2:]
    sub_compile_info.kernel_name = compile_info.kernel_name + core_type_marker
    sub_compile_info.sub_core_type = core_type
    return sub_compile_info


def _gen_compile_cmd_regbase(src_file: str, dst_file: str, compile_option_tuple, sub_arch: str, tiling_file: str,\
                                         with_tiling_file: bool = True):
    """
    Generate the compile command for the V300 compiler.
    :param src_file: the source file
    :param dst_file: the destination file
    :param extra_options: the extra options
    :param with_tiling_file: whether with the tiling file
    :return: the compile command
    """
    if global_var_storage.get_variable("ascendc_enable_ccache") == True:
        compile_cmd = [os.environ.get("ASCENDC_CCACHE_EXECUTABLE"), \
            global_var_storage.get_variable("ascendc_compiler_path"), '-c', '-O3']
    else:
        compile_cmd = [global_var_storage.get_variable("ascendc_compiler_path"), '-c', '-O3']

    for option in compile_option_tuple.compile_options:
        compile_cmd += [option]
    compile_cmd += [src_file, "--cce-aicore-arch=%s" % sub_arch,
                    "--cce-aicore-only", "-o", dst_file,
                    "-mllvm", "-cce-aicore-function-stack-size=16000",
                    "-mllvm", "-cce-aicore-addr-transform",
                    "-mllvm", "--cce-aicore-or-combine=false",
                    "-mllvm", "-instcombine-code-sinking=false",
                    "-mllvm", "-cce-aicore-jump-expand=false",
                    "-mllvm", "-cce-aicore-mask-opt=false"]
    for opt in compile_option_tuple.mllvm_options:
        compile_cmd += [opt]

    if with_tiling_file:
        compile_cmd += ["-include", tiling_file]
    compile_cmd += ["-std=c++17"]
    if "oom" in get_current_build_config("tir.op_debug_config"):
        compile_cmd += [f"-D{ASCENDC_OOM}={1}"]
    return compile_cmd


def _compile_single_tiling_regbase(param : SingleTilingKeyCompileParams):
    dst_file = param.compile_info.dst_file[:-2] + '_%s.o' % param.tiling_key
    compile_cmd = _gen_compile_cmd_regbase(param.compile_info.gen_kernel_func_file, dst_file, \
                                               param.compile_option_tuple, param.sub_arch, \
                                               param.tiling_info.tiling_data_file_path)
    compile_cmd += [f"-D{TILING_KEY_MACRO}={param.tiling_key}UL"]
    compile_cmd += \
        [f"-D{param.compile_info.origin_func_name}={param.compile_info.origin_func_name}_{param.tiling_key}_tilingkey"]
    kernel_func_name = param.compile_info.kernel_name + '_%s' % param.tiling_key
    compile_cmd += [f"-Dauto_gen_{param.compile_info.origin_func_name}_kernel={kernel_func_name}"]
    return compile_cmd


def _mssanitizer_link(src_file, dst_file, compile_log_path=None):
    """Build the mssanitize link command before link.
    Parameters
    ----------
    src_file : str
        The src object file.

    dst_file : str
        The dst object file.
    """
    short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
    if short_soc_version not in global_var_storage.get_variable("ascendc_asan_obj_path"):
        raise Exception("asan config file not support asan.a path")
    if not isinstance(src_file, list):
        src_file = [src_file]
    cmd = [CCECInfo.get_exe("ld.lld"), "-m", "aicorelinux", "-r", "-Ttext=0"]
    cmd.extend(src_file)
    cmd.extend(['--dependent-libraries'])
    cmd.extend(global_var_storage.get_variable("ascendc_asan_obj_path")[short_soc_version])
    cmd.extend([
        "-r",
        "-o",
        "%s" % dst_file,
        ])
    CommonUtility.run_cmd_inner(cmd, CompileStage.FATBIN, compile_log_path)


def _call_bisheng_regbase(compile_info: CompileInfo, compile_option_tuple, tiling_info: TilingInfo, sub_arch: str,\
    code_channel: int):
    """generate bisheng cmd instead of _build_aicore_compile_cmd, since tbe set davinci-m300-{sub_core} in build_cce.cc

    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
        sub_arch (str): m300 arch info
    """
    if tiling_info.static_shape_flag:
        compile_cmd = _gen_compile_cmd(compile_info.gen_kernel_func_file, compile_info.dst_file, compile_option_tuple, \
                                       tiling_info.tiling_data_file_path)
        # tbe-pass add "__kernel0" in tbe-codegen and json, we use -D to change function name
        compile_cmd += [f"-Dauto_gen_{compile_info.origin_func_name}_kernel={compile_info.get_kernel_func_name()}"]
        compile_cmd += [f"-D{TILING_KEY_MACRO}={tiling_info.tiling_key}UL"]
        CommonUtility.run_cmd_inner(compile_cmd, CompileStage.COMPILE, compile_info.compile_log_path)
        target = "cce_core"
        core_type_info = {var("core_type"): var("")}

        tvm_callback_cce_postproc(target, compile_info.kernel_name, tiling_info.block_dim, \
                                    0, "", None, None, core_type_info, None, None, False, 1, None, None)
    else:
        obj_files = []
        for tiling_key in compile_info.tiling_key_list:
            dst_file = compile_info.dst_file[:-2] + '_%s.o' % tiling_key
            obj_files.append(dst_file)
        cmds_list = []
        for tiling_key in compile_info.tiling_key_list:
            param = SingleTilingKeyCompileParams(\
                tiling_key, compile_info, sub_arch, tiling_info, code_channel, compile_option_tuple)
            cmds_list.append(_compile_single_tiling_regbase(param))
        compile_multi_tilingkey(compile_info.tiling_key_list, cmds_list, \
            os.path.basename(compile_info.dst_file)[:-2], compile_info.compile_log_path)
        fatbin_objs(obj_files, compile_info.dst_file, compile_info.is_debug, compile_info.compile_log_path)
        return compile_info.tiling_key_list


def _gen_mix_sub_json(compile_info: CompileInfo, tiling_info: TilingInfo, core_type: int = CORE_TYPE_CUBE):
    """generate cube/vector json file in code_channel_mix

    Args:
        compile_info (CompileInfo): compile variables to call bisheng
        tiling_info (TilingInfo): variables got from tiling
    """
    target = "cce_core"
    # in tik1 and tbe, we user "parameters" in json file to tell rts initialization workspace data
    # in AscendC, operator developers do initialization work, so atomic_args should be empty
    atomic_args = ""
    # json info is used to infer "pragma_json_info_deterministic", AscendC not supported
    json_info = {}
    json_info_tuple = {}
    # core_type_info, should be "" in code_channel_mix
    core_type_info = {var("core_type"): var("")}
    # kernel_list and kernel_list_deterministic is for fatbin
    kernel_list = None
    kernel_list_deterministic = None
    # AscendC mix-channel need ffts sync, tbe use MultiCoreSync visit stmt to find if exists op->call_name == "st_dev"
    is_ffts_id_needed = True
    subblockdim: int = tiling_info.task_ration
    # AscendC only support cube:vector = 1:1 or 1:2, so mix_type should be kAicMix
    mix: str = "MIX"
    mix_type_info: str = "aic_mix" if core_type == CORE_TYPE_CUBE else "aiv_mix"
    tvm_callback_cce_postproc(target, compile_info.kernel_name, tiling_info.block_dim,
                              0,
                              atomic_args,
                              json_info, json_info_tuple,
                              core_type_info, kernel_list, kernel_list_deterministic, is_ffts_id_needed,
                              subblockdim, mix, mix_type_info)


def _gen_non_mix_sub_json(compile_info: CompileInfo, tiling_info: TilingInfo, sub_core_type: str):
    """generate json file if operator code only has cube or vector code in v220

    Args:
        compile_info (CompileInfo): compile variables to call bisheng
        tiling_info (TilingInfo): variables got from tiling
        sub_core_type (str): core_type_info, should be AIV/AIC in code_channel_aiv/aic
    """
    target = "cce_core"
    # in tik1 and tbe, we user "parameters" in json file to tell rts initialization workspace data
    # in AscendC, operator developers do initialization work, so atomic_args should be empty
    atomic_args = ""
    # json info is used to infer "pragma_json_info_deterministic", AscendC not supported
    json_info = {}
    json_info_tuple = {}
    core_type_info = {var("core_type"): var(sub_core_type)}
    # kernel_list and kernel_list_deterministic is for fatbin
    kernel_list = None
    kernel_list_deterministic = None
    is_ffts_id_needed = False
    subblockdim: int = tiling_info.task_ration
    # AscendC only support cube:vector = 1:1 or 1:2, so mix_type should be kAicMix
    mix: str = ""
    mix_type_info: str = ""
    tvm_callback_cce_postproc(target, compile_info.kernel_name, tiling_info.block_dim, 0,
                              atomic_args, json_info, json_info_tuple,
                              core_type_info, kernel_list, kernel_list_deterministic, is_ffts_id_needed,
                              subblockdim, mix, mix_type_info)


def _gen_static_json_for_no_mix_v200(compile_info: CompileInfo, tiling_info: TilingInfo, kernel_type):
    target = "cce_core"
    tvm_callback_cce_postproc(target, compile_info.kernel_name, tiling_info.block_dim)
    # if enable_vector_core, json has _mix_aic suffix
    if get_current_build_config(enable_vector_core):
        kernel_meta_path = CommonUtility.get_kernel_meta_dir()
        kernel_name = compile_info.kernel_name
        kernel_json_path = os.path.join(kernel_meta_path, kernel_name + '.json')
        core_type_marker = "_mix_aic" if kernel_type is KernelMetaType.KERNEL_TYPE_AICORE else "_mix_aiv"
        seperate_json_path = os.path.join(kernel_meta_path, kernel_name + f'{core_type_marker}.json')
        os.rename(seperate_json_path, kernel_json_path)


def _gen_static_json_for_mix_v200(compile_info: CompileInfo, tiling_info: TilingInfo, kernel_type):
    set_soc_spec("AiCore")
    target = "cce_core"
    tvm_callback_cce_postproc(target, compile_info.kernel_name, tiling_info.block_dim)

    kernel_meta_path = CommonUtility.get_kernel_meta_dir()
    kernel_name = compile_info.kernel_name
    kernel_json_path = os.path.join(kernel_meta_path, kernel_name + '.json')

    # if enable_vector_core, json has _mix_aic suffix
    if get_current_build_config(enable_vector_core):
        core_type_marker = "_mix_aic"
        seperate_json_path = os.path.join(kernel_meta_path, kernel_name + f'{core_type_marker}.json')
        os.rename(seperate_json_path, kernel_json_path)

    try:
        with open(kernel_json_path, 'r') as fd:
            js = json.load(fd)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read json file failed, reason is:", err))
    js['binFileName'] = kernel_name
    js['kernelName'] = kernel_name
    if kernel_type is KernelMetaType.KERNEL_TYPE_MIX_AICORE:
        js['coreType'] = 'MIX_AICORE'
    elif kernel_type is KernelMetaType.KERNEL_TYPE_MIX_VECTOR_CORE:
        js['coreType'] = 'MIX_VECTOR_CORE'
    else:
        raise Exception(f'kernel_type is not support')
    try:
        with open(kernel_json_path, 'w') as fd_write:
            json.dump(js, fd_write, indent=2)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write json file failed, reason is:", err))


def _gen_dynamic_json_for_v200(compile_info: CompileInfo, tiling_info: TilingInfo, final_kernel_type: str):
    """according to the kernel type of each tiling key, get the finel kernel type
    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        tiling_info (TilingInfo): tiling info
    """
    if final_kernel_type == "VectorCore":
        set_soc_spec("VectorCore")
    else:
        set_soc_spec("AiCore")
    target = "cce_core"
    tvm_callback_cce_postproc(target, compile_info.kernel_name, tiling_info.block_dim)
    kernel_meta_path = CommonUtility.get_kernel_meta_dir()
    kernel_name = compile_info.kernel_name
    kernel_json_path = os.path.join(kernel_meta_path, kernel_name + '.json')

    # if enable_vector_core, json has _mix_aic suffix
    if get_current_build_config(enable_vector_core):
        core_type_marker = "_mix_aic"
        seperate_json_path = os.path.join(kernel_meta_path, kernel_name + f'{core_type_marker}.json')
        os.rename(seperate_json_path, kernel_json_path)
    try:
        with open(kernel_json_path, 'r') as fd:
            js = json.load(fd)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("read json file failed, reason is:", err))

    js['binFileName'] = kernel_name
    js['kernelName'] = kernel_name
    js['coreType'] = final_kernel_type

    try:
        with open(kernel_json_path, 'w') as fd_write:
            json.dump(js, fd_write, indent=2)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write json file failed, reason is:", err))

    _dynamic_kernel_list_to_json_for_kernel_type(compile_info, compile_info.kernel_name, \
            compile_info.tiling_key_list, compile_info.enable_deterministic, final_kernel_type)


def replay_op(op_info: OpInfo, entry_obj: str, code_channel: int, src_file: str, compile_options: list):
    """replay_op feature is at sunset
    """
    return True, "success"


def get_code_channel(src_file: str, kernel_name: str, optype: str, compile_options_input: list = None):
    # replay function needs, so it is reserved
    return CORE_TYPE_MIX


def _is_hard_sync_instr(inst: str):
    if inst[6:] != '41':
        return False
    if inst[4] == 'e' and (int(inst[5], 16) & 0x4 == 0x4):
        # WAIT_FLAG_DEV -> wait_flag_dev
        return True
    if inst[4] == 'f' and (int(inst[5], 16) & 0x8 == 0x0):
        # SET_CROSS_CORE -> ffts_cross_core_sync
        return True
    return False


def v220_mode(inst) -> int:
    if len(inst) != 8:
        return 0
    if inst[6] == 'f' or inst[6] == 'c':
        # inst[6] == 'f' means MATRIX and inst[6] == 'c' means FIXP
        return CORE_TYPE_CUBE
    elif inst[6] == '8' or inst[6] == '9':
        is_move_mask = (inst[4] == '4' and inst[5] == '0' and inst[6] == '8' and inst[7] == '0')
        if is_move_mask:
            return 0
        # SIMD INST
        return CORE_TYPE_VEC
    # DMA MOVE
    elif inst[6] == '6':
        if inst[7] == 'b' and (int(inst[4], 16) & 0x8) == 0x8:
            # MOV_{SRC}_TO_{DST}_ALIGN
            return CORE_TYPE_VEC
        else:
            # MOV_CUB1
            return CORE_TYPE_CUBE
    # DMA MOVE
    elif inst[6] == '7':
        if inst[7] == '0' and (int(inst[4], 16) & 0x8) == 0x8:
            # MOV_UB_TO_XX
            return CORE_TYPE_VEC
        elif (int(inst[0], 16) & 0x7) == 0 and (int(inst[1], 16) & 0x8) == 0x8:
            # MOV_XX_TO_UB
            return CORE_TYPE_VEC
        else:
            # MOV_CUB2
            return CORE_TYPE_CUBE
    # SCALAR
    return 0


def decode_mode(mode) -> int:
    # 3 means insts contain cube and vector instruct
    if mode == 3:
        return CORE_TYPE_MIX
    # 0 means insts is scalar instruct
    elif mode == 0:
        return CORE_TYPE_VEC
    else:
        return mode


def get_code_channel_v220_by_first_tiling_key(params: InferChannelParams):
    if params.tiling_info.static_shape_flag:
        # static shape use tiling_key itself
        infer_tiling_key = f'{params.tiling_info.tiling_key}'
    else:
        # dynamic shape use first tiling_key
        infer_tiling_key = params.tiling_key
    hardware_sync_in_asm = False
    mode = 0
    for arch in ["dav-c220-cube", "dav-c220-vec"]:
        dst_file = params.dst_file_header + f'_{arch}_{params.tiling_key}.o'
        compile_cmd = gen_compile_cmd_v220(params.src_file, dst_file, params.compile_option_tuple, \
                                            arch, params.tiling_info.tiling_data_file_path)
        compile_cmd += [f"-D{TILING_KEY_MACRO}={infer_tiling_key}UL", "-DASCENDC_DUMP=0", "-UASCENDC_ACC_DUMP"]
        CommonUtility.remove_options(compile_cmd, ['-DASCENDC_DUMP', '-DASCENDC_DUMP=1'])
        compile_cmd += [f"-D__GET_CODE_CHANNEL__"]
        if arch == 'dav-c220-vec' and params.no_kfc_server_flag:
            compile_cmd += [f"-D__NO_KFC_SERVER__"]
        CommonUtility.dump_compile_log(compile_cmd, CompileStage.INFERCHANNEL, params.compile_log_path)
        proc = subprocess.Popen(
            compile_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        (out, _) = proc.communicate()
        CommonUtility.dump_build_log(out.decode(), compile_cmd, CompileStage.INFERCHANNEL, proc.returncode)
        objdump_cmd = ['llvm-objdump', '-s', '-j', '.text', '{}'.format(dst_file)]

        CommonUtility.dump_compile_log(objdump_cmd, CompileStage.INFERCHANNEL, params.compile_log_path)
        proc = subprocess.Popen(
            objdump_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        (out, _) = proc.communicate()
        CommonUtility.dump_build_log(out.decode(), objdump_cmd, CompileStage.INFERCHANNEL, proc.returncode)

        os.chmod(dst_file, stat.S_IRUSR | stat.S_IWUSR)
        if not global_var_storage.get_variable("ascendc_compile_debug_config"):
            os.remove(dst_file)
        lines = out.decode('utf-8').split('\n')
        for line in lines:
            insts = line.strip().split()
            if len(insts) < 5:
                continue
            for inst in insts[1: 5]:
                hardware_sync_in_asm = hardware_sync_in_asm or _is_hard_sync_instr(inst)
                mode |= v220_mode(inst)
    code_channel = decode_mode(mode)
    return code_channel, hardware_sync_in_asm