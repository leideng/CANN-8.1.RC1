#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
ascendc super kernel
"""
import os
import stat
import json
import re
import subprocess
import math
import shutil
from contextlib import contextmanager
from tbe.tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE
from .compile_op import compile_op, OpInfo, KernelMetaType, STR_TO_KERNEL_TYPE_V220, super_kernel_compile
from .log_utils import LogUtil, AscendCLogLevel, LOG_LEVEL_TO_STR, CompileStage
from .ascendc_common_utility import CommonUtility
from .ascendc_constants import SuperKernelLinkMode, SuperKernelPreLoadMode, SuperKernelDataCacheMode,\
    SuperKernelEarlyStartMode
from .ascendc_compile_gen_code import gen_init_dump_code


def indent_code_func(code: str, indent: str = '    '):
    """Indent non-empty lines."""
    # use `(?=)' for lookahead assertion, see re module document.
    return re.sub(r'^(?=.+)', indent, code, flags=re.MULTILINE)


@contextmanager
def change_dir(path):
    original_dir = os.getcwd()
    try:
        os.chdir(path)
        yield
    finally:
        os.chdir(original_dir)


class SubOperatorInfos:
    def __init__(self, index, info_dict):
        keys_list = list(info_dict.keys())
        self.json_path: str = info_dict["json_path"]
        self.bin_path: list = info_dict["bin_path"]
        self.index: int = index
        try:
            with open(self.json_path, 'r') as fd:
                sub_operater_infos = json.load(fd)
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, \
                (f"read sub op json file failed, json name {self.json_path}, reason is:", err))

        self.kernel_name:str = sub_operater_infos["kernelName"]
        self.called_kernel_name: dict = sub_operater_infos["sub_operator_kernel_name"]
        self.origin_kernel_type_str: str = sub_operater_infos["sub_operator_kernel_type"]
        self.kernel_type: KernelMetaType = STR_TO_KERNEL_TYPE_V220[self.origin_kernel_type_str]
        self.block_dim: int = sub_operater_infos["blockDim"]
        self.timestamp_option: bool = "timestamp" in sub_operater_infos.get("debugOptions", "") \
                    or "printf" in sub_operater_infos.get("debugOptions", "")
        self.kernel_params : list = [param + f"_{self.index}" for param in sub_operater_infos["sub_operator_params"]]
        self.kernel_declare : str = ""
        self.kernel_call_block: str = ""
        self.preload_call_block: str = ""
        self.early_start_complement_set_flag_block: str = ""
        self.early_start_complement_wait_flag_block: str = ""
        self.early_start_set_flag: bool = sub_operater_infos['sub_operator_early_start_set_flag']
        self.early_start_wait_flag: bool = sub_operater_infos['sub_operator_early_start_wait_flag']
        self.aiv_bin: str = None
        self.aic_bin: str = None
        self.aiv_text_len: int = 0
        self.aic_text_len: int = 0
        self.data_cache_preload_call: str = ""
        self.sub_kernel_names: list = []
        self.extract_sub_op_bin_files()
        self.gen_sub_kernel_declare_and_call_func()

    def get_text_section_size(self, binary_file):
        command = ['llvm-objdump', '-h', binary_file]
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        if result.returncode != 0:
            CommonUtility.print_compile_log("", \
                f"The binary {binary_file} of {self.kernel_name} decode .text Error: {result.stderr}",\
                     AscendCLogLevel.LOG_WARNING)
            return 0

        for line in result.stdout.splitlines():
            if '.text' in line:
                parts = line.split()
                if len(parts) >= 4:
                    size = int(parts[2], 16)
                    return min(size, 2048 * 8)

        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, \
                        (f"The binary {binary_file} of {self.kernel_name} do not found .text section"))
        return 0

    def extract_sub_bin_file_of_mix_kernel(self, base_directory, aiv_bin_file_name, aic_bin_file_name):
        with change_dir(base_directory):
            try:
                subprocess.run(['ar', 'x', self.bin_path])
                subprocess.run(['mv', '-f', './' + aiv_bin_file_name, base_directory + "/"])
                subprocess.run(['mv', '-f', './' + aic_bin_file_name, base_directory + "/"])
            except Exception as err:
                raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("ar extract files or mv files failed", err))

    def extract_sub_op_bin_files(self):
        if self.kernel_type == KernelMetaType.KERNEL_TYPE_AIV_ONLY or\
            self.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0:
            self.aiv_bin = self.bin_path
            self.aiv_text_len = self.get_text_section_size(self.aiv_bin)
        elif self.kernel_type == KernelMetaType.KERNEL_TYPE_AIC_ONLY or\
            self.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0:
            self.aic_bin = self.bin_path
            self.aic_text_len = self.get_text_section_size(self.aic_bin)
        elif self.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_1 or\
            self.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_2:
            base_directory = os.path.dirname(self.bin_path)
            aiv_bin_file_name = os.path.basename(self.called_kernel_name["dav-c220-vec"]["obj_files"])
            aic_bin_file_name = os.path.basename(self.called_kernel_name["dav-c220-cube"]["obj_files"])
            self.extract_sub_bin_file_of_mix_kernel(base_directory, aiv_bin_file_name, aic_bin_file_name)
            self.aiv_bin = os.path.join(base_directory, aiv_bin_file_name)
            self.aiv_text_len = self.get_text_section_size(self.aiv_bin)
            self.aic_bin = os.path.join(base_directory, aic_bin_file_name)
            self.aic_text_len = self.get_text_section_size(self.aic_bin)

    def gen_call_func(self, indent_code, core_type, block_type, sub_block: bool = True):
        vector_call_func_block = f"if {core_type} {{\n"
        vector_call_func_block += f"    if ({block_type}() < {self.block_dim}) {{\n"
        vector_call_func_block += indent_code_func(indent_code, "        ")
        vector_call_func_block += "    }\n"
        vector_call_func_block += "}\n\n"
        return vector_call_func_block

    def gen_early_start_complement_func(self, core_type, condition_code, gen_set_flag: bool, sub_block: bool = True):
        vector_call_func_block = f"if {core_type} {{\n"
        vector_call_func_block += f"    if ({condition_code}) {{\n"
        if gen_set_flag:
            vector_call_func_block += f"        AscendC::SetNextTaskStart();\n"
        else:
            vector_call_func_block += f"        AscendC::WaitPreTaskEnd();\n"
        vector_call_func_block += "    }\n"
        vector_call_func_block += "}\n\n"
        return vector_call_func_block

    def set_early_start_complement_blocks(self, core_type, condition_code, sub_block: bool = True):
        if self.early_start_set_flag:
            self.early_start_complement_set_flag_block += \
                self.gen_early_start_complement_func(core_type, condition_code, True, sub_block)
        else:
            self.early_start_complement_set_flag_block += \
                self.gen_early_start_complement_func(core_type, "true", True, sub_block)

        if self.early_start_wait_flag:
            self.early_start_complement_wait_flag_block += \
                self.gen_early_start_complement_func(core_type, condition_code, False, sub_block)
        else:
            self.early_start_complement_wait_flag_block += \
                self.gen_early_start_complement_func(core_type, "true", False, sub_block)
        return

    def gen_sub_kernel_declare_and_call_func(self):
        params_with_type = ', '.join([f"GM_ADDR {param}" for param in self.kernel_params])

        #generate date cache preload for sub operator
        self.data_cache_preload_call += f"// begin add dc preload of sub_operator: {self.kernel_name}\n"
        len_of_param = len(self.kernel_params)
        if self.index == 0:
            len_of_param += 1
        for index in range(0, len_of_param, 8):
            self.data_cache_preload_call += f"dc_preload((__gm__ uint64_t *)(param_base), 0); \n"
            self.data_cache_preload_call += f"param_base += {min(8, len_of_param - index)}; \n"

        if self.kernel_type == KernelMetaType.KERNEL_TYPE_AIV_ONLY:
            aicore_kernel_name = self.called_kernel_name["AiCore"]["func_name"]
            self.sub_kernel_names.append(aicore_kernel_name)
            self.kernel_declare = f"extern \"C\"  __aicore__ void {aicore_kernel_name}({params_with_type});\n\n"
            params = ', '.join([f"{param}" for param in self.kernel_params])
            func_call = f"{aicore_kernel_name}({params});\n"
            self.kernel_call_block = self.gen_call_func(func_call, "ASCEND_IS_AIV", "AscendC::GetBlockIdx")
            preload_call_block = \
                f"preload((const void *){aicore_kernel_name}, {math.ceil(self.aiv_text_len / 2048)});\n"
            self.preload_call_block = self.gen_call_func(preload_call_block, "ASCEND_IS_AIV", "AscendC::GetBlockIdx")
            self.set_early_start_complement_blocks("ASCEND_IS_AIV", f"AscendC::GetBlockIdx() >= {self.block_dim}")
            self.set_early_start_complement_blocks("ASCEND_IS_AIC", "true")
        elif self.kernel_type == KernelMetaType.KERNEL_TYPE_AIC_ONLY:
            aicore_kernel_name = self.called_kernel_name["AiCore"]["func_name"]
            self.sub_kernel_names.append(aicore_kernel_name)
            self.kernel_declare = f"extern \"C\"  __aicore__ void {aicore_kernel_name}({params_with_type});\n\n"
            params = ', '.join([f"{param}" for param in self.kernel_params])
            func_call = f"{aicore_kernel_name}({params});\n"
            self.kernel_call_block = self.gen_call_func(func_call, "ASCEND_IS_AIC", "get_block_idx")
            preload_call_block = \
                f"preload((const void *){aicore_kernel_name}, {math.ceil(self.aic_text_len / 2048)});\n"
            self.preload_call_block = self.gen_call_func(preload_call_block, "ASCEND_IS_AIC", "get_block_idx")
            self.set_early_start_complement_blocks("ASCEND_IS_AIC", f"get_block_idx() >= {self.block_dim}")
            self.set_early_start_complement_blocks("ASCEND_IS_AIV", "true")
        elif self.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0:
            aicore_kernel_name = self.called_kernel_name["dav-c220-vec"]["func_name"]
            self.sub_kernel_names.append(aicore_kernel_name)
            self.kernel_declare = f"extern \"C\"  __aicore__ void {aicore_kernel_name}({params_with_type});\n\n"
            params = ', '.join([f"{param}" for param in self.kernel_params])
            func_call = f"{aicore_kernel_name}({params});\n"
            self.kernel_call_block = self.gen_call_func(func_call, "ASCEND_IS_AIV", "AscendC::GetBlockIdx")
            preload_call_block = \
                f"preload((const void *){aicore_kernel_name}, {math.ceil(self.aiv_text_len / 2048)});\n"
            self.preload_call_block = self.gen_call_func(preload_call_block, "ASCEND_IS_AIV", "AscendC::GetBlockIdx")
            self.set_early_start_complement_blocks("ASCEND_IS_AIV", f"AscendC::GetBlockIdx() >= {self.block_dim}")
            self.set_early_start_complement_blocks("ASCEND_IS_AIC", "true")
        elif self.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0:
            aicore_kernel_name = self.called_kernel_name["dav-c220-cube"]["func_name"]
            self.sub_kernel_names.append(aicore_kernel_name)
            self.kernel_declare = f"extern \"C\"  __aicore__ void {aicore_kernel_name}({params_with_type});\n\n"
            params = ', '.join([f"{param}" for param in self.kernel_params])
            func_call = f"{aicore_kernel_name}({params});\n"
            self.kernel_call_block = self.gen_call_func(func_call, "ASCEND_IS_AIC", "get_block_idx")
            preload_call_block = \
                f"preload((const void *){aicore_kernel_name}, {math.ceil(self.aic_text_len / 2048)});\n"
            self.preload_call_block = self.gen_call_func(preload_call_block, "ASCEND_IS_AIC", "get_block_idx")
            self.set_early_start_complement_blocks("ASCEND_IS_AIC", f"get_block_idx() >= {self.block_dim}")
            self.set_early_start_complement_blocks("ASCEND_IS_AIV", "true")
        elif self.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_1:  
            # need check of sub block id
            aicore_kernel_name = self.called_kernel_name["dav-c220-cube"]["func_name"]
            self.sub_kernel_names.append(aicore_kernel_name)
            self.kernel_declare = f"extern \"C\"  __aicore__ void {aicore_kernel_name}({params_with_type});\n\n"
            params = ', '.join([f"{param}" for param in self.kernel_params])
            func_call = f"{aicore_kernel_name}({params});\n"
            self.kernel_call_block = self.gen_call_func(func_call, "ASCEND_IS_AIC", "get_block_idx")
            preload_call_block = \
                f"preload((const void *){aicore_kernel_name}, {math.ceil(self.aic_text_len / 2048)});\n"
            self.preload_call_block = self.gen_call_func(preload_call_block, "ASCEND_IS_AIC", "get_block_idx")
            aicore_kernel_name = self.called_kernel_name["dav-c220-vec"]["func_name"]
            self.sub_kernel_names.append(aicore_kernel_name)
            self.kernel_declare += f"extern \"C\"  __aicore__ void {aicore_kernel_name}({params_with_type});\n\n"
            params = ', '.join([f"{param}" for param in self.kernel_params])
            func_call = f"{aicore_kernel_name}({params});\n"
            self.kernel_call_block += self.gen_call_func(func_call, "ASCEND_IS_AIV", "get_block_idx")
            preload_call_block = \
                f"preload((const void *){aicore_kernel_name}, {math.ceil(self.aiv_text_len / 2048)});\n"
            self.preload_call_block += self.gen_call_func(preload_call_block, "ASCEND_IS_AIV", "get_block_idx")
            self.set_early_start_complement_blocks("ASCEND_IS_AIC", f"get_block_idx() >= {self.block_dim}")
            self.set_early_start_complement_blocks("ASCEND_IS_AIV", f"get_block_idx() >= {self.block_dim}")
        elif self.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_2:
            aicore_kernel_name = self.called_kernel_name["dav-c220-cube"]["func_name"]
            self.sub_kernel_names.append(aicore_kernel_name)
            self.kernel_declare = f"extern \"C\"  __aicore__ void {aicore_kernel_name}({params_with_type});\n\n"
            params = ', '.join([f"{param}" for param in self.kernel_params])
            func_call = f"{aicore_kernel_name}({params});\n"
            self.kernel_call_block = self.gen_call_func(func_call, "ASCEND_IS_AIC", "get_block_idx")
            preload_call_block = \
                f"preload((const void *){aicore_kernel_name}, {math.ceil(self.aic_text_len / 2048)});\n"
            self.preload_call_block = self.gen_call_func(preload_call_block, "ASCEND_IS_AIC", "get_block_idx")
            aicore_kernel_name = self.called_kernel_name["dav-c220-vec"]["func_name"]
            self.sub_kernel_names.append(aicore_kernel_name)
            self.kernel_declare += f"extern \"C\"  __aicore__ void {aicore_kernel_name}({params_with_type});\n\n"
            params = ', '.join([f"{param}" for param in self.kernel_params])
            func_call = f"{aicore_kernel_name}({params});\n"
            self.kernel_call_block += self.gen_call_func(func_call, "ASCEND_IS_AIV", "get_block_idx")
            preload_call_block = \
                f"preload((const void *){aicore_kernel_name}, {math.ceil(self.aiv_text_len / 2048)});\n"
            self.preload_call_block += self.gen_call_func(preload_call_block, "ASCEND_IS_AIV", "get_block_idx")
            self.set_early_start_complement_blocks("ASCEND_IS_AIC", f"get_block_idx() >= {self.block_dim}")
            self.set_early_start_complement_blocks("ASCEND_IS_AIV", f"get_block_idx() >= {self.block_dim}")
        else:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, (f"kernel type {self.kernel_type} do not support!"))


class SuperOperatorInfos:
    def __init__(self, op_list, super_kernel_name):
        self.info_base = []
        for index, op_info in enumerate(op_list):
            self.info_base.append(SubOperatorInfos(index, op_info))
        self.kernel_name: str = super_kernel_name
        self.kernel_type: KernelMetaType = KernelMetaType.KERNEL_TYPE_MAX
        self.timestamp_option: bool = False
        self.get_summary_type_and_options()
        self.block_dim: int = 0
        self.get_max_block_dim()
        self.compile_info: json = None
        kernel_meta_dir = CommonUtility.get_kernel_meta_dir()
        file_name_tag = CommonUtility.get_distinct_filename_tag() + "_kernel.cpp"
        self.kernel_file = os.path.realpath(os.path.join(kernel_meta_dir, self.kernel_name + file_name_tag))
        self.link_mode: SuperKernelLinkMode = SuperKernelLinkMode.PerCubeHerVecWithSuper
        self.preload_mode: SuperKernelPreLoadMode = SuperKernelPreLoadMode.PreloadByAdanvanceStep
        self.early_start_mode: SuperKernelEarlyStartMode = SuperKernelEarlyStartMode.EarlyStartEnable
        self.datacache_mode: SuperKernelDataCacheMode = SuperKernelDataCacheMode.DataCacheLoadNA
        self.gen_compile_info()

    def get_summary_type_and_options(self):
        final_kernel_type = 0
        for sub_operator in self.info_base:
            # summarize sub kernels kernel type infos
            if sub_operator.kernel_type == KernelMetaType.KERNEL_TYPE_AIV_ONLY:
                final_kernel_type = final_kernel_type | 0b1
            elif sub_operator.kernel_type == KernelMetaType.KERNEL_TYPE_AIC_ONLY:
                final_kernel_type = final_kernel_type | 0b10
            elif sub_operator.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0:
                final_kernel_type = final_kernel_type | 0b100
            elif sub_operator.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0:
                final_kernel_type = final_kernel_type | 0b1000
            elif sub_operator.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_1:
                final_kernel_type = final_kernel_type | 0b10000
            elif sub_operator.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_2:
                final_kernel_type = final_kernel_type | 0b100000

            # judge super kernel enable options
            if sub_operator.timestamp_option:
                self.timestamp_option = True

        # get kernel type of super kernel
        if final_kernel_type == 0b1:
            self.kernel_type = KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0
        elif final_kernel_type == 0b10:
            self.kernel_type = KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0
        elif final_kernel_type == 0b100 or final_kernel_type == 0b101:
            self.kernel_type = KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0
        elif final_kernel_type == 0b1000 or final_kernel_type == 0b1010:
            self.kernel_type = KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0
        elif final_kernel_type == 0b10000:
            self.kernel_type = KernelMetaType.KERNEL_TYPE_MIX_AIC_1_1
        else:
            self.kernel_type = KernelMetaType.KERNEL_TYPE_MIX_AIC_1_2


    def get_max_block_dim(self):
        if self.kernel_type == KernelMetaType.KERNEL_TYPE_AIV_ONLY or \
            self.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0:
            for sub_operator in self.info_base:
                if sub_operator.block_dim > self.block_dim:
                    self.block_dim = sub_operator.block_dim
        else:
            for sub_operator in self.info_base:
                if sub_operator.kernel_type == KernelMetaType.KERNEL_TYPE_AIV_ONLY or \
            sub_operator.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0:
                    sub_operator_block_dim = math.ceil(sub_operator.block_dim / 2)
                    if sub_operator_block_dim > self.block_dim:
                        self.block_dim = sub_operator_block_dim
                elif sub_operator.block_dim > self.block_dim:
                    self.block_dim = sub_operator.block_dim


    def gen_compile_info(self):
        options = ["-x", "cce"]
        bisheng = os.environ.get('BISHENG_REAL_PATH')
        if bisheng is None:
            bisheng = shutil.which("bisheng")
        if bisheng is not None:
            bisheng_path = os.path.dirname(bisheng)
            tikcpp_path = os.path.realpath(os.path.join(bisheng_path, "..", "..", "tikcpp"))
        else:
            tikcpp_path = os.path.realpath("/usr/local/Ascend/latest/compiler/tikcpp")
        options.append("-I" + tikcpp_path)
        options.append("-I" + os.path.join(tikcpp_path, "..", "..", "include"))
        options.append("-I" + os.path.join(tikcpp_path, "tikcfw"))
        options.append("-I" + os.path.join(tikcpp_path, "tikcfw", "impl"))
        options.append("-I" + os.path.join(tikcpp_path, "tikcfw", "interface"))

        sub_operator_info = []
        for sub_operator in self.info_base:
            operator_info = {}
            if sub_operator.aiv_bin is not None:
                operator_info["aiv_bin"] = sub_operator.aiv_bin
            if sub_operator.aic_bin is not None:
                operator_info["aic_bin"] = sub_operator.aic_bin
            operator_info["sub_kernel_names"] = sub_operator.sub_kernel_names
            sub_operator_info.append(operator_info)

        if self.early_start_mode == SuperKernelEarlyStartMode.EarlyStartEnable:
            options.append("-D__ASCENDC_ENABLE_SET_NEXT_TASK_START")
            options.append("-D__ASCENDC_ENABLE_WAIT_PRE_TASK_END")

        self.compile_info = {
            "block_dim": self.block_dim,
            "kernel_type": self.kernel_type,
            "sub_operator": sub_operator_info,
            "kernel_file": self.kernel_file,
            "compile_option": options,
            "kernel_name":self.kernel_name,
            "link_mode": self.link_mode,
            "timestamp_option": self.timestamp_option
        }


def gen_file_header(super_operator):
    file_header = """
#if 1
#include "kernel_operator.h"
"""
    if super_operator.kernel_type == KernelMetaType.KERNEL_TYPE_AIV_ONLY or \
        super_operator.kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0:
        file_header += "#if defined(__DAV_C220_VEC__)\n"
    else:
        file_header += "#if defined(__DAV_C220_CUBE__)\n"

    file_header += f"    __gm__ struct OpSystemRunCfg g_opSystemRunCfg = {{{0}}};\n"
    file_header += f"#else\n"
    file_header += f"    extern __gm__ struct OpSystemRunCfg g_opSystemRunCfg;\n"
    file_header += f"#endif\n\n"

    return file_header


def gen_inter_ops_barrier(super_operator: SuperOperatorInfos, \
    pre_sub_operator: SubOperatorInfos, sub_operator: SubOperatorInfos):
    inter_ops_bar = "// begin inter ops barrier\n"
    if super_operator.early_start_mode == SuperKernelEarlyStartMode.EarlyStartEnable:
        inter_ops_bar += pre_sub_operator.early_start_complement_set_flag_block
        inter_ops_bar += sub_operator.early_start_complement_wait_flag_block
    else:
        inter_ops_bar += "AscendC::SyncAll<false>();\n"

    return inter_ops_bar


def gen_super_kernel_file(super_operator):
    super_kernel_file = ""
    super_kernel_file += gen_file_header(super_operator)

    super_kernel_params = []
    for sub_operator in super_operator.info_base:
        super_kernel_file += sub_operator.kernel_declare
        super_kernel_params += sub_operator.kernel_params
    
    super_kernel_params_str = ', '.join([f"GM_ADDR {param}" for param in super_kernel_params])

    if super_operator.timestamp_option:
        super_kernel_file += f"extern \"C\"  __global__ __attribute__((aligned(512))) __aicore__ void \
auto_gen_{super_operator.kernel_name}_kernel(GM_ADDR ffts_addr, {super_kernel_params_str}, GM_ADDR workspace){{\n\n"
        is_mix = super_operator.kernel_type in \
            [KernelMetaType.KERNEL_TYPE_MIX_AIC_1_1, KernelMetaType.KERNEL_TYPE_MIX_AIC_1_2]
        super_kernel_file += gen_init_dump_code(is_mix, 1048576)
    else:
        super_kernel_file += f"extern \"C\"  __global__ __attribute__((aligned(512))) __aicore__ void \
            auto_gen_{super_operator.kernel_name}_kernel(GM_ADDR ffts_addr, {super_kernel_params_str}){{\n\n"
    super_kernel_file += "    if (ffts_addr != nullptr) {\n"
    super_kernel_file += "        set_ffts_base_addr((uint64_t)ffts_addr);\n"
    super_kernel_file += "    }\n\n"


    if super_operator.datacache_mode == SuperKernelDataCacheMode.DataCacheLoadAdancanceStep:
        super_kernel_file += "    __gm__ uint64_t * param_base = (__gm__ uint64_t *)get_para_base();\n"

    if super_operator.preload_mode == SuperKernelPreLoadMode.PreLoadByWhole:
        super_kernel_file += f"AscendC::PreLoad(8);\n"

    for pre_sub_operator, sub_operator, next_sub_operator in zip([None] + super_operator.info_base[:-1], \
            super_operator.info_base, super_operator.info_base[1:] + [None]):

        super_kernel_file += indent_code_func(f"//begin func call of sub operator {sub_operator.kernel_name}\n")

        # add preload of current func
        if super_operator.preload_mode == SuperKernelPreLoadMode.PreLoadStepByStep:
            super_kernel_file += indent_code_func(sub_operator.preload_call_block)

        # add preload of next func, when n+1 preload instr
        if super_operator.preload_mode == SuperKernelPreLoadMode.PreloadByAdanvanceStep:
            if pre_sub_operator is None:
                super_kernel_file += indent_code_func(sub_operator.preload_call_block)
            if next_sub_operator is not None:
                super_kernel_file += indent_code_func(next_sub_operator.preload_call_block)

        if super_operator.datacache_mode == SuperKernelDataCacheMode.DataCacheLoadAdancanceStep:
            if pre_sub_operator is None:
                super_kernel_file += indent_code_func(sub_operator.data_cache_preload_call)
            if next_sub_operator is not None:
                super_kernel_file += indent_code_func(next_sub_operator.data_cache_preload_call)
            super_kernel_file += "\n"

        if pre_sub_operator is not None:
            super_kernel_file += indent_code_func(gen_inter_ops_barrier(super_operator,
                                                                        pre_sub_operator,
                                                                        sub_operator))
        super_kernel_file += indent_code_func(sub_operator.kernel_call_block)
        pre_sub_operator = sub_operator

    super_kernel_file += "}\n\n"
    try:
        with os.fdopen(os.open(super_operator.kernel_file, \
            os.O_RDWR | os.O_CREAT, stat.S_IWUSR | stat.S_IRUSR), 'w') as ofd:
            ofd.write(super_kernel_file)
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("gen super kernel func file failed, reason is:", err))


def ascendc_super_kernel_plus(kernel_infos, called_kernel_name="ascendc_super_kernel_plus", impl_mode=""):
    """ entry of super kernel compile

        Args:
            kernel_infos: infos of sub kernel
                {
                    "op_list": 
                        [{"op1": {"bin_path": "", "json_path": ""}, "op2": {xxx}}]
                }
            called_kernel_name: super kernel name
    """
    kernel_meta_dir = CommonUtility.get_kernel_meta_dir()
    if os.path.exists(os.path.join(kernel_meta_dir, called_kernel_name + ".o")):
        return

    if kernel_infos.get("op_list", "") == "":
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("super kernel compile must provide op lists"))
    super_operator = SuperOperatorInfos(kernel_infos["op_list"], called_kernel_name)

    gen_super_kernel_file(super_operator)
    super_kernel_compile(super_operator.compile_info)
    return