#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
AscendC adapter
"""

import ctypes
import json
import os
import stat
import struct
import math
from pathlib import Path
from collections import namedtuple
from tbe.common.context import get_context
from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.utils.op_tiling import do_op_tiling, _ASCEND_OPP_PATH_ENV, _ASCEND_OPP_PATH_DEFAULT, \
    _BUILTIN_TILING_PATH, _CUSTOM_TILING_PATH_DEFAULT, so_arch_path2
from tbe.tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE
from .log_utils import LogUtil, AscendCLogLevel
import tbe.common.context.op_context as op_context
from tbe.common.repository_manager.utils.repository_manager_log import LOG_INSTANCE
from .global_storage import global_var_storage

OpInfo = namedtuple('OpInfo', ['kernel_name', 'op_type', 'inputs', 'outputs', 'attrs', 'impl_mode', 'origin_inputs',\
                    'origin_outputs', 'param_type_dynamic', 'mc2_ctx', 'param_type_list', 'init_value_list',\
                    'output_shape_depend_on_compute'])

OpInfo.__new__.__defaults__ = (None, None, None, None, None, None, None, None, None, None, None, None, None)

DEFAULT_TILING_KEY_VALUE = 0
_ASCEND_CUSTOM_OPP_PATH_ENV = "ASCEND_CUSTOM_OPP_PATH"
_TILING_SO_PATH = "op_impl/ai_core/tbe/op_tiling/liboptiling.so"
opp_dir = os.environ.get(_ASCEND_OPP_PATH_ENV, _ASCEND_OPP_PATH_DEFAULT)
config_default = os.path.join(opp_dir, "vendors", "config.ini")


def get_default_optiling_pathlist():
    vendor_list = []
    full_path_list = []
    if not os.path.exists(config_default):
        return full_path_list
    with open(config_default) as f:
        vdr_lst = f.readline().split("=")[1].split(",")
        for vdr in vdr_lst:
            _vendor = vdr.strip()
            if _vendor not in vendor_list:
                vendor_list.append(_vendor)
                full_path = os.path.join(opp_dir, "vendors", _vendor)
                full_path_list.append(full_path)
    return full_path_list


def get_custom_opp_pathlist():
    vendor_list = []
    custom_opp_dir = None
    if op_context.get_context() is None:
        LOG_INSTANCE.warn("op_context.get_context() is None!")
    else:
        custom_opp_dir = op_context.get_context().get_addition("custom_opp_path")
        LOG_INSTANCE.info("op_context get custom_opp_dir: %s" % custom_opp_dir)
    if custom_opp_dir is None:
        custom_opp_dir = os.environ.get(_ASCEND_CUSTOM_OPP_PATH_ENV)
        LOG_INSTANCE.info("get custom_opp_dir from env path: %s" % custom_opp_dir)
    if custom_opp_dir is None:
        return vendor_list
    _path_lst = str(custom_opp_dir).split(":")
    for _path in _path_lst:
        local_path = _path.strip()
        if len(local_path) != 0 and local_path not in vendor_list:
            vendor_list.append(local_path)
    return vendor_list


def load_lib():
    opp_path = Path(os.environ.get(_ASCEND_OPP_PATH_ENV, _ASCEND_OPP_PATH_DEFAULT))
    libregister = ctypes.CDLL("libregister.so")

    builtin_optiling_lib_path2 = opp_path.joinpath(so_arch_path2)
    parent_dir = Path(os.path.dirname(builtin_optiling_lib_path2))
    builtin_optiling_rtlib_path = parent_dir.joinpath("libopmaster_rt.so")
    builtin_optiling_ctlib_path = parent_dir.joinpath("libopmaster_ct.so")

    # 1. custom optiling 2.0 regist
    default_lst = get_default_optiling_pathlist()
    custom_opp_list = get_custom_opp_pathlist()
    join_list = custom_opp_list + default_lst
    for _path in join_list:
        try:
            custom_opp_so_path = os.path.join(_path, _TILING_SO_PATH)
            if(not os.path.exists(custom_opp_so_path)):
                LogUtil.print_compile_log("", f"{custom_opp_so_path} not exists", AscendCLogLevel.LOG_INFO)
            else:
                lib_optiling = ctypes.CDLL(custom_opp_so_path)
                custom_opp_so_path_str = str(custom_opp_so_path)
                lib_optiling.TbeLoadSoAndSaveToRegistry(custom_opp_so_path_str.encode('utf_8'))
        except OSError as e:
            # Custom op tiling lib may not exists
            LogUtil.print_compile_log("", f"An OSError occurred: {e}", AscendCLogLevel.LOG_ERROR)
            pass

    # 2.  builtin optiling 2.0 regist
    try:
        if os.path.exists(builtin_optiling_rtlib_path):
            lib_optiling_builtin = ctypes.CDLL(builtin_optiling_rtlib_path)
            builtin_optiling_lib_path_str = str(builtin_optiling_rtlib_path)
            lib_optiling_builtin.TbeLoadSoAndSaveToRegistry(builtin_optiling_lib_path_str.encode('utf_8'))
        elif os.path.exists(builtin_optiling_lib_path2):
            lib_optiling_builtin = ctypes.CDLL(builtin_optiling_lib_path2)
            builtin_optiling_lib_path2_str = str(builtin_optiling_lib_path2)
            lib_optiling_builtin.TbeLoadSoAndSaveToRegistry(builtin_optiling_lib_path2_str.encode('utf_8'))
    except AttributeError as e:
        # ascend c static load builtin opmaster rt so fail, undefined symbol, then use 1.0 way
        LogUtil.print_compile_log("", f"An AttributeError occurred: {e}", AscendCLogLevel.LOG_ERROR)
        pass

    try:
        if os.path.exists(builtin_optiling_ctlib_path):
            ctlib_optiling_builtin = ctypes.CDLL(builtin_optiling_ctlib_path)
            builtin_optiling_ctlib_path_str = str(builtin_optiling_ctlib_path)
            ctlib_optiling_builtin.TbeLoadSoAndSaveToRegistry(builtin_optiling_ctlib_path_str.encode('utf_8'))
    except AttributeError as e:
        # ascend c static load builtin opmaster ct so fail
        LogUtil.print_compile_log("", f"An AttributeError occurred: {e}", AscendCLogLevel.LOG_ERROR)
        pass
    return libregister


class Field:
    def __init__(self, field):
        """field: used to record information of tiling field

        field type:
            1 varialbe:
                classType: 0
                has attr: name, dtype
            2 array:
                classType: 1
                has attr: name, dtype, arrSize
            3 struct:
                classType: 2
                has attr: name, dtype(fix "struct"), structType, structSize
        """
        self.class_type = int(field["classType"])
        self.name = field["name"]
        self.dtype = field["dtype"]
        if self.class_type == 1:
            self.arr_size = int(field["arrSize"])
        elif self.class_type == 2:
            self.struct_type = field["structType"]
            self.struct_size = int(field["structSize"])


class TilingDef:
    def __init__(self, json_value):
        self.class_name = json_value["class_name"]
        self.data_size = json_value["data_size"]
        self.field_list = []
        self.is_api = False
        self.generate_code = ''
        self.class_def = ''
        self.tiling_key = 0
        self.depth = 0
        for field in json_value["fields"]:
            self.field_list.append(Field(field))


def decode(tiling_data, fmt, offset=0):
    """
    decode tiling data from binary to map

    Args:
        tiling_data: b'\x01\x00\x02\x00\n\x00\x02\x00\x08\x00'
        fmt: dict(name, type) such as {a:'uint8', b:'uint16_t'}
        offset: point to the position where the tilingdata is to be parsed.
    """
    def _get_value(tiling_data, fmt, offset=0):
        """
        fmt example: [-1, "int"]   # int arrary of unknown size
                     [10, "int"]   # arrary of 10 ints
                     "int"         # single int
        """
        fmt_def = {
            "char": "c",
            "int": "i",
            "int32": "i",
            "uint": "I",
            "int8": "b",
            "uint8": "B",
            "int16": "h",
            "uint16": "H",
            "int64": "l",
            "uint64": "L",
            "float": "f",
            "double": "d"
        }
        count = 1
        unpack_size = 0
        if isinstance(fmt, (list, tuple)):
            count = fmt[0]
            if count < 0:
                fmt_size = struct.calcsize("i")
                res = struct.unpack_from("i", tiling_data, offset)
                count = res[0]
                unpack_size += fmt_size
            fmt_str = "{}{}".format(count, fmt_def.get(fmt[1]))
        else:
            fmt_str = "{}{}".format(count, fmt_def.get(fmt))

        if count == 0:
            return [unpack_size, []]

        fmt_size = struct.calcsize(fmt_str)
        # when dtype is float, needs to deal with INF / NAN problem,
        # python automatically convert INF/NAN to "inf/nan", needs extra process for kernel to compile
        res = struct.unpack_from(fmt_str, tiling_data, offset + unpack_size)
        if fmt_str.endswith("f"):
            str_res = list(res)
            for i, x in enumerate(res):
                if x == float("inf"):
                    str_res[i] = "float(1.0 / 0.0)"
                elif x == float("-inf"):
                    str_res[i] = "float(-1.0 / 0.0)"
                elif math.isnan(x):
                    str_res[i] = "float(0.0 / 0.0)"
            res = tuple(str_res)

        unpack_size += fmt_size
        if isinstance(fmt, (list, tuple)):
            return [unpack_size, res]
        return [unpack_size, res[0]]

    res = {}
    for key, value in fmt.items():
        unpack_size, res[key] = _get_value(tiling_data, value, offset)
        offset += unpack_size

    return [res, offset]


def _decode_struct_tiling_data(field, binary_tiling_data, offset, struct_tiling_def_base):
    """ decode struct tiling data

        Args:
            field: struct type field, use to get struct info
            binary_tiling_data: src binary of tiling data
            offset: point to the start location of binary_tiling_data
            struct_tiling_def_base: use to store the struct field info
        Return:
            struct_tiling_data: dict(name, type) such as {var0 : val0, var0:val1}
            offset: point to the end location of binary_tiling_data
    """
    struct_tiling_def = struct_tiling_def_base[field.struct_type]
    if struct_tiling_def is None:
        msg = "get_op_tiling.py:_decode_struct_tiling_data struct_type: {} is not define, ".format(field.struct_type)
        raise msg
    struct_tiling_data, struct_offset = _decode_tiling_data(struct_tiling_def, binary_tiling_data[offset:],\
                                            struct_tiling_def_base)
    return [struct_tiling_data, offset + struct_offset]


def get_bytes_by_type(dtype):
    type_bytes = {"int8_t": 1, "uint8_t": 1,
                "int16_t": 2, "uint16_t": 2,
                "int32_t": 4, "uint32_t": 4,
                "int64_t": 8, "uint64_t": 8,
                "float": 4}
    if dtype in type_bytes:
        return type_bytes[dtype]
    else:
        msg = "get_bytes_by_type cannot find type = " + dtype
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, (msg))


def _decode_tiling_data(tiling_def, run_info_tiling_data, struct_tiling_def_base):
    """ decode tiling data by tiling field info and run_info_tiling_data

        Args:
            tiling_def: record tiling filed info
            run_info_tiling_data: src binary of tiling data
            struct_tiling_def_base: used to decode struct tiling data
        Return:
            run_info_tiling_data: dict(name, type) such as {var0 : val0, var0:val1}
            offset: point to the end location of binary_tiling_data
    """
    tiling_cc2py_mapping = {
        "int": "int",
        "int32_t": "int",
        "uint": "uint",
        "uint32_t": "uint",
        "int8_t": "int8",
        "uint8_t": "uint8",
        "int16_t": "int16",
        "uint16_t": "uint16",
        "int64_t": "int64",
        "uint64_t": "uint64",
        "float": "float",
        "struct": "struct"
    }
    tiling_format = {}
    struct_binary_info_list = []
    struct_list = []
    offset = 0
    run_info_tiling_data_binary = b''
    for field in tiling_def.field_list:
        if field.dtype not in tiling_cc2py_mapping.keys():
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                 "tiling format key error: {}".format(field.dtype))
        if field.class_type == 0:
            tiling_format[field.name] = tiling_cc2py_mapping[field.dtype]
            data_size = get_bytes_by_type(field.dtype)
            run_info_tiling_data_binary += run_info_tiling_data[offset : offset + data_size]
            offset += data_size
        elif field.class_type == 1:
            tiling_format[field.name] = [field.arr_size, tiling_cc2py_mapping[field.dtype]]
            data_size = get_bytes_by_type(field.dtype) * field.arr_size
            run_info_tiling_data_binary += run_info_tiling_data[offset : offset + data_size]
            offset += data_size
        elif field.class_type == 2:
            struct_list.append(field)
            struct_binary_info_list.append([offset, field.struct_size])
            offset += field.struct_size

    for offset, struct_size in struct_binary_info_list:
        run_info_tiling_data_binary += run_info_tiling_data[offset : offset + struct_size]

    binary_tiling_data = run_info_tiling_data_binary
    # decode tiling data with out struct
    run_info_tiling_data_binary, offset = decode(binary_tiling_data, tiling_format)
    # decode struct tiling data
    for field in struct_list:
        struct_tiling_data, offset = _decode_struct_tiling_data(field, binary_tiling_data, \
                                        offset, struct_tiling_def_base)
        run_info_tiling_data_binary[field.name] = struct_tiling_data
    return [run_info_tiling_data_binary, offset]


def get_tiling_def(optype):
    libregister = ctypes.CDLL("libregister.so")
    optype_c = optype.encode('utf_8')

    get_subclass_func = libregister.AscendCPyInterfaceGetTilingDefInfo

    max_run_info_size = 1024 * 64
    result_info_buf = ctypes.create_string_buffer(max_run_info_size)
    result_info_buf_size = ctypes.c_size_t(max_run_info_size)
    res = get_subclass_func(optype_c, result_info_buf, result_info_buf_size)

    # it's allowed no tiling-def
    if not res:
        LogUtil.print_compile_log(optype, f"has no Tiling Info", AscendCLogLevel.LOG_INFO)
        return None
    res_info = json.loads(result_info_buf.value)
    class_info = TilingDef(res_info)
    return class_info


def get_struct_shape(struct_tiling_def_base):
    # generatre struct definition
    struct_class_list = [""]
    for struct_name, struct_tiling_def in struct_tiling_def_base.items():
        class_body = ""
        # tiling struct in tikcpp advanced api, which has been include in kernel_tiling.h
        if struct_tiling_def.is_api is True:
            continue
        class_body += f"class {struct_tiling_def.class_name}\n"
        class_body += "{\n"
        class_body += "public:\n"
        for field in struct_tiling_def.field_list:
            if field.class_type == 0:
                class_body += f"    {field.dtype} {field.name} = 0;\n"
            elif field.class_type == 1:
                class_body += f"    {field.dtype} {field.name}[{field.arr_size}] = {{}};\n"
            elif field.class_type == 2:
                class_body += f"    {field.struct_type} {field.name};\n"
        class_body += "};\n\n"
        if struct_tiling_def.depth >= len(struct_class_list):
            struct_class_list.append("")
        struct_class_list[struct_tiling_def.depth] += class_body

    total_class_body = ""
    for struct_class in struct_class_list[::-1]:
        total_class_body += struct_class
    return total_class_body


def get_struct_tiling_data(struct_tiling_def, struct_tiling_data, has_arr, struct_tiling_def_base):
    # generate struct value of static shape
    struct_field_list: list = struct_tiling_def.field_list
    if len(struct_field_list) != len(struct_tiling_data):
        msg = "size not match: struct_field_list = %s, struct_tiling_data = %s:\n" % (
            str(struct_field_list), str(struct_tiling_data))
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, (msg))
    tiling_data_val = "{"
    for i, struct_field in enumerate(struct_field_list):
        if struct_field.class_type == 0:
            tiling_data_val += f"{struct_tiling_data[struct_field.name]}, "
        elif struct_field.class_type == 1:
            has_arr = True
            # replace for inf, nan case in _get_value (will pass str)
            gen_str = str(struct_tiling_data[struct_field.name])[1:-1].replace("'", "")
            tiling_data_val += f"{{{gen_str}}}, "
        else:
            sub_tiling_data_val, sub_has_arr = get_struct_tiling_data(struct_tiling_def_base[struct_field.struct_type],
                struct_tiling_data[struct_field.name], has_arr, struct_tiling_def_base)
            sub_tiling_data_val += ", "
            tiling_data_val += sub_tiling_data_val
            has_arr |= sub_has_arr
    tiling_data_val += "}"
    return tiling_data_val, has_arr


def gen_all_dynamic_struct_def_except_self(is_optype_self, tiling_key, tiling_key_list, optype):
    tiling_def_list_of_key = []
    struct_tiling_def_base = {}

    optype_tiling_def = get_tiling_def(optype)
    if optype_tiling_def is None:
        LogUtil.print_compile_log(optype, f"do not registe tiling struct!!!", AscendCLogLevel.LOG_ERROR)
        return ''
    struct_tiling_def_base = get_struct_tiling_info(optype_tiling_def, struct_tiling_def_base)

    for one_tiling_key in tiling_key_list:
        optype_with_tilingkey = optype + "_" + one_tiling_key
        tiling_def = get_tiling_def(optype_with_tilingkey)
        if tiling_def is not None:
            struct_tiling_def_base = get_struct_tiling_info(tiling_def, struct_tiling_def_base)
            tiling_def.class_def = get_dynamic_tiling_struct(tiling_def)
            tiling_def.tiling_key = one_tiling_key
            tiling_def_list_of_key.append(tiling_def)

    optype_tiling_def.class_def = get_dynamic_tiling_struct(optype_tiling_def)

    # all fileds of substruct and file-item defination, just like dynamic shape scene
    codes = get_struct_shape(struct_tiling_def_base)
    if not is_optype_self:
        # when the tilingkey of this shape now use the special registered tilingkey struct, not optype struct
        # then must add defination of optype struct itself, or has not defination
        codes += optype_tiling_def.class_def
    tiling_struct_dict = set()
    tiling_def_class_name = ''
    if not is_optype_self:
        for tiling_def in tiling_def_list_of_key:
            if tiling_def.tiling_key == tiling_key:
                tiling_def_class_name = tiling_def.class_name

    for tiling_def in tiling_def_list_of_key:
        if not is_optype_self and tiling_def.tiling_key == tiling_key:
            # when this static shape tilingkey registed special tilingkey and is just this tilingkey
            continue
        if tiling_def.class_name != tiling_def_class_name and tiling_def.class_name not in tiling_struct_dict:
            # the defination of tilingkey-registed special struct
            codes += tiling_def.class_def
            tiling_struct_dict.add(tiling_def.class_name)
    return codes


def gen_static_shape(tiling_def, tilingdata, struct_tiling_def_base, all_dynamic_struct_def_except_self):
    field_list: list = tiling_def.field_list
    class_name_upper = tiling_def.class_name.upper()
    class_body = f"#ifndef __{class_name_upper}_HEADER__\n"
    class_body += f"#define __{class_name_upper}_HEADER__\n"
    class_body += "#include \"kernel_tiling/kernel_tiling.h\"\n"
    class_body += f"#ifdef ASCENDC_CPU_DEBUG\n"
    class_body += f"#include \"kernel_log.h\"\n"
    class_body += "#else\n"
    class_body += "#define __aicore__ [aicore]\n"
    class_body += "#endif\n"
    # all tiling struct info by dynamic, except the only one top-level struct of static-shape one itself
    class_body += all_dynamic_struct_def_except_self
    # the only one top-level struct of static-shape one itself
    class_body += f"class {tiling_def.class_name}\n"
    class_body += "{\n"
    class_body += "public:\n"
    has_arr = False
    if len(field_list) != len(tilingdata):
        msg = "size not match: filed_info_list = %s, tilingdata = %s:\n" % (str(field_list), str(tilingdata))
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, (msg))
    for field in field_list:
        if field.class_type == 0:
            class_body += f"    {field.dtype} {field.name} = {tilingdata[field.name]};\n"
        elif field.class_type == 1:
            has_arr = True
            str_part = str(tilingdata[field.name])[1:-1].replace("'", "")  # in case inf, need to remove str symbol
            class_body += f"    {field.dtype} {field.name}[{field.arr_size}] = {{{str_part}}};\n"
        elif field.class_type == 2:
            tiling_data_val, has_arr = get_struct_tiling_data(struct_tiling_def_base[field.struct_type],
                tilingdata[field.name], has_arr, struct_tiling_def_base)
            class_body += f"    {field.struct_type} {field.name} = {tiling_data_val};\n"

    class_body += "};\n\n"
    short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
    class_body += "#ifdef ASCENDC_TIME_STAMP_ON\n"
    if short_soc_version == "Ascend310P" and has_arr:
        class_body += "#define GET_TILING_DATA(tiling_data, tiling_arg)                                     \\\n"
        class_body += f"    {tiling_def.class_name} tiling_data;                                            \n"

        class_body += "#define GET_TILING_DATA_WITH_STRUCT(tiling_struct, tiling_data, tiling_arg)          \\\n"
        class_body += "    tiling_struct tiling_data;                                                       \n"

        class_body += "#define GET_TILING_DATA_MEMBER(tiling_type, member, var, tiling)                     \\\n"
        class_body += \
            "    tiling_type __ascendc_point##var;                                                          \\\n"
        class_body += \
            "    auto& var = __ascendc_point##var.member;                                                   \n"
    else :
        class_body += "#define GET_TILING_DATA(tiling_data, tiling_arg)                                     \\\n"
        class_body += f"    const {tiling_def.class_name} tiling_data;                                      \\\n"
        class_body += _add_time_stamp_codes('TIME_STAMP_TILING_DATA')

        class_body += "#define GET_TILING_DATA_WITH_STRUCT(tiling_struct, tiling_data, tiling_arg)          \\\n"
        class_body += "    const tiling_struct tiling_data;                                                 \\\n"
        class_body += _add_time_stamp_codes('TIME_STAMP_TILING_DATA_STRUCT')

        class_body += "#define GET_TILING_DATA_MEMBER(tiling_type, member, var, tiling)                     \\\n"
        class_body += \
            "    const tiling_type __ascendc_point##var;                                                    \\\n"
        class_body += \
            "    auto& var = __ascendc_point##var.member;                                                   \\\n"
        class_body += _add_time_stamp_codes('TIME_STAMP_TILING_DATA_MEMBER')

    class_body += "#else\n"

    if short_soc_version == "Ascend310P" and has_arr:
        class_body += "#define GET_TILING_DATA(tiling_data, tiling_arg)                                           \\\n"
        class_body += f"    {tiling_def.class_name} tiling_data;\n\n"

        class_body += "#define GET_TILING_DATA_WITH_STRUCT(tiling_struct, tiling_data, tiling_arg)                \\\n"
        class_body += "    tiling_struct tiling_data;\n\n"

        class_body += "#define GET_TILING_DATA_MEMBER(tiling_type, member, var, tiling)                           \\\n"
        class_body += \
            "    tiling_type __ascendc_point##var;                                                          \\\n"
        class_body += "    auto& var = __ascendc_point##var.member;\n\n"
    else :
        class_body += "#define GET_TILING_DATA(tiling_data, tiling_arg)                                           \\\n"
        class_body += f"    const {tiling_def.class_name} tiling_data;\n\n"

        class_body += "#define GET_TILING_DATA_WITH_STRUCT(tiling_struct, tiling_data, tiling_arg)                \\\n"
        class_body += "    const tiling_struct tiling_data;\n\n"

        class_body += "#define GET_TILING_DATA_MEMBER(tiling_type, member, var, tiling)                           \\\n"
        class_body += \
            "    const tiling_type __ascendc_point##var;                                                          \\\n"
        class_body += "    auto& var = __ascendc_point##var.member;\n\n"

    class_body += "#endif\n"

    class_body += f"#endif // __{class_name_upper}_HEADER__\n\n"
    return class_body


def get_dynamic_cpu_assign_tiling_data(struct_tiling_def_base, field_list, left_value, offset=0):
    # generate cpu code for assigning values to variables
    class_body = ""
    for field in field_list:
        if field.class_type == 0:
            class_body += \
                f"    {left_value}{field.name} = (*(const __gm__ {field.dtype} *)(p_tilingdata + {offset}));\n"
            offset += get_bytes_by_type(field.dtype)
        elif field.class_type == 1:
            class_body += f"    for (int i = 0 ; i < {field.arr_size}; i++) {{\n"
            class_body += \
                f"        {left_value}{field.name}[i] = (*(const __gm__ {field.dtype} *)\
(p_tilingdata + {offset} + i * sizeof({field.dtype})));\n"
            class_body += f"    }}\n"
            offset += get_bytes_by_type(field.dtype) * field.arr_size
        elif field.class_type == 2:
            struct_field_list = struct_tiling_def_base[field.struct_type].field_list
            struct_body, offset = get_dynamic_cpu_assign_tiling_data(struct_tiling_def_base,\
                struct_field_list, f"{left_value}{field.name}.", offset)
            class_body += struct_body
    return class_body, offset


def get_dynamic_npu_assign_tiling_data(struct_tiling_def_base, field_list, left_value, offset=0):
    # generate npu code for assigning values to variables
    class_body = ""
    for field in field_list:
        if field.class_type == 0:
            class_body += f"    {left_value}{field.name} = (*(__ubuf__ {field.dtype} *)\
((__ubuf__ uint8_t *)tilingdata_in_ub + {offset}));\n"
            offset += get_bytes_by_type(field.dtype)
        elif field.class_type == 1:
            class_body += f"    for (int i = 0 ; i < {field.arr_size}; i++) {{\n"
            class_body += \
                    f"        {left_value}{field.name}[i] = (*(__ubuf__ {field.dtype} *)\
((__ubuf__ uint8_t *)tilingdata_in_ub + {offset} + i * sizeof({field.dtype})));\n"
            class_body += f"    }}\n"
            offset += get_bytes_by_type(field.dtype) * field.arr_size
        elif field.class_type == 2:
            struct_field_list = struct_tiling_def_base[field.struct_type].field_list
            struct_body, offset = get_dynamic_npu_assign_tiling_data(struct_tiling_def_base,\
                                        struct_field_list, f"{left_value}{field.name}.", offset)
            class_body += struct_body
    return class_body, offset


def get_dynamic_assign_tiling_data_by_bytes(total_bytes, prefix_0, prefix_1):
    class_body = ""
    assign_8byte_time = total_bytes // 8
    left_bytes = total_bytes % 8
    current_offset = total_bytes - left_bytes
    # for i in range(0, current_offset, 8):
    class_body += f"    for (int i = 0 ; i < {current_offset}; i += 8) {{ \n"
    class_body += \
            f"        (*(uint64_t*)((uint8_t*)tilingdata + i)) = (*({prefix_0} uint64_t*)({prefix_1} + i));\n"
    class_body += f"    }}\n"

    if left_bytes // 4:
        class_body += f"    (*(uint32_t*)((uint8_t*)tilingdata + {current_offset})) = \
                            (*({prefix_0} uint32_t *)({prefix_1} + {current_offset}));\n"
        current_offset += 4
        left_bytes = left_bytes % 4

    if left_bytes // 2:
        class_body += f"    (*(uint16_t*)((uint8_t*)tilingdata + {current_offset})) = \
                            (*({prefix_0} uint16_t *)({prefix_1} + {current_offset}));\n"
        current_offset += 2
        left_bytes = left_bytes % 2

    if left_bytes:
        class_body += f"    (*(uint8_t*)((uint8_t*)tilingdata + {current_offset})) = \
                            (*({prefix_0} uint8_t *)({prefix_1} + {current_offset}));\n"
    return class_body


def get_dynamic_assign_tiling_data_by_size(offset, prefix_0, prefix_1):
    class_body = ""
    class_body += f"    constexpr uint32_t judge_bytes = all_bytes > 15 ? all_bytes - 15 : 0;\n"
    class_body += f"    uint32_t i = 0;\n"
    class_body += f"    if (judge_bytes > 0) {{\n"
    class_body += f"        for (; i < judge_bytes; i += 16) {{ \n"
    class_body += \
        f"            (*(uint64_t*)((uint8_t*)tilingdata + i)) = (*({prefix_0} uint64_t*)({prefix_1} + i));\n"
    class_body += \
        f"            (*(uint64_t*)((uint8_t*)tilingdata + i + 8)) = (*({prefix_0} uint64_t*)({prefix_1} + i + 8));\n"
    class_body += f"        }}\n"
    class_body += f"    }}\n"
    class_body += "    if (all_bytes & 0x00000008) {\n"
    class_body += f"        (*(uint64_t*)((uint8_t*)tilingdata + i)) = (*({prefix_0} uint64_t *)({prefix_1} + i));\n"
    class_body += "        i += 8;\n"
    class_body += "    }\n"
    class_body += "    if (all_bytes & 0x00000004) {\n"
    class_body += f"        (*(uint32_t*)((uint8_t*)tilingdata + i)) = (*({prefix_0} uint32_t *)({prefix_1} + i));\n"
    class_body += "        i += 4;\n"
    class_body += "    }\n"
    class_body += "    if (all_bytes & 0x00000002) {\n"
    class_body += f"        (*(uint16_t*)((uint8_t*)tilingdata + i)) = (*({prefix_0} uint16_t *)({prefix_1} + i));\n"
    class_body += "        i += 2;\n"
    class_body += "    }\n"
    class_body += "    if (all_bytes & 0x00000001) {\n"
    class_body += f"        (*(uint8_t*)((uint8_t*)tilingdata + i)) = (*({prefix_0} uint8_t *)({prefix_1} + i));\n"
    class_body += "    }\n"
    return class_body


def gen_dynamic_shape(tiling_def, struct_tiling_def_base):
    class_name_upper = tiling_def.class_name.upper()
    class_body = f"#ifndef __{class_name_upper}_HEADER__\n"
    class_body += f"#define __{class_name_upper}_HEADER__\n\n"
    class_body += "#include \"kernel_tiling/kernel_tiling.h\"\n"
    class_body += f"#ifdef ASCENDC_CPU_DEBUG\n"
    class_body += f"#include \"kernel_log.h\"\n"
    class_body += "#else\n"
    class_body += "#define __aicore__ [aicore]\n"
    class_body += "#endif\n"
    class_body += get_struct_shape(struct_tiling_def_base)
    class_body += get_dynamic_tiling_struct(tiling_def)
    class_body += get_tiling_copy_func_and_micro(tiling_def.class_name)
    class_body += f"#endif // __{class_name_upper}_HEADER__\n"
    return class_body


class TilingInfo:
    def __init__(self):
        self.block_dim: int = -1
        self.task_ration: int = 2  # AscendC only support 1:2
        self.file_content: str = ""
        self.tiling_data: str = ""
        self.tiling_data_file_path: str = ""
        self.tiling_data_size: int = 0 # TilingDef::getDataSize
        self.static_shape_flag: bool = True
        self.tiling_key: int = DEFAULT_TILING_KEY_VALUE
        self.static_workspace_size: int = 0
        self.tiling_key_list = []
        self.tiling_key_data_size = {}
        self.default_tiling_size: int = 0
        self.clear_atomic: bool = True
        self.schedule_mode: int = 0
        self.raw_run_info: dict = None

    def __str__(self):
        return ",".join("{}={}".format(key, getattr(self, key)) for key in self.__dict__.keys())

    def save_file(self, file_path):
        self.tiling_data_file_path = file_path
        try:
            with open(file_path, "w") as new_file:
                # Only the owner and group have rights
                os.chmod(file_path, stat.S_IRUSR + stat.S_IWUSR + stat.S_IRGRP)
                new_file.write(self.file_content)
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("open file error, reason:", err))

    def remove_file(self):
        os.remove(self.tiling_data_file_path)


def is_static_shape(inputs: list, outputs: list):
    """check if static shape, find dynamic shape if shape<0 in inputs

    Args:
    inputs (list): shape/ori_shape/format/ori_format/dtype/name, type including required/optional/dynamic,
                        if shape of inputs is const, there will be an extra field "const value".
    Returns:
        res (Boolean): True means static_shape, False means dynamic shape
    """
    for input_ele in inputs:
        if input_ele is None:
            continue
        for shape in input_ele["shape"]:
            if shape < 0:
                return False
    if outputs is not None:
        for output_ele in outputs:
            if output_ele is None:
                continue
            for shape in output_ele["shape"]:
                if shape < 0:
                    return False
    return True


def get_struct_tiling_info(tiling_def, struct_tiling_def_base, depth=0):
    depth += 1
    for field in tiling_def.field_list:
        if field.class_type == 2:
            if field.struct_type not in struct_tiling_def_base:
                struct_optype = field.struct_type + "OpApi"
                struct_tiling_def = get_tiling_def(struct_optype)
                # tiling struct in tikcpp advance api
                if struct_tiling_def is not None:
                    struct_tiling_def.is_api = True
                # op used struct, defined by user
                else:
                    struct_optype = field.struct_type + "Op"
                    struct_tiling_def = get_tiling_def(struct_optype)
                    if struct_tiling_def is None:
                        msg = "get_op_tiling.py:_decode_struct_tiling_data optype: {} is not define, ".\
                            format(struct_optype)
                        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, (msg))
                struct_tiling_def.depth = depth
                struct_tiling_def_base[field.struct_type] = struct_tiling_def
                struct_tiling_def_base = get_struct_tiling_info(struct_tiling_def, struct_tiling_def_base, depth)
    return struct_tiling_def_base


def get_dynamic_tiling_struct(tiling_def):
    """
    get tiling class def, init func and macro
    :param tiling_def:
    :param struct_tiling_def_base:
    :return:
    """
    class_def = f"class {tiling_def.class_name}\n"
    class_def += "{\n"
    class_def += "public:\n"
    class_def += f"__aicore__  __inline__ __attribute__ ((always_inline)) {tiling_def.class_name} () {{ }}\n"
    field_list: list = tiling_def.field_list
    for field in field_list:
        if field.class_type == 0:
            class_def += f"    {field.dtype} {field.name};\n"
        elif field.class_type == 1:
            class_def += f"    {field.dtype} {field.name}[{field.arr_size}];\n"
        elif field.class_type == 2:
            class_def += f"    {field.struct_type} {field.name};\n"
    class_def += "}__attribute__((__may_alias__));\n\n"
    return class_def


def get_header_and_sub_struct_def(tiling_def, struct_tiling_def_base):
    class_name_upper = tiling_def.class_name.upper()
    start_body = f"#ifndef __{class_name_upper}_HEADER__\n"
    start_body += f"#define __{class_name_upper}_HEADER__\n\n"
    start_body += "#include \"kernel_tiling/kernel_tiling.h\"\n"
    start_body += f"#ifdef ASCENDC_CPU_DEBUG\n"
    start_body += f"#include \"kernel_log.h\"\n"
    start_body += "#else\n"
    start_body += "#define __aicore__ [aicore]\n"
    start_body += "#endif\n"
    start_body += get_struct_shape(struct_tiling_def_base)
    end_body = f"#endif // __{class_name_upper}_HEADER__\n"
    return start_body, end_body


def get_tiling_copy_func_and_micro(class_name):
    class_body = "#if defined(ASCENDC_CPU_DEBUG)\n"
    class_body += "template <class T>\n"
    class_body += "inline __aicore__ void InitTilingData(const __gm__ uint8_t *p_tilingdata, T *tilingdata)\n"
    class_body += "#else\n"
    class_body += "template <class T>\n"
    class_body += "__inline__ __attribute__((always_inline)) __aicore__ void InitTilingData(const __gm__ uint8_t \
*p_tilingdata, T *tilingdata)\n"
    class_body += "#endif\n"
    class_body += "{\n"
    class_body += "    constexpr uint64_t all_bytes = sizeof(T);\n"
    class_body += "#if defined(ASCENDC_CPU_DEBUG) || defined(__DAV_C220_CUBE__) || defined(__GET_CODE_CHANNEL__)\n"
    class_body += "#if defined(__DAV_C100__) || defined(ASCENDC_CPU_DEBUG)\n"
    class_body += get_dynamic_assign_tiling_data_by_size("all_bytes", "const __gm__", "(const __gm__ uint8_t *)\
p_tilingdata")
    class_body += "#else\n"
    class_body += "    copy_data_align64((uint8_t*)tilingdata, (__gm__ uint8_t *)p_tilingdata, all_bytes);\n"
    class_body += "#endif\n"
    class_body += "#else\n"
    class_body += "    __ubuf__ uint8_t *tilingdata_in_ub = (__ubuf__ uint8_t *)get_imm(0);\n"
    class_body += "    constexpr uint32_t len_burst = (all_bytes + 31) / 32;\n"
    class_body += "#if !defined(__DAV_M310__)\n"
    class_body += "    copy_gm_to_ubuf(((__ubuf__ uint8_t *)tilingdata_in_ub), p_tilingdata, 0, 1,\
len_burst, 0, 0);\n"
    class_body += "#else\n"
    class_body += "    copy_gm_to_ubuf_align(((__ubuf__ uint8_t *)tilingdata_in_ub), (__gm__ uint8_t *)p_tilingdata,\
0, 1, all_bytes, 0, 0, 0, 0);\n"
    class_body += "#endif\n"
    class_body += "    set_flag(PIPE_MTE2, PIPE_S, EVENT_ID0);\n"
    class_body += "    wait_flag(PIPE_MTE2, PIPE_S, EVENT_ID0);\n"
    class_body += "#if defined __DAV_C100__\n"
    class_body += get_dynamic_assign_tiling_data_by_size("all_bytes", "__ubuf__",\
        "(__ubuf__ uint8_t *)tilingdata_in_ub")
    class_body += "#else\n"
    class_body += "    copy_data_align64((uint8_t*)tilingdata, (__ubuf__ uint8_t *)tilingdata_in_ub, all_bytes);\n"
    class_body += "#endif\n"
    class_body += "#endif\n"
    class_body += "#ifndef ASCENDC_CPU_DEBUG\n"
    class_body += "    pipe_barrier(PIPE_ALL);\n"
    class_body += "#endif\n"
    class_body += "}\n\n"

    class_body += "#ifdef ASCENDC_TIME_STAMP_ON\n"
    class_body += "#define GET_TILING_DATA(tiling_data, tiling_arg)                            \\\n"
    class_body += f"    {class_name} tiling_data;                                    \\\n"
    class_body += f"    InitTilingData<{class_name}>(tiling_arg, &tiling_data);      \\\n"
    class_body += _add_time_stamp_codes('TIME_STAMP_TILING_DATA')
    class_body += "#define GET_TILING_DATA_WITH_STRUCT(tiling_struct, tiling_data, tiling_arg)  \\\n"
    class_body += "    tiling_struct tiling_data;                                               \\\n"
    class_body += "    InitTilingData<tiling_struct>(tiling_arg, &tiling_data);                 \\\n"
    class_body += _add_time_stamp_codes('TIME_STAMP_TILING_DATA_STRUCT')

    class_body += "#define GET_TILING_DATA_MEMBER(tiling_type, member, var, tiling)            \\\n"
    class_body += "    decltype(((tiling_type *)0)->member) var;                               \\\n"
    class_body += "    size_t offset##var = (size_t)(&((tiling_type*)0)->member);              \\\n"
    class_body += "    InitTilingData<decltype(((tiling_type *)0)->member)>(tiling + offset##var, &var);\\\n"
    class_body += _add_time_stamp_codes('TIME_STAMP_TILING_DATA_MEMBER')

    class_body += "#else\n"

    class_body += "#define GET_TILING_DATA(tiling_data, tiling_arg)                            \\\n"
    class_body += f"    {class_name} tiling_data;                                    \\\n"
    class_body += f"    InitTilingData<{class_name}>(tiling_arg, &tiling_data);\n"

    class_body += "#define GET_TILING_DATA_WITH_STRUCT(tiling_struct, tiling_data, tiling_arg) \\\n"
    class_body += "    tiling_struct tiling_data;                                              \\\n"
    class_body += "    InitTilingData<tiling_struct>(tiling_arg, &tiling_data);\n"

    class_body += "#define GET_TILING_DATA_MEMBER(tiling_type, member, var, tiling)            \\\n"
    class_body += "    decltype(((tiling_type *)0)->member) var;                               \\\n"
    class_body += "    size_t offset##var = (size_t)(&((tiling_type*)0)->member);              \\\n"
    class_body += "    InitTilingData<decltype(((tiling_type *)0)->member)>(tiling + offset##var, &var);\n"
    class_body += "#endif\n"
    return class_body


def _change_param_name_to_name(inputs):
    for input_ele in inputs:
        if input_ele is None:
            continue
        if isinstance(input_ele, (list, tuple)):
            for single in input_ele:
                if "const_value" in single.keys():
                    single['name'] = single.get('param_name')
        else:
            if "const_value" in input_ele.keys():
                input_ele['name'] = input_ele.get('param_name')


def gen_static_shape_v2(optype:str, tiling_struct: str, tiling_raw_data: str):
    tiling_size = len(tiling_raw_data)
    tiling_format = {"tiling": [tiling_size, "uint8"]}
    # decode tiling data with out struct
    tiling_data, _ = decode(tiling_raw_data, tiling_format)
    tiling_arr_data = tiling_data["tiling"]
    class_name_upper = optype.upper()
    class_body = f"#ifndef __{class_name_upper}_HEADER__\n"
    class_body += f"#define __{class_name_upper}_HEADER__\n"
    class_body += "#include \"kernel_tiling/kernel_tiling.h\"\n"
    class_body += f"#ifdef ASCENDC_CPU_DEBUG\n"
    class_body += f"#include \"kernel_log.h\"\n"
    class_body += "#else\n"
    class_body += "#define __aicore__ [aicore]\n"
    class_body += "#endif\n"

    short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
    if short_soc_version == "Ascend310P":
        class_body += "#define GET_TILING_DATA(tiling_data, tiling_arg)                                           \\\n"
        class_body += \
            f"    uint8_t __ascendc_arr_##tiling_data[{tiling_size}] = {{{str(tiling_arr_data)[1:-1]}}};    \\\n"
        class_body += \
            f"    {tiling_struct} tiling_data = *reinterpret_cast<{tiling_struct} *>(__ascendc_arr_##tiling_data);\n\n"

        class_body += "#define GET_TILING_DATA_WITH_STRUCT(tiling_struct, tiling_data, tiling_arg)                \\\n"
        class_body += \
            f"    uint8_t __ascendc_arr_##tiling_data[{tiling_size}] = {{{str(tiling_arr_data)[1:-1]}}};    \\\n"
        class_body += \
            f"    tiling_struct tiling_data = *reinterpret_cast<tiling_struct *>(__ascendc_arr_##tiling_data);\n\n"

        class_body += "#define GET_TILING_DATA_MEMBER(tiling_type, member, var, tiling)                           \\\n"
        class_body += \
            f"    uint8_t __ascendc_arr_##var[{tiling_size}] = {{{str(tiling_arr_data)[1:-1]}}};    \\\n"
        class_body += \
            f"    tiling_type __ascendc_point##var = *reinterpret_cast<tiling_type *>(__ascendc_arr_##var);\\\n"
        class_body += "    auto& var = __ascendc_point##var.member;\n\n"
    else :
        class_body += "#define GET_TILING_DATA(tiling_data, tiling_arg)                                           \\\n"
        class_body += \
            f"    const uint8_t __ascendc_arr_##tiling_data[{tiling_size}] = {{{str(tiling_arr_data)[1:-1]}}};    \\\n"
        class_body += \
f"    const {tiling_struct} tiling_data = *reinterpret_cast<const {tiling_struct} *>(__ascendc_arr_##tiling_data);\n\n"

        class_body += "#define GET_TILING_DATA_WITH_STRUCT(tiling_struct, tiling_data, tiling_arg)                \\\n"
        class_body += \
            f"    const uint8_t __ascendc_arr_##tiling_data[{tiling_size}] = {{{str(tiling_arr_data)[1:-1]}}};    \\\n"
        class_body +=\
f"    const tiling_struct tiling_data = *reinterpret_cast<const tiling_struct *>(__ascendc_arr_##tiling_data);\n\n"

        class_body += "#define GET_TILING_DATA_MEMBER(tiling_type, member, var, tiling)                           \\\n"
        class_body += \
            f"    const uint8_t __ascendc_arr_##var[{tiling_size}] = {{{str(tiling_arr_data)[1:-1]}}};    \\\n"
        class_body += \
        f"    const tiling_type __ascendc_point##var = *reinterpret_cast<const tiling_type *>(__ascendc_arr_##var);\\\n"
        class_body += "    auto& var = __ascendc_point##var.member;\n\n"

    class_body += f"#endif // __{class_name_upper}_HEADER__\n"
    return class_body


def gen_dynamic_shape_v2(optype:str, tiling_struct: str):
    class_name_upper = optype.upper()
    class_body = f"#ifndef __{class_name_upper}_HEADER__\n"
    class_body += f"#define __{class_name_upper}_HEADER__\n\n"
    class_body += "#include \"kernel_tiling/kernel_tiling.h\"\n"
    class_body += f"#ifdef ASCENDC_CPU_DEBUG\n"
    class_body += f"#include \"kernel_log.h\"\n"
    class_body += "#else\n"
    class_body += "#define __aicore__ [aicore]\n"
    class_body += "#endif\n"
    class_body += get_tiling_copy_func_and_micro(tiling_struct)
    class_body += f"#endif // __{class_name_upper}_HEADER__\n"
    return class_body


def get_tiling_info_v2(op_info: OpInfo, tiling_key_list: list, default_tiling_struct: str, \
        tiling_struct_expr_map:dict):
    """get tiling define v2

    Args:
        optype (str): operator type
        tiling_key_list (list): tiling_key used by developer
        default_tiling_struct (str): default tiling struct
        tiling_struct_expr_map (dict): map of (tiling, tiling_struct)

    Returns:
        tiling_info (TilingInfo): tiling info formatted by tiling define and tiling data
    """
    optype = op_info.op_type
    inputs = op_info.inputs
    outputs = op_info.outputs
    attrs = op_info.attrs
    tiling_info = TilingInfo()
    tiling_info.tiling_key_list = tiling_key_list
    static_shape = is_static_shape(inputs, outputs)
    context = get_context()
    if static_shape:
        _change_param_name_to_name(inputs)
        _change_param_name_to_name(op_info.origin_inputs)
        compile_info = context.get_compile_info()
        tiling_config = {"name" : "ascendc_op_para_size", "dtype" : "int", "value" : 2 * 1024 * 1024}
        attrs.append(tiling_config)
        run_info = do_op_tiling(optype, compile_info, op_info.origin_inputs, op_info.origin_outputs, None, None, attrs)
        # bytes.fromhex(run_info['tiling_data']) can deserialization DumpByteBuffer
        # save undecoded tiling data for replay
        tiling_info.tiling_data = run_info["tiling_data"]
        tiling_info.tiling_key = run_info['tiling_key']
        tiling_info.block_dim = run_info["block_dim"]
        tiling_info.clear_atomic = run_info["clear_atomic"]
        tiling_info.schedule_mode = run_info.get("schedule_mode", 0)
        total_workspace_size = sum(run_info["workspaces"])
        tiling_info.file_content = gen_static_shape_v2(optype, tiling_struct_expr_map[str(tiling_info.tiling_key)],\
                                                             run_info["tiling_data"])
        tiling_info.static_workspace_size = total_workspace_size
        run_info["tiling_data"] = tiling_info.tiling_data.hex()
        tiling_info.raw_run_info = run_info
        if total_workspace_size >= 0:
            if len(run_info["workspaces"]) > 1:
                msg = "the num of workspace can not large than 1"
                raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, msg)
            context.add_workspace("total_workspace", size = total_workspace_size)
    else:
        tiling_info.static_shape_flag = False
        context.add_workspace("total_workspace", size = -1)
        tiling_info.file_content = gen_dynamic_shape_v2(optype, default_tiling_struct)
    return tiling_info


def get_tiling_info(op_info: OpInfo, tiling_key_list: list = None):
    """get tiling define and tiling data registered by operator developer

    Args:
        optype (str): operator type
        inputs (list): inputs of operator
        outputs (list): outputs of operator
        attrs : attrs of operator

    Returns:
        tiling_info (TilingInfo): tiling info formatted by tiling define and tiling data
    """
    optype = op_info.op_type
    inputs = op_info.inputs
    outputs = op_info.outputs
    attrs = op_info.attrs
    # The registration of the tiling define is done when load_lib().
    load_lib()
    tiling_info = TilingInfo()
    tiling_info.tiling_key_list = tiling_key_list
    static_shape = is_static_shape(inputs, outputs)
    context = get_context()
    if static_shape:
        _change_param_name_to_name(inputs)
        _change_param_name_to_name(op_info.origin_inputs)
        compile_info = context.get_compile_info()
        tiling_config = {"name" : "ascendc_op_para_size", "dtype" : "int", "value" : 2 * 1024 * 1024}
        attrs.append(tiling_config)
        run_info = do_op_tiling(optype, compile_info, op_info.origin_inputs, op_info.origin_outputs, None, None, attrs)
        # bytes.fromhex(run_info['tiling_data']) can deserialization DumpByteBuffer
        # save undecoded tiling data for replay
        tiling_info.tiling_data = run_info["tiling_data"]
        tiling_info.tiling_key = run_info['tiling_key']
        optype_with_tilingkey = optype + "_" + str(tiling_info.tiling_key)
        tiling_def = get_tiling_def(optype_with_tilingkey)
        # judge the tilingkey of this shape now use if the tiling struct of optype itslef
        # or the special registered tilingkey struct
        is_optype_self = False
        if tiling_def is None:
            is_optype_self = True
            tiling_def = get_tiling_def(optype)
        if tiling_def is None:
            return tiling_info
        struct_tiling_def_base : dict = {}
        struct_tiling_def_base = get_struct_tiling_info(tiling_def, struct_tiling_def_base)
        run_info["tiling_data"], _ = _decode_tiling_data(tiling_def, run_info["tiling_data"], struct_tiling_def_base)
        tiling_info.block_dim = run_info["block_dim"]
        tiling_info.clear_atomic = run_info["clear_atomic"]
        tiling_info.schedule_mode = run_info.get("schedule_mode", 0)
        # all tiling struct info by dynamic, except the only one top-level struct of static-shape one itself
        all_dynamic_struct_def_except_self = gen_all_dynamic_struct_def_except_self(\
            is_optype_self, str(tiling_info.tiling_key), tiling_key_list, optype)
        tiling_info.file_content = gen_static_shape(\
            tiling_def, run_info["tiling_data"], struct_tiling_def_base, all_dynamic_struct_def_except_self)
        tiling_info.tiling_data_size = tiling_def.data_size
        total_workspace_size = sum(run_info["workspaces"])
        tiling_info.static_workspace_size = total_workspace_size
        run_info["tiling_data"] = tiling_info.tiling_data.hex()
        tiling_info.raw_run_info = run_info
        if total_workspace_size >= 0:
            if len(run_info["workspaces"]) > 1:
                msg = "the num of workspace can not large than 1"
                raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, msg)
            context.add_workspace("total_workspace", size = total_workspace_size)

    else:
        tiling_info.static_shape_flag = False
        tiling_def_list_of_key = []
        struct_tiling_def_base = {}
        tiling_max_data_size = 0

        optype_tiling_def = get_tiling_def(optype)
        if optype_tiling_def is None:
            LogUtil.print_compile_log(optype, f"do not registe tiling struct!!!", AscendCLogLevel.LOG_ERROR)
            return tiling_info
        struct_tiling_def_base = get_struct_tiling_info(optype_tiling_def, struct_tiling_def_base)

        context.add_workspace("total_workspace", size = -1)

        for tiling_key in tiling_key_list:
            optype_with_tilingkey = optype + "_" + tiling_key
            tiling_def = get_tiling_def(optype_with_tilingkey)
            if tiling_def is not None:
                struct_tiling_def_base = get_struct_tiling_info(tiling_def, struct_tiling_def_base)
                tiling_def.class_def = get_dynamic_tiling_struct(tiling_def)
                tiling_def.tiling_key = tiling_key
                tiling_def_list_of_key.append(tiling_def)
                tiling_max_data_size = max(tiling_max_data_size, tiling_def.data_size)
                tiling_info.tiling_key_data_size[tiling_key] = tiling_def.data_size

        # do not have tiling key return tiling header file of optype
        if len(tiling_def_list_of_key) == 0:
            optype_tiling_def.generate_code = gen_dynamic_shape(optype_tiling_def, struct_tiling_def_base)
            tiling_info.file_content = optype_tiling_def.generate_code
        else: # deal with tiling header file wiht tiling key
            optype_tiling_def.class_def = get_dynamic_tiling_struct(optype_tiling_def)

            # begin tiling header file
            tiling_info.file_content, end_body = \
                                    get_header_and_sub_struct_def(optype_tiling_def, struct_tiling_def_base)

            tiling_info.file_content += "// begin def of all tiling struct\n"
            tiling_info.file_content += optype_tiling_def.class_def
            tiling_struct_dict = set()
            for tiling_def in tiling_def_list_of_key:
                if tiling_def.class_name not in tiling_struct_dict:
                    tiling_info.file_content += tiling_def.class_def
                    tiling_struct_dict.add(tiling_def.class_name)
            is_begin:bool = True
            tiling_info.file_content += get_tiling_copy_func_and_micro(optype_tiling_def.class_name)
            tiling_info.file_content += end_body
        tiling_info.tiling_data_size = max(tiling_max_data_size, optype_tiling_def.data_size)
        tiling_info.default_tiling_size = optype_tiling_def.data_size
    return tiling_info


def get_tiling_declaration(optype: str):
    load_lib()
    tiling_info = TilingInfo()
    tiling_def = get_tiling_def(optype)
    if tiling_def is None:
        return tiling_info
    struct_tiling_def_base : dict = {}
    struct_tiling_def_base = get_struct_tiling_info(tiling_def, struct_tiling_def_base)
    tiling_info.file_content = gen_dynamic_shape(tiling_def, struct_tiling_def_base)
    return tiling_info


def _add_time_stamp_codes(desc_id: str, space_len: int = 1):
    source = "    " * space_len
    return source + f"AscendC::PrintTimeStamp(static_cast<uint32_t>(AscendC::TimeStampId::{desc_id}));\n\n"
