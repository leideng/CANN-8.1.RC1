#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2024. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
AscendC compile log
"""
import os
import stat
from enum import Enum
from datetime import datetime, timezone
from tbe.common.platform.platform_info import get_soc_spec, set_current_compile_soc_info
from tbe.tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE


CompileStage = Enum('CompileStage', ('PRECOMPILE', 'INFERCHANNEL', 'DEBUG_PRECOMPILE', \
    'COMPILE', 'FATBIN', 'LINKRELOCATE'))


class AscendCLogLevel(Enum):
    LOG_DEBUG = 0
    LOG_INFO = 1
    LOG_WARNING = 2
    LOG_ERROR = 3


LOG_LEVEL_TO_STR = {
    AscendCLogLevel.LOG_DEBUG : "\033[32mDEBUG\033[0m",
    AscendCLogLevel.LOG_INFO : "\033[32mINFO\033[0m",
    AscendCLogLevel.LOG_WARNING : "\033[93mWARNING\033[0m",
    AscendCLogLevel.LOG_ERROR : "\033[31mERROR\033[0m",
}


class LogUtil:
    """
    This class defines some common tool function methods.
    """
    class Option(Enum):
        DEFAULT = 0
        NON_SOC = 1

    def __init__(self):
        pass

    # write the cmpile_cmd to log
    @staticmethod
    def dump_compile_log(compile_cmd, stage: CompileStage, log_file=None):
        if log_file is None or compile_cmd is None:
            return
        flags = os.O_RDWR | os.O_CREAT
        modes = stat.S_IWUSR | stat.S_IRUSR
        try:
            with os.fdopen(os.open(log_file, flags, modes), 'a') as f:
                f.write(f'// Stage: {stage}\n')
                f.write(" ".join(str(cmd) for cmd in compile_cmd))
                f.write("\n\n")
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write log failed, reason:", err))

    @staticmethod
    def set_soc_version(soc_version):
        set_current_compile_soc_info(soc_version)

    @staticmethod
    def dump_log(log_str, log_file=None, level="[INFO] : "):
        if log_file is None or log_str is None:
            return
        flags = os.O_RDWR | os.O_CREAT
        modes = stat.S_IWUSR | stat.S_IRUSR
        try:
            with os.fdopen(os.open(log_file, flags, modes), 'a') as f:
                f.write(f'// : log:\n')
                f.write(f"{level} {log_str}")
                f.write("\n\n")
        except Exception as err:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write log failed, reason:", err))

    # print log with level judge
    @staticmethod
    def print_compile_log(kernel_name: str, msg_info: str, log_level: AscendCLogLevel, option: Option = Option.DEFAULT):
        default_log_level = AscendCLogLevel.LOG_WARNING.value
        plog_switch = os.environ.get("ASCEND_SLOG_PRINT_TO_STDOUT")
        if plog_switch is None and log_level.value < default_log_level:
            return
        if plog_switch is not None and int(plog_switch) == 0 and log_level.value < default_log_level:
            return
        plog_level = os.environ.get("ASCEND_GLOBAL_LOG_LEVEL")
        if plog_level is None and log_level.value < default_log_level:
            return
        if plog_level is not None and log_level.value < int(plog_level):
            return
        LogUtil.log_print(kernel_name, msg_info, log_level, option)

    # print log without level judge
    @staticmethod
    def log_print(kernel_name: str, msg_info: str, log_level: AscendCLogLevel, option: Option = Option.DEFAULT):
        short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
        current_time = datetime.now(tz=timezone.utc)
        tim_head = "[\033[32m{}-{}-{} {}:{}:{}\033[0m]".format(current_time.year, 
                                                               current_time.month,
                                                               current_time.day,
                                                               current_time.hour,
                                                               current_time.minute,
                                                               current_time.second)
        level_info = " [{}]".format(LOG_LEVEL_TO_STR[log_level])
        log_msg = tim_head + level_info
        if option is not LogUtil.Option.NON_SOC:
            log_msg += " [{}]".format(short_soc_version.lower())
        if kernel_name != "":
            log_msg += " {}".format(kernel_name)
        log_msg += " {}".format(msg_info)
        print(log_msg)