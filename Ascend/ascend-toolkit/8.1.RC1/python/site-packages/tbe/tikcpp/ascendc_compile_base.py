#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2024. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
ascendc compile base
"""
import os
import stat
import subprocess
import multiprocessing
from collections import namedtuple
from .ascendc_common_utility import CommonUtility, write_mk, CompileInfo
from .global_storage import global_var_storage
from .log_utils import AscendCLogLevel, CompileStage
from tbe.tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE
from tbe.common.platform.platform_info import get_soc_spec, set_soc_spec
from tbe.tvm.contrib.ccec import CCECInfo
from .get_op_tiling import TilingInfo
from .ascendc_constants import SuperKernelLinkMode, KernelMetaType, CORE_TYPE_CUBE, \
    CORE_TYPE_VEC, CORE_TYPE_MIX, SuperKernelEarlyStartMode
from tbe.common.context import get_context


def gen_super_kernel_compile_info(kernel_info, compile_log_path):
    kernel_meta_dir = CommonUtility.get_kernel_meta_dir()
    compile_info = CompileInfo()
    compile_info.src_file = kernel_info["kernel_file"]
    compile_info.dst_file = os.path.join(kernel_meta_dir, kernel_info["kernel_name"] + ".o")
    compile_info.kernel_name = kernel_info["kernel_name"]
    compile_info.origin_func_name = kernel_info["kernel_name"]
    compile_info.op_type = kernel_info["kernel_name"]
    compile_info.tiling_key_list = ["0"]
    compile_info.is_debug = False
    compile_info.compile_log_path = compile_log_path
    compile_info.tiling_key_kernel_type = {"0": kernel_info["kernel_type"]}
    compile_info.no_set_kernel_type = False
    compile_info.default_kernel_type = kernel_info["kernel_type"]
    compile_info.gen_kernel_func_file = kernel_info["kernel_file"]
    compile_info.enable_final_super_kernel_compile = True
    compile_info.super_kernel_info = kernel_info

    tiling_info = TilingInfo()
    tiling_info.static_shape_flag = True
    tiling_info.tiling_key = 0
    tiling_info.tiling_data_file_path = ""
    tiling_info.block_dim = kernel_info["block_dim"]
    return compile_info, tiling_info


def gen_sub_super_kernel_early_start_compile_options(compile_option_tuple, compile_info,
    early_start_mode: SuperKernelEarlyStartMode):
    if early_start_mode == SuperKernelEarlyStartMode.EarlyStartDisable:
        return
    sp_info = get_context().get_addition("super_kernel_sub_info")
    if len(sp_info) != 0 and "super_kernel_count" in sp_info and "super_kernel_sub_id" in sp_info:
        super_kernel_count = sp_info["super_kernel_count"]
        super_kernel_sub_id = sp_info["super_kernel_sub_id"]
        if compile_info.super_kernel_early_start_set_flag and (super_kernel_sub_id < super_kernel_count - 1):
            compile_option_tuple.compile_options.append("-D__ASCENDC_ENABLE_SET_NEXT_TASK_START")
            global_var_storage.set_variable("ascendc_sub_super_kernel_early_start_set_flag", True)
        if compile_info.super_kernel_early_start_wait_flag and (super_kernel_sub_id != 0):
            compile_option_tuple.compile_options.append("-D__ASCENDC_ENABLE_WAIT_PRE_TASK_END")
            global_var_storage.set_variable("ascendc_sub_super_kernel_early_start_wait_flag", True)
    else:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, \
            ("sub super kernel compile must provide super_kernel_sub_info"))


def gen_sub_super_kernel_compile_options(compile_option_tuple, tiling_info, compile_info):
    compile_option_tuple.compile_options.append("-D__ASCENDC_SUPER_KERNEL_DISABLE_TPIPE_BAR_ALL")
    gen_sub_super_kernel_early_start_compile_options(compile_option_tuple, compile_info, \
                                                    SuperKernelEarlyStartMode.EarlyStartEnable)
    return


def get_actual_kernel_type(tiling_key, compile_info, need_ffts, kernel_name):
    code_type = compile_info.code_channel
    default_kernel_type = compile_info.default_kernel_type
    kernel_type = compile_info.tiling_key_kernel_type[
        tiling_key] if tiling_key in compile_info.tiling_key_kernel_type else default_kernel_type
    if kernel_type in [KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0]:
        return CORE_TYPE_CUBE
    elif kernel_type in [KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0]:
        return CORE_TYPE_VEC
    elif kernel_type in [KernelMetaType.KERNEL_TYPE_MIX_AIC_1_2]:
        return CORE_TYPE_MIX
    if compile_info.no_set_kernel_type and need_ffts:
        return code_type
    else:
        CommonUtility.print_compile_log(
            kernel_name, "Aicore Exception Restart not support this kernel type", AscendCLogLevel.LOG_ERROR)
        raise Exception(f"Aicore Exception Restart not support this kernel type")

def localization_sub_op_func_sym(dst_file: str, sub_op_kernel_info):
    symbols = []
    for sub_op in sub_op_kernel_info:
        sub_symbols = sub_op.get("sub_kernel_names", [])
        symbols += sub_symbols
    try:
        localization_symbols_cmd = \
                        ["llvm-objcopy"] + [f"--localize-symbol={symbol}" for symbol in symbols] + [dst_file]
        subprocess.run(localization_symbols_cmd)    
    except Exception as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("localize sub op func sym failed", err))


def gen_super_kernel_link_obj_sequence(compile_info: CompileInfo, sub_op_kernel_info, link_mode: SuperKernelLinkMode):
    super_kernl_files = compile_info.super_kernel_objs if \
        len(compile_info.super_kernel_objs) != 0 else [compile_info.dst_file]
    objs_vec = []
    objs_cube = []
    objs = []
    for sub_op in sub_op_kernel_info:
        if "aiv_bin" in sub_op:
            objs_vec.append(sub_op["aiv_bin"])
        if "aic_bin" in sub_op:
            objs_cube.append(sub_op["aic_bin"])
    if link_mode == SuperKernelLinkMode.PerVecHerCube:
        objs += super_kernl_files
        objs += objs_vec
        objs += objs_cube
    elif link_mode == SuperKernelLinkMode.PerCubeHerVec:
        objs += super_kernl_files
        objs += objs_cube
        objs += objs_vec
    elif link_mode == SuperKernelLinkMode.PerCubeHerVecWithSuper:
        if len(super_kernl_files) == 1:
            objs += super_kernl_files
            objs += objs_cube
            objs += objs_vec
        else:        
            sp_vec = ""
            sp_cube = ""
            for sp_file in super_kernl_files:
                if "mix_aic" in sp_file:
                    sp_cube = sp_file
                elif "mix_aiv" in sp_file:
                    sp_vec = sp_file
            objs.append(sp_cube)
            objs += objs_cube
            objs.append(sp_vec)
            objs += objs_vec
    else:
        raise Exception(f"invalid link mode type")
    return objs


def raise_error_for_sub_super_kernel():
    if global_var_storage.get_variable("ascendc_enable_super_kernel") is True:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("super kernel compile only support for static shape"))


def add_sub_super_kernel_info(js):
    if global_var_storage.get_variable("ascendc_enable_super_kernel") is True:
        js["sub_operator_params"] = global_var_storage.get_variable("ascendc_sub_super_kernel_params")
        js["sub_operator_kernel_type"] = global_var_storage.get_variable("ascendc_sub_super_kernel_type")
        js["sub_operator_kernel_name"] = global_var_storage.get_variable("ascendc_sub_super_kernel_fun_names")
        js["sub_operator_early_start_set_flag"] = global_var_storage.get_variable(
            "ascendc_sub_super_kernel_early_start_set_flag")
        js["sub_operator_early_start_wait_flag"] = global_var_storage.get_variable(
            "ascendc_sub_super_kernel_early_start_wait_flag")
        return js
    return js


def save_kernel_type(kernel_type: str):
    if global_var_storage.get_variable("ascendc_enable_super_kernel") is True:
        global_var_storage.set_variable("ascendc_sub_super_kernel_type", kernel_type)


def gen_sub_kernel_name(current_kernel_name: str, arch: str, kernel_type: str, obj_files: str):
    if global_var_storage.get_variable("ascendc_enable_super_kernel") is True:
        sp_info = get_context().get_addition("super_kernel_sub_info")
        save_kernel_type(kernel_type)
        if len(sp_info) != 0 and "super_kernel_count" in sp_info and "super_kernel_sub_id" in sp_info:
            super_kernel_count = sp_info["super_kernel_count"]
            super_kernel_sub_id = sp_info["super_kernel_sub_id"]
            new_kernel_name = current_kernel_name + "_" + str(super_kernel_count) + "_" + str(super_kernel_sub_id)
            tmp_kernel_info_list = global_var_storage.get_variable("ascendc_sub_super_kernel_fun_names")
            tmp_kernel_info_list[arch] = {"func_name": new_kernel_name, "obj_files" : obj_files}
            global_var_storage.set_variable("ascendc_sub_super_kernel_fun_names", tmp_kernel_info_list)
            return new_kernel_name
        else:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, \
                ("sub super kernel compile must provide super_kernel_sub_info"))
    else:
        return current_kernel_name

SingleTilingKeyCompileParams = namedtuple('SingleTilingKeyCompileParams', \
    ['tiling_key', 'compile_info', 'sub_arch', 'tiling_info', 'code_channel', 'compile_option_tuple'])


def fatbin_objs(obj_files: list, dst_file: str, is_debug: bool, compile_log_path=None):
    if global_var_storage.get_variable("ascendc_enable_super_kernel") is True:
        tmp_kernel_info_list = global_var_storage.get_variable("ascendc_sub_super_kernel_fun_names")
        if len(tmp_kernel_info_list) == 2:
            tmp_obj_files = []
            for arch in tmp_kernel_info_list:
                tmp_obj_files.append(tmp_kernel_info_list[arch]["obj_files"])
            try:
                subprocess.run(['ar', 'rcs', dst_file] + tmp_obj_files)
            except Exception as err:
                raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("ar sub super kernel op files failed", err))
            return
    compile_cmd = [CCECInfo.get_exe("ld.lld"), '-m', 'aicorelinux', '-r', '-Ttext=0']
    if global_var_storage.get_variable("ascendc_enable_coverage"):
        compile_cmd.append('-q')
    if not is_debug:
        compile_cmd.append('-x')
    for obj in obj_files:
        compile_cmd += [obj]
    compile_cmd += ['-static', '-o', "%s" % dst_file]
    CommonUtility.run_cmd_inner(compile_cmd, CompileStage.FATBIN, compile_log_path)
    if not global_var_storage.get_variable("ascendc_compile_debug_config"):
        for obj in obj_files:
            os.remove(obj)


def link_relocatable(bin_file_path, compile_log_path=None):
    short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
    if short_soc_version == "Ascend310B":
        link_cmd = [CCECInfo.get_exe("ld.lld"),
                    "-m",
                    "aicorelinux",
                    "-Ttext=0",
                    "%s" % bin_file_path,
                    "-static",
                    "-o",
                    "%s" % bin_file_path,
                    ]
        if global_var_storage.get_variable("ascendc_enable_coverage"):
            link_cmd.append('-q')
    else:
        link_cmd = [CCECInfo.get_exe("ld.lld"),
                    "-m",
                    "aicorelinux",
                    "-Ttext=0",
                    "%s" % bin_file_path,
                    "-static",
                    "-o",
                    "%s" % bin_file_path,
                    ]
        if global_var_storage.get_variable("ascendc_enable_coverage"):
            link_cmd.append('-q')
    CommonUtility.run_cmd_inner(link_cmd, CompileStage.LINKRELOCATE, compile_log_path)


def compile_multi_tilingkey(tiling_key_list, cmds_list, dstfile_name, compile_log_path):
    parallel_compile_check = os.getenv('TILINGKEY_PAR_COMPILE')
    if parallel_compile_check != '1' and parallel_compile_check != '0':
        CommonUtility.print_compile_log("", "[WARNING] TILINGKEY_PAR_COMPILE ONLY SUPPORT 0 OR 1",
            AscendCLogLevel.LOG_WARNING)
    ci_big_makefile_par_switch = os.getenv('TILINGKEY_PAR_COMPILE') == '1'
    ascendc_self_par_job = os.getenv('ASCENDC_PAR_COMPILE_JOB')
    ascendc_self_par_job_num = 0
    if ascendc_self_par_job is not None:
        if ascendc_self_par_job == '1':
            cpu_db_num = 2 * multiprocessing.cpu_count() - 2
            ascendc_self_par_job_num = cpu_db_num if cpu_db_num > 0 else 1
        else:
            ascendc_self_par_job_num = int(ascendc_self_par_job)

    if ci_big_makefile_par_switch or ascendc_self_par_job_num > 0:
        write_mk(tiling_key_list, cmds_list, dstfile_name, compile_log_path)
        # when TILINGKEY_PARALLEL_COMPILATION_SWITCH and ASCENDC_PAR_COMPILE_JOB conflicts
        # TILINGKEY_PARALLEL_COMPILATION_SWITCH first
        mk_file = f'{dstfile_name}.mk'
        if ci_big_makefile_par_switch:
            cmd = ['make', '-f', mk_file]
        else:
            cmd = ['make', '-f', mk_file, '-j', f'{ascendc_self_par_job_num}']
        cmd_str = ' '.join(cmd)
        file_name = ""
        if global_var_storage.get_variable("ascendc_enable_build_log") is True:
            file_name, kernel_name, hash_name = CommonUtility.get_build_file_name(cmds_list[0], CompileStage.COMPILE)
            try:
                with open(file_name, mode="at") as f:
                    os.chmod(file_name, stat.S_IRUSR + stat.S_IWUSR)
                    f.write("%s\n" % (cmd_str))
                    cmd.append('2>&1')
                    cmd.append('|')
                    cmd.append('tee -a')
                    cmd.append(file_name)
                    cmd_str = ' '.join(cmd)
            except Exception as err:
                raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, ("write log failed, reason is:", err))
        ret = os.system(f'{cmd_str}')
        if ret != 0 and global_var_storage.get_variable("ascendc_enable_build_log") is True:
            file_name_parts = file_name.split('.')
            new_file_name = file_name_parts[0] + "_error." + file_name_parts[-1]
            os.rename(file_name, new_file_name)
            CommonUtility.print_compile_log("", "Operator {}_{}: errors occurred during compile phase \
of {}, See also {}".format(kernel_name, hash_name, \
str(CompileStage.COMPILE), new_file_name), AscendCLogLevel.LOG_ERROR)
            raise Exception("An error occurred during compile phases of {}".format(str(CompileStage.COMPILE)))
        if not global_var_storage.get_variable("ascendc_compile_debug_config"):
            CommonUtility.remove_temp_file(mk_file)
    else:
        for cmds in cmds_list:
            CommonUtility.run_cmd_inner(cmds, CompileStage.COMPILE, compile_log_path)