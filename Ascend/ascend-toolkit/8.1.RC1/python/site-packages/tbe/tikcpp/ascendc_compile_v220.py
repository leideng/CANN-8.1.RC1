#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2024. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
ascendc compile v220
"""

import os
from tbe.common.buildcfg import get_current_build_config
from .global_storage import global_var_storage
from .ascendc_common_utility import CommonUtility, CompileInfo
from .get_op_tiling import TilingInfo
from .log_utils import CompileStage
from .ascendc_constants import CORE_TYPE_MIX, CORE_TYPE_CUBE, CORE_TYPE_VEC, ASCENDC_OOM, KernelMetaType,\
    MIX_CORE_MACRO, TILING_KEY_MACRO
from .ascendc_compile_base import fatbin_objs, compile_multi_tilingkey, \
    SingleTilingKeyCompileParams, gen_sub_kernel_name
from .ascendc_compile_dfx import DFXSectionGenerator


def gen_compile_cmd_v220(src_file: str, dst_file: str, compile_option_tuple, sub_arch: str, tiling_file: str,\
    with_tiling_file: bool = True):
    """
    Generate the compile command for the V220 compiler.
    :param src_file: the source file
    :param dst_file: the destination file
    :param extra_options: the extra options
    :param with_tiling_file: whether with the tiling file
    :return: the compile command
    """
    if global_var_storage.get_variable("ascendc_enable_ccache") == True:
        compile_cmd = [os.environ.get("ASCENDC_CCACHE_EXECUTABLE"), \
            global_var_storage.get_variable("ascendc_compiler_path"), '-c', '-O3']
    else:
        compile_cmd = [global_var_storage.get_variable("ascendc_compiler_path"), '-c', '-O3']

    for option in compile_option_tuple.compile_options:
        compile_cmd += [option]
    compile_cmd += [src_file, "--cce-aicore-arch=%s" % sub_arch,
                    "--cce-aicore-only", "-o", dst_file,
                    "-mllvm", "-cce-aicore-stack-size=0x8000",
                    "-mllvm", "-cce-aicore-function-stack-size=0x8000",
                    "-mllvm", "-cce-aicore-record-overflow=false",
                    "-mllvm", "-cce-aicore-addr-transform",
                    "-mllvm", "-cce-aicore-dcci-insert-for-scalar=false"]
    if global_var_storage.get_variable("ascendc_enable_sanitizer"):
        compile_cmd += ["--cce-enable-sanitizer", "-g"]
        compile_cmd += ["-mllvm", "-cce-aicore-long-call", "-mllvm", "-cce-aicore-jump-expand=true"]

    for opt in compile_option_tuple.mllvm_options:
        compile_cmd += [opt]

    if with_tiling_file and tiling_file != "":
        compile_cmd += ["-include", tiling_file]
    compile_cmd += ["-std=c++17"]
    if "oom" in get_current_build_config("tir.op_debug_config"):
        compile_cmd += [f"-D{ASCENDC_OOM}={1}"]
    return compile_cmd


def get_v220_kernel_type_mix_flag(compile_info: CompileInfo, tiling_info: TilingInfo):
    is_v220_flag = CommonUtility.is_v220()
    kernel_type_res = 0
    is_single_and_using_hard_sync = is_v220_flag and compile_info.hard_sync and \
            compile_info.code_channel in [CORE_TYPE_VEC, CORE_TYPE_CUBE]
    if is_v220_flag is False:
        return False, is_single_and_using_hard_sync

    is_mix = compile_info.code_channel == CORE_TYPE_MIX
    if compile_info.no_set_kernel_type:
        return is_mix, is_single_and_using_hard_sync
    
    used_tiling_keys = []
    if tiling_info.static_shape_flag:
        used_tiling_keys.append(str(tiling_info.tiling_key))
    else:
        used_tiling_keys = compile_info.tiling_key_list

    for tiling_key in used_tiling_keys:
        kernel_type = compile_info.tiling_key_kernel_type[tiling_key]
        if kernel_type == KernelMetaType.KERNEL_TYPE_AIV_ONLY:
            kernel_type_res = kernel_type_res | 0x1
        elif kernel_type == KernelMetaType.KERNEL_TYPE_AIC_ONLY:
            kernel_type_res = kernel_type_res | 0x2
        elif kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_HARD_SYNC or \
            kernel_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0:
            kernel_type_res = kernel_type_res | 0x4
        else:
            kernel_type_res = kernel_type_res | 0x8
    if kernel_type_res == 2 or kernel_type_res == 1:
        return False, False
    else:
        return True, is_single_and_using_hard_sync


def compile_single_tiling_v220(param : SingleTilingKeyCompileParams):
    dst_file = param.compile_info.dst_file[:-2] + '_%s.o' % param.tiling_key
    compile_cmd = gen_compile_cmd_v220(param.compile_info.gen_kernel_func_file, dst_file, param.compile_option_tuple, \
                                            param.sub_arch, param.tiling_info.tiling_data_file_path)
    compile_cmd += [f"-D{TILING_KEY_MACRO}={param.tiling_key}UL"]
    compile_cmd += \
        [f"-D{param.compile_info.origin_func_name}={param.compile_info.origin_func_name}_{param.tiling_key}_tilingkey"]
    if param.code_channel == CORE_TYPE_MIX or \
        (param.compile_info.hard_sync and param.compile_info.code_channel in [CORE_TYPE_VEC, CORE_TYPE_CUBE]):
        kernel_func_name = param.compile_info.kernel_name[:-7] + param.tiling_key + param.compile_info.kernel_name[-8:]
    else:
        kernel_func_name = param.compile_info.kernel_name + '_%s' % param.tiling_key
    if param.code_channel == CORE_TYPE_MIX:
        compile_cmd += [f"-D{MIX_CORE_MACRO}={1}"]
    compile_cmd += [f"-Dauto_gen_{param.compile_info.origin_func_name}_kernel={kernel_func_name}"]
    return compile_cmd, kernel_func_name


def call_bisheng_v220(compile_info: CompileInfo, compile_option_tuple, tiling_info: TilingInfo, sub_arch: str,\
    code_channel: int):
    """generate bisheng cmd instead of _build_aicore_compile_cmd, since tbe set davinci-c220-{sub_core} in build_cce.cc

    Args:
        compile_info (CompileInfo): compile info for generate .o and .json
        compile_options (list): compile options for bisheng
        tiling_info (TilingInfo): tiling info
        sub_arch (str): davinci-c220-cube or davinci-c220-vec
    """
    sources = CommonUtility().ascendc_read_file(compile_info.gen_kernel_func_file)
    new_sources = sources[:-1]
    if tiling_info.static_shape_flag:
        compile_cmd = gen_compile_cmd_v220(compile_info.gen_kernel_func_file, compile_info.dst_file, \
            compile_option_tuple, sub_arch, tiling_info.tiling_data_file_path)
        # tbe-pass add "__kernel0" in tbe-codegen and json, we use -D to change function name
        if code_channel == CORE_TYPE_MIX or \
            (compile_info.hard_sync and compile_info.code_channel in [CORE_TYPE_VEC, CORE_TYPE_CUBE]):
            # if code_mix, do not add __kernel0 when compile
            current_kernel_name = compile_info.kernel_name
            current_kernel_name = gen_sub_kernel_name(current_kernel_name, sub_arch,\
                KernelMetaType.KERNEL_TYPE_MIX_AIC_1_2.name if code_channel == CORE_TYPE_MIX else \
                    (KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0.name if code_channel == CORE_TYPE_VEC else \
                    KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0.name), compile_info.dst_file)
        else:
            current_kernel_name = compile_info.get_kernel_func_name()
            current_kernel_name = gen_sub_kernel_name(current_kernel_name, "AiCore",\
                KernelMetaType.KERNEL_TYPE_AIC_ONLY.name if sub_arch == "dav-c220-cube" else \
                KernelMetaType.KERNEL_TYPE_AIV_ONLY.name, compile_info.dst_file)
        compile_cmd += [f"-Dauto_gen_{compile_info.origin_func_name}_kernel={current_kernel_name}"]
        if code_channel == CORE_TYPE_MIX:
            compile_cmd += [f"-D{MIX_CORE_MACRO}={1}"]
        new_sources += DFXSectionGenerator().generate_dfx_section(str(tiling_info.tiling_key),\
                                            tiling_info, current_kernel_name, compile_info, True)
        new_sources += "#endif\n"
        # add dfx info section to sourse file
        CommonUtility().ascendc_write_file(compile_info.gen_kernel_func_file, new_sources)

        compile_cmd += [f"-D{TILING_KEY_MACRO}={tiling_info.tiling_key}UL"]
        CommonUtility.run_cmd_inner(compile_cmd, CompileStage.COMPILE, compile_info.compile_log_path)
        return [f'{tiling_info.tiling_key}']
    else:
        obj_files = []
        for tiling_key in compile_info.tiling_key_list:
            dst_file = compile_info.dst_file[:-2] + '_%s.o' % tiling_key
            obj_files.append(dst_file)
        cmds_list = []
        for tiling_key in compile_info.tiling_key_list:
            param = SingleTilingKeyCompileParams(\
                tiling_key, compile_info, sub_arch, tiling_info, code_channel, compile_option_tuple)
            compile_cmd, kernel_name = compile_single_tiling_v220(param)
            new_sources += DFXSectionGenerator().generate_dfx_section(tiling_key,\
                                                tiling_info, kernel_name, compile_info, True)
            cmds_list.append(compile_cmd)
        new_sources += "#endif\n"
        # add dfx info section to sourse file
        CommonUtility().ascendc_write_file(compile_info.gen_kernel_func_file, new_sources)

        compile_multi_tilingkey(compile_info.tiling_key_list, cmds_list, \
            os.path.basename(compile_info.dst_file)[:-2], compile_info.compile_log_path)
        fatbin_objs(obj_files, compile_info.dst_file, compile_info.is_debug, compile_info.compile_log_path)
        return compile_info.tiling_key_list


def get_ktype_section_variable(variable_name: str, section_func_name: str, kernel_meta_type: KernelMetaType):
    if kernel_meta_type == KernelMetaType.KERNEL_TYPE_AIV_ONLY:
        section_var = f""
        section_var += f"static const struct FunLevelKType {variable_name} __attribute__ "
        section_var += f"((used, section (\".ascend.meta.{section_func_name}\"))) = "
        section_var += f"{{ {{{{F_TYPE_KTYPE, sizeof(unsigned int)}}, K_TYPE_AIV}} }};\n"
    elif kernel_meta_type == KernelMetaType.KERNEL_TYPE_AIC_ONLY:
        section_var = f""
        section_var += f"static const struct FunLevelKType {variable_name} __attribute__ "
        section_var += f"((used, section (\".ascend.meta.{section_func_name}\"))) = "
        section_var += f"{{ {{{{F_TYPE_KTYPE, sizeof(unsigned int)}}, K_TYPE_AIC}} }};\n"
    elif kernel_meta_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_HARD_SYNC:
        section_var = f""
        section_var += f"static const struct FunLevelMixCoreType {variable_name} __attribute__ "
        section_var += f"((used, section (\".ascend.meta.{section_func_name}\"))) = "
        section_var += f"{{ {{{{F_TYPE_KTYPE, sizeof(unsigned int)}}, K_TYPE_MIX_AIV_MAIN}},\
    {{{{F_TYPE_MIX_TASK_RATION, sizeof(unsigned int)}}, 0, 1}} }};\n"
    elif kernel_meta_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_HARD_SYNC:
        section_var = f""
        section_var += f"static const struct FunLevelMixCoreType {variable_name} __attribute__ "
        section_var += f"((used, section (\".ascend.meta.{section_func_name}\"))) = "
        section_var += f"{{ {{{{F_TYPE_KTYPE, sizeof(unsigned int)}}, K_TYPE_MIX_AIC_MAIN}},\
    {{{{F_TYPE_MIX_TASK_RATION, sizeof(unsigned int)}}, 1, 0}} }};\n"
    elif kernel_meta_type == KernelMetaType.KERNEL_TYPE_MIX_AIV_1_0:
        section_var = f""
        section_var += f"static const struct FunLevelMixCoreType {variable_name} __attribute__ "
        section_var += f"((used, section (\".ascend.meta.{section_func_name}\"))) = "
        section_var += f"{{ {{{{F_TYPE_KTYPE, sizeof(unsigned int)}}, K_TYPE_MIX_AIV_MAIN}},\
    {{{{F_TYPE_MIX_TASK_RATION, sizeof(unsigned int)}}, 0, 1}} }};\n"
    elif kernel_meta_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_0:
        section_var = f""
        section_var += f"static const struct FunLevelMixCoreType {variable_name} __attribute__ "
        section_var += f"((used, section (\".ascend.meta.{section_func_name}\"))) = "
        section_var += f"{{ {{{{F_TYPE_KTYPE, sizeof(unsigned int)}}, K_TYPE_MIX_AIC_MAIN}},\
    {{{{F_TYPE_MIX_TASK_RATION, sizeof(unsigned int)}}, 1, 0}} }};\n"
    elif kernel_meta_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_1:
        section_var = f""
        if "mix_aic" in variable_name:
            section_var += f"#if defined(__DAV_C220_CUBE__)\n"
        elif "mix_aiv" in variable_name:
            section_var += f"#if defined(__DAV_C220_VEC__)\n"
        section_var += f"static const struct FunLevelMixCoreType {variable_name} __attribute__ "
        section_var += f"((used, section (\".ascend.meta.{section_func_name}\"))) = "
        section_var += f"{{ {{{{F_TYPE_KTYPE, sizeof(unsigned int)}}, K_TYPE_MIX_AIC_MAIN}},\
    {{{{F_TYPE_MIX_TASK_RATION, sizeof(unsigned int)}}, 1, 1}} }};\n"
        section_var += "#endif\n"
    elif kernel_meta_type == KernelMetaType.KERNEL_TYPE_MIX_AIC_1_2:
        section_var = f""
        if "mix_aic" in variable_name:
            section_var += f"#if defined(__DAV_C220_CUBE__)\n"
        elif "mix_aiv" in variable_name:
            section_var += f"#if defined(__DAV_C220_VEC__)\n"
        section_var += f"static const struct FunLevelMixCoreType {variable_name} __attribute__ "
        section_var += f"((used, section (\".ascend.meta.{section_func_name}\"))) = "
        section_var += f"{{ {{{{F_TYPE_KTYPE, sizeof(unsigned int)}}, K_TYPE_MIX_AIC_MAIN}},\
    {{{{F_TYPE_MIX_TASK_RATION, sizeof(unsigned int)}}, 1, 2}} }};\n"
        section_var += "#endif\n"
    else:
        raise Exception(f"invalid kernel meta type")
    return section_var