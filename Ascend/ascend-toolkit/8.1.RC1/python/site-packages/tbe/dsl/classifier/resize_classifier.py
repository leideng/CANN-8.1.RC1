"""
Copyright (c) Huawei Technologies Co., Ltd. 2022. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the Apache License Version 2.0.
You may not use this file except in compliance with the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
Apache License for more details at
http://www.apache.org/licenses/LICENSE-2.0

classifier of shape in positive resize
"""
from functools import reduce
from typing import Tuple

from operator import mul
from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.base import operation

from . import shape_classifier


@shape_classifier.register_classifier(shape_classifier.RESIZE)
def classify_resize(ins: list, extra_params: dict):
    """
    classifier of positive resize
    :param ins: A list contains images, size.
    :param extra_params: reserved
    :return:
    """
    return ResizeClassifier(ins, extra_params).classify()


class ResizeClassifier:
    INPUT_COUNT = 2
    IMAGE_DIMS = 5
    SIZE_DIMS = 1
    SIZE_COUNT = 2
    INPUT_IMAGE_IDX = 0
    INPUT_SIZE_IDX = 1
    UNKNOWN_SHAPE = -1
    UNKNOWN_RANK = -2
    DYNAMIC_CONST = "_dynamic_const"
    DYNAMIC_SHAPE = "_dynamic_shape"
    DYNAMIC_RANK = "_dynamic_rank"
    BROADCAST = "broadcast"
    FIRST_HW = "first_hw"
    PURE_COPY = "pure_copy"

    def __init__(self, ins: list, extra_params: dict) -> None:
        self.ins = ins
        self.axis_h_idx = 2
        self.axis_w_idx = 3
        self.new_h_idx = 1
        self.new_w_idx = 2
        self.new_c0_idx = 3
        self.new_range_beg = 2
        self.axis_c0 = 16
        self.pair_ones = [1, 1]
        self.default_size = [-1, -1]
        self.default_unknown_shape = [-1, -1, -1, self.axis_c0]
        self.image_shape = list(self.ins[self.INPUT_IMAGE_IDX].get("shape"))
        self.image_range = list(self.ins[self.INPUT_IMAGE_IDX].get("range"))
        self.size_shape = list(self.ins[self.INPUT_SIZE_IDX].get("shape"))
        self.size_list = list(self.ins[self.INPUT_SIZE_IDX].get("const_value", self.default_size))
        if isinstance(extra_params, dict):
            self.half_pixel_centers = extra_params.get("half_pixel_centers", False)
        else:
            self.half_pixel_centers = False
        

    @property
    def _is_const(self):
        return (-1 not in self.size_list and -1 not in self.image_shape) or operation.get_op_mode() == "static"

    @property
    def _is_unknown_shape(self):
        return self.UNKNOWN_SHAPE in self.image_shape + self.size_shape

    @property
    def _is_unknown_rank(self):
        return self.UNKNOWN_RANK in self.image_shape + self.size_shape

    @property
    def _current_mode(self):
        if self._is_const:
            return self.DYNAMIC_CONST
        if self._is_unknown_shape:
            return self.DYNAMIC_SHAPE
        if self._is_unknown_rank:
            return self.DYNAMIC_RANK

        return self.DYNAMIC_SHAPE

    def _check_inputs(self):
        if len(self.ins) != self.INPUT_COUNT:
            dict_args = {
                "errCode": "E90001",
                "detailed_cause": f'resize must has {self.INPUT_COUNT} inputs, but it is {len(self.ins)}'
            }
            raise RuntimeError(dict_args, get_error_message(dict_args))

        if len(self.image_shape) != self.IMAGE_DIMS:
            dict_args = {
                "errCode": "E90001",
                "detailed_cause": f'images must be {self.IMAGE_DIMS}-D tensor, but it is {len(self.image_shape)}'
            }
            raise RuntimeError(dict_args, get_error_message(dict_args))

        if len(self.size_shape) != self.SIZE_DIMS:
            dict_args = {
                "errCode": "E90001",
                "detailed_cause": f'size must be {self.SIZE_DIMS}-D tensor, but it is {len(self.size_shape)}'
            }
            raise RuntimeError(dict_args, get_error_message(dict_args))

        if len(self.size_list) != self.SIZE_COUNT:
            dict_args = {
                "errCode": "E90001",
                "detailed_cause": f'size value must be {self.SIZE_COUNT}-D, but it is {len(self.size_list)}'
            }
            raise RuntimeError(dict_args, get_error_message(dict_args))

    def _update_image_range(self):
        h_range = self.image_range[self.axis_h_idx]
        w_range = self.image_range[self.axis_w_idx]
        if h_range[0] is None:
            h_range = (1, h_range[1])
        if w_range[0] is None:
            w_range = (1, w_range[1])
        self.image_range[self.axis_h_idx] = h_range
        self.image_range[self.axis_w_idx] = w_range

    def _update_const(self):
        if self.image_shape[self.axis_h_idx:-1] == self.size_list:
            self.image_shape = [reduce(mul, self.image_shape[:-1]), 1, 1, self.image_shape[-1]]
            self.image_range = [(self.image_shape[0], self.image_shape[0]), (1, 1), (1, 1), self.image_range[-1]]
            self.size_list = self.pair_ones
        elif self.image_shape[self.axis_h_idx:-1] == [1, 1]:
            self.image_shape = [reduce(mul, self.image_shape[:self.axis_h_idx]), 1, 1, self.image_shape[-1]]
            self.image_range = [(self.image_shape[0], self.image_shape[0]), (1, 1), (1, 1), self.image_range[-1]]
            self.size_list = [reduce(mul, self.size_list), 1]
        else:
            self.image_shape = [reduce(mul, self.image_shape[:self.axis_h_idx])] + self.image_shape[self.axis_h_idx:]
            self.image_range = [(self.image_shape[0], self.image_shape[0])] + self.image_range[self.axis_h_idx:]

    @staticmethod
    def _gen_range(*ranges):
        low_list = []
        high_list = []
        for val in ranges:
            low_list.append(val[0])
            high_list.append(val[1])
        ret_range = []
        if None in low_list:
            ret_range.append(1)
        else:
            ret_range.append(reduce(mul, low_list))

        if None in high_list:
            ret_range.append(None)
        else:
            ret_range.append(reduce(mul, high_list))
        return tuple(ret_range)

    def _update_unknown_shape(self):
        self.image_shape = self.default_unknown_shape
        tmp_range = [self._gen_range(self.image_range[0], self.image_range[1])]
        self.image_range = tmp_range + self.image_range[self.axis_h_idx:-1] + [(self.axis_c0, self.axis_c0)]
        self.size_list = self.default_size

    def _update_unknown_rank(self):
        self.image_shape = self.default_unknown_shape
        self.image_range = [(1, None), (1, None), (1, None), (self.axis_c0, self.axis_c0)]
        self.size_list = self.default_size

    def _gen_broadcast_input(self):
        image_shape = self.image_shape.copy()
        image_range = self.image_range.copy()
        image_shape[self.new_h_idx:self.new_c0_idx] = [1, 1]
        image_range[self.new_h_idx:self.new_c0_idx] = [(1, 1), (1, 1)]
        self.size_list = [-1, 1]
        return self._gen_input(image_shape, image_range, self.BROADCAST)

    def _gen_first_hw_input(self):
        image_range = self.image_range.copy()
        # different from pure copy
        h_range = (self.new_range_beg, self.image_range[self.new_h_idx][1])
        w_range = (self.new_range_beg, self.image_range[self.new_w_idx][1])
        image_range[self.new_h_idx:self.new_c0_idx] = [h_range, w_range]
        self.size_list = self.pair_ones
        return self._gen_input(self.image_shape, image_range, self.FIRST_HW)

    def _gen_pure_copy_input(self):
        image_shape = [-1, 1, 1, self.axis_c0]
        image_range = [self._gen_range(*self.image_range[:-1])]
        image_range.extend([(1, 1), (1, 1), self.image_range[-1]])
        self.size_list = self.pair_ones
        return self._gen_input(image_shape, image_range, self.PURE_COPY)

    def classify(self):
        """
        classify process
        """
        self._check_inputs()
        self._update_image_range()

        mode_map = {
            self.DYNAMIC_CONST: self._update_const,
            self.DYNAMIC_SHAPE: self._update_unknown_shape,
            self.DYNAMIC_RANK: self._update_unknown_rank
        }
        mode_map.get(self._current_mode)()

        ins_list = []
        ins_list.append(self._gen_input(self.image_shape, self.image_range))
        if self._is_const is False:
            if self.half_pixel_centers is False:
                ins_list.append(self._gen_first_hw_input())
            if self.image_range[self.new_h_idx][0] <= 1 and self.image_range[self.new_w_idx][0] <= 1:
                ins_list.append(self._gen_broadcast_input())
            ins_list.append(self._gen_pure_copy_input())

        return ins_list

    def _gen_input(
        self,
        image_shape,
        image_range,
        _mode="resize",
    ):
        new_image = {"shape": image_shape, "range": image_range, "mode": _mode}
        return [new_image, self.size_list]
