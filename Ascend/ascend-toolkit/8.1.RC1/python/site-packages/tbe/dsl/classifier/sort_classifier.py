#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in sort
"""
from functools import reduce as shape_product
from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.base import operation

from . import shape_classifier

OP_MODE = "op_mode"
SORT = "sort"
TOPK = "topk"
TOPKV2 = "topkv2"
OP_MODE_MAP = {
    SORT: 0,
    TOPK: 1,
    TOPKV2: 2
}


def element_multiply(inputs):
    """
    get product res
    """
    if len(inputs) == 0:
        return 1
    if None in inputs:
        return None
    return shape_product(lambda x, y: x * y, inputs)


@shape_classifier.register_classifier(shape_classifier.SORT)
def classify_sort(ins: list, extra_params: dict):
    """
    Sort Classifier
    :param ins: A list contains tensor, sort axis
    :param extra_params: A dict contains op_mode(sort/topk/topkv2)
    :return:
    """
    return SortClassifier(ins, extra_params).classify()


class SortClassifier:
    def __init__(self, ins: list, extra_params: dict):
        """
        :param ins: input list
        :param extra_params:
        """
        self.ins = ins
        self.mode = OP_MODE_MAP.get(extra_params.get(OP_MODE, SORT))
        operation.get_context().add("_op_mode", self.mode)
        self.is_static = operation.get_op_mode() == "static"
        self.x_shape = None
        self.x_dtype = None
        self.sort_axis = None

        self.check_input()

    def check_input(self):
        if not (len(self.ins) == 2 or len(self.ins) == 3):
            dict_args = {}
            dict_args["errCode"] = "E90001"
            dict_args["detailed_cause"] = "The input args of sort classifier must be 2 or 3"
            raise RuntimeError(dict_args, get_error_message(dict_args))

        self.x_shape = list(self.ins[0].get("shape"))
        self.x_dtype = self.ins[0].get("dtype")

        if self.mode > 0:
            k_num = self.ins[2] if isinstance(self.ins[2], int) else 0
            operation.get_context().add("_k_num", k_num)

        if -2 in self.x_shape:
            self.sort_axis = -1
        else:
            self.sort_axis = self.ins[1]

            if self.sort_axis == -1:
                self.sort_axis = len(self.x_shape) - 1

            if self.sort_axis != len(self.x_shape) - 1:
                raise RuntimeError("Sort axis must be the last dim.")

            if self.is_static and self.mode == 2:
                raise RuntimeError("TopKV2 only supports dynamic.")

    def classify(self):
        return self.static_classify() if self.is_static else self.dynamic_classify()

    def static_classify(self):
        input_shape = [element_multiply(self.x_shape[0:self.sort_axis]), self.x_shape[self.sort_axis]]

        input_dict = {
            "shape": input_shape,
            "dtype": self.x_dtype,
            "range": [(_range, _range) for _range in input_shape]
        }

        return [[input_dict, ]]

    def dynamic_classify(self):
        input_dict = {
            "shape": [-1, -1],
            "dtype": self.x_dtype,
            "range": [(1, None), (1, None)]
        }

        if self.mode == 2:
            input_k = {
                "shape": [1, ],
                "range": [(1, None)]
            }
            return [[input_dict, input_k]]

        return [[input_dict, ]]
