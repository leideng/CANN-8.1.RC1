#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2021-2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in quant
"""
from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.base import operation
from . import shape_classifier


@shape_classifier.register_classifier(shape_classifier.QUANT)
def classify(ins: list, extra_params: dict):
    """
    classify
    :param ins: input list
    :param extra_params: include transpose list
    :return:
    """

    def _is_const(_ins):
        dim_length = max(len(x.get('shape')) for x in _ins)
        shapes = [list(x.get('shape')) for x in _ins]
        for i in range(dim_length):
            if min(s[i] for s in shapes) == -1:
                return False
        return True

    def _update_shape_range(_shape, _range):
        new_shape, new_range = [], []
        for dim_value, dim_range in zip(_shape, _range):
            if dim_value > 0:
                dim_range = (dim_value, dim_value)
            elif dim_range[0] == dim_range[1] and not dim_range[0] is None and dim_range[0] > 0:
                dim_value = dim_range[0]
            new_shape.append(dim_value)
            new_range.append(dim_range)
        return new_shape, new_range

    if len(ins) < 1:
        dict_args = {"errCode": "E90001", "detailed_cause": "input numbers error"}
        raise RuntimeError(dict_args, get_error_message(dict_args))

    quant_mode = "original"
    if _is_const(ins):
        quant_mode = "const"
    operation.get_context().add("quant_mode", quant_mode)

    out = []
    for _index, _input in enumerate(ins):
        shape_x = _input.get("shape")
        range_x = _input.get("range")
        format_x = _input.get("format")
        ori_format = _input.get("ori_format")
        ori_shape = _input.get("ori_shape")
        if "dtype" in _input:
            dtype_x = _input.get("dtype")
        elif "data_type" in _input:
            dtype_x = _input.get("data_type")
        else:
            raise RuntimeError("need dtype or data_type in input")

        shape_x, range_x = _update_shape_range(shape_x, range_x)
        new_input_x = {
            "shape": shape_x,
            "range": range_x,
            "dtype": dtype_x,
            "format": format_x,
            "ori_format": ori_format,
            "ori_shape": ori_shape,
            "quant_mode": quant_mode
        }
        out.append(new_input_x)

        if _index == 0:
            operation.get_context().add("format", format_x)
            operation.get_context().add("ori_format", ori_format)
            operation.get_context().add("ori_shape", ori_shape)

    return [out]
