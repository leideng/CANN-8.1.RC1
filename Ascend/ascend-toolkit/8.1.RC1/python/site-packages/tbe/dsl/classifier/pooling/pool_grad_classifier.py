#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2023-2024 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in pool grad
"""
import copy
from typing import Any
from typing import Dict
from typing import Optional

from tbe.common.buildcfg import get_current_build_config
from tbe.dsl.base import operation
from tbe.dsl.classifier import shape_classifier

from .. import util


@shape_classifier.register_classifier(shape_classifier.POOLING_GRAD)
def classify(ins: list, extra_params: Optional[Dict[str, Any]] = None):
    """pooling grad classify to generate all possible res, including base_func res and optimized res
    Args:
        ins (list): original or processed or selective inputs from ops and UB fusion
        extra_params (Optional[Dict[str, Any]], optional): _optimize attributes, default None
    Returns:
        list[Dict]: classify ins
    """
    classify_ins = PoolingGradClassifier(ins, extra_params).classify()

    return [classify_ins[-1]] if get_current_build_config("enable_op_prebuild") else classify_ins


class PoolingGradClassifier:
    def __init__(self, ins, extra_params) -> None:
        self._x = ins[0]
        self._y = ins[1]
        self._dy = ins[2]
        self._window_axes = ins[3]
        self._extra_params = extra_params

        self._rank = len(self._x["shape"])

    def classify(self):
        f_x = self._fuse_shape(self._x)
        f_y = self._fuse_shape(self._y)
        f_dy = self._fuse_shape(self._dy)
        a_window_axes = self._adjust_window_axes()

        # a part of tiling key
        f_x.update(_key=10)

        # add format for optiling
        operation.get_context().add("_x_format", self._x.get("format"))
        operation.get_context().add("_x_ori_format", self._x.get("ori_format"))

        return [[f_x, f_y, f_dy, a_window_axes]]

    def _fuse_shape(self, x):
        x_c = copy.deepcopy(x)
        shape, range_ = x_c["shape"], x_c["range"]

        f_shape, f_range = [], []
        aloned = True
        for i, (d, r) in enumerate(zip(shape, range_)):
            if aloned or i in self._window_axes:
                f_shape.append(d)
                f_range.append(r)
            else:
                f_shape[-1] = util.combine_dim((f_shape[-1], d))
                f_range[-1] = util.combine_range((f_range[-1], r))

            aloned = i in self._window_axes

        x_c.update(shape=f_shape, range=f_range)
        return x_c

    def _adjust_window_axes(self):
        window_axes = []
        pre_i, pre_dim = -1, -1
        for i in self._window_axes:
            dim = pre_dim + min(i - pre_i, 2)
            window_axes.append(dim)

            pre_i, pre_dim = i, dim

        return window_axes
