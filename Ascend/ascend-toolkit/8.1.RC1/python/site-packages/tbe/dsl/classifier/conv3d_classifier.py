#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in conv3d
"""

import copy
from enum import IntEnum

from . import shape_classifier
from .util import LoadModeType


@shape_classifier.register_classifier(shape_classifier.CONV3D)
def classify(ins: list, extra_params: dict):
    """
    classify
    :param ins: input list, includes input_list, attr_list
    :param extra_params: Conv3d is only used in single op
    :return: ins of list after the classification function
    """
    # 1 Define classifer
    classifer = Conv3d(ins, extra_params)
    # 2 Determine the classification
    classifer.determine_classification()
    return classifer.classify()


class Conv3d:
    """
    conv3d classifier
    """
    def __init__(self, ins, extra_params):
        """
        init
        :param ins: input list, includes input_list, attr_list
        :param extra_params: conv3d is only used in single op
        """
        self.ins = ins
        self.input_list, self.attr_list = ins
        self.extra_params = extra_params
        self.single_op_binary_flag = self.extra_params.get("binary_flag", False)
        self.load_mode_list = [LoadModeType.LOAD3D]
        self.cyclebuffer_flag_list = [0]
        self.outs = []

    def determine_classification(self):
        """
        Determines whether it belongs to a classification scenario
        """
        if self.single_op_binary_flag:
            self.load_mode_list = [LoadModeType.LOAD3D]
            self.cyclebuffer_flag_list = [0]

    def classify(self):
        """
        Construct multiple inputs based on branch conditions
        """
        if not self.single_op_binary_flag:
            return [self.ins]

        for branch in self.load_mode_list:
            for cyclebuffer_flag in self.cyclebuffer_flag_list:
                tmp_ins = list(copy.deepcopy(self.ins))
                tmp_ins.append([{"options": {"load_mode": branch, "cyclebuffer_flag": cyclebuffer_flag}}])
                self.outs.append(tuple(tmp_ins))
        return self.outs
