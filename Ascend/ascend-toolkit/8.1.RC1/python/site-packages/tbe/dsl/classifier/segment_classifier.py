#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in segment
"""
from itertools import chain
from typing import Any
from typing import Dict
from typing import Optional

from functools import reduce as functools_reduce
from tbe.dsl.base import operation
from . import shape_classifier
from . import util
from .util import BLOCK_NUM_MAPPING

UNKNOWN_DIM = -1
UNKNOWN_RANK = -2
FP16_REPEAR = 128
FP32_REPEAT = 64
HIGN_PERFORMANCE = "high_performance"


def _classify_segment_zero_shape(x_dtype, indices_dtype, num_segments_dtype):
    x_dict = {
        "shape": (0, 1),
        "range": ((0, 0), (0, 0)),
        "dtype": x_dtype
    }

    indices_dict = {
        "shape": (0,),
        "range": ((0, 0)),
        "dtype": indices_dtype
    }
    num_segments_dict = {
        "shape": None,
        "range": None,
        "dtype": num_segments_dtype,
        "const_value": 1
    }
    return [x_dict, indices_dict, num_segments_dict]


@shape_classifier.register_classifier(shape_classifier.SEGMENT)
def classify_segment(ins: list, extra_params: Optional[Dict[str, Any]] = None):
    """
    SegmentClassifier
    :param ins:
    :param extra_params:
    :return:
    """
    impl_mode = 0
    is_segment = False
    if extra_params is not None and extra_params.get("impl_mode") == HIGN_PERFORMANCE:
        impl_mode = 1
    if (extra_params is not None) and (extra_params.get("is_segment") is True):
        is_segment = True
    return SegmentClassifier(ins, impl_mode, is_segment).classify()


class SegmentClassifier:
    def __init__(self, ins: list, impl_mode: int,  is_segment: bool, segment_type=shape_classifier.SEGMENT):
        self.is_zeros_shape = False
        self.is_zeros_range = False
        self.is_segment = is_segment
        self.ori_x_shape = list(ins[0].get("shape"))
        self.ori_x_range = list(ins[0].get("range"))
        self.ori_id_shape = list(ins[1].get("shape"))
        self.ori_id_range = list(ins[1].get("range"))
        self.ori_num_segments_shape = list(ins[2].get("shape"))
        self.ori_num_segments_range = list(ins[2].get("range"))

        self.x_dtype = ins[0].get("dtype")
        self.id_dtype = ins[1].get("dtype")
        self.repeat = FP16_REPEAR if self.x_dtype == "float16" else FP32_REPEAT
        self.one_block = BLOCK_NUM_MAPPING.get(self.x_dtype)
        
        self._num_segments_dtype = ins[2].get("dtype")
        self.num_segments_intput = ins[2]
        self.num_segments_int = 0
        if -2 in chain(self.ori_x_shape + self.ori_id_shape + self.ori_num_segments_shape):
            self.is_zeros_range = True
        if "const_value" in self.num_segments_intput:
            axis_value = self.num_segments_intput.get("const_value")
            if isinstance(axis_value, int):
                self.num_segments_int = axis_value
            else:
                self.num_segments_int = axis_value[0]
        self.impl_mode = impl_mode
        self.x_shape = self.ori_x_shape
        self.num_segments_shape = None
        self.num_segments_range = None
        self.x_range = self.ori_x_range
        self.id_shape = self.ori_id_shape
        self.id_range = self.ori_id_range
        self.segment_axis = 1
        self.is_static = operation.get_op_mode() == "static"
        self.segment_type = shape_classifier.SEGMENT
        self.output_shape = [-1, -1]
        self._check_zero_shape()

    def add_compile_info(self):
        operation.get_context().add("_segment_axis", self.segment_axis)
        operation.get_context().add("_segment_mode", self.segment_type)
        operation.get_context().add("_impl_mode", self.impl_mode)
        operation.get_context().add("_num_segment", self.num_segments_int)
        operation.get_context().add("_output_shape", self.output_shape)
        operation.get_context().add("_id_shape", self.id_shape)
        operation.get_context().add("_is_segment", self.is_segment)

    def ori_info_process(self):
        if not self.is_static:
            if self.segment_type == shape_classifier.SEGMENT:
                self.x_shape = [UNKNOWN_DIM, UNKNOWN_DIM]
                self.x_range = [(1, None), (1, None)]
                self.id_shape = [UNKNOWN_DIM]
                self.id_range = [(1, None)],
            if "const_value" not in self.num_segments_intput:
                self.num_segments_shape = [UNKNOWN_DIM]
                self.num_segments_range = [(1, None)]

    def classify(self):
        """
        classify
        :return:
        """
        segment_ins = []
        if self.is_zeros_shape or self.is_zeros_range:
            segment_ins.append(_classify_segment_zero_shape(self.x_dtype, self.id_dtype, self._num_segments_dtype))
        def _get_prod(shape_to_prod):
            return int(functools_reduce(lambda i, j: i * j, shape_to_prod))

        def _update_shape_range(_shape):
            new_range = []
            for i, shape_value in enumerate(_shape):
                dim_range = (shape_value, shape_value)
                if shape_value == UNKNOWN_DIM:
                    dim_range = (1, None)
                new_range.append(dim_range)
            return new_range

        def _segment_instances(segment_ins):
            segment_instances = []
            if "const_value" not in self.num_segments_intput:
                self.num_segments_shape = [UNKNOWN_DIM]
                self.num_segments_range = [(1, None)]
            new_input_x = {
                "shape": self.x_shape,
                "range": self.x_range,
                "dtype": self.x_dtype,
                "ori_shape": self.ori_x_shape
            }
            new_input_id = {
                "shape": self.id_shape,
                "range": self.id_range,
                "dtype": self.id_dtype,
                "ori_shape": self.ori_id_shape
            }
            new_input_num_segments = {
                "shape": self.num_segments_shape,
                "range": self.num_segments_range,
                "dtype": self._num_segments_dtype,
                "ori_shape": self.num_segments_shape,
                "const_value": self.num_segments_int
            }
            segment_instances.append(new_input_x)
            segment_instances.append(new_input_id)
            segment_instances.append(new_input_num_segments)
            segment_ins.append(segment_instances)

        def _unknow_shape(segment_ins):
            self.x_shape = [UNKNOWN_DIM, UNKNOWN_DIM]
            self.id_shape = [UNKNOWN_DIM]
            self.id_range = [(1, None)]
            self.x_range = [(1, None), (1, self.one_block - 1)]
            _segment_instances(segment_ins)
            self.x_range = [(1, None), (self.one_block, self.repeat)]
            _segment_instances(segment_ins)
            self.x_range = [(1, None), (self.repeat + 1, None)]
            _segment_instances(segment_ins)
        len_shape_id = len(self.id_shape)
        len_shape_x = len(self.x_shape)
        if self.is_static:
            if len_shape_x == len_shape_id:
                self.x_shape = [_get_prod(self.x_shape[0:len_shape_x]), 1]
                self.id_shape = [_get_prod(self.id_shape[0:len_shape_id])]
            else:
                self.x_shape = [_get_prod(self.x_shape[0:len_shape_id]), _get_prod(self.x_shape[len_shape_id:])]
                self.id_shape = [_get_prod(self.id_shape[0:len_shape_id])]
            self.x_range = _update_shape_range(self.x_shape)
            self.id_range = _update_shape_range(self.id_shape)
            _segment_instances(segment_ins)
        elif not self.is_static and not self.is_zeros_range:
            if len_shape_x == len_shape_id:
                shape_x0 = UNKNOWN_DIM
                if UNKNOWN_DIM not in self.x_shape:
                    shape_x0 = _get_prod(self.x_shape[0:len_shape_x])
                self.x_shape = [shape_x0, 1]
                self.id_shape = [shape_x0]
                self.x_range = _update_shape_range(self.x_shape)
                self.id_range = _update_shape_range(self.id_shape)
                _segment_instances(segment_ins)
            elif UNKNOWN_DIM not in self.x_shape[len_shape_id:]:
                shape_x0 = UNKNOWN_DIM
                if UNKNOWN_DIM not in self.x_shape[0:len_shape_id]:
                    shape_x0 = _get_prod(self.x_shape[0:len_shape_id])
                self.x_shape = [shape_x0, _get_prod(self.x_shape[len_shape_id:])]
                self.id_shape = [shape_x0]
                self.x_range = _update_shape_range(self.x_shape)
                self.id_range = _update_shape_range(self.id_shape)
                _segment_instances(segment_ins)
            else:
                _unknow_shape(segment_ins)
        else:
            _unknow_shape(segment_ins)
        self.output_shape = [self.num_segments_int, self.x_shape[-1]]

        self.add_compile_info()
        return segment_ins

    def _check_zero_shape(self):
        # shape value zero
        for dim_value in chain(self.ori_x_shape + self.ori_id_shape + self.ori_num_segments_shape):
            if 0 == dim_value:
                self.is_zeros_shape = True
                break

        # range value zero
        if not self.is_zeros_shape:
            for dim_range in chain(self.ori_x_range + self.ori_id_range + self.ori_num_segments_range):
                if 0 == dim_range[0]:
                    self.is_zeros_range = True
                    break
