#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2023-2024 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in conv3d_backprop_input.
"""
import copy
from itertools import product
from tbe.common.utils import const
from .conv2d_bp_input_classifier import Load3dComputeMode


class Load3dComputeModeConv3DDx(Load3dComputeMode):
    """
    compute classify public func of Conv3dBackpropInput.
    """
    def __init__(self, ins: list or tuple, extra_params: dict):
        self.ins = ins
        self.extra_params = extra_params if extra_params else {}
        kernel, out_backprop, y, input_size, strides, pads, dilations, groups, data_format, kernel_name = self.ins
        self.input_size = [input_size]
        self.filter = [kernel]
        self.out_backprop = [out_backprop]
        self.y = [y]
        self.strides = [strides]
        self.pads = [pads]
        self.dilations = [dilations]
        self.groups = [groups]
        self.data_format = [data_format]
        self.kernel_name = [kernel_name]
        self.build_options = []
        self.build_option_space = {
            const.SPLIT_AXIS_MODE_STR: [const.SplitAxisMode.split_hw.value],
            # SD_KD_MODE_KEY denotes stride_d & kernel_d mode,
            # SD_EQ_KD_FLAG: stride_d == kernel_d and (dedx_d + pad_h + pad_t) = dedy_d * stride_d
            # SD_LE_KD_FLAG: stride_d <= kernel_d
            # SD_GT_KD_FLAG: stride_d > kernel_d
            const.SD_KD_MODE_KEY: [const.SD_EQ_KD_FLAG, const.SD_LE_KD_FLAG, const.SD_GT_KD_FLAG],
            const.BINARY_KEY: [self.extra_params.get(const.BINARY_KEY)],
            const.STRIDE_EXPAND_KEY: [True, False],
            const.DILATION_D_GT_ONE_KEY: [True, False]
        }

    def produce_mode(self):
        if self.extra_params.get(const.BINARY_KEY):
            return list(
                filter(
                    self._check_input_args_valid,
                    product(self.filter, self.out_backprop, self.y, self.input_size, self.strides, self.pads,
                            self.dilations, self.groups, self.data_format, self.kernel_name, self.build_options)))
        else:
            return [self.ins]

    def update_build_option_space(self):
        self.update_split_axis_mode()
        self.update_sd_kd_mode()
        self.update_dilation_d_mode()

    def update_sd_kd_mode(self):
        if self.extra_params.get(const.SD_KD_MODE_KEY) is not None:
            self.build_option_space.update({const.SD_KD_MODE_KEY: [self.extra_params.get(const.SD_KD_MODE_KEY)]})

    def update_dilation_d_mode(self):
        if self.extra_params.get(const.DILATION_D_GT_ONE_KEY) is not None:
            self.build_option_space.update({const.DILATION_D_GT_ONE_KEY:
                                           [self.extra_params.get(const.DILATION_D_GT_ONE_KEY)]})

    def _check_input_args_valid(self, input_args):
        _, _, _, _, strides, _, _, _, _, _, build_option = input_args
        if all(sd == 1 for sd in strides) and (build_option.get(const.SD_KD_MODE_KEY) == const.SD_GT_KD_FLAG
                                               or build_option.get(const.STRIDE_EXPAND_KEY)):
            return False
        if not all(sd == 1 for sd in strides) and not build_option.get(const.STRIDE_EXPAND_KEY):
            return False

        return True


class Load3dComputeModeConv3DTranspose(Load3dComputeMode):
    """
    compute classify public func of Conv3dTranspose.
    """
    def __init__(self, ins: list or tuple, extra_params: dict):
        self.ins = ins
        self.extra_params = extra_params if extra_params else {}
        (kernel, out_backprop, y, input_size, strides, pads, dilations, groups, output_padding, data_format,
         kernel_name) = self.ins
        self.input_size = [input_size]
        self.filter = [kernel]
        self.out_backprop = [out_backprop]
        self.y = [y]
        self.strides = [strides]
        self.pads = [pads]
        self.dilations = [dilations]
        self.groups = [groups]
        self.output_padding = [output_padding]
        self.data_format = [data_format]
        self.kernel_name = [kernel_name]
        self.build_options = []
        self.build_option_space = {
            const.SPLIT_AXIS_MODE_STR: [const.SplitAxisMode.split_hw.value],
            const.SD_KD_MODE_KEY: [const.SD_EQ_KD_FLAG, const.SD_LE_KD_FLAG, const.SD_GT_KD_FLAG],
            const.BINARY_KEY: [self.extra_params.get(const.BINARY_KEY)],
            const.STRIDE_EXPAND_KEY: [True, False],
            const.DILATION_D_GT_ONE_KEY: [True, False]
        }

    def produce_mode(self):
        if self.extra_params.get(const.BINARY_KEY):
            return list(
                filter(
                    self._check_input_args_valid,
                    product(self.filter, self.out_backprop, self.y, self.input_size, self.strides, self.pads,
                            self.dilations, self.groups, self.output_padding, self.data_format, self.kernel_name,
                            self.build_options)))
        else:
            return [self.ins]

    def update_build_option_space(self):
        self.update_split_axis_mode()
        self.update_sd_kd_mode()
        self.update_dilation_d_mode()

    def update_sd_kd_mode(self):
        if self.extra_params.get(const.SD_KD_MODE_KEY) is not None:
            self.build_option_space.update({const.SD_KD_MODE_KEY: [self.extra_params.get(const.SD_KD_MODE_KEY)]})

    def update_dilation_d_mode(self):
        if self.extra_params.get(const.DILATION_D_GT_ONE_KEY) is not None:
            self.build_option_space.update({const.DILATION_D_GT_ONE_KEY:
                                           [self.extra_params.get(const.DILATION_D_GT_ONE_KEY)]})

    def _check_input_args_valid(self, input_args):
        _, _, _, _, strides, _, _, _, _, _, _, build_option = input_args
        if all(sd == 1 for sd in strides) and (build_option.get(const.SD_KD_MODE_KEY) == const.SD_GT_KD_FLAG
                                               or build_option.get(const.STRIDE_EXPAND_KEY)):
            return False
        if not all(sd == 1 for sd in strides) and not build_option.get(const.STRIDE_EXPAND_KEY):
            return False

        return True


def get_compute_mode(mode):
    compute_mode = {}
    if mode == "conv3d_backprop_input":
        compute_mode["load3d"] = Load3dComputeModeConv3DDx
    elif mode == "conv3d_transpose":
        compute_mode["load3d"] = Load3dComputeModeConv3DTranspose

    return compute_mode


def classify(ins: list or tuple, extra_params: dict, mode: str = "conv3d_backprop_input"):
    """
    Get binary template parameters.

    Parameters
    ----------
    ins (list or tuple):
    extra_params (dict):
    mode (str): this param is used to correctly obtain ths initalization class corresponding to the operator.

    Returns
    ----------
    outs: a list of binary template parameters
    """
    outs = []
    compute_mode = get_compute_mode(mode)
    for _, func in compute_mode.items():
        temp_ins = copy.deepcopy(ins)
        outs += func(temp_ins, extra_params).update_mode()

    return outs