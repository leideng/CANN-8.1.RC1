#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in conv2d_backprop_input
"""
from typing import Any
from typing import Dict
from typing import Optional
import copy
from itertools import product

from tbe.common.utils.const import SplitAxisMode
from tbe.common.utils.const import SPLIT_AXIS_MODE_STR


DYNAMIC_FMAP_W_MAX = 4096


class Load3dComputeMode(object):
    """
    compute classify public func
    """
    def __init__(self, ins: list or tuple, extra_params: dict):
        self.input_list, self.attr_list = ins
        self.extra_params = extra_params if extra_params else {}
        input_size, weight, out_backprop, y = self.input_list
        strides, pads, dilations, groups, data_format = self.attr_list
        self.input_size = [input_size, ]
        self.filter = [weight, ]
        self.out_backprop = [out_backprop, ]
        self.y = [y, ]
        self.strides = [strides, ]
        self.pads = [pads, ]
        self.dilations = [dilations, ]
        self.groups = [groups, ]
        self.data_format = [data_format, ]
        self.kernel_name = ["conv2d_backprop_input", ]
        self.build_options = []
        self.build_option_space = {
            SPLIT_AXIS_MODE_STR: [SplitAxisMode.split_hw.value]
        }

    @staticmethod
    def _get_none_range_flag(dynamic_range):
        """
        Determine whether it is a None range scene
        """
        if not dynamic_range:
            return True
        for idx_range in dynamic_range:
            if not idx_range or idx_range[0] is None or idx_range[1] is None:
                return True
            if idx_range[1] > DYNAMIC_FMAP_W_MAX:
                return True
        return False

    def updata_attr_strides(self):
        need_expand_stride = self.extra_params.get("need_expand_stride")
        if need_expand_stride is None:
            if self._check_strides_negative():
                self.strides.append((1, ) * len(self.strides[0]))
        elif need_expand_stride:
            self.strides = [(-1, ) * len(self.strides[0])]
        else:
            self.strides = [(1, ) * len(self.strides[0])]

    def update_split_axis_mode(self):
        need_split_w = self.extra_params.get("split_w")
        if need_split_w is None and self.extra_params is not None and \
           self.extra_params.get("single_op") and self._get_binary_flag():
            # split_w only support binary singleop
            self.build_option_space[SPLIT_AXIS_MODE_STR] = [
                SplitAxisMode.split_hw.value,
                SplitAxisMode.split_w.value
            ]
        elif need_split_w:
            self.build_option_space[SPLIT_AXIS_MODE_STR] = [SplitAxisMode.split_w.value]

    def update_build_option_space(self):
        """
        Subclass can overwrite this method to extend build option space.
        """
        self.update_split_axis_mode()

    def update_attrs(self):
        self.updata_attr_strides()
        self.update_build_option_space()
        self.build_options = [
            dict(zip(self.build_option_space.keys(), comb)) for comb in product(*self.build_option_space.values())
        ]

    def produce_mode(self):
        return list(
            product(self.input_size, self.filter, self.out_backprop, self.y, self.strides, self.pads, self.dilations,
                    self.groups, self.data_format, self.kernel_name, self.build_options))

    def update_mode(self):
        self.update_attrs()
        return self.produce_mode()

    def _check_strides_negative(self):
        strides = self.strides[0]
        return all(x < 0 for x in strides)

    def _get_binary_flag(self):
        in_out_dtype_check = self.y[0].get("dtype") != self.filter[0].get("dtype")
        out_dtype_check = self.y[0].get("dtype") not in ["bfloat16", "float16", "float32"]
        if in_out_dtype_check or out_dtype_check:
            return False
        shape_flag = all(x < 0 for x in self.filter[0].get("ori_shape"))
        none_range_flag = self._get_none_range_flag(self.y[0].get("range"))
        return none_range_flag or shape_flag


class Load3dComputeModeConv2dTranspose(Load3dComputeMode):
    """
    compute classify public func of Conv2DTranspose
    """
    def __init__(self, ins: list or tuple, extra_params: dict):
        self.input_list, self.attr_list = ins
        self.extra_params = extra_params if extra_params else {}
        input_size, out_backprop, weight, bias, offset_w, y = self.input_list
        strides, pads, dilations, groups, data_format, \
            out_padding, offset_x, kernel_name = self.attr_list
        self.input_size = [input_size, ]
        self.out_backprop = [out_backprop, ]
        self.filter = [weight, ]
        self.bias = [bias, ]
        self.offset_w = [offset_w, ]
        self.y = [y, ]
        self.strides = [strides, ]
        self.pads = [pads, ]
        self.dilations = [dilations, ]
        self.groups = [groups, ]
        self.data_format = [data_format, ]
        self.out_padding = [out_padding, ]
        self.offset_x = [offset_x, ]
        self.kernel_name = [kernel_name, ]
        self.build_options = []
        self.build_option_space = {
            SPLIT_AXIS_MODE_STR: [SplitAxisMode.split_hw.value]
        }

    def produce_mode(self):
        return list(
            product(self.input_size, self.out_backprop, self.filter, self.bias, self.offset_w, self.y, self.strides,
                    self.pads, self.dilations, self.groups, self.data_format, self.out_padding, self.offset_x,
                    self.kernel_name, self.build_options))


class Load3dComputeModeDepthwise(Load3dComputeMode):
    """
    compute classify public func of Conv2DTranspose
    """
    def __init__(self, ins: list or tuple, extra_params: dict):
        self.input_list, self.attr_list = ins
        self.extra_params = extra_params if extra_params else {}
        input_size, weight, out_backprop, input_grad = self.input_list
        strides, pads, dilations, data_format, kernel_name = self.attr_list
        self.input_size = [input_size, ]
        self.out_backprop = [out_backprop, ]
        self.filter = [weight, ]
        self.y = [input_grad, ]
        self.strides = [strides, ]
        self.pads = [pads, ]
        self.dilations = [dilations, ]
        self.data_format = [data_format, ]
        self.kernel_name = [kernel_name, ]
        self.build_options = []
        self.build_option_space = {
            SPLIT_AXIS_MODE_STR: [SplitAxisMode.split_hw.value]
        }

    def updata_attr_strides(self):
        pass

    def produce_mode(self):
        return list(
            product(self.input_size, self.filter, self.out_backprop, self.y, self.strides, self.pads,
                    self.dilations, self.data_format, self.kernel_name, self.build_options))


def get_comput_mode(mode):
    compute_mode = {
        "load3d": Load3dComputeMode,
    }
    if mode == "conv2d_transpose":
        compute_mode["load3d"] = Load3dComputeModeConv2dTranspose
    if mode == "depthwise_conv2d_backprop_input":
        compute_mode["load3d"] = Load3dComputeModeDepthwise
    return compute_mode


def classify(ins: list or tuple, extra_params: dict, mode: str = "conv2d_backprop_input"):
    """
    Get binary template parameters.

    Parameters
    ----------
    ins (list or tuple):
    extra_params (dict):
    mode (str): this param is used to correctly obtain ths initalization class corresponding to the operator.

    Returns
    ----------
    outs: a list of binary template parameters
    """
    outs = []
    compute_mode = get_comput_mode(mode)
    for _, func in compute_mode.items():
        temp_ins = copy.deepcopy(ins)
        outs += func(temp_ins, extra_params).update_mode()

    return outs
