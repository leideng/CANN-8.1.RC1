#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2021-2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
TransdataRule
"""
from tbe.common.platform.platform_info import get_soc_spec
from .constants import TC
from .constants import RESERVED_SPACE
from .constants import STRIDE_16
from .util import set_align

BNF = TC.BORROW_N_B8B16_FORWARD
BNB = TC.BORROW_N_B8B16_BACKWARD
BHF = TC.BORROW_H_B8B16_FORWARD
BHB = TC.BORROW_H_B8B16_BACKWARD


class TransdataUserRule():
    """
    Regulation: which axes could be borrowed
    """

    def __init__(self, inputs, formats, shapes, attrs):
        self.inputs = inputs
        self.src_format = formats[0]
        self.dst_format = formats[1]

        self.src_shape = shapes[0]
        self.perm = shapes[1]
        self.src_pad_var = shapes[2]
        self.index_c = shapes[3]

        self.is_const = attrs[0]
        self.ori_bit = attrs[1]
        self.bit = attrs[2]
        self.soc_ub_size = get_soc_spec("UB_SIZE")
        self.block = int(get_soc_spec("ubblock_size"))
        self.factor = self.block // self.bit
        if self.factor < STRIDE_16:
            self.factor = STRIDE_16

    def ruling(self):
        mapping = {("ND", "FRACTAL_NZ"): self._nd2nz,
                   ("FRACTAL_NZ", "ND"): self._nz2nd,
                   ("NC1HWC0", "NHWC"): self._nc1hwc02nhwc,
                   ("NHWC", "NC1HWC0"): self._nhwc2nc1hwc0,
                   ("NC1HWC0", "NCHW"): self._nc1hwc02nchw,
                   ("NCHW", "NC1HWC0"): self._nchw2nc1hwc0}
        func = mapping.get((self.src_format, self.dst_format), None)
        return {} if not func else func()

    def _nlast_dyn_branch(self, inputs, is_forward=True):
        out = {}
        for key in inputs:
            if key == 0 and self.perm[0] == 0:
                value = BNF if is_forward else BNB
            else:
                value = BHF if is_forward else BHB
            out.update({key: value})
        return out

    def _nlast_const_branch(self, inputs):
        if not self.is_const:
            return inputs

        shape = [set_align(k, v) for k, v in zip(self.src_shape, self.src_pad_var)]
        ub_size = (self.soc_ub_size - RESERVED_SPACE) // self.ori_bit // 2
        out, base = {}, shape[-1]
        for k, branch in inputs.items():
            cond_0 = branch in [BNF, BNB, BHF] and ub_size > self.factor * base
            cond_1 = branch in [BHB, ] and ub_size > self.factor * self.factor * base
            if cond_0 or cond_1:
                out.update({k: branch})
        return out

    def _nd2nz(self):
        out = self._nlast_dyn_branch(self.inputs, is_forward=True)
        return self._nlast_const_branch(out)

    def _nz2nd(self):
        out = self._nlast_dyn_branch(self.inputs, is_forward=False)
        return self._nlast_const_branch(out)

    def _nc1hwc02nhwc(self):
        return self._nz2nd()

    def _nhwc2nc1hwc0(self):
        return self._nd2nz()

    def _nchw2nc1hwc0(self, branch=BHF):
        for i in self.inputs:
            cond_0 = i == 0 and self.perm[0] == 0
            cond_1 = self.index_c != 0
            cond_2 = (self.src_shape[0] == -1 or self.src_shape[0] >= 4)
            if cond_0 and cond_1 and cond_2:
                return {0: branch}
        return {}

    def _nc1hwc02nchw(self):
        return self._nchw2nc1hwc0(branch=BHB)
