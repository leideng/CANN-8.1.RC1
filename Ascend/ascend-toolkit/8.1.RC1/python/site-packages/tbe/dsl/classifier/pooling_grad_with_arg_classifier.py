#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in pooling grad with arg
"""
from typing import Any
from typing import Dict
from typing import Optional
from tbe.dsl.base import operation
from tbe.dsl.base.operation import add_compile_info_inner
from tbe.common.utils.errormgr import get_error_message
from . import shape_classifier

UNKNOWN_RANK = -2
DIM_0 = 0
DIM_1 = 1
DIM_2 = 2
DIM_3 = 3
DIM_4 = 4
DIM_5 = 5
INPUT_X_INDEX = 0
INPUT_GRAD_INDEX = 1
INPUT_ARGMAX_INDEX = 2


def get_format(format_info):
    format_dict = {"NC1HWC0": 0, "NCHW": 1, "NHWC": 2}
    return format_dict.get(format_info)


class PoolingGradWithArgClassifier:
    def __init__(self, ins: list, extra_params: list):
        self.ins = ins
        self.ksize = extra_params.get("ksize")
        self.strides = extra_params.get("strides")
        self.pads = extra_params.get("pads")
        self.is_2d = extra_params.get("is_2d")
        self.ceil_mode = extra_params.get("ceil_mode")
        self.padding_mode = extra_params.get("padding_mode")
        self.input_format = extra_params.get("input_format")
        self.dilations = None
        self.pad_d_top = 0
        self.pad_d_bottom = 0
        self.pad_hw_top = 0
        self.pad_hw_bottom = 0
        self.pad_hw_left = 0
        self.pad_hw_right = 0
        self.di = 0
        self.hi = 0
        self.wi = 0
        self.do = 0
        self.ho = 0
        self.wo = 0
        self.k_d = 0
        self.k_h = 0
        self.k_w = 0
        self.s_d = 0
        self.s_h = 0
        self.s_w = 0

    def _calc_exact_output_len(self, input_len, pad_top_value, k_value, s_value):
        exact_input_len = input_len + 2 * pad_top_value - \
            (k_value - 1) - 1 + ((s_value - 1) if self.ceil_mode else 0)
        exact_out = (exact_input_len // s_value) + 1
        if (exact_out - 1) * s_value >= input_len + pad_top_value:
            exact_out = exact_out - 1
        return exact_out

    def _calc_pads(self):
        if self.is_2d:
            self.pad_d_top = 0
            self.pad_d_bottom = 0
            self.pad_hw_top = self.pads[DIM_2]
            self.pad_hw_bottom = 0
            self.pad_hw_left = self.pads[DIM_3]
            self.pad_hw_right = 0
            self.di, self.hi, self.wi = 1, self.ins[INPUT_X_INDEX].get(
                "shape")[DIM_2], self.ins[INPUT_X_INDEX].get("shape")[DIM_3]
            self.do, self.ho, self.wo = 1, self.ins[INPUT_GRAD_INDEX].get(
                "shape")[DIM_2], self.ins[INPUT_GRAD_INDEX].get("shape")[DIM_3]
            self.k_d, self.k_h, self.k_w = 1, self.ksize[DIM_2], self.ksize[DIM_3]
            self.s_d, self.s_h, self.s_w = 1, self.strides[DIM_2], self.strides[DIM_3]
        else:
            # if 3d: ksize should be [1, k_d, k_h, k_w], strides should be [1, s_d, s_h, s_w]
            # pad should be [1, pad_d_top, pad_hw_top, pad_hw_left]
            self.pad_d_top = self.pads[DIM_1]
            self.pad_d_bottom = 0
            self.pad_hw_top = self.pads[DIM_2]
            self.pad_hw_bottom = 0
            self.pad_hw_left = self.pads[DIM_3]
            self.pad_hw_right = 0

            self.di, self.hi, self.wi = self.ins[INPUT_X_INDEX].get("shape")[DIM_1], \
                                        self.ins[INPUT_X_INDEX]. get("shape")[DIM_3], \
                                        self.ins[INPUT_X_INDEX].get("shape")[DIM_4]
            self.do, self.ho, self.wo = self.ins[INPUT_GRAD_INDEX].get("shape")[DIM_1], \
                                        self.ins[INPUT_GRAD_INDEX].get("shape")[DIM_3], \
                                        self.ins[INPUT_GRAD_INDEX].get("shape")[DIM_4]
            self.k_d, self.k_h, self.k_w = self.ksize[DIM_1], self.ksize[DIM_2], self.ksize[DIM_3]
            self.s_d, self.s_h, self.s_w = self.strides[DIM_1], self.strides[DIM_2], self.strides[DIM_3]

        exact_do = self._calc_exact_output_len(self.di, self.pad_d_top, self.k_d, self.s_d)
        exact_ho = self._calc_exact_output_len(self.hi, self.pad_hw_top, self.k_h, self.s_h)
        exact_wo = self._calc_exact_output_len(self.wi, self.pad_hw_left, self.k_w, self.s_w)

        if exact_do != self.do or exact_ho != self.ho or exact_wo != self.wo:
            dict_args = {"errCode": "E90001",
                         "detailed_cause": "the grad size is wrong!"}
            raise RuntimeError(dict_args, get_error_message(dict_args))

        pad_d = (self.do - 1) * self.s_d + self.k_d
        pad_h = (self.ho - 1) * self.s_h + self.k_h
        pad_w = (self.wo - 1) * self.s_w + self.k_w

        self.pad_d_bottom = pad_d - self.di - \
            self.pad_d_top if pad_d - self.di - self.pad_d_top > 0 else 0
        self.pad_hw_bottom = pad_h - self.hi - \
            self.pad_hw_top if pad_h - self.hi - self.pad_hw_top > 0 else 0
        self.pad_hw_right = pad_w - self.wi - self.pad_hw_left if pad_w - \
            self.wi - self.pad_hw_left > 0 else 0
        
    def _calc_pads_tf(self):
        if not self.is_2d:
            dict_args = {"errCode": "E90001",
                         "detailed_cause": "The format must be NC1HWC0...."}
            raise RuntimeError(dict_args, get_error_message(dict_args))
        # Since tensor input_x and input_grad here have format NC1HWC0, we use index 2 for H and 3 for W. 
        self.di, self.hi, self.wi = 1, self.ins[INPUT_X_INDEX].get(
            "shape")[DIM_2], self.ins[INPUT_X_INDEX].get("shape")[DIM_3]
        self.do, self.ho, self.wo = 1, self.ins[INPUT_GRAD_INDEX].get(
            "shape")[DIM_2], self.ins[INPUT_GRAD_INDEX].get("shape")[DIM_3]
        
        # Since ksize and stride here have format NCHW, we use index 2 for H and 3 for W. 
        self.k_d, self.k_h, self.k_w = 1, self.ksize[DIM_2], self.ksize[DIM_3]
        self.s_d, self.s_h, self.s_w = 1, self.strides[DIM_2], self.strides[DIM_3]

        self.pad_d_top = 0
        self.pad_d_bottom = 0
        self.pad_hw_top = 0
        self.pad_hw_bottom = 0
        self.pad_hw_left = 0
        self.pad_hw_right = 0

        if self.padding_mode == "SAME":
            padh = max(0, (self.ho - 1) * self.s_h + self.k_h - self.hi)
            padw = max(0, (self.wo - 1) * self.s_w + self.k_w - self.wi)
            self.pad_hw_top = padh // 2
            self.pad_hw_bottom = padh - self.pad_hw_top
            self.pad_hw_left = padw // 2
            self.pad_hw_right = padw - self.pad_hw_left

    def _unify_static_shape(self):
        if self.ceil_mode is not None:
            self._calc_pads()
        if self.padding_mode is not None:
            self._calc_pads_tf()
        for ins in self.ins:
            if self.is_2d:
                new_shape = (ins["shape"][DIM_0], 1, ins["shape"][DIM_1],
                             ins["shape"][DIM_2], ins["shape"][DIM_3], ins["shape"][DIM_4])
                ins["shape"] = new_shape
                ins["range"] = ((1, None), (1, 1), (1, None),
                                (1, None), (1, None), (16, 16))

    def _unknown_rank(self):
        for ins in self.ins:
            if UNKNOWN_RANK in ins.get("shape"):
                return True
        if self.ksize is None or self.strides is None or self.pads is None:
            return True
        return False

    def _unify_unknown_rank_2d(self):
        for ins in self.ins:
            ins["shape"] = (-1, 1, -1, -1, -1, 16)
            ins["range"] = ((1, None), (1, 1), (1, None),
                            (1, None), (1, None), (16, 16))

        self.k_d, self.k_h, self.k_w = 1, -1, -1
        self.s_d, self.s_h, self.s_w = 1, -1, -1
        self.pad_d_top, self.pad_d_bottom = 0, 0
        self.pad_hw_top, self.pad_hw_bottom = -1, -1
        self.pad_hw_left, self.pad_hw_right = -1, -1

    def _unify_unknown_rank_3d(self):
        for ins in self.ins:
            ins["shape"] = (-1, -1, -1, -1, -1, 16)
            ins["range"] = ((1, None), (1, None), (1, None),
                            (1, None), (1, None), (16, 16))

        self.k_d, self.k_h, self.k_w = -1, -1, -1
        self.s_d, self.s_h, self.s_w = -1, -1, -1
        self.pad_d_top, self.pad_d_bottom = -1, -1
        self.pad_hw_top, self.pad_hw_bottom = -1, -1
        self.pad_hw_left, self.pad_hw_right = -1, -1

    def _unify_dynamic_shape_2d(self):
        for ins in self.ins:
            ins["shape"] = (-1, 1, -1, -1, -1, 16)
            ins["range"] = ((1, None), (1, 1), (1, None),
                            (1, None), (1, None), (16, 16))

        self.k_d, self.k_h, self.k_w = 1, self.ksize[DIM_2], self.ksize[DIM_3]
        self.s_d, self.s_h, self.s_w = 1, self.strides[DIM_2], self.strides[DIM_3]
        self.pad_d_top, self.pad_d_bottom = 0, 0
        self.pad_hw_top, self.pad_hw_bottom = -1, -1
        self.pad_hw_left, self.pad_hw_right = -1, -1

    def _unify_dynamic_shape_3d(self):
        for ins in self.ins:
            ins["shape"] = (-1, -1, -1, -1, -1, 16)
            ins["range"] = ((1, None), (1, None), (1, None),
                            (1, None), (1, None), (16, 16))

        self.k_d, self.k_h, self.k_w = self.ksize[DIM_1], self.ksize[DIM_2], self.ksize[DIM_3]
        self.s_d, self.s_h, self.s_w = self.strides[DIM_1], self.strides[DIM_2], self.strides[DIM_3]
        self.pad_d_top, self.pad_d_bottom = -1, -1
        self.pad_hw_top, self.pad_hw_bottom = -1, -1
        self.pad_hw_left, self.pad_hw_right = -1, -1

    def _add_to_compile_info(self):
        def _gen_window_info(_ori_window_info):
            return [-1, ] if not _ori_window_info else _ori_window_info[:]

        window_info = []
        window_info.append(_gen_window_info(self.ksize))
        window_info.append(_gen_window_info(self.strides))
        window_info.append(_gen_window_info(self.dilations))
        window_info.append(_gen_window_info(self.pads))
        window_info.append([0 if self.ceil_mode == 0 else 1])
        if self.padding_mode:
            window_info.append([0 if self.padding_mode == "VALID" else 1])
        else:
            window_info.append([-1])
        window_info.append([get_format(self.input_format)])
        add_compile_info_inner("_ori_window_info", window_info)

    def classify(self):
        self._add_to_compile_info()
        if operation.get_context().get_mode() == "static":
            self._unify_static_shape()
        else:
            if self._unknown_rank():
                add_compile_info_inner("_unknown_rank", True)
                self._unify_unknown_rank_2d() if self.is_2d else self._unify_unknown_rank_3d()
            else:
                self._unify_dynamic_shape_2d() if self.is_2d else self._unify_dynamic_shape_3d()
        inputs = []
        for ins in self.ins:
            inputs.append(ins)
        inputs.append({"ksize": [self.k_d, self.k_h, self.k_w]})
        inputs.append({"strides": [self.s_d, self.s_h, self.s_w]})
        inputs.append({"pads": [self.pad_d_top, self.pad_d_bottom, self.pad_hw_top,
                      self.pad_hw_bottom, self.pad_hw_left, self.pad_hw_right]})
        inputs.append({"format": self.input_format})
        return [inputs]
    
    def _unify_static_shape_4d(self):
        if self.ceil_mode is not None:
            self.pad_hw_top = self.pads[DIM_2]
            self.pad_hw_bottom = 0
            self.pad_hw_left = self.pads[DIM_3]
            self.pad_hw_right = 0
            if self.input_format == "NCHW":
                self.hi = self.ins[INPUT_X_INDEX].get("shape")[2]
                self.wi = self.ins[INPUT_X_INDEX].get("shape")[3]
                self.ho = self.ins[INPUT_GRAD_INDEX].get("shape")[2]
                self.wo = self.ins[INPUT_GRAD_INDEX].get("shape")[3]
            else:
                self.hi = self.ins[INPUT_X_INDEX].get("shape")[1]
                self.wi = self.ins[INPUT_X_INDEX].get("shape")[2]
                self.ho = self.ins[INPUT_GRAD_INDEX].get("shape")[1]
                self.wo = self.ins[INPUT_GRAD_INDEX].get("shape")[2]
            self.k_h, self.k_w = self.ksize[DIM_2], self.ksize[DIM_3]
            self.s_h, self.s_w = self.strides[DIM_2], self.strides[DIM_3]

            exact_ho = self._calc_exact_output_len(
                self.hi, self.pad_hw_top, self.k_h, self.s_h)
            exact_wo = self._calc_exact_output_len(
                self.wi, self.pad_hw_left, self.k_w, self.s_w)

            if exact_ho != self.ho or exact_wo != self.wo:
                dict_args = {"errCode": "E90001",
                             "detailed_cause": "the grad size is wrong!"}
                raise RuntimeError(dict_args, get_error_message(dict_args))

            pad_h = (self.ho - 1) * self.s_h + self.k_h
            pad_w = (self.wo - 1) * self.s_w + self.k_w
            self.pad_hw_bottom = pad_h - self.hi - \
                self.pad_hw_top if pad_h - self.hi - self.pad_hw_top > 0 else 0
            self.pad_hw_right = pad_w - self.wi - self.pad_hw_left if pad_w - \
                self.wi - self.pad_hw_left > 0 else 0

    def _unify_dynamic_shape(self):
        for ins in self.ins:
            ins["shape"] = (-1, -1, -1, -1)
            ins["range"] = ((1, None), (1, None), (1, None), (1, None))
        self.k_h, self.k_w = self.ksize[DIM_2], self.ksize[DIM_3]
        self.s_h, self.s_w = self.strides[DIM_2], self.strides[DIM_3]
        self.pad_hw_top, self.pad_hw_bottom = -1, -1
        self.pad_hw_left, self.pad_hw_right = -1, -1

    def _unify_unknown_rank(self):
        for ins in self.ins:
            ins["shape"] = (-1, -1, -1, -1)
            ins["range"] = ((1, None), (1, None), (1, None), (1, None))
        self.k_h, self.k_w = -1, -1
        self.s_h, self.s_w = -1, -1
        self.pad_hw_top, self.pad_hw_bottom = -1, -1
        self.pad_hw_left, self.pad_hw_right = -1, -1

    def classify_4d(self):
        self._add_to_compile_info()
        if operation.get_context().get_mode() == "static":
            self._unify_static_shape_4d()
        else:
            if self._unknown_rank():
                add_compile_info_inner("_unknown_rank", True)
                self._unify_unknown_rank()
            else:
                self._unify_dynamic_shape()
        inputs = []
        for ins in self.ins:
            inputs.append(ins)
        inputs.append({"ksize": [self.k_h, self.k_w]})
        inputs.append({"strides": [self.s_h, self.s_w]})
        inputs.append(
            {"pads": [self.pad_hw_top, self.pad_hw_bottom, self.pad_hw_left, self.pad_hw_right]})
        inputs.append({"format": self.input_format})
        return [inputs]


@shape_classifier.register_classifier(shape_classifier.POOLING_GRAD_WITH_ARG)
def classify_pooling_grad_with_arg(ins: list, extra_params: Optional[Dict[str, Any]] = None):
    if extra_params.get("input_format") == "NC1HWC0":
        return PoolingGradWithArgClassifier(ins, extra_params).classify()
    else:
        return PoolingGradWithArgClassifier(ins, extra_params).classify_4d()
