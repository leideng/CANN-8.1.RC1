#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in split
"""
from functools import reduce
from operator import mul
from typing import List, Optional

from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.base import operation

from . import shape_classifier
from . import util

INPUT_NUMBER_LIMIT = 63
UNKNOWN_RANK = -2
BLOCK_SIZE_BYTE = 32
AXIS_INDEX = 1
SPLIT_SIZE_INDEX = 2
SPLIT = "split"
SPLIT_EMPTY = "split_empty"
INT32_LIMIT = 2147483647
INT64_LIMIT = 9223372036854775807


@shape_classifier.register_classifier(shape_classifier.SPLIT)
def classify(ins: list, extra_params: dict):
    """
    classify
    :param ins: inputs, [split_dim], [split_size]
    :param extra_params: include split_num and avg_split
    :return: inputs, axis, split_size
    """
    if extra_params is None or "num_split" not in extra_params:
        dict_args = {
            "errCode": "E90001",
            "detailed_cause": "inputs of classify must include the dict extra_params with the key num_split when "
                              "mode is split"
        }
        raise RuntimeError(dict_args, get_error_message(dict_args))
    avg_split = False
    if "avg_split" in extra_params:
        avg_split = extra_params.get("avg_split")
    num_split = extra_params.get("num_split")
    classifier = SplitClassifier(ins, num_split, avg_split)
    operation.get_context().add("_avg_split", avg_split or num_split == 1)
    return classifier.classify()


class SplitClassifier:
    """
    Split classifier
    """

    def __init__(self, ins: List, num_split: int, avg_split: bool):
        self._ins: List = ins
        self._ori_axis: Optional[int] = None
        self._axis: Optional[int] = None
        self._num_split: int = num_split
        self._maybe_empty: bool = False
        self._only_empty: bool = False
        self._is_unknow_rank: bool = False
        self._split_size: List = [-1] * num_split
        self._shapes: List = []
        self._ranges: List = []
        self._merged_shapes: List = []
        self._merged_ranges: List = []
        self._avg_split: bool = avg_split
        self._is_const: bool = False

    @staticmethod
    def shape_is_const(_shape, start, end):
        return -1 not in _shape[start:end]

    @staticmethod
    def merge_shape(_shape):
        return reduce(mul, _shape, 1)

    def classify(self):
        self._check_params()
        self._get_input_info()
        self._process_single_output()
        self._process_unknown_axis()
        operation.add_compile_info_inner("_ori_axis", self._axis)
        if self._axis < 0:
            self._axis = self._axis + len(self._shapes)
        self._process_unknown_rank()
        self._merge_shape_range()
        self._update_shape_range()
        self._get_split_size_info()
        self._process_empty_shape()
        self._process_const_split_size()
        res = self._generate_ins()
        return res

    def _is_single_output(self):
        return self._num_split == 1

    def _check_params(self):
        if len(self._ins) <= 1:
            dict_args = {"errCode": "E90001", "detailed_cause": "input numbers error"}
            raise RuntimeError(dict_args, get_error_message(dict_args))

    def _get_axis(self, split_dim):
        if isinstance(split_dim, int):
            return split_dim
        if isinstance(split_dim, dict):
            axis_value = split_dim.get("const_value")
            if isinstance(axis_value, int):
                return axis_value
            if isinstance(axis_value, (tuple, list)):
                return axis_value[0]
            if len(self._shapes) == 1:
                return 0
        return self._axis

    def _modify_split_size(self, split_size):
        split_axis = self._axis
        if split_axis < 0:
            split_axis = split_axis + len(self._shapes)
        if split_axis < 0 or split_axis >= len(self._shapes) or min(self._merged_shapes) < 0:
            return self._split_size
        curr_sum = sum(split_size) + 1
        if split_size.count(-1) == 1 and curr_sum <= self._shapes[split_axis]:
            split_size[split_size.index(-1)] = self._shapes[split_axis] - curr_sum
            return split_size
        return self._split_size

    def _get_split_size(self, split_size):
        if isinstance(split_size, (tuple, list)) and min(split_size) >= -1 and len(split_size) == self._num_split:
            if min(split_size) >= 0:
                return list(split_size)
            return self._modify_split_size(list(split_size))
        if isinstance(split_size, dict):
            split_size_value = split_size.get("const_value") if self._is_const is True else None
            if isinstance(split_size_value, (tuple, list)) and \
               min(split_size_value) >= -1 and len(split_size_value) == self._num_split:
                if min(split_size_value) >= 0:
                    return list(split_size_value)
                return self._modify_split_size(list(split_size_value))
        return self._split_size

    def _get_input_info(self):
        input_x = self._ins[0]
        self._shapes = input_x.get("shape") or (1,)
        if UNKNOWN_RANK in self._shapes:
            self._ranges = input_x.get("range", [(0, None)])
        else:
            self._ranges = input_x.get("range") or ((1, 1),)
        if len(self._ins) > AXIS_INDEX:
            self._ori_axis = self._get_axis(self._ins[AXIS_INDEX])
            self._axis = self._ori_axis

    def _get_split_size_info(self):
        if len(self._ins) > SPLIT_SIZE_INDEX:
            self._is_const = (operation.get_op_mode() == "static"
                              or self.shape_is_const(self._merged_shapes, 0, len(self._merged_shapes)))
            self._split_size = self._get_split_size(self._ins[SPLIT_SIZE_INDEX])

    def _process_unknown_rank(self):
        if UNKNOWN_RANK in self._shapes:
            if len(self._shapes) != 1:
                dict_args = {"errCode": "E90001",
                             "detailed_cause": "if the shape contains -2, it must be [-2] or (-2,)"}
                raise RuntimeError(dict_args, get_error_message(dict_args))
            self._shapes = [-1, -1]
            self._ranges = [(1, None), (1, None)]
            self._is_unknow_rank = True
            self._axis = 0 if self._is_single_output() else 1

    def _process_single_output(self):
        if self._is_single_output():
            self._axis = 0

    def _process_unknown_axis(self):
        if self._axis is None:
            self._shapes = [-1, -1]
            min_range = [r_min for r_min, _ in self._ranges]
            if 0 in min_range and self._avg_split is False:
                self._ranges = [(0, None), (0, None)]
            else:
                self._ranges = [(1, None), (1, None)]
            self._axis = 0 if self._is_single_output() else 1

    def _merge_shape_range(self):
        if self.shape_is_const(self._shapes, 0, self._axis):
            self._merged_shapes.append(self.merge_shape(self._shapes[0:self._axis]))
        else:
            value = 1 if self._axis == 0 else -1
            self._merged_shapes.append(value)
        new_range = util.combine_range(self._ranges[0:self._axis] or [(1, 1)],
                                    bound_limit=INT32_LIMIT if self._merged_shapes[-1] <= INT32_LIMIT else INT64_LIMIT)
        self._merged_ranges.append(new_range)
        if self.shape_is_const(self._shapes, self._axis, len(self._shapes)):
            self._merged_shapes.append(self.merge_shape(self._shapes[self._axis:]))
        else:
            self._merged_shapes.append(-1)
        new_range = util.combine_range(self._ranges[self._axis:],
                                    bound_limit=INT32_LIMIT if self._merged_shapes[-1] <= INT32_LIMIT else INT64_LIMIT)
        self._merged_ranges.append(new_range)

    def _process_empty_shape(self):
        self._only_empty = 0 in self._shapes or all(lower == 0 and upper == 0 for lower, upper in self._ranges)
        self._maybe_empty = any(lower == 0 for lower, _ in self._ranges) or self._is_unknow_rank

    def _update_shape_range(self):
        for index, (shape_value, (lower, upper)) in enumerate(zip(self._merged_shapes, self._merged_ranges)):
            if shape_value != -1:
                self._merged_ranges[index] = (shape_value, shape_value)
            if lower is not None and upper is not None and lower == upper:
                self._merged_shapes[index] = lower

    def _process_const_split_size(self):
        if min(self._split_size) > -1 and min(self._merged_shapes) > -1 and self._ori_axis is not None:
            split_output = self._merged_shapes[1] // self._shapes[self._ori_axis]
            for index, value in enumerate(self._split_size):
                self._split_size[index] = value * split_output

    def _generate_ins(self):
        if self._only_empty:
            return [EmptyMode.gen_in(self._split_size)]
        res = [OriginalMode.gen_in(self._merged_shapes, self._merged_ranges, self._split_size)]
        if self._maybe_empty:
            res.append(EmptyMode.gen_in(self._split_size))
        return res


class OriginalMode:
    """
    Original Mode
    """

    @classmethod
    def gen_in(cls, shapes, ranges, split_size):
        """
        generate input
        :param shapes:
        :param ranges:
        :param split_size:
        :return:
        """
        new_input = {
                "shape": shapes,
                "range": ranges,
                "mode": SPLIT,
            }
        axis = 1
        return [new_input, axis, split_size]


class EmptyMode:
    """
    Empty Mode
    """

    @classmethod
    def gen_in(cls, split_size):
        """
        generate input
        :param split_size:
        :return:
        """
        new_input = {"shape": (0, 0),
                     "range": [(0, 0), (0, 0)],
                     "mode": SPLIT_EMPTY,
                     }
        axis = 0
        return [new_input, axis, split_size]
