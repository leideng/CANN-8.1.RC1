#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in conv3d_backprop_filter
"""

import copy
from itertools import product

from tbe.common.utils import log

from .conv_bp_filter_base import ConvBpFilterBase
from .conv_bp_filter_base import ComputeTemplate
from .util import LoadModeType


class Conv3dBpFilterClassifier(ConvBpFilterBase):
    """
    conv3dbpfilter classifier
    """

    def __init__(self, ins, op_name, fusion_mode, extra_params):
        """
        init
        :param ins: [input_list, attr_list, option_list]
            input_list: [x, filter_size, out_backprop, y]
            attr_list: single op mode, is [strides, pads, dilations, groups, data_format, kernel_name]
                       fusion mode, is [{"val": [strides, pads, dilations, groups, data_format], "name": kernel_name},]
            option_list: [{"name": op_name, "options": {}}, {}]
        :param extra_params: conv3d_backprop_filter is only used in single op
        """
        self.ins = ins
        self.input_list, self.attr_list, self.option_list = self.ins
        self.extra_params = extra_params

        inputs_list = self.input_list + self.attr_list
        super().__init__(inputs_list, op_name, fusion_mode)
        self.load_mode_list = []
        self.strideh_read_list = []

    @staticmethod
    def _is_invalid_choice(choice):
        load_mode, strideh_read = choice
        if strideh_read == 0 and load_mode == LoadModeType.LOAD3D:
            return False
        return True

    def classify(self):
        """
        Construct multiple inputs based on load_mode conditions
        """
        self._determine_classification_dynamic()
        outs = []
        choice_list = list(product(self.load_mode_list, self.strideh_read_list))
        for choice in choice_list:
            if self._is_invalid_choice(choice):
                continue
            load_mode, strideh_read = choice
            ct = ComputeTemplate()
            ct.flag_all_one_case = load_mode == LoadModeType.LOAD2D
            ct.flag_load3d_w_split_case = load_mode == LoadModeType.W_SPLIT_LOAD3D
            ct.l0b_dma_flag = load_mode == LoadModeType.DMA_CPY
            ct.strideh_read_flag = strideh_read
            ct.load_mode = load_mode
            log.debug("[ComputeTemplate] {}".format(ct.get_debug_info()))

            tmp_ins = list(copy.deepcopy(self.ins))
            # option struct is [{"name": op_x, "options": {}}, {"name": op_y, "options": {}}]
            cur_option = {"name": self.op_name, "options": {"compute_template": ct}}
            # in single op mode, option_list is empty
            tmp_ins[2] = [cur_option]

            outs.append(tuple(tmp_ins))
        return outs

    def _determine_classification_dynamic(self):
        self.load_mode_list = [LoadModeType.LOAD3D]
        self.strideh_read_list = [int(False)]
