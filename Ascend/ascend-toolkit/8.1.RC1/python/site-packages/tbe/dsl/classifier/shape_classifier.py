#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape
"""
import functools
from typing import Any
from typing import Dict
from typing import Optional

from tbe.common.register import operation_func_mgr
from tbe.dsl.base.classifier import conv2d_classifier
from tbe.dsl.classifier import conv2d_bp_input_classifier
from tbe.dsl.classifier import conv3d_bp_input_classifier


ELEWISE = "elewise"
BROADCAST = "broadcast"
NORM = "norm"
GENERIC_VECTOR = "generic_vector"
REDUCE = "reduce"
GATHER = "gather"
GATHER_ND = "gather_nd"
SPARSE_APPLY = "sparse_apply"
SLICE = "slice"
TRANSPOSE = "transpose"
CONCAT = "concat"
TRANSDATA = "transdata"
SPLIT = "split"
TUPLE_REDUCE = "tuple_reduce"
POOLING = "pooling"
POOLING_WITH_ARG = "pooling_with_arg"
CONV2D = "Convolution"
QUANT_CONV2D = "QuantConvolution"
QUANT = "quant"
CONV2D_BP_FILTER = "Conv2d_backprop_filter"
CONV2D_DX = "conv2d_backprop_input"
CONV2D_TRANSPOSE = "conv2d_transpose"
DEPTHWISW_CONV2D_DX = "depthwise_conv2d_backprop_input"
CONV3D = "Conv3D"
CONV3D_DX = "conv3d_backprop_input"
CONV3D_TRANSPOSE = "conv3d_transpose"
SORT = "sort"
RESIZE = "resize"
SEGMENT = "segment"
SCATTER = "scatter"
SCATTER_ND = "scatter_nd"
POOLING_GRAD_WITH_ARG = "pooling_grad_with_arg"
POOLING_GRAD = "PoolGrad"


CLASSIFY_SAME_PATTERN_MAP = {
    "ElemWise": ELEWISE,
    "Broadcast": BROADCAST,
    "CommReduce": REDUCE,
    "anti_quant":QUANT,
    "quant":QUANT
}

_classifiers = {}


@operation_func_mgr.register_classify_processor(QUANT_CONV2D, support_type="all")
@operation_func_mgr.register_classify_processor("Convolution", support_type="all")
@operation_func_mgr.register_classify_processor("Conv2d_backprop_filter", support_type="all")
def classify(ins: list, mode: str, extra_params: Optional[Dict[str, Any]] = None):
    """
    classify
    :param ins:
    :param mode:
    :param extra_params: must include keepdims when mode is reduce
    :return:
    """
    mode = CLASSIFY_SAME_PATTERN_MAP.get(mode, mode)
    if mode in [CONV2D, QUANT_CONV2D]:
        if extra_params is not None:
            if extra_params.get("op_pattern") is None:
                extra_params.update({"op_pattern": mode})
        else:
            extra_params = {"op_pattern": mode}
        return conv2d_classifier.classify(ins, extra_params)
    if mode in [CONV2D_DX, CONV2D_TRANSPOSE, DEPTHWISW_CONV2D_DX]:
        return conv2d_bp_input_classifier.classify(ins, extra_params, mode=mode)
    if mode in (CONV3D_DX, CONV3D_TRANSPOSE):
        return conv3d_bp_input_classifier.classify(ins, extra_params, mode=mode)

    classifier_func = _get_classifier(mode)
    if classifier_func is not None:
        return classifier_func(ins, extra_params)

    return [ins]


def _get_classifier(mode):
    # type: (str) -> callable
    return _classifiers.get(mode)


def register_classifier(mode):
    # type: (str) -> callable
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        _classifiers[mode] = wrapper
        return wrapper

    return decorator
