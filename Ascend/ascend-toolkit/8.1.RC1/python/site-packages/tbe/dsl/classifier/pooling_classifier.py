#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in pooling
"""
import copy
import dataclasses
from enum import Enum
from itertools import product

from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.base.operation import add_compile_info_inner

from . import shape_classifier
from . import util

UNKNOWN_DIM_VALUE = -1
NANO_BLOCK_SIZE = 16

DTYPE_AND_LAST_DIM_MAP = {
    "float32": (8, 16),
    "int32": (8, 16),
    "float16": (16, ),
    "int16": (16, ),
    "int8": (32, ),
    "uint8": (32, )
}

NANO_DTYPE_AND_LAST_DIM_MAP = {
    "float16": (8, ),
}


def _is_true(expr, dict_args):
    """
    check if true
    """
    if not expr:
        raise RuntimeError(dict_args, get_error_message(dict_args))


class WindowAxisType(Enum):
    """
    window axis type enum
    """
    SPLIT = "split"
    NONE_REDUCE = "none_reduce"
    GLOBAL_REDUCE = "global_reduce"
    NORMAL = "normal"


@dataclasses.dataclass
class PoolingInputInfo:
    """
    input info
    """
    shape: list = dataclasses.field(default_factory=list)
    shape_range: list = dataclasses.field(default_factory=list)
    window_axes: list = dataclasses.field(default_factory=list)
    global_axes: list = dataclasses.field(default_factory=list)
    disable_fuse_axes: list = dataclasses.field(default_factory=list)


@dataclasses.dataclass
class WindowInfo:
    """
    window info
    """
    dimensions: list = dataclasses.field(default_factory=list)
    strides: list = dataclasses.field(default_factory=list)
    dilations: list = dataclasses.field(default_factory=list)
    paddings: list = dataclasses.field(default_factory=list)


class PoolingStrategy:
    """
    split and fuse strategy, which consists of the types of window axes
    types:
        1. WindowAxisType.NORMAL: common window axis
        2. WindowAxisType.SPLIT: dimension=stride, padding=[0, 0], dilation=1, input_dim % dimension == 0,
                                    previous is common axis.
                                    A X -> A Xo Xk -> AXo Xk
        3. WindowAxisType.NONE_REDUCE: dimension=stride=1, padding=[0, 0], dilation=1, previous is common axis
                                        A X -> A Xo 1 -> AXo
        4. WindowAxisType.GLOBAL_REDUCE: window dimension=dim dimension, padding=[0, 0], dilation=1,
                                            previous is SPLIT.
                                            Xo Xk Y -> Xo Xk Yo Yk -> Xo Xk 1 Yk -> Xo XkYk
    special rule: if all types of window_axes are WindowAxisType.NONE_REDUCE, convert last window axis to SPLIT
            (NONE_REDUCE, NONE_REDUCE, NONE_REDUCE) -> (NONE_REDUCE, NONE_REDUCE, SPLIT)
    """
    def __init__(self, input_info: PoolingInputInfo, window_info: WindowInfo, is_global_pooling: bool):
        """
        pooling strategy init
        """
        self.input_info = input_info
        self.window_info = window_info
        self.is_global_pooling = is_global_pooling

        self.global_reduce_prerequisite = None
        self.none_reduce_and_split_prerequisite = None

        self.strategy = self._generate()

    @staticmethod
    def _refine(single_strategy):
        refined_single_strategy = list(single_strategy)
        if set(refined_single_strategy) == {WindowAxisType.NONE_REDUCE}:
            refined_single_strategy[-1] = WindowAxisType.SPLIT

        return refined_single_strategy

    def _generate(self):
        if self.window_info.dimensions is None or self.window_info.strides is None or self.is_global_pooling:
            return [[WindowAxisType.NORMAL] * len(self.input_info.window_axes)]

        window_axes_type_list_list = \
            [[WindowAxisType.NORMAL, WindowAxisType.GLOBAL_REDUCE,
              WindowAxisType.NONE_REDUCE, WindowAxisType.SPLIT] for _ in range(len(self.input_info.window_axes))]

        split_and_fuse_strategy = []
        for single_strategy in product(*window_axes_type_list_list):
            if not self._prune(single_strategy):
                refined_single_strategy = self._refine(single_strategy)
                if refined_single_strategy not in split_and_fuse_strategy:
                    split_and_fuse_strategy.append(refined_single_strategy)

        return split_and_fuse_strategy

    def _is_global_reduce_prerequisite(self, dim_index, window_index, single_strategy):
        position_prerequisite = dim_index - 1 in self.input_info.window_axes and \
            single_strategy[window_index - 1] == WindowAxisType.SPLIT and \
            dim_index - 1 not in self.input_info.disable_fuse_axes and \
            dim_index not in self.input_info.disable_fuse_axes

        dilation = self.window_info.dilations[window_index]
        padding = self.window_info.paddings[window_index]
        is_valid_stride = self.window_info.strides[window_index] == self.window_info.dimensions[window_index]
        window_info_prerequisite = dilation == 1 and list(padding) == [0, 0] and is_valid_stride

        self.global_reduce_prerequisite = position_prerequisite and window_info_prerequisite

    def _is_none_reduce_and_split_prerequisite(self, dim_index, window_index, single_strategy):
        position_prerequisite = dim_index != 0 and \
            (dim_index - 1 not in self.input_info.window_axes or
             single_strategy[window_index - 1] == WindowAxisType.NONE_REDUCE) and \
            dim_index - 1 not in self.input_info.disable_fuse_axes and \
            dim_index not in self.input_info.disable_fuse_axes

        dimension = self.window_info.dimensions[window_index]
        stride = self.window_info.strides[window_index]
        dilation = self.window_info.dilations[window_index]
        padding = self.window_info.paddings[window_index]
        window_info_prerequisite = dimension == stride and dilation == 1 and list(padding) == [0, 0]

        self.none_reduce_and_split_prerequisite = position_prerequisite and window_info_prerequisite

    def _judge_pruning_none_reduce_and_split(self, dim_index, window_index, single_strategy):
        cur_type = single_strategy[window_index]
        if cur_type not in (WindowAxisType.SPLIT, WindowAxisType.NONE_REDUCE):
            return False

        dim = self.input_info.shape[dim_index]
        dimension = self.window_info.dimensions[window_index]

        if not self.none_reduce_and_split_prerequisite:
            return True
        if dim != UNKNOWN_DIM_VALUE and dim % dimension != 0:
            return True
        if cur_type == WindowAxisType.NONE_REDUCE:
            if dimension != 1:
                return True
        else:
            if dimension == 1:
                return True

        return False

    def _judge_pruning_global_reduce(self, dim_index, window_index, single_strategy):
        cur_type = single_strategy[window_index]
        if cur_type != WindowAxisType.GLOBAL_REDUCE:
            return False

        dim = self.input_info.shape[dim_index]
        dim_range = self.input_info.shape_range[dim_index]
        max_range = util.VAR_BOUND_LIMIT if dim_range[1] is None else dim_range[1]
        dimension = self.window_info.dimensions[window_index]

        if not self.global_reduce_prerequisite:
            return True
        if dim == UNKNOWN_DIM_VALUE:
            if dim_range[0] > dimension or dimension > max_range:
                return True
        else:
            if dim != dimension:
                return True

        return False

    def _judge_pruning_normal(self, dim_index, window_index, single_strategy):
        cur_type = single_strategy[window_index]
        if cur_type != WindowAxisType.NORMAL:
            return False

        dim = self.input_info.shape[dim_index]
        dimension = self.window_info.dimensions[window_index]

        if self.global_reduce_prerequisite:
            if dim != UNKNOWN_DIM_VALUE:
                if dim == dimension:
                    return True
        if self.none_reduce_and_split_prerequisite:
            if dim != UNKNOWN_DIM_VALUE:
                if dim % dimension == 0:
                    return True
            else:
                if dimension == 1:
                    return True

        return False

    def _prune(self, single_strategy):
        window_axes_count = 0
        for i in range(len(self.input_info.shape)):
            if i not in self.input_info.window_axes:
                continue
            self._is_global_reduce_prerequisite(i, window_axes_count, single_strategy)
            self._is_none_reduce_and_split_prerequisite(i, window_axes_count, single_strategy)

            if self._judge_pruning_none_reduce_and_split(i, window_axes_count, single_strategy) or \
                    self._judge_pruning_global_reduce(i, window_axes_count, single_strategy) or \
                    self._judge_pruning_normal(i, window_axes_count, single_strategy):
                return True

            window_axes_count += 1

        return False


class PoolingClassifyInfo:
    """
    pooling classify info
    """
    def __init__(self, window_axes, extra_params):
        """
        pooling classify info init
        """
        self._check_extra_params(extra_params)
        self.window_axes = window_axes
        self.window_info = WindowInfo()
        self.extra_params = extra_params
        self.is_global_pooling = self._parse_global_pooling()
        self.disable_fuse_axes = self._parse_disable_fuse_axes()
        self.window_info.dimensions = self._parse_window_dimensions()
        self.window_info.strides = self._parse_window_strides()
        self.window_info.dilations = self._parse_window_dilations()
        self.window_info.paddings = self._parse_padding_dimensions()

    @staticmethod
    def _check_extra_params(extra_params):
        """
        check extra_params
        """
        _is_true(extra_params is None or isinstance(extra_params, dict),
                 {"errCode": "E90001",
                  "detailed_cause": "extra_params must be a dict or None when mode is pooling."})

    def normalize(self, max_dim_len):
        """
        normalize window info
        1. convert negative value in window_axes to positive: -1 -> -1 + max_dim_len
        2. sort window_axes
        3. sort window_dimensions/window_strides/window_dilations/padding_dimensions
           according to sorted window_axes index
        """
        def _reorder_list(_ori_list, _index_list):
            if not _ori_list:
                return _ori_list

            return [_ori_list[i] for i in _index_list]

        local_window_axes = [x + max_dim_len if x < 0 else x for x in self.window_axes]
        sorted_window_axes = sorted(enumerate(local_window_axes), key=lambda x: x[1])
        self.window_axes = [i[1] for i in sorted_window_axes]
        index_list = [i[0] for i in sorted_window_axes]
        for single_window_axis in self.window_axes:
            _is_true(0 <= single_window_axis < max_dim_len,
                     {"errCode": "E90001",
                      "detailed_cause": f"window axis {single_window_axis} must less than"
                                        f"{max_dim_len} and larger than zero!"})
        _is_true(max_dim_len - 1 not in self.window_axes,
                 {"errCode": "E90001",
                  "detailed_cause": "In pooling classifier, last axis of input shape must not be window axis."})

        self.window_info.dimensions = _reorder_list(self.window_info.dimensions, index_list)
        self.window_info.strides = _reorder_list(self.window_info.strides, index_list)
        self.window_info.dilations = _reorder_list(self.window_info.dilations, index_list)
        self.window_info.paddings = _reorder_list(self.window_info.paddings, index_list)

    def add_to_compile_info(self):
        """
        add window info to compile info
        """
        def _gen_window_info(_ori_window_info):
            return [] if _ori_window_info is None else _ori_window_info[:]

        add_compile_info_inner("_ori_window_axes", self.window_axes[:])

        window_info = []
        window_info.append(_gen_window_info(self.window_info.dimensions))
        window_info.append(_gen_window_info(self.window_info.strides))
        window_info.append(_gen_window_info(self.window_info.dilations))
        if self.window_info.paddings is None:
            window_info.append([])
        else:
            window_info.append([item for sub_list in self.window_info.paddings for item in sub_list])

        add_compile_info_inner("_ori_window_info", window_info)

    def _parse_global_pooling(self):
        """
        parse global_pooling
        """
        if self.extra_params is None:
            return False

        is_global_pooling = False
        if "global_pooling" in self.extra_params:
            is_global_pooling = self.extra_params.get("global_pooling")
            add_compile_info_inner("_is_global_pooling", is_global_pooling)

        return is_global_pooling

    def _parse_disable_fuse_axes(self):
        """
        parse disable_fuse_axes
        """
        if self.extra_params is None:
            return []

        disable_fuse_axes = []
        if "disable_fuse_axes" in self.extra_params:
            disable_fuse_axes = self.extra_params.get("disable_fuse_axes")
            _is_true(all(x >= 0 for x in disable_fuse_axes),
                     {"errCode": "E90001",
                      "detailed_cause": "element in disable_fuse_axes must be positive."})
            add_compile_info_inner("_disable_fuse_axes", disable_fuse_axes)

        return disable_fuse_axes

    def _parse_window_dimensions(self):
        """
        parse window_dimensions
        """
        if self.extra_params is None:
            return []

        window_dimensions = []
        if "window_dimensions" in self.extra_params:
            window_dimensions = self.extra_params.get("window_dimensions")

            if window_dimensions is None:
                return window_dimensions

            _is_true(isinstance(window_dimensions, (list, tuple)) and len(window_dimensions) == len(self.window_axes),
                     {"errCode": "E90001",
                      "detailed_cause": "In pooling classifier, window_dimensions must be a list or a tuple and "
                                        "its length must be equal to length of window axes."})

        return window_dimensions

    def _parse_window_strides(self):
        """
        parse window_strides
        """
        if self.extra_params is None:
            return []

        window_strides = []
        if "window_strides" in self.extra_params:
            window_strides = self.extra_params.get("window_strides")

            if window_strides is None:
                return window_strides

            _is_true(isinstance(window_strides, (list, tuple)) and len(window_strides) == len(self.window_axes),
                     {"errCode": "E90001",
                      "detailed_cause": "In pooling classifier, window_strides must be a list or a tuple and "
                                        "its length must be equal to length of window axes."})

        return window_strides

    def _parse_window_dilations(self):
        """
        parse window_dilations
        """
        window_dilations = [1] * len(self.window_axes)

        if self.extra_params is None:
            return window_dilations

        if "window_dilations" in self.extra_params:
            window_dilations = self.extra_params.get("window_dilations")

            if window_dilations is None:
                return window_dilations

            _is_true(isinstance(window_dilations, (list, tuple)) and len(window_dilations) == len(self.window_axes),
                     {"errCode": "E90001",
                      "detailed_cause": "In pooling classifier, window_dilations must be a list or a tuple and "
                                        "its length must be equal to length of window axes."})

        return window_dilations

    def _parse_padding_dimensions(self):
        """
        parse padding_dimensions
        """
        padding_dimensions = [[0, 0] for _ in range(len(self.window_axes))]

        if self.extra_params is None:
            return padding_dimensions

        if "padding_dimensions" in self.extra_params:
            padding_dimensions = self.extra_params.get("padding_dimensions")

            if padding_dimensions is None:
                return padding_dimensions

            _is_true(isinstance(padding_dimensions, (list, tuple)) and
                     len(padding_dimensions) == len(self.window_axes),
                     {"errCode": "E90001",
                      "detailed_cause": "In pooling classifier, padding_dimensions must be a list or a tuple and "
                                        "its length must be equal to length of window axes."})
            for sub_dimensions in padding_dimensions:
                _is_true(isinstance(sub_dimensions, (list, tuple)) and len(sub_dimensions) == 2,
                         {"errCode": "E90001",
                          "detailed_cause": "In pooling classifier, element in padding_dimensions must be "
                                            "a list or a tuple, which length must be 2."})

        return padding_dimensions


def _check(ins):
    """
    pooling classifier check
    """
    _is_true(len(ins) >= 1,
             {"errCode": "E90001",
              "detailed_cause": "In pooling classifier, length of inputs must be no less than 1."})

    inputs = ins[:-1]
    for single_input in inputs:
        cur_dtype = single_input.get("dtype")
        if int(get_soc_spec("ubblock_size")) == NANO_BLOCK_SIZE:
            expected_last_dim_values = NANO_DTYPE_AND_LAST_DIM_MAP.get(cur_dtype)
        else:
            expected_last_dim_values = DTYPE_AND_LAST_DIM_MAP.get(cur_dtype)
        _is_true(single_input.get("shape")[-1] in expected_last_dim_values,
                 {"errCode": "E90001",
                  "detailed_cause": f"In pooling classifier, last dim of input shape "
                                    f"must be in {expected_last_dim_values} when dtype is {cur_dtype}."})
        _is_true(-2 not in single_input.get("shape"),
                 {"errCode": "E90001",
                  "detailed_cause": "In pooling classifier, -2 is not supported yet."})

    window_axes = ins[-1]
    _is_true(tuple(window_axes) in [(2, 3), (1, 3, 4)],
             {"errCode": "E90001",
              "detailed_cause": "In pooling classifier, only support 5HD and 6HD currently."})


@shape_classifier.register_classifier(shape_classifier.POOLING)
def classify(ins: list, extra_params: dict):
    """
    classify
    :param ins: inputs list and last element must be window axes
    :param extra_params: a dict with the following keys:
        "disable_fuse_axes": [input: list, output: list[list]] with positive elements.
            The input list consists of the indices of the non-fusible axes. Each list in the output list
            is the new index of the non-fusible axes after the fused axes in the corresponding scene.
        "window_dimensions" : list or tuple
            Dimensions of window
        "window_strides" : list or tuple
            Strides of window
        "window_dilations" : list or tuple
            Dilations of window, default value is [1] * window_length
        "padding_dimensions" : list[list] or tuple[tuple]
            Dimensions of padding on all window sides and one window side corresponds to two dimensions
            None means padding dimensions are all zero, default is None
        "global_pooling" : bool
            Flag of global pooling
    :return:
    """
    _check(ins)
    inputs = ins[:-1]
    ops_window_axes = ins[-1]

    classify_info = PoolingClassifyInfo(ops_window_axes, extra_params)
    pooling_classifier = PoolingClassifier(inputs, classify_info)

    classify_out = pooling_classifier.classify()

    return classify_out


def _get_shape_and_range_list(inputs):
    """
    get shape and range list according inputs dict
    """
    shape_list = [x.get("shape") for x in inputs]
    range_list = []
    for single_input in inputs:
        single_range = single_input.get("range")
        if single_range:
            range_list.append(single_range)
        else:
            range_list.append([(1, None) for _ in range(len(shape_list[0]))])

    return shape_list, range_list


def _infer_shape_and_range(shape_list, range_list):
    """
    infer shape and range according to shape and range list
    """
    def __get_dim(_i):
        return max(s[_i] for s in shape_list)

    def __select_min_upper_bound(_upper_bound_list):
        _min_ele = util.VAR_BOUND_LIMIT + 1
        for _ele in _upper_bound_list:
            if _ele is None:
                continue
            if _ele < _min_ele:
                _min_ele = _ele

        return _min_ele if _min_ele != util.VAR_BOUND_LIMIT + 1 else None

    def __get_range(_i):
        if shape_out[_i] != UNKNOWN_DIM_VALUE:
            return shape_out[_i], shape_out[_i]

        return max(r[_i][0] for r in range_list), \
            __select_min_upper_bound([r[_i][1] for r in range_list])

    shape_out = [__get_dim(i) for i in range(len(shape_list[0]))]
    range_out = [__get_range(i) for i in range(len(range_list[0]))]

    for index, _ in enumerate(shape_out):
        if range_out[index][0] == range_out[index][1]:
            shape_out[index] = range_out[index][0]

    return shape_out, range_out


class PoolingClassifier:
    """
    pooling classifier
    """
    def __init__(self, ins: list, classify_info: PoolingClassifyInfo):
        """
        pooling classifier init
        """
        self.ins = ins
        self.max_shape_len = max(len(x.get("shape")) for x in ins)

        self.classify_info = classify_info
        self.classify_info.normalize(self.max_shape_len)
        self.classify_info.add_to_compile_info()

        self.window_axes = classify_info.window_axes
        self.window_info = classify_info.window_info

        self.inferred_shape, self.inferred_range = self._infer()
        self.split_and_fuse_strategy = self._gen_split_and_fuse_strategy()
        self.classify_output = self._gen_classify_output()

    @staticmethod
    def _fuse(s_input_info: PoolingInputInfo, s_window_info: WindowInfo, is_unknown_window_info=False):
        """
        fuse shape, range, window axes, window info
        # common_axis, common_axis can be fused
        # global_reduce_axis, global_reduce_axis can be fused
        # window_reduce_axis, window_reduce_axis can not be fused
        """
        def __obtain_state(_index):
            if is_pad_axis:
                _output_state = "pad_" + str(_index)
                return _output_state

            if is_window_axis:
                if is_global_axis:
                    return "global_reduce"

                return "window_reduce_" + str(_index)

            return "common"

        f_input_info = PoolingInputInfo()
        f_window_info = WindowInfo()
        window_axes_count = 0
        state = "init"
        for i, (d, r) in enumerate(zip(s_input_info.shape, s_input_info.shape_range)):
            is_pad_axis = i in s_input_info.disable_fuse_axes
            is_window_axis = i in s_input_info.window_axes
            is_global_axis = i in s_input_info.global_axes
            state_i = __obtain_state(i)

            if state == state_i:
                f_input_info.shape[-1] = util.combine_dim([f_input_info.shape[-1], d])
                f_input_info.shape_range[-1] = util.combine_range([f_input_info.shape_range[-1], r])
                if is_global_axis and not is_unknown_window_info:
                    f_window_info.dimensions[-1] = \
                        f_window_info.dimensions[-1] * s_window_info.dimensions[window_axes_count]
                    f_window_info.strides[-1] = f_window_info.dimensions[-1]
                    f_window_info.dilations[-1] = 1
                    f_window_info.paddings[-1] = [0, 0]
            else:
                f_input_info.shape.append(d)
                f_input_info.shape_range.append(r)
                if is_window_axis and not is_unknown_window_info:
                    f_window_info.dimensions.append(s_window_info.dimensions[window_axes_count])
                    f_window_info.strides.append(s_window_info.strides[window_axes_count])
                    f_window_info.dilations.append(s_window_info.dilations[window_axes_count])
                    f_window_info.paddings.append(s_window_info.paddings[window_axes_count])

            if is_window_axis:
                cur_window_axis = len(f_input_info.shape) - 1
                append_window_axis = not f_input_info.window_axes or f_input_info.window_axes[-1] != cur_window_axis
                if append_window_axis:
                    f_input_info.window_axes.append(cur_window_axis)
                window_axes_count += 1

            state = state_i

        return f_input_info, f_window_info

    def classify(self):
        """
        get pooling classifier out
        """
        return self.classify_output

    def _infer(self):
        """
        infer shape and range
        return:
        1. inferred_shape
        2. inferred_range
        """
        local_shape_list, local_range_list = _get_shape_and_range_list(self.ins)
        shape_to_fuse, range_to_fuse = _infer_shape_and_range(local_shape_list, local_range_list)

        return shape_to_fuse, range_to_fuse

    def _gen_split_and_fuse_strategy(self):
        """
        generate split and fuse strategy
        """
        ori_input_info = PoolingInputInfo(shape=self.inferred_shape, shape_range=self.inferred_range,
                                          window_axes=self.window_axes,
                                          disable_fuse_axes=self.classify_info.disable_fuse_axes)
        pooling_strategy = PoolingStrategy(ori_input_info, self.window_info, self.classify_info.is_global_pooling)

        return pooling_strategy.strategy

    def _split(self, split_and_fuse_strategy):
        """
        split shape, range, window axes, window info according to window_axes_type
        """
        def __split_shape_and_range(_shape, _range, _factor):
            if _shape != UNKNOWN_DIM_VALUE:
                _out_shape = [_shape // _factor, _factor]
                _out_range = [(_out_shape[0], _out_shape[0]), (_out_shape[1], _out_shape[1])]
            else:
                _out_shape = [UNKNOWN_DIM_VALUE, _factor]
                _first_dim_max_range = None if _range[1] is None else (_range[1] + _factor - 1) // _factor
                _first_dim_min_range = (_range[0] + _factor - 1) // _factor
                _out_range = [(_first_dim_min_range, _first_dim_max_range), (_out_shape[1], _out_shape[1])]

            return _out_shape, _out_range

        def __add_window_info(_window_info: WindowInfo, _dimensions, _strides, _dilations, _paddings):
            _window_info.dimensions.append(_dimensions)
            _window_info.strides.append(_strides)
            _window_info.dilations.append(_dilations)
            _window_info.paddings.append(_paddings)

        s_input_info = PoolingInputInfo()
        s_window_info = WindowInfo()
        extra_common_axis_count = 0
        window_axes_count = 0
        for i, (d, r) in enumerate(zip(self.inferred_shape, self.inferred_range)):
            if i in self.classify_info.disable_fuse_axes:
                s_input_info.disable_fuse_axes.append(i + extra_common_axis_count)
            if i not in self.window_axes:
                s_input_info.shape.append(d)
                s_input_info.shape_range.append(r)
                continue
            window_axis_type = split_and_fuse_strategy[window_axes_count]
            k_size = self.window_info.dimensions[window_axes_count]
            if window_axis_type == WindowAxisType.NONE_REDUCE:
                s_input_info.shape.append(d)
                s_input_info.shape_range.append(r)
            elif window_axis_type == WindowAxisType.GLOBAL_REDUCE:
                s_input_info.shape.append(k_size)
                s_input_info.shape_range.append([k_size, k_size])
                s_input_info.global_axes.append(i + extra_common_axis_count)
                s_input_info.window_axes.append(i + extra_common_axis_count)
                __add_window_info(s_window_info, k_size, k_size, 1, [0, 0])
            elif window_axis_type == WindowAxisType.SPLIT:
                shapes, ranges = __split_shape_and_range(d, r, k_size)
                s_input_info.shape.extend(shapes)
                s_input_info.shape_range.extend(ranges)
                extra_common_axis_count += 1
                s_input_info.global_axes.append(i + extra_common_axis_count)
                s_input_info.window_axes.append(i + extra_common_axis_count)
                __add_window_info(s_window_info, k_size, k_size, 1, [0, 0])
                if i in self.classify_info.disable_fuse_axes:
                    s_input_info.disable_fuse_axes.append(i + extra_common_axis_count)
            else:
                s_input_info.shape.append(d)
                s_input_info.shape_range.append(r)
                s_input_info.window_axes.append(i + extra_common_axis_count)
                __add_window_info(s_window_info, k_size, self.window_info.strides[window_axes_count],
                                  self.window_info.dilations[window_axes_count],
                                  self.window_info.paddings[window_axes_count])
            window_axes_count += 1

        return s_input_info, s_window_info

    def _gen_classify_output(self):
        """
        generate classify out
        """
        if self.window_info.dimensions is None or self.window_info.strides is None:
            ori_input_info = PoolingInputInfo(shape=self.inferred_shape, shape_range=self.inferred_range,
                                              window_axes=self.window_axes,
                                              disable_fuse_axes=self.classify_info.disable_fuse_axes)
            f_input_info, _ = self._fuse(ori_input_info, self.window_info, is_unknown_window_info=True)
            single_output = {
                "shape": f_input_info.shape,
                "range": f_input_info.shape_range,
                "strategy": ["normal"] * len(self.window_axes),
                "window_dimensions": self.window_info.dimensions,
                "window_strides": self.window_info.strides,
                "window_dilations": self.window_info.dilations,
                "padding_dimensions": self.window_info.paddings,
            }
            cur_output = [copy.deepcopy(single_output) for _ in self.ins]
            cur_output.append(f_input_info.window_axes)

            return [cur_output]

        classify_output = []
        mode = "const"
        for single_strategy in self.split_and_fuse_strategy:
            t_input_info, t_window_info = self._split(single_strategy)
            f_input_info, f_window_info = self._fuse(t_input_info, t_window_info)
            single_output = {
                "shape": f_input_info.shape,
                "range": f_input_info.shape_range,
                "strategy": [i.value for i in single_strategy],
                "window_dimensions": f_window_info.dimensions,
                "window_strides": f_window_info.strides,
                "window_dilations": f_window_info.dilations,
                "padding_dimensions": f_window_info.paddings,
            }
            if any(x < 0 for x in f_input_info.shape):
                mode = "dynamic"
            cur_output = [copy.deepcopy(single_output) for _ in self.ins]
            cur_output.append(f_input_info.window_axes)
            classify_output.append(cur_output)

        for output in classify_output:
            for single_out in output:
                if isinstance(single_out, dict):
                    single_out["mode"] = mode

        return classify_output
