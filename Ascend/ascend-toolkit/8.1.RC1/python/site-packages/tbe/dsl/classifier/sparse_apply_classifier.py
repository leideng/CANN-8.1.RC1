#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in sparse_apply
"""

from functools import reduce as shape_product
from typing import Any
from typing import Dict
from typing import Optional
from tbe.dsl.base import operation
from tbe.common.utils.errormgr import get_error_message
from . import shape_classifier

UNKNOWN_RANK = -2
INDEX_TYPE = 2


class SparseClassifier:
    def __init__(self, ins: list, extra_params: list):
        """
        :param ins: input list
        :extra_param: extra parameters, specify input shape type: 0 for var, 1 for grad, 2 for indices 
        """
        self.ins = list(zip(extra_params, ins))

    def classify(self):
        if operation.get_context().get_mode() == "static":
            self._unify_static_shape()
        else:
            self._check_unknown_rank()
            self._unify_dynamic_shape()
        inputs = []
        for shape_type, _in in self.ins:
            ret = {"shape": _in.get("shape"), "range": _in.get("range"), "input_shape_type": shape_type}
            inputs.append(ret)
        return [inputs]

    def _unify_static_shape(self):
        for shape_type, _in in self.ins:
            if shape_type != INDEX_TYPE:
                # ignore indices input
                if len(_in.get("shape")) > 1:
                    _in["shape"] = [_in.get("shape")[0], shape_product(lambda x, y : x * y, _in.get("shape")[1:])]
                else:
                    _in["shape"] = [_in.get("shape")[0], 1]

    def _check_unknown_rank(self):
        for shape_type, _in in self.ins:
            shape = list(_in.get("shape"))
            if UNKNOWN_RANK in shape:
                if len(shape) != 1:
                    dict_args = {"errCode": "E90001",
                                 "detailed_cause": "If the shape contains -2, it must be [-2] or (-2,)"}
                    raise RuntimeError(dict_args, get_error_message(dict_args))
                if shape_type == INDEX_TYPE:
                    _in["shape"] = [-1]
                    _in["range"] = [(1, None)]
                else:
                    _in["shape"] = [-1, -1]
                    _in["range"] = [(1, None), (1, None)]

    def _unify_dynamic_shape(self):
        for shape_type, _in in self.ins:
            if shape_type != INDEX_TYPE:
                if len(_in.get("shape")) > 1:
                    if -1 in _in.get("shape")[1:]:
                        _in["shape"] = [_in.get("shape")[0], -1]
                        _in["range"] = [_in.get("range")[0], (1, None)]
                    else:
                        _in["shape"] = [_in.get("shape")[0], shape_product(lambda x, y : x * y, _in.get("shape")[1:])]
                        _in["range"] = [_in.get("range")[0], (_in["shape"][1], _in["shape"][1])]
                else:
                    _in["shape"] = [_in.get("shape")[0], 1]
                    _in["range"] = [_in.get("range")[0], (1, 1)]


@shape_classifier.register_classifier(shape_classifier.SPARSE_APPLY)
def classify_sparse(ins: list, extra_params: Optional[Dict[str, Any]] = None):
    operation.get_context().add("_classify_inputs_num", len(ins))
    if not extra_params:
        dict_args = {"errCode": "E90001", "detailed_cause": "extra_params cannot be empty"}
        raise RuntimeError(dict_args, get_error_message(dict_args))

    if len(ins) != len(extra_params.get("input_shape_type")):
        dict_args = {"errCode": "E90001", "detailed_cause": "classify_inputs num must equal to extra_parms_num"}
        raise RuntimeError(dict_args, get_error_message(dict_args))

    return SparseClassifier(ins, extra_params.get("input_shape_type")).classify()
