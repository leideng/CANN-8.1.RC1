#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in scatter
"""
from itertools import chain
from typing import Any
from typing import Dict
from typing import Optional

from tbe.dsl.base import operation

from . import shape_classifier
from . import util

UNKNOWN = "unknown"
UNKNOWN_DIM = -1
UNKNOWN_RANK = -2
MAX_DIMS = 8 


def _classify_scatter_zero_shape(var_dtype, indices_dtype):
    var_dict = {
        "shape": (0, 0),
        "range": ((0, 0), (0, 0)),
        "dtype": var_dtype
    }
    indices_dict = {
        "shape": (0, 1),
        "range": ((0, 0), (1, 1)),
        "dtype": indices_dtype
    }
    update_dict = {
        "shape": (0, 0),
        "range": ((0, 0), (0, 0)),
        "dtype": var_dtype
    }
    return [var_dict, indices_dict, update_dict]


@shape_classifier.register_classifier(shape_classifier.SCATTER)
def classify_scatter(ins: list, extra_params: Optional[Dict[str, Any]]):
    """
    ScatterClassifier
    :param ins:
    :param extra_params:
    :return:
    """
    return ScatterClassifier(ins).classify()


@shape_classifier.register_classifier(shape_classifier.SCATTER_ND)
def classify_scatter_nd(ins: list, extra_params: Optional[Dict[str, Any]]):
    """
    ScatterNdClassifier
    :param ins:
    :param extra_params:
    :return:
    """
    return ScatterClassifier(ins, shape_classifier.SCATTER_ND, extra_params).classify()


class ScatterClassifier:
    def __init__(self, ins: list, scatter_type=shape_classifier.SCATTER, extra_params=None):
        self.is_zeros_shape = False
        self.is_zeros_range = False
        self.op_name_is_scatter_nd = False
        # operator of 'scatter_nd' needs special processing because there is no var input
        self.op_name_is_scatter_nd = False
        self.is_static = operation.get_op_mode() == "static"
        if extra_params is not None and "op_name" in extra_params:
            self.op_name_is_scatter_nd = extra_params.get("op_name") == "scatter_nd"

        if not self.op_name_is_scatter_nd:
            self.ori_var_shape = list(ins[0].get("shape"))
            self.ori_var_range = list(ins[0].get("range"))
            self.ori_indices_shape = list(ins[1].get("shape"))
            self.ori_indices_range = list(ins[1].get("range"))
            self.ori_update_shape = list(ins[2].get("shape"))
            self.ori_update_range = list(ins[2].get("range"))
            self.var_dtype = ins[0].get("dtype")
        else:
            self.ori_indices_shape = list(ins[0].get("shape"))
            self.ori_indices_range = list(ins[0].get("range"))
            self.ori_update_shape = list(ins[1].get("shape"))
            self.ori_update_range = list(ins[1].get("range"))
            self.last_input = ins[2]
            self.ori_var_shape = []
            self.ori_var_range = []
            if "const_value" in self.last_input and self.is_static:
                self.ori_var_shape = self.last_input.get("const_value")
                self.ori_var_range = util.generate_range(self.ori_var_shape)
            else:
                self.ori_var_shape = [UNKNOWN_DIM, ] * MAX_DIMS
                self.ori_var_range = [(1, None)] * MAX_DIMS
            self.var_dtype = ins[1].get("dtype")
        if -2 in chain(list(self.ori_var_shape) + self.ori_indices_shape + self.ori_update_shape):
            self.is_zeros_range = True
        self.indices_dtype = ins[0].get("dtype") if self.op_name_is_scatter_nd else ins[1].get("dtype")
        self.scatter_axis = 0
        self.scatter_rank = 1
        self.scatter_type = scatter_type

        self.var_shape = self.ori_var_shape
        self.var_range = self.ori_var_range
        self.indices_shape = self.ori_indices_shape
        self.indices_range = self.ori_indices_range
        self.update_shape = self.ori_update_shape
        self.update_range = self.ori_update_range
        self._check_zero_shape()

    def add_compile_info(self):
        operation.get_context().add("_scatter_axis", self.scatter_axis)
        operation.get_context().add("_scatter_mode", self.scatter_type)

    def ori_info_process(self):
        if self.is_static:
            if self.scatter_type == shape_classifier.SCATTER:
                self.indices_shape.append(1)
                self.indices_range.append((1, 1))
            total_indices = util.combine_dim(self.indices_shape[:])
            if total_indices == 1:
                self.update_shape.insert(0, 1)
                self.update_range.insert(0, (1, 1))
        else:
            if self.scatter_type == shape_classifier.SCATTER:
                if not self.op_name_is_scatter_nd:
                    self.var_shape = [UNKNOWN_DIM, UNKNOWN_DIM]
                    self.var_range = [(1, None), (1, None)]
                self.indices_shape = [UNKNOWN_DIM, UNKNOWN_DIM]
                self.indices_range = [(1, None), (1, None)]
                self.update_shape = [UNKNOWN_DIM, UNKNOWN_DIM]
                self.update_range = [(1, None), (1, None)]
            else:
                if not self.op_name_is_scatter_nd:
                    var_dims = len(self.ori_var_shape)
                    self.var_shape = [UNKNOWN_DIM, ] * var_dims
                    self.var_range = [(1, None)] * var_dims
                elif "const_value" not in self.last_input:
                    self.var_shape = [UNKNOWN_DIM, ] * MAX_DIMS
                    self.var_range = [(1, None)] * MAX_DIMS

                indices_dims = len(self.ori_indices_shape)
                self.indices_shape = [UNKNOWN_DIM, ] * (indices_dims - 1)
                self.indices_shape.append(self.ori_indices_shape[-1])
                self.indices_range = [(1, None)] * indices_dims

                update_dims = len(self.ori_update_shape)
                self.update_shape = [UNKNOWN_DIM, ] * update_dims
                self.update_range = [(1, None)] * update_dims

                if UNKNOWN_RANK in chain(tuple(self.ori_var_shape) + tuple(self.ori_indices_shape) +
                                         tuple(self.ori_update_shape)):
                    self.var_shape = [UNKNOWN_DIM, ] * MAX_DIMS
                    self.var_range = [(1, None)] * MAX_DIMS

                    self.indices_shape = [UNKNOWN_DIM, UNKNOWN_DIM]
                    self.indices_range = [(1, None), (1, None)]

                    self.update_shape = [UNKNOWN_DIM, UNKNOWN_DIM]
                    self.update_range = [(1, None), (1, None)]
        self.scatter_rank = 1 if self.scatter_type == shape_classifier.SCATTER else self.indices_shape[-1]

    def classify(self):
        """
        classify
        :return:
        """
        scatter_instances = []

        self.ori_info_process()
        self.add_compile_info()
        if self.is_zeros_shape or self.is_zeros_range:
            scatter_instances.append(_classify_scatter_zero_shape(self.var_dtype, self.indices_dtype))

        pre_axis_shape = util.combine_dim(self.var_shape[:self.scatter_axis]) if self.scatter_axis != 0 else 1
        pre_axis_range = util.combine_range(self.var_range[:self.scatter_axis]) if self.scatter_axis != 0 else (1, 1)

        rank_range = len(self.var_shape) - self.scatter_axis
        rank_enum = [self.scatter_rank] if self.scatter_rank != -1 else [i for i in range(1, rank_range + 1)]
        for rank in rank_enum:
            scatter_axis_shape = list(self.var_shape[self.scatter_axis:self.scatter_axis + rank])
            scatter_axis_range = list(self.var_range[self.scatter_axis:self.scatter_axis + rank])

            if self.scatter_axis + rank >= len(self.var_shape):
                after_axis_shape = 1
                after_axis_range = (1, 1)
            else:
                after_axis_shape = util.combine_dim(self.var_shape[self.scatter_axis + rank:])
                after_axis_range = util.combine_range(self.var_range[self.scatter_axis + rank:])

            scatter_axis_dims = len(self.indices_shape) - 1
            indices_loop_shape = util.combine_dim(self.indices_shape[:scatter_axis_dims])
            indices_loop_range = util.combine_range(self.indices_range[:scatter_axis_dims])

            update_loop_shape = util.combine_dim(self.update_shape[:scatter_axis_dims])
            update_loop_range = util.combine_range(self.update_range[:scatter_axis_dims])
            if scatter_axis_dims >= len(self.update_shape):
                update_scatter_shape = 1
                update_scatter_range = (1, 1)
            else:
                update_scatter_shape = util.combine_dim(self.update_shape[scatter_axis_dims:])
                update_scatter_range = util.combine_range(self.update_range[scatter_axis_dims:])

            scatter_ins = []

            if self.scatter_axis == 0:
                var_dict = _assemble_dict(
                    [*scatter_axis_shape, after_axis_shape],
                    [*scatter_axis_range, after_axis_range],
                    self.var_dtype)
            else:
                var_dict = _assemble_dict(
                    [pre_axis_shape, *scatter_axis_shape, after_axis_shape],
                    [pre_axis_range, *scatter_axis_range, after_axis_range],
                    self.var_dtype)

            indices_dict = _assemble_dict(
                [indices_loop_shape, rank],
                [indices_loop_range, (rank, rank)],
                self.indices_dtype)

            update_dict = _assemble_dict(
                [update_loop_shape, update_scatter_shape],
                [update_loop_range, update_scatter_range],
                self.var_dtype)

            scatter_ins.append(var_dict)
            scatter_ins.append(indices_dict)
            scatter_ins.append(update_dict)
            scatter_instances.append(scatter_ins)
            scatter_nd_shape = [*scatter_axis_shape, after_axis_shape] if self.is_static else self.ori_var_shape
            operation.get_context().add("_scatter_nd_shape", scatter_nd_shape)
        return scatter_instances

    def _check_zero_shape(self):
        # shape value zero
        for dim_value in chain(list(self.ori_var_shape) + self.ori_indices_shape + self.ori_update_shape):
            if 0 == dim_value:
                self.is_zeros_shape = True
                break

        # range value zero
        if not self.is_zeros_shape:
            for dim_range in chain(list(self.ori_var_range) + self.ori_indices_range + self.ori_update_range):
                if 0 == dim_range[0]:
                    self.is_zeros_range = True
                    break


def _assemble_dict(shape_info, range_info, dtype_info):
    res = {"dtype": dtype_info, "shape": shape_info, "range": range_info}

    return res
