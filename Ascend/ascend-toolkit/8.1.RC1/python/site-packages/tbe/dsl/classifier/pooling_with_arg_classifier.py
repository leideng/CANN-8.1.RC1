#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in pooling
"""
from copy import deepcopy
from functools import reduce
from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.base import operation
from . import shape_classifier

WINDOW_AXES = "WINDOW_AXES"
ATTR_AXES = "ATTR_AXES"
WINDOW_DIMENSIONS = "WINDOW_DIMENSIONS"
WINDOW_STRIDES = "WINDOW_STRIDES"
WINDOW_PADDINGS = "WINDOW_PADDINGS"
WINDOW_DILATIONS = "WINDOW_DILATIONS"
CEIL_MODE = "CEIL_MODE"

BOOL_MAP = {
    "FLOOR": [False, ],
    "CEIL": [True, ],
    "BOTH": [True, False]
}

DTYPE_BYTE_MAPPING = {
    "float16": 2,
    "float32": 4,
}

FORMAT_MAPPING = {
    "NC1HWC0": 0,
    "NDC1HWC0": 1,
    "NCHW": 2,
    "NHWC": 3,
}

N_AXIS = 0
C1_AXIS = 1
KHW_AXIS = 2
FRACTAL_AXIS = 3
FRACTAL_LOWER_AXIS = 4


def _pooling_with_arg_assert(condition: bool, dict_args: dict):
    if not condition:
        raise RuntimeError(dict_args, get_error_message(dict_args))


@shape_classifier.register_classifier(shape_classifier.POOLING_WITH_ARG)
def classify_pooling_with_arg(ins: list, extra_params: dict):
    """
    pooling with arg classify
    :param ins: A list constains tensor
    :param extra_params: A dict contains pooling args
    :return: Standard input
    """
    return PoolingWithArgClassifier(ins, extra_params).classify()


class PoolingWithArgClassifier:
    def __init__(self, ins: list, extra_params: dict):
        """
        :param ins: input list
        :param extra_params: pooling params
        """
        self.input_shape = ins[0].get("shape")
        self.input_dtype = ins[0].get("dtype")
        self.input_format = ins[0].get("format")
        self.window_axes = extra_params.get(WINDOW_AXES)

        self._check_support_format(self.input_format)
        self._check_shape(self.input_shape, self.input_format)
        # inorder to avoid img2col emitinsn constrain, ckhwk must fuse.
        self.input_shape, self.window_axes = self._fuse_axis(self.input_shape, self.input_format, self.window_axes)

        self.attr_axes = extra_params.get(ATTR_AXES)
        self.window_dimensions = self._get_attr_by_axes(extra_params.get(WINDOW_DIMENSIONS), self.attr_axes)
        self.window_strides = self._get_attr_by_axes(extra_params.get(WINDOW_STRIDES), self.attr_axes)
        self.window_dilations = self._get_attr_by_axes(extra_params.get(WINDOW_DILATIONS), self.attr_axes)
        self.window_paddings = self._get_attr_by_axes(extra_params.get(WINDOW_PADDINGS), self.attr_axes)

        self.calculate_mode = self._calculate_mode(extra_params.get(CEIL_MODE))
        operation.get_context().add("_calculate_mode", self.calculate_mode)
        self.is_static = operation.get_op_mode() == "static"

    @staticmethod
    def _check_support_format(input_format: str):
        format_error_info = {"errCode": "E90001", "detailed_cause":
            f"pooling with arg support (5hd, NCHW), format = {input_format}"}
        _pooling_with_arg_assert(input_format in ("NC1HWC0", "NCHW"), format_error_info)

    @staticmethod
    def _check_shape(input_shape: list, input_format: str):
        if input_format == "NC1HWC0":
            input_shape_len = len(input_shape)
            shape_len_error_info = {"errCode": "E90001", "detailed_cause":
                f"pooling with arg only support 5hd format, shape len = {input_shape_len}"}
            _pooling_with_arg_assert(input_shape_len == 5, shape_len_error_info)

            last_dim_value = input_shape[-1]
            last_dim_error_info = {"errCode": "E90001", "detailed_cause":
                f"pooling with arg only support 5hd format, last dim = {last_dim_value}"}
            _pooling_with_arg_assert(last_dim_value == 16, last_dim_error_info)

            for _value in input_shape[:-1]:
                dim_value_error_info = {"errCode": "E90001", "detailed_cause":
                    f"pooling dim value error, _value={_value}"}
                _pooling_with_arg_assert(_value == -1 or _value >= 0, dim_value_error_info)
        else:
            for _value in input_shape:
                dim_value_error_info = {"errCode": "E90001", "detailed_cause":
                    f"pooling dim value error, _value={_value}"}
                _pooling_with_arg_assert(_value == -1 or _value >= 0, dim_value_error_info)

    @staticmethod
    def _fuse_axis(input_shape: list, inpput_format: str, window_axes: list):
        def _fuse_continus_axis(axes):
            if 0 in axes:
                return 0
            elif -1 in axes:
                return -1
            return reduce(lambda a, b: a * b, axes)

        operation.get_context().add("_org_shape", input_shape)
        operation.get_context().add("_org_pooling_axes", window_axes)

        if inpput_format == "NC1HWC0":
            result_shape = list(deepcopy(input_shape))
            result_shape[0] = _fuse_continus_axis(input_shape[:2])
            result_shape[1] = 1
            return tuple(result_shape), window_axes

        # ND format
        result_shape = []
        # last reduce(NCHW)
        result_shape.append(_fuse_continus_axis(input_shape[:window_axes[0]]))
        result_shape.append(input_shape[window_axes[0]])
        result_shape.append(input_shape[window_axes[1]])
        # n last reduce
        if window_axes[-1] + 1 < len(input_shape):
            result_shape.append(_fuse_continus_axis(input_shape[window_axes[-1] + 1:]))
        return tuple(result_shape), (1, 2)

    @staticmethod
    def _check_pooling_axes(window_axes: list):
        window_axes_error_info = {"errCode": "E90001", "detailed_cause":
            f"len(window_axes) != 2, _value = {window_axes}"}
        _pooling_with_arg_assert(len(window_axes) == 2, window_axes_error_info)

    @staticmethod
    def _assign_unknown_value(params: list):
        result = []
        for _value in params:
            if isinstance(_value, list):
                real_value = []
                for _v in _value:
                    tmp_res = _v if _v is not None else -1
                    real_value.append(tmp_res)
                result.append(real_value)
            else:
                real_value = _value if _value is not None else -1
                result.append(real_value)
        return result

    @staticmethod
    def _calculate_mode(input_mode):
        if input_mode is None:
            return "BOTH"
        elif input_mode:
            return "CEIL"
        return "FLOOR"

    @staticmethod
    def _get_attr_by_axes(input_list, attr_axes):
        result = []
        for _idx in attr_axes:
            result.append(input_list[_idx])
        return result

    def classify(self):
        self._store_axis_info_by_format()
        self._check_pooling_params()
        self._store_pooling_params()

        if self.is_static:
            return self.static_classify()
        return self.dynamic_classify()

    def dynamic_classify(self):
        self._norm_dynamic_params()
        result = []
        for _b in BOOL_MAP.get(self.calculate_mode):
            result.append(
                [self.input_shape, self.window_axes, self.window_dimensions, self.window_strides, self.window_paddings,
                 self.window_dilations, _b])
        return result

    def static_classify(self):
        return [[self.input_shape, self.window_axes, self.window_dimensions, self.window_strides, self.window_paddings,
                 self.window_dilations, BOOL_MAP.get(self.calculate_mode)[0]]]

    def _norm_dynamic_params(self):
        self.window_dimensions = self._assign_unknown_value(self.window_dimensions)
        self.window_strides = self._assign_unknown_value(self.window_strides)
        self.window_paddings = self._assign_unknown_value(self.window_paddings)
        self.window_dilations = self._assign_unknown_value(self.window_dilations)

    def _store_axis_info_by_format(self):
        if self.input_format == "NC1HWC0":
            operation.get_context().add("_n_axis", N_AXIS)
            operation.get_context().add("_c1_axis", C1_AXIS)
            operation.get_context().add("_khw_axis", KHW_AXIS)
            operation.get_context().add("_fractal_axis", FRACTAL_AXIS)
            operation.get_context().add("_fractal_lower_axis", FRACTAL_LOWER_AXIS)

    def _check_pooling_params(self):
        self._check_pooling_axes(self.window_axes)

        axes_length = len(self.window_axes)
        pooling_params_check = axes_length == len(self.window_dimensions) \
                               and axes_length == len(self.window_dilations) \
                               and axes_length == len(self.window_strides) \
                               and axes_length == len(self.window_paddings) \
                               and 2 == len(self.window_paddings[0])
        pooling_params_error_info = {"errCode": "E90001",
                                     "detailed_cause": f"pooling params:"
                                                       f"axes_length = {axes_length}"
                                                       f"dimensions = {self.window_dimensions}"
                                                       f"dilations = {self.window_dilations}"
                                                       f"strides = {self.window_strides}"
                                                       f"paddings = {self.window_paddings}"}
        _pooling_with_arg_assert(pooling_params_check, pooling_params_error_info)

    def _store_pooling_params(self):
        operation.get_context().add("_input_dtype", self.input_dtype)
        operation.get_context().add("_input_bytes", DTYPE_BYTE_MAPPING.get(self.input_dtype))
        operation.get_context().add("_input_format", FORMAT_MAPPING.get(self.input_format))
        operation.get_context().add("_pooling_axes", self.window_axes)
        operation.get_context().add("_attr_axes", self.attr_axes)
        operation.get_context().add("_pooling_dimensions", self.window_dimensions)
        operation.get_context().add("_pooling_strides", self.window_strides)
        operation.get_context().add("_pooling_dilations", self.window_dilations)
        operation.get_context().add("_pooling_pads", self.window_paddings)
