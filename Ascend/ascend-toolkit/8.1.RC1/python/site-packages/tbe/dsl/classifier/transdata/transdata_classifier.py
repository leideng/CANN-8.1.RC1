#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
TransdataClassify
"""
import copy
from abc import ABC
from abc import abstractmethod
from typing import Any, Dict, Optional

from tbe.dsl.base import operation
from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.classifier.transdata.constants import intrinsic_check_support

from .constants import B32
from .constants import B64
from .constants import DO_NOTHING
from .constants import DO_PAD
from .constants import DO_TRANSPOSE_PAD
from .constants import DATA_TYPE_SIZE
from .constants import REINTERPRET_TYPE
from .constants import UNKNOWN_DIM
from .constants import STRIDE_16

from .util import math_prod
from .util import set_align
from .util import pad_refined
from .transdata_rule import TransdataUserRule
from .. import shape_classifier

_classifies = {}


@shape_classifier.register_classifier(shape_classifier.TRANSDATA)
def classify(ins: list, extra_params: Optional[Dict[str, Any]]):
    dst_shape = ins[1].get("shape", None)
    src_shape = ins[0].get("shape", None)
    if len(src_shape) != len(dst_shape):
        category = "forward" if len(src_shape) < len(dst_shape) else "backward"
    else:
        src_format = ins[0].get("format", None)
        dst_format = ins[1].get("format", None)
        if src_format == "FRACTAL_Z_C04":
            category = "c04.backward"
        elif dst_format == "FRACTAL_Z_C04":
            category = "c04.forward"
        else:
            dict_args = {"errCode": "E80001",
                     "detailed_cause": "Pad or DePad is required in transdata,"
                                       "but length of src is equal to dst or the transdata is not C04" }
            raise RuntimeError(dict_args, get_error_message(dict_args))


    return _classifies.get(category)(ins).classify()


class TransdataClassify(ABC):
    """
    TransdataClassify
    """

    def __init__(self, ins):
        # base-info
        self._ins = copy.deepcopy(ins)
        self._axes_map = self._ins[2]
        self._dst_shape = self._ins[1].get("shape", None)
        self._src_shape = self._ins[0].get("shape", None)
        self._dst_format = self._ins[1].get("format", None)
        self._src_format = self._ins[0].get("format", None)
        self._dtype = self._ins[0].get("dtype", None)

        # other-info
        self.is_borrow = False
        self.borrow_choose = []
        self.index_c = None
        self.is_forward = True if self.get_category().find("forward") != -1 else False

        # pad-info
        self.src_pad_mode = []
        self.src_pad_var = []

        # transpose-info
        self.src, self.dst = [], []
        self.pad, self.de_pad = [], []
        self.combine = None

        # reinterpret
        self.block = int(get_soc_spec("ubblock_size"))
        self.soc_ub_size = get_soc_spec("UB_SIZE")
        self.ori_bit = DATA_TYPE_SIZE.get(self._dtype, None)
        self.block_size = self.block // self.ori_bit

        self.bit = self.ori_bit
        if self.bit in [B32, B64]:
            self.bit = DATA_TYPE_SIZE.get(REINTERPRET_TYPE.get(self._dtype, None), None)

        self.borrow_factor = self.block // self.bit
        if self.borrow_factor < STRIDE_16:
            self.borrow_factor = STRIDE_16

        # transdata dynamic compile check(FZ is special in dynamic)
        operation.get_context().add("_transdata_format", [self._src_format, self._dst_format])
        if not input_is_const(self._src_shape) or not input_is_const(self._dst_shape):
            _check = [4 if self._src_format == "FRACTAL_Z" else len(self._src_shape),
                      4 if self._dst_format == "FRACTAL_Z" else len(self._dst_shape), ]
            operation.get_context().add("_transdata_check", _check)
        else:
            operation.get_context().add("_transdata_check", [0, 0])

    def __init_subclass__(cls, **kwargs):
        _classifies[cls.get_category()] = cls

    @classmethod
    @abstractmethod
    def get_category(cls):
        """"""

    @abstractmethod
    def classify(self):
        """"""

    def add_const_compile_info(self, shape, _shape, axes_map):
        """
        Const's input from Classify would be tiling's input.
        Func make const-shape matched with compileInfo.
        """
        src_pad_mode, src_pad_var, permute = [], [], []
        index = 0 if not self.is_forward else 1
        for var in axes_map.items():
            if isinstance(var[index], int):
                src_pad_mode.append(DO_NOTHING)
                src_pad_var.append(1)
                permute.append(var[index])
            elif isinstance(var[index], (list, tuple)) and len(var[index]) == 1:
                src_pad_mode.append(DO_PAD)
                src_pad_var.append(pad_refined(shape[var[index][0]], _shape[var[index - 1]]))
                permute.extend(var[index])
            else:
                src_pad_mode.append(DO_TRANSPOSE_PAD)
                src_pad_var.append(pad_refined(shape[var[index][-1]], _shape[var[index - 1]]))
                permute.extend(var[index])

        operation.add_compile_info_inner("_src_pad_mode", src_pad_mode)
        operation.add_compile_info_inner("_src_pad_var", src_pad_var)
        operation.add_compile_info_inner("_permute", permute)

    def add_dynamic_compile_info(self, src_fuse, permute, shape, _shape):
        """
        Convert origin compileInfo that from use-defined to tiling.
        """
        index = 0 if not self.is_forward else 1
        for var in self._axes_map.items():
            if isinstance(var[index], int):
                self.src_pad_mode.append(DO_NOTHING)
                self.src_pad_var.append(1)
            elif isinstance(var[index], (list, tuple)) and len(var[index]) == 1:
                self.src_pad_mode.append(DO_PAD)
                self.src_pad_var.append(pad_refined(shape[var[index][0]], _shape[var[index - 1]]))
            else:
                self.src_pad_mode.append(DO_TRANSPOSE_PAD)
                self.src_pad_var.append(pad_refined(shape[var[index][-1]], _shape[var[index - 1]]))
                self.index_c = len(self.src_pad_mode) - 1

        operation.add_compile_info_inner("_src_pad_mode", self.src_pad_mode)
        operation.add_compile_info_inner("_src_pad_var", self.src_pad_var)
        operation.add_compile_info_inner("_permute", permute)
        operation.add_compile_info_inner("_src_fuse", src_fuse)

        # Globally unique
        operation.add_compile_info_inner("_is_ori_last_transpose", int(permute[-1] != len(permute) - 1))

    def reinterpret_axes_map(self, src_shape, dst_shape, axes_map):
        """
        Reinterpret: make last-transpose + b32 to b16.
        """
        pack_var = self.ori_bit // self.bit
        if not self.is_forward:
            src_shape, dst_shape = dst_shape, src_shape
            axes_map = dict([tuple(val) if isinstance(val, list) else val, key] for key, val in axes_map.items())

        # NCH -> NCH2, NHC -> NHC2, NC1HC0 -> NC1HC02
        src_shape.append(pack_var)
        dst_shape.append(pack_var)
        axes_map.update({len(src_shape) - 1: len(dst_shape) - 1})

        if not self.is_forward:
            src_shape, dst_shape = dst_shape, src_shape
            axes_map = dict([tuple(val) if isinstance(val, list) else val, key] for key, val in axes_map.items())
        return src_shape, dst_shape, axes_map

    def create_base_result(self, category):
        """
        Return BaseSch Result
        """
        self._ins[0]["bit"] = self.ori_bit
        self._ins[0]["ori_bit"] = self.ori_bit
        self._ins[0]["shape"] = self._src_shape
        self._ins[0]["range"] = [[1, None] if x == UNKNOWN_DIM else [x, x] for x in self._src_shape]
        self._ins[0]["is_forward"] = self.is_forward
        self._ins[0]["transdata_category"] = category
        self._ins[0]["borrow_idx"] = None
        self._ins[1] = self._dst_shape
        self._ins[2] = self._axes_map
        return self._ins

    def create_bn_bh_result(self, category):
        """
        Return BN\BH SCH Result
        BN: borrow normal axis that do not transpose.
        BH: borrow transpose axis that do transpose.
        """
        src_shape = self._src_shape.copy()
        dst_shape = self._dst_shape.copy()
        axes_map = self._axes_map.copy()
        dtype = self._dtype
        is_reinterpret = self.ori_bit != self.bit

        if is_reinterpret:
            dtype = REINTERPRET_TYPE.get(dtype, None)
            src_shape, dst_shape, axes_map = self.reinterpret_axes_map(src_shape, dst_shape, axes_map)
        return self.create_new_ins([src_shape, dst_shape], axes_map, dtype, category)

    def create_data_move_result(self, category, perm, is_const=False):
        """
        Return DataMove Result:
        1. data-move work in dynamic(const had already supported).
        2. [M,C0] -> [C0,M], M should be assumed as 1.
        3. [M,N] -> [N,M], M should be assumed as 1.
        4. pure-dma = transpose-not-work.
        5. only-last-transpose, care about last-dim is 1.
        """
        dst_shape = self._src_shape.copy()
        src_shape = self._src_shape.copy()
        if not self.is_forward:
            dst_shape = self._dst_shape.copy()
            src_shape = self._dst_shape.copy()

        src_pad_mode = self.src_pad_mode.copy()
        src_pad_var = self.src_pad_var.copy()
        if perm.index(len(perm) - 1) != len(perm) - 1:
            src_pad_mode = self.src_pad_mode[:-1]
            src_pad_var = self.src_pad_var[:-1]
            dst_shape = dst_shape[:-1]
            src_shape = src_shape[:-1]

        if DO_TRANSPOSE_PAD in src_pad_mode:
            src_pad_mode[src_pad_mode.index(DO_TRANSPOSE_PAD)] = DO_PAD

        if is_const:
            _input = src_shape if self.is_forward else dst_shape
            _output = dst_shape if self.is_forward else src_shape
            for k, v in enumerate(_input):
                _output[k] = set_align(v, src_pad_var[k])

        operation.add_compile_info_inner("_data_move_src_pad_mode", src_pad_mode)
        operation.add_compile_info_inner("_data_move_src_pad_var", src_pad_var)
        operation.add_compile_info_inner("_data_move_permute", list(range(len(src_pad_var))))

        axes_map = dict([(k, (k,)) if v == 1 else (k, k) for k, v in enumerate(src_pad_mode)])
        if not self.is_forward:
            axes_map = dict([((k,), k) if v == 1 else (k, k) for k, v in enumerate(src_pad_mode)])
        return self.create_new_ins([src_shape, dst_shape], axes_map, self._dtype, [None, category])

    def create_remove_size_one_axis_result(self, category):
        """
        Return remove nopad dim result:
        1. remove_size_one_axis work in dynamic(const had already supported).
        2. if the dim is nopad type and equal to one in transfer, remove it
        3. eg: NCHW<--->FRACTAL_Z(C1HWN1N0C0), in this transfer HW do not pad or depad,
           we will generate a tilingkey to support it, and determine whether to choose it or not in optiling.
           if in runtime shape HW is equal to 1, we will choose it, otherwise, it is not selected.
        """
        axis_map, new_map = {}, {}
        src_list = []
        dst_list = []
        src_shape = list(copy.deepcopy(self._src_shape))
        dst_shape = list(copy.deepcopy(self._dst_shape))
        # remove no pad and depad dim whose dim size equal to one
        for k, v in self._axes_map.items():
            # if key and value are both int type remove it
            if isinstance(k, int) and isinstance(v, int):
                del src_shape[k]
                del dst_shape[v]
            else:
                if isinstance(k, int) and isinstance(v, (tuple, list)):
                    src_list.append(k)
                    dst_list.extend(v)
                elif isinstance(v, int) and isinstance(k, (tuple, list)):
                    src_list.extend(k)
                    dst_list.append(v)
                else :
                    dict_args = {"errCode": "E80001",
                         "detailed_caused": f"invalid axis map item k[{type(k)}] v[{type(v)}]"}
                    raise RuntimeError(dict_args, get_error_message(dict_args))
                axis_map[k] = v
        sorted_src_dst_lists = [sorted(src_list), sorted(dst_list)]
        # update axis_map
        index = 1 if not self.is_forward else 0
        for item in axis_map.items():
            private_idx = []
            external_idx = []
            for idx in item[1 - index]:
                private_idx.append(sorted_src_dst_lists[1 - index].index(idx))
            external_idx = sorted_src_dst_lists[index].index(item[index])
            new_item = [external_idx, tuple(private_idx)]
            new_map[new_item[index]] = new_item[1 - index]
        self.set_remove_size_one_axis_compile_info(category, new_map, src_shape, dst_shape)
        return self.create_new_ins((src_shape, dst_shape), new_map, self._dtype, [None, category])

    def set_remove_size_one_axis_compile_info(self, category, axis_map, src_shape, dst_shape):
        """
        Set Remove onpad dim result compile info
        Generate new pad mode, pad var and permute
        """
        remove_size_one_axis_src_pad_mode = []
        remove_size_one_axis_src_pad_var = []
        remove_size_one_axis_permute = []
        index = 1
        if not self.is_forward:
            index = 0
            src_shape, dst_shape = dst_shape, src_shape
        for var in axis_map.items():
            remove_size_one_axis_permute.extend(var[index])
            if isinstance(var[index], (list, tuple)) and len(var[index]) == 1:
                remove_size_one_axis_src_pad_mode.append(DO_PAD)
                remove_size_one_axis_src_pad_var.append(pad_refined(dst_shape[var[index][0]],
                                                                    src_shape[var[index - 1]]))
            else:
                remove_size_one_axis_src_pad_mode.append(DO_TRANSPOSE_PAD)
                remove_size_one_axis_src_pad_var.append(pad_refined(dst_shape[var[index][-1]],
                                                                    src_shape[var[index - 1]]))

        if self.is_forward:
            remove_size_one_axis_permute = \
            [remove_size_one_axis_permute.index(i) for i in sorted(remove_size_one_axis_permute)]
        operation.add_compile_info_inner("_remove_size_one_axis_src_pad_mode", remove_size_one_axis_src_pad_mode)
        operation.add_compile_info_inner("_remove_size_one_axis_src_pad_var", remove_size_one_axis_src_pad_var)
        operation.add_compile_info_inner("_remove_size_one_axis_permute", remove_size_one_axis_permute)

    def create_new_ins(self, shapes, axes_map, dtype, category):
        # new-ins
        src_shape, dst_shape = shapes
        ins = copy.deepcopy(self._ins)
        ins[0]["bit"] = self.bit if category[1].find("borrow") != -1 else self.ori_bit
        ins[0]["ori_bit"] = self.ori_bit
        ins[0]["shape"] = src_shape
        ins[0]["dtype"] = dtype
        ins[0]["range"] = [[1, None] if x == UNKNOWN_DIM else [x, x] for x in src_shape]
        ins[0]["is_forward"] = self.is_forward
        ins[0]["transdata_category"] = category[1]
        ins[0]["borrow_idx"] = category[0]
        ins[1] = dst_shape
        ins[2] = axes_map
        return ins
     
    def const_strategy(self):
        """
        Decide which axes be borrowed is best(NHC|NCH).
        """
        num = 1
        buffer, target = 0, 0
        total = self.soc_ub_size // self.ori_bit // 2
        shape = self._src_shape if self.is_forward else self._dst_shape

        for k in reversed(range(len(shape))):
            v = shape[k]
            if k not in [self.index_c, len(shape) - 1]:
                if v >= self.borrow_factor:
                    used = v // self.borrow_factor * self.borrow_factor * num
                    if used >= total:
                        used = total
                else:
                    used = v * num
                    if used >= total // self.borrow_factor * v:
                        used = total // self.borrow_factor * v

                if used > buffer:
                    target = k
                    buffer = used
            num *= v
        return target

    def is_const_data_move(self, shape, perm):
        """
        :param shape: shape is out, Backward: shape is input
        :param perm: permute
        :return: data-move or not
        """
        _perm = []
        transpose_shape = shape if self.is_forward else [shape[i] for i in perm]
        for i, v in enumerate(transpose_shape):
            if v != 1:
                _perm.append(perm[i])
        i = 0
        while i < len(_perm) - 1:
            if _perm[i] > _perm[i + 1]:
                return False
            i += 1
        return True

    def comm_borrow_choose(self, is_last_transpose, shape, is_const=False):
        """
        Which axes could be borrowed by common-rule.
        :param is_last_transpose: transpose mode.
        :param shape: input(forward), output(backward).
        :param is_const: const or not.
        :return: candidates that axes can be borrowed.
        """
        self.is_borrow = True
        if is_last_transpose:
            self.is_borrow = self.ori_bit != self.bit
            if intrinsic_check_support():
                self.is_borrow = False
        else:
            if is_const:
                limit = 1024 if self.is_forward else 128
                self.is_borrow = shape[-1] % self.block_size != 0 and shape[-1] <= limit

        if not self.is_borrow:
            return

        self.borrow_choose = list(range(self.index_c))
        if self.index_c != len(self.src_pad_mode) - 1:
            self.borrow_choose.append(self.index_c)

        if is_const:
            out = []
            for i in self.borrow_choose:
                xi = 1 if shape[i] <= self.borrow_factor else shape[i] // self.borrow_factor
                num = 1 if i + 1 >= len(shape) else math_prod(shape[i + 1:])
                burst_len = num * xi
                if burst_len < self.block_size:
                    continue
                out.append(i)
            self.borrow_choose = out

    def user_borrow_choose(self, shape, perm, is_const=True):
        """
        Choose axes that decided by user-defined.
        :param shape: input(forward), output(backward).
        :param perm: dst(forward), src(backward).
        :param is_const: const or not.
        :return: candidates that axes can be borrowed.
        """
        if not self.is_borrow:
            return

        attrs = [is_const, self.ori_bit, self.bit]
        formats = [self._src_format, self._dst_format]
        shapes = [shape, perm, self.src_pad_var, self.index_c]
        self.borrow_choose = TransdataUserRule(self.borrow_choose, formats, shapes, attrs).ruling()

        if not self.borrow_choose:
            self.is_borrow = False
            return

        if len(self.borrow_choose) > 1 and is_const:
            idx = self.const_strategy()
            self.borrow_choose = {idx: self.borrow_choose.get(idx, None)}

        if not self.is_forward:
            keys = self.borrow_choose.keys()
            values = self.borrow_choose.values()
            self.borrow_choose = dict(zip([perm.index(k) for k in keys], values))


def eliminate_one(src_shape, dst_shape, src, dst, pad):
    # 1. Only work in Const (Don't do infer shape).
    # 2. Pad axis can not do eliminate.
    # 3. Template is forward.
    if not input_is_const(src_shape) or not input_is_const(dst_shape):
        src_shape = [UNKNOWN_DIM] * len(src_shape)
        _dst_shape = [UNKNOWN_DIM] * len(dst_shape)
        _dst_shape[-1] = dst_shape[-1]
        return [src_shape, _dst_shape, src, dst, pad]

    n_src, n_dst, n_pad = [], [], []
    for k, v in enumerate(src):
        if src_shape[v] == 1 and not pad[k]:
            continue
        n_pad.append(pad[k])
        n_src.append(v)
        n_dst.append(dst[k])

    back = sorted(n_dst)
    dst = [back.index(x) for x in n_dst]
    dst_shape = [dst_shape[x] for x in back]

    pad = n_pad
    src_shape = [src_shape[x] for x in set(n_src)]

    num = 0
    src = []
    for k, i in enumerate(n_src):
        if k == 0:
            src.append(num)
            num += 1
            continue

        if n_src[k - 1] == i:
            src.append(num - 1)
            continue

        src.append(num)
        num += 1

    return [src_shape, dst_shape, src, dst, pad]


def input_is_const(shape):
    return UNKNOWN_DIM not in shape
