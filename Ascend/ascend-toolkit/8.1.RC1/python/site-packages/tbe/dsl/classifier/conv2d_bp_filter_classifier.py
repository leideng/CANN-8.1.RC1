#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
classifier of shape in conv2d_backprop_filter
"""

import copy
from itertools import product

from tbe.common import platform as tbe_platform
from tbe.common.utils import log
from tbe.common.utils.conv_util import CubeConstantConfig
from tbe.common.utils.errormgr import error_manager_util
from tbe.dsl.base.operation import get_op_context
from tbe.dsl.base.operation import is_unify
from tbe.dsl.compute.cube_util import Load3DParam
from tbe.dsl.compute.cube_util import is_exceed_l1_for_load3d
from tbe.dsl.compute.cube_util import is_load3d_constraint

from . import shape_classifier
from .conv_bp_filter_base import ComputeTemplate
from .conv_bp_filter_base import ConvBpFilterBase
from .util import LoadModeType


@shape_classifier.register_classifier(shape_classifier.CONV2D_BP_FILTER)
def classify(ins: list, extra_params: dict):
    """
    classify
    :param ins: input list, includes input_list, attr_list, option_list
    :param extra_params: useless in conv2d_backprop_filter
    :return: ins of list after the classification function
    """
    # 1 Define classifer
    classifier = Conv2dBpFilterClassifier(ins, CubeConstantConfig.CONV2D_BACKPROP_FILTER_OP_NAME, True, extra_params)
    # 2 format source input
    classifier.format_shape_and_range()
    # 3 return all situation inputs for compute
    return classifier.classify()


class Conv2dBpFilterClassifier(ConvBpFilterBase):
    """
    conv2dbpfilter classifier
    """

    def __init__(self, ins, op_name, fusion_mode, extra_params):
        """
        init
        :param ins: [input_list, attr_list, option_list]
            input_list: [x, filter_size, out_backprop, y]
            attr_list: single op mode, is [strides, pads, dilations, groups, data_format, kernel_name]
                       fusion mode, is [{"val": [strides, pads, dilations, groups, data_format], "name": kernel_name},]
            option_list: [{"name": op_name, "options": {}}, {}]
        :param extra_params: useless in conv2d_backprop_filter
        """
        self.ins = ins
        self.input_list, self.attr_list, self.option_list = self.ins
        self.extra_params = extra_params
        self._init_inputs_in_fusion_mode()
        self._init_attr_in_fusion_mode()

        inputs_list = self.input_list + self.attr_list
        super().__init__(inputs_list, op_name, fusion_mode)

        self.load_mode_list = []
        self.strideh_read_list = []
        self.linear_embedding_opti_list = []

        self.op_name_in_fusion_mode = None
        self.idx_in_fusion_options = -1
        self._init_fusion_info()

        self.ct = ComputeTemplate()

    @staticmethod
    def _is_legal_range(attr_list, lower_limit, upper_limit):
        for attr in attr_list:
            if not isinstance(attr, int) or attr < lower_limit or attr > upper_limit:
                return False
        return True

    @staticmethod
    def _is_invalid_choice(choice):
        load_mode, strideh_read, linear_embedding_opti = choice
        # strideh_read needs to rely on the load3d instruction
        if strideh_read == 1 and load_mode in [LoadModeType.LOAD2D, LoadModeType.DMA_CPY]:
            return True
        # linear_embedding_opti need to rely on the DMA_CPY
        if linear_embedding_opti and load_mode != LoadModeType.DMA_CPY:
            return True
        if linear_embedding_opti and strideh_read == 1:
            return True
        if linear_embedding_opti and not tbe_platform.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out"):
            return True
        return False

    def classify(self):
        """
        Construct multiple inputs based on load_mode conditions
        """
        if get_op_context().get_addition("is_dynamic_constantization") or not is_unify():
            self._determine_classification_const()
            tmp_ins = list(copy.deepcopy(self.ins))
            cur_option = {"options": {"compute_template": self.ct}}
            tmp_ins[2] = [cur_option]  # ins struct is [input_list, attr_list, option_list]
            return [tmp_ins]

        self._determine_classification_dynamic()
        outs = []
        choice_list = list(product(self.load_mode_list, self.strideh_read_list, self.linear_embedding_opti_list))
        for choice in choice_list:
            if self._is_invalid_choice(choice):
                continue
            load_mode, strideh_read, linear_embedding_opti = choice
            ct = ComputeTemplate()
            ct.flag_all_one_case = load_mode == LoadModeType.LOAD2D
            ct.flag_load3d_w_split_case = load_mode == LoadModeType.W_SPLIT_LOAD3D
            ct.l0b_dma_flag = load_mode == LoadModeType.DMA_CPY
            ct.strideh_read_flag = strideh_read
            ct.load_mode = load_mode
            ct.linear_embedding_opti_flag = linear_embedding_opti
            log.debug("[ComputeTemplate] {}".format(ct.get_debug_info()))

            tmp_ins = list(copy.deepcopy(self.ins))
            _, _, option_list = tmp_ins
            # option struct is [{"name": op_x, "options": {}}, {"name": op_y, "options": {}}]
            cur_option = {"name": self.op_name_in_fusion_mode, "options": {"compute_template": ct}}
            if option_list:
                conv_idx = self.idx_in_fusion_options
                if conv_idx != -1:
                    option_para = option_list[conv_idx].get("options")
                    if option_para:
                        option_list[conv_idx]["options"]["compute_template"] = ct
                    else:
                        option_list[conv_idx]["options"] = cur_option
                else:
                    option_list.append(cur_option)
            else:
                # in single op mode, option_list is empty
                tmp_ins[2] = [cur_option]

            outs.append(tuple(tmp_ins))
        return outs

    def _determine_compute_template(self):
        """
        flags has dependence each other, so keep order
        c04_flag: independent
        conv1d_flag: independent
        flag_all_one_case: depend conv1d_flag
        flag_load3d_w_split_case: depend all above
        l0b_dma_flag: depend all above
        linear_embedding_opti: depend flag_load3d_w_split_case, l0b_dma_flag
        load_mode: depend flag_all_one_case, flag_load3d_w_split_case, l0b_dma_flag
        strideh_read_flag: depend c04_flag, load_mode
        flag_load3d_special_case: depend load_mode
        """
        self.ct.c04_flag = self._is_c04_mode()
        self.ct.conv1d_flag = self._is_conv1d()
        self.ct.flag_all_one_case = self._is_load2d_mode()
        self.ct.flag_load3d_w_split_case = self._is_load3d_w_split_mode()
        self.ct.l0b_dma_flag = self._is_l0b_dma_mode()
        self.ct.linear_embedding_opti_flag = self._is_linear_embedding_opti_mode()
        self.ct.load_mode = self._get_load_mode()
        self.ct.strideh_read_flag = int(self.ct.load_mode in [LoadModeType.LOAD3D, LoadModeType.W_SPLIT_LOAD3D]
                                        and self._is_stride_h_read())
        self.ct.flag_load3d_special_case = (self._is_constraint_case_for_load3d()
                                            and self.ct.load_mode == LoadModeType.LOAD3D)
        if self._is_exceed_l1_final():
            dict_args = {}
            dict_args["errCode"] = "E60026"
            error_manager_util.raise_runtime_error(dict_args)

    def _init_inputs_in_fusion_mode(self):
        # in fusion mode, inputs from tefusion like that : [{"name": "x", "shape": [1,3,4,5], ...}, ...]
        if self.input_list[0].get("name") not in ["x", "filter_size", "out_backprop", "y"]:
            return

        inputs_dict = {i.get("name"): i for i in self.input_list}
        self.input_list = [
            inputs_dict.get("x"),
            inputs_dict.get("filter_size"),
            inputs_dict.get("out_backprop"),
            inputs_dict.get("y")
        ]

    def _init_attr_in_fusion_mode(self):
        # in fusion mode, attrs from tefusion like that : [{"val": [strides, pads, ...], "name": kernel_name}, ...]
        if not isinstance(self.attr_list[0], dict):
            return
        for attr in self.attr_list:
            if "name" in attr and "conv" in attr.get("name").lower():
                self.attr_list = attr.get("val") + [attr.get("name")]
                return

    def _init_fusion_info(self):
        for idx, option in enumerate(self.option_list):
            if "name" in option and "conv" in option.get("name").lower():
                self.op_name_in_fusion_mode = option.get("name")
                self.idx_in_fusion_options = idx
                return

    def _get_load_mode(self):
        if self.ct.flag_all_one_case:
            return LoadModeType.LOAD2D
        if self.ct.flag_load3d_w_split_case:
            return LoadModeType.W_SPLIT_LOAD3D
        if self.ct.l0b_dma_flag:
            return LoadModeType.DMA_CPY
        return LoadModeType.LOAD3D

    def _get_param_of_l1_check(self):
        return {
            "stride": self.strides.strides,
            "dilation": [self.dilations.dilation_h, self.dilations.dilation_w],
            "weight_shape": [self.kernel.kernel_h, self.kernel.kernel_w],
            "width_grads": self.grads.grads_w,
            "width_fmap": self.fm.fmap_w,
            "input_dtype": self.fm.dtype
        }

    def _is_stride_h_read(self):
        if self.ct.c04_flag or self.ct.flag_all_one_case or self.ct.conv1d_flag:
            return False

        return (self.pads.pad_u == 0 and self.pads.pad_d == 0 and
                self.kernel.kernel_h == 1 and self.strides.stride_h > 1)

    def _is_load2d_mode(self):
        """
        The reading of fmap from L1 to L0B uses load2d,
        The conditions for enabling this feature for static scenes are:
            1. height & weight of filter are all 1
            2. strides is [1,1]
            3. pads is [0,0,0,0]
            4. input is not fp32
        """
        if self.fm.dtype == 'float32' or self.ct.conv1d_flag:
            return False

        should_be_one_list = [self.strides.stride_h, self.strides.stride_w, self.kernel.kernel_h, self.kernel.kernel_w]
        return all(x == 1 for x in should_be_one_list) and all(x == 0 for x in self.pads.pads)

    def _is_conv1d(self):
        """
        conv1d situation, all params in h is 1, support w be in [1,2**31 - 1]
        The conditions for enabling this feature for static scenes are:
            1. fmap_height_after_pad = 1
            2. kernel_height = 1
        """
        fmap_h_paded = self.fm.fmap_h + self.pads.pad_u + self.pads.pad_d
        fmap_w_paded = self.fm.fmap_w + self.pads.pad_l + self.pads.pad_r

        is_exceed_l1 = is_exceed_l1_for_load3d(self._get_param_of_l1_check(),
                                               is_conv1d=True,
                                               is_strideh_read=False,
                                               is_c04=self.ct.c04_flag,
                                               is_load3d_w_split=False)
        if is_exceed_l1:
            return False

        if not all([
                self._is_legal_range([self.kernel.kernel_h, self.kernel.kernel_w], Load3DParam.filter_min(),
                                     Load3DParam.filter_max()),
                self._is_legal_range(self.strides.strides, Load3DParam.stride_min(), Load3DParam.stride_max()),
                self._is_legal_range(self.pads.pads, Load3DParam.pad_min(), Load3DParam.pad_max()),
                self._is_legal_range([self.dilations.dilation_h, self.dilations.dilation_w], Load3DParam.dilation_min(),
                                     Load3DParam.dilation_max())
        ]):
            return False

        return ((fmap_h_paded == 1 and self.kernel.kernel_h == 1) and (fmap_w_paded != 1 or self.kernel.kernel_w != 1))

    def _is_c04_mode(self):
        return self.kernel.format == "FRACTAL_Z_C04"

    def _is_constraint_case_for_load3d(self):
        """
        Limitations on some chips, wo=1 needs to be extended to 2 to calculate
        The conditions for enabling this feature for static scenes are:
            1. ho != 1 and wo ==1
            2. current platform is load3d_constraints
        """
        return (is_load3d_constraint() and self.grads.grads_h != 1 and self.grads.grads_w == 1)

    def _is_load3d_w_split_mode(self):
        """
        The reading of fmap from L1 to L0B uses load3d_w_split,
        The conditions for enabling this feature for static scenes are:
            1. The minimum L1 check for normal scenarios is not met
            2. not exceed L1 for load3d_w_split scenarios
            3. kh/kw in [1, 255] or [1, 511](milan platform)
            4. stride in [1, 63]
            5. pad in [0, 255]
        """
        if (self.ct.conv1d_flag or self._is_constraint_case_for_load3d()
                or self.ct.c04_flag):
            return False

        if not all([
                self._is_legal_range([self.kernel.kernel_h, self.kernel.kernel_w], Load3DParam.filter_min(),
                                     Load3DParam.filter_max()),
                self._is_legal_range(self.strides.strides, Load3DParam.stride_min(), Load3DParam.stride_max()),
                self._is_legal_range(self.pads.pads, Load3DParam.pad_min(), Load3DParam.pad_max()),
                self._is_legal_range([self.dilations.dilation_h, self.dilations.dilation_w], Load3DParam.dilation_min(),
                                     Load3DParam.dilation_max())
        ]):
            return False

        is_exceed_l1_no_w_split = is_exceed_l1_for_load3d(self._get_param_of_l1_check(),
                                                                    is_conv1d=self.ct.conv1d_flag,
                                                                    is_strideh_read=self._is_stride_h_read(),
                                                                    is_c04=self.ct.c04_flag,
                                                                    is_load3d_w_split=False)
        if not is_exceed_l1_no_w_split:
            return False

        # Load2D exceeds L1 limit, need to turn off Load2D
        self.ct.flag_all_one_case = False
        is_exceed_l1_with_w_split = is_exceed_l1_for_load3d(self._get_param_of_l1_check(),
                                                                      is_conv1d=self.ct.conv1d_flag,
                                                                      is_strideh_read=self._is_stride_h_read(),
                                                                      is_c04=self.ct.c04_flag,
                                                                      is_load3d_w_split=True)
        return not is_exceed_l1_with_w_split

    def _is_l0b_dma_mode(self):
        """
        over-spec scene, replace load_3d with dma_copy
        support scene:
            1. not transdata fusion
            2. w cannot split
            3. not c04
        ----------
        following scene will choose dma mode:
            1. over l1 buffer
            2. kernel > 255
            3. stride > 63
            4. pad > 255
            5. load3d_special_case and w_after_pad > 63
        """
        if (self.fm.tag == "NHWC_trans_5HD" or self.ct.flag_load3d_w_split_case or
                self.ct.c04_flag):
            return False

        is_exceed_l1 = is_exceed_l1_for_load3d(self._get_param_of_l1_check(),
                                                         is_conv1d=self.ct.conv1d_flag,
                                                         is_strideh_read=self._is_stride_h_read(),
                                                         is_c04=self.ct.c04_flag,
                                                         is_load3d_w_split=self.ct.flag_load3d_w_split_case)
        fmap_w_paded = self.fm.fmap_w + self.pads.pad_l + self.pads.pad_r
        is_special_case = self._is_constraint_case_for_load3d() and fmap_w_paded > Load3DParam.stride_max()
        if is_exceed_l1 or is_special_case:
            return True

        return not all([
            self._is_legal_range([self.kernel.kernel_h, self.kernel.kernel_w], Load3DParam.filter_min(),
                                 Load3DParam.filter_max()),
            self._is_legal_range(self.strides.strides, Load3DParam.stride_min(), Load3DParam.stride_max()),
            self._is_legal_range(self.pads.pads, Load3DParam.pad_min(), Load3DParam.pad_max()),
            self._is_legal_range([self.dilations.dilation_h, self.dilations.dilation_w], Load3DParam.dilation_min(),
                                 Load3DParam.dilation_max())
        ])

    def _is_linear_embedding_opti_mode(self):
        '''
        Scenes that use convolution for linear embedding can be optimized by special optimization
        following scene will choose dma mode:
           1. dilation = [1, 1, 1, 1]
           2. pad = [0, 0, 0, 0]
           3. kernel = stride
           4. input = output * stride
        '''
        case_conditon = (all(x == 1 for x in self.dilations.dilations) and all(x == 0 for x in self.pads.pads)
                         and self.kernel.kernel_h == self.strides.stride_h
                         and self.kernel.kernel_w == self.strides.stride_w
                         and self.fm.fmap_w == self.grads.grads_w * self.strides.stride_w
                         and self.fm.fmap_h == self.grads.grads_h * self.strides.stride_h)

        case_white_list = (self.kernel.kernel_w == 32 and self.kernel.kernel_h == 32
                           and self.fm.fmap_h == 224 and
                           self.fm.fmap_w == 224 and self.fm.fmap_c == 3)

        dma_flag = (self.ct.flag_load3d_w_split_case and case_conditon and case_white_list and
                    tbe_platform.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out"))
        if dma_flag:
            self.ct.flag_load3d_w_split_case = False
            self.ct.l0b_dma_flag = True
            return True
        return False

    def _is_exceed_l1_final(self):
        if self.ct.flag_load3d_w_split_case or self.ct.l0b_dma_flag:
            return False

        return is_exceed_l1_for_load3d(self._get_param_of_l1_check(),
                                                 is_conv1d=self.ct.conv1d_flag,
                                                 is_strideh_read=self._is_stride_h_read(),
                                                 is_c04=self.ct.c04_flag,
                                                 is_load3d_w_split=self.ct.flag_load3d_w_split_case)

    def _determine_classification_const(self):
        self._determine_compute_template()
        log.debug("[ComputeTemplate] {}".format(self.ct.get_debug_info()))

    def _determine_classification_dynamic(self):
        if self.fm.dtype == 'float32':
            self.load_mode_list = [LoadModeType.LOAD3D, LoadModeType.W_SPLIT_LOAD3D, LoadModeType.DMA_CPY]
        else:
            self.load_mode_list = [LoadModeType.LOAD3D, LoadModeType.LOAD2D, LoadModeType.W_SPLIT_LOAD3D,
                                   LoadModeType.DMA_CPY]
        self.strideh_read_list = [int(True), int(False)]
        self.linear_embedding_opti_list = [True, False]
