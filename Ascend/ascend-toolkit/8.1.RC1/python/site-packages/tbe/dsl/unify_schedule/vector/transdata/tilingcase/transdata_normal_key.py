#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright(C) 2022. Huawei Technologies Co., Ltd. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
Transdata Schedule Key
"""
import numpy
from tbe.dsl.base.operation import get_context
from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.classifier.transdata.constants import DIFF_ATTR, COMMON_ALIGN, STORAGE_ALIGN
from tbe.dsl.classifier.transdata.constants import CONST_KEY, CATEGORY_MAP_UB, RULE
from tbe.dsl.classifier.transdata.constants import NOT_WORK, ALIGN, NOT_ALIGN
from tbe.dsl.classifier.transdata.constants import CATEGORY_MAP_DIRECTION
from tbe.dsl.classifier.transdata.constants import combine_n
from ..common.graph.transdata_graph_info import ComputeGraphInfo


class TransdataCase:
    """
    Obj-TransdataCase
    """

    def __init__(self, graph: ComputeGraphInfo):
        self.tiling_key = CONST_KEY

        # decide kinds of cases
        self.fuse_mode = 0
        self.direction = CATEGORY_MAP_DIRECTION.get(graph.category, None)
        self.ub_category = CATEGORY_MAP_UB.get(graph.category, 0)
        self.shape_type = 0
        self.block_split_idx = None
        self.ub_split_first_idx = None
        self.ub_split_second_idx = None
        self.transpose_work = 0
        self.avoid_bank_conflict = 0
        # forward: last-dim is input, backward: last-dim is output
        self.last_dim_type = 0
        self.binary_c0 = int(numpy.log(get_context().get_current_compute().get("_c0")) / numpy.log(2))

        # update value
        self.block_factor = None
        self.ub_first_factor = None
        self.ub_second_factor = None
        self.tensor_ub_size_list = []
        self.transdata_category = graph.category


class TransdataSplit:
    """
    Obj-TransdataSplit: base + borrow
    """

    def __init__(self, outs, option):
        self.outs = outs
        self.option = option

        self.is_const = None
        self.bit = None
        self.ori_bit = None
        self.graph_info = None
        self.align_size = None

    @staticmethod
    def split(_length, _perm):
        """
        Return all split cases no matter sch support or not.
        Eg: Input:[A,B,C,D,E], output:[E,D,C,B,A], perm: [4,3,2,1,0]
                           |->split_i: B = B.outer * B.inner
                 Input: [A, B, C, D, E]
                 Output:[E, D, C, B, A]
                                     |->split_o: A = A.outer * A.inner
                 AxisInUB: [E, D, C, B.inner, A.inner]
                 AxisOutUB: [B.outer, A.outer]
                                |->split_b
        split_i : ub split in input
        split_o : ub split in output
        split_b : block split in output
        """
        _out = []
        for i in range(_length - 1, -1, -1):
            # axes in ub by split input that base on output
            input_axis_inner = {_perm.index(x) for x in range(i + 1, _length, 1)}
            for o in range(_length - 1, -1, -1):
                # axes in ub by split output
                output_axis_inner = set(range(o + 1, _length, 1))
                if o in input_axis_inner or _perm.index(i) in output_axis_inner:
                    continue
                output_axis_inner = output_axis_inner.union(input_axis_inner)
                axis_outer = set(range(_length)).difference(output_axis_inner)
                for b in axis_outer:
                    _out.append([b, _perm.index(i), o])
        return _out

    @staticmethod
    def add_fuse_generation(inputs):
        # work for fuse axis situation
        for v in inputs:
            v.fuse_mode = 1
            v.block_split_idx = 0
            calc_key(v)
        # filter same keys
        key, values = [], []
        for i in inputs:
            if i.tiling_key in key:
                continue
            key.append(i.tiling_key)
            values.append(i)
        return values

    def base_filter(self, inputs):
        """
        Return legal cases from all split cases
        1. not support to split last c0
        2. maybe not existed c1 and c0
        3. not split c1 and c0 together
        """

        def split_c1c0_together(_input):
            c1 = self.graph_info.c1c0[0]
            c0 = self.graph_info.c1c0[1]
            return True if c1 in _input and c0 in _input else False

        def split_c0(_input):
            return True if self.graph_info.c1c0[1] in _input else False

        if not self.graph_info.c1c0:
            return inputs

        out = []
        for i in inputs:
            if not split_c1c0_together(i) and not split_c0(i):
                out.append(i)
        return out

    def base_generation(self, inputs):
        """
        For BaseSch, create cases as soon as possible.
        ShapeType has two mode: StorageAlign, CommonAlign.
        TransposeWork has two mode: work, not-work.
        AvoidBankConflict has two mode: work, not-work.
        """

        def attrs_filter(_shape, _avoid, _type, _input):
            # some attrs are mutually exclusive
            if _shape == COMMON_ALIGN and not self._check_common_align(_input):
                return False
            if _type == ALIGN and self.graph_info.is_forward:
                return False
            # pass-bug for all-avoid-situation
            if _avoid == NOT_WORK and not self.graph_info.is_last_transpose:
                return False
            return True

        out = []
        attrs = combine_n(*[i for _, i in DIFF_ATTR.items()])
        for i in inputs:
            for (shape_type, avoid_bc, last_dim_type) in attrs:
                if not attrs_filter(shape_type, avoid_bc, last_dim_type, i):
                    continue
                case = TransdataCase(self.graph_info)
                case.block_split_idx = i[0]
                case.ub_split_first_idx = i[1]
                case.ub_split_second_idx = i[2]
                case.shape_type = shape_type
                case.transpose_work = 1
                case.avoid_bank_conflict = avoid_bc
                case.last_dim_type = last_dim_type
                calc_key(case)
                ComputeGraphInfo.set_buffer_size(self.graph_info, case)
                out.append(case)
        return out

    def data_move_filter(self, inputs):
        # reused base-filter
        return self.base_filter(inputs)

    def data_move_generation(self, inputs):
        """
        For data-move-sch: only choose ShapeType from [StorageAlign, CommonAlign].
        TransposeWork is 0, AvoidBankConflict is 0, last_dim_type is 0.
        """
        out = []
        for i in inputs:
            for j in [COMMON_ALIGN, STORAGE_ALIGN]:
                for m in [ALIGN, NOT_ALIGN]:
                    if self.graph_info.is_forward and m == ALIGN:
                        continue
                    if j == COMMON_ALIGN and not self._check_common_align(i):
                        continue
                    case = TransdataCase(self.graph_info)
                    case.block_split_idx = i[0]
                    case.ub_split_first_idx = i[1]
                    case.ub_split_second_idx = i[2]
                    case.shape_type = j
                    case.last_dim_type = m
                    calc_key(case)
                    ComputeGraphInfo.set_buffer_size(self.graph_info, case)
                    out.append(case)
        return out

    def borrow_filter(self, inputs):
        """
        Return legal cases from all split cases
        1. not split C
        2. not split X0(N0 H0)
        3. if src-tensor is fp32, it would be interpret as fp16 that don't split last-dim
        """

        def split_c(input_):
            for c in self.graph_info.c1c0:
                if c in input_:
                    return True
            return False

        out = []
        length = len(self.graph_info.tiling_tensor.shape)
        for i in inputs:
            not_split_c = not split_c(i)
            not_split_x0 = self.graph_info.x1x0[-1] not in i
            if not_split_c and not_split_x0:
                if length - 1 in i and self.ori_bit != self.bit:
                    continue
                out.append(i)
        return out

    def borrow_generation(self, inputs):
        result = []
        for i in inputs:
            case = TransdataCase(self.graph_info)
            case.block_split_idx = i[0]
            case.ub_split_first_idx = i[1]
            case.ub_split_second_idx = i[2]
            case.transpose_work = 1
            calc_key(case)
            ComputeGraphInfo.set_buffer_size(self.graph_info, case)
            result.append(case)
        return result

    def borrow_x_filter(self, inputs):
        """
        Return legal cases from all split cases.
        Eg: NI C1 H C0 2 N0 -> NO NI C1 H C0 2
        1. must split NO ps:(NO,NI) = (X1,X0)
        2. not split NI C0 2
        Backward need refine
        """

        def split_c0(_input):
            return self.graph_info.c1c0[1] in _input

        def split_x1(_input):
            return self.graph_info.x1x0[0] in _input

        def split_x0(_input):
            return self.graph_info.x1x0[1] in _input

        out = []
        length = len(self.graph_info.tiling_tensor.shape)
        for i in inputs:
            if self.graph_info.is_forward and split_c0(i):
                continue
            if not split_x0(i) and split_x1(i):
                if length - 1 in i and self.ori_bit != self.bit:
                    continue
                out.append(i)
        return out

    def borrow_x_generation(self, inputs):
        # reused borrow-generation
        return self.borrow_generation(inputs)

    def _check_common_align(self, _input):
        """
        If forward: (N,H,C) -> (N,C1,H,C0), don't split C.
        If backward: (N,C1,H,C0) -> (N,H,C), don't split C.
        Attention backward split on transpose-tensor(N,H,C1,C0)
        """
        last_dim = self.graph_info.reshape[-1]
        if not isinstance(self.graph_info.reshape[-1], (list, tuple)):
            last_dim = [self.graph_info.reshape[-1]]

        new_input = [self.graph_info.permute[x] for x in _input] if self.graph_info.is_forward else _input
        for v in last_dim:
            if v in new_input:
                return False
        return True


def calc_key(case: TransdataCase):
    """
    :param case: TilingCase
    :return: case.tiling_key
    """

    var = [case.fuse_mode, case.direction, case.ub_category, case.shape_type,
           case.block_split_idx, case.ub_split_first_idx, case.ub_split_second_idx,
           case.transpose_work, case.avoid_bank_conflict, case.last_dim_type, case.binary_c0]

    def check(_key, value):
        if _key not in value[1]:
            dict_args = {"errCode": "E90003",
                         "detailed_cause": "%s should in %s, but is %d" % (value[0], str(value[1]), _key)}
            raise RuntimeError(dict_args, get_error_message(dict_args))

    key = 0
    for k, v in zip(var, RULE):
        check(k, v)
        key += k * v[-1]
    case.tiling_key = key
