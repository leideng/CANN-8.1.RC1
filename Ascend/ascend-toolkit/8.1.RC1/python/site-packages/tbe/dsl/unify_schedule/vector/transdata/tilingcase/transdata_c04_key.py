#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright(C) 2022. Huawei Technologies Co., Ltd. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
transdata c04 tilingcase
"""
import numpy
from tbe.dsl.base.operation import get_context
from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.classifier.transdata.constants import DIFF_ATTR, COMMON_ALIGN, STORAGE_ALIGN
from tbe.dsl.classifier.transdata.constants import CONST_KEY, CATEGORY_MAP_UB, RULEC04
from tbe.dsl.classifier.transdata.constants import CATEGORY_MAP_DIRECTION
from ..common.graph.transdata_graph_info import ComputeGraphInfo


class TransdataC04Case:
    """
    Obj-TransdataC04Case
    """

    def __init__(self, graph: ComputeGraphInfo):
        self.tiling_key = CONST_KEY

        # decide kinds of cases
        self.ub_category = CATEGORY_MAP_UB.get(graph.category, 0)
        self.direction = CATEGORY_MAP_DIRECTION.get(graph.category, None)
        self.block_split_idx = None
        self.ub_split_first_idx = None
        self.shape_type = 0

        # update value
        self.block_factor = None
        self.ub_first_factor = None
        self.pad_factor = None
        self.tensor_ub_size_list = []
        self.transdata_category = graph.category


class TransdataC04Split:
    """
    Obj-TransdataSplit: base
    """

    def __init__(self, outs, option):
        self.outs = outs
        self.option = option

        self.is_const = None
        self.bit = None
        self.ori_bit = None
        self.graph_info = None
        self.align_size = None

    @staticmethod
    def split(_length, _perm):
        """
        Return all split cases no matter sch support or not.
        """
        _out = []
        for i in range(_length - 1, -1, -1):
            axis_outer = set(range(_length)).difference({i + 1})
            for b in range(i + 1):
                _out.append([b, i])
        return _out

    def base_generation(self, split_info):
        """
        For BaseSch, create cases as soon as possible.
        ShapeType has two mode: StorageAlign, CommonAlign.
        forward generate common align no matter sch support or not.
        optiling generate support common align tiling_key
        """
        out = []
        for i in split_info:
            for shape_type in [COMMON_ALIGN, STORAGE_ALIGN]:
                if not self.graph_info.is_forward and \
                   shape_type == COMMON_ALIGN and not self._check_common_align(i):
                    continue
                case = TransdataC04Case(self.graph_info)
                case.block_split_idx = i[0]
                case.ub_split_first_idx = i[1]
                case.shape_type = shape_type

                calc_key(case)
                ComputeGraphInfo.set_buffer_size(self.graph_info, case)
                out.append(case)
        return out

    def base_filter(self, split_info):
        """
        Return legal cases from all split cases
        1. not support to split last c0
        return split axies Info of UB/Block after filter 
        """

        def split_c0(_split_info):
            return True if self.graph_info.c1c0[1] in _split_info else False

        if not self.graph_info.c1c0:
            return split_info

        out = []
        for i in split_info:
            if  not split_c0(i):
                out.append(i)
        return out

    def data_move_filter(self, inputs):
        # reused base-filter
        return self.base_filter(inputs)

    def data_move_generation(self, inputs):
        """
        reused base_generation
        """
        return self.base_generation(inputs)

    def _check_common_align(self, _input):
        """
        If forward: (N,H,C) -> (N,C1,H,C0), don't split C.
        If backward: (N,C1,H,C0) -> (N,H,C), don't split C.
        Attention backward split on transpose-tensor(N,H,C1,C0)
        """
        last_dim = self.graph_info.reshape[-1]
        if not isinstance(self.graph_info.reshape[-1], (list, tuple)):
            last_dim = [self.graph_info.reshape[-1]]

        new_input = [self.graph_info.permute[x] for x in _input] if self.graph_info.is_forward else _input
        for v in last_dim:
            if v in new_input:
                return False
        return True


def calc_key(case: TransdataC04Case):
    """
    :param case: TilingCase
    :return: case.tiling_key
    """

    var = [case.ub_category, case.direction, case.block_split_idx,
           case.ub_split_first_idx, case.shape_type]

    def check(_key, value):
        if _key not in value[1]:
            dict_args = {"errCode": "E90003",
                         "detailed_cause": "%s should in %s, but is %d" % (value[0], str(value[1]), _key)}
            raise RuntimeError(dict_args, get_error_message(dict_args))

    key = 0
    for k, v in zip(var, RULEC04):
        check(k, v)
        key += k * v[-1]
    case.tiling_key = key
