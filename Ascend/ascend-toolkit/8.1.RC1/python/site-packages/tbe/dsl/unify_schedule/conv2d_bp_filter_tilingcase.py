#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
conv2d backprop filter tiling case
"""

import copy
from collections import OrderedDict
from collections import namedtuple
from functools import reduce
from itertools import product

from tbe import tvm
from tbe.common.platform import platform_info as tbe_platform_info
from tbe.common.utils import log
from tbe.common.utils.const import BIT_RATIO_DICT
from tbe.dsl.base.operation import add_compile_info
from tbe.dsl.base.operation import get_context
from tbe.dsl.base.operation import get_op_context
from tbe.dsl.base.operation import in_dynamic
from tbe.dsl.base.operation import register_tiling_case
from tbe.dsl.classifier.util import LoadModeType
from tbe.dsl.compute import cube_util
from tbe.dsl.compute.conv2d_backprop_filter_compute import DynamicConv2dBpFilterParams as DynamicParams
from tbe.dsl.compute.conv2d_backprop_filter_compute import get_binary_mode
from tbe.dsl.static_schedule.conv_util import get_inout_dtype

from .constants import Pattern
from .conv2d_bp_filter_tensor import TensorConv2dBackPropFilter
from .cube_tilingcase import ConvBpFilterTilingIdOffset
from .cube_tilingcase import CubeStaticTilingOp
from .cube_tilingcase import CubeTilingOp
from .cube_tilingcase import TilingSelection
from .cube_tilingcase import TilingUtils as utils
from .cube_tilingcase import get_op_tiling
from .util import ceil_div

H_RANGE = 4096
W_RANGE = 4096
N_RANGE = 2**31 - 1
W_DELTA = 1
H_LEN = 400
W_LEN = 400
MAX_INT64 = 9223372036854775807
MIN_INT64 = 1
DEFAULT_KERNEL_ID = None

KILO_BYTE = 1024
CUBE_DIM = 16
OPEN_DOUBLE_BUFFER = 2
CUBE_MUL_SHAPE = 256
# minimum value of multi_m_AL1
MULTI_M_AL1_MIN = 1
# channel size, support 4 channels
C04_SIZE = 4
# fractal size, only support 16 for now
BLOCK_SIZE = 16

# Tiling Dtype parameter index number
A_DTYPE_INDEX = 0
B_DTYPE_INDEX = 1
C_DTYPE_INDEX = 2
MAD_DTYPE_INDEX = 3


SHAPE_VARS = ("batch", "fmap_c", "fmap_h", "fmap_w", "dedy_c", "dedy_h", "dedy_w")
ATTR_VARS = ("kernel_h", "kernel_w", "fmap_c1", "dedy_c1", "stride_h", "stride_w", "padt", "padb", "padl", "padr",
    "dilation_h", "dilation_w", "groups", "cin1_g", "cout1_g", "real_g", "mag_factor", "hf32_flag")
TILING_VARS = ("group_dim", "batch_dim", "k_dim", "batch_single_core", "n_single_core", "n_dim", "n_bl1",
    "n_ub_l0_time", "cub_n1", "m_dim", "m_single_core", "m_al1", "m_l0", "k_l0", "kal1_factor", "kbl1_factor",
    "kal0_factor", "kbl0_factor", "kal1_16", "kbl1_16", "kl1_times", "bl1_bound", "m_aub", "n_bub", "k_aub",
    "k_bub", "wi_bub", "ho_bL1", "multi_n_ub_l1", "multi_m_ub_l1", "multi_k_aub_l1", "multi_k_bub_l1", "al1_pb",
    "bl1_pb", "l0c_pb",
)
SPECIAL_SCENE_VAR = ("load3d_special", "is_bf16")


def get_all_vars():
    return SHAPE_VARS + ATTR_VARS + TILING_VARS + SPECIAL_SCENE_VAR


class Conv2DBpFilterTilingIdOffset(ConvBpFilterTilingIdOffset):
    # tiling_id offset
    def __init__(self):
        super().__init__()
        self.linear_embedding_opti_flag = 14
        self.strideh_read_flag = 13


def _gen_target_area(var_names):
    """
    generated target area

    Parameters
    ----------
    var_names : list of variable names to be generated

    info : dict, tiling info

    Returns
    -------
    area of dict, each item for a range
    """
    target_area = {}
    for var_name in var_names:
        target_area[var_name] = (1, None)
    return target_area


@register_tiling_case(pattern=Pattern.CONV2D_BACKPROP_FILTER)
def calc_conv2dbp_filter(outs, option=None):
    """
    tiling_case func for dynamic shape conv2d_bp_filter

    Parameters
    ----------
    option : option

    Returns
    -------
    list of dict, each dict for a tiling case
    """
    var_names = ('batch', 'fmap_h', 'fmap_w')
    tgt_list = []
    info = DynamicParams.tiling_info_dict
    tgt_area = _gen_target_area(var_names)
    tgt_list.append(tgt_area)
    max_id = DEFAULT_KERNEL_ID
    if not in_dynamic():
        tensor_dw = TensorConv2dBackPropFilter(outs)
        tensor_list = tensor_dw.get_tensor_and_para_map()
        tiling_dw = Conv2dBpFilterStaticTiling(outs, tensor_list)
        tiling_dw.get_static_tiling()
        return [{"tiling_strategy": tiling_dw.tiling}]

    tiling_cases = []
    for tgt in tgt_list:
        new_info = copy.deepcopy(info)
        tiling_op = Conv2dBpFilterTiling(new_info, DynamicParams.var_map)
        selector = TilingSelection(tiling_op, max_id)
        tiling_cases += selector.calc_tiling(tgt, var_names)

    # dynaminc constantization for static shape scene
    context = get_op_context()
    dyn_constant_tiling = None
    if context.get_addition("is_dynamic_constantization"):
        tiling_data_key = get_all_vars()
        tiling_data, tiling_key = get_op_tiling("Conv2DBackpropFilter", tiling_data_key)
        dyn_constant_tiling = Conv2dBpFilterTiling.get_dyn_constant_tiling(
            tiling_cases, tiling_data, tiling_key, "Conv2DBackpropFilter")
        return dyn_constant_tiling
    return tiling_cases


class Conv2dBpFilterTiling(CubeTilingOp):
    """
    get_tiling class for dynamic shape conv2d_bp_filter
    """

    def __init__(self, tiling_info, var_map):
        super().__init__(tiling_info, var_map)
        self.a_info = self.tiling_info['A_shape']
        self.b_info = self.tiling_info['B_shape']
        self.c_info = self.tiling_info['C_shape']
        self._get_calc_info()
        self.key = 'B_shape'
        self.op_type = 'conv2d_backprop_filter'
        self.var_map = var_map
        self.binary_mode = DynamicParams.binary_mode
        self.load_mode = DynamicParams.load_mode
        self.strideh_read_flag = DynamicParams.strideh_read_flag
        self.linear_embedding_opti_flag = DynamicParams.linear_embedding_opti_flag
        self.attrs = DynamicParams.attrs
        get_context().add("_use_cache_tiling", bool(self.binary_mode))

    @staticmethod
    def get_default_tiling(w_bound=None):
        """
        get default tiling for unlimited range or special case

        Returns
        -------
        dict: default tiling for conv2d_bp_filter
        """
        return {
            'AUB_shape': [1, 0, 0, 0],
            'BUB_shape': None,
            'AL1_shape': [utils.CUBE_SIZE, 1, 1],
            'BL1_shape': [utils.CUBE_SIZE, 1, 1],
            'AL0_matrix': [1, 1, utils.CUBE_SIZE, utils.CUBE_SIZE, 1],
            'BL0_matrix': [1, 1, utils.CUBE_SIZE, utils.CUBE_SIZE, 1],
            'CL0_matrix': [1, 1, utils.CUBE_SIZE, utils.CUBE_SIZE, 1],
            'CUB_matrix': [1, 1, utils.CUBE_SIZE, utils.CUBE_SIZE, 1],
            'block_dim': [1, 1, 1, 1],
            'cout_bef_batch_flag': 0,
            'A_overhead_opt_flag': 0,
            'B_overhead_opt_flag': 0,
            'manual_pingpong_buffer': {
                'AUB_pbuffer': 1,
                'BUB_pbuffer': 1,
                'AL1_pbuffer': 1,
                'BL1_pbuffer': 1,
                'AL0_pbuffer': 1,
                'BL0_pbuffer': 1,
                'CL0_pbuffer': 1,
                'CUB_pbuffer': 1,
                'UBG_pbuffer': 1
            },
            'dynamic_l0a_attach': 'dw_cc',
            'dynamic_l0b_attach': 'dw_cc',
            'dynamic_al1_attach': 'dw_cc',
            'dynamic_bl1_attach': 'dw_cc',
            'bl1_hw_allin_flag': 'dw_cc',
            'w_one_flag': 1,
        }

    @staticmethod
    def _get_choice_list():
        (abkl1_attach, al1_attach_flag, bl1_attach_flag, min_kl1_cmp_kl0, load3d_special_flag, conv1d_flag) = (
            [utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL, utils.ATTACH_LESS],
            [utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL, utils.ATTACH_LESS],
            [utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL, utils.ATTACH_LESS],
            [0, 1],
            [0, 1],
            [0, 1])

        choice_list = list(
            product(abkl1_attach, al1_attach_flag, bl1_attach_flag, min_kl1_cmp_kl0, load3d_special_flag, conv1d_flag))

        return choice_list

    def assembly_case(self, tiling, coverage, cnt):
        """
        Configure dict of tiling strategy and coverage

        Parameters
        ----------
        tiling: dict, tiling from repository or cost model

        coverage: list of tuple, coverage of tiling

        cnt: serial number of tiling

        Returns
        -------
        dict: describe a tiling strategy
        """
        var_range = OrderedDict()
        if not self.binary_mode:
            if 'batch' in self.var_map:
                var_range['batch'] = (utils.trans_to_int(coverage[0]), utils.trans_to_int(coverage[1]))
            if 'fmap_h' in self.var_map or 'fmap_w' in self.var_map:
                x_h_low, x_h_high = utils.trans_to_int(coverage[2]), utils.trans_to_int(coverage[3])
                x_w_low, x_w_high = utils.trans_to_int(coverage[4]), utils.trans_to_int(coverage[5])
                self._set_padding_list(x_h_low, x_w_low)
                dedy_h_low = self._get_output_h(x_h_low)
                dedy_w_low = self._get_output_w(x_w_low)
                if x_h_high and x_w_high:
                    self._set_padding_list(x_h_high, x_w_high)
                dedy_h_high = self._get_output_h(x_h_high)
                dedy_w_high = self._get_output_w(x_w_high)

                var_range['fmap_h'] = (x_h_low, x_h_high)
                var_range['fmap_w'] = (x_w_low, x_w_high)
                var_range['dedy_h'] = (dedy_h_low, dedy_h_high)
                var_range['dedy_w'] = (dedy_w_low, dedy_w_high)

        block_dim_multi = tiling["AUB_shape"][0] if tiling["AUB_shape"] else 1
        block_dims = block_dim_multi * reduce(lambda x, y: x * y, tiling['block_dim'])
        correct_range_flag = DynamicParams.correct_range_flag

        return {
            "key": cnt,
            "tiling_strategy": tiling,
            "var_range": var_range,
            "block_dim": block_dims,
            "correct_range_flag": correct_range_flag
        }

    def get_ub_fusion_para(self):
        '''
        -----------------------------------------------------------------
        | format |    aub_num     |    bub_num     |
        -----------------------------------------------------------------
        | NC1HWC0|        0       |        0       |
        | NCHW   |        1       |        1       |
        | NHWC   |        1       |        1       |
        -----------------------------------------------------------------
        Returns
        ----------
        aub_num: int, The amount of space that aub needs to occupy
        bub_num: int, The amount of space that bub needs to occupy
        cub_num: int, The amount of space that cub needs to occupy
        ub_size: int, The size ub can use
        '''
        cub_num = 1
        ub_size = tbe_platform_info.get_soc_spec("UB_SIZE")
        if self.binary_mode == utils.NC1HWC0:
            aub_num = 0
            bub_num = 0
        else:
            aub_num = 1
            bub_num = 1
        result = {"aub_num": aub_num, "bub_num": bub_num, "cub_num": cub_num, "ub_size": ub_size}

        return result

    def _check_invalid_choice(self, choice):
        abkl1_attach, al1_attach_flag, bl1_attach_flag, min_kl1_cmp_kl0, load3d_special_flag, conv1d_flag = choice
        # Drop invalid choices
        # 1) a_l1 full_load or a_l1 full_k, b_l1 full_load or full_k: a_kl1 equals a_bkl1;
        invalid_choice = (
            al1_attach_flag in (utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL) and
            bl1_attach_flag in (utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL) and
            abkl1_attach != utils.ATTACH_FULL_LOAD
        )

        # 2) a_l1 full_load or full_k, b_l1 k_split: a_kl1 > b_kl1 & reorder_l1_mn is 1;
        invalid_choice |= (
            al1_attach_flag in (utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL) and
            bl1_attach_flag == utils.ATTACH_LESS and
            (abkl1_attach != utils.ATTACH_EQUAL)
        )

        # 3) a_l1 k_split, b_l1 full_load or full_k: a_kl1 < b_kl1 & reorder_l1_mn is 0;
        invalid_choice |= (
            al1_attach_flag == utils.ATTACH_LESS and
            bl1_attach_flag in (utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL) and
            abkl1_attach != utils.ATTACH_LESS
        )

        # 5) load3d_special_flag and load2d/load3d_w_split/dma_cpy is invalid
        invalid_choice |= (load3d_special_flag == 1 and self.load_mode in
                           [LoadModeType.LOAD2D, LoadModeType.W_SPLIT_LOAD3D, LoadModeType.DMA_CPY])

        # 6) strideh_read_flag and load2d is invalid
        invalid_choice |= (self.strideh_read_flag == 1 and self.load_mode == LoadModeType.LOAD2D)

        # 7) conv1d_flag and load3d_w_split/dma_cpy is invalid
        invalid_choice |= (conv1d_flag == 1 and self.load_mode in
                           [LoadModeType.W_SPLIT_LOAD3D, LoadModeType.DMA_CPY])

        # 8) load3d_w_split/dma_cpy and abl1 k full load is invalid
        invalid_choice |= ((al1_attach_flag in (utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL)
                            or bl1_attach_flag in (utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL))
                            and self.load_mode in [LoadModeType.W_SPLIT_LOAD3D, LoadModeType.DMA_CPY]
                            and not self.linear_embedding_opti_flag)

        # 9) linear_embedding_opti_flag Dependent on DMA_CPY
        invalid_choice |= (self.linear_embedding_opti_flag and self.load_mode != LoadModeType.DMA_CPY)

        # 10) linear_embedding_opti_flag, A ATTACH_FULL_LOAD/ATTACH_LESS and B ATTACH_LESS
        invalid_choice |= ((al1_attach_flag in (utils.ATTACH_EQUAL,)
                            or bl1_attach_flag in (utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL))
                            and self.linear_embedding_opti_flag)

        # 11) conv1d and strideh_read_flag is invalid
        invalid_choice |= (conv1d_flag == 1 and self.strideh_read_flag == 1)

        return invalid_choice

    def _get_calc_info(self):
        self._convert_type(self.a_info, self.b_info, self.c_info)
        self.k_h, self.k_w = self.c_info[2:4]
        self.k_cin = self.c_info[1] * self.c_info[4]
        self.k_cout = self.c_info[0]
        self.stride_h, self.stride_w = self.tiling_info["strideH"], \
            self.tiling_info["strideW"]
        self.dilate_h, self.dilate_w = self.tiling_info["dilationH"], \
            self.tiling_info["dilationW"]

        if isinstance(self.tiling_info["padl"], tvm.tir.PrimExpr) or \
            isinstance(self.tiling_info["padu"], tvm.tir.PrimExpr):
            self.pad_mode = "SAME"
            self.cur_pads = [-1, -1, -1, -1]
            for pad in ("padl", "padr", "padu", "padd"):
                self.tiling_info[pad] = -1
        else:
            self.pad_mode = "FIX"
            self.cur_pads = [
                self.tiling_info["padl"], self.tiling_info["padr"], self.tiling_info["padu"], self.tiling_info["padd"]
            ]

        self.k_h_dilation = (self.k_h - 1) * self.dilate_h + 1
        self.k_w_dilation = (self.k_w - 1) * self.dilate_w + 1

    def _set_padding_list(self, cur_h, cur_w):
        """
        get padding list in cur dx shape
        """

        if self.pad_mode == "SAME":
            pad_h = max(utils.align(cur_h, self.stride_h) - self.stride_h + self.k_h_dilation - cur_h, 0)
            pad_up = pad_h // 2
            pad_down = pad_h - pad_up
            pad_w = max(utils.align(cur_w, self.stride_w) - self.stride_w + self.k_w_dilation - cur_w, 0)
            pad_left = pad_w // 2
            pad_right = pad_w - pad_left
            self.cur_pads = [pad_left, pad_right, pad_up, pad_down]

    def _get_output_h(self, h_i):
        if not h_i:
            return None
        return max(1, (h_i + self.cur_pads[2] + self.cur_pads[3] - self.dilate_h *
                       (self.k_h - 1) - 1) // self.stride_h + 1)

    def _get_output_w(self, w_i):
        if not w_i:
            return None
        return max(1, (w_i + self.cur_pads[0] + self.cur_pads[1] - self.dilate_w *
                       (self.k_w - 1) - 1) // self.stride_w + 1)

    def _gen_cache_tiling(self, cache_tiling, choice):
        '''
        Generate cache tiling and tiling_id.
        ---------------------------------------------
        |      variable     |    offset    |         value        |
        |     stride_read   |      12      |          0,1         |
        | abkl1_attach_flag |      10      |          0,1,2       |
        |  al1_attach_flag  |      8       |          0,1,2       |
        |  bl1_attach_flag  |      6       |          0,1,2       |
        |  min_kl1_cmp_kl0  |      5       |          0,1         |
        |  load3d_special   |      4       |          0,1         |
        |   conv1d_flag     |      3       |          0,1         |
        |    load_mode      |      2       | 0(load3d),1(load2d)  |
        |    binary_mode    |      0       |0(5HD),1(NCHW),2(NHWC)|

        Returns
        ----------
        cache_tiling:Value of tiling
        tiling_id: The id of tiling
        '''
        (cache_tiling.get('attach_at_flag')['abkl1_attach_flag'],
         cache_tiling.get('attach_at_flag')['al1_attach_flag'],
         cache_tiling.get('attach_at_flag')['bl1_attach_flag'],
         cache_tiling.get('attach_at_flag')['min_kl1_cmp_kl0'],
         cache_tiling['load3d_special_flag'],
         cache_tiling['conv1d_flag']) = choice

        abkl1_attach, al1_attach_flag, bl1_attach_flag, min_kl1_cmp_kl0, load3d_special_flag, conv1d_flag = choice
        offset = Conv2DBpFilterTilingIdOffset()
        tiling_id = 0
        tiling_id += self.linear_embedding_opti_flag << offset.linear_embedding_opti_flag
        tiling_id += self.strideh_read_flag << offset.strideh_read_flag
        tiling_id += abkl1_attach << offset.abkl1_attach_flag_offset
        tiling_id += al1_attach_flag << offset.al1_attach_flag_offset
        tiling_id += bl1_attach_flag << offset.bl1_attach_flag_offset
        tiling_id += min_kl1_cmp_kl0 << offset.min_kl1_cmp_kl0_offset
        tiling_id += load3d_special_flag << offset.load3d_special_flag
        tiling_id += conv1d_flag << offset.conv1d_flag
        tiling_id += self.load_mode << offset.load_mode_offset
        tiling_id += (self.binary_mode - 1) << offset.binary_mode_offset

        return cache_tiling, tiling_id


class Conv2dBpFilterStaticTiling(CubeStaticTilingOp):
    """
    get tiling for static shape scene of dw
    """
    Load3dParams = namedtuple('Load3dParams', [
        'stride_height', 'stride_width', 'pad_up', 'pad_down', 'pad_left', 'pad_right', 'kernel_height', 'kernel_width',
        'dilation_height', 'dilation_width'
    ])

    def __init__(self, out_list, tensor_list):
        # tensor_list format is [compute_tensors, placeholder_tensors, output_tensors, tensor_map, para_map]
        super().__init__(out_list)
        self.tensor_list = tensor_list
        self.tensor_map = tensor_list[3]
        self._set_tiling_info_dict()

    def _get_and_transfer_cache_tiling(self):
        """
        get cache_tiling and transfer it to static tiling
        """
        def _add_tiling_compile_info():
            x_format = get_op_context().get_addition("x").get("format")
            add_compile_info("tiling_type", "static")
            add_compile_info("binary_mode", get_binary_mode(x_format, True))

        log.info("[tiling route][{}]use do_op_tiling".format(self.kernel_name))
        _add_tiling_compile_info()
        tiling_data_key = get_all_vars()
        tiling_data, tiling_key = get_op_tiling("Conv2DBackpropFilter", tiling_data_key)
        log.debug("[optiling]tiling_key: {}, tiling_data {}".format(tiling_key, tiling_data))
        return self._transfer_tiling(tiling_key, tiling_data)

    def _transfer_tiling(self, tiling_key, tiling_data):
        '''
        transfer tiling_data to tiling_case
        '''
        c0 = BLOCK_SIZE * 2 // BIT_RATIO_DICT.get(self.tiling_info_dict.get("A_dtype"))
        # get tiling value from tiling_data
        batch_dim = tiling_data.get("batch_dim")
        n_dim = tiling_data.get("n_dim")
        m_dim = tiling_data.get("m_dim")
        k_dim = tiling_data.get("k_dim")
        g_dim = tiling_data.get("group_dim")
        k_al1 = tiling_data.get("kal1_16") * c0
        k_bl1 = tiling_data.get("kbl1_16") * c0
        m_al1 = tiling_data.get("m_al1")
        n_bl1 = tiling_data.get("n_bl1")
        m_l0 = tiling_data.get("m_l0")
        k_l0 = tiling_data.get("k_l0")
        cub_n1 = tiling_data.get("cub_n1")
        n_l0 = cub_n1 * tiling_data.get("n_ub_l0_time")

        offset = ConvBpFilterTilingIdOffset()
        # get pb_flag from tiling_key
        tiling_key = tiling_key >> offset.db_al1_offset
        al1_pb = (tiling_key & 1) + 1
        tiling_key = tiling_key >> 1
        bl1_pb = (tiling_key & 1) + 1
        tiling_key = tiling_key >> 1
        l0c_pb = (tiling_key & 1) + 1

        # construct tiling_case
        tiling_case = {'AL0_matrix': [m_l0, k_l0, CUBE_DIM, c0, 1, 1], 'AL1_shape': [k_al1, m_al1, 1, 1],
                       'AUB_shape': [k_dim, 0, 0, 0], 'BL0_matrix': [k_l0, n_l0, CUBE_DIM, c0, 1, 1],
                       'BL1_shape': [k_bl1, n_bl1, 1, 1], 'BUB_shape': None,
                       'CL0_matrix': [n_l0, m_l0, CUBE_DIM, CUBE_DIM, 1, 1], 'INPUT_L1_BT_param': None,
                       'INPUT_L1_FB_param': None, 'INPUT_L1_eltwise_param': None, 'INPUT_L1_sparse_index': None,
                       'block_dim': [batch_dim, n_dim, m_dim, g_dim],
                       'manual_pingpong_buffer': {'AL0_pbuffer': utils.DB_ON, 'AL1_pbuffer': al1_pb, 'AUB_pbuffer': 1,
                                                  'BL0_pbuffer': utils.DB_ON, 'BL1_pbuffer': bl1_pb, 'BUB_pbuffer': 1,
                                                  'CL0_pbuffer': l0c_pb, 'INPUT_L1_BT_pbuffer': 1,
                                                  'INPUT_L1_FB_pbuffer': 1, 'INPUT_L1_eltwise_pbuffer': 1,
                                                  'UBG_pbuffer': 1, 'CUB_pbuffer': 1},
                       'special_optimize_flag': 0, 'tbe_compile_para': 0, 'vector_block_num': 0,
                       'CUB_matrix': [cub_n1, m_l0, CUBE_DIM, CUBE_DIM, 1, 1],
                       'AUB_channel_wise_flag': None, 'BUB_channel_wise_flag': None, 'CUB_channel_wise_flag': False,
                       'A_overhead_opt_flag': 0, 'B_overhead_opt_flag': 0, 'n_bef_batch_flag': 0,
                       'n_bef_group_flag': 0, 'batch_bef_group_flag': 0, 'binary_flag': 0}
        return tiling_case

    def _get_load3d_para(self):
        # load_3d parameters
        load_3d_tensor = "fmap_matrix"
        if DynamicParams.var_map and not DynamicParams.flag_all_one_case:
            load_3d_tensor = "fmap_fractal"

        load3d_params = self.Load3dParams(
            self._get_value(self.tensor_map.get(load_3d_tensor).op.attrs['stride'][0]),
            self._get_value(self.tensor_map.get(load_3d_tensor).op.attrs['stride'][1]),
            self._get_value(self.tensor_map.get(load_3d_tensor).op.attrs['pad'][0]),
            self._get_value(self.tensor_map.get(load_3d_tensor).op.attrs['pad'][1]),
            self._get_value(self.tensor_map.get(load_3d_tensor).op.attrs['pad'][2]),
            self._get_value(self.tensor_map.get(load_3d_tensor).op.attrs['pad'][3]),
            self._get_value(self.tensor_map.get(load_3d_tensor).op.attrs['kernel_size'][2]),
            self._get_value(self.tensor_map.get(load_3d_tensor).op.attrs['kernel_size'][3]),
            self._get_value(self.tensor_map.get(load_3d_tensor).op.attrs['dilation'][2]),
            self._get_value(self.tensor_map.get(load_3d_tensor).op.attrs['dilation'][3]))
        return load3d_params

    def _set_tiling_info_dict(self):
        dw_cc = self.tensor_map.get("dw_cc")
        split_axis_mode = DynamicParams.flag_load3d_w_split_case
        group_dict = self.tensor_map.get("fmap_matrix").op.attrs['group_dict']
        self.kernel_name = str(self.tensor_map.get("dw_ddr").op.attrs["kernel_name"])

        # type of group_dict is tvm.container.StrMap not dict
        cin1_g = self._get_value(group_dict["cin1_g"])
        cout_g = self._get_value(group_dict["cout_g"])
        real_g = self._get_value(group_dict["real_g"])

        batch_grads, _, height_grads, width_grads, c0_grads = cube_util.shape_to_list(
            self.tensor_map.get("grads").shape)
        grads_shape = [batch_grads, cout_g // c0_grads, height_grads, width_grads, c0_grads]
        batch_fmap, _, height_fmap, width_fmap, c0_fmap = cube_util.shape_to_list(self.tensor_map.get("fmap").shape)
        fmap_shape = [batch_fmap, cin1_g, height_fmap, width_fmap, c0_fmap]

        (stride_height, stride_width, pad_up, pad_down, pad_left, pad_right, kernel_height, kernel_width,
         dilation_height, dilation_width) = self._get_load3d_para()
        weight_shape = [cout_g, cin1_g, kernel_height, kernel_width, c0_fmap]
        tiling_dtype = get_inout_dtype(self.tensor_map.get("grads"), self.tensor_map.get("fmap"), dw_cc,
                                       "Conv2DBackpropFilter")

        self.tiling_info_dict = {
            "op_type": "conv2d_backprop_filter",
            "A_shape": list(grads_shape),
            "B_shape": list(fmap_shape),
            "C_shape": list(weight_shape),
            "A_dtype": str(tiling_dtype[A_DTYPE_INDEX]),
            "B_dtype": str(tiling_dtype[B_DTYPE_INDEX]),
            "C_dtype": str(tiling_dtype[C_DTYPE_INDEX]),
            "mad_dtype": str(tiling_dtype[MAD_DTYPE_INDEX]),
            "padl": pad_left,
            "padr": pad_right,
            "padu": pad_up,
            "padd": pad_down,
            "strideH": stride_height,
            "strideW": stride_width,
            "strideH_expand": 1,
            "strideW_expand": 1,
            "dilationH": dilation_height,
            "dilationW": dilation_width,
            "group": real_g,
            "bias_flag": 0,
            "fused_double_operand_num": 0,
            "fusion_type": 0,
            "kernel_name": self.kernel_name,
            "split_axis_mode": split_axis_mode,
        }

    def _support_optiling(self, is_binary_const=True):
        """
        Determine whether it is supported dyn_const_tiling and cache_tiling
        """
        if tvm.api_config.query_bit_width() == 64:
            return False

        def _is_c04_opti():
            return fmap_c0 <= C04_SIZE

        fmap_shape = self.tiling_info_dict.get("B_shape")
        _, _, _, _, fmap_c0 = fmap_shape

        if is_binary_const:
            if _is_c04_opti():
                return False

        return True

    def _get_default_tiling(self):
        """
        get default tiling for conv2dbpfilter
        """
        l1_size = tbe_platform_info.get_soc_spec("L1_SIZE")
        corenum = tbe_platform_info.get_soc_spec("CORE_NUM")
        l0c_size = tbe_platform_info.get_soc_spec("L0C_SIZE")
        l0b_size = tbe_platform_info.get_soc_spec("L0B_SIZE")

        def _get_factors(val, val_max):
            """
            get the factor of val that smaller than val_max
            """
            factor_max = min(val, val_max)
            for m_fac in range(factor_max, 0, -1):
                if val % m_fac == 0:
                    return m_fac
            return 1

        def _get_nbl0():
            """
            nbl0 can not too large to over space.
            nbl0 can be 1, kernel_width, kernel_width * kernel_height
            1024 = 16 * 16 * 2 (byte) * 2 (double_buffer)
            """
            split_axis_mode = self.tiling_info_dict.get("split_axis_mode")
            kernel_height, kernel_width = self.tiling_info_dict.get("C_shape")[2:4]
            if split_axis_mode == 1:
                # Enable single-line load for Hi
                nbl0 = kernel_width if kernel_width <= l0b_size // KILO_BYTE else 1
            elif kernel_width * kernel_height <= l0b_size // KILO_BYTE:
                nbl0 = kernel_width * kernel_height
            elif kernel_width <= l0b_size // KILO_BYTE:
                nbl0 = kernel_width
            else:
                nbl0 = 1
            return nbl0

        def _get_kbl1():
            """
            give the max kbl1 that fmap load kernel_h
            or kernel_h+stride_h in the hi direction in L1
            """
            # For w-split mode, set Ho_single_core to 1
            if self.tiling_info_dict.get("split_axis_mode") == 1:
                return CUBE_DIM
            width_grads = self.tiling_info_dict.get("A_shape")[-2]
            if width_grads < CUBE_DIM:
                return CUBE_DIM
            if width_grads % CUBE_DIM == 0:
                return width_grads

            kbl1_before = width_grads // CUBE_DIM
            # if kbl1_before is not factor of K, it needs to recalculate
            c_k1 = ceil_div(hw_pad_1, CUBE_DIM)
            k_npart = ceil_div(c_k1, kbl1_before)
            kbl1 = c_k1 // k_npart * CUBE_DIM
            return kbl1

        def _cal_bl1size():
            """
            calculate bl1_size, if kbl1 is a factor of Wo,
            it must loads Hk in H direction
            else it must loads Hk+stride_h in H direction
            """
            width_fmap = self.tiling_info_dict.get("B_shape")[-2]
            stride_height = self.tiling_info_dict.get("strideH")
            stride_width = self.tiling_info_dict.get("strideW")
            kernel_height, kernel_width = self.tiling_info_dict.get("C_shape")[2:4]
            dilation_height = self.tiling_info_dict.get("dilationH")
            dilation_width = self.tiling_info_dict.get("dilationW")
            in_dtype = self.tiling_info_dict.get("B_dtype")
            width_grads = self.tiling_info_dict.get("A_shape")[-2]
            if self.tiling_info_dict.get("split_axis_mode") == 1:
                # w-split mode, load size of Hi is 1
                bl1_size = ((CUBE_DIM - 1) * stride_width +
                            (kernel_width - 1) * dilation_width + 1) * CUBE_DIM * BIT_RATIO_DICT.get(in_dtype, 2)
                return bl1_size
            if width_grads % kbl1 == 0:
                phol1 = 1
            else:
                phol1 = 2
            pbl1hi = (phol1 - 1) * stride_height + (kernel_height - 1) * dilation_height + 1
            bl1_size = pbl1hi * width_fmap * CUBE_DIM * BIT_RATIO_DICT.get(in_dtype, 2)
            return bl1_size

        fp32_input_flag = self.tiling_info_dict.get("A_dtype") == "float32" and self.tiling_info_dict.get(
            "B_dtype") == "float32"
        nbl0 = _get_nbl0()
        l0c_mal0_max = (l0c_size // KILO_BYTE // 2 // nbl0) if fp32_input_flag else (l0c_size // KILO_BYTE // nbl0)
        l0a_mal0_max = l0b_size // KILO_BYTE
        _, c1_grads, _, _, _ = cube_util.shape_to_list(self.tensor_map.get("grads").shape)
        if self.tiling_info_dict.get("split_axis_mode") == 0:
            _, hw_pad_1, _, _, _, _ = cube_util.shape_to_list(self.tensor_map.get("fmap_fractal").shape)
        mal0 = _get_factors(c1_grads, min(l0c_mal0_max, l0a_mal0_max))
        kbl1 = _get_kbl1()

        batch_grads, _, height_grads, _, _ = cube_util.shape_to_list(self.tensor_map.get("grads").shape)
        block_batch = _get_factors(batch_grads, corenum)
        block_k = _get_factors(height_grads, corenum // block_batch)
        aub_shape = [block_k, 0, 0, 0] if self.tiling_info_dict.get("split_axis_mode") == 1 else None
        out_dtype = self.tiling_info_dict.get("C_dtype").lower()

        if nbl0 * mal0 * CUBE_DIM * CUBE_DIM * BIT_RATIO_DICT.get(out_dtype, 4) * OPEN_DOUBLE_BUFFER < l0c_size:
            cl0_pbuffer = 2
        else:
            cl0_pbuffer = 1

        bl1_size = _cal_bl1size()
        in_dtype = self.tiling_info_dict.get("B_dtype")
        al1_size = mal0 * CUBE_MUL_SHAPE * BIT_RATIO_DICT.get(in_dtype, 2)
        if al1_size * OPEN_DOUBLE_BUFFER + bl1_size <= l1_size:
            bl1_pbuffer = 2
        elif al1_size + bl1_size <= l1_size:
            bl1_pbuffer = 1
        else:
            bl1_pbuffer = 1
            mal0 = 1

        if self.tensor_map.get("fmap_fractal").op.tag == "fmap_2_fractal_dma":
            kbl1 = CUBE_DIM
            mal0 = 1
            nbl0 = 1

        mal1 = MULTI_M_AL1_MIN
        if DynamicParams.dma_c04_flag:
            kernel_height, kernel_width = self.tiling_info_dict.get("C_shape")[2:4]
            row_major_c04 = C04_SIZE
            n_single_core = ceil_div(kernel_width * kernel_height * row_major_c04, BLOCK_SIZE)
            nbl0 = n_single_core
            mal1 = mal0
            mal0 = 1
        al0_matrix = [mal0, 2, CUBE_DIM, CUBE_DIM // 2, 1] if fp32_input_flag else [mal0, 1, CUBE_DIM, CUBE_DIM, 1]
        bl0_matrix = [2, nbl0, CUBE_DIM, CUBE_DIM // 2, 1] if fp32_input_flag else [1, nbl0, CUBE_DIM, CUBE_DIM, 1]
        return {
            'AUB_shape': aub_shape,
            'BUB_shape': None,
            'AL1_shape': [CUBE_DIM, mal1, 1, 1],
            'BL1_shape': [kbl1, 1, 1, 1],
            'AL0_matrix': al0_matrix,
            'BL0_matrix': bl0_matrix,
            'CL0_matrix': [nbl0, mal0, CUBE_DIM, CUBE_DIM, 1],
            'CUB_matrix': [nbl0, mal0, CUBE_DIM, CUBE_DIM, 1],
            'block_dim': [block_batch, 1, 1, 1],
            'cout_bef_batch_flag': 0,
            'A_overhead_opt_flag': 0,
            'B_overhead_opt_flag': 0,
            'manual_pingpong_buffer': {
                'AUB_pbuffer': 1,
                'BUB_pbuffer': 1,
                'AL1_pbuffer': 1,
                'BL1_pbuffer': bl1_pbuffer,
                'AL0_pbuffer': 2,
                'BL0_pbuffer': 2,
                'CL0_pbuffer': cl0_pbuffer,
                'CUB_pbuffer': cl0_pbuffer,
                'UBG_pbuffer': 1
            }
        }
