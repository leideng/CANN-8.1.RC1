#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
pooling tilingcase
"""
from tbe.common.utils import decode
from tbe.common.utils import do_op_tiling
from tbe.dsl.base.operation import add_compile_info_inner
from tbe.dsl.base.operation import get_compile_info
from tbe.dsl.base.operation import get_context
from tbe.dsl.base.operation import register_build_pointcut
from tbe.tvm.tir.expr import ConstExpr
from tbe.tvm.tir import Select

from .pooling_helper import PoolingConstants
from .pooling_helper import PoolingSchType
from .pooling_helper import reorder_reduce_window_shape
from .pooling_helper import raise_error
from .pooling_info import PoolingComputeInfo
from .pooling_info import PoolingSocInfo
from ... import util
from ...computation import Computation
from ...constants import CompileInfo
from ...constants import Pattern
from ...constants import PoolingPattern


class CalcPoolingTilingCase(Computation):
    """
    calculate pooling tiling case
    """
    def __init__(self, outs, option):
        self.outs = outs
        self.option = option

    @classmethod
    def get_instance(cls, outs, option):
        return cls(outs, option)

    @classmethod
    def get_supported_pattern(cls):
        return [Pattern.POOLING]

    @classmethod
    def get_supported_soc(cls):
        return ["default"]

    def get_sub_pattern(self):
        return PoolingPattern.P_0

    def do_tiling_case(self):
        outs = list(self.outs) if isinstance(self.outs, (list, tuple)) else [self.outs]

        current_compute = get_context().get_current_compute()
        # construct information of graph and add to ComputeContext
        compute_info = PoolingComputeInfo(outs)
        current_compute.add("_compute_info", compute_info)

        tiling_case_list = []
        tiling_case_list += _add_tiling_case(compute_info)
        _apply_compile_info(compute_info)

        return tiling_case_list


def _apply_compile_info(compute_info: PoolingComputeInfo):
    # common info
    core_num = PoolingSocInfo.get_core_num()
    min_block_size = PoolingSocInfo.get_block_size(compute_info.graph_info.min_type)
    common_info = [core_num, min_block_size]
    add_compile_info_inner("_common_info", common_info)


def _add_dyn_tiling_case(compute_info: PoolingComputeInfo):
    res_shape = compute_info.base_info.after_reduce_shape
    tiling_case_list = []

    for block_split_axis in range(len(res_shape)):
        for ub_split_axis in range(len(res_shape)):
            for _, sch_type in PoolingSchType.__members__.items():
                tiling_case = PoolingTilingCase(compute_info, block_split_axis, ub_split_axis, sch_type)
                if tiling_case.check_valid():
                    tiling_case_list.append(tiling_case)

    return tiling_case_list


def _add_const_tiling_case(compute_info: PoolingComputeInfo):
    tiling_case_list = []
    tiling_case = PoolingTilingCase(compute_info, enable_db=True)
    tiling_case_list.append(tiling_case)
    tiling_case = PoolingTilingCase(compute_info)
    tiling_case_list.append(tiling_case)
    tiling_case = PoolingTilingCase(compute_info, sch_type=PoolingSchType.WINDOW_SPLIT)
    tiling_case_list.append(tiling_case)

    return tiling_case_list


def _add_tiling_case(compute_info: PoolingComputeInfo):
    if compute_info.base_info.mode == PoolingConstants.CONST:
        return _add_const_tiling_case(compute_info)

    return _add_dyn_tiling_case(compute_info)


def _pooling_pre_build():
    """
    pre build of pooling sch
    """
    pass


def _pooling_post_build():
    """
    post build of pooling sch
    """
    def _encode_var_name(_var_names):
        after_encode_name = []
        for name in _var_names:
            names = name[1:].split('_')
            if names[0] == 'dim':
                after_encode_name.append(10000 + int(names[1]))
            elif names[0] == 'block':
                after_encode_name.append(20000)
            elif names[0] == 'ub':
                after_encode_name.append(30000)
            elif names[0] == 'dimension':
                after_encode_name.append(40000 + int(names[1]))
            elif names[0] == 'stride':
                after_encode_name.append(50000 + int(names[1]))
            elif names[0] == 'dilation':
                after_encode_name.append(60000 + int(names[1]))
            elif names[0] == 'padding':
                after_encode_name.append(70000 + int(names[1]))
            else:
                raise_error("unknown var name in pooling schedule, please check")

        return after_encode_name

    normal_vars = get_compile_info().get(CompileInfo.NORMAL_VARS)
    pooling_vars = {}
    for tiling_key, var_names in normal_vars.items():
        pooling_vars[tiling_key] = _encode_var_name(var_names)
    add_compile_info_inner("_pooling_vars", pooling_vars)


@register_build_pointcut(pattern=Pattern.POOLING)
def build_pointcut(func, *args, **kwargs):
    """
    pooling build pointcut
    """
    _pooling_pre_build()
    func(*args, **kwargs)
    _pooling_post_build()


class PoolingTilingCase:
    """
    class for pooling tiling case
    """
    def __init__(self, compute_info: PoolingComputeInfo, block_idx=None, ub_idx=None,
                 sch_type=PoolingSchType.COMMON, enable_db=False):
        """
        init tiling case
        """
        self.compute_info: PoolingComputeInfo = compute_info
        self.block_split_axis_index = block_idx
        self.ub_split_axis_index = ub_idx
        self.ori_sch_type = sch_type
        self.sch_type = sch_type

        self.block_factor = None
        self.ub_factor = None
        self.multi_core = True

        self.is_const = compute_info.base_info.mode == PoolingConstants.CONST
        self.is_enable_db = enable_db

        self.sch_key = self.calc_sch_key()
        self.mode_key = self.calc_mode_key()
        self.pattern_key = self.calc_pattern_key()
        self.tiling_key = self.calc_tiling_key()

        self.ori_sch_type = sch_type
        self.ori_is_enable_db = enable_db

    def check_valid(self):
        """
        check current tilingcase is valid
        """
        if self.block_split_axis_index is None or self.ub_split_axis_index is None:
            return True

        shape_to_split = util.shape_to_list(self.compute_info.base_info.after_reduce_shape)

        if len(shape_to_split) - 1 == self.block_split_axis_index:
            return False

        if len(shape_to_split) - 1 == self.ub_split_axis_index:
            return False

        # common sch axes has been fused
        if self.sch_type == PoolingSchType.COMMON:
            if self.block_split_axis_index != 0:
                return False

        if self.sch_type == PoolingSchType.WINDOW_SPLIT:
            if self.ub_split_axis_index not in self.compute_info.base_info.window_indices:
                return False

        return True

    def check_consistency(self):
        """
        check consistency of init and cur
        """
        if self.ori_sch_type != self.sch_type:
            return False

        if self.ori_is_enable_db != self.is_enable_db:
            return False

        return True

    def calc_const_tiling(self):
        """
        get const tiling
        """
        def _construct_input_and_output():
            _inputs = []
            for _single_tensor in self.compute_info.graph_info.input_tensor_set:
                _inputs.append({"shape": util.shape_to_list(_single_tensor.shape),
                                "dtype": _single_tensor.dtype})

            _outputs = []
            for _single_tensor in self.compute_info.graph_info.real_output_tensor_set:
                _output_shape = []
                for _dim in _single_tensor.shape:
                    if isinstance(_dim, Select):
                        _dim_value = _dim.true_value if _dim.condition.value else _dim.false_value
                        _output_shape.append(_dim_value.value)
                    elif isinstance(_dim, ConstExpr):
                        _output_shape.append(_dim.value)
                    else:
                        _output_shape.append(_dim)
                _outputs.append({"shape": _output_shape, "dtype": _single_tensor.dtype})

            return _inputs, _outputs

        def _save_ori_info(_ori_info):
            _compile_info = get_compile_info()
            _ori_info["_ori_window_axes"] = _compile_info.get("_ori_window_axes")
            _ori_info["_ori_window_info"] = _compile_info.get("_ori_window_info")

            if "_disable_fuse_axes" in _compile_info:
                _disable_fuse_axes = _compile_info.get("_disable_fuse_axes")
                _compile_info["_disable_fuse_axes"] = []
                _ori_info["_disable_fuse_axes"] = _disable_fuse_axes

        def _update_compile_info(_window_axes, _window_info):
            if _window_axes is not None:
                add_compile_info_inner("_ori_window_axes", _window_axes)
            if _window_info is not None:
                add_compile_info_inner("_ori_window_info", _window_info)

        def _rollback_ori_info_in_compile_info(_ori_info):
            _compile_info = get_compile_info()
            if "_disable_fuse_axes" in _compile_info:
                _compile_info["_disable_fuse_axes"] = _ori_info.get("_disable_fuse_axes")

            if "_ori_window_axes" in _compile_info:
                _compile_info["_ori_window_axes"] = _ori_info.get("_ori_window_axes")

            if "_ori_window_info" in _compile_info:
                _compile_info["_ori_window_info"] = _ori_info.get("_ori_window_info")

        if not self.is_const:
            raise_error("do const tiling while mode is not const, please check")

        add_compile_info_inner("_is_const", True)

        # the flag of invoking op_tiling interface during compilation
        add_compile_info_inner("_is_const_post", False)
        ori_info = {}
        # save before fuse info
        _save_ori_info(ori_info)
        # update compile info with after fuse info
        _update_compile_info(self.compute_info.base_info.window_indices, self.compute_info.base_info.window_info)

        inputs, outputs = _construct_input_and_output()
        run_info = do_op_tiling("AutoTiling", get_compile_info(), inputs, outputs)
        tiling_format = {"block_axis": "int", "block_factor": "int",
                         "ub_axis": "int", "ub_factor": "int", "sch_type": "int"}
        tiling_data = decode(run_info.get("tiling_data"), tiling_format)
        self.parse_and_update_sch_key(tiling_data.get("sch_type"))
        self.tiling_key = self.calc_tiling_key()

        self.block_split_axis_index = tiling_data.get("block_axis")
        self.block_factor = tiling_data.get("block_factor")
        self.ub_split_axis_index = tiling_data.get("ub_axis")
        self.ub_factor = tiling_data.get("ub_factor")
        self.multi_core = run_info.get("block_dim") > 1

        # the flag of invoking op_tiling interface during running
        add_compile_info_inner("_is_const_post", True)
        # rollback before fuse info
        _rollback_ori_info_in_compile_info(ori_info)

        block_dims = get_compile_info().get("_const_block_dims")
        if block_dims is None:
            block_dims = {}
            add_compile_info_inner("_const_block_dims", block_dims)
        block_dims[self.tiling_key] = run_info.get("block_dim")

    def calc_sch_key(self):
        """
        calculate sch key, including sch_type and is_enable_db
        """
        type_key = 0x1 if self.sch_type == PoolingSchType.WINDOW_SPLIT else 0x0

        return (type_key << 1) + int(self.is_enable_db)

    def parse_and_update_sch_key(self, sch_key):
        """
        parse and update sch key, including sch_type and is_enable_db
        """
        self.sch_key = sch_key
        type_key = sch_key >> 1
        self.sch_type = PoolingSchType.WINDOW_SPLIT if type_key == 1 else PoolingSchType.COMMON
        self.is_enable_db = bool(sch_key % 2)

    def calc_mode_key(self):
        """
        calculate mode key(0xFFF is const)
        """
        mode_key = PoolingConstants.CONST_MODE_KEY if self.is_const else self.sch_key

        return mode_key

    def calc_pattern_key(self):
        """
        calculate pooling pattern: strategy_pattern + window pattern
        """
        def _get_window_reduce_pattern_key(_axis_list):
            _pattern = 0x0
            for _i in range(shape_len):
                if _i in _axis_list:
                    _pattern += 0x2 << (shape_len - _i - 1)
                else:
                    _pattern += 0x1 << (shape_len - _i - 1)

            return _pattern

        shape_len = len(self.compute_info.base_info.ori_input_shape)
        window_reduce_pattern_key = _get_window_reduce_pattern_key(self.compute_info.base_info.window_indices)

        strategy_key = 0x0
        if not self.is_const:
            for single_window_type in self.compute_info.base_info.strategy:
                strategy_key = \
                    (strategy_key << 4) + PoolingConstants.WINDOW_AXES_TYPE_AND_KEY_MAP.get(single_window_type)

        return (strategy_key << 3 * 4) + window_reduce_pattern_key

    def calc_tiling_key(self):
        """
        uint64 hex
        0-1: schedule type, 0x1B(pooling)
        2-3: reverse
        4-6: mode, 0xfff(const)
        7-13: pooling pattern
        14: block axis, 0xf(None)
        15: ub axis, 0xf(None)
        """
        block_tiling_key = 0xf if self.block_split_axis_index is None else self.block_split_axis_index
        ub_tiling_key = 0xf if self.ub_split_axis_index is None else self.ub_split_axis_index

        return (PoolingConstants.POOLING_SCH_ID << 14 * 4) + (self.mode_key << 9 * 4) + (self.pattern_key << 2 * 4) + \
            (block_tiling_key << 4) + ub_tiling_key
