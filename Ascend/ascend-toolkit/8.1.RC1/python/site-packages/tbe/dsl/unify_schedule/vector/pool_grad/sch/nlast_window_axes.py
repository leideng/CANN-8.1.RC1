#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright 2023-2024 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
nlast window axes schedule
"""

from tbe.dsl.compute.constants import ComputeType
from tbe.dsl.unify_schedule import schedule
from tbe.dsl.unify_schedule.constants import Pattern
from tbe.dsl.unify_schedule.constants import PoolGradPattern
from tbe.dsl.unify_schedule.vector.pool_grad import pool_grad_schedule
from tbe.dsl.unify_schedule.vector.pool_grad import pool_grad_tilingcase


class NlastWindowAxes(pool_grad_schedule.PoolGradSchedule, schedule.Schedule):
    """
    Support nlast window axis pooling, contains:
    1. (n, h, w, c)
    2. (n, d, h, w, c)
    3. (n, c1, h, w, c0)
    4. (n, d, c1, h, w, c0)
    """

    @classmethod
    def get_supported_pattern(cls):
        return [Pattern.POOL_GRAD]

    @classmethod
    def get_supported_sub_pattern(cls):
        return PoolGradPattern.NLAST_WINDOW_AXIS

    def _get_coexist(self):
        # 'TODO, should be 3
        # 'coexist = 4
        # 'if self._tiling_case.strategy in (pool_grad_tilingcase.Strategy.UB_AT_BLOCK_A,
        # '                                  pool_grad_tilingcase.Strategy.UB_AT_BLOCK_R,
        # '                                  pool_grad_tilingcase.Strategy.UB_RK_BLOCK_A,
        # '                                  pool_grad_tilingcase.Strategy.UB_RK_BLOCK_R):
        # '    coexist += 1
        return 5

    def _do_align(self):
        align_factor = self._get_align_factor()
        stages = self._sch.get_stages(compute_type=ComputeType.DMA_IN)
        for x in stages:
            x.storage_align(x.op.axis[-2], align_factor, 0)

        for x in self._sch.get_stages(scope="local.UB"):
            if x in stages or x.is_scan_state() or x.is_scan_update():
                continue

            if x.is_scan():
                x.compute_align(x.op.spatial_axis_[-1], align_factor)
                continue

            x.compute_align(x.op.axis[-1], align_factor)

        align_k_factor = self._get_k_align_factor()
        for x in self._sch.get_stages(dtype="uint1"):
            if x.is_scan_state() or x.is_scan_update():
                continue

            if x.is_scan():
                x.storage_align(x.op.scan_axis, align_k_factor, 0)
                continue

            x.storage_align(x.op.axis[0], align_k_factor, 0)
