#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
extract_image_patches format NCHW schedule
"""
from tbe import tvm
from tbe.common import platform as tbe_platform
from tbe.dsl.base.operation import get_compile_info


class EIPNCHWSchedule:
    def __init__(self, outs, tiling_case):
        self.outs = outs
        self.y = outs[0]
        self.sch = tvm.create_schedule(self.y.op)
        self.sch.tiling_key = tiling_case.key

        self.dtype = self.y.dtype
        c0_dict = {"int8": 32, "uint8": 32, "int16": 16, "float16": 16, "float32": 16}
        self.c0 = c0_dict.get(self.dtype)
        elems_per_block_dict = {"int8": 32, "uint8": 32, "int16": 16, "float16": 16, "float32": 8}
        self.elems_per_block = elems_per_block_dict.get(self.dtype)
        block_num = (tbe_platform.get_soc_spec("UB_SIZE") - 1024) // 32  # 1024: remain 1k for scalar
                                                                         # 32: bytes per block
        self.max_elem_num = self.elems_per_block * block_num

        self.n, self.c, self.hi, self.wi, \
                self.kh, self.kw, self.sh, self.sw, self.rh, self.rw, self.padding, \
                self.ho, self.wo, \
                self.n_factor, self.c_factor, self.kh_factor, self.kw_factor, \
                self.ho_factor, self.wo_factor, self.ub_factor = self.y.op.attrs.get("params")

        computes = self.y.op.attrs.get("computes")
        if self.padding == "VALID":
            self.x, self.x_ub, self.x_nhwc, self.y_nhwc, self.y_ub = computes
        else:
            self.x, self.x_ub, self.x_nhwc, self.padding_computes, self.x_p, self.y_nhwc, self.y_ub = computes

        self.is_const = get_compile_info().get("isConst")

        self.compute_at_axis = None
        self.emit_insn_axis = None
        self.x_ub_inline = False
        self.y_ub_inline = False

    def do_schedule(self):
        self._do_set_scope()

        if self.sch.tiling_key == 20001:
            self._cut_n()
        elif self.sch.tiling_key == 20002:
            self._cut_nc()
        elif self.sch.tiling_key == 20003:
            self._cut_nkh()
        elif self.sch.tiling_key == 20004:
            self._cut_nckh()
        elif self.sch.tiling_key == 20005:
            self._cut_nkhc()
        elif self.sch.tiling_key == 20006:
            self._cut_nkhkwhoc()
        elif self.sch.tiling_key == 20007:
            self._cut_nkhkwhowo()
        else:
            self._cut_nckhkwhowo()

        self._do_compute_at()
        self._do_emit_insn()

        return self.sch

    def _do_set_scope(self):
        for _ in [self.x_ub, self.x_nhwc, self.y_nhwc, self.y_ub]:
            self.sch[_].set_scope("local.UB")
            self.sch[_].set_buffer_size(self.max_elem_num // 3)
        if self.padding == "SAME" or self.padding == "CALCULATED":
            for _ in self.padding_computes:
                self.sch[_].set_scope("local.UB")
                self.sch[_].set_buffer_size(self.max_elem_num // 3)
                self.sch[_].reused_by(self.x_p)
            self.sch[self.x_p].set_scope("local.UB")
            self.sch[self.x_p].set_buffer_size(self.max_elem_num // 3)

    def _do_compute_at(self):
        if not self.x_ub_inline:
            self.sch[self.x_ub].compute_at(self.sch[self.y], self.compute_at_axis)
        for _ in [self.x_nhwc, self.y_nhwc]:
            self.sch[_].compute_at(self.sch[self.y], self.compute_at_axis)
        if self.padding == "SAME" or self.padding == "CALCULATED":
            for _ in [*self.padding_computes, self.x_p]:
                self.sch[_].compute_at(self.sch[self.y], self.compute_at_axis)
        if not self.y_ub_inline:
            self.sch[self.y_ub].compute_at(self.sch[self.y], self.compute_at_axis)

    def _do_emit_insn(self):
        if not self.x_ub_inline:
            self.sch[self.x_ub].emit_insn(self.x_ub.op.axis[0], "dma_copy")

            src_in_dst_ord_0 = tvm.call_intrin("handle", "tir.tvm_tuple", *(0, 2, 3, 1))
            if self.dtype in ["float32"]:
                self.sch[self.x_nhwc].emit_insn(
                    self.x_nhwc.op.axis[0],
                    "vector_transpose",
                    attrs={"src_in_dst_order": src_in_dst_ord_0, "is_trans_align": 1, "enable_vnchwconv_b32": 1})
            else:
                self.sch[self.x_nhwc].emit_insn(
                    self.x_nhwc.op.axis[0],
                    "vector_transpose",
                    attrs={"src_in_dst_order": src_in_dst_ord_0, "is_trans_align": 1})
        else:
            self.sch[self.x_nhwc].emit_insn(self.x_nhwc.op.axis[0], "dma_copy")

        if self.padding == "SAME" or self.padding == "CALCULATED":
            self.sch[self.x_p].emit_insn(self.x_p.op.axis[0], "dma_copy")
            for _ in self.padding_computes:
                self.sch[_].emit_insn(_.op.axis[0], "dma_copy", {"split_select": 1})

        if self.dtype == "int16":
            self.sch[self.y_nhwc].emit_insn(self.y_nhwc.op.axis[0], "dma_copy")
        else:
            self.sch[self.y_nhwc].emit_insn(self.y_nhwc.op.axis[0], "vector_adds")

        if not self.y_ub_inline:
            src_in_dst_ord_1 = tvm.call_intrin("handle", "tir.tvm_tuple", *(0, 5, 1, 2, 3, 4))
            if self.dtype in ["float32"]:
                self.sch[self.y_ub].emit_insn(
                    self.y_ub.op.axis[0],
                    "vector_transpose",
                    attrs={"src_in_dst_order": src_in_dst_ord_1, "is_trans_align": 1, "enable_vnchwconv_b32": 3})
            else:
                self.sch[self.y_ub].emit_insn(
                    self.y_ub.op.axis[0],
                    "vector_transpose",
                    attrs={"src_in_dst_order": src_in_dst_ord_1, "is_trans_align": 1})

        self.sch[self.y].emit_insn(self.emit_insn_axis, "dma_copy")

    def _cut_n(self):
        # (ub_factor, c, kh, kw, ho, wo) per loop
        y_n_o, y_n_i = self.sch[self.y].split(self.y.op.axis[0], factor=self.n_factor)
        y_n_i_o, y_n_i_i = self.sch[self.y].split(y_n_i, factor=self.ub_factor)
        self.sch.bind_axes([y_n_o], tvm.thread_axis("blockIdx.x"))
        self.compute_at_axis = y_n_i_o
        self.emit_insn_axis = y_n_i_i

        # x_ub (ub_factor, c, hi, wi)
        if self.is_const and self.kh * self.ho * self.wi == 1:
            self.sch[self.x_ub].compute_inline()
            self.x_ub_inline = True
        else:
            self.sch[self.x_ub].storage_align(self.sch[self.x_ub].op.axis[1], self.elems_per_block, 0)
            self.sch[self.x_ub].compute_align(self.sch[self.x_ub].op.axis[3], self.wi)
            if not self.is_const:
                group_id_0 = tvm.call_extern("int32", "axis_group", 0, "overwrite")
                for _ in self.x_ub.op.axis[2:]:
                    self.sch[self.x_ub].pragma(_, "axis_group", group_id_0)

        # x_nhwc (ub_factor, hi, wi, c)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[3], self.c0)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[2], self.wi)
        c_align = (self.c + self.c0 - 1) // self.c0 * self.c0
        self.sch[self.x_nhwc].storage_align(self.sch[self.x_nhwc].op.axis[0], self.elems_per_block * c_align, 0)
        if not self.is_const:
            group_id_1 = tvm.call_extern("int32", "axis_group", 1, "overwrite")
            for _ in self.x_nhwc.op.axis[1:3]:
                self.sch[self.x_nhwc].pragma(_, "axis_group", group_id_1)

        if self.padding == "SAME" or self.padding == "CALCULATED":
            # (ub_factor, hi_p, wi_p, c)
            for _ in [*self.padding_computes, self.x_p]:
                self.sch[_].compute_align(self.sch[_].op.axis[3], self.c0)

        # y_nhwc (ub_factor, kh, kw, ho, wo, c)
        self.sch[self.y_nhwc].compute_align(self.sch[self.y_nhwc].op.axis[5], self.c0)

        # y_ub (ub_factor, c, kh, kw, ho, wo)
        if self.is_const and self.kh * self.kw * self.ho * self.wo == 1:
            self.sch[self.y_ub].compute_inline()
            self.y_ub_inline = True
        elif self.is_const and self.c == 1:
            pass
        else:
            self.sch[self.y_ub].storage_align(self.sch[self.y_ub].op.axis[1], self.elems_per_block, 0)
            khkwhowo_align = (self.kh * self.kw * self.ho * self.wo + self.elems_per_block - 1) // \
                self.elems_per_block * self.elems_per_block
            self.sch[self.y_ub].storage_align(self.sch[self.y_ub].op.axis[0], self.c0 * khkwhowo_align, 0)
            if not self.is_const:
                group_id_2 = tvm.call_extern("int32", "axis_group", 2, "overwrite")
                for _ in self.y_ub.op.axis[2:]:
                    self.sch[self.y_ub].pragma(_, "axis_group", group_id_2)

        # y (ub_factor, c, kh, kw, ho, wo)
        if not self.is_const:
            group_id_3 = tvm.call_extern("int32", "axis_group", 3, "overwrite")
            for _ in self.y.op.axis[2:]:
                self.sch[self.y].pragma(_, "axis_group", group_id_3)

    def _cut_nc(self):
        # (1, ub_factor, kh, kw, ho, wo) per loop
        y_n_o, y_n_i = self.sch[self.y].split(self.y.op.axis[0], factor=self.n_factor)
        y_c_o, y_c_i = self.sch[self.y].split(self.y.op.axis[1], factor=self.c_factor)
        y_c_i_o, y_c_i_i = self.sch[self.y].split(y_c_i, factor=self.ub_factor)
        self.sch[self.y].reorder(y_n_o, y_c_o, y_n_i, y_c_i_o, y_c_i_i, *self.y.op.axis[2:])
        self.sch.bind_axes([y_n_o, y_c_o], tvm.thread_axis("blockIdx.x"))
        self.compute_at_axis = y_c_i_o
        self.emit_insn_axis = y_c_i_i

        # x_ub (1, ub_factor, hi, wi)
        if self.is_const and self.kh * self.ho * self.wi == 1:
            self.sch[self.x_ub].compute_inline()
            self.x_ub_inline = True
        else:
            self.sch[self.x_ub].storage_align(self.sch[self.x_ub].op.axis[1], self.elems_per_block, 0)
            self.sch[self.x_ub].compute_align(self.sch[self.x_ub].op.axis[3], self.wi)
            if not self.is_const:
                group_id_0 = tvm.call_extern("int32", "axis_group", 0, "overwrite")
                for _ in self.x_ub.op.axis[2:]:
                    self.sch[self.x_ub].pragma(_, "axis_group", group_id_0)

        # x_nhwc (1, hi, wi, ub_factor)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[3], self.c0)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[2], self.wi)
        if not self.is_const:
            group_id_1 = tvm.call_extern("int32", "axis_group", 1, "overwrite")
            for _ in self.x_nhwc.op.axis[1:3]:
                self.sch[self.x_nhwc].pragma(_, "axis_group", group_id_1)

        if self.padding == "SAME" or self.padding == "CALCULATED":
            # (1, hi_p, wi_p, ub_factor)
            for _ in [*self.padding_computes, self.x_p]:
                self.sch[_].compute_align(self.sch[_].op.axis[3], self.c0)

        # y_nhwc (1, kh, kw, ho, wo, ub_factor)
        self.sch[self.y_nhwc].compute_align(self.sch[self.y_nhwc].op.axis[5], self.c0)

        # y_ub (1, ub_factor, kh, kw, ho, wo)
        if self.is_const and self.kh * self.kw * self.ho * self.wo == 1:
            self.sch[self.y_ub].compute_inline()
            self.y_ub_inline = True
        elif self.is_const and self.c == 1:
            pass
        else:
            self.sch[self.y_ub].storage_align(self.sch[self.y_ub].op.axis[1], self.elems_per_block, 0)
            if not self.is_const:
                group_id_2 = tvm.call_extern("int32", "axis_group", 2, "overwrite")
                for _ in self.y_ub.op.axis[2:]:
                    self.sch[self.y_ub].pragma(_, "axis_group", group_id_2)

        # y (1, ub_factor, kh, kw, ho, wo)
        if not self.is_const:
            group_id_3 = tvm.call_extern("int32", "axis_group", 3, "overwrite")
            for _ in self.y.op.axis[2:]:
                self.sch[self.y].pragma(_, "axis_group", group_id_3)

    def _cut_nkh(self):
        # (1, c, ub_factor, kw, ho, wo) per loop
        y_n_o, y_n_i = self.sch[self.y].split(self.y.op.axis[0], factor=self.n_factor)
        y_kh_o, y_kh_i = self.sch[self.y].split(self.y.op.axis[2], factor=self.kh_factor)
        y_kh_i_o, y_kh_i_i = self.sch[self.y].split(y_kh_i, factor=self.ub_factor)
        self.sch[self.y].reorder(y_n_o, y_kh_o, y_n_i, y_kh_i_o, self.y.op.axis[1],
                                 y_kh_i_i, *self.y.op.axis[3:])
        self.sch.bind_axes([y_n_o, y_kh_o], tvm.thread_axis("blockIdx.x"))
        self.compute_at_axis = y_kh_i_o
        self.emit_insn_axis = self.y.op.axis[1]

        # x_ub (1, c, hi, wi)
        if self.is_const and self.ub_factor * self.ho * self.wi == 1:
            self.sch[self.x_ub].compute_inline()
            self.x_ub_inline = True
        else:
            self.sch[self.x_ub].storage_align(self.sch[self.x_ub].op.axis[1], self.elems_per_block, 0)
            self.sch[self.x_ub].compute_align(self.sch[self.x_ub].op.axis[3], self.wi)
            if not self.is_const:
                group_id_0 = tvm.call_extern("int32", "axis_group", 0, "overwrite")
                for _ in self.x_ub.op.axis[2:]:
                    self.sch[self.x_ub].pragma(_, "axis_group", group_id_0)

        # x_nhwc (1, hi, wi, c)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[3], self.c0)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[2], self.wi)
        if not self.is_const:
            group_id_1 = tvm.call_extern("int32", "axis_group", 1, "overwrite")
            for _ in self.x_nhwc.op.axis[1:3]:
                self.sch[self.x_nhwc].pragma(_, "axis_group", group_id_1)

        if self.padding == "SAME" or self.padding == "CALCULATED":
            # (1, hi_p, wi_p, c)
            for _ in [*self.padding_computes, self.x_p]:
                self.sch[_].compute_align(self.sch[_].op.axis[3], self.c0)

        # y_nhwc (1, ub_factor, kw, ho, wo, c)
        self.sch[self.y_nhwc].compute_align(self.sch[self.y_nhwc].op.axis[5], self.c0)

        # y_ub (1, c, ub_factor, kw, ho, wo)
        if self.is_const and self.ub_factor * self.kw * self.ho * self.wo == 1:
            self.sch[self.y_ub].compute_inline()
            self.y_ub_inline = True
        elif self.is_const and self.c == 1:
            pass
        else:
            self.sch[self.y_ub].storage_align(self.sch[self.y_ub].op.axis[1], self.elems_per_block, 0)
            if not self.is_const:
                group_id_2 = tvm.call_extern("int32", "axis_group", 2, "overwrite")
                for _ in self.y_ub.op.axis[2:]:
                    self.sch[self.y_ub].pragma(_, "axis_group", group_id_2)

        # y (1, c, ub_factor, kw, ho, wo)
        if not self.is_const:
            group_id_3 = tvm.call_extern("int32", "axis_group", 3, "overwrite")
            for _ in [y_kh_i_i, *self.y.op.axis[3:]]:
                self.sch[self.y].pragma(_, "axis_group", group_id_3)

    def _cut_nckh(self):
        # (1, c0, ub_factor, kw, ho, wo) per loop
        y_n_o, y_n_i = self.sch[self.y].split(self.y.op.axis[0], factor=self.n_factor)
        y_c_o, y_c_i = self.sch[self.y].split(self.y.op.axis[1], factor=self.c_factor)
        y_kh_o, y_kh_i = self.sch[self.y].split(self.y.op.axis[2], factor=self.kh_factor)
        y_c_i_o, y_c_i_i = self.sch[self.y].split(y_c_i, factor=self.c0)
        y_kh_i_o, y_kh_i_i = self.sch[self.y].split(y_kh_i, factor=self.ub_factor)
        self.sch[self.y].reorder(y_n_o, y_c_o, y_kh_o, y_n_i, y_c_i_o,
                                 y_kh_i_o, y_c_i_i, y_kh_i_i, *self.y.op.axis[3:])
        self.sch.bind_axes([y_n_o, y_c_o, y_kh_o], tvm.thread_axis("blockIdx.x"))
        self.compute_at_axis = y_kh_i_o
        self.emit_insn_axis = y_c_i_i

        # x_ub (1, c0, hi, wi)
        if self.is_const and self.ub_factor * self.ho * self.wi == 1:
            self.sch[self.x_ub].compute_inline()
            self.x_ub_inline = True
        else:
            self.sch[self.x_ub].storage_align(self.sch[self.x_ub].op.axis[1], self.elems_per_block, 0)
            self.sch[self.x_ub].compute_align(self.sch[self.x_ub].op.axis[3], self.wi)
            if not self.is_const:
                group_id_0 = tvm.call_extern("int32", "axis_group", 0, "overwrite")
                for _ in self.x_ub.op.axis[2:]:
                    self.sch[self.x_ub].pragma(_, "axis_group", group_id_0)

        # x_nhwc (1, hi, wi, c0)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[3], self.c0)
        if self.is_const and self.c == 1:
            self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[2], self.elems_per_block)
        else:
            self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[2], self.wi)
        if not self.is_const:
            group_id_1 = tvm.call_extern("int32", "axis_group", 1, "overwrite")
            for _ in self.x_nhwc.op.axis[1:3]:
                self.sch[self.x_nhwc].pragma(_, "axis_group", group_id_1)

        if self.padding == "SAME" or self.padding == "CALCULATED":
            # (1, hi_p, wi_p, c0)
            for _ in [*self.padding_computes, self.x_p]:
                self.sch[_].compute_align(self.sch[_].op.axis[3], self.c0)

        # y_nhwc (1, ub_factor, kw, ho, wo, c0)
        self.sch[self.y_nhwc].compute_align(self.sch[self.y_nhwc].op.axis[5], self.c0)

        # y_ub (1, c0, ub_factor, kw, ho, wo)
        if self.is_const and self.ub_factor * self.kw * self.ho * self.wo == 1:
            self.sch[self.y_ub].compute_inline()
            self.y_ub_inline = True
        elif self.is_const and self.c == 1:
            self.sch[self.y_ub].compute_align(self.sch[self.y_ub].op.axis[3], self.c0)
        else:
            self.sch[self.y_ub].storage_align(self.sch[self.y_ub].op.axis[1], self.elems_per_block, 0)
            if not self.is_const:
                group_id_2 = tvm.call_extern("int32", "axis_group", 2, "overwrite")
                for _ in self.y_ub.op.axis[2:]:
                    self.sch[self.y_ub].pragma(_, "axis_group", group_id_2)

        # y (1, c0, ub_factor, kw, ho, wo)
        if not self.is_const:
            group_id_3 = tvm.call_extern("int32", "axis_group", 3, "overwrite")
            for _ in [y_kh_i_i, *self.y.op.axis[3:]]:
                self.sch[self.y].pragma(_, "axis_group", group_id_3)

    def _cut_nkhc(self):
        # (1, ub_factor, 1, kw, ho, wo) per loop
        y_n_o, y_n_i = self.sch[self.y].split(self.y.op.axis[0], factor=self.n_factor)
        y_c_o, y_c_i = self.sch[self.y].split(self.y.op.axis[1], factor=self.c_factor)
        y_kh_o, y_kh_i = self.sch[self.y].split(self.y.op.axis[2], factor=self.kh_factor,
                                                tail_strategy="shift_inwards")
        y_c_i_o, y_c_i_i = self.sch[self.y].split(y_c_i, factor=self.ub_factor)
        self.sch[self.y].reorder(y_n_o, y_c_o, y_kh_o, y_n_i, y_c_i_o, y_kh_i, y_c_i_i, *self.y.op.axis[3:])
        self.sch.bind_axes([y_n_o, y_c_o, y_kh_o], tvm.thread_axis("blockIdx.x"))
        self.compute_at_axis = y_kh_i
        self.emit_insn_axis = y_c_i_i

        # x_ub (1, ub_factor, hi, wi)
        if self.is_const and self.ho * self.wi == 1:
            self.sch[self.x_ub].compute_inline()
            self.x_ub_inline = True
        else:
            self.sch[self.x_ub].storage_align(self.sch[self.x_ub].op.axis[1], self.elems_per_block, 0)
            self.sch[self.x_ub].compute_align(self.sch[self.x_ub].op.axis[3], self.wi)
            if not self.is_const:
                group_id_0 = tvm.call_extern("int32", "axis_group", 0, "overwrite")
                for _ in self.x_ub.op.axis[2:]:
                    self.sch[self.x_ub].pragma(_, "axis_group", group_id_0)

        # x_nhwc (1, hi, wi, ub_factor)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[3], self.c0)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[2], self.wi)
        if not self.is_const:
            group_id_1 = tvm.call_extern("int32", "axis_group", 1, "overwrite")
            for _ in self.x_nhwc.op.axis[1:3]:
                self.sch[self.x_nhwc].pragma(_, "axis_group", group_id_1)

        if self.padding == "SAME" or self.padding == "CALCULATED":
            # (1, hi_p, wi_p, ub_factor)
            for _ in [*self.padding_computes, self.x_p]:
                self.sch[_].compute_align(self.sch[_].op.axis[3], self.c0)

        # y_nhwc (1, 1, kw, ho, wo, ub_factor)
        self.sch[self.y_nhwc].compute_align(self.sch[self.y_nhwc].op.axis[5], self.c0)

        # y_ub (1, ub_factor, 1, kw, ho, wo)
        if self.is_const and self.kw * self.ho * self.wo == 1:
            self.sch[self.y_ub].compute_inline()
            self.y_ub_inline = True
        elif self.is_const and self.c == 1:
            pass
        else:
            self.sch[self.y_ub].storage_align(self.sch[self.y_ub].op.axis[1], self.elems_per_block, 0)
            if not self.is_const:
                group_id_2 = tvm.call_extern("int32", "axis_group", 2, "overwrite")
                for _ in self.y_ub.op.axis[2:]:
                    self.sch[self.y_ub].pragma(_, "axis_group", group_id_2)

        # y (1, ub_factor, 1, kw, ho, wo)
        if not self.is_const:
            group_id_3 = tvm.call_extern("int32", "axis_group", 3, "overwrite")
            for _ in self.y.op.axis[3:]:
                self.sch[self.y].pragma(_, "axis_group", group_id_3)

    def _cut_nkhkwhoc(self):
        # (1, ub_factor, 1, 1, 1, wo) per loop
        y_n_o, y_n_i = self.sch[self.y].split(self.y.op.axis[0], factor=self.n_factor)
        y_c_o, y_c_i = self.sch[self.y].split(self.y.op.axis[1], factor=self.c_factor)
        y_kh_o, y_kh_i = self.sch[self.y].split(self.y.op.axis[2], factor=self.kh_factor,
                                                tail_strategy="shift_inwards")
        y_kw_o, y_kw_i = self.sch[self.y].split(self.y.op.axis[3], factor=self.kw_factor,
                                                tail_strategy="shift_inwards")
        y_ho_o, y_ho_i = self.sch[self.y].split(self.y.op.axis[4], factor=self.ho_factor,
                                                tail_strategy="shift_inwards")
        y_c_i_o, y_c_i_i = self.sch[self.y].split(y_c_i, factor=self.ub_factor)
        self.sch[self.y].reorder(y_n_o, y_c_o, y_kh_o, y_kw_o, y_ho_o, y_n_i,
                                 y_c_i_o, y_kh_i, y_kw_i, y_ho_i, y_c_i_i, self.y.op.axis[5])
        self.sch.bind_axes([y_n_o, y_c_o, y_kh_o, y_kw_o, y_ho_o], tvm.thread_axis("blockIdx.x"))
        self.compute_at_axis = y_ho_i
        self.emit_insn_axis = y_c_i_i

        # x_ub (1, ub_factor, 1, wi)
        if self.is_const and self.wo == 1:
            self.sch[self.x_ub].compute_inline()
            self.x_ub_inline = True
        else:
            self.sch[self.x_ub].storage_align(self.sch[self.x_ub].op.axis[1], self.elems_per_block, 0)

        # x_nhwc (1, 1, wi, ub_factor)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[3], self.c0)

        if self.padding == "SAME" or self.padding == "CALCULATED":
            # (1, 1, wi_p, ub_factor)
            for _ in [*self.padding_computes, self.x_p]:
                self.sch[_].compute_align(self.sch[_].op.axis[3], self.c0)

        # y_nhwc (1, 1, 1, 1, wo, ub_factor)
        self.sch[self.y_nhwc].compute_align(self.sch[self.y_nhwc].op.axis[5], self.c0)

        # y_ub (1, ub_factor, 1, 1, 1, wo)
        if self.is_const and self.wo == 1:
            self.sch[self.y_ub].compute_inline()
            self.y_ub_inline = True
        elif self.is_const and self.c == 1:
            pass
        else:
            self.sch[self.y_ub].storage_align(self.sch[self.y_ub].op.axis[1], self.elems_per_block, 0)

    def _cut_nkhkwhowo(self):
        # (1, c, 1, 1, 1, ub_factor) per loop
        y_n_o, y_n_i = self.sch[self.y].split(self.y.op.axis[0], factor=self.n_factor)
        y_kh_o, y_kh_i = self.sch[self.y].split(self.y.op.axis[2], factor=self.kh_factor,
                                                tail_strategy="shift_inwards")
        y_kw_o, y_kw_i = self.sch[self.y].split(self.y.op.axis[3], factor=self.kw_factor,
                                                tail_strategy="shift_inwards")
        y_ho_o, y_ho_i = self.sch[self.y].split(self.y.op.axis[4], factor=self.ho_factor,
                                                tail_strategy="shift_inwards")
        y_wo_o, y_wo_i = self.sch[self.y].split(self.y.op.axis[5], factor=self.wo_factor,
                                                tail_strategy="shift_inwards")
        y_wo_i_o, y_wo_i_i = self.sch[self.y].split(y_wo_i, factor=self.ub_factor)
        self.sch[self.y].reorder(y_n_o, y_kh_o, y_kw_o, y_ho_o, y_wo_o, y_n_i, y_kh_i,
                                 y_kw_i, y_ho_i, y_wo_i_o, self.y.op.axis[1], y_wo_i_i)
        self.sch.bind_axes([y_n_o, y_kh_o, y_kw_o, y_ho_o, y_wo_o], tvm.thread_axis("blockIdx.x"))
        self.compute_at_axis = y_wo_i_o
        self.emit_insn_axis = self.y.op.axis[1]

        # x_ub (1, c, 1, wi)
        if self.is_const and self.ub_factor == 1:
            self.sch[self.x_ub].compute_inline()
            self.x_ub_inline = True
        else:
            self.sch[self.x_ub].storage_align(self.sch[self.x_ub].op.axis[1], self.elems_per_block, 0)

        # x_nhwc (1, 1, wi, c)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[3], self.c0)

        if self.padding == "SAME" or self.padding == "CALCULATED":
            # (1, 1, wi_p, c)
            for _ in [*self.padding_computes, self.x_p]:
                self.sch[_].compute_align(self.sch[_].op.axis[3], self.c0)

        # y_nhwc (1, 1, 1, 1, ub_factor, c)
        self.sch[self.y_nhwc].compute_align(self.sch[self.y_nhwc].op.axis[5], self.c0)

        # y_ub (1, c, 1, 1, 1, ub_factor)
        if self.is_const and self.ub_factor == 1:
            self.sch[self.y_ub].compute_inline()
            self.y_ub_inline = True
        elif self.is_const and self.c == 1:
            pass
        else:
            self.sch[self.y_ub].storage_align(self.sch[self.y_ub].op.axis[1], self.elems_per_block, 0)

    def _cut_nckhkwhowo(self):
        # (1, c0, 1, 1, 1, ub_factor) per loop
        y_n_o, y_n_i = self.sch[self.y].split(self.y.op.axis[0], factor=self.n_factor)
        y_c_o, y_c_i = self.sch[self.y].split(self.y.op.axis[1], factor=self.c_factor)
        y_kh_o, y_kh_i = self.sch[self.y].split(self.y.op.axis[2], factor=self.kh_factor,
                                                tail_strategy="shift_inwards")
        y_kw_o, y_kw_i = self.sch[self.y].split(self.y.op.axis[3], factor=self.kw_factor,
                                                tail_strategy="shift_inwards")
        y_ho_o, y_ho_i = self.sch[self.y].split(self.y.op.axis[4], factor=self.ho_factor,
                                                tail_strategy="shift_inwards")
        y_wo_o, y_wo_i = self.sch[self.y].split(self.y.op.axis[5], factor=self.wo_factor,
                                                tail_strategy="shift_inwards")
        y_c_i_o, y_c_i_i = self.sch[self.y].split(y_c_i, factor=self.c0)
        y_wo_i_o, y_wo_i_i = self.sch[self.y].split(y_wo_i, factor=self.ub_factor)
        self.sch[self.y].reorder(y_n_o, y_c_o, y_kh_o, y_kw_o, y_ho_o, y_wo_o, y_n_i, y_c_i_o,
                                 y_kh_i, y_kw_i, y_ho_i, y_wo_i_o, y_c_i_i, y_wo_i_i)
        self.sch.bind_axes(
            [self.y.op.axis[0], y_c_o, *self.y.op.axis[2:5], y_wo_o],
            tvm.thread_axis("blockIdx.x"))
        self.compute_at_axis = y_wo_i_o
        self.emit_insn_axis = y_c_i_i

        # x_ub (1, c0, 1, wi)
        if self.is_const and self.ub_factor == 1:
            self.sch[self.x_ub].compute_inline()
            self.x_ub_inline = True
        else:
            self.sch[self.x_ub].storage_align(self.sch[self.x_ub].op.axis[1], self.elems_per_block, 0)

        # x_nhwc (1, 1, wi, c0)
        self.sch[self.x_nhwc].compute_align(self.sch[self.x_nhwc].op.axis[3], self.c0)

        if self.padding == "SAME" or self.padding == "CALCULATED":
            # (1, 1, wi_p, c0)
            for _ in [*self.padding_computes, self.x_p]:
                self.sch[_].compute_align(self.sch[_].op.axis[3], self.c0)

        # y_nhwc (1, 1, 1, 1, ub_factor, c0)
        self.sch[self.y_nhwc].compute_align(self.sch[self.y_nhwc].op.axis[5], self.c0)

        # y_ub (1, c0, 1, 1, 1, ub_factor)
        if self.is_const and self.ub_factor == 1:
            self.sch[self.y_ub].compute_inline()
            self.y_ub_inline = True
        elif self.is_const and self.c == 1:
            pass
        else:
            self.sch[self.y_ub].storage_align(self.sch[self.y_ub].op.axis[1], self.elems_per_block, 0)
