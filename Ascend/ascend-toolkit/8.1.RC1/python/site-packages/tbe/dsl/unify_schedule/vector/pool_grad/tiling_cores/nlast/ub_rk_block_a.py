#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright 2023-2024 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
UB split ro, block split a
"""

from tbe.dsl.unify_schedule.constants import PoolGradPattern
from tbe.dsl.unify_schedule.vector.pool_grad import pool_grad_tilingcase
from tbe.dsl.unify_schedule.vector.pool_grad.tiling_cores.nlast import \
    nlast_tiling_core


class UbRkBlockA(nlast_tiling_core.NlastTilingCore):
    def get_strategy():
        return (PoolGradPattern.NLAST_WINDOW_AXIS, pool_grad_tilingcase.Strategy.UB_RK_BLOCK_A)

    def _do_split(self):
        self._ub_split.stage = self._dp
        self._ub_split.axis = self._rk_axes[self._ub_idx]
        self._ub_split.do_split()

        self._dp.reorder(*self._ah_axes,
                         *self._ro_axes,
                         *self._rk_axes[:self._ub_idx],
                         self._ub_split.outer,
                         self._ub_split.inner,
                         *self._rk_axes[self._ub_idx+1:],
                         *self._ak_axes,
                         self._at_axis)

        self._fn.reorder(*self._fn_ah_axes, *self._fn_ak_axes, self._fn_at_axis)

        self._block_split.stage = self._fn
        self._block_split.axis = self._fn.fuse(*self._fn_ah_axes)
        self._block_split.do_split()

    def _do_compute_at(self):
        for x in self._dp.ancestors:
            if x.is_placeholder() or x.is_scan_component():
                continue
            x.compute_at(self._dp, self._ub_split.outer)
        self._dp.compute_at(self._fn, self._block_split.inner)

        for x in self._dp.descendants:
            if x == self._fn:
                continue
            x.reverse_compute_at(self._dp, self._ub_split.outer)

    def _do_emit_insn(self):
        self._fn.emit_phony()
        self._dp.emit(self._ub_split.inner, attrs={"reduce_mode": "conditional_reduce",
                                                   "analysis_repeat_overlap": 1})
