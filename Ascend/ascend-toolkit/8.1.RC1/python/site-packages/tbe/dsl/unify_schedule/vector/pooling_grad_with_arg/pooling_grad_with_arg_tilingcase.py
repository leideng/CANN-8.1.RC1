#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
pooling grad tilingcase
"""
from tabnanny import check
from tbe.common.utils import decode
from tbe.common.utils import do_op_tiling
from tbe.dsl.base import operation
from tbe.dsl.base.operation import add_compile_info_inner, get_compile_info
from tbe.dsl.base.operation import add_compile_info
from tbe.dsl.base.operation import get_context
from tbe.dsl.base.operation import register_build_pointcut
from tbe.tvm.tir.expr import ConstExpr
from tbe.tvm.tir.expr import Select

from .pooling_grad_helper import PoolingGradSchType
from .pooling_grad_helper import PoolingGradConstants
from .pooling_grad_helper import raise_error
from .pooling_grad_helper import get_format
from .pooling_grad_info import PoolingGradComputeInfo
from .pooling_grad_info import PoolingGradSocInfo

from ... import util
from ...computation import Computation
from ...constants import CompileInfo
from ...constants import Pattern
from ...constants import PoolingGradPattern


def _pre_build():
    """
    pooling grad pre build
    """
    pass


def _post_build():
    """
    pooling grad post build
    """
    def _encode_var_name(_var_names):
        after_encode_name = []
        for name in _var_names:
            names = name[1:].split('_')
            if names[0] == "x":
                after_encode_name.append(10000 + int(names[2]))
            elif names[0] == "block":
                after_encode_name.append(20000)
            elif names[0] == "ub":
                after_encode_name.append(30000)
            elif names[0] == "window" and names[1] == "factor":
                after_encode_name.append(40000)
            elif names[0] == "window":
                after_encode_name.append(50000 + int(names[1]))
            elif names[0] == "stride":
                after_encode_name.append(60000 + int(names[1]))
            elif names[0] == "dilations":
                after_encode_name.append(70000 + int(names[1]))
            elif names[0] == "padding":
                after_encode_name.append(80000 + int(names[1]))
            elif names[0] == "grad":
                after_encode_name.append(90000 + int(names[2]))
            else:
                raise_error(
                    "unknown var name in pooling grad schedule, please check!")
        return after_encode_name
    normal_vars = get_compile_info().get(CompileInfo.NORMAL_VARS)
    pooling_grad_vars = {}
    for tiling_key, var_names in normal_vars.items():
        pooling_grad_vars[tiling_key] = _encode_var_name(var_names)
    add_compile_info_inner("_pooling_grad_vars", pooling_grad_vars)


@register_build_pointcut(pattern=Pattern.POOLING_GRAD_WITH_ARG)
def build_pointcut(func, *args, **kwargs):
    """
    pooling grad build pointcut
    """
    _pre_build()
    func(*args, **kwargs)
    _post_build()


class CalcPoolingGradWithArgTilingCase(Computation):
    """
    pooling grad tilingcase class
    """

    def __init__(self, outs, option):
        self.outs = outs
        self.option = option
        self.format_info = get_format(operation.get_context().get_current_compute().get("_format_info"))

    @classmethod
    def get_instance(cls, outs, option):
        return cls(outs, option)

    @classmethod
    def get_supported_pattern(cls):
        return [Pattern.POOLING_GRAD_WITH_ARG]

    @classmethod
    def get_supported_soc(cls):
        return ["default"]

    def get_sub_pattern(self):
        if self.format_info == "NC1HWC0":
            return PoolingGradPattern.PG_0
        elif self.format_info == "NCHW":
            return PoolingGradPattern.PG_1
        else:
            return PoolingGradPattern.PG_2

    def do_tiling_case(self):
        outs = list(self.outs) if isinstance(
            self.outs, (list, tuple)) else [self.outs]
        current_compute = get_context().get_current_compute()
        compute_info = PoolingGradComputeInfo(outs)
        current_compute.add("_compute_info", compute_info)

        tiling_case_list = []
        if self.format_info == "NC1HWC0":
            tiling_case_list += _add_tiling_case(compute_info)
        else:
            tiling_case_list += _add_4d_tiling_case(compute_info, self.format_info)
        _apply_compile_info(compute_info)

        return tiling_case_list


def _apply_compile_info(compute_info: PoolingGradComputeInfo):
    core_num = PoolingGradSocInfo.get_core_num()
    common_info = [core_num]
    add_compile_info_inner("_common_info", common_info)


def _add_dyn_tiling_case(compute_info: PoolingGradComputeInfo):
    res_shape = compute_info.base_info.res_shape
    tiling_case_list = []

    for block_split_axis in range(len(res_shape)):
        if block_split_axis == 1: # D axis is useless
            continue
        for ub_split_axis in range(block_split_axis, len(res_shape)):
            for _, sch_type in PoolingGradSchType.__members__.items():
                if sch_type == PoolingGradSchType.LARGE_KERNEL:
                    continue
                else:
                    tiling_case = PoolingGradTilingCase(
                        compute_info, block_split_axis, ub_split_axis, sch_type)
                    if tiling_case.check_valid():
                        tiling_case_list.append(tiling_case)
    # large kernel only support block axis is c, ub axis is h
    block_split_axis = 2
    ub_split_axis = 3
    tiling_case = PoolingGradTilingCase(
                        compute_info, block_split_axis, ub_split_axis, sch_type=PoolingGradSchType.LARGE_KERNEL)
    if tiling_case.check_valid():
        tiling_case_list.append(tiling_case)
    operation.add_build_arg("enable_branch_eliminator_else_case", False)
    operation.add_build_arg("predicate_total_out_of_bound", False)
    return tiling_case_list


def _add_const_tiling_case(compute_info: PoolingGradComputeInfo):
    tiling_case_list = []
    tiling_case = PoolingGradTilingCase(compute_info)
    tiling_case_list.append(tiling_case)
    tiling_case = PoolingGradTilingCase(
        compute_info, sch_type=PoolingGradSchType.WINDOW_SPLIT)
    tiling_case_list.append(tiling_case)
    tiling_case = PoolingGradTilingCase(
        compute_info, sch_type=PoolingGradSchType.STRIDE_1)
    tiling_case_list.append(tiling_case)
    tiling_case = PoolingGradTilingCase(
        compute_info, sch_type=PoolingGradSchType.LARGE_KERNEL)
    tiling_case_list.append(tiling_case)
    operation.add_build_arg("predicate_total_out_of_bound", False)
    operation.add_build_arg("out_of_bound_sync_check", False)
    return tiling_case_list


def _add_tiling_case(compute_info: PoolingGradComputeInfo):
    if compute_info.base_info.mode == PoolingGradConstants.STATIC:
        return _add_const_tiling_case(compute_info)
    return _add_dyn_tiling_case(compute_info)


def _add_nchw_const_tilingcase(compute_info: PoolingGradComputeInfo, format_info):
    tiling_case_list = []
    tiling_case = PoolingGrad4DTilingCase(
        compute_info, sch_type=PoolingGradSchType.COMMON, sub_pattern=format_info)
    tiling_case_list.append(tiling_case)

    operation.add_build_arg("enable_branch_eliminator_else_case", False)
    operation.add_build_arg("predicate_total_out_of_bound", False)
    operation.add_build_arg("bind_reduction_using_block", False)
    operation.add_build_arg("enable_auto_atomic", ["", "", "", "add.float32"])
    operation.add_build_arg("enable_mask_counter_mode", "disable")
    return tiling_case_list


def _add_nchw_dyn_tiling_case(compute_info: PoolingGradComputeInfo, format_info):
    h_idx, w_idx, nc_idx = 0, 1, 2
    kh_idx, kw_idx = 3, 4
    tiling_case_list = []
    for block_split_axis in [h_idx, w_idx]:
        ub_axis_list = [val for val in [h_idx, kh_idx, w_idx, kw_idx] if val not in range(-1, block_split_axis)]
        for ub_split_axis in ub_axis_list:
            tiling_case = PoolingGrad4DTilingCase(
                compute_info, block_split_axis, ub_split_axis,
                sch_type=PoolingGradSchType.COMMON, sub_pattern=format_info)
            if tiling_case.check_valid():
                tiling_case_list.append(tiling_case)
    block_split_axis = nc_idx
    for ub_split_axis in [nc_idx, h_idx, kh_idx, w_idx, kw_idx]:
        tiling_case = PoolingGrad4DTilingCase(
            compute_info, block_split_axis, ub_split_axis, sch_type=PoolingGradSchType.COMMON, sub_pattern=format_info)
        if tiling_case.check_valid():
            tiling_case_list.append(tiling_case)

    operation.add_build_arg("enable_branch_eliminator_else_case", False)
    operation.add_build_arg("predicate_total_out_of_bound", False)
    operation.add_build_arg("bind_reduction_using_block", False)
    operation.add_build_arg("enable_auto_atomic", ["", "", "", "add.float32"])
    return tiling_case_list


def _add_nhwc_const_tilingcase(compute_info: PoolingGradComputeInfo, format_info):
    pass


def _add_nhwc_dyn_tiling_case(compute_info: PoolingGradComputeInfo, format_info):
    pass


def _add_4d_tiling_case(compute_info: PoolingGradComputeInfo, format_info):
    if format_info == "NCHW":
        if compute_info.base_info.mode == PoolingGradConstants.STATIC:
            return _add_nchw_const_tilingcase(compute_info, format_info)
        return _add_nchw_dyn_tiling_case(compute_info, format_info)
    else:
        if compute_info.base_info.mode == PoolingGradConstants.STATIC:
            return _add_nhwc_const_tilingcase(compute_info, format_info)
        return _add_nhwc_dyn_tiling_case(compute_info, format_info)


class PoolingGradTilingCase:
    """
    class for pooling grad tiling case
    """

    def __init__(self, compute_info: PoolingGradComputeInfo,
                 block_idx=None, ub_idx=None, sch_type=PoolingGradSchType.COMMON, enable_db=False):
        """
        init tiling case
        """
        self.compute_info = compute_info
        self.block_split_axis_index = block_idx
        self.ub_split_axis_index = ub_idx
        self.ori_sch_type = sch_type
        self.sch_type = sch_type
        self.is_enable_db = enable_db
        self.ori_is_enable_db = enable_db
        self.is_const = compute_info.base_info.mode == PoolingGradConstants.STATIC

        self.block_factor = None
        self.ub_factor = None
        self.multi_core = True
        self.window_factor = None

        self.sch_key = self.calc_sch_key()
        self.mode_key = self.calc_mode_key()
        self.pattern_key = self.calc_pattern_key()
        self.tiling_key = self.calc_tiling_key()

    def check_valid(self):
        """
        check current tilingcase is valid
        """
        if self.block_split_axis_index is None or self.ub_split_axis_index is None:
            return True
        shape_to_list = util.shape_to_list(
            self.compute_info.base_info.res_shape)
        if (len(shape_to_list) - 1) == self.block_split_axis_index:
            return False
        if (len(shape_to_list) - 1) == self.ub_split_axis_index:
            return False
        return True

    def check_consistency(self):
        """
        check consistency of init and cur
        """
        check_result = (self.ori_sch_type == self.sch_type and self.ori_is_enable_db == self.is_enable_db)
        return check_result

    def parse_and_update_sch_key(self, sch_key):
        """
        parse and update sch key, including sch_type and is_enable_db
        """
        self.sch_key = sch_key
        type_key = sch_key >> 1
        if type_key == 0:
            self.sch_type = PoolingGradSchType.COMMON
        elif type_key == 1:
            self.sch_type = PoolingGradSchType.WINDOW_SPLIT
        elif type_key == 2:
            self.sch_type = PoolingGradSchType.STRIDE_1
        else:
            self.sch_type = PoolingGradSchType.LARGE_KERNEL
        self.is_enable_db = bool(sch_key % 2)

    def _construct_input_and_output(self):
        _inputs = []
        shape_x = util.shape_to_list(
            list(self.compute_info.graph_info.output_tensor_set)[0].shape)
        _inputs.append({"shape": shape_x, "dtype": "float16"})
        for _single_tensor in self.compute_info.graph_info.input_tensor_set:
            if "grad" in _single_tensor.op.name:
                _inputs.append({"shape": util.shape_to_list(
                    _single_tensor.shape), "dtype": _single_tensor.dtype})
        for _single_tensor in self.compute_info.graph_info.input_tensor_set:
            if "argmax" in _single_tensor.op.name:
                _inputs.append({"shape": util.shape_to_list(
                    _single_tensor.shape), "dtype": _single_tensor.dtype})

        _outputs = []
        for _single_tensor in self.compute_info.graph_info.real_output_tensor_set:
            _output_shape = []
            for _dim in _single_tensor.shape:
                if isinstance(_dim, Select):
                    _dim_value = _dim.true_value if _dim.condition.value else _dim.false_value
                    _output_shape.append(_dim_value.value)
                elif isinstance(_dim, ConstExpr):
                    _output_shape.append(_dim.value)
                else:
                    _output_shape.append(_dim)
            _outputs.append(
                {"shape": _output_shape, "dtype": _single_tensor.dtype})
        return _inputs, _outputs

    def calc_const_tiling(self):
        """
        get const tiling
        """
        if not self.is_const:
            raise_error("do const tiling while mode is not const, please check!")

        # main logic for const tiling case
        add_compile_info_inner("_is_const", True)
        # the flag of invoking op_tiling inferface during compilation
        add_compile_info_inner("_is_const_post", False)

        inputs, outputs = self._construct_input_and_output()
        run_info = do_op_tiling(
            "AutoTiling", get_compile_info(), inputs, outputs)
        tiling_format = {"block_axis": "int", "block_factor": "int", "ub_axis": "int",
                         "ub_factor": "int", "window_factor": "int", "sch_type": "int"}
        tiling_data = decode(run_info.get("tiling_data"), tiling_format)
        self.parse_and_update_sch_key(tiling_data.get("sch_type"))
        self.tiling_key = self.calc_tiling_key()

        self.block_split_axis_index = tiling_data.get("block_axis")
        self.block_factor = tiling_data.get("block_factor")
        self.ub_split_axis_index = tiling_data.get("ub_axis")
        self.ub_factor = tiling_data.get("ub_factor")
        self.window_factor = tiling_data.get("window_factor")
        self.multi_core = run_info.get("block_dim") > 1

        # the flag of invoking op_tiling inferface during running
        add_compile_info_inner("_is_const_post", True)

        block_dims = get_compile_info().get("_const_block_dims")

        if block_dims is None:
            block_dims = {}
            add_compile_info_inner("_const_block_dims", block_dims)
        block_dims[self.tiling_key] = run_info.get("block_dim")

    def calc_sch_key(self):
        """
        calculate sch key, including sch_type and is_enable_db
        """
        if self.sch_type == PoolingGradSchType.LARGE_KERNEL:
            type_key = 0x3
        elif self.sch_type == PoolingGradSchType.STRIDE_1:
            type_key = 0x2
        elif self.sch_type == PoolingGradSchType.WINDOW_SPLIT:
            type_key = 0x1
        else:
            type_key = 0x0
        return (type_key << 1) + int(self.is_enable_db)

    def calc_mode_key(self):
        """
        calculate mode key(0xfff is static)
        """
        mode_key = PoolingGradConstants.STATIC_MODE_KEY if self.is_const else self.sch_key
        return mode_key

    def calc_pattern_key(self):
        """
        calculate pattern: NC1HWC0 is 0
        """
        strategy_key = 0x0
        return strategy_key << 3 * 4

    def calc_tiling_key(self):
        """
        uint64 hex
        0-1: schedule type, 0x22(pooling grad)
        2-3: reverse
        4-6: mode, 0xfff(const)
        7-13: pattern
        14: block axis, 0xf(None)
        15: ub axis, 0xf(None)
        """
        block_tiling_key = 0xf if self.block_split_axis_index is None else self.block_split_axis_index
        ub_tiling_key = 0xf if self.ub_split_axis_index is None else self.ub_split_axis_index

        return (PoolingGradConstants.POOLING_GRAD_SCH_ID << 14 * 4) + (self.mode_key << 9 * 4) + \
            (self.pattern_key << 2 * 4) + (block_tiling_key << 4) + ub_tiling_key


class PoolingGrad4DTilingCase(PoolingGradTilingCase):
    def __init__(self, compute_info: PoolingGradComputeInfo,
                 block_idx=None, ub_idx=None, sch_type=PoolingGradSchType.COMMON, enable_db=False, sub_pattern=None):
        """
        init tiling case
        """
        self.compute_info = compute_info
        self.block_split_axis_index = block_idx
        self.ub_split_axis_index = ub_idx
        self.ori_sch_type = sch_type
        self.sch_type = sch_type
        self.is_enable_db = enable_db
        self.ori_is_enable_db = enable_db
        self.is_const = compute_info.base_info.mode == PoolingGradConstants.STATIC
        self.sub_pattern = sub_pattern

        self.block_factor = None
        self.ub_factor = None
        self.multi_core = True
        self.window_factor = None

        self.sch_key = self.calc_sch_key()
        self.mode_key = self.calc_mode_key()
        self.pattern_key = self.calc_pattern_key()
        self.tiling_key = self.calc_tiling_key()

    def calc_pattern_key(self):
        """
        calculate pattern: NCHW is 1, NHWC is 2
        """
        if self.sub_pattern == "NCHW":
            strategy_key = 0x1
        elif self.sub_pattern == "NHWC":
            strategy_key = 0x2
        return strategy_key << 3 * 4
    
    def check_valid(self):
        """
        check current tilingcase is valid
        """
        if self.block_split_axis_index is None or self.ub_split_axis_index is None:
            return True
        if self.sch_type != PoolingGradSchType.COMMON:
            return False
        return True
    
    def calc_const_tiling(self):
        """
        get const tiling
        """
        if not self.is_const:
            raise_error("do const tiling while mode is not const, please check!")

        # main logic for const tiling case
        add_compile_info_inner("_is_const", True)
        # the flag of invoking op_tiling inferface during compilation
        add_compile_info_inner("_is_const_post", False)

        inputs, outputs = self._construct_input_and_output()
        for input_tensor in inputs:
            input_tensor.get("shape").insert(0, 1)
        for output_tensor in outputs:
            output_tensor.get("shape").insert(0, 1)
        run_info = do_op_tiling(
            "AutoTiling", get_compile_info(), inputs, outputs)
        tiling_format = {"block_axis": "int", "block_factor": "int", "ub_axis": "int",
                         "ub_factor": "int", "window_factor": "int", "sch_type": "int"}
        tiling_data = decode(run_info.get("tiling_data"), tiling_format)
        self.parse_and_update_sch_key(tiling_data.get("sch_type"))
        self.tiling_key = self.calc_tiling_key()

        self.block_split_axis_index = tiling_data.get("block_axis")
        self.block_factor = tiling_data.get("block_factor")
        self.ub_split_axis_index = tiling_data.get("ub_axis")
        self.ub_factor = tiling_data.get("ub_factor")
        self.window_factor = tiling_data.get("window_factor")
        self.multi_core = run_info.get("block_dim") > 1

        # the flag of invoking op_tiling inferface during running
        add_compile_info_inner("_is_const_post", True)

        block_dims = get_compile_info().get("_const_block_dims")

        if block_dims is None:
            block_dims = {}
            add_compile_info_inner("_const_block_dims", block_dims)
        block_dims[self.tiling_key] = run_info.get("block_dim")