#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
tuple reduce tilingcase
"""
# Standard Packages
from typing import List
# TBE Packages
from tbe.tvm import Tensor
from tbe.dsl.base.operation import add_compile_info_inner
from tbe.dsl.base.operation import get_compile_info
from tbe.dsl.base.operation import add_build_arg
# Tuple Reduce
from tbe.dsl.unify_schedule.constants import Pattern
from tbe.dsl.unify_schedule.constants import TupleReducePattern
from tbe.dsl.unify_schedule.computation import Computation
from tbe.dsl.base.operation import register_build_pointcut
from tbe.dsl.unify_schedule.vector.tuple_reduce.common.tilingcase_info import Info
from tbe.dsl.unify_schedule.vector.tuple_reduce.common.constants import ScheduleType
from tbe.dsl.unify_schedule.vector.tuple_reduce.common.constants import Options

DEFAULT = "default"
CONST = "const"
DYNAMIC = "dynamic"


class CalcTupleReduceTilingCase(Computation):
    """
    calculate tuple reduce tiling case
    """

    def __init__(self, outs, option):
        self.outs = outs
        self.option = option
        self.tiling_shape = None

    @classmethod
    def get_instance(cls, outs, option):
        return cls(outs, option)

    @classmethod
    def get_supported_pattern(cls):
        return [Pattern.TUPLE_REDUCE]

    @classmethod
    def get_supported_soc(cls):
        return [DEFAULT]

    def get_sub_pattern(self):
        return TupleReducePattern.TR_0

    def do_tiling_case(self):
        """
        do tuple reduce tiling case
        @return:
        """
        return self.calc_tiling_case()

    def calc_tiling_case(self):
        """
        Generate tiling cases for all possible situations
        @return:
        """
        tiling_case_list: List[CreateCase] = []
        outs: List[Tensor] = list(self.outs) if isinstance(self.outs, (list, tuple)) else [self.outs]
        info: Info = Info(outs)
        self.tiling_shape: List = info.max_shape

        for st in ScheduleType:
            for opt in Options:
                for block_idx in range(len(self.tiling_shape)):
                    for ub_idx in range(len(self.tiling_shape)):
                        case = CreateCase(info, st, opt, block_idx, ub_idx)
                        if case.check_validity:
                            tiling_case_list.append(case)

        # save all tilingkeys
        tilingkeys = get_compile_info().get("_tilingkeys")
        if tilingkeys is None:
            tilingkeys = []
        tilingkeys = tilingkeys + [case.tiling_key for case in tiling_case_list]
        add_compile_info_inner("_tilingkeys", tilingkeys)

        return tiling_case_list


class CreateCase:
    """
    Tiling Case Data Struct for tuple-reduce
    """

    def __init__(self,
                 info: Info,
                 schedule_type: ScheduleType,
                 options: Options,
                 block_axis: int,
                 ub_axis: int):
        self.info = info
        self.schedule_type = schedule_type
        self.options = options
        self.block_axis = block_axis
        self.ub_axis = ub_axis
        self.tiling_key = self.calc_tiling_key()
    
    @property
    def check_validity(self):
        if self.info.is_const and self.tiling_key != self.info.tiling_key:
            return False

        if self.schedule_type == ScheduleType.NormalCut:
            if self.info.reduce_axis_one_hot[self.block_axis]:
                return False
            if not self.info.reduce_axis_one_hot[self.ub_axis]:
                if self.block_axis > self.ub_axis:
                    return False
            
        if self.schedule_type == ScheduleType.ReduceCut:
            if not self.info.reduce_axis_one_hot[self.block_axis]:
                return False
            if not self.info.atomic_support:
                return False
            if self.info.reduce_axis_one_hot[self.ub_axis]:
                if self.block_axis > self.ub_axis:
                    return False
        
        if self.schedule_type == ScheduleType.HybridCut:
            if not self.info.atomic_support:
                return False
            if not self.block_axis == 0:
                return False
            if 1 not in self.info.reduce_axis_one_hot[:self.ub_axis + 1]:
                return False
            if 0 not in self.info.reduce_axis_one_hot[self.ub_axis:]:
                return False
        
        if self.options == Options.UBAlignPad:
            if self.info.has_mov_align:
                return False
            if self.info.max_shape_len > 3:
                return False
            if not isinstance(self.info.max_shape[-1], int):
                return True
            if self.info.max_shape_len == 3 and self.info.max_shape[-1] > 20:
                return False
            if self.info.max_shape_len == 2 and self.info.max_shape[-1] > 32:
                return False
            return True
        if self.options == Options.TransposeReduce:
            return False
        
        return True
    
    def calc_tiling_key(self):
        reduce_pattern = self.info.classify_key
        schedule_type = self.schedule_type.value
        options = self.options.value
        block_axis = self.block_axis
        ub_axis = self.ub_axis

        key_values = (reduce_pattern, options, schedule_type, block_axis, ub_axis)
        key_weights = (10**4, 10**3, 10**2, 10**1, 10**0)
        tiling_key = [value * weight for value, weight in zip(key_values, key_weights)]
        return sum(tiling_key)


@register_build_pointcut(pattern=Pattern.TUPLE_REDUCE)
def build_pointcut(func, *args, **kwargs):
    """
    tuple reduce build pointcut
    """
    add_build_arg("enable_s64_to_s32", True)
    func(*args, **kwargs)
