#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2022. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the Apache License Version 2.0.
You may not use this file except in compliance with the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
Apache License for more details at
http://www.apache.org/licenses/LICENSE-2.0

resize tiling case
"""
from enum import Enum
from enum import auto
from enum import IntEnum
from typing import Optional

from tbe.dsl.base.operation import get_context
from tbe.dsl.base.operation import register_build_pointcut
from tbe.dsl.base.operation import get_compile_info
from tbe.dsl.base.operation import add_compile_info_inner
from tbe.dsl.unify_schedule.computation import Computation
from tbe.dsl.unify_schedule.constants import Pattern
from tbe.dsl.unify_schedule.constants import ResizePattern
from tbe.dsl.unify_schedule import util
from tbe.dsl.unify_schedule.vector.tiling_key import TilingKey
from tbe.dsl.unify_schedule.vector.tiling_key import ScheduleType


class Soc:
    DEFAULT = "default"


class ComputeMode:
    BROADCAST = "broadcast"
    FIRST_HW = "first_hw"
    PURE_COPY = "pure_copy"


class TilingStrategy(Enum):
    """
    TilingStrategy
    """
    PURE_COPY = auto()
    PURE_COPY_NONE_CUT = auto()
    BROADCAST_HW = auto()
    BROADCAST_HW_NONE_CUT = auto()
    FIRST_HW = auto()
    FIRST_HW_NONE_CUT = auto()
    SMALL_NC1 = auto()
    SMALL_NC1_NONE_CUT = auto()
    BASE_NONE_CUT = auto()
    BASE_CUT = auto()
    CONST = auto()


class ModeKey(IntEnum):
    """
    Mode key
    """
    COPY_MODE = 0x1
    BROADCAST_MODE = 0x2
    BASE_MODE = 0x3
    FIRST_HW_MODE = 0x4
    SMALL_NC1_MODE = 0x5
    CONST_MODE = 0x6


class PatternKey(IntEnum):
    """
    Pattern Key
    """
    NONE_CUT = 0x0
    CUT = 0x1


class ResizeCompileInfo:
    """
    Resize Built-in Compile Info Keys
    """
    IS_CONST = "_is_const"
    ONLY_CONST_TILING = "_only_const_tiling"
    CONST_DIMS = "_const_dims"
    COEXIST_UB_COUNT = "_coexist_ub_count"
    RESIZE_AXIS_IS_VAR = "_resize_axis_is_var"
    TILING_KEY = "_tiling_key"
    MODE = "_mode"
    RESIZE_METHOD = "_resize_method"
    ALIGN_CORNERS = "_align_corners"
    HALF_PIXEL_CENTERS = "_half_pixel_centers"
    TENSOR_SPACE = "_tensor_space"
    HW_GATE = "_hw_gate"
    NC1_GATE = "_nc1_gate"


class ResizeComputation(Computation):
    """
    Resize Tilingcase Computation
    """

    def __init__(self, outs, option):
        self.out = outs[0] if isinstance(outs, (list, tuple)) else outs
        self.option = option

    def get_sub_pattern(self):
        return ResizePattern.R_0

    @classmethod
    def get_instance(cls, outs, option):
        return cls(outs, option)

    @classmethod
    def get_supported_pattern(cls):
        return [Pattern.RESIZE]

    @classmethod
    def get_supported_soc(cls):
        return [Soc.DEFAULT]

    def do_tiling_case(self):  # type: () -> list[ResizeTilingCase]

        def _is_const(shape_inner):
            return all(isinstance(s, int) for s in shape_inner)

        def _add_tiling_case(tiling_mode, tiling_pattern, tiling_strategy, dim_size_tup, enable_db=False):
            tiling_key_inst.mode = tiling_mode
            tiling_key_inst.pattern = tiling_pattern
            for i in range(dim_size_tup[0]):
                for j in range(dim_size_tup[0]):
                    for k in range(dim_size_tup[1]):
                        tiling_key_inst.clear_split_axis()
                        tiling_key_inst.block_axis = i
                        tiling_key_inst.ub_axis = j
                        tiling_key_inst.split_flag = k
                        case = ResizeTilingCase()
                        case.block_split_axis = i
                        case.ub_split_axis = j
                        case.vice_ub_split_axis = k
                        case.tiling_key = tiling_key_inst.tiling_key
                        case.mode = tiling_key_inst.mode
                        case.pattern = tiling_key_inst.pattern
                        case.tiling_strategy = tiling_strategy
                        case.enable_db = enable_db
                        tiling_case.append(case)

        tiling_case = []
        tiling_key_inst = TilingKey(ScheduleType.RESIZE)

        shape = util.shape_to_list(self.out.shape)
        dims_size = len(shape) - 1
        none_cut_dims_size = 1
        if _is_const(shape):
            case = ResizeTilingCase()
            tiling_key_inst.set_const_mode()
            case.tiling_key = tiling_key_inst.tiling_key
            case.tiling_strategy = TilingStrategy.CONST
            case.enable_db = False
            tiling_case.append(case)
            return tiling_case

        cur_compute_mode = get_context().get_current_compute().get("_mode")
        mode_case_map_none_cut = {
            ComputeMode.BROADCAST: (ModeKey.BROADCAST_MODE, PatternKey.NONE_CUT, TilingStrategy.BROADCAST_HW_NONE_CUT),
            ComputeMode.FIRST_HW: (ModeKey.FIRST_HW_MODE, PatternKey.NONE_CUT, TilingStrategy.FIRST_HW_NONE_CUT),
            ComputeMode.PURE_COPY: (ModeKey.COPY_MODE, PatternKey.NONE_CUT, TilingStrategy.PURE_COPY_NONE_CUT)
        }
        mode_case_map_cut = {
            ComputeMode.BROADCAST: (ModeKey.BROADCAST_MODE, PatternKey.CUT, TilingStrategy.BROADCAST_HW),
            ComputeMode.FIRST_HW: (ModeKey.FIRST_HW_MODE, PatternKey.CUT, TilingStrategy.FIRST_HW),
            ComputeMode.PURE_COPY: (ModeKey.COPY_MODE, PatternKey.CUT, TilingStrategy.PURE_COPY)
        }
        compute_modes = (ComputeMode.BROADCAST, ComputeMode.FIRST_HW, ComputeMode.PURE_COPY)
        if cur_compute_mode in compute_modes:
            _add_tiling_case(*mode_case_map_none_cut.get(cur_compute_mode), (none_cut_dims_size, 1))
            if cur_compute_mode == ComputeMode.BROADCAST:
                _add_tiling_case(*mode_case_map_cut.get(cur_compute_mode), (dims_size - 1, 1))
            else:
                # only cut 0 dimension
                _add_tiling_case(*mode_case_map_cut.get(cur_compute_mode), (none_cut_dims_size, 1))
            return tiling_case

        _add_tiling_case(ModeKey.BASE_MODE, PatternKey.NONE_CUT, TilingStrategy.BASE_NONE_CUT, (none_cut_dims_size, 1))
        _add_tiling_case(ModeKey.BASE_MODE, PatternKey.CUT, TilingStrategy.BASE_CUT, (dims_size, dims_size))
        _add_tiling_case(ModeKey.SMALL_NC1_MODE, PatternKey.NONE_CUT, TilingStrategy.SMALL_NC1_NONE_CUT,
                         (none_cut_dims_size, 1))
        _add_tiling_case(ModeKey.SMALL_NC1_MODE, PatternKey.CUT, TilingStrategy.SMALL_NC1, (dims_size, dims_size))

        return tiling_case


class ResizeTilingCase:
    """
    Resize Tiling Case
    """

    def __init__(self):
        self._tiling_key = 0
        self._mode = 0
        self._pattern = 0
        self._tiling_strategy: Optional[Enum] = None
        self._block_split_axis = 0
        self._ub_split_axis = 0
        self._vice_ub_split_axis = 0
        self._enable_db = False

    @property
    def tiling_strategy(self):
        """
        :return: tiling_strategy
        """
        return self._tiling_strategy

    @property
    def enable_db(self):
        """
        enable_db
        """
        return self._enable_db

    @property
    def block_split_axis(self):
        """
        :return: block_split_axis
        """
        return self._block_split_axis

    @property
    def ub_split_axis(self):
        """
        :return: ub_split_axis
        """
        return self._ub_split_axis

    @property
    def vice_ub_split_axis(self):
        """
        :return: vice_ub_split_axis
        """
        return self._vice_ub_split_axis

    @property
    def tiling_key(self):
        """
        :return: tiling_key
        """
        return self._tiling_key

    @tiling_key.setter
    def tiling_key(self, value):
        """
        set tiling_key
        :param value:
        :return:
        """
        self._tiling_key = value

    @property
    def mode(self):
        """
        :return: mode
        """
        return self._mode

    @mode.setter
    def mode(self, value):
        """
        set mode
        :param value:
        :return:
        """
        self._mode = value

    @property
    def pattern(self):
        """
        :return: pattern
        """
        return self._pattern

    @pattern.setter
    def pattern(self, value):
        """
        set pattern
        :param value:
        :return:
        """
        self._pattern = value

    @tiling_strategy.setter
    def tiling_strategy(self, value):
        """
        set tiling_strategy
        :param value:
        :return:
        """
        self._tiling_strategy = value

    @block_split_axis.setter
    def block_split_axis(self, value):
        """
        set block_split_axis
        :param value:
        :return:
        """
        self._block_split_axis = value

    @ub_split_axis.setter
    def ub_split_axis(self, value):
        """
        set ub_split_axis
        :param value:
        :return:
        """
        self._ub_split_axis = value

    @vice_ub_split_axis.setter
    def vice_ub_split_axis(self, value):
        """
        set vice_ub_split_axis
        :param value:
        :return:
        """
        self._vice_ub_split_axis = value

    @enable_db.setter
    def enable_db(self, value):
        """
        set enable_db
        :param value:
        :return:
        """
        self._enable_db = value


@register_build_pointcut(pattern=Pattern.RESIZE)
def build_pointcut(func, *args, **kwargs):
    """
    build pointcut
    :param func:
    :param args:
    :param kwargs:
    """

    def _pre_build():
        if get_compile_info().get(ResizeCompileInfo.IS_CONST, False) is False:
            cpt_computes = get_context().get_computes()
            cpt_coexist_ub_count, cpt_resize_axis_flag = {}, {}

            for cpt in cpt_computes:
                for sch_cxt in cpt.get_schedules():
                    tiling_key = sch_cxt.get(ResizeCompileInfo.TILING_KEY)
                    cpt_resize_axis_flag[tiling_key] = sch_cxt.get(ResizeCompileInfo.RESIZE_AXIS_IS_VAR)
                    mode = sch_cxt.get(ResizeCompileInfo.MODE)
                    coexist_count = sch_cxt.get(ResizeCompileInfo.COEXIST_UB_COUNT)
                    if mode and coexist_count:
                        cpt_coexist_ub_count[mode] = coexist_count
            add_compile_info_inner(ResizeCompileInfo.COEXIST_UB_COUNT, cpt_coexist_ub_count)
            add_compile_info_inner(ResizeCompileInfo.RESIZE_AXIS_IS_VAR, cpt_resize_axis_flag)

    _pre_build()
    func(*args, **kwargs)
