#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
conv2d backprop filter tiling case
"""

from collections import OrderedDict
from functools import reduce
from itertools import product

from tbe import tvm
from tbe.common.tiling import get_tiling
from tbe.common.platform import platform_info as tbe_platform_info
from tbe.common.utils import log
from tbe.dsl.base.operation import add_compile_info
from tbe.dsl.base.operation import get_op_context
from tbe.dsl.base.operation import get_te_var
from tbe.dsl.base.operation import get_context as op_get_context
from tbe.dsl.base.operation import in_dynamic
from tbe.dsl.base.operation import register_tiling_case
from tbe.dsl.compute.conv3d_backprop_filter_compute import DynamicConv3dBpFilterParams as DynamicParams

from .cube_tilingcase import ConvBpFilterTilingIdOffset
from .cube_tilingcase import CubeStaticTilingOp
from .cube_tilingcase import CubeTilingOp
from .cube_tilingcase import get_op_tiling
from .cube_tilingcase import TilingSelection
from .cube_tilingcase import TilingUtils as utils
from .cube_tilingcase import C0_SIZE
from .constants import Pattern

D_RANGE = 4096
H_RANGE = 4096
W_RANGE = 4096
N_RANGE = 1000000
DHW_DELTA = 1
H_LEN = 400
W_LEN = 400
D_LEN = 600

_DEFAULT_TILING_FLAG = 32
CUBE_DIM = 16

SHAPE_VARS = ("batch_n", "fmap_c", "fmap_d", "fmap_h", "fmap_w", "dedy_c", "dedy_d", "dedy_h", "dedy_w")
ATTR_VARS = ("kernel_d", "kernel_h", "kernel_w", "fmap_c1", "dedy_c1", "stride_d", "stride_h", "stride_w", "padf",
             "padb",  "padu", "padd", "padl", "padr", "dilation_d", "dilation_h", "dilation_w",
             "cin1_g", "cout1_g", "real_g", "mag_factor")
TILING_VARS = ("group_dim", "batch_dim", "k_dim", "batch_single_core", "n_single_core", "n_dim", "n_bl1",
               "n_ub_l0_time", "cub_n1", "m_dim", "m_single_core", "m_al1", "m_l0", "k_l0",
               "kal1_factor", "kbl1_factor", "kal0_factor", "kbl0_factor", "kl1_times",
               "bl1_bound", "ho_bL1", "load3d_special", "is_bf16")


class Conv3DBpFilterTilingIdOffset(ConvBpFilterTilingIdOffset):
    # tiling_id offset
    def __init__(self):
        super().__init__()


@register_tiling_case(pattern=Pattern.CONV3D_BACKPROP_FILTER)
def calc_conv3dbp_filter(outs, option=None):
    """
    calculate tilings

    Parameters
    ----------
    outs: outs
    option: option

    Returns
    -------
    tiling_cases: list, calculated tilings
    """
    info = DynamicParams.tiling_info_dict
    group_dict = DynamicParams.group_dict
    var_names = ["batch_n", "fmap_d", "fmap_h", "fmap_w"]

    shape_dict = {"batch_n": info.get("b_shape")[0],
                  "fmap_d": info.get("b_shape")[1],
                  "fmap_h": info.get("b_shape")[3],
                  "fmap_w": info.get("b_shape")[4]}
    if not in_dynamic():
        tiling_dw = Conv3dBpFilterStaticTiling(outs)
        if tiling_dw.in_dtype == "bfloat16":
            # BF16 only supports dynamic constantization
            tiling_dw.res.op.attrs["is_dynamic_constantization"] = True
        else:
            tiling_dw.get_static_tiling()
        return [{"tiling_strategy": tiling_dw.tiling}]

    tgt_area = {}
    te_var = []
    for v in var_names:
        if DynamicParams.binary_mode:
            tgt_area[v] = (1, None)
        if get_te_var(v) and get_te_var(v).get_bound():
            tgt_area[v] = tuple(get_te_var(v).get_bound())
            te_var.append(v)
        else:
            tgt_area[v] = (shape_dict.get(v), shape_dict.get(v))

    if ("fmap_d" in te_var or "fmap_h" in te_var or "fmap_w" in te_var):
        mode = "dynamic_dhw"
    else:
        mode = "dynamic_batch"
    tiling_op = Conv3dBpFilterTiling(info, mode, DynamicParams.var_map)

    tiling_cases = TilingSelection(tiling_op).calc_tiling(tgt_area, var_names)
    if not DynamicParams.binary_mode:
        dedy_c1 = utils.icd(group_dict["cout_ori"], info.get("a_shape")[-1])
        fmap_c1 = utils.icd(group_dict["cin_ori"], info.get("b_shape")[-1])
        add_compile_info("dedy_c1", dedy_c1)
        add_compile_info("fmap_c1", fmap_c1)
    # dynaminc constantization for static shape scene
    context = get_op_context()
    dyn_constant_tiling = None
    if context.get_addition("is_dynamic_constantization"):
        tiling_data_key = SHAPE_VARS + ATTR_VARS + TILING_VARS
        tiling_data, tiling_key = get_op_tiling("Conv3DBackpropFilter", tiling_data_key)
        dyn_constant_tiling = Conv3dBpFilterTiling.get_dyn_constant_tiling(
            tiling_cases, tiling_data, tiling_key, "Conv3DBackpropFilter")
        return dyn_constant_tiling
    return tiling_cases


class Conv3dBpFilterTiling(CubeTilingOp):
    """
    Conv3dBpFilter tiling class
    """
    def __init__(self, tiling_info, dynamic_mode, var_map):
        super().__init__(tiling_info, dynamic_mode, var_map)
        self.a_info = self.tiling_info['a_shape']
        self.b_info = self.tiling_info['b_shape']
        self.c_info = self.tiling_info['c_shape']
        self._get_calc_info()
        self.dynamic_mode = dynamic_mode
        self.binary_mode = DynamicParams.binary_mode
        self.load_mode = DynamicParams.load_mode
        self.strideh_read_flag = False
        self.support_l0c2out = tbe_platform_info.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out")
        self.var_map = var_map
        self.key = 'B_shape'
        self.op_type = 'conv3d_bp_filter'
        op_get_context().add("_use_cache_tiling", bool(self.binary_mode))

    @staticmethod
    def _get_choice_list():
        (al1_pb, bl1_pb, l0c_pb, abkl1_attach, al1_attach_flag, bl1_attach_flag, min_kl1_cmp_kl0,
         load3d_special_flag, conv1d_flag) = (
            [utils.DB_OFF, utils.DB_ON],
            [utils.DB_OFF, utils.DB_ON],
            [utils.DB_OFF, utils.DB_ON],
            [utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL, utils.ATTACH_LESS],
            [utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL, utils.ATTACH_LESS],
            [utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL, utils.ATTACH_LESS],
            [0, 1],
            [0],
            [0])

        choice_list = list(
            product(al1_pb, bl1_pb, l0c_pb, abkl1_attach, al1_attach_flag, bl1_attach_flag, min_kl1_cmp_kl0,
                    load3d_special_flag, conv1d_flag))

        return choice_list

    def get_repo_tiling(self):
        tiling_list = get_tiling(self.tiling_info)
        res_list = []

        for tiling in tiling_list:
            self._set_padding_list(tiling['B_shape'][1],
                                   tiling['B_shape'][3],
                                   tiling['B_shape'][4])
            if tiling['pad'] == self.cur_pads:
                self._get_attach_flag(tiling)
                res_list.append(tiling)
        return res_list

    def get_costmodel_tiling(self, shape):
        """
        get tiling using cost model

        Parameters
        ----------
        shape: specified shape to get tiling

        Returns
        -------
        tiling: tiling retrieved by cost model
        """

        if self.dynamic_mode == "dynamic_batch":
            self.a_info[0] = shape
            self.b_info[0] = shape
        elif self.dynamic_mode == "dynamic_dhw":
            self.b_info[0], self.b_info[1], self.b_info[3], self.b_info[4] = shape
            self.a_info[0] = self.b_info[0]
            self._set_padding_list(self.b_info[1], self.b_info[3], self.b_info[4])

            self.tiling_info['pad'] = self.cur_pads[:]
            self.a_info[1] = self._get_output_d(self.b_info[1])
            self.a_info[3] = self._get_output_h(self.b_info[3])
            self.a_info[4] = self._get_output_w(self.b_info[4])
        self.tiling_info["tiling_type"] = "cost_model_tiling"

        cost_tiling = get_tiling(self.tiling_info)
        if cost_tiling:
            tiling = cost_tiling[0]
            if tiling.get("tiling").get("AL0_matrix")[2] == _DEFAULT_TILING_FLAG:
                tiling = self._get_default_tiling_extend()
        else:
            tiling = self._get_default_tiling_extend()
        self._get_attach_flag(tiling)
        return tiling


    def get_depth_range(self, tiling, fmap_shape):
        """
        get depth range

        Parameters
        ----------
        tiling : dict, result of tiling fetch

        fmap_shape : list, size of fmap_shape

        Returns
        -------
        list, range covered for tiling_in
        """
        n_i, d_i, _, h_i, w_i, _ = fmap_shape
        self._set_padding_list(d_i, h_i, w_i)
        di_min = max(self.k_d - self.cur_pads[0] - self.cur_pads[1], 1)
        di_max = d_i
        cur_d_size = d_i

        while cur_d_size >= max(self.k_d - self.cur_pads[0] - self.cur_pads[1], 1) and \
            self._check_tiling_match(tiling, w_i, h_i, cur_d_size, n_i):
            di_min = cur_d_size
            cur_d_size = cur_d_size - DHW_DELTA

        # searching up-ward for w_max
        cur_d_size = d_i
        while cur_d_size <= D_RANGE and \
            self._check_tiling_match(tiling, w_i, h_i, cur_d_size, n_i):
            di_max = cur_d_size
            cur_d_size = cur_d_size + DHW_DELTA

        perf_di_min = max(di_min, d_i - D_LEN)
        perf_di_max = min(di_max, d_i + D_LEN)

        return [perf_di_min, perf_di_max]

    def get_tiling_range(self, tiling_in, shape_info):
        """
        get the covered area of a tiling

        Parameters
        ----------
        tiling_in : dict, result of tiling fetch

        shape_info : list, size of shape_info

        Returns
        -------
        list, range covered for tiling_in
        """

        n_i, d_i, _, h_i, w_i, _ = shape_info

        self._set_padding_list(d_i, h_i, w_i)

        # get min value
        hi_min = max(self.k_h - self.cur_pads[2] - self.cur_pads[3], 1)
        wi_min = max(self.k_w - self.cur_pads[4] - self.cur_pads[5], 1)

        if not tiling_in["BL1_shape"]:
            # fully load in BL1, covering lower region
            return [1, n_i, 1, d_i, 1, h_i, 1, w_i]

        depth_range = self.get_depth_range(tiling_in, shape_info)


        # check tiling covering itself situation
        if (h_i > H_RANGE or w_i > W_RANGE or d_i > D_RANGE or n_i > N_RANGE or
            not self._check_tiling_match(tiling_in, w_i, h_i, d_i, n_i)):
            return [0, 0, 0, 0, 0, 0, 0, 0]

        hi_max = h_i
        cur_w_size = w_i

        # searching down-ward for w_min
        while (cur_w_size >= max(self.k_w - self.cur_pads[4] - self.cur_pads[5], 1) and
               self._check_tiling_match(tiling_in, cur_w_size, h_i, d_i, n_i)):
            wi_min = cur_w_size
            cur_w_size = cur_w_size - DHW_DELTA

        # searching up-ward for w_max
        cur_w_size = w_i
        while (cur_w_size <= W_RANGE and
               self._check_tiling_match(tiling_in, cur_w_size, h_i, d_i, n_i)):
            wi_max = cur_w_size
            cur_w_size = cur_w_size + DHW_DELTA

        perf_wi_min = max(wi_min, w_i - W_LEN)
        perf_wi_max = min(wi_max, w_i + W_LEN)

        if perf_wi_min > perf_wi_max:
            return [0, 0, 0, 0, 0, 0, 0, 0]

        # searching down-ward for h_min based on w_min
        perf_hi_min = max(hi_min, h_i - H_LEN)
        cur_h_size = h_i
        while (cur_h_size >= max(self.k_h - self.cur_pads[2] - self.cur_pads[3], 1) and
               self._check_tiling_match(tiling_in, perf_wi_min, cur_h_size, d_i, n_i)):
            hi_min = cur_h_size
            cur_h_size = cur_h_size - DHW_DELTA
        perf_hi_min = max(hi_min, h_i - H_LEN)

        # searching up-ward for h_max based on w_max
        cur_h_size = h_i
        while (cur_h_size <= H_RANGE and
               self._check_tiling_match(tiling_in, perf_wi_max, cur_h_size, d_i, n_i)):
            hi_max = cur_h_size
            cur_h_size = cur_h_size + DHW_DELTA
        perf_hi_max = min(hi_max, h_i + H_LEN)

        ni_min = n_i
        ni_max = n_i
        cur_n_size = n_i
        while (cur_n_size >= 1 and
               self._check_tiling_match(tiling_in, perf_wi_min, perf_hi_min, depth_range[0], cur_n_size)):
            ni_min = cur_n_size
            cur_n_size = cur_n_size - DHW_DELTA

        cur_n_size = n_i
        dynamic_l0a_attach = tiling_in.get('dynamic_l0a_attach')
        dynamic_l0b_attach = tiling_in.get('dynamic_l0b_attach')
        dynamic_al1_attach = tiling_in.get('dynamic_al1_attach')
        dynamic_bl1_attach = tiling_in.get('dynamic_bl1_attach')
        attach_set = {dynamic_l0a_attach, dynamic_l0b_attach, dynamic_al1_attach, dynamic_bl1_attach}
        if len(attach_set) == 1 and 'dw_cc' in attach_set:
            ni_max = -1
        else:
            while (cur_n_size <= N_RANGE and
                   self._check_tiling_match(tiling_in, perf_wi_max, perf_hi_max, depth_range[1], cur_n_size)):
                ni_max = cur_n_size
                cur_n_size = cur_n_size + DHW_DELTA

        perf_range = [ni_min, ni_max] + depth_range + [perf_hi_min, perf_hi_max, perf_wi_min, perf_wi_max]
        perf_range = [int(v) for v in perf_range]
        return perf_range

    def get_batch_range(self, tiling, fmap_shape):
        """
        get the covered area of a tiling

        Parameters
        ----------
        tiling : dict, result of tiling fetch

        fmap_shape : list, size of fmap_shape

        Returns
        -------
        list, range covered for tiling_in
        """

        n_i, d_i, _, h_i, w_i, _ = fmap_shape
        self._set_padding_list(d_i, h_i, w_i)
        d_o = self._get_output_d(d_i)
        h_o = self._get_output_h(h_i)
        w_o = self._get_output_w(w_i)
        dy_shape = n_i, d_o, self.a_info[2], h_o, w_o, utils.CUBE_SIZE
        block_dim_batch = tiling.get("block_dim")[0]

        ni_min = 1
        ni_max = N_RANGE

        full_k_in_l0a, full_k_in_l0b, grads_l1_tiling_nparts, \
            fmap_l1_tiling_nparts = self._check_full_k(tiling, dy_shape)
        batch_num_sc = utils.icd(n_i * d_o, block_dim_batch)

        # based on l0_attach and l1_attach
        if (full_k_in_l0a <= 0 and full_k_in_l0b <= 0) \
            and (grads_l1_tiling_nparts[0] != 1 \
            and fmap_l1_tiling_nparts[0] != 1):
            # batch wont influence attach flag
            return [ni_min, ni_max]
        else:
            # attach flag with different batch situation
            if batch_num_sc == 1:
                return [ni_min, utils.icd(block_dim_batch, d_o)]
            else:
                return [utils.icd(block_dim_batch + 1, d_o), ni_max]

    def assembly_case(self, tiling_strategy, covered, cnt):
        var_range = OrderedDict()
        block_dim_multi = tiling_strategy["AUB_shape"][0] if tiling_strategy["AUB_shape"] else 1
        block_dim_g = tiling_strategy["BUB_shape"][0] if tiling_strategy["BUB_shape"] else 1
        block_dims = block_dim_multi * block_dim_g * reduce(lambda x, y: x * y, tiling_strategy['block_dim'])
        if self.binary_mode:
            return {"key": cnt, "tiling_strategy": tiling_strategy, "var_range": var_range, "block_dim": block_dims}
        if self.dynamic_mode == "dynamic_dhw":
            x_n_low, x_n_high = utils.trans_to_int(covered[0]), utils.trans_to_int(covered[1])
            x_d_low, x_d_high = utils.trans_to_int(covered[2]), utils.trans_to_int(covered[3])
            x_h_low, x_h_high = utils.trans_to_int(covered[4]), utils.trans_to_int(covered[5])
            x_w_low, x_w_high = utils.trans_to_int(covered[6]), utils.trans_to_int(covered[7])
            self._set_padding_list(x_d_low, x_h_low, x_w_low)
            dedy_d_low = self._get_output_d(x_d_low)
            dedy_h_low = self._get_output_h(x_h_low)
            dedy_w_low = self._get_output_w(x_w_low)
            self._set_padding_list(x_d_high, x_h_high, x_w_high)
            dedy_d_high = self._get_output_d(x_d_high)
            dedy_h_high = self._get_output_h(x_h_high)
            dedy_w_high = self._get_output_w(x_w_high)

            var_range['batch_n'] = (x_n_low, x_n_high)
            var_range['fmap_d'] = (x_d_low, x_d_high)
            var_range['fmap_h'] = (x_h_low, x_h_high)
            var_range['fmap_w'] = (x_w_low, x_w_high)
            var_range['dedy_d'] = (dedy_d_low, dedy_d_high)
            var_range['dedy_h'] = (dedy_h_low, dedy_h_high)
            var_range['dedy_w'] = (dedy_w_low, dedy_w_high)
        elif self.dynamic_mode == "dynamic_batch":
            var_range['batch_n'] = (utils.trans_to_int(covered[0]), utils.trans_to_int(covered[1]))

        return {"key": cnt, "tiling_strategy": tiling_strategy,
                "var_range": var_range, "block_dim": block_dims}

    def get_default_range(self, tgt_area):
        """
        get default range

        Parameters
        ----------
        tgt_area : tuple, target area to be covered
        Returns
        -------
        list, default range
        """
        if not tgt_area[5]:
            tgt_area[5] = H_RANGE

        if not tgt_area[7]:
            fmap_w = 1
            while fmap_w <= W_RANGE:
                # calc pad_left and pad_right to get dedy_w
                self._set_padding_list(D_RANGE, H_RANGE, fmap_w)
                dedy_w = self._get_output_w(fmap_w)
                if not self._check_l1_limitation(fmap_w, dedy_w):
                    break
                fmap_w += 1
            tgt_area[7] = fmap_w - 1

        return super(Conv3dBpFilterTiling, self).get_default_range(tgt_area)

    def get_default_tiling(self):
        """
        get default tiling
        """
        tiling = self._get_default_tiling_extend()
        return tiling.get("tiling")

    def _check_invalid_choice(self, choice):
        al1_pb, bl1_pb, l0c_pb, abkl1_attach, al1_attach_flag, bl1_attach_flag, min_kl1_cmp_kl0,\
            load3d_special_flag, conv1d_flag = choice
        # Drop invalid choices
        choice_list = [al1_pb, abkl1_attach, al1_attach_flag, bl1_attach_flag, load3d_special_flag]
        invalid_choice = super()._check_invalid_choice(choice_list)

        # 1) b_l1 full_load to b_l1_pb off
        invalid_choice |= (bl1_attach_flag == utils.ATTACH_FULL_LOAD and bl1_pb != utils.DB_OFF)

        return invalid_choice

    def _gen_cache_tiling(self, cache_tiling, choice):
        '''
        Generate cache tiling and tiling_id.
        ---------------------------------------------
        |      variable     |    offset    |         value        |
        |     stride_read   |      15      |          0,1         |
        |       db_al1      |      14      |          0,1         |
        |       db_bl1      |      13      |          0,1         |
        |       db_l0c      |      12      |          0,1         |
        | abkl1_attach_flag |      10      |          0,1,2       |
        |  al1_attach_flag  |      8       |          0,1,2       |
        |  bl1_attach_flag  |      6       |          0,1,2       |
        |  min_kl1_cmp_kl0  |      5       |          0,1         |
        |  load3d_special   |      4       |          0,1         |
        |   conv1d_flag     |      3       |          0,1         |
        |    load_mode      |      2       |        0(load3d)     |
        |    binary_mode    |      0       |         0(6HD)       |

        Returns
        ----------
        cache_tiling:Value of tiling
        tiling_id: The id of tiling
        '''
        (cache_tiling.get('manual_pingpong_buffer')['AL1_pbuffer'],
         cache_tiling.get('manual_pingpong_buffer')['BL1_pbuffer'],
         cache_tiling.get('manual_pingpong_buffer')['CL0_pbuffer'],
         cache_tiling.get('attach_at_flag')['abkl1_attach_flag'],
         cache_tiling.get('attach_at_flag')['al1_attach_flag'],
         cache_tiling.get('attach_at_flag')['bl1_attach_flag'],
         cache_tiling.get('attach_at_flag')['min_kl1_cmp_kl0'],
         cache_tiling['load3d_special_flag'],
         cache_tiling['conv1d_flag']) = choice

        al1_pb, bl1_pb, l0c_pb, abkl1_attach, al1_attach_flag, bl1_attach_flag, min_kl1_cmp_kl0, \
        load3d_special_flag, conv1d_flag = choice
        offset = Conv3DBpFilterTilingIdOffset()
        tiling_id = 0
        tiling_id += self.strideh_read_flag << offset.strideh_read_flag
        tiling_id += (al1_pb - 1) << offset.db_al1_offset
        tiling_id += (bl1_pb - 1) << offset.db_bl1_offset
        tiling_id += (l0c_pb - 1) << offset.db_l0c_offset
        tiling_id += abkl1_attach << offset.abkl1_attach_flag_offset
        tiling_id += al1_attach_flag << offset.al1_attach_flag_offset
        tiling_id += bl1_attach_flag << offset.bl1_attach_flag_offset
        tiling_id += min_kl1_cmp_kl0 << offset.min_kl1_cmp_kl0_offset
        tiling_id += load3d_special_flag << offset.load3d_special_flag
        tiling_id += conv1d_flag << offset.conv1d_flag
        tiling_id += self.load_mode << offset.load_mode_offset
        tiling_id += (self.binary_mode - 1) << offset.binary_mode_offset

        return cache_tiling, tiling_id

    def _check_l1_limitation(self, fmap_w, dedy_w):
        al1_min_byte = C0_SIZE * C0_SIZE * utils.FP16_SIZE
        if dedy_w % C0_SIZE == 0:
            bl1_min_byte  = self.k_h_dilation * fmap_w * C0_SIZE * utils.FP16_SIZE
        else:
            bl1_min_byte = (self.k_h_dilation + self.stride_h) * fmap_w * C0_SIZE * utils.FP16_SIZE
        return (al1_min_byte + bl1_min_byte) <= tbe_platform_info.get_soc_spec("L1_SIZE")

    def _get_default_tiling_extend(self):
        tiling = {
            'AUB_shape': None, 'BUB_shape': None,
            'AL1_shape': [utils.CUBE_SIZE, 1, 1, 1],
            'BL1_shape': [utils.CUBE_SIZE, 1, 1, 1],
            'AL0_matrix': [1, 1, utils.CUBE_SIZE, utils.CUBE_SIZE, 1],
            'BL0_matrix': [1, 1, utils.CUBE_SIZE, utils.CUBE_SIZE, 1],
            'CL0_matrix': [1, 1, utils.CUBE_SIZE, utils.CUBE_SIZE, 1],
            'CUB_matrix': [1, 1, utils.CUBE_SIZE, utils.CUBE_SIZE, 1],
            'cout_bef_batch_flag': 0,
            'block_dim': [1, 1, 1, 1],
            'A_overhead_opt_flag': 0, 'B_overhead_opt_flag': 0,
            'manual_pingpong_buffer': {
                'AUB_pbuffer': 1, 'BUB_pbuffer': 1,
                'AL1_pbuffer': 1, 'BL1_pbuffer': 1,
                'AL0_pbuffer': 1, 'BL0_pbuffer': 1,
                'CL0_pbuffer': 1, 'CUB_pbuffer': 1,
                'UBG_pbuffer': 1},
            "dynamic_l0a_attach": "dw_cc",
            "dynamic_l0b_attach": "dw_cc",
            "dynamic_al1_attach": "dw_cc",
            "dynamic_bl1_attach": "dw_cc",
            "bl1_hw_allin_flag": True,
            "batch_num_sc": 0,
            "flag_fmap_load2d": False,
            "k_atomic_add_len": 0
        }
        tiling_extend = {"tiling": tiling, "A_shape": self.a_info,
                         "B_shape": self.b_info}
        return tiling_extend

    def _get_calc_info(self):
        self._convert_type(self.a_info, self.b_info, self.c_info)
        self.k_d, self.k_h, self.k_w = self.c_info[1:4]
        self.k_cin = self.c_info[4]
        self.k_cout = self.c_info[0]
        self.stride_d, self.stride_h, self.stride_w = self.tiling_info["stride"]
        self.dilate_d, self.dilate_h, self.dilate_w = self.tiling_info["dilation"]
        pad_front, pad_back, pad_up, pad_down, pad_left, pad_right = self.tiling_info["pad"]
        dynamic_dhw_flag = (isinstance(pad_up, tvm.tir.PrimExpr) or isinstance(pad_front, tvm.tir.PrimExpr)
                            or isinstance(pad_left, tvm.tir.PrimExpr))
        if dynamic_dhw_flag:
            self.pad_mode = "SAME"
            self.cur_pads = [-1, -1, -1, -1, -1, -1]
            self.tiling_info["pad"] = [-1, -1, -1, -1, -1, -1]
        else:
            self.pad_mode = "FIX"
            self.cur_pads = [
                pad_front, pad_back, pad_up, pad_down, pad_left, pad_right
            ]

        self.k_d_dilation = (self.k_d - 1) * self.dilate_d + 1
        self.k_h_dilation = (self.k_h - 1) * self.dilate_h + 1
        self.k_w_dilation = (self.k_w - 1) * self.dilate_w + 1

    def _set_padding_list(self, cur_d, cur_h, cur_w):
        """
        get padding list in cur dx shape
        """

        if self.pad_mode == "SAME" and cur_d and cur_h and cur_w:
            pad_d = max(utils.align(cur_d, self.stride_d) -
                        self.stride_d + self.k_d_dilation - cur_d, 0)
            pad_front = pad_d // 2
            pad_back = pad_d - pad_front
            pad_h = max(utils.align(cur_h, self.stride_h) -
                        self.stride_h + self.k_h_dilation - cur_h, 0)
            pad_up = pad_h // 2
            pad_down = pad_h - pad_up
            pad_w = max(utils.align(cur_w, self.stride_w) -
                        self.stride_w + self.k_w_dilation - cur_w, 0)
            pad_left = pad_w // 2
            pad_right = pad_w - pad_left
            self.cur_pads = [pad_front, pad_back, pad_up, pad_down, pad_left, pad_right]

    def _get_bound_fmap(self, tiling,
                        width_grads, width_fmap,
                        local_tiling_flag, height_grads):
        """
        get bound info for _get_bound_fmap

        Parameters
        ----------
        tiling : dict, result of tiling fetch

        width_grads, width_fmap : int, size of w

        Returns
        -------
        int, load_length

        """

        # bl1 set storage bound
        # actual load length in k_reduce_axis
        bl1_k = tiling.get("BL1_shape")[0]
        block_dim_hw = tiling.get("AUB_shape")[0] \
            if tiling.get("AUB_shape") else 1
        hw_pad_1 = utils.icd(width_grads * height_grads, utils.CUBE_SIZE)
        flag_fmap_load2d = local_tiling_flag[-2]

        # load2d instructions refer to data_mov with raw lens
        if flag_fmap_load2d:
            return bl1_k

        if tiling["AL0_matrix"]:
            # dw_k equals to ka if L0A needs tiling
            dw_k = tiling["AL0_matrix"][1]
        elif tiling["BL0_matrix"]:
            dw_k = tiling["BL0_matrix"][0]
        else:
            # both fully loaded
            dw_k = hw_pad_1 // block_dim_hw

        hw_single_core_factor = utils.icd(hw_pad_1, block_dim_hw) * \
                                utils.CUBE_SIZE
        hw_single_core_factor = utils.align(hw_single_core_factor,
                                            dw_k * utils.CUBE_SIZE)

        if bl1_k < width_grads:
            # tiling load lenth less thenwidth_grads, need to load a full line
            # if res_data exists then need to load 2 lines
            ho_len = 1 if (width_grads % bl1_k == 0 and \
                           hw_single_core_factor % width_grads == 0) else 2
        else:
            # load3d instructions refer to load extra lines with pad/stride/filter
            if bl1_k % width_grads == 0 and \
                    hw_single_core_factor % width_grads == 0:
                # full line could load without extra lines
                additional_rows = 0
            elif bl1_k * 2 % width_grads == 0 or \
                bl1_k % width_grads == 1:
                # every 2 load3d covered only 1 extra line
                additional_rows = 1
            else:
                # other situations need 2 extra lines in case
                additional_rows = 2
            ho_len = bl1_k // width_grads + additional_rows

        hi_max = self.k_h_dilation + (ho_len - 1) * self.stride_h
        bl1_k_full = width_fmap * hi_max

        return bl1_k_full

    def _check_tiling_match(self, tiling, current_w, current_h, current_d, current_n):
        """

        check whether this tiling matches the shape

        Parameters
        ----------
        tiling : dict, result of tiling fetch

        current_size : int, size of h,w

        Returns
        -------
        bool, True: match
            False: do not match

        """

        # shape info
        block_dim_batch = tiling.get("block_dim")[0]

        batch, w_i, h_i, d_i = current_n, current_w, current_h, current_d
        self._set_padding_list(d_i, h_i, w_i)
        d_o = self._get_output_d(d_i)
        h_o = self._get_output_h(h_i)
        w_o = self._get_output_w(w_i)
        howo_align = utils.align(h_o * w_o, utils.FP16_K)

        dy_shape = batch, d_o, self.a_info[2], h_o, w_o, utils.CUBE_SIZE
        fmap_shape = batch, d_i, self.b_info[2], h_i, w_i, utils.CUBE_SIZE

        if d_o <= 0 or h_o <= 0 or w_o <= 0:
            return False

        # flag check
        local_tiling_flag = self._get_attach_flag_detail(tiling,
                                                         dy_shape, fmap_shape)
        seed_tiling_flag = (tiling["dynamic_l0a_attach"],
                            tiling["dynamic_l0b_attach"],
                            tiling["dynamic_al1_attach"],
                            tiling["dynamic_bl1_attach"],
                            tiling["bl1_hw_allin_flag"],
                            tiling["batch_num_sc"],
                            tiling["d_pad_flag"],
                            tiling["flag_fmap_load2d"],
                            tiling["k_atomic_add_len"])

        for index, flag in enumerate(seed_tiling_flag[:-2]):
            if flag == "dw_cc":
                continue
            elif flag != local_tiling_flag[index]:
                return False

        # align tiling["BL1_shape"] for k_h * k_w
        tiling["BL1_shape"][1] = utils.align(
            tiling.get("BL1_shape")[1] * tiling.get("BL0_matrix")[1],
            self.k_h * self.k_w) // tiling.get("BL0_matrix")[1]

        # get k axis length in al1
        bl1_bound = self._get_bound_fmap(tiling,
                                         w_o, w_i, local_tiling_flag, h_o)

        # fmap size in L1 ( K *  N * db * 2byte)
        fmap_l1_size = (utils.FP16_SIZE * bl1_bound *
                        tiling['BL1_shape'][1] *
                        tiling["BL0_matrix"][1] // (self.k_h * self.k_w) *
                        utils.FP16_N *
                        tiling['manual_pingpong_buffer']['BL1_pbuffer'])

        # grad size
        if tiling["AL1_shape"]:
            # tiling size in L1 ( M * K * db * 2byte)
            al1_m = tiling["AL1_shape"][1] * tiling["AL0_matrix"][0] * utils.FP16_M
            grad_l1_size = (utils.FP16_SIZE * tiling["AL1_shape"][0] * al1_m *
                            tiling['manual_pingpong_buffer']['AL1_pbuffer'])
        else:
            # fully load in AL1
            al1_m = self.k_cout
            grad_l1_size = (utils.FP16_SIZE * howo_align * al1_m *
                            utils.icd(batch * d_o, block_dim_batch))

        return int(fmap_l1_size + grad_l1_size) <= tbe_platform_info.get_soc_spec("L1_SIZE")

    def _get_output_d(self, d_i):
        if not d_i:
            return None
        return max(1, (d_i + self.cur_pads[0] + self.cur_pads[1] - self.dilate_d *
                (self.k_d - 1) - 1) // self.stride_d + 1)

    def _get_output_h(self, h_i):
        if not h_i:
            return None
        return max(1, (h_i + self.cur_pads[2] + self.cur_pads[3] - self.dilate_h *
                       (self.k_h - 1) - 1) // self.stride_h + 1)

    def _get_output_w(self, w_i):
        if not w_i:
            return None
        return max(1, (w_i + self.cur_pads[4] + self.cur_pads[5] - self.dilate_w *
                (self.k_w - 1) - 1) // self.stride_w + 1)

    def _check_full_k(self, tiling, dy_shape):
        """
        set flag whether axis K is fully loaded in L0A and L0B
        return:
        -------
        full_k_l0a: 1 or 0, 1 means K is fully loaded in L0A
        full_k_l0b: 1 or 0, 1 means K is fully loaded in L0B
        """

        # if k is fully load in BL1 and
        # there is multi load in N1 and N1 in BL1
        # isn't aligned to kernel_height*kernel_width, then align to it
        _, _, _, grads_height, grads_width, _ = dy_shape
        hw_mad_1 = utils.icd(grads_height * grads_width, utils.FP16_K)

        fmap_channel_1 = utils.icd(self.k_cin, utils.CUBE_SIZE)
        fkk = self.k_d * fmap_channel_1 * self.k_h * self.k_w
        c1_grads = utils.icd(self.k_cout, utils.CUBE_SIZE)
        block_dim_hw = tiling.get("AUB_shape")[0] \
            if tiling.get("AUB_shape") else 1

        block_dim_cout = tiling.get("block_dim")[2]
        block_dim_cin = tiling.get("block_dim")[1]

        if tiling.get("BL1_shape"):
            tiling["BL1_shape"][1] = utils.align(
                tiling.get("BL1_shape")[1] * tiling.get("BL0_matrix")[1],
                self.k_h * self.k_w) // tiling.get("BL0_matrix")[1]

        # whether axis K is fully loaded in L0A and L0B
        # excluding axis batch
        full_k_l0a = 1 \
            if not tiling["AL0_matrix"] \
            else tiling["AL0_matrix"][1] // utils.icd(hw_mad_1, block_dim_hw)
        full_k_l0b = 1 \
            if not tiling["BL0_matrix"] \
            else tiling["BL0_matrix"][0] // utils.icd(hw_mad_1, block_dim_hw)

        dw_tiling_factor = [tiling["CL0_matrix"][0], tiling["CL0_matrix"][1]]
        dw_tiling_nparts = \
            [utils.icd(fkk // block_dim_cin, dw_tiling_factor[0]),
             utils.icd(utils.icd(c1_grads, dw_tiling_factor[1]), block_dim_cout)]

        if tiling["AL1_shape"]:  # if grads needs tiling in L1
            if len(tiling["AL1_shape"]) == 1: # but no C_1 tiling info
                tiling["AL1_shape"] = tiling["AL1_shape"] + [1]
            # nparts K1 in L1, nparts M1 in L1
            grads_l1_tiling_nparts = [
                utils.icd(hw_mad_1,
                          (block_dim_hw *
                           (tiling["AL1_shape"][0] // utils.CUBE_SIZE))),
                dw_tiling_nparts[1] // tiling["AL1_shape"][1]]
        else:
            grads_l1_tiling_nparts = [1, 1]

        if tiling["BL1_shape"]: # if fmap needs tiling in L1
            if len(tiling["BL1_shape"]) == 1: # but no fkk tiling info
                tiling["BL1_shape"] = \
                    tiling["BL1_shape"] + [1] # tiling fkk=1
            # DDR to L1 [nparts K1, nparts N1]
            fmap_l1_tiling_nparts = [
                utils.icd(hw_mad_1,
                          (block_dim_hw *
                           (tiling["BL1_shape"][0] // utils.CUBE_SIZE))),
                dw_tiling_nparts[0] // tiling["BL1_shape"][1]]
        else:
            fmap_l1_tiling_nparts = [1, 1]

        return full_k_l0a, full_k_l0b, \
               grads_l1_tiling_nparts, fmap_l1_tiling_nparts

    def _get_attach_flag(self, tiling_extend):
        """
        tiling_extend: tiling with "A_shape", "B_shape", "C_shape"
        """

        tiling = tiling_extend["tiling"]
        dy_shape = tiling_extend["A_shape"]
        fmap_shape = tiling_extend["B_shape"]

        l0a_attach, l0b_attach, al1_attach, bl1_attach, \
            bl1_hw_allin_flag, batch_num_sc, d_pad_flag, \
            flag_fmap_load2d, k_atomic_add_len = \
            self._get_attach_flag_detail(tiling, dy_shape, fmap_shape)

        tiling.update({
            "dynamic_l0a_attach": l0a_attach,
            "dynamic_l0b_attach": l0b_attach,
            "dynamic_al1_attach": al1_attach,
            "dynamic_bl1_attach": bl1_attach,
            "bl1_hw_allin_flag": bl1_hw_allin_flag,
            "batch_num_sc": batch_num_sc,
            "d_pad_flag": d_pad_flag,
            "flag_fmap_load2d": flag_fmap_load2d,
            "k_atomic_add_len": k_atomic_add_len})

    def _get_attach_flag_detail(self, tiling, dy_shape, fmap_shape):
        l0a_attach = None
        l0b_attach = None
        al1_attach = None
        bl1_attach = None
        bl1_hw_allin_flag = False
        flag_fmap_load2d = False
        k_atomic_add_len = -1

        batch = dy_shape[0]
        dy_d = dy_shape[1]
        fmap_c1 = fmap_shape[2]
        block_dim_batch = tiling.get("block_dim")[0]
        block_dim_hw = tiling.get("AUB_shape")[0] \
            if tiling.get("AUB_shape") else 1

        d_pad_flag = False
        if self.cur_pads[0] != 0 or self.cur_pads[1] != 0:
            if tiling.get("BL0_matrix"):
                n_l0 = tiling.get("BL0_matrix")[1]
                if fmap_c1 * self.k_h_dilation * self.k_w_dilation % n_l0 != 0:
                    d_pad_flag = True
            else:
                d_pad_flag = True

        batch_num_sc = utils.icd(batch * dy_d, block_dim_batch)

        height_all_one = (self.stride_h == 1
            and dy_shape[3] == 1 and fmap_shape[3] == 1
            and self.k_h == 1)
        width_all_one = (self.stride_w == 1
            and dy_shape[4] == 1 and fmap_shape[4] == 1
            and self.k_w == 1)

        # load2d check
        flag_fmap_load2d = height_all_one and width_all_one

        full_k_in_l0a, full_k_in_l0b, grads_l1_tiling_nparts, \
            fmap_l1_tiling_nparts = self._check_full_k(tiling, dy_shape)
        l0a_attach, l0b_attach = self._get_l0_attach(
            tiling, batch_num_sc, full_k_in_l0a, full_k_in_l0b)
        al1_attach, bl1_attach = self._get_l1_attach(
            tiling, batch_num_sc, grads_l1_tiling_nparts, fmap_l1_tiling_nparts)

        bl1_hw_allin_flag = self._get_bl1_hw_allin_flag(
            tiling, fmap_l1_tiling_nparts)

        fmap_hw_align = utils.align(fmap_shape[3] * fmap_shape[4], 16)
        k_atomic_add_len = utils.align(
            utils.icd(fmap_hw_align, block_dim_hw), 16)

        return l0a_attach, l0b_attach, al1_attach, bl1_attach, \
                bl1_hw_allin_flag, batch_num_sc == 1, d_pad_flag, \
                flag_fmap_load2d, k_atomic_add_len

    @staticmethod
    def _get_bl1_hw_allin_flag(tiling, fmap_l1_tiling_nparts):
        if tiling.get("BL1_shape"):
            if fmap_l1_tiling_nparts[0] == 1:
                return True
        else:
            return True
        return False

    @staticmethod
    def _get_l0_attach(tiling, batch_num_sc, full_k_in_l0a, full_k_in_l0b):
        l0a_attach = None
        l0b_attach = None

        if tiling.get("AL0_matrix"):
            l0a_attach = "dw_ddr" if batch_num_sc == 1 and full_k_in_l0a > 0 \
                else "dw_cc"

        if tiling.get("BL0_matrix"):
            l0b_attach = "dw_ddr" if batch_num_sc == 1 and full_k_in_l0b > 0 \
                else "dw_cc"
        return l0a_attach, l0b_attach

    @staticmethod
    def _get_l1_attach(tiling, batch_num_sc, grads_l1_tiling_nparts,
                       fmap_l1_tiling_nparts):
        al1_attach = None
        bl1_attach = None

        if tiling.get("AL1_shape"):
            # if axis K needs split, then attach to dw_cc else attach to dw_ddr
            al1_attach = "dw_cc" if grads_l1_tiling_nparts[0] != 1 or \
                batch_num_sc != 1 else "dw_ddr"

        if tiling.get("BL1_shape"):
            # if axis k needs split, then attch to dw_cc else attcah to dw_ddr
            bl1_attach = "dw_cc" if fmap_l1_tiling_nparts[0] != 1 or \
                batch_num_sc != 1 else "dw_ddr"
        return al1_attach, bl1_attach


class Conv3dBpFilterStaticTiling(CubeStaticTilingOp):
    def __init__(self, out_list):
        super().__init__(out_list)
        self._set_tiling_info_dict()
        self.in_dtype = DynamicParams.tiling_info_dict.get('a_dtype')

    def _set_tiling_info_dict(self):
        self.tiling_info_dict = DynamicParams.tiling_info_dict
        if self.tiling_info_dict.get('dynamic_shape_flag'):
            self.tiling_info_dict['dynamic_shape_flag'] = False

    def _support_optiling(self, is_binary_const=True):
        """
        Determine whether it is supported dyn_const_tiling and cache_tiling
        """
        if not is_binary_const:
            return False

        if not tbe_platform_info.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out"):
            return False

        return True

    def _get_default_tiling(self):
        """
        get default tiling for conv3dbpfilter
        """
        return {
            'AUB_shape': None,
            'BUB_shape': None,
            'AL1_shape': [CUBE_DIM, 1, 1],
            'BL1_shape': [CUBE_DIM, 1, 1],
            'AL0_matrix': [1, 1, CUBE_DIM, CUBE_DIM, 1],
            'BL0_matrix': [1, 1, CUBE_DIM, CUBE_DIM, 1],
            'CL0_matrix': [1, 1, CUBE_DIM, CUBE_DIM, 1],
            'CUB_matrix': [1, 1, CUBE_DIM, CUBE_DIM, 1],
            'block_dim': [1, 1, 1, 1],
            'cout_bef_batch_flag': 0,
            'A_overhead_opt_flag': 0,
            'B_overhead_opt_flag': 0,
            'manual_pingpong_buffer': {
                'AUB_pbuffer': 1,
                'BUB_pbuffer': 1,
                'AL1_pbuffer': 1,
                'BL1_pbuffer': 1,
                'AL0_pbuffer': 1,
                'BL0_pbuffer': 1,
                'CL0_pbuffer': 1,
                'CUB_pbuffer': 1,
                'UBG_pbuffer': 1
            }
        }

    def _get_and_transfer_cache_tiling(self):
        """
        get cache_tiling and transfer it to static tiling
        """
        log.error("[optiling] Conv3dBackpropFilter does not currently support cachtiling")
