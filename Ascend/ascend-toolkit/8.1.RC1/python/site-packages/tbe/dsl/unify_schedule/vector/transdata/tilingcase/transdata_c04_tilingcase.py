#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2023. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
transdata c04 tilingcase
"""

from tbe.common.utils import op_tiling
from tbe.common.platform.platform_info import get_soc_spec
from tbe.dsl.base.operation import get_context
from tbe.dsl.base.operation import get_compile_info
from tbe.dsl.base.operation import add_compile_info_inner
from tbe.dsl.unify_schedule.util import shape_to_list
from tbe.dsl.unify_schedule.constants import CompileInfo
from tbe.dsl.classifier.transdata.constants import FORMATC04, FORMATC04BACKWARD, RESERVED_SPACE
from tbe.dsl.classifier.transdata.constants import Tiling, DATA_TYPE_SIZE
from ..common.graph.graph import Graph
from ..transdata_entrance import Collecting

CONST_KEY = 123


class TransdataC04Case:
    def __init__(self, blk_idx=None, key=CONST_KEY, split_full_hw=0):
        self.tiling_key = key
        self.block_split_idx = blk_idx
        self.ub_split_first_idx = 0
        self.ub_split_second_idx = 1
        self.block_dim = None

        self.block_factor = None
        self.ub_first_factor = None
        self.ub_second_factor = None
        self.buffer_size = None
        self.is_split_full_hw = split_full_hw


def calc_buffer_size(graph_info):
    def calc_value(_nodes):
        value = 0
        for v in _nodes:
            value += DATA_TYPE_SIZE[v]
        return value

    node_list = graph_info.exist_nodes
    max_value = max([calc_value(node) for node in node_list])
    soc_ub_size = get_soc_spec("UB_SIZE") - RESERVED_SPACE
    return soc_ub_size // max_value // 128 * 128


class TilingTransdataC04(Collecting):
    def __init__(self, outs, option):
        Collecting.__init__(self, outs, option)
        self.is_const = None
        self.is_forward = None
        self.graph_info = None
        self.common_info = None

    @classmethod
    def get_tiling(cls):
        return Tiling.TRANSDATAC04

    def do_tiling_case(self):
        outs = list(self.outs) if isinstance(self.outs, (list, tuple)) else [self.outs]
        self.graph_info = Graph(outs)
        self.is_const = get_compile_info().get("_is_const")
        self.is_forward = get_compile_info().get("_is_forward")
        get_context().get_current_compute().add("_compute_graph_info", self.graph_info)

        add_compile_info_inner("_is_c04", True)
        return self.cst_tilingcase() if self.is_const else self.dync_tilingcase()

    def cst_tilingcase(self):
        input_tensor = list(self.graph_info.input_tensor_set)[0]
        output_tensor = list(self.graph_info.output_tensor_set)[0]
        input_shape = shape_to_list(input_tensor.shape)
        output_shape = shape_to_list(output_tensor.shape)
        src_format, dst_format = get_context().get("_transdata_format")
        inputs = [{"shape": input_shape, "dtype": input_tensor.dtype, "format": src_format}]
        outputs = [{"shape": output_shape, "dtype": output_tensor.dtype, "format": dst_format}]

        cst_case = TransdataC04Case()
        cst_case.buffer_size = calc_buffer_size(self.graph_info)
        is_runtime_const = 0
        core_num = get_soc_spec("CORE_NUM")
        self.common_info = [int(self.is_const), is_runtime_const, cst_case.buffer_size, core_num]
        add_compile_info_inner("_common_info", self.common_info)

        run_info = op_tiling.do_op_tiling("Transdata", get_compile_info(), inputs, outputs)
        tiling_data = op_tiling.decode(run_info["tiling_data"], FORMATC04)
        return self.assign_data(cst_case, tiling_data)

    def assign_data(self, cst_case, tiling_data):
        cst_case.block_split_idx = tiling_data["block_split_idx"]
        cst_case.block_factor = tiling_data["block_factor"]
        cst_case.ub_first_factor = tiling_data["ub_first_factor"]
        cst_case.ub_second_factor = tiling_data["ub_second_factor"]
        cst_case.block_dim = tiling_data["block_dim"]
        cst_case.is_split_full_hw = tiling_data["is_split_full_hw"]

        # Set Const Runtime cores
        # Set Const Runtime mark
        self.common_info[1] = 1
        add_compile_info_inner("_common_info", self.common_info)
        add_compile_info_inner(CompileInfo.CONST_BLOCK_DIMS,
                               {str(cst_case.tiling_key): tiling_data["block_dim"]})
        return [cst_case, ]

    def dync_tilingcase(self):
        buffer_size = calc_buffer_size(self.graph_info)
        is_runtime_const = 0
        core_num = get_soc_spec("CORE_NUM")
        self.common_info = [int(self.is_const), is_runtime_const, buffer_size, core_num]
        add_compile_info_inner("_common_info", self.common_info)

        case_0 = TransdataC04Case(blk_idx=0, key=100)
        case_1 = TransdataC04Case(blk_idx=1, key=200)
        case_2 = TransdataC04Case(blk_idx=0, key=300, split_full_hw=1)
        case_3 = TransdataC04Case(blk_idx=1, key=400, split_full_hw=1)
        case_0.buffer_size = buffer_size
        case_1.buffer_size = buffer_size
        case_2.buffer_size = buffer_size
        case_3.buffer_size = buffer_size
        return [case_0, case_1, case_2, case_3]


class TransdataC04BackwardCase:
    def __init__(self, blk_idx=None, key=CONST_KEY):
        self.tiling_key = key
        self.block_split_idx = blk_idx
        self.ub_split_first_idx = 2
        self.ub_split_second_idx = 0
        self.block_dim = None

        self.block_factor = None
        self.ub_first_factor = None
        self.ub_second_factor = None
        self.buffer_size = None


class TilingTransdataC04Backward(Collecting):
    def __init__(self, outs, option):
        Collecting.__init__(self, outs, option)
        self.is_const = None
        self.is_forward = None
        self.graph_info = None
        self.common_info = None

    @classmethod
    def get_tiling(cls):
        return Tiling.TRANSDATAC04BACKWARD

    def do_tiling_case(self):
        outs = list(self.outs) if isinstance(self.outs, (list, tuple)) else [self.outs]
        self.graph_info = Graph(outs)
        self.is_const = get_compile_info().get("_is_const")
        self.is_forward = get_compile_info().get("_is_forward")
        get_context().get_current_compute().add("_compute_graph_info", self.graph_info)

        add_compile_info_inner("_is_c04_backward", True)
        return self.cst_tilingcase() if self.is_const else self.dync_tilingcase()

    def cst_tilingcase(self):
        input_tensor = list(self.graph_info.input_tensor_set)[0]
        output_tensor = list(self.graph_info.output_tensor_set)[0]
        input_shape = shape_to_list(input_tensor.shape)
        output_shape = shape_to_list(output_tensor.shape)
        src_format, dst_format = get_context().get("_transdata_format")
        inputs = [{"shape": input_shape, "dtype": input_tensor.dtype, "format": src_format}]
        outputs = [{"shape": output_shape, "dtype": output_tensor.dtype, "format": dst_format}]

        cst_case = TransdataC04BackwardCase()
        cst_case.buffer_size = calc_buffer_size(self.graph_info)
        is_runtime_const = 0
        core_num = get_soc_spec("CORE_NUM")
        self.common_info = [int(self.is_const), is_runtime_const, cst_case.buffer_size, core_num]
        add_compile_info_inner("_common_info", self.common_info)

        run_info = op_tiling.do_op_tiling("Transdata", get_compile_info(), inputs, outputs)
        tiling_data = op_tiling.decode(run_info["tiling_data"], FORMATC04BACKWARD)
        return self.assign_data(cst_case, tiling_data)

    def assign_data(self, cst_case, tiling_data):
        cst_case.block_split_idx = tiling_data["block_split_idx"]
        cst_case.block_factor = tiling_data["block_factor"]
        cst_case.ub_first_factor = tiling_data["ub_first_factor"]
        cst_case.ub_second_factor = tiling_data["ub_second_factor"]
        cst_case.block_dim = tiling_data["block_dim"]

        # Set Const Runtime cores
        # Set Const Runtime mark
        self.common_info[1] = 1
        add_compile_info_inner("_common_info", self.common_info)
        add_compile_info_inner(CompileInfo.CONST_BLOCK_DIMS,
                               {str(cst_case.tiling_key): tiling_data["block_dim"]})
        return [cst_case, ]

    def dync_tilingcase(self):
        buffer_size = calc_buffer_size(self.graph_info)
        is_runtime_const = 0
        core_num = get_soc_spec("CORE_NUM")
        self.common_info = [int(self.is_const), is_runtime_const, buffer_size, core_num]
        add_compile_info_inner("_common_info", self.common_info)

        case_0 = TransdataC04BackwardCase(blk_idx=0, key=100)
        case_1 = TransdataC04BackwardCase(blk_idx=2, key=200)
        case_0.buffer_size = buffer_size
        case_1.buffer_size = buffer_size
        return [case_0, case_1]
