#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
sparse apply tiling case
"""

from tbe import tvm
from tbe.common.utils import op_tiling
from tbe.dsl.base import operation
from tbe.dsl.base.operation import add_compile_info_inner
from tbe.common.platform.platform_info import get_soc_spec
from ...computation import Computation
from ...constants import Pattern

SPARSE = 100
SPARSE_OUT = 200
COL = 300
MIX = 400
NONE = 500


class SparseComputation(Computation):
    """
    SparseComputation
    """

    def __init__(self, outs, option):
        self.outs = outs
        self.option = option
        self.row = outs[0].shape[0]
        self.col = outs[0].shape[1]
        self.idx = outs[0].op.sparse_axis[0].dom.extent
        self.core_num = get_soc_spec("CORE_NUM")
        # threshold for max col loaded to ub at once, will be replaced by max coexist nodes
        self.max_c_in_ub = 3200
        # threshold for col axis, exceed this threshold col will involved in block strategy, else not
        self.col_for_block = 64
        # a threshold, exceed this threshold, multi-core is disabled
        self.min_col_threshold = 8
        self.cases = []
        self.block_key_map = {"sparse": SPARSE, "sparse_out": SPARSE_OUT, "col": COL, "mix": MIX, "none": NONE}
        self.tiling_data = None

    @classmethod
    def get_instance(cls, outs, option):
        return cls(outs, option)

    @classmethod
    def get_supported_pattern(cls):
        return [Pattern.SPARSE_APPLY]

    @classmethod
    def get_supported_soc(cls):
        return ["default"]

    def get_sub_pattern(self):
        return ""

    def do_tiling_case(self):
        """
        do tiling case

        Parameters
        ----------
        None

        Returns
        -------
        None
        """
        self._init_cases()
        self._calc_tiling_key()
        self._add_compile_info()
        self._filter_cases()
        self._add_caseinfo()
        return self.cases

    def _init_cases(self):
        """
        initialize cases

        Parameters
        ----------
        None

        Returns
        -------
        None
        """
        self.cases = []
        self.cases.append({"block_axis": "sparse", "split_col_for_ub_tiling": False, "vec_multi_idx": False})
        self.cases.append({"block_axis": "sparse", "split_col_for_ub_tiling": True, "vec_multi_idx": False})
        self.cases.append({"block_axis": "sparse_out", "split_col_for_ub_tiling": False, "vec_multi_idx": False})
        self.cases.append({"block_axis": "sparse_out", "split_col_for_ub_tiling": False, "vec_multi_idx": True})
        self.cases.append({"block_axis": "sparse_out", "split_col_for_ub_tiling": True, "vec_multi_idx": False})
        self.cases.append({"block_axis": "col", "split_col_for_ub_tiling": False, "vec_multi_idx": False})
        self.cases.append({"block_axis": "col", "split_col_for_ub_tiling": True, "vec_multi_idx": False})
        self.cases.append({"block_axis": "mix", "split_col_for_ub_tiling": False, "vec_multi_idx": False})
        self.cases.append({"block_axis": "mix", "split_col_for_ub_tiling": True, "vec_multi_idx": False})
        self.cases.append({"block_axis": "none", "split_col_for_ub_tiling": False, "vec_multi_idx": False})

    def _filter_cases(self):
        # filter unnessary tilingcase when compile, reserved
        if operation.get_op_mode() == "static":
            op_type = "AutoTiling"
            compile_info = {
                "_core_num": self.core_num,
                "_max_col_in_ub": self.max_c_in_ub,
                "_min_col_for_block": self.col_for_block,
                "_min_col_threshold": self.min_col_threshold,
                "_opt_level": 1,
                "_pattern": "SparseApply"
            }
            inputs = []
            outputs = []
            var_shape = (int(self.row), int(self.col))
            idx_shape = (int(self.idx), )
            inputs.append({"shape": var_shape, "dtype": self.outs[0].dtype})
            inputs.append({"shape": idx_shape, "dtype": "int32"})
            run_info = op_tiling.do_op_tiling(op_type, compile_info, inputs, outputs)
            tiling_format = {
                "_row": "int64",
                "_col": "int64",
                "_idx": "int64",
                "_s_factor": "int64",
                "_c_block_factor": "int64",
                "_c_ub_factor": "int64",
                "_idx_factor": "int64"
            }
            self.tiling_data = op_tiling.decode(run_info.get("tiling_data"), tiling_format)
            tiling_key = run_info.get("tiling_key")
            ret = []
            for case in self.cases:
                if case.get("key") == tiling_key:
                    ret.append(case)
                    break
            self.cases = ret

    def _calc_tiling_key(self):
        """
        calc tilingkey for every case, key = block_key + ub_split_key

        Parameters
        ----------
        None

        Returns
        -------
        None
        """
        for case in self.cases:
            block_axis = case.get("block_axis")
            block_key = self.block_key_map.get(block_axis)
            ub_split_key = 0
            vec_key = 0
            if case.get("split_col_for_ub_tiling"):
                ub_split_key = 1
            if case.get("vec_multi_idx"):
                vec_key = 10
            tiling_key = block_key + vec_key + ub_split_key
            case["key"] = tiling_key

    def _add_caseinfo(self):
        """
        add extra info, these will be read in schedule

        Parameters
        ----------
        None

        Returns
        -------
        None
        """
        for case in self.cases:
            case["max_col_in_ub"] = self.max_c_in_ub
            case["min_col_threshold"] = self.min_col_threshold
            case["min_col_for_block"] = self.col_for_block
            case["core_num"] = self.core_num
            case["tiling_data"] = self.tiling_data

    def _add_compile_info(self):
        """
        add compile info

        Parameters
        ----------
        None

        Returns
        -------
        None
        """
        add_compile_info_inner("_core_num", self.core_num)
        add_compile_info_inner("_max_col_in_ub", self.max_c_in_ub)
        add_compile_info_inner("_min_col_for_block", self.col_for_block)
        add_compile_info_inner("_min_col_threshold", self.min_col_threshold)
        add_compile_info_inner("_opt_level", 1)
