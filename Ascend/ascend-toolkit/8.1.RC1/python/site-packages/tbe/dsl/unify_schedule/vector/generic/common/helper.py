#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2023-2024 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
helper
"""
from collections.abc import Iterable
from copy import copy

from tbe import tvm
from tbe.common.context import op_context
from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.base import operation
from tbe.tvm import Stage

from . import constants
from .... import constants as unify_constants
from .... import util


def get_op_num():
    op_info = operation.get_op_context().get_op_info()

    return len(op_info) if op_info is not None else 0


def judge_iterable(obj):
    """
    judge object is iterable
    """
    return isinstance(obj, Iterable)


def raise_error(error_message, error_code="E90001"):
    """
    raise and report error
    """
    dict_args = {"errCode": error_code, "detailed_cause": error_message}
    raise RuntimeError(dict_args, get_error_message(dict_args))


def check_true(condition, error_message, error_code="E90001"):
    """
    if condition is false, raise and report error
    """
    if not condition:
        raise_error(error_message, error_code)


def report_fusion_check_result(check_result=True):
    reported_result = 0 if check_result else -1
    op_context.get_context().add_addition("_fusion_check_result", reported_result)


def copy_dict(src_dict):
    """
    copy keys and values
    """
    dst_dict = {}
    for tensor, tensor_list in src_dict.items():
        dst_dict[tensor] = copy(tensor_list)

    return dst_dict


def get_actual_value(ori_value):
    """
    get actual value of ori_value
    """
    return ori_value.value if isinstance(ori_value, tvm.expr.ConstExpr) else ori_value


def value_aligned(ori_value, align_factor, is_ceil=True, is_process_zero=True):
    """
    align value according to align_factor
    """
    if is_process_zero and ori_value == 0:
        return align_factor

    if is_ceil:
        return (ori_value + align_factor - 1) // align_factor * align_factor

    return ori_value // align_factor * align_factor


def calc_shape_product(shape, start_idx=0, end_idx=None):
    """
    calculate shape product from start_idx to end_idx
    """
    if end_idx is None:
        end_idx = len(shape)

    if not shape:
        return 1

    product = 1
    for idx in range(start_idx, end_idx):
        actual_value = get_actual_value(shape[idx])
        if isinstance(actual_value, int):
            product *= actual_value

    return product


def calc_iter_vars_extent_product(iter_vars_list, start_idx=0, end_idx=None):
    """
    calculate extent product of iter_vars from start_idx to end_idx
    """
    if end_idx is None:
        end_idx = len(iter_vars_list)

    product = 1
    for idx in range(start_idx, end_idx):
        dim_value = get_extent_of_iter_var(iter_vars_list[idx])
        actual_dim_value = get_actual_value(dim_value)
        if isinstance(actual_dim_value, int):
            product *= actual_dim_value

    return product


def judge_the_equality_of_tvm_shape(left_shape, right_shape):
    """
    judge equality of two tvm shapes
    """
    if len(left_shape) != len(right_shape):
        return False

    for _, (left_dim, right_dim) in enumerate(zip(left_shape, right_shape)):
        if not util.expr_equal(left_dim, right_dim):
            return False

    return True


def judge_reduce_axis(iter_var):
    """
    judge iter_var is reduce_axis
    """
    return iter_var.iter_type == constants.IterVarType.CommReduce.value


def compare_iter_var_vs_value(iter_var, right_value, op):
    """
    compare iter_var and value according to certain op
    """
    last_dim_value = get_extent_of_iter_var(iter_var)
    if last_dim_value is None:
        return False

    last_dim_range = util.get_bound(last_dim_value)

    return compare_value_vs_value(last_dim_value, right_value, op) or \
        compare_range_vs_value(last_dim_range, right_value, op)


def compare_value_vs_value(left_value, right_value, op):
    """
    compare value and value according to certain op
    """
    left_actual_value = get_actual_value(left_value)
    if not isinstance(left_actual_value, int):
        return False
    right_actual_value = get_actual_value(right_value)
    if not isinstance(right_actual_value, int):
        return False

    res = None
    if op == constants.CmpOp.LT:
        res = left_actual_value < right_actual_value
    elif op == constants.CmpOp.GT:
        res = left_actual_value > right_actual_value
    elif op == constants.CmpOp.LE:
        res = left_actual_value <= right_actual_value
    elif op == constants.CmpOp.GE:
        res = left_actual_value >= right_actual_value
    elif op == constants.CmpOp.EQ:
        res = left_actual_value == right_actual_value
    elif op == constants.CmpOp.NE:
        res = left_actual_value != right_actual_value
    else:
        raise_error("func of compare_value_vs_value does not support current operation, please check.")

    return res


def compare_range_vs_value(left_range, right_value, op):
    """
    compare range and value according to certain op
    """
    lower_bound, upper_bound = left_range[0], left_range[1]
    lower_bound_actual_value = get_actual_value(lower_bound)
    upper_bound_actual_value = get_actual_value(upper_bound)

    right_actual_value = get_actual_value(right_value)
    if not isinstance(right_actual_value, int):
        return False

    res = None
    if op == constants.CmpOp.LT:
        res = upper_bound_actual_value < right_actual_value
    elif op == constants.CmpOp.GT:
        res = lower_bound_actual_value > right_actual_value
    elif op == constants.CmpOp.LE:
        res = upper_bound_actual_value <= right_actual_value
    elif op == constants.CmpOp.GE:
        res = lower_bound_actual_value >= right_actual_value
    else:
        raise_error("func of compare_range_vs_value does not support current operation, please check.")

    return res


def get_extent_of_iter_var(iter_var):
    """
    get iter_var's extent
    """
    if iter_var.dom is None:
        return None

    return iter_var.dom.extent


def judge_the_equality_of_iter_vars(left_iter_var, right_iter_var):
    """
    judge equality of two iter_vars
    """
    if left_iter_var.dom is None or right_iter_var.dom is None:
        return False

    return util.expr_equal(left_iter_var.dom.min, right_iter_var.dom.min) and \
        util.expr_equal(left_iter_var.dom.extent, right_iter_var.dom.extent)


def judge_the_equality_of_iter_var_vs_int(iter_var, extent_value):
    """
    judge equality of iter_var and int
    """
    return util.expr_equal(iter_var.dom.min, 0) and util.expr_equal(iter_var.dom.extent, extent_value)


def get_insn(tensor):
    """
    get insn name of pass
    """
    insn = util.get_dsl_insn(tensor)

    return unify_constants.INSN_MAPPING.get(insn, insn)


def get_bytes_num(dtype):
    """
    get number of bytes according to dtype
    """
    return unify_constants.DTYPE_BYTE_MAPPING.get(dtype)


def get_bit_dtype(dtype):
    """
    get bit dtype according to dtype
    """
    bytes_num = get_bytes_num(dtype)
    bit_dtype = None
    if bytes_num == 0.125:
        bit_dtype = constants.BitDtype.B1
    elif bytes_num == 1:
        bit_dtype = constants.BitDtype.B8
    elif bytes_num == 2:
        bit_dtype = constants.BitDtype.B16
    elif bytes_num == 4:
        bit_dtype = constants.BitDtype.B32
    elif bytes_num == 8:
        bit_dtype = constants.BitDtype.B64
    else:
        raise_error("func of get_bit_dtype does not support current dtype.")

    return bit_dtype


def get_tvm_input_tensors(tvm_tensor):
    """
    get input_tensors of tensor
    """
    if not hasattr(tvm_tensor.op, "input_tensors"):
        return None

    return tvm_tensor.op.input_tensors


def get_tvm_tensor_max_dtype(tvm_tensor_list):
    """
    get max dtype of tensors
    """
    max_dtype = tvm_tensor_list[0].dtype
    for cur_tensor in tvm_tensor_list[1:]:
        if get_bytes_num(cur_tensor.dtype) > get_bytes_num(max_dtype):
            max_dtype = cur_tensor.dtype

    return max_dtype


def get_tvm_tensor_max_shape(tvm_tensor_list):
    """
    get max shape of tensors
    """
    max_dim_length = max(len(t.shape) for t in tvm_tensor_list)
    max_shape = [1] * max_dim_length
    for cur_tensor in tvm_tensor_list:
        cur_shape = util.shape_to_list(cur_tensor.shape)
        diff_length = max_dim_length - len(cur_shape)
        for idx in range(max_dim_length):
            cur_dim = 1 if idx < diff_length else cur_shape[idx - diff_length]
            if not util.expr_equal(max_shape[idx], cur_dim):
                max_shape[idx] = tvm.max(max_shape[idx], cur_dim)

    return util.shape_to_list(max_shape)


def calc_mte_continuous_bytes(shape, tiling_index, tiling_factor):
    """
    calc continuous_bytes of mte
    """
    if tiling_index is None:
        return calc_shape_product(shape, 0)

    return calc_shape_product(shape, tiling_index + 1) * tiling_factor


def traverse_obj(root_obj, visited_obj_list, traverse_func, stop_func=None):
    """
    traverse obj
    """
    ListHelper.add(visited_obj_list, root_obj)
    if callable(stop_func) and stop_func(root_obj):
        return
    iter_obj_list = traverse_func(root_obj)
    if iter_obj_list:
        for iter_obj in iter_obj_list:
            traverse_obj(iter_obj, visited_obj_list, traverse_func, stop_func)


def select_obj(root_obj, visited_obj_list, select_func, is_include_root=False):
    """
    select obj
    """
    select_obj_list = []
    for visit_obj in visited_obj_list:
        if not select_func(visit_obj):
            continue
        if not is_include_root:
            if visit_obj == root_obj:
                continue

        ListHelper.add(select_obj_list, visit_obj)

    return select_obj_list


def traverse_and_select_obj(root_obj, traverse_func, select_func, stop_func=None, is_include_root=False):
    """
    traverse and select obj
    """
    visited_obj_list = []
    traverse_obj(root_obj, visited_obj_list, traverse_func, stop_func)

    return select_obj(root_obj, visited_obj_list, select_func, is_include_root)


class AxesHelper:
    """
    axes helper methods
    """
    @classmethod
    def get_axis_of_reduce_according_to_index(cls, reduce_stage_obj, src_index):
        common_axes_count = 0
        reduce_axes_count = 0
        real_split_axis = None
        for idx in range(reduce_stage_obj.before_reduce_shape_length):
            if idx == src_index:
                if idx in reduce_stage_obj.reduce_axes_indices:
                    real_split_axis = reduce_stage_obj.tvm_stage.op.reduce_axis[reduce_axes_count]
                else:
                    if reduce_stage_obj.keep_dims:
                        real_split_axis = reduce_stage_obj.tvm_stage.op.axis[common_axes_count + reduce_axes_count]
                    else:
                        real_split_axis = reduce_stage_obj.tvm_stage.op.axis[common_axes_count]
                break

            if idx in reduce_stage_obj.reduce_axes_indices:
                reduce_axes_count += 1
            else:
                common_axes_count += 1

        return real_split_axis

    @classmethod
    def get_actual_split_axis(cls, ori_axis, split_info_list, is_post_split):
        while True:
            is_found = False
            for single_split_info in split_info_list:
                if single_split_info.ori_axis == ori_axis:
                    is_found = True
                    ori_axis = single_split_info.inner_axis if is_post_split else single_split_info.outer_axis
            if not is_found:
                break

        return ori_axis

    @classmethod
    def get_axes_after_split(cls, ori_axis, split_info_list):
        axes_list = [ori_axis]
        while True:
            is_found = False
            for single_split_info in split_info_list:
                local_axes_list = axes_list[:]
                for ori_axis in local_axes_list:
                    if ori_axis != single_split_info.ori_axis:
                        continue
                    ori_index = axes_list.index(ori_axis)
                    axes_list[ori_index:ori_index + 1] = [single_split_info.outer_axis, single_split_info.inner_axis]
            if not is_found:
                break

        return axes_list

    @classmethod
    def get_reorder_perm_according_to_reduce_axes(cls, shape_length, reduce_axes_indices):
        reorder_perm = [0] * shape_length
        reduce_axes_length = len(reduce_axes_indices)
        common_axes_start_pos = 0
        reduce_axes_start_pos = max(reduce_axes_indices) + 1 - reduce_axes_length

        for idx in range(shape_length):
            if idx <= max(reduce_axes_indices):
                if idx in reduce_axes_indices:
                    reorder_perm[reduce_axes_start_pos] = idx
                    reduce_axes_start_pos += 1
                else:
                    reorder_perm[common_axes_start_pos] = idx
                    common_axes_start_pos += 1
            else:
                # nlast common axes
                reorder_perm[reduce_axes_start_pos] = idx
                reduce_axes_start_pos += 1

        return reorder_perm

    @classmethod
    def get_common_node_reorder_axes(cls, tvm_stage: Stage, reorder_perm):
        ori_axes = tvm_stage.op.axis
        reorder_axes_list = [ori_axes[ori_idx] for ori_idx in reorder_perm]

        return reorder_axes_list

    @classmethod
    def fine_tune_common_node_reorder_axes_after_split(cls, tvm_stage, reduce_axes_indices, split_axes):
        # limit:
        # 1. reduce axes can not split
        ori_axes = tvm_stage.op.axis
        reorder_axes_list = tvm_stage.leaf_iter_vars[:]
        # nlast A before ub_inner, must be reordered to the positions before R
        # A0, A1, R0, R1, A2, ub_outer, ub_inner, A3 -> A0, A1, A2, ub_outer, R0, R1, ub_inner, A3
        reduce_axes_start_index = reorder_axes_list.index(ori_axes[min(reduce_axes_indices)])
        reduce_axes_end_index = reorder_axes_list.index(ori_axes[max(reduce_axes_indices)])
        if split_axes.ub_inner in reorder_axes_list:
            ub_inner_index = reorder_axes_list.index(split_axes.ub_inner)
        else:
            ub_inner_index = reduce_axes_end_index
        if reduce_axes_end_index + 1 < ub_inner_index:
            local_list = reorder_axes_list[reduce_axes_end_index + 1:ub_inner_index]
            reorder_axes_list[reduce_axes_end_index + 1:ub_inner_index] = []
            reorder_axes_list[reduce_axes_start_index:reduce_axes_start_index] = local_list

        return reorder_axes_list

    @classmethod
    def fine_tune_reduce_node_reorder_axes_after_split(cls, tvm_stage, split_axes):
        reorder_axes_list = tvm_stage.leaf_iter_vars[:]
        # nlast A before ub_inner, must be reordered to the positions before R
        # A0, A1, R0, R1, A2, ub_outer, ub_inner, A3 -> A0, A1, A2, ub_outer, R0, R1, ub_inner, A3
        reduce_axes_start_index = -1
        reduce_axes_end_index = -1
        for idx, iter_var in enumerate(reorder_axes_list):
            if judge_reduce_axis(iter_var):
                if iter_var != split_axes.block_outer and reduce_axes_start_index == -1:
                    reduce_axes_start_index = idx
                reduce_axes_end_index = idx

        if split_axes.ub_inner in reorder_axes_list:
            ub_inner_index = reorder_axes_list.index(split_axes.ub_inner)
        else:
            ub_inner_index = reduce_axes_end_index

        if reduce_axes_end_index + 1 < ub_inner_index:
            local_list = reorder_axes_list[reduce_axes_end_index + 1:ub_inner_index]
            reorder_axes_list[reduce_axes_end_index + 1:ub_inner_index] = []
            reorder_axes_list[reduce_axes_start_index:reduce_axes_start_index] = local_list

        return reorder_axes_list

    @classmethod
    def get_reduce_node_reorder_axes(cls, tvm_stage, reduce_axes_indices, keep_dims, reorder_perm):
        ori_reduce_axes = tvm_stage.op.reduce_axis
        ori_axes = tvm_stage.op.axis[:]
        # remove 1 due to keep_dims
        if keep_dims:
            for reduce_axis_idx in sorted(reduce_axes_indices, reverse=True):
                ori_axes.pop(reduce_axis_idx)

        reorder_axes_list = []
        count_common_axes = 0
        count_reduce_axes = 0
        for ori_idx in reorder_perm:
            if ori_idx in reduce_axes_indices:
                reorder_axes_list.append(ori_reduce_axes[count_reduce_axes])
                count_reduce_axes += 1
            else:
                reorder_axes_list.append(ori_axes[count_common_axes])
                count_common_axes += 1

        return reorder_axes_list


class ListHelper:
    """
    list helper methods
    """
    @classmethod
    def add(cls, ori_list, value, insert_index=None):
        """
        if value not in ori_list, add it
        """
        if value not in ori_list:
            if insert_index is not None:
                ori_list.insert(insert_index, value)
            else:
                ori_list.append(value)

    @classmethod
    def remove(cls, ori_list, value):
        """
        if value in ori_list, remove it
        """
        if value in ori_list:
            ori_list.remove(value)

    @classmethod
    def get_difference(cls, left_list, right_container):
        """
        get difference list between left_list and right_container
        """
        difference_list = []
        for value in left_list:
            if value not in right_container:
                ListHelper.add(difference_list, value)

        return difference_list

    @classmethod
    def has_intersection(cls, left_list, right_container):
        """
        has intersection between left_list and right_container
        """
        for value in left_list:
            if value in right_container:
                return True

        return False

    @classmethod
    def get_intersection(cls, left_list, right_container):
        """
        get intersection list between left_list and right_container
        """
        intersection_list = []
        for value in left_list:
            if value in right_container:
                ListHelper.add(intersection_list, value)

        return intersection_list

    @classmethod
    def get_union(cls, left_list, right_container):
        """
        get union list between left_list and right_container
        """
        union_list = left_list[:]
        for value in right_container:
            ListHelper.add(union_list, value)

        return union_list
