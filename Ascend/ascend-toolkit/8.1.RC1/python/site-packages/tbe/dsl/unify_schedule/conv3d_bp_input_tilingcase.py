#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
conv3d backprop input tiling case
"""
import copy
import json
import math

from collections import OrderedDict
from functools import reduce
from itertools import product
from typing import Dict
from typing import Iterable
from typing import List

from tbe import tvm
from tbe.common import platform as tbe_platform
from tbe.common.context import get_context
from tbe.common.context import op_context
from tbe.common.platform import platform_info as tbe_platform_info
from tbe.common.tiling import get_tiling
from tbe.common.tiling import get_tiling_type
from tbe.common.tiling import set_tiling_type
from tbe.common.tiling import tiling_api
from tbe.common.utils import const
from tbe.common.utils import do_op_tiling
from tbe.common.utils import log
from tbe.common.utils.const import SplitAxisMode
from tbe.common.utils.errormgr import error_manager_cube as err_man
from tbe.common.utils.errormgr import raise_err_message_cube
from tbe.common.utils.op_util.op_util_cube import decode_tiling
from tbe.dsl.base import operation
from tbe.dsl.base.operation import add_compile_info
from tbe.dsl.base.operation import get_compile_info
from tbe.dsl.base.operation import get_context as op_get_context
from tbe.dsl.base.operation import get_te_var
from tbe.dsl.base.operation import is_unify
from tbe.dsl.base.operation import register_build_pointcut
from tbe.dsl.base.operation import register_tiling_case
from tbe.dsl.compute import cube_util
from tbe.dsl.compute.conv3d_backprop_input_compute import DynamicConv3dBpInputParams
from tbe.dsl.compute.cube_util import BIT_RATIO_DICT
from tbe.dsl.compute.cube_util import Load3DParam
from tbe.dsl.static_schedule.conv_util import update_info_dict
from tbe.tvm.ir import PrimExpr

from .constants import Pattern
from .cube_tilingcase import CubeTilingOp
from .cube_tilingcase import TilingSelection
from .cube_tilingcase import TilingUtils as utils
from .tilingcase_util import BinaryTilingItem
from .tilingcase_util import Conv3dBackpropParaProcess
from .tilingcase_util import construct_tiling_case
from .tilingcase_util import is_valid_tiling
from .tilingcase_util import parse_run_info
from .util import get_core_num


H_RANGE = 4096
W_RANGE = 4096
W_DELTA = 1
D_DELTA = 1
H_LEN = 400
W_LEN = 400
D_LEN = 400
VALID_TILING_NUM = 32
_DEFAULT_TILING_FLAG = 32
DYNAMIC_FLAG = -1
UNKNOWN_FLAG = -2
UNKNOWN_SHAPE = [-2]
CONV3D_PADS_LEN = 6
_C0_SIZE = tbe_platform.C0_SIZE
BLOCK_K_DICT = {"float16": 16, "float32": 8, "int8": 32, "uint8": 32, "int32": 8, "uint4": 64, "int4": 64,
                "bfloat16": 16}
INT32_MAX = 2**31 - 1
BLOCK_DIM_MAX = 64
BINARY_RANGE_CONST_64 = 64
BINARY_RANGE_CONST_256 = 256
BINARY_RANGE_CONST_1024 = 1024


def _parse_fuzz_build_range(info_list):
    """
    parse multiple range segment from json string

    Notice
    ----------
    for conv3d only parse input range

    Parameters
    ----------
    info_list: list support info
        [{
            "inputs": [{
                "index": 2,
                "tensor": [{
                    "range": [
                        [1, 1],
                        [8, 15],
                        [32, 63],
                        [32, 63],
                        [64, 64]
                    ],
                    "shape": [-1, -1, -1, -1, 64]
                }]
            }]
        }]

    Returns
    -------
    range_list: list of 5d range
    """
    range_list = []
    target_index = 2
    for item in info_list:
        inputs = item.get("inputs")
        for input_tensor in inputs:
            invalid = (not isinstance(input_tensor, dict)) or input_tensor.get("index") != target_index
            if invalid:
                continue
            input_range = input_tensor.get("tensor")[0].get("range")
            if input_range:
                for axis_range in input_range:
                    invalid = (not isinstance(axis_range, list)) \
                              or len(axis_range) != 2 \
                              or axis_range[0] < 1 \
                              or axis_range[0] > axis_range[1]
                    if invalid:
                        raise RuntimeError("invalid range {}".format(str(axis_range)))
                range_list.append(input_range)
    return range_list


def _get_pad_mode(conv_info):
    """
    get pad mode from conv_info
    """
    pad_mode = "FIX"
    if any(isinstance(i, PrimExpr) for i in conv_info["pad"]):
        pad_mode = "VAR"
    return pad_mode


def gen_support_info(range_x):
    """
    kernel list support info part

    Notice
    ------
    only need to set inputs with range

    Parameters
    ----------
    range_x: list
    input x range

    Returns
    -------
    support_info: dict
    """
    support_info = {}
    inputs = []
    item = {}
    item["index"] = 2
    item["tensor"] = []
    tensor_info = {}
    ori_tensors = DynamicConv3dBpInputParams.para_dict.get("ori_tensors")
    ori_tensors_input = ori_tensors.get("out_backprop")
    ori_shape = ori_tensors_input.get("ori_shape")
    tensor_info["shape"] = ori_shape
    x_format = ori_tensors_input.get("ori_format")

    # get dy_range depends on dx_range
    conv_info = DynamicConv3dBpInputParams.tiling_info_dict
    para_dict = DynamicConv3dBpInputParams.para_dict
    dx_range_ndhwc = [range_x[0],
                      range_x[1],
                      range_x[2],
                      range_x[3],
                      [ori_shape[x_format.find("C")], ori_shape[x_format.find("C")]]
                     ]
    conv3d_backprop = Conv3dBackpropParaProcess(para_dict, _get_pad_mode(conv_info))
    dy_range_ndhwc = conv3d_backprop.get_dy_range(dx_range_ndhwc)
    range_valid = [[0, 0]] * 5
    range_valid[x_format.find("N")] = list(dy_range_ndhwc[0])
    range_valid[x_format.find("D")] = list(dy_range_ndhwc[1])
    range_valid[x_format.find("H")] = list(dy_range_ndhwc[2])
    range_valid[x_format.find("W")] = list(dy_range_ndhwc[3])
    range_valid[x_format.find("C")] = list(dy_range_ndhwc[4])
    tensor_info["range"] = range_valid
    item["tensor"].append(tensor_info)
    inputs.append(item)
    support_info["inputs"] = inputs
    return support_info


def add_covered_shape_range(compile_info):
    """
    tiling_case func for dynamic shape conv3d backprop input

    Parameters
    ----------
    compile_info: dict
    tiling range info

    Returns
    -------
    info_list: dict
    support info and compile info pair
    max_kernel_id: int
    last kernel id
    """
    id_list = list(compile_info["block_dim"].keys())
    id_list.sort()

    te_vars = []
    info_list = []
    for cpt in op_get_context().get_computes():
        te_vars += cpt.get_vars()
    var_list = [var.get_name() for var in te_vars]
    for kernel_id, _ in compile_info["block_dim"].items():
        new_compile = compile_info.copy()
        for keys, value in new_compile.items():
            if isinstance(value, dict):
                value = {} if value.get(kernel_id) is None else {kernel_id: value[kernel_id]}
                new_compile[keys] = value
        new_compile["kernelId"] = kernel_id
        new_compile["_vars"] = {kernel_id: var_list}
        range_x = new_compile["repo_range"].get(kernel_id) or new_compile["cost_range"].get(kernel_id)
        new_range = [range_x[:2], range_x[2:4], range_x[4:6], range_x[6:8]]
        new_support = gen_support_info(new_range)
        info_list.append({"supportInfo": new_support, "compileInfo": new_compile})
    return info_list, id_list[-1]


@register_build_pointcut(pattern=Pattern.CONV3D_BACKPROP_INPUT)
def build_pointcut_conv3d_backprop_input(func, *args, **kwargs):
    """
    kernel info process before build

    Notice
    ------
    kernel_info: dict with support info and compile info
        {
            "supportInfo": {
                "inputs": [{
                    "index": 2,
                    "tensor": [{
                    "range": [
                        [1, 1],
                        [8, 15],
                        [32, 63],
                        [32, 63],
                        [64, 64]
                    ],
                    "shape": [-1, -1, -1, -1, 64]
                    }]
                }]
            },
            "compileInfo": {
                "_pattern": "Conv3d_backprop_input",
                "tiling_type": "dynamic_tiling",
                "repo_seeds": {},
                "repo_range": {},
                "cost_range": {},
                "block_dim": {
                    1: 32
                },
                "_vars": {
                    0: ["batch_n", "dedx_d", "dedy_d", "dedx_h", "dedy_h", "dedx_h", "dedy_w"]
                }
            }
        }

    Parameters
    ----------
    func: funtions
        build process
    args: list
        function input args
    kwargs: dict
        function input args and value

    Returns
    -------
    None
    """
    fuzz_build = (get_context().get_build_type() == "fuzzily_build")
    if fuzz_build:  # set kernel info
        info_list, max_kernel_id = add_covered_shape_range(get_compile_info())
        get_context().add_build_json_result("maxKernelId", max_kernel_id)
        get_context().add_build_json_result("kernelList", info_list)
    func(*args, **kwargs)


def query_tiling_cases(query_dict):
    """
    do query tiling cases for dynamic shape conv3d_bp_input

    Parameters
    ----------
    query_dict : dict contains tilingcase query params.

    Returns
    -------
    list of dict, each dict for a tiling case
    """
    tgt_list = query_dict.get("tgt_list")
    conv_info = query_dict.get("conv_info")
    max_kernel_id = query_dict.get("max_kernel_id")
    var_names = query_dict.get("var_names")
    fuzz_build = query_dict.get("fuzz_build")
    graph_parser = query_dict.get("graph_parser")

    all_compile_info = {}
    tiling_cases = []
    for tgt in tgt_list:
        new_info = copy.deepcopy(conv_info)
        tiling_op = Conv3dBpInputTiling(new_info, graph_parser)
        selector = TilingSelection(tiling_op, max_kernel_id)
        tiling_cases += selector.calc_tiling(tgt, var_names)

        if fuzz_build:
            tgt_ndhw = []
            for var_name in var_names:
                tgt_ndhw.extend(tgt[var_name])
            current_info = get_compile_info().copy()
            id_list = list(current_info["block_dim"].keys())
            id_list.sort()
            max_kernel_id = id_list[-1] + 1
            for range_key in ["repo_range", "cost_range"]:
                if isinstance(current_info.get(range_key), dict):
                    for kernel_id, range_x in current_info[range_key].items():
                        new_range = []
                        for index, dim_value in enumerate(range_x):
                            if index in (0, 2, 4, 6):
                                new_range.append(tgt_ndhw[index] if dim_value < tgt_ndhw[index] else dim_value)
                            else:
                                new_range.append(tgt_ndhw[index] if dim_value > tgt_ndhw[index] else dim_value)
                        current_info[range_key][kernel_id] = new_range
            if all_compile_info:
                for key, value in current_info.items():
                    if isinstance(all_compile_info.get(key), dict) and isinstance(value, dict):
                        new_item = all_compile_info.get(key)
                        new_item.update(value)
                        all_compile_info[key] = new_item
                        add_compile_info(key, new_item)
            else:
                all_compile_info = current_info

        if not query_dict.get(const.BINARY_KEY, False):
            add_compile_info("dedy_c1", conv_info.get("ori_cout"))

    return tiling_cases


def get_tiling_cases(graph_parser):
    """
    get tiling cases for dynamic shape conv3d_bp_input

    Parameters
    ----------
    tgt_list : list of dict, each dict for a dynamic dim
    conv_info: tiling_info_dict
    var_names: keys of dynamic dims

    Returns
    -------
    list of dict, each dict for a tiling case
    """
    var_names = ("batch_n", "dedx_d", "dedx_h", "dedx_w")
    tgt_list = []
    tgt_area = {}
    conv_info = DynamicConv3dBpInputParams.tiling_info_dict
    para_dict = DynamicConv3dBpInputParams.para_dict
    shape_dict = {"batch_n": conv_info.get("c_shape")[0],
                  "dedx_d": conv_info.get("c_shape")[1],
                  "dedx_h": conv_info.get("c_shape")[2],
                  "dedx_w": conv_info.get("c_shape")[3]}

    for var_name in var_names:
        if para_dict.get(const.BINARY_KEY):
            tgt_area[var_name] = (1, INT32_MAX)
        elif get_te_var(var_name):
            tgt_area[var_name] = tuple(get_te_var(var_name).get_bound())
        else:
            tgt_area[var_name] = (int(shape_dict.get(var_name)), int(shape_dict.get(var_name)))

    tgt_list.append(tgt_area) # deal with dynamic shape range by default
    max_kernel_id = None
    fuzz_build = (get_context().get_build_type() == "fuzzily_build") and not para_dict.get(const.BINARY_KEY)
    if fuzz_build:
        missing_support_info = get_context().get_addition("missing_support_info")
        if len(missing_support_info) > 0:
            missing_support_list = _parse_fuzz_build_range(json.loads(missing_support_info))
            if len(missing_support_list) > 0:
                tgt_list.clear()  # clear the old data and only deal with fuzz shape range
                for item in missing_support_list:
                    if item:
                        # get dx_range deponds on dy_range
                        dy_range = copy.deepcopy(item)
                        conv3d_backprop = Conv3dBackpropParaProcess(para_dict, _get_pad_mode(conv_info))
                        dx_range_ndhw = conv3d_backprop.get_dx_range(dy_range)
                        fuzz_area = {}
                        fuzz_area["batch_n"] = tuple(dx_range_ndhw[0])
                        fuzz_area["dedx_d"] = tuple(dx_range_ndhw[1])
                        fuzz_area["dedx_h"] = tuple(dx_range_ndhw[2])
                        fuzz_area["dedx_w"] = tuple(dx_range_ndhw[3])
                        tgt_list.append(fuzz_area)
        kernel_id = get_context().get_addition("max_kernel_id")
        if (isinstance(kernel_id, int) and kernel_id > -2):
            max_kernel_id = kernel_id + 1

    query_dict = {
        "tgt_list": tgt_list,
        "conv_info": conv_info,
        "max_kernel_id": max_kernel_id,
        "var_names": var_names,
        "fuzz_build": fuzz_build,
        "graph_parser": graph_parser,
        const.BINARY_KEY: para_dict.get(const.BINARY_KEY),
    }
    tiling_cases = query_tiling_cases(query_dict)

    return tiling_cases


def check_binary_support(tensor_attr: dict):
    """
    Check whether binary constant is supported, based on static constraints.
    """
    support_flag = tbe_platform.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out")
    support_flag = support_flag and tensor_attr.get(const.FUSION_KEY) == 0

    return support_flag


def construct_info_dict(tensor_map):
    """
    Construct info dict for static tiling.
    """
    def _transform_tvm_int(var):
        if isinstance(var, tvm.tir.expr.IntImm):
            return var.value
        return var

    dx_res = tensor_map.get("dx_res")
    a_ddr = tensor_map.get("a_ddr")
    input_dtype = a_ddr.dtype if a_ddr is not None else "float16"
    output_dtype = str(dx_res.op.attrs.get("output_dtype"))
    if input_dtype.lower() == "bfloat16":
        input_dtype = "float16"
        output_dtype = "float16"
    _, block_size_k, block_size_n = tbe_platform.CUBE_MKN.get(tensor_map.get("b_ddr").dtype).get("mac")
    support_l0c2out_flag = tbe_platform.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out")
    dy_batch, dy_depth, _, dy_h, dy_w, _ = tensor_map.get("a_ddr").shape
    _, _, _, b_ddr_n0 = tensor_map.get("b_ddr").shape
    group_dict = dx_res.op.attrs.get("group_dict")
    real_g = group_dict.get("real_g")
    cout_g = group_dict.get("cout_g")
    cout1_g = cout_g // block_size_n
    cin1_g = group_dict.get("cin1_g")
    b_ddr_kd, kernel_h, kernel_w = dx_res.op.attrs.get("kernels")
    cddr_batch, cddr_depth, cddr_c1, cddr_h, cddr_w, cdder_c0 = dx_res.op.attrs.get("output_shape")
    padu, padd, padl, padr = dx_res.op.attrs.get("bp_pads")
    pad_head, pad_tail = dx_res.op.attrs.get("depth_pad")
    stride_d, stride_h, stride_w = dx_res.op.attrs.get("strides")
    dilation_d, dilation_h, dilation_w = dx_res.op.attrs.get("dilations")
    aub_fused_num = 0
    cub_fused_num = 0

    info_dict = {
        "a_shape": [_transform_tvm_int(dim) for dim in (dy_batch, dy_depth, cout1_g, dy_h, dy_w, block_size_k)],
        "b_shape": [_transform_tvm_int(dim) for dim in (cout_g, b_ddr_kd, cin1_g, kernel_h, kernel_w, b_ddr_n0)],
        "c_shape": [_transform_tvm_int(dim) for dim in (cddr_batch, cddr_depth, cddr_h, cddr_w, cddr_c1 * cdder_c0)],
        "a_dtype": input_dtype,
        "b_dtype": input_dtype,
        "c_dtype": output_dtype,
        "mad_dtype": 'float32',
        "pad": [_transform_tvm_int(dim) for dim in (pad_head, pad_tail, padu, padd, padl, padr)],
        "stride": [_transform_tvm_int(stride_d), 1, 1],
        "strideh_expand": _transform_tvm_int(stride_h),
        "stridew_expand": _transform_tvm_int(stride_w),
        "dilation": [_transform_tvm_int(dim) for dim in (dilation_d, dilation_h, dilation_w)],
        "group": _transform_tvm_int(real_g),
        "fused_coefficient": [aub_fused_num, 0, cub_fused_num],
        "bias_flag": False,
        "op_type": "conv3d_backprop_input",
        "kernel_name": str(dx_res.op.attrs.get("kernel_name"))
    }
    update_info_dict(support_l0c2out_flag, tensor_map.get("fixpipe_tensor"), tensor_map.get("bias_l1"), info_dict)

    return info_dict


def get_default_tiling_static(tensor_map: dict, tensor_attr: dict):
    """
    Default tiling for static condition.
    """
    _, k0_size, _ = tbe_platform.CUBE_MKN.get(tensor_map.get("a_ddr").dtype).get("mac")
    _, kernel_h, kernel_w = tensor_attr.get("kernels")
    _, stride_h, stride_w = tensor_attr.get("strides")
    aub_fusion_flag = tensor_attr.get("aub_fusion_flag", False)
    k_al1 = kernel_h * kernel_w * k0_size

    tiling = {
        "AL1_shape": [k_al1, 1, 1, 1],
        "BL1_shape": [k0_size, 1, 1, 1],
        "AL0_matrix": [1, 1, 16, k0_size, 1, 1],
        "BL0_matrix": [1, 1, 16, k0_size, 1, 1],
        "CL0_matrix": [1, 1, 16, 16, 1, 1],
        "CUB_matrix": [1, 1, 16, 16, 1, 1],
        "block_dim": [1, 1, 1, 1],
        "n_bef_batch_flag": 0,
        "n_bef_group_flag": 0,
        "batch_bef_group_flag": 0,
        "A_overhead_opt_flag": 0,
        "B_overhead_opt_flag": 0,
        "AUB_channel_wise_flag": None,
        "BUB_channel_wise_flag": None,
        "CUB_channel_wise_flag": None,
        "manual_pingpong_buffer": {
            'AUB_pbuffer': 1,
            'BUB_pbuffer': 1,
            'AL1_pbuffer': 1,
            'BL1_pbuffer': 1,
            'AL0_pbuffer': 1,
            'BL0_pbuffer': 1,
            'CL0_pbuffer': 1,
            'CUB_pbuffer': 1,
            'UBG_pbuffer': 1,
        }
    }

    if stride_h > 1 or stride_w > 1 or aub_fusion_flag:
        tiling["AUB_shape"] = [kernel_h * kernel_w * k0_size, 1, 1, 1]
        tiling["BUB_shape"] = None
    else:
        tiling["AUB_shape"] = None
        tiling["BUB_shape"] = None

    return tiling


def customize_tiling(tiling: dict, tensor_attr: dict):
    """
    Customize tiling based on constraints.
    """
    stride_d, _, _ = tensor_attr.get("strides")
    b_ddr_kd, _, _ = tensor_attr.get("kernels")
    pad_head, pad_tail = tensor_attr.get("depth_pad")
    _, cddr_depth, _, _, _, _ = tensor_attr.get("output_shape")
    # cl0_tiling_d should be 1 for L12out & nz2nd case to solve precision problem
    if tiling.get("AL0_matrix") and tensor_attr.get("6HD_TRANS_NDHWC") and (
            stride_d > b_ddr_kd or (pad_head + pad_tail + cddr_depth - b_ddr_kd) % stride_d > 0):
        tiling["AL0_matrix"][-1] = 1


def get_static_tiling(graph_parser):
    """
    Get static tiling for 3ddx.

    1) Return None on condition that graph_parser is unsupported
    2) Use repo tiling if bank is hit
    3) Use original tiling otherwise, and enable binary constant if supported
    """
    if graph_parser.unsupported_flag:
        return None

    tensor_map = graph_parser.tensor_map
    tensor_attr = graph_parser.tensor_attr

    support_binary_flag = check_binary_support(tensor_attr)
    info_dict = construct_info_dict(tensor_map)
    curr_tiling_type = get_tiling_type()

    set_tiling_type("repository_tiling")
    tiling_from_repo = tiling_api.get_tiling(info_dict)

    set_tiling_type(curr_tiling_type)
    tiling_res = tiling_api.get_tiling(info_dict)

    if not all(x == 0 for x in tiling_from_repo.get("AL0_matrix")):
        tiling_res = tiling_from_repo
    elif support_binary_flag:
        log.debug('Binary constant is supported')
        op_context.get_context().add_addition("support_binary_constant", True)
        op_context.get_context().add_addition("need_expand_stride", tensor_attr.get("need_expand_stride", False))
        op_context.get_context().add_addition("split_w", tensor_attr.get("split_w", False))

    if is_valid_tiling(tiling_res):
        log.debug('Get tiling from costmodel/repository in tilingcase')
    else:
        log.debug('Get default tiling in tilingcase')
        tiling_res = get_default_tiling_static(tensor_map, tensor_attr)

    decode_tiling(tiling_res)
    customize_tiling(tiling_res, tensor_attr)
    tiling_case = construct_tiling_case(tiling_res)
    tiling_case.update({"tensor_map": tensor_map, "tensor_attr": tensor_attr, "binary_flag": False})

    return tiling_case


@register_tiling_case(pattern=Pattern.CONV3D_BACKPROP_INPUT)
def calc_conv3dbp_input(outs, option=None):
    """
    tiling_case func for dynamic shape conv3d_bp_input

    Parameters
    ----------
    outs : tvm tensor or list of tvm tensor, results for tvm compute

    Returns
    -------
    list of dict, each dict for a tiling case
    """
    context = op_context.get_context()
    graph_parser = Conv3dBackpropInputGraphParser(outs[0])
    graph_parser.parse_graph()

    # 1) On static condition
    if not is_unify():
        return get_static_tiling(graph_parser)

    # 2) On binary constant condition
    add_compile_info("binary_mode", DynamicConv3dBpInputParams.para_dict.get(const.BINARY_KEY, False))
    add_compile_info("fusion_mode", graph_parser.tensor_attr.get(const.FUSION_KEY, 0))

    if context.get_addition("enable_binary_constant"):
        add_compile_info("tiling_type", "binary")
        add_compile_info("block_dim", {"CORE_NUM": get_core_num()})

        run_info = do_op_tiling(
            context.get_addition('params_do_op_tiling')['op_type'], get_compile_info(),
            context.get_addition('params_do_op_tiling')['inputs'],
            context.get_addition('params_do_op_tiling')['outputs'], None, None,
            context.get_addition('params_do_op_tiling')['attrs'])

        tiling_key, tiling_data = parse_run_info(run_info)
        log.debug(f"tiling_data {tiling_data}")

        compute_config = {
            const.DTYPE_KEY: DynamicConv3dBpInputParams.tiling_info_dict.get("a_dtype"),
            const.STRIDE_EXPAND_KEY: DynamicConv3dBpInputParams.para_dict.get(const.STRIDE_EXPAND_KEY),
            const.SPLIT_AXIS_MODE_STR: DynamicConv3dBpInputParams.para_dict.get(const.SPLIT_AXIS_MODE_STR),
            const.SD_KD_MODE_KEY: DynamicConv3dBpInputParams.para_dict.get(const.SD_KD_MODE_KEY),
            const.FUSION_KEY: graph_parser.tensor_attr.get(const.FUSION_KEY),
            const.DILATION_D_GT_ONE_KEY: DynamicConv3dBpInputParams.para_dict.get(const.DILATION_D_GT_ONE_KEY)
        }

        tiling_strategies = Conv3dBpInputTiling.gen_binary_tiling_strategies(compute_config)

        if tiling_key not in tiling_strategies:
            raise RuntimeError(f"tiling_strategies not match tiling_key {tiling_key}")
        tiling_cases = [construct_tiling_case(tiling_strategies.get(tiling_key), tiling_key, tiling_data)]

        for tiling_case in tiling_cases:
            tiling_case.update({
                'tensor_map': graph_parser.tensor_map,
                'tensor_attr': graph_parser.tensor_attr,
                'binary_flag': True
            })

        return tiling_cases

    # 3) On dynamic or binary condition
    tiling_cases = get_tiling_cases(graph_parser)

    return tiling_cases


class Conv3dBpInputTiling(CubeTilingOp):
    """
    the conv3d backprop input tiling case
    """
    def __init__(self, tiling_info, graph_parser=None):
        super().__init__(tiling_info, None)
        self.op_type = "conv3d_backprop_input"
        self.graph_parser = graph_parser
        self.key = "C_shape"
        self.a_info = self.tiling_info.get("a_shape")
        self.b_info = self.tiling_info.get("b_shape")
        self.c_info = self.tiling_info.get("c_shape")
        self.a_type = self.tiling_info.get("a_dtype")
        self.c_type = self.tiling_info.get("c_dtype")
        self._get_calc_info()
        self.var_map = DynamicConv3dBpInputParams.var_map
        self.binary_mode = DynamicConv3dBpInputParams.para_dict.get(const.BINARY_KEY)
        op_get_context().add('_use_cache_tiling', self.binary_mode)

    # |         name          | offset | bit |   choice   |                      definition                          |
    # | --------------------  | ------ | --- | -----------| ---------------------------------------------------------|
    # | db_al1                | 0      | 1   | 0, 1       | 0: disable db; 1: enable db                              |
    # | db_bl1                | 1      | 1   | 0, 1       | 0: disable db; 1: enable db                              |
    # | db_l0c                | 2      | 1   | 0, 1       | 0: disable db; 1: enable db                              |
    # | db_cub                | 3      | 1   | 0, 1       | 0: disable db; 1: enable db                              |
    # | al1_attach_flag       | 4      | 2   | 0, 1, 2    | 0: full load; 1: k full load; 2: k not full load         |
    # | bl1_attach_flag       | 6      | 2   | 0, 1, 2    | 0: full load; 1: k full load; 2: k not full load         |
    # | abkl1_attach_flag     | 8      | 2   | 0, 1, 2    | 0: kal1 equal kbl1; 1: kal1 > kbl1; 2: kal1 < kbl1       |
    # | dilation_d_gt_one_flag| 10     | 2   | 0, 1       | 0: dilation_d equal 1; 1: dilation_d > 1                 |
    # | stride_expand_flag    | 11     | 1   | 0, 1       | 0: no pre-expansion; 1: pre-expansion                    |
    # | sd_kd_mode            | 12     | 2   | 0, 1, 2    | 0: s_d equal k_d && dx_d + pad_h + pad_t equal sd * dy_d |
    # |                       |        |     |            | 1: stride_d <= kernel_d; 2: stride_d > kernel_d          |
    # | split_axis_mode       | 14     | 1   | 0, 1       | 0: split hw; 1: split w                                  |
    # | load3d_special        | 15     | 1   | 0, 1       | 0: not load3d special case; 1: otherwise                 |
    # | fusion_mode           | 16     | 2   | 0, 1, 2, 3 | 0: 6hd in, 6hd out; 1~3: undefined                       |

    BINARY_TILING_ITEMS = (
        BinaryTilingItem('db_al1', 0, 1, 2),
        BinaryTilingItem('db_bl1', 1, 1, 2),
        BinaryTilingItem('db_l0c', 2, 1, 2),
        BinaryTilingItem('db_cub', 3, 1, 2),
        BinaryTilingItem('al1_attach_flag', 4, 2, 3),
        BinaryTilingItem('bl1_attach_flag', 6, 2, 3),
        BinaryTilingItem('abkl1_attach_flag', 8, 2, 3),
        BinaryTilingItem('dilation_d_gt_one_flag', 10, 1, 2),
        BinaryTilingItem('stride_expand_flag', 11, 1, 2),
        BinaryTilingItem('sd_kd_mode', 12, 2, 3),
        BinaryTilingItem('split_axis_mode', 14, 1, 2),
        BinaryTilingItem('load3d_special', 15, 1, 2),
        BinaryTilingItem('fusion_mode', 16, 2, 4)
    )

    @staticmethod
    def decode_binary_tiling_id(tiling_id: int, binary_tiling_items: List[BinaryTilingItem]) -> Dict[str, int]:
        """
        Decode binary tiling id to a dict, containing all tiling items with values.

        Returns
        -------
        tiling dict: dict.
        """
        def _extract_bits_from_int(num, offset, bits):
            return num >> offset & (2**bits - 1)

        return {item.name: _extract_bits_from_int(tiling_id, item.offset, item.bits) for item in binary_tiling_items}

    @staticmethod
    def encode_binary_tiling(binary_tiling: Iterable, binary_tiling_items: List[BinaryTilingItem]):
        """
        Encode binary tiling to binary tiling id.

        Returns
        -------
        tiling_id: int.
        """
        tiling_id = 0
        for idx, val in enumerate(binary_tiling):
            tiling_id += val << binary_tiling_items[idx].offset

        return tiling_id

    @staticmethod
    def gen_binary_tiling_space(binary_tiling_items: List[BinaryTilingItem]):
        """
        Generate combinations of tiling items.

        Returns
        -------
        binary_tiling_space: An iterator of combinations of tiling items.
        """
        binary_tiling_space = product(
            *map(lambda tiling_item: list(range(tiling_item.valid_len)), binary_tiling_items))

        return binary_tiling_space

    @staticmethod
    def gen_binary_tiling_strategies(compute_config: dict):
        def _get_tvm_var(var_name: str):
            te_var = get_te_var(var_name)
            if te_var is None:
                raise_err_message_cube(f"cannot find tvm var with name {var_name}")
            return te_var.get_tvm_var()

        block_reduce = tbe_platform_info.CUBE_MKN.get(compute_config.get(const.DTYPE_KEY)).get("mac")[1]
        tiling_strategies = {}

        for binary_tiling in Conv3dBpInputTiling.gen_binary_tiling_space(Conv3dBpInputTiling.BINARY_TILING_ITEMS):
            if Conv3dBpInputTiling.is_binary_tiling_invalid(binary_tiling, compute_config):
                continue

            tiling_id = Conv3dBpInputTiling.encode_binary_tiling(binary_tiling, Conv3dBpInputTiling.BINARY_TILING_ITEMS)
            tiling_dict = Conv3dBpInputTiling.decode_binary_tiling_id(tiling_id,
                                                                      Conv3dBpInputTiling.BINARY_TILING_ITEMS)

            min_kl1 = _get_tvm_var('min_kl1_div_kl0') * _get_tvm_var('k_l0') * block_reduce
            max_kl1 = _get_tvm_var('max_kl1_div_min_kl1') * min_kl1
            abkl1_attach_flag = tiling_dict.get("abkl1_attach_flag")

            if abkl1_attach_flag == 0:
                k_bl1 = k_al1 = max_kl1
            elif abkl1_attach_flag == 1:
                k_al1 = max_kl1
                k_bl1 = min_kl1
            elif abkl1_attach_flag == 2:
                k_al1 = min_kl1
                k_bl1 = max_kl1
            else:
                raise_err_message_cube(f"not support abkl1_attach_flag is {abkl1_attach_flag}")

            tiling_strategy = {
                'block_dim': [_get_tvm_var('batch_dim'), _get_tvm_var('n_dim'), _get_tvm_var('m_dim'),
                              _get_tvm_var('group_dim'), _get_tvm_var('d_dim')],
                # AL0_matrix definition: [ma, ka, 16, c0, batch_al0, group_al0, d_al0]
                'AL0_matrix': [_get_tvm_var('m_l0'), _get_tvm_var('k_l0'), utils.CUBE_SIZE, block_reduce, 1, 1,
                               _get_tvm_var("d_al0")],
                # BL0_matrix definition: [kb, nb, 16, c0, batch_bl0, group_bl0, d_bl0]
                'BL0_matrix': [_get_tvm_var('k_l0'), _get_tvm_var('n_l0_div_ub') * _get_tvm_var('n_cub'),
                               utils.CUBE_SIZE, block_reduce, 1, 1, _get_tvm_var("d_bl0")],
                # CL0_matrix definition: [nc, mc, 16, 16, batch_cl0, group_cl0, d_cl0]
                'CL0_matrix': [_get_tvm_var('n_l0_div_ub') * _get_tvm_var('n_cub'), _get_tvm_var('m_l0'),
                               utils.CUBE_SIZE, utils.CUBE_SIZE, 1, 1, _get_tvm_var("d_cl0")],
                # CUB_matrix definition (OBP): [nc_factor, mc_factor, 16, 16, batch_cub, group_cub]
                'CUB_matrix': [_get_tvm_var('n_cub'), _get_tvm_var('m_l0'), utils.CUBE_SIZE, utils.CUBE_SIZE, 1, 1],
                # definition (Milan): [nc_factor, mc_factor, 16, 16, batch_L0C_OUTPUT, group_L0C_OUTPUT]
                'L0C_OUTPUT_matrix': [_get_tvm_var('n_cub'), _get_tvm_var('m_l0'), utils.CUBE_SIZE,
                                      utils.CUBE_SIZE, 1, 1],
                # BUB_shape definition: [k_BUB, n_BUB, batch_BUB, group_BUB]
                'BUB_shape': [1, 1, 1, 1],
                # AUB_shape definition: [k_AUB, m_AUB, batch_AUB, group_AUB]
                'AUB_shape': [_get_tvm_var('k_aub'), _get_tvm_var('m_aub'), _get_tvm_var('wo_aub'), 1],
                # AL1_shape definition: [k_AL1, m_AL1, batch_AL1, group_AL1, d_AL1]
                'AL1_shape': [k_al1, _get_tvm_var('m_al1'), 1, 1, _get_tvm_var('d_al1')],
                # BL1_shape definition: [k_BL1, n_BL1, batch_BL1, group_BL1, d_BL1]
                'BL1_shape': [k_bl1, _get_tvm_var('n_bl1'), 1, 1, _get_tvm_var('d_bl1')],
                'n_bef_batch_flag': 0,
                'n_bef_group_flag': 0,
                'batch_bef_group_flag': 0,
                'A_overhead_opt_flag': 0,
                'B_overhead_opt_flag': 0,
                'AUB_channel_wise_flag': None,
                'BUB_channel_wise_flag': None,
                'CUB_channel_wise_flag': None,
                'manual_pingpong_buffer': {
                    'AUB_pbuffer': utils.DB_OFF,
                    'BUB_pbuffer': utils.DB_OFF,
                    'AL1_pbuffer': utils.DB_ON if tiling_dict.get("db_al1") == 1 else utils.DB_OFF,
                    'BL1_pbuffer': utils.DB_ON if tiling_dict.get("db_bl1") == 1 else utils.DB_OFF,
                    'AL0_pbuffer': utils.DB_ON,
                    'BL0_pbuffer': utils.DB_ON,
                    'CL0_pbuffer': utils.DB_ON if tiling_dict.get("db_l0c") == 1 else utils.DB_OFF,
                    'CUB_pbuffer': utils.DB_ON if tiling_dict.get("db_cub") == 1 else utils.DB_OFF,
                    'UBG_pbuffer': utils.DB_OFF
                },
                'attach_at_flag': {
                    'cub_attach_flag': utils.ATTACH_LESS,
                    'cl0_attach_flag': utils.ATTACH_LESS,
                    'al0_attach_flag': utils.ATTACH_LESS,
                    'bl0_attach_flag': utils.ATTACH_LESS,
                    'al1_attach_flag': tiling_dict.get("al1_attach_flag"),
                    'bl1_attach_flag': tiling_dict.get("bl1_attach_flag"),
                    'aub_attach_flag': utils.ATTACH_LESS,
                    'abkl1_attach_flag': abkl1_attach_flag,
                    'aub_multi_flag': -1
                },
                "load3d_special_flag":
                tiling_dict.get("load3d_special"),
                "split_axis_mode":
                tiling_dict.get("split_axis_mode"),
                "fusion_mode":
                tiling_dict.get("fusion_mode"),
            }

            tiling_strategies[tiling_id] = tiling_strategy

        return tiling_strategies

    @staticmethod
    def is_binary_tiling_invalid(binary_tiling, compute_config):
        """
        Validate binary tiling.

        Returns
        -------
        bool: True if binary tiling is valid.
        """
        cur_split_axis_mode = compute_config.get(const.SPLIT_AXIS_MODE_STR)
        cur_sd_kd_mode = compute_config.get(const.SD_KD_MODE_KEY)
        cur_stride_expand = compute_config.get(const.STRIDE_EXPAND_KEY)
        cur_fusion_mode = compute_config.get(const.FUSION_KEY)
        cur_dilation_d_gt_one_flag = compute_config.get(const.DILATION_D_GT_ONE_KEY)

        (db_al1, db_bl1, _, db_cub, al1_attach_flag, bl1_attach_flag, abkl1_attach_flag, dilation_d_gt_one_flag,
         stride_expand_flag, sd_kd_mode, split_axis_mode, load3d_special, fusion_mode) = binary_tiling

        invalid_flag = (al1_attach_flag == 0) and ((bl1_attach_flag in (0, 1) and abkl1_attach_flag != 0) or
                                                   (bl1_attach_flag == 2 and abkl1_attach_flag == 2))

        invalid_flag = invalid_flag or ((al1_attach_flag == 0 and db_al1 == 1) or
                                        (bl1_attach_flag == 0 and db_bl1 == 1))

        invalid_flag = invalid_flag or (al1_attach_flag == 1 and
                                        ((bl1_attach_flag in (0, 1) and abkl1_attach_flag != 0) or
                                         (bl1_attach_flag == 2 and abkl1_attach_flag == 2)))

        invalid_flag = invalid_flag or (al1_attach_flag == 2 and (bl1_attach_flag in (0, 1) and abkl1_attach_flag != 2))

        invalid_flag = invalid_flag or (split_axis_mode != cur_split_axis_mode)

        invalid_flag = invalid_flag or (not cube_util.is_load3d_constraint() and load3d_special == 1)

        invalid_flag = invalid_flag or (tbe_platform.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out")
                                        and db_cub == 1)

        invalid_flag = invalid_flag or (sd_kd_mode != cur_sd_kd_mode)

        invalid_flag = invalid_flag or (stride_expand_flag != cur_stride_expand)

        invalid_flag = invalid_flag or (fusion_mode != cur_fusion_mode)

        invalid_flag = invalid_flag or (dilation_d_gt_one_flag != cur_dilation_d_gt_one_flag)

        return invalid_flag

    def assembly_case(self, tiling, coverage, cnt):
        """
        Configure dict of tiling strategy and coverage

        Parameters
        ----------
        tiling: dict, tiling from repository or cost model

        coverage: list of tuple, coverage of tiling

        cnt: serial number of tiling

        Returns
        -------
        dict: describe a tiling strategy
        """
        var_range = OrderedDict()
        if "batch_n" in self.var_map:
            var_range['batch_n'] = (utils.trans_to_int(coverage[0]), utils.trans_to_int(coverage[1]))
        if "dedy_d" in self.var_map:
            dx_d_low, dx_d_high = utils.trans_to_int(coverage[2]), utils.trans_to_int(coverage[3])
            dedy_d_low = self._get_dedy_d(dx_d_low, self.stride_d)
            dedy_d_high = self._get_dedy_d(dx_d_high, self.stride_d)
            var_range['dedx_d'] = (dx_d_low, dx_d_high)
            var_range['dedy_d'] = (dedy_d_low, dedy_d_high)
        if "dedy_h" in self.var_map:
            dx_h_low, dx_h_high = utils.trans_to_int(coverage[4]), utils.trans_to_int(coverage[5])
            dedy_h_low = self._get_dedy_h(dx_h_low, self.stride_h)
            dedy_h_high = self._get_dedy_h(dx_h_high, self.stride_h)
            var_range['dedx_h'] = (dx_h_low, dx_h_high)
            var_range['dedy_h'] = (dedy_h_low, dedy_h_high)
        if "dedy_w" in self.var_map:
            dx_w_low, dx_w_high = utils.trans_to_int(coverage[6]), utils.trans_to_int(coverage[7])
            dedy_w_low = self._get_dedy_w(dx_w_low, self.stride_w)
            dedy_w_high = self._get_dedy_w(dx_w_high, self.stride_w)
            var_range['dedx_w'] = (dx_w_low, dx_w_high)
            var_range['dedy_w'] = (dedy_w_low, dedy_w_high)
        return {"key": cnt, "tiling_strategy": tiling, "var_range": var_range}

    def get_cache_tiling(self):
        compute_config = {
            const.DTYPE_KEY: DynamicConv3dBpInputParams.tiling_info_dict.get("a_dtype"),
            const.STRIDE_EXPAND_KEY: None,
            const.SPLIT_AXIS_MODE_STR: None,
            const.SD_KD_MODE_KEY: None,
            const.FUSION_KEY: self.graph_parser.tensor_attr.get(const.FUSION_KEY),
            const.DILATION_D_GT_ONE_KEY: None
        }
        compute_config.update(DynamicConv3dBpInputParams.para_dict)
        tiling_strategies = Conv3dBpInputTiling.gen_binary_tiling_strategies(compute_config)
        tiling_cases = []
        for tiling_id, tiling_strategy in tiling_strategies.items():
            tiling_case = construct_tiling_case(tiling_strategy, tiling_id)
            tiling_case.update({
                'tensor_map': self.graph_parser.tensor_map,
                'tensor_attr': self.graph_parser.tensor_attr,
                'binary_flag': True
            })
            tiling_cases.append(tiling_case)

        return tiling_cases

    def get_costmodel_tiling(self, shape):
        """
        get tiling using cost model

        Parameters
        ----------
        shape: specified shape to get tiling

        Returns
        -------
        tiling: tiling retrieved by cost model
        """

        if "batch_n" in self.var_map:
            self.a_info[0] = shape if isinstance(shape, int) else shape[0]
            self.c_info[0] = shape if isinstance(shape, int) else shape[0]
        if "dedx_d" in self.var_map:
            self.c_info[1] = shape[1]
            self.a_info[1] = self._get_dedy_d(self.c_info[1], self.stride_d)
        if "dedx_h" in self.var_map:
            self.c_info[2] = shape[2]
            self.a_info[3] = self._get_dedy_h(self.c_info[2], self.stride_h)
        if "dedx_w" in self.var_map:
            self.c_info[3] = shape[3]
            self.a_info[4] = self._get_dedy_w(self.c_info[3], self.stride_w)
        self.tiling_info["tiling_type"] = "cost_model_tiling"

        if self.pad_mode == "VAR":
            pad_d = ((self.c_info[1] + self.stride_d - 1) // self.stride_d * self.stride_d - self.stride_d
                     + self.k_d_dilation - self.c_info[1])
            pad_d = max(pad_d, 0)
            pad_head = pad_d // 2
            pad_tail = pad_d - pad_head
            pad_h = ((self.c_info[2] + self.stride_h - 1) // self.stride_h * self.stride_h - self.stride_h
                     + self.k_h_dilation - self.c_info[2])
            pad_h = max(pad_h, 0)
            pad_up = pad_h // 2
            pad_w = ((self.c_info[3] + self.stride_w - 1) // self.stride_w * self.stride_w - self.stride_w
                     + self.k_w_dilation - self.c_info[3])
            pad_w = max(pad_w, 0)
            pad_left = pad_w // 2
        else:
            pad_head, pad_tail, pad_up, pad_left = self.padh, self.padt, self.padu, self.padl
        self.tiling_info["pad"] = self._get_padding(pad_head, pad_tail, pad_up, pad_left)
        cost_seeds = get_tiling(self.tiling_info)
        tiling = self._check_and_set_default_tiling(cost_seeds[0])

        return tiling

    def get_default_range(self, tgt_area):
        if not tgt_area[5]:
            tgt_area[5] = H_RANGE

        if not tgt_area[7]:
            fmap_w = 1
            while fmap_w <= W_RANGE:
                if not self._check_l1_limitation(fmap_w):
                    break
                dedy_w = self._get_dedy_w(fmap_w, self.stride_w)
                if not self._check_ub_limitation(dedy_w):
                    break
                fmap_w += 1
            tgt_area[7] = fmap_w - 1

        return super(Conv3dBpInputTiling, self).get_default_range(tgt_area)

    def get_default_tiling(self):
        """
        get default tiling for unlimited range or special case

        Returns
        -------
        dict: default tiling for conv3d_bp_input
        """
        tiling = {}
        # defaut value 16
        k0_size = tbe_platform.CUBE_MKN[self.a_type]["mac"][1]
        k_al1 = self.k_h * self.k_w * k0_size
        aub_fusion_flag = DynamicConv3dBpInputParams.tiling_info_dict.get("fused_coefficient")[0]

        if self.stride_h > 1 or self.stride_w > 1 or aub_fusion_flag:
            tiling["AUB_shape"] = [k_al1, 1, 1, 1]
            tiling["BUB_shape"] = None
        else:
            tiling["AUB_shape"] = None
            tiling["BUB_shape"] = None

        tiling["AL1_shape"] = [k_al1, 1, 1, 1]
        tiling["BL1_shape"] = [k0_size, 1, 1, 1]
        tiling["block_dim"] = [1, 1, 1, 1]
        tiling["AL0_matrix"] = [1, 1, 16, k0_size, 1, 1]
        tiling["BL0_matrix"] = [1, 1, 16, k0_size, 1, 1]
        tiling["CL0_matrix"] = [1, 1, 16, 16, 1, 1]
        tiling["CUB_matrix"] = [1, 1, 16, 16, 1, 1]
        tiling["n_bef_batch_flag"] = 0
        tiling["n_bef_group_flag"] = 0
        tiling["batch_bef_group_flag"] = 0
        tiling["A_overhead_opt_flag"] = 0
        tiling["B_overhead_opt_flag"] = 0
        tiling["CUB_channel_wise_flag"] = None
        tiling["AUB_channel_wise_flag"] = None
        tiling["BUB_channel_wise_flag"] = None
        tiling["manual_pingpong_buffer"] = {
            'AUB_pbuffer': 1,
            'BUB_pbuffer': 1,
            'CUB_pbuffer': 1,
            'AL1_pbuffer': 1,
            'BL1_pbuffer': 1,
            'AL0_pbuffer': 1,
            'BL0_pbuffer': 1,
            'CL0_pbuffer': 1,
            'UBG_pbuffer': 1,
        }

        return tiling

    def get_repo_tiling(self):
        """
        get tiling from repository

        Returns
        -------
        tiling: shape and tiling retrieved from repository
        """
        self.tiling_info["pad"] = [-1, -1, -1, -1, -1, -1]
        tiling_list = get_tiling(self.tiling_info)

        res_list = []
        for tiling_mess in tiling_list:
            # pad set -1 to get tilings from repository, so we need to
            # check A_shape&C_shape to filter tilings not matched with
            # current kernel_info out
            dedx_d, dedx_h, dedx_w = tiling_mess["C_shape"][1], tiling_mess["C_shape"][2], tiling_mess["C_shape"][3]
            t_d = self._get_dedy_d(dedx_d, self.stride_d)
            t_h = self._get_dedy_h(dedx_h, self.stride_h)
            t_w = self._get_dedy_w(dedx_w, self.stride_w)
            if (t_d == tiling_mess["A_shape"][1] and t_h == tiling_mess["A_shape"][3] and
                t_w == tiling_mess["A_shape"][4] and
                self._check_exceed_ub_buffer(tiling_mess.get("tiling"), dedx_d, dedx_h)):
                res_list.append(tiling_mess)
        return res_list

    def get_tiling_range(self, tiling_in, c_shape):
        """
        get the covered area of a tiling

        Parameters
        ----------
        tiling_in : dict, result of tiling fetch

        c_shape : list, size of fmap_shape

        Returns
        -------
        list, range covered for tiling_in
        """
        def _get_perf_range():
            # modify range for curv performance line
            if len(tiling["AL1_shape"]) == 0:
                al1_k_modify = (self.k_cout + utils.CUBE_SIZE - 1) // utils.CUBE_SIZE
                m0 = tbe_platform.CUBE_MKN[self.c_type]["mac"][0]
                m_aligned = (c_shape[2] * c_shape[3] + m0 - 1) // m0
                cl0_tiling_mc = tiling_in["CL0_matrix"][1]
                m_dim = tiling_in["block_dim"][2]
                tiling["AL1_shape"] = [al1_k_modify, m_aligned // cl0_tiling_mc // m_dim]
            bool_check_case = utils.icd(
                utils.icd(utils.icd(h_o * w_o, tiling["block_dim"][2]), utils.FP16_M),
                tiling["AL0_matrix"][0]) <= tiling["AL1_shape"][1]
            if bool_check_case:
                range_max = tiling["AL1_shape"][1] * tiling["AL0_matrix"][0] * \
                            utils.FP16_M * tiling["block_dim"][2]
                if h_range_max * w_range_max > range_max:
                    return range_max // w_o, w_o
            return h_range_max, w_range_max

        def _modify_max_range():
            """
            modify h_max and w_max according to the limit of ub buffer,
            ensure that aub + cub < ub buffer
            aub = ma * ka * db_flag * bit_num * d_factor
            cub = mc * nc * m0 * n0 * db_flag * bit_num
            """
            if tiling_in.get("AUB_shape"):
                cub_buffer = (reduce(lambda x, y: x * y, tiling_in["CUB_matrix"][:4]) *
                              tiling_in.get("manual_pingpong_buffer").get("CUB_pbuffer") *
                              BIT_RATIO_DICT.get(self.c_type))
                tiling_k_aub = tiling_in.get("AUB_shape")[0] // (self.b_info[3] * self.b_info[4])
                dy_d = self._get_dedy_d(d_o, self.stride_d)
                d_factor = self._get_d_factor(tiling_in, self.stride_d, self.k_d, dy_d)
                m_aub_max = ((tbe_platform_info.get_soc_spec("UB_SIZE") - cub_buffer) //
                             BIT_RATIO_DICT.get(self.a_type) //
                             tiling_in.get("manual_pingpong_buffer").get("AUB_pbuffer") //
                             tiling_k_aub // d_factor / (1 + 1 / self.stride_w))

                if tiling_in.get("AUB_shape")[1] >= 1:
                    w_range = min(w_range_max, max(m_aub_max // tiling_in.get("AUB_shape")[1], c_shape[3]))
                    return w_range
            return w_range_max

        tiling = self._preprocess_tiling(tiling_in)
        n_o, d_o, h_o, w_o, _ = c_shape

        paras = {
            "var_map": self.var_map,
            "k_h": self.k_h,
            "k_w": self.k_w,
            "k_d": self.k_d,
            "pad_mode": self.pad_mode,
        }
        tiling_range_n = list(self._get_batch_range(n_o, paras))

        if not self._check_tiling_match(tiling, w_o, h_o, d_o) or h_o > H_RANGE or w_o > W_RANGE:
            return tiling_range_n + [0, 0, 0, 0, 0, 0]
        h_range_min, h_range_max = self._get_h_range(h_o, tiling, paras)

        w_range_min, w_range_max = self._get_w_range(h_o, w_o, d_o, tiling, paras)

        d_range_min, d_range_max = self._get_d_range(h_o, w_range_min, d_o, tiling, paras)

        w_range_max = _modify_max_range()

        h_range_max, w_range_max = _get_perf_range()

        return tiling_range_n + [d_range_min, d_range_max, h_range_min, h_range_max, w_range_min, w_range_max]

    def _check_and_set_default_tiling(self, tiling_in):
        """
        get default tiling for unlimited range or special case

        Returns
        -------
        dict: default tiling for conv3d_bp_input
        """
        if tiling_in.get("tiling").get("AL0_matrix")[2] == _DEFAULT_TILING_FLAG:
            tiling = self.get_default_tiling()
            return {"tiling": tiling, "A_shape": self.a_info,
                    "B_shape": self.b_info, "C_shape": self.c_info}
        return tiling_in

    def _check_exceed_l1_buffer(self, tiling, current_w, current_h, current_d):
        if len(tiling["AL1_shape"]) != 0:
            # get M axis length in al1
            al1_bound = self._get_al1_bound(tiling, current_w, current_h)
            # get d
            dy_d = self._get_dedy_d(current_d, self.stride_d)
            d_factor = self._get_d_factor(tiling, self.stride_d, self.k_d, dy_d)
            # fmap size in L1 (d * M * K * db * 2byte)
            fmap_l1_size = (d_factor * al1_bound * tiling["AL1_shape"][0] *
                            utils.FP16_K * tiling["manual_pingpong_buffer"]["AL1_pbuffer"] *
                            utils.FP16_SIZE)
        else:
            dy_d = self._get_dedy_d(current_d, self.stride_d)
            dy_h = self._get_dedy_h(current_h, self.stride_h)
            dy_w = self._get_dedy_w(current_w, self.stride_w)
            # In full load, fmap size in L1 (dy_d * dy_h * dy_w * C1 * C0 * 2byte)
            fmap_l1_size = (dy_d * dy_h * dy_w * utils.icd(self.k_cout, utils.FP16_K) *
                            utils.FP16_SIZE)

        # filter size
        if tiling["BL1_shape"] is None:
            # not using BL1
            filter_l1_size = 0
        elif len(tiling["BL1_shape"]) == 0:
            # fully load in BL1
            filter_l1_size = (self.k_d * self.k_h * self.k_w * self.k_cin * self.k_cout *
                              utils.FP16_SIZE // tiling['block_dim'][1])
        else:
            # fmap size in L1 (d * K * N * db * 2byte)
            kd_tiling_l1_factor = tiling["BL1_shape"][3]
            kd_factor = tiling['BL0_matrix'][5] if tiling.get("BL0_matrix") else self.k_d
            bl1_d = kd_factor * kd_tiling_l1_factor
            filter_l1_size = (bl1_d * tiling["BL1_shape"][1] * tiling["CL0_matrix"][0] *
                              utils.FP16_N * tiling["BL1_shape"][0] * utils.FP16_K * self.k_h * self.k_w *
                              tiling["manual_pingpong_buffer"]["BL1_pbuffer"] * utils.FP16_SIZE)
        return fmap_l1_size + filter_l1_size <= tbe_platform_info.get_soc_spec("L1_SIZE")

    def _check_exceed_ub_buffer(self, tiling, current_d, current_w):
        # shape info
        if self.stride_w == 1 and self.stride_h == 1:
            return True
        dy_d = self._get_dedy_d(current_d, self.stride_d)
        dy_w = self._get_dedy_w(current_w, self.stride_w)
        aub_tiling_k, aub_tiling_m, _, _ = tiling.get("AUB_shape")
        aub_tiling_k_factor = aub_tiling_k // (self.k_h * self.k_w * utils.CUBE_SIZE)
        aub_tiling_m_factor = aub_tiling_m

        d_factor = self._get_d_factor(tiling, self.stride_d, self.k_d, dy_d)

        dedy_ub_size = ((d_factor * aub_tiling_k_factor * dy_w * utils.CUBE_SIZE * utils.FP16_SIZE *
                        (utils.icd(aub_tiling_m_factor, self.stride_h))) *
                        tiling["manual_pingpong_buffer"]["AUB_pbuffer"])

        dy_filing_size = (d_factor * aub_tiling_k_factor * aub_tiling_m_factor * (dy_w * self.stride_w) *
                          utils.CUBE_SIZE * utils.FP16_SIZE * tiling["manual_pingpong_buffer"]["AUB_pbuffer"])

        cub_size = (tiling["CUB_matrix"][0] * tiling["CUB_matrix"][1] * utils.CUBE_SIZE**2 *
                    BIT_RATIO_DICT.get(self.c_type) *
                    tiling["manual_pingpong_buffer"]["CUB_pbuffer"])

        return (dedy_ub_size * (self.var_map.get("fused_num", 0) + 1) + dy_filing_size +
                cub_size) <= tbe_platform_info.get_soc_spec("UB_SIZE")

    def _check_l1_limitation(self, fmap_w_upper):
        w_value = fmap_w_upper * self.stride_w
        if fmap_w_upper > _C0_SIZE:
            h_value_max = self.k_h_dilation + 1
        elif _C0_SIZE % fmap_w_upper == 0:
            h_value_max = self.k_h_dilation + _C0_SIZE // fmap_w_upper - 1
        else:
            h_value_max = self.k_h_dilation + _C0_SIZE // fmap_w_upper + 1
        block_size_k = tbe_platform.CUBE_MKN.get(self.a_type).get("mac")[1]
        a_l1_size = h_value_max * w_value * ((self.k_d_dilation - 2) // self.stride_d + 2) * block_size_k * 2
        b_l1_size = _C0_SIZE * block_size_k * 2
        l1_size = tbe_platform_info.get_soc_spec("L1_SIZE")
        return (a_l1_size + b_l1_size) <= l1_size

    def _check_tiling_match(self, tiling, current_w, current_h, current_d):
        """

        check whether this tiling matches the shape

        Parameters
        ----------
        tiling : dict, result of tiling fetch

        current_d : int, size of d

        current_h : int, size of h

        current_w : int, size of w

        Returns
        -------
        bool, True: match
        False: do not match

        """
        if not self._check_exceed_l1_buffer(tiling, current_w, current_h, current_d):
            return False

        if self.stride_h > 1 or self.stride_w > 1:
            if not self._check_exceed_ub_buffer(tiling, current_d, current_w):
                return False

        return True

    def _check_ub_limitation(self, dedy_w_upper):
        w_value = dedy_w_upper * self.stride_w

        aub_dedy_size_min = dedy_w_upper * _C0_SIZE * 2
        aub_filling_size_min = w_value * _C0_SIZE * 2
        cub_size_min = _C0_SIZE * _C0_SIZE * 2
        ub_size = tbe_platform_info.get_soc_spec("UB_SIZE")

        return (aub_dedy_size_min * (self.var_map.get("fused_num", 0) + 1) +
                aub_filling_size_min + cub_size_min) <= ub_size

    def _get_al1_bound(self, tiling, current_size_w, current_size_h):
        """
        get al1 bound info

        Parameters
        ----------
        tiling : dict, result of tiling fetch

        current_size_w : int, size of w

        current_size_h : int, size of h

        Returns
        -------
        int, al1_load_length (al1_bound)

        """

        # shape info
        out_w, _ = current_size_w, current_size_h
        w_i = self._get_dedy_w(out_w, stride_w=1)

        # M axis theorically loading length in al0
        al0_m_data = tiling['CL0_matrix'][1] * utils.FP16_M

        # load3d instructions refer to load extra lines with pad/stride/filter
        if al0_m_data % out_w == 0:
            # full line could load without extra lines
            extend_h = 0
        elif (al0_m_data * 2) % out_w == 0 or out_w % al0_m_data == 0:
            # every 2 load3d covered only 1 extra line
            extend_h = 1
        else:
            # other situations need 2 extra lines in case
            extend_h = 2
        l1_ho = al0_m_data // out_w + extend_h

        # calculate input lines (hi) from output lines (ho)
        li_hi = self.k_h + (l1_ho - 1)

        return li_hi * w_i

    def _get_batch_range(self, batch, paras):
        """
        get batch covering range
        """
        if "batch_n" in paras.get("var_map"):
            core_num = tbe_platform_info.get_soc_spec("CORE_NUM")
            if batch >= core_num:
                return core_num, -1
            if core_num == utils.N_BASE:
                return 1, -1
            batch_log = int(math.log(batch, utils.N_BASE))
            return utils.N_BASE ** batch_log, utils.N_BASE ** (int(batch_log + 1))
        return batch, batch

    def _get_calc_info(self):
        self._convert_type(self.a_info, self.b_info, self.c_info)
        self.k_d, self.k_h, self.k_w = self.b_info[1], self.b_info[3], self.b_info[4]
        self.k_cin = self.b_info[2] * self.b_info[5]
        self.k_cout = self.b_info[0]
        self.stride_d = self.tiling_info["stride"][0]
        self.stride_h = self.tiling_info["strideh_expand"]
        self.stride_w = self.tiling_info["stridew_expand"]
        self.dilate_d, self.dilate_h, self.dilate_w = self.tiling_info["dilation"]

        self.k_d_dilation = (self.k_d - 1) * self.dilate_d + 1
        self.k_h_dilation = (self.k_h - 1) * self.dilate_h + 1
        self.k_w_dilation = (self.k_w - 1) * self.dilate_w + 1

        self.pad_mode = "FIX"
        if any(isinstance(i, PrimExpr) for i in self.tiling_info["pad"]):
            self.pad_mode = "VAR"
        self.padh, self.padt, self.padu, self.padd, self.padl, self.padr = self.tiling_info["pad"]

    def _get_d_factor(self, tiling, stride_d, kernel_d, dedy_d):
        """
        get d_factor value

        Parameters
        ----------
        tiling: tiling information

        stride_d: stride in d dimension

        kernel_d: kernel size in d dimension

        dedy_d: stride in d dimension

        Returns
        ---------
        d_factor: d value in AL1 and UB
        """
        al0_tiling_dfactor = tiling["AL0_matrix"][-1]
        if tiling.get("BL0_matrix"):
            bl0_tiling_kd = tiling["BL0_matrix"][-1]
        else:
            bl0_tiling_kd = kernel_d
        if tiling.get("BL1_shape"):
            b_factor = min(tiling["BL1_shape"][-1] * bl0_tiling_kd, kernel_d)
        else:
            b_factor = kernel_d
        ext = utils.icd(al0_tiling_dfactor - 1, stride_d)
        estimate_d = utils.icd(b_factor - 1, stride_d) + ext + 1
        d_factor = min(estimate_d, dedy_d)
        return d_factor

    def _get_dedy_d(self, fmap_d, stride_d):
        """
        calculate output d
        """
        if not fmap_d:
            return None
        if self.pad_mode == "VAR":
            return utils.icd(fmap_d, stride_d)
        return (fmap_d + self.padh + self.padt - self.k_d_dilation) // stride_d + 1

    def _get_dedy_h(self, fmap_h, stride_h):
        """
        calculate output h
        """
        if not fmap_h:
            return None
        if self.pad_mode == "VAR":
            return utils.icd(fmap_h, stride_h)
        return (fmap_h + self.padu + self.padd - self.k_h_dilation) // stride_h + 1

    def _get_dedy_w(self, fmap_w, stride_w):
        """
        calculate output w
        """
        if not fmap_w:
            return None
        if self.pad_mode == "VAR":
            return utils.icd(fmap_w, stride_w)
        return (fmap_w + self.padl + self.padr - self.k_w_dilation) // stride_w + 1

    def _get_d_range(self, fmap_h, fmap_w_min, fmap_d, tiling, paras):
        """
        get d covering range
        """
        if "dedx_d" in paras.get("var_map") or "dedy_d" in paras.get("var_map"):
            if not tiling["AL1_shape"]:
                return 1, fmap_d
            di_min = utils.HW_MIN
            if paras.get("pad_mode") != "VAR":
                di_min = max(paras.get("k_d") - self.padh - self.padt, di_min)
            support_d_min = di_min
            cur_d_size = fmap_d
            di_max = -1
            # searching down-ward fo d_min
            while cur_d_size >= support_d_min and self._check_tiling_match(tiling, fmap_w_min, fmap_h, cur_d_size):
                di_min = cur_d_size
                cur_d_size -= D_DELTA
            di_min = max(di_min, fmap_d - D_LEN)
            return di_min, di_max
        return fmap_d, fmap_d

    def _get_h_range(self, fmap_h, tiling, paras):
        """
        get h covering range
        """
        if "dedx_h" in paras.get("var_map") or "dedy_h" in paras.get("var_map"):
            if not tiling["AL1_shape"]:
                return 1, fmap_h
            hi_min = utils.HW_MIN
            if paras.get("pad_mode") != "VAR":
                hi_min = max(paras.get("k_h") - self.padu - self.padd, hi_min)
            hi_min = max(hi_min, fmap_h - H_LEN)
            hi_max = min(utils.NHW_MAX, fmap_h + H_LEN)
            return hi_min, hi_max
        return fmap_h, fmap_h

    def _get_w_range(self, fmap_h, fmap_w, fmap_d, tiling, paras):
        """
        get w covering range
        """
        if "dedx_w" in paras.get("var_map") or "dedy_w" in paras.get("var_map"):
            if not tiling["AL1_shape"]:
                return 1, fmap_w
            wi_min = utils.HW_MIN
            if paras.get("pad_mode") != "VAR":
                wi_min = max(paras.get("k_w") - self.padl - self.padr, wi_min)
            support_w_min = wi_min
            cur_w_size = fmap_w
            # searching down-ward fo w_min
            while cur_w_size >= support_w_min and self._check_tiling_match(tiling, cur_w_size, fmap_h, fmap_d):
                wi_min = cur_w_size
                cur_w_size -= W_DELTA
            # searching up-ward for w_max
            cur_w_size = fmap_w
            wi_max = fmap_w
            while cur_w_size <= utils.NHW_MAX and self._check_tiling_match(tiling, cur_w_size, fmap_h, fmap_d):
                wi_max = cur_w_size
                cur_w_size += W_DELTA
            wi_min = max(wi_min, fmap_w - W_LEN)
            wi_max = min(wi_max, fmap_w + W_LEN)
            if wi_min > wi_max:
                return 0, 0
            return wi_min, wi_max
        return fmap_w, fmap_w

    def _get_padding(self, padh, padt, padu, padl):
        """
        get padding in tiling info for cost model's - get tiling function

        Parameters
        ----------
        padh: head pad in d dimension

        padt: tail pad in d dimension

        padu: head pad in h dimension

        padl: head pad in w dimension

        Returns
        --------
        pads: pads using for get tiling
        """
        new_up_pad = self.k_h_dilation - padu - 1
        new_left_pad = self.k_w_dilation - padl - 1
        new_down_pad = (self.c_info[2] - 1) + self.k_h_dilation - self.a_info[3] * self.stride_h - new_up_pad
        new_right_pad = (self.c_info[3] - 1) + self.k_w_dilation - self.a_info[4] * self.stride_w - new_left_pad
        if (self.stride_h > 1 or self.stride_w > 1) and (new_down_pad < 0 or new_right_pad < 0):
            new_down_pad = (new_down_pad + abs(new_down_pad)) // 2
            new_right_pad = (new_right_pad + abs(new_right_pad)) // 2
        return [padh, padt, new_up_pad, new_down_pad, new_left_pad, new_right_pad]

    def _preprocess_tiling(self, tiling_in):
        """
        preprocess tiling for get tiling range
        """
        tiling = copy.deepcopy(tiling_in)
        if tiling["AL1_shape"]:
            tiling["AL1_shape"][0] = tiling["AL1_shape"][0] // (self.k_h * self.k_w * utils.CUBE_SIZE)

        if tiling["BL1_shape"]:
            tiling["BL1_shape"][0] = tiling["BL1_shape"][0] // (self.k_h * self.k_w * utils.CUBE_SIZE)
        return tiling


class Conv3dBackpropInputGraphParser(object):
    TAG_MAP = OrderedDict([
        ("conv3d_backprop_input_dy_ddr", "a_ddr"),
        ("conv3d_backprop_input_filter_ddr", "b_ddr"),
        ("conv3d_backprop_input_dy_zero", "a_zero"),
        ("conv3d_backprop_input_dy_filling", "a_filling"),
        ("conv3d_backprop_input_dy_l1", "a_l1"),
        ("conv3d_backprop_input_dy_vn", "a_vn"),
        ("conv3d_backprop_input_dy_l1_s1", "a_l1"),
        ("conv3d_backprop_input_im2col_row_major", "a_col_before"),
        ("conv3d_backprop_input_im2col_fractal", "a_col"),
        ("conv3d_backprop_input_w_l1", "b_l1"),
        ("conv3d_backprop_input_w_l1_d_extraction", "b_l1_d_extraction"),
        ("conv3d_backprop_input_w_l1_zero", "b_l1_zero"),
        ("conv3d_backprop_input_w_l1_vn", "b_l1_vn"),
        ("conv3d_backprop_input_w_col", "b_col"),
        ("conv3d_backprop_input_mad", "c_col"),
        ("conv3d_backprop_input_dx_ddr", "dx_ddr"),
        ("conv3d_backprop_input_dx_filing_zero", "c_fill_zero"),
        ("conv3d_backprop_input_c_ddr_zero", "c_ddr_zero"),
        ("conv3d_backprop_input_c_ddr_vn", "c_ddr_vn"),
        ("conv3d_backprop_input_c_ddr_vn", "dx_res"),
        ("conv3d_backprop_input_c_ddr", "dx_res"),
        ("conv3d_backprop_input_c_ddr_add", "c_ddr_add",),
        ("conv3d_backprop_input_bias_ddr", "bias_ddr"),
    ])

    # key: tensor name, value: (scope, emit_insn, emit_dict)
    # scope None denotes gm
    SCOPE_MAP_MILAN_STC_SINGLE_OP = {
        "a_ddr": (None, None, {}),
        "b_ddr": (None, None, {}),
        "a_zero": (tbe_platform_info.scope_cbuf, "set_2d", {}),
        "a_filling": (tbe_platform_info.scope_cbuf, "dma_copy", {}),
        "a_l1": (tbe_platform_info.scope_cbuf, "phony_insn", {}),
        "b_l1": (tbe_platform_info.scope_cbuf, "dma_copy", {}),
        "b_col": (tbe_platform_info.scope_cb, "dma_copy", {}),
        "a_col_before": (tbe_platform_info.scope_cbuf, "set_fmatrix", {}),
        "a_col": (tbe_platform_info.scope_ca, "im2col", {}),
        "c_col": (tbe_platform_info.scope_cc, "mad", {}),
        "dx_ddr": (None, "fixpipe_op", {"enable_select2if": 1}),
        "c_fill_zero": (tbe_platform_info.scope_cbuf, "set_2d", {"enable_select2if": 1}),
        "c_ddr_zero": (None, "dma_copy", {}),
        "c_ddr_vn": (None, "phony_insn", {}),
    }

    SCOPE_MAP_MILAN_DYN_SINGLE_OP = copy.deepcopy(SCOPE_MAP_MILAN_STC_SINGLE_OP)
    SCOPE_MAP_MILAN_DYN_SINGLE_OP.update({
        "a_vn": (tbe_platform_info.scope_cbuf, "inline", {}),
        "a_col_before": (tbe_platform_info.scope_cbuf, "row_major_vm", {}),
        "a_col": (tbe_platform_info.scope_ca, "im2col_v2", {}),
        "b_l1_d_extraction": (tbe_platform_info.scope_cbuf, "inline", {}),
        "b_l1_zero": (tbe_platform_info.scope_cbuf, "set_2d", {}),
        "b_l1_vn": (tbe_platform_info.scope_cbuf, "phony_insn", {}),
    })

    SCOPE_MAP_OBP_STC_SINGLE_OP = {}
    SCOPE_MAP_OBP_DYN_SINGLE_OP = {}
    SCOPE_CONDITION = {
        # key definition: (binary_flag, support_l0c2out_flag)
        (True, True): SCOPE_MAP_MILAN_DYN_SINGLE_OP,
        (False, True): SCOPE_MAP_MILAN_STC_SINGLE_OP,
        (True, False): SCOPE_MAP_OBP_DYN_SINGLE_OP,
        (False, False): SCOPE_MAP_OBP_STC_SINGLE_OP,
    }

    def __init__(self, res_tensor):
        self.tensor_map = {}
        self.undef_tensor_list = []
        self.tensor_attr = {}
        self.res_tensor = res_tensor
        self.unsupported_flag = False
        self.support_l0c2out_flag = tbe_platform.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out")

    def parse_graph(self):
        """
        Parse compute graph for 3ddx.
        Notice that OBP & fusion condition are not supported.
        """
        def _parse(tensor):
            for tensor_in in tensor.op.input_tensors:
                if tensor_in.op.tag not in self.TAG_MAP and tensor_in.op.attrs.get("tag") not in self.TAG_MAP:
                    log.warn(f"Cannot find op tag {tensor_in.op.tag} in tag map, tensor name: {tensor_in.name}")
                    self.undef_tensor_list.append(tensor_in)

                tag = tensor_in.op.tag if tensor_in.op.tag in self.TAG_MAP  else tensor_in.op.attrs.get("tag")
                self.tensor_map.update({self.TAG_MAP.get(tag): tensor_in})
                _parse(tensor_in)

        if self.res_tensor.op.tag not in self.TAG_MAP:
            self.undef_tensor_list.append(self.res_tensor)
        else:
            self.tensor_map.update({self.TAG_MAP.get(self.res_tensor.op.tag): self.res_tensor})

        _parse(self.res_tensor)

        if not self.support_l0c2out_flag or len(self.undef_tensor_list) > 0:
            self.unsupported_flag = True
            return

        if "a_zero" in self.tensor_map:
            self.tensor_attr.update({"need_expand_stride": True})

        dx_res = self.tensor_map.get("dx_res")
        # NOTE: fusion_mode, split_w are faked at present
        fusion_mode = 1 if dx_res.op.attrs.get("dsl_flag", False) else 0
        self.tensor_attr.update({const.FUSION_KEY: fusion_mode, "split_w": False})
        self.tensor_attr["6HD_TRANS_NDHWC"] = dx_res.op.attrs.get("6HD_TRANS_NDHWC", False)
        self.tensor_attr["NDHWC_trans_6HD"] = self.tensor_map.get("a_ddr").op.tag == "NDHWC_trans_6HD"
        binary_flag = dx_res.op.attrs.get("binary_flag", False)
        _, _, block_size_n0 = tbe_platform.CUBE_MKN.get(self.tensor_map.get("b_ddr").dtype).get("mac")

        if binary_flag:
            self.tensor_attr.update({
                "dilations": (self._get_var("dilation_d"), self._get_var("dilation_h"), self._get_var("dilation_w")),
                "kernels": (self._get_var("kernel_d"), self._get_var("kernel_h"), self._get_var("kernel_w")),
                "strides": (self._get_var("stride_d"), self._get_var("stride_h"), self._get_var("stride_w")),
                "group_dict": {
                    "real_g": self._get_var("real_g"),
                    "cout_g": self._get_var("dedy_cout1_g") * block_size_n0,
                    "cin1_g": self._get_var("dedx_cin1_g"),
                    "cout1_g": self._get_var("dedy_cout1_g")
                },
                "output_shape": (self._get_var("batch_n"), self._get_var("dedx_d"), self._get_var("dedx_cin1"),
                                 self._get_var("dedx_h"), self._get_var("dedx_w"), block_size_n0),
                "output_dtype":
                dx_res.dtype,
                "depth_pad": (self._get_var("pad_h"), self._get_var("pad_t")),
                "bp_pads": (self._get_var("backprop_pad_u"), self._get_var("backprop_pad_d"),
                            self._get_var("backprop_pad_l"), self._get_var("backprop_pad_r")),
                "padding_var": (self._get_var("backprop_pad_u"), self._get_var("backprop_pad_d"),
                                self._get_var("backprop_pad_l"), self._get_var("backprop_pad_r")),
                "special_load3d_flag":
                bool(dx_res.op.attrs.get("special_load3d_flag")),
                "dilation_d_gt_one_flag":
                (self.tensor_map.get("b_l1_zero") is not None) and (self.tensor_map.get("b_l1_vn") is not None)
            })
        else:
            self.tensor_attr.update({
                "dilations": [dim.value for dim in dx_res.op.attrs.get("dilations")],
                "kernels": [dim.value for dim in dx_res.op.attrs.get("kernels")],
                "strides": [dim.value for dim in dx_res.op.attrs.get("strides")],
                "group_dict": {
                    "real_g": dx_res.op.attrs.get("group_dict").get("real_g").value,
                    "cout_g": dx_res.op.attrs.get("group_dict").get("cout_g").value,
                    "cin1_g": dx_res.op.attrs.get("group_dict").get("cin1_g").value,
                    "cout1_g": dx_res.op.attrs.get("group_dict").get("cout_g").value // block_size_n0
                },
                "output_shape": [dim.value for dim in dx_res.op.attrs.get("output_shape")],
                "output_dtype":
                dx_res.dtype,
                "depth_pad": [dim.value for dim in dx_res.op.attrs.get("depth_pad")],
                "bp_pads": [dim.value for dim in dx_res.op.attrs.get("bp_pads")],
                "padding_var": [dim.value for dim in dx_res.op.attrs.get("bp_pads")],
                "special_load3d_flag":
                bool(dx_res.op.attrs.get("special_load3d_flag")),
                "dilation_d_gt_one_flag":
                (self.tensor_map.get("b_l1_zero") is not None) and (self.tensor_map.get("b_l1_vn") is not None)
            })

    def _get_var(self, var_name: str):
        te_var = get_te_var(var_name)
        if te_var is None:
            raise_err_message_cube(f"Cannot find tvm var with name: {var_name}")
        return te_var.get_tvm_var()


class Conv3dBackpropInputBinaryParaProcess():
    """
    Helper class for binary param process.
    """
    def __init__(self, paras):
        self.op_type = "conv3d_backprop_input"
        self.filters = paras.get("filters")
        self.out_backprop = paras.get("out_backprop")
        self.y = paras.get("y")
        self.strides = paras.get("strides")
        self.pads = paras.get("pads")
        self.dilations = paras.get("dilations")
        self.groups = paras.get("groups")
        self.data_format = paras.get("data_format")
        self.kernel_name = paras.get("kernel_name")
        self.build_options = paras.get("build_options")
        self.shape = {}
        self.attrs = {}
        self.valid_paras = {
            "valid_format": {"filter": ("NCDHW", "NDHWC", "DHWCN"),
                             "out_backprop": ("NCDHW", "NDHWC"),
                             "dedx": ("NCDHW", "NDHWC")},
            # dtype comb in order of filter, dedy, dedx
            "valid_dtype_comb": (("float16", "float16", "float16"), ("bfloat16", "bfloat16", "bfloat16"))
        }

    __binary_vars = OrderedDict([
        # shape vars
        ("batch_n", (1, INT32_MAX)),
        ("dedy_cout", (1, INT32_MAX)),
        ("dedy_d", (1, INT32_MAX)),
        ("dedy_h", (1, INT32_MAX)),
        ("dedy_w", (1, INT32_MAX)),
        ("dedx_cin", (1, INT32_MAX)),
        ("dedx_d", (1, INT32_MAX)),
        ("dedx_h", (1, INT32_MAX)),
        ("dedx_w", (1, INT32_MAX)),
        ("kernel_d", (1, Load3DParam.filter_max())),
        ("kernel_h", (1, Load3DParam.filter_max())),
        ("kernel_w", (1, Load3DParam.filter_max())),
        ("dedy_cout1", (1, INT32_MAX)),
        ("dedx_cin1", (1, INT32_MAX)),
        ("real_g", (1, INT32_MAX)),
        ("dedy_cout1_g", (1, INT32_MAX)),
        ("dedx_cin1_g", (1, INT32_MAX)),
        ("kernel_g_dk_cin1g_hk_wk", (1, INT32_MAX)),

        # attr vars
        ("stride_d", (1, INT32_MAX)),
        ("stride_h", (1, INT32_MAX)),
        ("stride_w", (1, INT32_MAX)),
        ("pad_h", (0, Load3DParam.pad_max())),
        ("pad_t", (0, Load3DParam.pad_max())),
        ("pad_u", (0, Load3DParam.pad_max())),
        ("pad_d", (0, Load3DParam.pad_max())),
        ("pad_l", (0, Load3DParam.pad_max())),
        ("pad_r", (0, Load3DParam.pad_max())),
        ("dilation_d", (1, Load3DParam.dilation_max())),
        ("dilation_h", (1, Load3DParam.dilation_max())),
        ("dilation_w", (1, Load3DParam.dilation_max())),
        ("shape_up_modify", (-Load3DParam.pad_max(), 0)),
        ("shape_left_modify", (-Load3DParam.pad_max(), 0)),
        ("shape_down_modify", (-Load3DParam.pad_max(), 0)),
        ("shape_right_modify", (-Load3DParam.pad_max(), 0)),
        ("backprop_pad_h", (0, Load3DParam.pad_max())),
        ("backprop_pad_t", (0, Load3DParam.pad_max())),
        ("backprop_pad_u", (0, Load3DParam.pad_max())),
        ("backprop_pad_d", (0, Load3DParam.pad_max())),
        ("backprop_pad_l", (0, Load3DParam.pad_max())),
        ("backprop_pad_r", (0, Load3DParam.pad_max())),

        # tiling vars
        ("batch_dim", (1, BLOCK_DIM_MAX)),
        ("n_dim", (1, BLOCK_DIM_MAX)),
        ("m_dim", (1, BLOCK_DIM_MAX)),
        ("group_dim", (1, BLOCK_DIM_MAX)),
        ("d_dim", (1, BLOCK_DIM_MAX)),
        ("m_al1", (1, BINARY_RANGE_CONST_1024)),
        ("n_bl1", (1, BINARY_RANGE_CONST_1024)),
        ("m_l0", (1, BINARY_RANGE_CONST_64)),
        ("n_l0_div_ub", (1, BINARY_RANGE_CONST_64)),
        ("n_cub", (1, BINARY_RANGE_CONST_64)),
        ("k_l0", (1, BINARY_RANGE_CONST_64)),
        ("min_kl1_div_kl0", (1, BINARY_RANGE_CONST_1024)),
        ("max_kl1_div_min_kl1", (1, BINARY_RANGE_CONST_1024)),
        ("k_div_max_kl1", (1, BINARY_RANGE_CONST_1024)),
        ("d_al1", (1, BINARY_RANGE_CONST_1024)),
        ("d_bl1", (1, BINARY_RANGE_CONST_1024)),
        ("d_al0", (1, BINARY_RANGE_CONST_64)),
        ("d_bl0", (1, BINARY_RANGE_CONST_64)),
        ("d_cl0", (1, BINARY_RANGE_CONST_64)),
        ("k_aub", (1, BINARY_RANGE_CONST_1024)),
        ("m_aub", (1, BINARY_RANGE_CONST_1024)),
        ("wo_aub", (1, INT32_MAX)),
        ("al1_bound", (BINARY_RANGE_CONST_256, BINARY_RANGE_CONST_1024 * BINARY_RANGE_CONST_1024)),
        ("bl1_bound", (BINARY_RANGE_CONST_256, BINARY_RANGE_CONST_1024 * BINARY_RANGE_CONST_1024)),
        ("aub_bound", (BINARY_RANGE_CONST_256, BINARY_RANGE_CONST_256 * BINARY_RANGE_CONST_1024)),

        # extend vars
        ("load3d_special", (0, 1)),
        ("hf32_flag", (0, 1)),
    ])

    @classmethod
    def get_binary_vars(cls):
        return cls.__binary_vars

    @staticmethod
    def check_binary_flag(tensor_dict: dict):
        return all(x == -1 for x in tensor_dict.get("ori_shape")) and \
            tbe_platform.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out")

    @staticmethod
    def define_var(name: str):
        if operation.get_te_var(name) is None:
            return operation.var(name)
        return operation.get_te_var(name).get_tvm_var()

    @staticmethod
    def get_var(var_name: str):
        te_var = operation.get_te_var(var_name)
        if te_var is None:
            err_man.raise_err_specific_user("Cannot find te var: {}".format(var_name))
        return te_var.get_tvm_var()

    def check_paras(self):
        self._check_input_dict(self.filters, "filters", False)
        self._check_input_dict(self.out_backprop, "out_backprop", False)
        self._check_input_dict(self.y, "y", False)
        self._check_format(self.filters.get("ori_format"), "filter")
        self._check_format(self.out_backprop.get("ori_format"), "out_backprop")
        self._check_format(self.y.get("ori_format"), "dedx")
        if self.y.get("ori_format") != self.data_format:
            err_man.raise_err_specific_user(self.op_type, "The ori_format of y and data_format are not same.")
        self._check_dtype_comb()
        self._check_attr_dim()

    def define_placeholder(self):
        for var in self.get_binary_vars():
            self.define_var(var)

        self.attrs["group_dict"] = {
            "real_g": self.define_var("real_g"),
            "cout1_g": self.define_var("dedy_cout1_g"),
            "cout_g": self.define_var("dedy_cout1_g") * BLOCK_K_DICT.get(self.out_backprop.get("dtype")),
            "cin1_g": self.define_var("dedx_cin1_g"),
            "cin_ori": self.define_var("dedx_cin"),
            "cout_ori": self.define_var("dedy_cout"),
        }

        if all(sd == 1 for sd in self.strides):
            self.attrs["strides_ndhwc"] = self.strides
        else:
            self.attrs["strides_ndhwc"] = (1, self.define_var("stride_d"), self.define_var("stride_h"),
                                           self.define_var("stride_w"), 1)
        self.attrs["pads"] = (self.define_var("pad_h"), self.define_var("pad_t"), self.define_var("pad_u"),
                              self.define_var("pad_d"), self.define_var("pad_l"), self.define_var("pad_r"))
        self.attrs["dilations_ndhwc"] = (1, self.define_var("dilation_d"), self.define_var("dilation_h"),
                                         self.define_var("dilation_w"), 1)
        _, block_size_k, block_size_n = tbe_platform.CUBE_MKN.get(self.filters.get("dtype")).get('mac')
        self.shape["dedy_ndc1hwc0"] = (self.define_var("batch_n"), self.define_var("dedy_d"),
                                       self.define_var("dedy_cout1"), self.define_var("dedy_h"),
                                       self.define_var("dedy_w"), BLOCK_K_DICT.get(self.out_backprop.get("dtype")))
        self.shape["filter_fz_3d"] = (self.define_var("kernel_g_dk_cin1g_hk_wk"), self.define_var("dedy_cout1_g"),
                                      block_size_n, block_size_k)
        self.shape["filter_ncdhw"] = (self.define_var("dedy_cout"), self.define_var("dedx_cin"),
                                      self.define_var("kernel_d"), self.define_var("kernel_h"),
                                      self.define_var("kernel_w"))
        self.shape["dedx_ndhwc"] = (self.define_var("batch_n"), self.define_var("dedx_d"), self.define_var("dedx_h"),
                                    self.define_var("dedx_w"), self.define_var("dedx_cin"))
        self.shape["dedx_ndc1hwc0"] = (self.define_var("batch_n"), self.define_var("dedx_d"),
                                       self.define_var("dedx_cin1"), self.define_var("dedx_h"),
                                       self.define_var("dedx_w"), BLOCK_K_DICT.get(self.y.get("dtype")))

        input_size_tensor = tvm.placeholder([5], name="input_size", dtype="int32")
        filter_tensor = tvm.placeholder(self.shape.get("filter_fz_3d"),
                                        name="filter",
                                        dtype=self.filters.get("dtype"),
                                        attrs={"tag": "conv3d_backprop_input_filter_ddr"})
        dedy_tensor = tvm.placeholder(self.shape.get("dedy_ndc1hwc0"),
                                      name="dedy",
                                      dtype=self.out_backprop.get("dtype"),
                                      attrs={"tag": "conv3d_backprop_input_dy_ddr"})

        return input_size_tensor, filter_tensor, dedy_tensor

    def _check_attr_dim(self):
        if len(self.strides) != len(self.data_format):
            err_man.raise_err_specific_user(self.op_type, "Invalid strides length")
        if len(self.dilations) != len(self.data_format):
            err_man.raise_err_specific_user(self.op_type, "Invalid dilation length")
        if len(self.pads) != CONV3D_PADS_LEN:
            err_man.raise_err_specific_user(self.op_type, "Invalid pads length")

    def _check_dtype_comb(self):
        if (self.filters.get("dtype"), self.out_backprop.get("dtype"), self.y.get("dtype")) \
            not in self.valid_paras.get("valid_dtype_comb"):
            err_man.raise_err_specific_user(self.op_type, "Invalid dtype combination")

    def _check_format(self, param_format, param_name):
        expect_formats = self.valid_paras.get("valid_format").get(param_name)
        if param_format not in expect_formats:
            err_man.raise_err_input_format_invalid(
                self.op_type, param_name, expect_formats, param_format)

    def _check_input_dict(self, para, para_name, need_range):
        if not isinstance(para, dict):
            err_man.raise_err_check_type(self.op_type, para_name, dict, type(para))
        if not para.get("ori_shape"):
            err_man.raise_err_specific_user(self.op_type, f"need to pass ori_shape in {para_name}")
        if not para.get("dtype"):
            err_man.raise_err_specific_user(self.op_type, f"need to pass dtype in {para_name}")
        if not para.get("ori_format"):
            err_man.raise_err_specific_user(self.op_type, f"need to pass ori_format in {para_name}")
        if list(para.get("ori_shape")) != UNKNOWN_SHAPE:
            if len(para.get("ori_shape")) != len(para.get("ori_format")):
                err_man.raise_err_specific_user(self.op_type, "ori_shape and ori_format not match")
            for i in range(len(para.get("ori_shape"))):
                if not isinstance(para.get("ori_shape")[i], int):
                    err_man.raise_err_specific_user(self.op_type, "value of shape must be int")
                if para.get("ori_shape")[i] <= 0 and para.get("ori_shape")[i] != DYNAMIC_FLAG:
                    err_man.raise_err_specific_user(self.op_type, "value of shape must be -1 or >0")
            if need_range and not para.get("range"):
                err_man.raise_err_specific_user(self.op_type, f"need to pass range in {para_name}")