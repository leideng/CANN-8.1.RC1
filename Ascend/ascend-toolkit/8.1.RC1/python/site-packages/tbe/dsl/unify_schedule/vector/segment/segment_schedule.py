#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
segment schedule
"""
from typing import Any

from tbe import tvm
from tbe.common.utils import op_tiling
from tbe.dsl.base import operation
from tbe.dsl.base.operation import get_compile_info

from ... import util
from ...constants import CompileInfo
from ...constants import DTYPE_BYTE_MAPPING
from ...constants import SegmentPattern
from ...constants import Pattern
from ...schedule import Schedule
from .segment_tilingcase import TilingStrategy
from .segment_tilingcase import SegmentCompileInfo
from .segment_schedule_atomic import SegmentAtomicSchedule
from .segment_schedule_no_atomic import SegmentNoAtomicSchedule
from .segment_schedule_zero import SegmentZeroSchedule

DEFAULT = "default"

# block size in D architecture
BLOCK_SIZE_BYTE = 32

# STORE AREA
VAR_STORE_GM = 0
VAR_STORE_UB = 1


# 'pylint: disable=R0902, R0903
class SegmentSchedule(Schedule):
    """
    segment schedule
    """
    def __init__(self, outs, tiling_case):
        self._out_tensor = outs[0]
        self._schedule = None
        self._tiling_case = tiling_case
        self._tiling_key = self._tiling_case.get("key")
        self._is_atomic = self._tiling_case.get("is_atomic", True)
        self._is_zero = self._tiling_case.get("is_zero", False)

    @classmethod
    def get_instance(cls, outs, tiling_case):  # type: (list[Any], Any) -> "Schedule"
        return cls(outs, tiling_case)

    @classmethod
    def get_supported_soc(cls):  # type: () -> list[str]
        return [DEFAULT]

    @classmethod
    def get_supported_pattern(cls):  # type: () -> list[str]
        return [Pattern.SEGMENT]

    @classmethod
    def get_supported_sub_pattern(cls):  # type: () -> list[str]
        return [SegmentPattern.NORMAL_SCHEDULE]

    def do_schedule(self):
        """
        schedule body
        :return:
        """
        if not self._is_zero:
            if self._is_atomic:
                atomic_sch = SegmentAtomicSchedule([self._out_tensor], self._tiling_case)
                real_sch = atomic_sch.do_schedule()
            else:
                no_atomic_sch = SegmentNoAtomicSchedule([self._out_tensor], self._tiling_case)
                real_sch = no_atomic_sch.do_schedule()
        else:
            zero_sch = SegmentZeroSchedule([self._out_tensor], self._tiling_case)
            real_sch = zero_sch.do_schedule()
        return real_sch
