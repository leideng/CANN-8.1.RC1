#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
pooling_with_arg_vars tiling case
"""
from enum import Enum
from enum import IntEnum
from enum import auto
from typing import Optional, List, Any

from tbe import tvm
from tbe.dsl.base import operation
from tbe.dsl.base.operation import register_build_pointcut
from tbe.dsl.unify_schedule.vector.tiling_key import TilingKey
from tbe.dsl.unify_schedule.vector.tiling_key import ScheduleType

from ... import util
from ...computation import Computation
from ...constants import CompileInfo
from ...constants import PoolingWithArgPattern
from ...constants import Pattern

DEFAULT = "default"
DYNAMIC = "dynamic"
STATIC = "static"
# calculate mode
FLOOR = "FLOOR"
CEIL = "CEIL"
EXPAND_MODE = "EXPAND_MODE"
MTE1 = "MTE1"
VECTOR = "VECTOR"
NO_SPLIT = "NO_SPLIT"
SPLIT = "SPLIT"
ALL_SPLIT = "ALL_SPLIT"
C0_REORDER = "C0_REORDER"
HW_BLOCK = "HW_BLOCK"
N_BLOCK = "N_BLOCK"
H_IDX = 0
W_IDX = 1
VCOPY_SIZE_MAX = 4095

CALCULATE_DICT = {
    False: [FLOOR],
    True: [CEIL],
}

TilingMode = {
    "NC1HWC0": {
        DYNAMIC: 0x000,
        STATIC: 0x001
    },
    "NCHW": {
        DYNAMIC: 0x002,
        STATIC: 0x003
    },
    "NHWC": {
        DYNAMIC: 0x004,
        STATIC: 0x005
    }
}

FORMAT_MAPPING = {
    0: "NC1HWC0",
    1: "NDC1HWC0",
    2: "NCHW",
    3: "NHWC"
}

TilingPattern = {
    MTE1: 0x000,
    VECTOR: 0x001,
}

TilingSplit = {
    MTE1: {
        NO_SPLIT: 0x0,
        SPLIT: 0x1,
    },
    VECTOR: {
        NO_SPLIT: 0x0,
        SPLIT: 0x1,
        ALL_SPLIT: 0x2,
        C0_REORDER: 0x3,
    }

}

TilingCalMode = {
    FLOOR: 0x0,
    CEIL: 0x1,
}

CEIL_MODE_MAP = {
    "FLOOR": 0,
    "CEIL": 1,
    "BOTH": -1
}

FUSED_OUTER = {
    False: 0,
    True: 1
}

SPLIT_MODES = {
    NO_SPLIT: {
        HW_BLOCK: [H_IDX, W_IDX],
        N_BLOCK: [H_IDX, W_IDX]
    },
    SPLIT: {
        HW_BLOCK: [H_IDX, W_IDX],
        N_BLOCK: [H_IDX, W_IDX]
    }
}

NdTilingPattern = {
    NO_SPLIT: 0x000,
    SPLIT: 0x001,
}

NdTilingSplit = {
    HW_BLOCK: 0x0,
    N_BLOCK: 0x1,
}

KERNEL_MAX = 255
STRIDE_MAX = 63
DILATION_MAX = 255
PAD_MAX = 255
BLOCK_SIZE = 32
UB_TEMP_BUFFER = 256


class PoolingWithArgCompileInfo:
    """
    Built-in Compile info keys
    """
    L1_BUFFER_SIZE = "_l1_size"
    BASE_INFO = "_base_info"
    POOLING_INFO = "_pooling_info"
    POOLING_AXES = "_pooling_axes"
    ORG_POOLING_AXES = "_org_pooling_axes"
    ATTR_AXES = "_attr_axes"
    POOLING_DIMENSIONS = "_pooling_dimensions"
    POOLING_STRIDES = "_pooling_strides"
    POOLING_DILATIONS = "_pooling_dilations"
    POOLING_PADS = "_pooling_pads"
    CALCULATE_MODE = "_calculate_mode"
    COMPUTE_CALCULATE_MODE = "_compute_calculate_mode"
    POOLING_EXPAND_MODE = "_expand_mode"
    TENSOR_NUMBERS = "_tensor_numbers"
    INPUT_BYTES = "_input_bytes"
    INPUT_DTYPE = "_input_dtype"
    INPUT_FORMAT = "_input_format"
    INSN_PATTERN = "_insn_pattern"


SUB_PATTERN_MAP = {
    0: PoolingWithArgPattern.SCHEDULE_5HD,
    2: PoolingWithArgPattern.SCHEDULE_NCHW
}


class TilingStrategy(Enum):
    """
    TilingStrategy
    """
    DYNAMIC = auto()
    STATIC = auto()


class PoolingWithArgComputation(Computation):
    """
    SliceComputation
    """
    def __init__(self, outs, option):
        self.outs = outs
        self.option = option
        self.calculate_mode = operation.get_context().get_current_compute().get(
            PoolingWithArgCompileInfo.COMPUTE_CALCULATE_MODE)
        self.input_dtype = operation.get_context().get(PoolingWithArgCompileInfo.INPUT_DTYPE)
        self.input_format = operation.get_context().get(PoolingWithArgCompileInfo.INPUT_FORMAT)
        self.is_static = operation.get_op_mode() == "static"

    @classmethod
    def get_instance(cls, outs, option):  # type: (list[Any], dict[str, Any]) -> "Computation"
        return cls(outs, option)

    @classmethod
    def get_supported_pattern(cls):  # type: () -> list[str]
        return [Pattern.POOLINGWITHARG]

    @classmethod
    def get_supported_soc(cls):  # type: () -> list[str]
        return [DEFAULT]

    @staticmethod
    def _get_tiling_patterns():
        def _kernel_support():
            kh = operation.get_context().get_current_compute().get("_kh")
            kw = operation.get_context().get_current_compute().get("_kw")
            support = True
            if isinstance(kh, int):
                support = support and (kh <= KERNEL_MAX)

            if isinstance(kw, int):
                support = support and (kw <= KERNEL_MAX)

            return support

        def _stride_support():
            stride_h = operation.get_context().get_current_compute().get("_stride_h")
            stride_w = operation.get_context().get_current_compute().get("_stride_w")
            support = True
            if isinstance(stride_h, int):
                support = support and (stride_h <= STRIDE_MAX)

            if isinstance(stride_w, int):
                support = support and (stride_w <= STRIDE_MAX)

            return support

        def _dilation_support():
            dilate_h = operation.get_context().get_current_compute().get("_dilation_h")
            dilate_w = operation.get_context().get_current_compute().get("_dilation_w")
            support = True
            if isinstance(dilate_h, int):
                support = support and (dilate_h <= DILATION_MAX)

            if isinstance(dilate_w, int):
                support = support and (dilate_w <= DILATION_MAX)

            return support

        def _pad_support():
            pt = operation.get_context().get_current_compute().get("_padding_top")
            pb = operation.get_context().get_current_compute().get("_padding_bottom")
            pl = operation.get_context().get_current_compute().get("_padding_left")
            pr = operation.get_context().get_current_compute().get("_padding_right")
            support = True
            if isinstance(pt, int):
                support = support and (pt <= PAD_MAX)
            if isinstance(pb, int):
                support = support and (pb <= PAD_MAX)
            if isinstance(pl, int):
                support = support and (pl <= PAD_MAX)
            if isinstance(pr, int):
                support = support and (pr <= PAD_MAX)

            return support

        def _l1_size_dma():
            shape_w = operation.get_context().get_current_compute().get("_fm_w")
            if isinstance(shape_w, tvm.tir.IntImm):
                shape_w = shape_w.value
            kh = operation.get_context().get_current_compute().get("_kh")
            support = True
            if isinstance(kh, int) and isinstance(shape_w, int):
                support = support and (kh * shape_w * BLOCK_SIZE < util.get_l1_size())
            return support

        def _support_load3d_insn():
            return _kernel_support() and _stride_support() and _dilation_support() and _pad_support() and _l1_size_dma()

        if (util.is_v100() or util.is_v200()) and _support_load3d_insn():
            return [MTE1, VECTOR]
        return [VECTOR, ]

    @staticmethod
    def _check_indices():
        kh = operation.get_context().get_current_compute().get("_kh")
        if not isinstance(kh, int):
            return True

        if kh > VCOPY_SIZE_MAX:
            return False

        shape_w = operation.get_context().get_current_compute().get("_fm_w")
        if isinstance(shape_w, tvm.tir.IntImm):
            return kh * shape_w.value < VCOPY_SIZE_MAX
        elif isinstance(shape_w, int):
            return kh * shape_w < VCOPY_SIZE_MAX

        return True

    def do_tiling_case(self):
        if FORMAT_MAPPING.get(self.input_format) in ("NC1HWC0",):
            return self._calc_tilingcase_5hd()
        return self._calc_tilingcase_nd()

    def get_sub_pattern(self):  # type: () -> str
        return SUB_PATTERN_MAP.get(self.input_format)

    def _calc_tilingcase_5hd(self):
        def skip_condition(split_pattern, input_dtype, fuse):
            return (split_pattern == ALL_SPLIT and fuse) \
                   or (split_pattern == C0_REORDER and input_dtype == "float16") \
                   or (split_pattern == MTE1 and input_dtype == "float32")
        calculate_modes = CALCULATE_DICT.get(self.calculate_mode)
        tiling_patterns = self._get_tiling_patterns()
        strategy = TilingStrategy.STATIC if self.is_static else TilingStrategy.DYNAMIC
        operation.get_context().add(PoolingWithArgCompileInfo.INSN_PATTERN, tiling_patterns)
        cases = []
        for _fuse in FUSED_OUTER.keys():
            for _mode in calculate_modes:
                for _pattern in tiling_patterns:
                    for _split in TilingSplit.get(_pattern).keys():
                        _tiling_key = TilingKey(ScheduleType.POOLING_WITH_ARG)
                        _tiling_key.mode = TilingMode.get("NC1HWC0").get("dynamic")
                        _tiling_key.pattern = TilingPattern.get(_pattern)
                        _tiling_key.split_flag = TilingSplit.get(_pattern).get(_split)
                        _tiling_key.set_value(FUSED_OUTER.get(_fuse), 12, 13)
                        _tiling_key.set_value(TilingCalMode.get(_mode), 13, 14)
                        if skip_condition(_split, self.input_dtype, _fuse):
                            continue
                        cases.append({
                            "key": _tiling_key,
                            "tiling_strategy": strategy,
                            "calculate_mode": _mode,
                            "insn_pattern": _pattern,
                            "split_flag": _split,
                            "fused_outer": _fuse
                        })
        return cases

    def _calc_tilingcase_nd(self):
        pool_axes = operation.get_context().get(PoolingWithArgCompileInfo.POOLING_AXES)
        strategy = TilingStrategy.STATIC if self.is_static else TilingStrategy.DYNAMIC
        calculate_modes = CALCULATE_DICT.get(self.calculate_mode)
        cases = []
        for _mode in calculate_modes:
            for _split_mode in SPLIT_MODES.keys():
                for _block_mode in SPLIT_MODES.get(_split_mode):
                    for _ub_axis in SPLIT_MODES.get(_split_mode).get(_block_mode):
                        _tiling_key = TilingKey(ScheduleType.POOLING_WITH_ARG)
                        _tiling_key.mode = TilingMode.get("NCHW").get("dynamic")
                        _tiling_key.pattern = NdTilingPattern.get(_split_mode)
                        _tiling_key.split_flag = NdTilingSplit.get(_block_mode)
                        _tiling_key.set_value(TilingCalMode.get(_mode), 13, 14)
                        _tiling_key.ub_axis = pool_axes[_ub_axis]
                        if _ub_axis == 0 and (not self._check_indices()):
                            continue
                        cases.append({
                            "key": _tiling_key,
                            "tiling_strategy": strategy,
                            "split_mode": _split_mode,
                            "block_mode": _block_mode,
                            "ub_axis": pool_axes[_ub_axis],
                            "ceil_mode": _mode,
                        })
        return cases


def unify_attr_info(attr_input):
    attr_result = []
    for _v in attr_input:
        if isinstance(_v, list):
            for _inner_v in _v:
                tmp_value = -1 if _inner_v is None else _inner_v
                attr_result.append(tmp_value)
        else:
            tmp_value = -1 if _v is None else _v
            attr_result.append(tmp_value)
    return  attr_result


def _pre_build(schedules_list):
    def _flatten_sch(_schedules: list):
        for sub_schs in schedules_list:
            if isinstance(sub_schs, list):
                _schedules.extend(list(filter(None, sub_schs)))
            else:
                _schedules.append(sub_schs)
    schedules = []
    _flatten_sch(schedules)

    op_cores = util.get_core_num()
    op_ub_size = util.get_ub_size() - UB_TEMP_BUFFER
    op_l1_size = util.get_l1_size()
    op_input_bytes = operation.get_context().get(PoolingWithArgCompileInfo.INPUT_BYTES)
    op_input_format = operation.get_context().get(PoolingWithArgCompileInfo.INPUT_FORMAT)
    op_ceil_mode = operation.get_context().get(PoolingWithArgCompileInfo.CALCULATE_MODE)
    mode_str = operation.get_op_mode()
    op_pooling_mode = TilingMode.get(FORMAT_MAPPING.get(op_input_format)).get(mode_str)
    base_info = [op_cores, op_l1_size, op_ub_size, op_input_bytes, op_input_format, CEIL_MODE_MAP.get(op_ceil_mode),
                 op_pooling_mode]
    operation.add_compile_info_inner(PoolingWithArgCompileInfo.BASE_INFO, base_info)

    # POOLING_INFO
    op_window_axes = operation.get_context().get(PoolingWithArgCompileInfo.POOLING_AXES)
    op_attr_axes = operation.get_context().get(PoolingWithArgCompileInfo.ATTR_AXES)
    op_window_dimensions = operation.get_context().get(PoolingWithArgCompileInfo.POOLING_DIMENSIONS)
    op_window_strides = operation.get_context().get(PoolingWithArgCompileInfo.POOLING_STRIDES)
    op_window_dilations = operation.get_context().get(PoolingWithArgCompileInfo.POOLING_DILATIONS)
    op_window_pads = operation.get_context().get(PoolingWithArgCompileInfo.POOLING_PADS)

    op_context_axes = unify_attr_info(op_window_axes)
    op_context_attr_axes = unify_attr_info(op_attr_axes)
    op_context_dimensions = unify_attr_info(op_window_dimensions)
    op_context_strides = unify_attr_info(op_window_strides)
    op_context_dilations = unify_attr_info(op_window_dilations)
    op_context_pads = unify_attr_info(op_window_pads)
    op_context_info = [op_context_axes, op_context_attr_axes, op_context_dimensions, op_context_strides,
                       op_context_dilations, op_context_pads]
    operation.add_compile_info_inner(PoolingWithArgCompileInfo.POOLING_INFO, op_context_info)

    parameter_length_set = set()
    for single_sch in schedules:
        parameter_length_set.add(len(util.get_sch_additional_entry(single_sch, "real_outs")))

    parameter_max_length, parameter_min_length = max(parameter_length_set), min(parameter_length_set)
    if parameter_max_length == parameter_min_length:
        return

    for single_sch in schedules:
        ori_real_outs = util.get_sch_additional_entry(single_sch, "real_outs")
        if len(ori_real_outs) == parameter_max_length:
            continue

        for index in range(parameter_max_length - len(ori_real_outs)):
            fake_workspace = tvm.placeholder([], dtype="float16", name="fake_workspace_" + str(index))
            ori_real_outs.append(fake_workspace)
        util.add_sch_additional_entry(single_sch, "real_outs", ori_real_outs)

    if operation.get_op_mode() == "dynamic":
        operation.get_op_context().add_workspace("workspace_0")

    return


def _post_build():
    """
    encode normal vars in norm sch
    """
    def _name_to_int(_var_names):
        new_var_names = []
        for name in _var_names:
            if name[0] != "_":
                continue
            names = name[1:].split("_")
            if names[0] == "input":
                new_var_names.append(10000 + int(names[2]))
            elif names[0] == "dimension":
                new_var_names.append(20000 + int(names[1]))
            elif names[0] == "stride":
                new_var_names.append(30000 + int(names[1]))
            elif names[0] == "padding":
                new_var_names.append(40000 + int(names[1]))
            elif names[0] == "dilation":
                new_var_names.append(50000 + int(names[1]))
            elif names[0] == "block":
                new_var_names.append(60000 + int(names[2]))
            elif names[0] == "ub" and names[1] == "fractal":
                new_var_names.append(70000 + int(names[3]))
            elif names[0] == "ub" and names[1] == "khw":
                new_var_names.append(80000 + int(names[3]))

        return new_var_names

    normal_vars = operation.get_compile_info().get(CompileInfo.NORMAL_VARS)
    pooling_with_arg_vars = {}
    for tiling_key, var_names in normal_vars.items():
        pooling_with_arg_vars[tiling_key] = _name_to_int(var_names)
    operation.add_compile_info_inner("_pooling_with_arg_vars", pooling_with_arg_vars)


@register_build_pointcut(pattern=Pattern.POOLINGWITHARG)
def build_pointcut(func, *args, **kwargs):
    """
    build_pointcut
    :param func:
    :param args:
    :param kwargs:
    :return:
    """
    _pre_build(args[0])
    func(*args, **kwargs)
    _post_build()
