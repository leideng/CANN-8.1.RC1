# Copyright (c) Huawei Technologies Co., Ltd. 2022. All rights reserved.
#
# licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
from enum import IntEnum
from tbe import tvm
from tbe.common import platform as tbe_platform
from tbe.common.utils.errormgr import error_manager_vector
from tbe.dsl.base.operation import var
from tbe.dsl.base.operation import get_op_mode


class TilingStrategy(IntEnum):
    DB_BASE_KEY = 10000
    NON_ALIGN_BASE_KEY = 1000
    NON_ALIGN_BASE_KEY_CIN_AS_ONE = 2000
    NON_ALIGN_BASE_KEY_USE_DMA_NO_OVERLAP = 3000
    L1_BASE_KEY = 100
    WORKSPACE_BASE_KEY = 10
    UB_BASE_KEY = 1 


class YAxisOrder(IntEnum):
    N = 0
    HO = 1
    WO = 2
    KH = 3
    KW = 4
    C1 = 5
    C0 = 6


class ExtractImagePatchesWithoutCbufSchedule:
    def __init__(self, outs, tiling_case):
        self.y = outs[0]
        block_num = tbe_platform.get_soc_spec(tbe_platform.UB_SIZE) // 32 - 8  # 32KB per block, 8 block for reg_mov
        dtype_2_c0_dict = {"int8": 32, "uint8": 32, "int16": 16, "float16": 16, "float":16, "float32":16}
        data_per_block = {"int8": 32, "uint8": 32, "int16": 16, "float16": 16, "float": 8, "float32": 8}
        if self.y.dtype not in dtype_2_c0_dict:
            error_manager_vector.raise_err_specific_reson(
                "extract_image_patches",
                "excepted dtype uint8/int8/float16/float32/bfloat16"
            )
        self.c0 = dtype_2_c0_dict.get(self.y.dtype)
        self.max_data_num = data_per_block.get(self.y.dtype) * block_num
        self.x, self.x_ub, self.padding_computes, self.x_p, self.y_5hd, self.workspace, \
            self.workspace_ub, self.y_transform, self.y_ub = self.y.op.attrs["computes"]
        self.padding = self.y.op.attrs["padding"]

        self._sch = tvm.create_schedule(self.y.op)
        self._sch.tiling_key = tiling_case.key
        outs.append(self.workspace)

        # refer to extract_image_patches_without_cbuf_tilingcase.py
        self.tiling_mode = tiling_case.key % TilingStrategy.DB_BASE_KEY // TilingStrategy.NON_ALIGN_BASE_KEY
        self.multi_core_cut_axis = tiling_case.key % TilingStrategy.NON_ALIGN_BASE_KEY // TilingStrategy.L1_BASE_KEY
        self.workspace_cut_axis = tiling_case.key % TilingStrategy.L1_BASE_KEY // TilingStrategy.WORKSPACE_BASE_KEY
        self.y_cut_axis = tiling_case.key % TilingStrategy.WORKSPACE_BASE_KEY

        if tiling_case.multi_core_factor is not None:
            self.multi_core_factor = tiling_case.multi_core_factor
        else:
            self.multi_core_factor = var("multi_core_factor")
        if tiling_case.workspace_factor is not None:
            self.workspace_factor = tiling_case.workspace_factor
        else:
            self.workspace_factor = var("workspace_factor")
        if tiling_case.y_factor is not None:
            self.y_factor = tiling_case.y_factor
        else:
            self.y_factor = var("y_factor")

        self.inline_list = []
        self.db_list = []
        self.multi_core_bind_axis = None
        self.y_compute_at_axis = None
        self.y_emit_axis = None
        self.axis_group = None
        self.workspace_axis = None
        self.workspace_compute_at_axis = None
        self.workspace_emit_axis = None

    def do_schedule(self):
        self._do_inline()
        self._cut_y()
        if self.workspace not in self.inline_list:
            self._cut_workspace_4_multi_core()
            self._cut_workspace_4_ub()
        self._set_scope()
        self._do_buffer_align()
        self._do_reuse()
        self._do_db()
        self._set_buffer_size()
        self._do_compute_at()
        self._do_emit()
        self._do_axis_group()

        return self._sch

    def _do_inline(self):
        x_ub_inline = False
        x_p_inline = False

        if self.tiling_mode == 0 or \
                (self.tiling_mode == 1 and self.y_cut_axis == YAxisOrder.KW) or \
                self.workspace_cut_axis == YAxisOrder.C1:
            x_ub_inline = True
            x_p_inline = True

        if self.padding == "SAME":
            # refer to extract_image_patches_without_cbuf_tilingcase.py, tiling key meaning:
            # 12304: <without cbuf> && <c not align, db on> && <multi_core cut kh> && <y cut kw>
            # 12404: <without cbuf> && <c not align, db on> && <multi_core cut kw> && <y cut kw>
            if (self.tiling_mode == 1 and self.y_cut_axis in [1, 2, 3]) or \
                    self.workspace_cut_axis >= 2 or \
                    self._sch.tiling_key in [12304, 12404]: # see above for meaning 12304, 12404
                x_ub_inline = True
        else:
            x_p_inline = True

        if x_ub_inline:
            self._sch[self.x_ub].compute_inline()
            self.inline_list.append(self.x_ub)

        if x_p_inline:
            for _ in self.padding_computes:
                self._sch[_].compute_inline()
                self.inline_list.append(_)
            self._sch[self.x_p].compute_inline()
            self.inline_list.append(self.x_p)

        if self.workspace_cut_axis == 0:
            self._sch[self.y_5hd].compute_inline()
            self._sch[self.workspace].compute_inline()
            self._sch[self.workspace_ub].compute_inline()
            self.inline_list += [self.y_5hd, self.workspace, self.workspace_ub]

        if self.tiling_mode in [0, 1]:
            self._sch[self.y_ub].compute_inline()
            self.inline_list.append(self.y_ub)

    def _cut_y(self):
        if self.y_cut_axis == 5 or self.tiling_mode == 1:
            axis_c1, axis_c0 = self._sch[self.y].split(self.y.op.axis[5], factor=self.c0)
            y_axis = [*self.y.op.axis[:5], axis_c1, axis_c0]
        else:
            y_axis = [*self.y.op.axis[:]]

        if self.tiling_mode == 1:
            y_axis_order = [
                YAxisOrder.N,
                YAxisOrder.C1,
                YAxisOrder.HO,
                YAxisOrder.WO,
                YAxisOrder.KH,
                YAxisOrder.KW,
                YAxisOrder.C0,
            ]  # n, c1, ho, wo, kh, kw, c0
            y_axis = [y_axis[_] for _ in y_axis_order]
            self._sch[self.y].reorder(*y_axis)
        else:
            y_axis_order = [
                YAxisOrder.N,
                YAxisOrder.HO,
                YAxisOrder.WO,
                YAxisOrder.KH,
                YAxisOrder.KW,
                YAxisOrder.C1,
                YAxisOrder.C0,
            ]  # n, ho, wo, kh, kw, c1, c0
            y_axis_order = y_axis_order[:len(y_axis)]

        multi_core_cut_axis_index = y_axis_order.index(self.multi_core_cut_axis)
        multi_core_cut_axis_outer, multi_core_cut_axis_inner = \
            self._sch[self.y].split(y_axis[multi_core_cut_axis_index], factor=self.multi_core_factor)
        self.multi_core_bind_axis = \
            self._sch[self.y].fuse(*y_axis[:multi_core_cut_axis_index], multi_core_cut_axis_outer)
        self._sch[self.y].bind(self.multi_core_bind_axis, tvm.thread_axis("blockIdx.x"))

        # refer to extract_image_patches_without_cbuf_tilingcase.py, tiling key meaning:
        # 13100: <without cbuf> && <c not align, db off> && (<multi_core cut ho>
        # 13200: <without cbuf> && <c not align, db off> && <multi_core cut wo>
        if self._sch.tiling_key in [13100, 13200]: # see above for meaning 13100, 13200
            self.y_compute_at_axis = self.multi_core_bind_axis
            self.y_emit_axis = multi_core_cut_axis_inner
            self.axis_group = (self.y_emit_axis, *y_axis[multi_core_cut_axis_index + 1:])
            return

        if self.multi_core_cut_axis == self.y_cut_axis:
            self.y_compute_at_axis, self.y_emit_axis = \
                self._sch[self.y].split(multi_core_cut_axis_inner, factor=self.y_factor)
            self.axis_group = (self.y_emit_axis, *y_axis[multi_core_cut_axis_index + 1:])
        else:
            y_cut_axis_index = y_axis_order.index(self.y_cut_axis)
            self.y_compute_at_axis, self.y_emit_axis = \
                self._sch[self.y].split(y_axis[y_cut_axis_index], factor=self.y_factor)
            self.axis_group = (self.y_emit_axis, *y_axis[y_cut_axis_index + 1:])

    def _cut_workspace_4_multi_core(self):
        if self.multi_core_cut_axis == 0:
            n_o, n_i = self._sch[self.workspace].split(self.workspace.op.axis[0], factor=self.multi_core_factor)
        else:
            n_o, n_i = self.workspace.op.axis[0], 1

        if self.multi_core_cut_axis == 0:
            ho_o, ho_i = 1, self.workspace.op.axis[2]
        elif self.multi_core_cut_axis == 1:
            ho_o, ho_i = self._sch[self.workspace].split(self.workspace.op.axis[2], factor=self.multi_core_factor)
        else:
            ho_o, ho_i = self.workspace.op.axis[2], 1

        if self.multi_core_cut_axis < 2:
            wo_o, wo_i = 1, self.workspace.op.axis[3]
        else:
            wo_o, wo_i = self._sch[self.workspace].split(self.workspace.op.axis[3], factor=self.multi_core_factor)

        self.workspace_axis = (
            n_o, 
            ho_o, 
            wo_o, 
            n_i, 
            self.workspace.op.axis[YAxisOrder.HO], 
            ho_i, 
            wo_i,
            self.workspace.op.axis[YAxisOrder.KW], 
            self.workspace.op.axis[YAxisOrder.C1], 
            self.workspace.op.axis[YAxisOrder.C0]
        )

    def _cut_workspace_4_ub(self):
        '''
            refer to self._cut_workspace_4_multi_core, workspace_axis was reordered. 
            new indexes and their name are following:
                0 : n_o
                1 : ho_o 
                2 : wo_o
                3 : n_i
                4 : ho
                5 : ho_i
                6 : wo_i
                7 : kw
                8 : c1
                9 : c0
        '''
        if self.workspace_cut_axis == 1:
            c1_o, c1_i = self._sch[self.workspace].split(self.workspace_axis[4], factor=self.workspace_factor)

            self.workspace_axis = (
                self.workspace_axis[0], self.workspace_axis[1], self.workspace_axis[2],
                self.workspace_axis[3], c1_o, c1_i, self.workspace_axis[5], self.workspace_axis[6],
                self.workspace_axis[7], self.workspace_axis[8], self.workspace_axis[9]
            )

            self.workspace_compute_at_axis = c1_o
            self.workspace_emit_axis = c1_i

        elif self.workspace_cut_axis == 2:
            ho_o, ho_i = self._sch[self.workspace].split(self.workspace_axis[5], factor=self.workspace_factor)

            self.workspace_axis = (
                self.workspace_axis[0], self.workspace_axis[1], self.workspace_axis[2],
                self.workspace_axis[3], self.workspace_axis[4], ho_o, ho_i, self.workspace_axis[6],
                self.workspace_axis[7], self.workspace_axis[8], self.workspace_axis[9]
            )

            self.workspace_compute_at_axis = ho_o
            self.workspace_emit_axis = ho_i

        elif self.workspace_cut_axis == 4:
            kh_o, kh_i = self._sch[self.workspace].split(self.workspace_axis[7], factor=self.workspace_factor)

            self.workspace_axis = (
                self.workspace_axis[0], self.workspace_axis[1], self.workspace_axis[2],
                self.workspace_axis[3], self.workspace_axis[4], self.workspace_axis[5],
                kh_o, self.workspace_axis[6], kh_i, self.workspace_axis[8], self.workspace_axis[9]
            )

            self.workspace_compute_at_axis = kh_o
            self.workspace_emit_axis = self.workspace_axis[7]

        elif self.workspace_cut_axis == 3:
            wo_o, wo_i = self._sch[self.workspace].split(self.workspace_axis[6], factor=self.workspace_factor)

            self.workspace_axis = (
                self.workspace_axis[0], self.workspace_axis[1], self.workspace_axis[2],
                self.workspace_axis[3], self.workspace_axis[4], self.workspace_axis[5],
                self.workspace_axis[7], wo_o, wo_i, self.workspace_axis[8], self.workspace_axis[9]
            )

            self.workspace_compute_at_axis = wo_o
            self.workspace_emit_axis = wo_i

        else:
            kw_o, kw_i = self._sch[self.workspace].split(self.workspace_axis[8], factor=self.workspace_factor)

            self.workspace_axis = (
                self.workspace_axis[0], self.workspace_axis[1], self.workspace_axis[2],
                self.workspace_axis[3], self.workspace_axis[4], self.workspace_axis[5],
                self.workspace_axis[6], self.workspace_axis[7], kw_o, kw_i, self.workspace_axis[9]
            )

            self.workspace_compute_at_axis = kw_o
            self.workspace_emit_axis = kw_i

        workspace_axis_ = []
        for _ in self.workspace_axis:
            if _ != 1:
                workspace_axis_.append(_)

        self._sch[self.workspace].reorder(*workspace_axis_)

    def _set_scope(self):
        for _ in [self.x_ub, *self.padding_computes, self.x_p, self.y_5hd,
                  self.workspace_ub, self.y_transform, self.y_ub]:
            if _ not in self.inline_list:
                self._sch[_].set_scope(tbe_platform.scope_ubuf)

    def _do_buffer_align(self):
        self._sch[self.y_transform].buffer_align((1, 1), (1, 1), (1, 1), (1, 1), (1, 1), (1, 1), (1, self.c0))

    def _do_reuse(self):
        if self.x_p not in self.inline_list:
            for _ in self.padding_computes:
                self._sch[_].reused_by(self.x_p)

        if self.y_ub not in self.inline_list:
            self._sch[self.y_transform].reused_by(self.y_ub)

    def _do_db(self):
        if self.tiling_mode == 3:
            return

        if self.workspace not in self.inline_list:
            self._sch[self.workspace_ub].double_buffer()
            self.db_list += [self.workspace_ub]

        self._sch[self.y_transform].double_buffer()
        self.db_list.append(self.y_transform)

        if self.y_ub not in self.inline_list:
            self._sch[self.y_ub].double_buffer()

        # to reduce .o size
        if self._sch.tiling_key in [12212, 12112, 12111, 12022, 12122, 12214]:
            return

        if self.x_ub not in self.inline_list:
            self._sch[self.x_ub].double_buffer()
            self.db_list.append(self.x_ub)
        elif self.x_p not in self.inline_list:
            for _ in self.padding_computes:
                self._sch[_].double_buffer()
            self._sch[self.x_p].double_buffer()
            self.db_list.append(self.x_p)

        if self.workspace not in self.inline_list:
            self._sch[self.y_5hd].double_buffer()
            self.db_list += [self.y_5hd]

    def _set_buffer_size(self):
        if self.workspace in self.inline_list:
            max_node_num = (self.x_ub not in self.inline_list) + (self.x_ub in self.db_list) + \
                           (self.x_p not in self.inline_list) + (self.x_p in self.db_list) + \
                           (self.y_transform not in self.inline_list) + (self.y_transform in self.db_list)

            for _ in [self.x_ub, *self.padding_computes, self.x_p, self.y_transform, self.y_ub]:
                if _ not in self.inline_list:
                    self._sch[_].set_buffer_size(self.max_data_num // max_node_num)

        else:
            max_node_num = (self.x_ub not in self.inline_list) + (self.x_ub in self.db_list) + \
                           (self.x_p not in self.inline_list) + (self.x_p in self.db_list) + \
                           (self.y_5hd not in self.inline_list) + (self.y_5hd in self.db_list)

            for _ in [self.x_ub, *self.padding_computes, self.x_p, self.y_5hd]:
                if _ not in self.inline_list:
                    self._sch[_].set_buffer_size(self.max_data_num // max_node_num)

            max_node_num = (self.workspace_ub not in self.inline_list) + (self.workspace_ub in self.db_list) + \
                           (self.y_transform not in self.inline_list) + (self.y_transform in self.db_list)

            for _ in [self.workspace_ub, self.y_transform, self.y_ub]:
                if _ not in self.inline_list:
                    self._sch[_].set_buffer_size(self.max_data_num // max_node_num)

    def _do_compute_at(self):
        if self.workspace not in self.inline_list:
            self._sch[self.workspace].compute_at(self._sch[self.y], self.multi_core_bind_axis)

            for _ in [self.x_ub, *self.padding_computes, self.x_p, self.y_5hd]:
                if _ not in self.inline_list:
                    self._sch[_].compute_at(self._sch[self.workspace], self.workspace_compute_at_axis)

        else:
            for _ in [self.x_ub, *self.padding_computes, self.x_p, self.y_5hd]:
                if _ not in self.inline_list:
                    self._sch[_].compute_at(self._sch[self.y], self.y_compute_at_axis)

        for _ in [self.workspace_ub, self.y_transform, self.y_ub]:
            if _ not in self.inline_list:
                self._sch[_].compute_at(self._sch[self.y], self.y_compute_at_axis)

    def _do_emit(self):
        if self.x_ub not in self.inline_list:
            self._sch[self.x_ub].emit_insn(self.x_ub.op.axis[0], "dma_copy")

        if self.x_p not in self.inline_list:
            for _ in self.padding_computes:
                self._sch[_].emit_insn(_.op.axis[0], "dma_copy", {"split_select": 1})
            self._sch[self.x_p].emit_insn(self.x_p.op.axis[0], "dma_copy")

        if self.workspace not in self.inline_list:
            if self.y.dtype in ("float16", "float32", "float") and self.workspace_cut_axis != 5:
                self._sch[self.y_5hd].emit_insn(self.y_5hd.op.axis[0], "vector_adds")
            else:
                self._sch[self.y_5hd].emit_insn(self.y_5hd.op.axis[0], "dma_copy")
            self._sch[self.workspace].emit_insn(self.workspace_emit_axis, "dma_copy")
            self._sch[self.workspace_ub].emit_insn(self.workspace_ub.op.axis[0], "dma_copy")

        if self.y.dtype in ("float16", "float32", "float") and self.workspace in self.inline_list and \
                (self.x_ub not in self.inline_list or self.x_p not in self.inline_list):
            self._sch[self.y_transform].emit_insn(self.y_transform.op.axis[0], "vector_adds")
        else:
            self._sch[self.y_transform].emit_insn(self.y_transform.op.axis[0], "dma_copy")

        if self.y_ub not in self.inline_list:
            self._sch[self.y_ub].emit_insn(self.y_ub.op.axis[0], "data_mov")

        self._sch[self.y].emit_insn(self.y_emit_axis, "dma_copy")

    def _do_axis_group(self):
        if get_op_mode() == "static":
            return

        if self.tiling_mode == 1:
            return

        group_id = tvm.call_extern("int32", "axis_group", 0, "overwrite")
        for _ in self.axis_group:
            self._sch[self.y].pragma(_, "axis_group", group_id)
