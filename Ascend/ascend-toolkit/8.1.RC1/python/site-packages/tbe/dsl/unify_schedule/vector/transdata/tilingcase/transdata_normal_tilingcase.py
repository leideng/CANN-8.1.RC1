#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright(C) 2022. Huawei Technologies Co., Ltd. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
Transdata Schedule Remake stage 1 - Tilingcase
"""
from copy import deepcopy
from tbe.common.utils import op_tiling
from tbe.common.utils.errormgr import get_error_message
from tbe.common.platform.platform_info import get_soc_spec
from tbe.dsl.base.operation import get_context
from tbe.dsl.base.operation import get_compile_info, add_compile_info_inner
from tbe.dsl.unify_schedule.util import shape_to_list
from tbe.dsl.unify_schedule.constants import CompileInfo
from tbe.dsl.classifier.transdata.constants import FORMAT, UB_CATEGORY_COUNT
from tbe.dsl.classifier.transdata.constants import GENERAL_BRANCH, DATA_MOVE_BRANCH
from tbe.dsl.classifier.transdata.constants import intrinsic_check_support
from tbe.dsl.classifier.transdata.constants import Tiling

from ..common.graph.transdata_graph_info import ComputeGraphInfo
from .transdata_normal_key import TransdataCase, TransdataSplit
from ..transdata_entrance import Collecting


class TilingT0(Collecting, TransdataSplit):

    def __init__(self, outs, option):
        TransdataSplit.__init__(self, outs, option)
        self.tiling_case_list = []
        self.block = int(get_soc_spec("ubblock_size"))

    @classmethod
    def get_tiling(cls):
        return Tiling.T0

    @staticmethod
    def apply_ub_info(case_list):
        """
        Return all possible UBSize for tiling.
        case_list: list of all possible tiling_cases.
        ub_info: possible UBSize.
        """
        ub_info = [[-1] for i in range(UB_CATEGORY_COUNT)]
        for i in case_list:
            ub_info[i.ub_category] = i.tensor_ub_size_list

        if "_ub_info" in get_compile_info().keys():
            pre_info = get_compile_info().get("_ub_info")
            for k, v in enumerate(ub_info):
                if pre_info[k] == [-1, ] and v != [-1, ]:
                    pre_info[k] = v
            ub_info = pre_info
        add_compile_info_inner("_ub_info", ub_info)

    def do_tiling_case(self):
        """
        do tiling case
        """
        outs = list(self.outs) if isinstance(self.outs, (list, tuple)) else [self.outs]
        self.graph_info = ComputeGraphInfo(outs)
        current_compute = get_context().get_current_compute()
        current_compute.add("_compute_graph_info", self.graph_info)

        # while src-tensor is fp32, schedule would reinterpret it by fp16-mode,
        # ori-bit is size of fp32-element.
        self.bit = current_compute.get("_bit")
        self.ori_bit = current_compute.get("_ori_bit")
        self.is_const = current_compute.get("_const_model")

        if self.is_const:
            self.align_size = self.block // self.bit
            self.tiling_case_list += self.calc_const_tiling_case()
        else:
            self.align_size = self.block // self.ori_bit
            self.tiling_case_list += self.calc_tiling_case()
            self.apply_dynamic_compile_info()

        return self.tiling_case_list

    def calc_tiling_case(self, ):
        def _base_case():
            length = len(self.graph_info.tiling_tensor.shape)
            result = self.split(length, self.graph_info.permute)
            result = self.base_filter(result)
            return self.base_generation(result)

        def _data_move_case():
            length = len(list(self.graph_info.input_tensor_set)[0].shape)
            result = self.split(length, self.graph_info.permute)
            result = self.data_move_filter(result)
            return self.data_move_generation(result)

        def _borrow_n_h_case():
            length = len(self.graph_info.tiling_tensor.shape)
            perm = [int(x) for x in self.graph_info.tiling_tensor.op.attrs["permute"]]
            result = self.split(length, perm)
            result = self.borrow_filter(result)
            return self.borrow_generation(result)

        def _borrow_x_case():
            # work for last-transpose + B32
            length = len(self.graph_info.tiling_tensor.shape)
            perm = [int(x) for x in self.graph_info.tiling_tensor.op.attrs["permute"]]
            result = self.split(length, perm)
            result = self.borrow_x_filter(result)
            return self.borrow_x_generation(result)

        def _add_fuse_case(cases):
            return self.add_fuse_generation(deepcopy(cases))

        if self.graph_info.category in GENERAL_BRANCH:
            out = _base_case()
        elif self.graph_info.category in DATA_MOVE_BRANCH:
            out = _data_move_case()
        else:
            out = _borrow_x_case() if self.graph_info.is_last_transpose else _borrow_n_h_case()

        return out + _add_fuse_case(out)

    def calc_const_tiling_case(self):
        # ConstTiling
        input_tensor = list(self.graph_info.input_tensor_set)[0]
        output_tensor = list(self.graph_info.output_tensor_set)[0]
        input_shape = shape_to_list(input_tensor.shape)
        output_shape = shape_to_list(output_tensor.shape)
        src_format, dst_format = get_context().get("_transdata_format")
        inputs = [{"shape": input_shape, "dtype": input_tensor.dtype, "format": src_format}]
        outputs = [{"shape": output_shape, "dtype": output_tensor.dtype, "format": dst_format}]

        # ConstModel need Tiling to convert ub_size from different choose.
        cst_case = TransdataCase(self.graph_info)
        ComputeGraphInfo.set_buffer_size(self.graph_info, cst_case)
        self.apply_info([cst_case], is_const_compile=True)
        run_info = op_tiling.do_op_tiling("Transdata", get_compile_info(), inputs, outputs)
        tiling_data = op_tiling.decode(run_info["tiling_data"], FORMAT)
        return self.assign_data(cst_case, tiling_data)

    def apply_dynamic_compile_info(self):
        # Interface
        if not get_compile_info():
            dict_args = {"errCode": "E90003", "detailed_cause": "pre_compile_info is null"}
            raise RuntimeError(dict_args, get_error_message(dict_args))
        self.apply_info(self.tiling_case_list)

    def apply_info(self, case_list, is_const_compile=False):
        # Interface
        self.apply_common_info(is_const_compile)
        self.apply_ub_info(case_list)

    def apply_common_info(self, is_const_compile):
        # Common compileInfo
        is_forward = int(self.graph_info.is_forward)
        align_size = self.align_size
        core_num = get_soc_spec("CORE_NUM")
        is_const = int(self.is_const)
        is_const_compile = int(is_const_compile)
        support_b32_vnc = intrinsic_check_support()
        common_info = [is_forward, align_size, core_num, is_const, is_const_compile, support_b32_vnc, self.block]
        common_info.extend(get_context().get("_transdata_check"))
        add_compile_info_inner("_common_info", common_info)

    def assign_data(self, cst_case, tiling_data):
        # assign data for const case.
        cst_case.fuse_mode = tiling_data["fuse_mode"]
        cst_case.ub_category = tiling_data["ub_category"]
        cst_case.shape_type = tiling_data["shape_type"]
        cst_case.block_split_idx = tiling_data["block_split_idx"]
        cst_case.ub_split_first_idx = tiling_data["ub_split_first_idx"]
        cst_case.ub_split_second_idx = tiling_data["ub_split_second_idx"]
        cst_case.block_factor = tiling_data["block_factor"]
        cst_case.ub_first_factor = tiling_data["ub_first_factor"]
        cst_case.ub_second_factor = tiling_data["ub_second_factor"]
        cst_case.transpose_work = tiling_data["transpose_work"]
        cst_case.last_dim_type = tiling_data["last_dim_type"]
        cst_case.avoid_bank_conflict = tiling_data["avoid_bank_conflict"]

        self.apply_info([cst_case], is_const_compile=False)
        block_dims = get_compile_info().get(CompileInfo.CONST_BLOCK_DIMS)
        if block_dims is None:
            block_dims = {}
            add_compile_info_inner(CompileInfo.CONST_BLOCK_DIMS, block_dims)
        block_dims[str(cst_case.tiling_key)] = tiling_data["block_dim"]
        return [cst_case, ]
