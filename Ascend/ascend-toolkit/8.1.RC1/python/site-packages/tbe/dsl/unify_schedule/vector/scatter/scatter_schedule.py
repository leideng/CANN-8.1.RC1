#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
scatter schedule entry
"""
from typing import Any

from tbe.dsl.base import operation

from ...constants import ScatterPattern
from ...constants import Pattern
from ...schedule import Schedule

from .scatter_schedule_atomic import ScatterAtomicSchedule
from .scatter_schedule_without_cached import ScatterScheduleWithoutCached
from .scatter_schedule_cached_var import ScatterCacheSchedule

DEFAULT = "default"


# 'pylint: disable=R0902, R0903
class EntryScatterSchedule(Schedule):
    """
    scatter schedule
    """

    def __init__(self, outs, tiling_case):
        self._out_tensor = outs[0]
        self._tiling_case = tiling_case
        self._is_atomic = self._tiling_case.get("is_atomic", False)
        self._is_sparse_cache = self._tiling_case.get("is_sparse_cache", False)
        self._op_type = self._tiling_case.get("op_type")

    @classmethod
    def get_instance(cls, outs, tiling_case):  # type: (list[Any], Any) -> "Schedule"
        return cls(outs, tiling_case)

    @classmethod
    def get_supported_soc(cls):  # type: () -> list[str]
        return [DEFAULT]

    @classmethod
    def get_supported_pattern(cls):  # type: () -> list[str]
        return [Pattern.SCATTER]

    @classmethod
    def get_supported_sub_pattern(cls):  # type: () -> list[str]
        return [ScatterPattern.NORMAL_SCHEDULE]

    def do_schedule(self):
        """
        schedule body
        :return:
        """
        if self._is_atomic:
            atomic_sch = ScatterAtomicSchedule([self._out_tensor], self._tiling_case)
            real_sch = atomic_sch.do_schedule()

        else:
            if not self._is_sparse_cache and self._op_type != "scatter_nd":
                sparse_cache_sch = ScatterCacheSchedule([self._out_tensor], self._tiling_case)
                real_sch = sparse_cache_sch.do_schedule()
            else:
                base_sch = ScatterScheduleWithoutCached([self._out_tensor], self._tiling_case)
                real_sch = base_sch.do_schedule()

        return real_sch
