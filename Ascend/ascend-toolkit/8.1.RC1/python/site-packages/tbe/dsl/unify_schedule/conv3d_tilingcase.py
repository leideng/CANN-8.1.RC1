#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
conv3d tiling case
"""

import copy
import math
import json
from collections import OrderedDict
from itertools import product
from functools import reduce

from tbe import tvm
from tbe.common import platform as tbe_platform
from tbe.common.platform import platform_info as tbe_platform_info
from tbe.common.tiling import get_tiling
from tbe.common.context import get_context
from tbe.common.utils import log
from tbe.dsl.base.operation import add_compile_info
from tbe.dsl.base.operation import get_compile_info
from tbe.dsl.base.operation import get_op_context
from tbe.dsl.base.operation import register_tiling_case
from tbe.dsl.base.operation import register_build_pointcut
from tbe.dsl.base.operation import get_context as op_get_context
from tbe.dsl.base.operation import get_te_var
from tbe.dsl.base.operation import in_dynamic
from tbe.dsl.compute import util as te_util
from tbe.dsl.compute.conv3d_compute import Conv3DParam
from tbe.dsl.static_schedule.conv_util import get_fixpipe_tensor
from tbe.dsl.static_schedule.conv_util import update_info_dict
from tbe.dsl.static_schedule.conv3d_schedule import AutoScheduleOp
from tbe.dsl.static_schedule.util import CalculateMultiUB
from tbe.dsl.unify_schedule.constants import DTYPE_BYTE_MAPPING
from tbe.dsl.unify_schedule.constants import DTYPE_BIT_MAPPING
from tbe.tvm.ir import PrimExpr

from .cube_tilingcase import CubeStaticTilingOp
from .cube_tilingcase import CubeTilingOp
from .cube_tilingcase import get_op_tiling
from .cube_tilingcase import TilingSelection
from .cube_tilingcase import TilingUtils as utils
from .constants import Pattern


H_RANGE = 4096
W_RANGE = 4096
W_DELTA = 1
D_DELTA = 1
H_LEN = 400
W_LEN = 400
D_LEN = 400
VALID_TILING_NUM = 32
N_BASE = 2
_CONV_NUM = 5
_TILING_FLOAT16_MKN = 16


SHAPE_VARS = ("batch_n", "fmap_c", "fmap_d", "fmap_h", "fmap_w", "c_out", "d_out", "h_out", "w_out")
ATTR_VARS = ("kernel_d", "kernel_h", "kernel_w", "fmap_c1", "c1_out", "stride_d", "stride_h", "stride_w", "padf",
    "padb", "padu", "padd", "padl", "padr", "dilation_d", "dilation_h", "dilation_w",
    "cin1_g", "cout1_g", "real_g", "mag_factor", "hf32_flag")
TILING_VARS = ("group_dim", "batch_dim", "d_dim", "batch_dout_single_core", "n_single_core", "n_dim", "n_bl1",
    "n_ub_l0_time", "cub_n1", "m_dim", "m_single_core", "m_al1", "m_l0", "k_l0", "kal1_factor", "kbl1_factor",
    "kal0_factor", "kbl0_factor", "kl1_times", "al1_bound", "bt_bound", "load3d_special")


class TilingIdOffset():
    # tiling_id offset
    def __init__(self):
        self.pad_greater_than_filter_offset = 17
        self.db_al1_offset = 16
        self.db_bl1_offset = 15
        self.db_l0c_offset = 14
        self.db_cub_offset = 13
        self.abkl1_attach_flag_offset = 11
        self.al1_attach_flag_offset = 9
        self.bl1_attach_flag_offset = 7
        self.bl0_attach_flag_offset = 6
        self.cycle_buffer_flag_offset = 5
        self.load3d_special_flag_offset = 4
        self.load_mode_offset = 2
        self.binary_mode_offset = 0


def _parse_fuzz_build_range(info_list):
    """
    parse multiple range segment from json string

    Notice
    ----------
    for conv3d only parse input range

    Parameters
    ----------
    info_list: list support info
        [{
            "inputs": [{
                "index": 0,
                "tensor": [{
                    "range": [
                        [1, 1],
                        [8, 15],
                        [32, 63],
                        [32, 63],
                        [64, 64]
                    ],
                    "shape": [-1, -1, -1, -1, 64]
                }]
            }]
        }]

    Returns
    -------
    range_list: list of 5d range
    """
    target_index = 0
    range_list = []
    for item in info_list:
        inputs = item.get("inputs")
        for input_tensor in inputs:
            invalid = (not isinstance(input_tensor, dict)) or input_tensor.get("index") != target_index
            if invalid:
                continue
            input_range = input_tensor.get("tensor")[0].get("range")
            if input_range:
                for axis_range in input_range:
                    invalid = (not isinstance(axis_range, list)) \
                              or len(axis_range) != 2 \
                              or axis_range[0] > axis_range[1] \
                              or axis_range[0] < 1
                    if invalid:
                        raise RuntimeError("invalid range {}".format(str(axis_range)))
                range_list.append(input_range)
    return range_list


def gen_support_info(range_x):
    """
    kernel list support info part

    Notice
    ------
    only need to set inputs with range

    Parameters
    ----------
    range_x: list
    -   input x range

    Returns
    -------
    support_info: dict
    """
    support_info = {}
    inputs = []
    item = {}
    item["index"] = 0
    item["tensor"] = []
    tensor_info = {}
    ori_tensors = Conv3DParam.para_dict.get("ori_tensors")
    ori_tensors_input = ori_tensors.get("fmap")
    ori_shape = ori_tensors_input.get("ori_shape")
    tensor_info["shape"] = ori_shape
    x_format = ori_tensors_input.get("ori_format")
    range_valid = [[0, 0]] * 5
    # range_x : NDHW, @see get_tiling_range
    range_valid[x_format.find("N")] = list(range_x[0])
    range_valid[x_format.find("D")] = list(range_x[1])
    range_valid[x_format.find("H")] = list(range_x[2])
    range_valid[x_format.find("W")] = list(range_x[3])
    range_valid[x_format.find("C")] = [ori_shape[x_format.find("C")]] * 2
    tensor_info["range"] = range_valid
    item.get("tensor").append(tensor_info)
    inputs.append(item)
    support_info["inputs"] = inputs
    return support_info


def add_covered_shape_range(compile_info):
    """
    tiling_case func for dynamic shape conv3d

    Parameters
    ----------
    compile_info: dict
    -   tiling range info

    Returns
    -------
    info_list: dict
    -   support info and compile info pair
    max_kernel_id: int
    -   last kernel id
    """
    id_list = list(compile_info["block_dim"].keys())
    id_list.sort()
    te_vars = []
    info_list = []
    for cpt in op_get_context().get_computes():
        te_vars += cpt.get_vars()
    var_list = [var.get_name() for var in te_vars]
    for kernel_id, _ in compile_info["block_dim"].items():
        new_compile = compile_info.copy()
        for keys, value in new_compile.items():
            if isinstance(value, dict):
                value = {} if value.get(kernel_id) is None else {kernel_id: value[kernel_id]}
                new_compile[keys] = value
        new_compile["kernelId"] = kernel_id
        new_compile["_vars"] = {kernel_id: var_list}
        range_x = new_compile["repo_range"].get(kernel_id) or new_compile["cost_range"].get(kernel_id)
        new_range = [range_x[:2], range_x[2:4], range_x[4:6], range_x[6:8]]
        new_support = gen_support_info(new_range)
        info_list.append({"supportInfo": new_support, "compileInfo": new_compile})
    return info_list, id_list[-1]


@register_build_pointcut(pattern=Pattern.CONV3D)
def build_pointcut_conv3d(func, *args, **kwargs):
    """
    kernel info process before build

    Notice
    ------
    kernel_info: dict with support info and compile info
    -   {
    -       "supportInfo": {
    -           "inputs": [{
    -               "index": 0,
    -               "tensor": [{
    -               "range": [
    -                   [1, 1],
    -                   [8, 15],
    -                   [32, 63],
    -                   [32, 63],
    -                   [64, 64]
    -               ],
    -               "shape": [-1, -1, -1, -1, 64]
    -               }]
    -           }]
    -       },
    -       "compileInfo": {
    -           "_pattern": "conv3d",
    -           "tiling_type": "dynamic_tiling",
    -           "repo_seeds": {},
    -           "repo_range": {},
    -           "cost_range": {},
    -           "block_dim": {
    -               1: 32
    -           },
    -           "_vars": {
    -               0: ["batch_n", "fmap_d", "d_out", "fmap_h", "h_out", "fmap_w", "w_out"]
    -           }
    -       }
    -   }

    Parameters
    ----------
    func: funtions
    -   build process
    args: list
    -   function input args
    kwargs: dict
    -   function input args and value

    Returns
    -------
    None
    """
    fuzz_build = (get_context().get_build_type() == "fuzzily_build")
    if fuzz_build:  # set kernel info
        info_list, max_kernel_id = add_covered_shape_range(get_compile_info())
        get_context().add_build_json_result("kernelList", info_list)
        get_context().add_build_json_result("maxKernelId", max_kernel_id)
    func(*args, **kwargs)


def query_tiling_cases(tgt_list, conv_info, max_kernel_id, var_names):
    """
    do query tiling cases for dynamic shape conv3d

    Parameters
    ----------
    tgt_list : list of dict, each dict for a dynamic dim
    conv_info: tiling_info_dict
    max_kernel_id: the max value of kernel id
    var_names: keys of dynamic dims

    Returns
    -------
    list of dict, each dict for a tiling case
    """
    all_compile_info = {}
    tiling_cases = []
    for tgt in tgt_list:
        new_conv_info = copy.deepcopy(conv_info)
        tiling_op = Conv3dTiling(new_conv_info, Conv3DParam.var_map)
        selector = TilingSelection(tiling_op, max_kernel_id)
        tiling_cases += selector.calc_tiling(tgt, var_names)
        fuzz_build = (get_context().get_build_type() == "fuzzily_build")
        if fuzz_build:
            tgt_ndhw = []
            for var_name in var_names:
                tgt_ndhw.extend(tgt[var_name])
            current_info = get_compile_info().copy()
            id_list = list(current_info["block_dim"].keys())
            id_list.sort()
            max_kernel_id = id_list[-1] + 1
            for range_key in ["repo_range", "cost_range"]:
                if isinstance(current_info.get(range_key), dict):
                    for kernel_id, range_x in current_info[range_key].items():
                        new_range = []
                        for index, dim_value in enumerate(range_x):
                            if index not in (0, 2, 4, 6):
                                new_range.append(tgt_ndhw[index] if dim_value > tgt_ndhw[index] else dim_value)
                            else:
                                new_range.append(tgt_ndhw[index] if dim_value < tgt_ndhw[index] else dim_value)
                        current_info[range_key][kernel_id] = new_range
            if all_compile_info:
                for key, value in current_info.items():
                    if isinstance(all_compile_info.get(key), dict) and isinstance(value, dict):
                        new_item = all_compile_info.get(key)
                        new_item.update(value)
                        all_compile_info[key] = new_item
                        add_compile_info(key, all_compile_info.get(key))
            else:
                all_compile_info = current_info
        if not Conv3DParam.binary_mode:
            group_dict = Conv3DParam.tensor_map.get("group_dict")
            fmap_cin1_g = utils.icd(group_dict["cin_ori"], new_conv_info.get("a_shape")[-1])
            add_compile_info("fmap_c1", fmap_cin1_g)
    return tiling_cases


def get_tiling_cases(tgt_list, conv_info, var_names):
    """
    get tiling cases for dynamic shape conv3d

    Parameters
    ----------
    tgt_list : list of dict, each dict for a dynamic dim
    conv_info: tiling_info_dict
    var_names: keys of dynamic dims

    Returns
    -------
    list of dict, each dict for a tiling case
    """
    para_dict = Conv3DParam.para_dict
    max_kernel_id = None
    fuzz_build = (get_context().get_build_type() == "fuzzily_build")
    if fuzz_build:
        missing_support_info = get_context().get_addition("missing_support_info")
        if len(missing_support_info) > 0:
            missing_support_list = _parse_fuzz_build_range(json.loads(missing_support_info))
            if len(missing_support_list) > 0:
                tgt_list.clear()  # clear the old data and only deal with fuzz shape range
                fmap_ori_format = para_dict.get("ori_tensors").get("fmap").get("ori_format")
                pos_list = [fmap_ori_format.find("N"),
                            fmap_ori_format.find("D"),
                            fmap_ori_format.find("H"),
                            fmap_ori_format.find("W")]
                for item in missing_support_list:
                    if item:
                        fuzz_area = {}
                        for var, index in zip(var_names, pos_list):
                            fuzz_area[var] = tuple(item[index])
                        tgt_list.append(fuzz_area)
        kernel_id = get_context().get_addition("max_kernel_id")
        valid = isinstance(kernel_id, int) and kernel_id > -2
        if valid:
            max_kernel_id = kernel_id + 1

    tiling_cases = query_tiling_cases(tgt_list, conv_info, max_kernel_id, var_names)
    return tiling_cases


# noinspection PyUnusedLocal
@register_tiling_case(pattern=Pattern.CONV3D)
def calc_conv3d(outs, option=None):
    """
    tiling_case func for dynamic shape conv3d

    Parameters
    ----------
    outs: tvm tensor or list of tvm tensor, results for tvm compute

    Returns
    -------
    list of dict, each dict for a tiling case
    """
    var_names = ('batch_n', 'fmap_d', 'fmap_h', 'fmap_w')
    tgt_list = []
    tgt_area = {}
    conv_info = Conv3DParam.tiling_info_dict
    shape_dict = {"batch_n": conv_info.get("a_shape")[0],
                  "fmap_d": conv_info.get("a_shape")[1],
                  "fmap_h": conv_info.get("a_shape")[3],
                  "fmap_w": conv_info.get("a_shape")[4]}
    if not in_dynamic():
        tiling_conv3d = Conv3dStaticTiling(outs)
        if tiling_conv3d.in_dtype in ("float32", "bfloat16"):
            tiling_conv3d.res.op.attrs["is_dynamic_constantization"] = True
        else:
            tiling_conv3d.get_static_tiling()
        return [{"tiling_strategy": tiling_conv3d.tiling}]

    conv_info["dynamic_shape_flag"] = True
    for var_name in var_names:
        if Conv3DParam.binary_mode:
            tgt_area[var_name] = (1, None)
        elif get_te_var(var_name):
            tgt_area[var_name] = tuple(get_te_var(var_name).get_bound())
        else:
            tgt_area[var_name] = (int(shape_dict.get(var_name)), int(shape_dict.get(var_name)))

    tgt_list.append(tgt_area) # deal with dynamic shape range by default

    tiling_cases = get_tiling_cases(tgt_list, conv_info, var_names)
    # dynaminc constantization for static shape scene
    context = get_op_context()
    if context.get_addition("is_dynamic_constantization"):
        tiling_data_key = SHAPE_VARS + ATTR_VARS + TILING_VARS
        tiling_data, tiling_key = get_op_tiling("Conv3D", tiling_data_key)
        dyn_constant_tiling = Conv3dTiling.get_dyn_constant_tiling(
            tiling_cases, tiling_data, tiling_key, "Conv3D")
        return dyn_constant_tiling
    return tiling_cases


class Conv3dTiling(CubeTilingOp):
    """
    conv3d tiling class
    """
    def __init__(self, tiling_info, var_map):
        super().__init__(tiling_info, var_map)
        self.a_info = tiling_info['a_shape']
        self.b_info = tiling_info['b_shape']
        self.c_type = tiling_info["c_dtype"]
        self._get_calc_info()
        self.key = 'A_shape'
        self.op_type = "convolution_3d"
        self.var_map = var_map
        self.binary_mode = Conv3DParam.binary_mode
        self.load_mode = Conv3DParam.load_mode
        self.cycle_buffer_flag = Conv3DParam.cycle_buffer_flag
        self.support_l0c2out = tbe_platform_info.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out")
        op_get_context().add("_use_cache_tiling", bool(self.binary_mode))

    @staticmethod
    def _get_choice_list():
        (pad_greater_than_filter, al1_pb, bl1_pb, l0c_pb, c_ub_pb, abkl1_attach, al1_attach_flag, bl1_attach_flag,
         bl0_attach_flag, load3d_special_flag) = (
            [0, 1],
            [utils.DB_OFF, utils.DB_ON],
            [utils.DB_OFF, utils.DB_ON],
            [utils.DB_OFF, utils.DB_ON],
            [utils.DB_OFF, utils.DB_ON],
            [utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL, utils.ATTACH_LESS],
            [utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL, utils.ATTACH_LESS],
            [utils.ATTACH_FULL_LOAD, utils.ATTACH_EQUAL, utils.ATTACH_LESS, utils.NO_ATTACH],
            [0, 1],
            [0, 1])

        choice_list = list(
            product(pad_greater_than_filter, al1_pb, bl1_pb, l0c_pb, c_ub_pb, abkl1_attach, al1_attach_flag,
                    bl1_attach_flag, bl0_attach_flag, load3d_special_flag))

        return choice_list

    def get_repo_tiling(self):
        tiling_list = get_tiling(self.tiling_info)
        res_list = []
        for tiling in tiling_list:
            t_padh, t_padt, t_padu, t_padd, t_padl, t_padr = tiling.get('pad')
            t_out_d = (tiling.get('A_shape')[1] + t_padh + t_padt - self.dilation_d * (self.k_d - 1) - 1) \
                      // self.stride_d + 1
            t_out_h = (tiling.get('A_shape')[3] + t_padu + t_padd - self.dilation_h * (self.k_h - 1) - 1) \
                      // self.stride_h + 1
            t_out_w = (tiling.get('A_shape')[4] + t_padl + t_padr - self.dilation_w * (self.k_w - 1) - 1) \
                      // self.stride_w + 1
            out_d = self._get_output_d(tiling.get('A_shape')[1])
            out_h = self._get_output_h(tiling.get('A_shape')[3])
            out_w = self._get_output_w(tiling.get('A_shape')[4])
            if out_d == t_out_d and out_h == t_out_h and out_w == t_out_w:
                res_list.append(tiling)
        return res_list

    def get_costmodel_tiling(self, shape):
        """
        get tiling using cost model

        Parameters
        ----------
        shape: specified shape to get tiling

        Returns
        -------
        tiling: tiling retrieved by cost model
        """

        if 'batch_n' in self.var_map:
            self.a_info[0] = shape if isinstance(shape, int) else shape[0]
        if 'fmap_d' in self.var_map:
            self.a_info[1] = shape[1]
        if 'fmap_h' in self.var_map:
            self.a_info[3] = shape[2]
        if 'fmap_w' in self.var_map:
            self.a_info[4] = shape[3]
        if self.pad_mode == "VAR":
            self.tiling_info["pad"] = \
                self._calc_pads(shape[1], shape[2], shape[3])
        self.tiling_info["tiling_type"] = "cost_model_tiling"

        tiling = get_tiling(self.tiling_info)[0]
        return tiling

    def get_default_tiling(self):
        """
        get default tiling

        Parameters
        ----------
        None

        Returns
        -------
        default tiling
        """

        def _handle_block_dim():
            """
            avoid cyclomatic complexity, handle block_dim
            """
            tiling["block_dim"] = [1, 1, 1, 1]
            device_core_num = tbe_platform_info.get_soc_spec("CORE_NUM")
            if (self.a_info[0] > 1) and (device_core_num > 1):
                if self.a_info[0] <= device_core_num:
                    tiling.get("block_dim")[0] = self.a_info[0]
                else:
                    for i in range(device_core_num, 0, -1):
                        if self.a_info[0] % i == 0:
                            break
                    tiling.get("block_dim")[0] = i
            else:
                tiling.get("block_dim")[0] = 1

        tiling = {}
        tiling_m = 1
        tiling_k = 1
        tiling_n = 1
        tiling["AL1_shape"] = [1]
        tiling["BL1_shape"] = None
        tiling["AL0_matrix"] = [tiling_m, tiling_k, utils.FP16_M, utils.FP16_K]
        tiling["BL0_matrix"] = [tiling_k, tiling_n, utils.FP16_N, utils.FP16_K]
        tiling["CL0_matrix"] = [tiling_n, tiling_m, utils.FP16_M, utils.FP16_N]
        tiling["L0C_OUTPUT_matrix"] = [tiling_n, tiling_m, utils.FP16_M, utils.FP16_N]
        tiling["AUB_shape"] = tiling.get("AL1_shape")
        tiling["BUB_shape"] = None
        tiling["manual_pingpong_buffer"] = {'AL1_pbuffer': 1, 'BL1_pbuffer': 1,
                                            'AL0_pbuffer': 1, 'BL0_pbuffer': 1,
                                            'CL0_pbuffer': 1, 'L0C_OUTPUT_pbuffer': 1, 'UBG_pbuffer': 1}
        tiling["A_overhead_opt_flag"] = False
        tiling["B_overhead_opt_flag"] = False
        tiling["CUB_channel_wise_flag"] = True
        tiling["n_bef_batch_flag"] = False
        tiling['default_tiling'] = True
        _handle_block_dim()

        return tiling

    def schedule_handle(self, block_dims, tiling):
        """
        schedule handle

        Parameters
        ----------
        block_dims: block dim
        tiling: tiling info

        Returns
        -------
        the min of block_dims and al1_factor
        """
        # calculate the actual block_dim_m in the dynamic batch
        out_img_shape = self._get_output_h(self.a_info[3])*self._get_output_w(self.a_info[4])
        c_tiling_factor = tiling['CL0_matrix'][1]*tiling['CL0_matrix'][2]
        c_factor = te_util.int_ceil_div(out_img_shape, c_tiling_factor)
        if len(tiling['AL1_shape']) == 1:
            tiling['AL1_shape'] = tiling['AL1_shape'] + [1]
        if tiling['AL1_shape']:
            al1_factor = te_util.int_ceil_div(c_factor, tiling['AL1_shape'][1])
        else:
            al1_factor = 1

        return tvm.min(block_dims, al1_factor)

    def assembly_case(self, tiling_strategy, covered, cnt):
        var_range = OrderedDict()
        block_dim_multi = tiling_strategy["BUB_shape"][0] if tiling_strategy["BUB_shape"] else 1
        block_dims = block_dim_multi *\
            reduce(lambda x, y: x * y, tiling_strategy["block_dim"])
        correct_range_flag = Conv3DParam.dynamic_para.get("correct_range_flag")

        if Conv3DParam.binary_mode:
            return {"key": cnt, "tiling_strategy": tiling_strategy, "var_range": var_range,
                    "block_dim": block_dims, "correct_range_flag": correct_range_flag}

        if 'batch_n' in self.var_map:
            var_range['batch_n'] = (covered[0], covered[1])

        if 'fmap_d' in self.var_map:
            var_range['fmap_d'] = (covered[2], covered[3])
            var_range['d_out'] = (self._get_output_d(var_range['fmap_d'][0]),
                               self._get_output_d(var_range['fmap_d'][1]))

        if 'fmap_h' in self.var_map:
            var_range['fmap_h'] = (covered[4], covered[5])
            var_range['h_out'] = (self._get_output_h(var_range['fmap_h'][0]),
                               self._get_output_h(var_range['fmap_h'][1]))

        if 'fmap_w' in self.var_map:
            var_range['fmap_w'] = (covered[6], covered[7])
            var_range['w_out'] = (self._get_output_w(var_range['fmap_w'][0]),
                               self._get_output_w(var_range['fmap_w'][1]))

        if tiling_strategy["AL0_matrix"][2] == VALID_TILING_NUM:
            tiling_strategy = self.get_default_tiling()
            block_dims = reduce(lambda x, y: x * y, tiling_strategy.get("block_dim"))
        elif 'fmap_h' not in self.var_map and 'fmap_w' not in self.var_map:
            new_block_dims = copy.deepcopy(tiling_strategy['block_dim'])
            new_tiling = copy.deepcopy(tiling_strategy)
            new_block_dims[2] = int(self.schedule_handle(new_block_dims[2], new_tiling))
            block_dims = block_dim_multi *\
                reduce(lambda x, y: x * y, new_block_dims)

        return {"key": cnt, "tiling_strategy": tiling_strategy, "var_range": var_range,
                "block_dim": block_dims, "correct_range_flag": correct_range_flag}

    def get_tiling_range(self, tiling_in, shape_info):
        """
        get the covered area of a tiling

        Parameters
        ----------
        tiling_in : dict, result of tiling fetch

        shape_info : list, size of fmap_shape

        Returns
        -------
        list, range covered for tiling_in
        """

        tiling = self._preprocess_tiling(tiling_in)
        fmap_n, fmap_d, _, fmap_h, fmap_w, _ = shape_info
        if not tiling["AL1_shape"]:
            # fully load in AL1, covering lower region
            return [1, fmap_n, 1, fmap_d, 1, fmap_h, 1, fmap_w]
        n_range_min, n_range_max = self._get_batch_range(fmap_n)
        perf_range = [n_range_min, n_range_max]
        # get min value
        hi_min, wi_min = 1, 1
        if self.pad_mode != "VAR":
            hi_min = max(self.k_h - self.padu - self.padd, 1)
            wi_min = max(self.k_w - self.padl - self.padr, 1)
        support_w_min = wi_min

        hi_max = H_RANGE
        cur_w_size = fmap_w

        # check tiling covering itself situation
        if not self._check_tiling_match(tiling, cur_w_size) or \
                fmap_h > H_RANGE or fmap_w > W_RANGE:
            return [0, 0, 0, 0, 0, 0]

        # searching down-ward for w_min
        while self._check_tiling_match(tiling, cur_w_size) \
                and cur_w_size > support_w_min:
            wi_min = cur_w_size
            cur_w_size = cur_w_size - W_DELTA

        # searching up-ward for w_max
        cur_w_size = fmap_w
        while self._check_tiling_match(tiling, cur_w_size) \
                and cur_w_size <= W_RANGE:
            wi_max = cur_w_size
            cur_w_size = cur_w_size + W_DELTA

        perf_di_min = 1
        perf_di_max = -1

        # If the pad in the d direction is not 0, the k value of al0_matrix can only be a factor of C1HkWk
        if tiling.get('AL0_matrix') and tiling.get('AL0_matrix')[-1] != 1:
            cur_d_size = fmap_d
            # searching down-ward for d_min
            while self._check_tiling_match_d([cur_d_size, fmap_h, fmap_w]):
                perf_di_min = cur_d_size
                cur_d_size = cur_d_size - D_DELTA

            # searching up-ward for d_max
            cur_d_size = fmap_d
            while self._check_tiling_match_d([cur_d_size, fmap_h, fmap_w]):
                perf_di_max = cur_d_size
                cur_d_size = cur_d_size + D_DELTA

        perf_wi_min = max(wi_min, fmap_w - W_LEN)
        perf_wi_max = min(wi_max, fmap_w + W_LEN)
        perf_hi_max = min(hi_max, fmap_h + H_LEN)
        perf_hi_min = max(hi_min, fmap_h - H_LEN)

        if perf_wi_min > perf_wi_max:
            return [0, 0, 0, 0, 0, 0, 0, 0]

        perf_range += [perf_di_min, perf_di_max, perf_hi_min, perf_hi_max, perf_wi_min, perf_wi_max]
        perf_range = [int(v) for v in perf_range]
        return perf_range

    def _gen_cache_tiling(self, cache_tiling, choice):
        '''
        Generate cache tiling and tiling_id.
        ---------------------------------------------
        |      variable     |    offset    |         value        |
        |       db_al1      |      14      |          0,1         |
        |       db_bl1      |      13      |          0,1         |
        |       db_l0c      |      12      |          0,1         |
        |       db_cub      |      11      |          0,1         |
        | abkl1_attach_flag |      9       |          0,1,2       |
        |  al1_attach_flag  |      7       |          0,1,2       |
        |  bl1_attach_flag  |      5       |          0,1,2       |
        |  bl0_attach_flag  |      4       |          0,1         |
        | cycle_buffer_flag |      3       |           0          |
        |  load3d_special   |      2       |          0,1         |
        |    load_mode      |      1       |       0(load3d)      |
        |    binary_mode    |      0       |         0(6HD)       |

        Returns
        ----------
        cache_tiling:Value of tiling
        tiling_id: The id of tiling
        '''
        (cache_tiling['pad_greater_than_filter'],
         cache_tiling.get('manual_pingpong_buffer')['AL1_pbuffer'],
         cache_tiling.get('manual_pingpong_buffer')['BL1_pbuffer'],
         cache_tiling.get('manual_pingpong_buffer')['CL0_pbuffer'],
         cache_tiling.get('manual_pingpong_buffer')['L0C_OUTPUT_pbuffer'],
         cache_tiling.get('attach_at_flag')['abkl1_attach_flag'],
         cache_tiling.get('attach_at_flag')['al1_attach_flag'],
         cache_tiling.get('attach_at_flag')['bl1_attach_flag'],
         cache_tiling.get('attach_at_flag')['bl0_attach_flag'],
         cache_tiling['load3d_special_flag']) = choice

        pad_greater_than_filter, al1_pb, bl1_pb, l0c_pb, c_ub_pb, abkl1_attach, al1_attach_flag, bl1_attach_flag, \
            bl0_attach_flag, load3d_special_flag = choice
        offset = TilingIdOffset()
        tiling_id = 0
        tiling_id += pad_greater_than_filter << offset.pad_greater_than_filter_offset
        tiling_id += (al1_pb - 1) << offset.db_al1_offset
        tiling_id += (bl1_pb - 1) << offset.db_bl1_offset
        tiling_id += (l0c_pb - 1) << offset.db_l0c_offset
        tiling_id += (c_ub_pb - 1) << offset.db_cub_offset
        tiling_id += abkl1_attach << offset.abkl1_attach_flag_offset
        tiling_id += al1_attach_flag << offset.al1_attach_flag_offset
        tiling_id += bl1_attach_flag << offset.bl1_attach_flag_offset
        tiling_id += bl0_attach_flag << offset.bl0_attach_flag_offset
        tiling_id += self.cycle_buffer_flag << offset.cycle_buffer_flag_offset
        tiling_id += load3d_special_flag << offset.load3d_special_flag_offset
        tiling_id += self.load_mode << offset.load_mode_offset
        tiling_id += (self.binary_mode - 1) << offset.binary_mode_offset

        return cache_tiling, tiling_id

    def _check_invalid_choice(self, choice):
        pad_greater_than_filter, al1_pb, bl1_pb, l0c_pb, c_ub_pb, abkl1_attach, al1_attach_flag, bl1_attach_flag, \
            bl0_attach_flag, load3d_special_flag, *_ = choice
        ## Drop invalid choices
        choice_list = [al1_pb, abkl1_attach, al1_attach_flag, bl1_attach_flag, load3d_special_flag]
        invalid_choice = super()._check_invalid_choice(choice_list)

        # 1) b_l1 full_load or none to b_l1_pb off
        invalid_choice |= (
            (bl1_attach_flag == utils.ATTACH_FULL_LOAD or bl1_attach_flag == utils.NO_ATTACH) and
            bl1_pb != utils.DB_OFF
        )

        # 2) b_l1 none is set to bl1 NO_ATTACH and kbl1 large than kal1
        invalid_choice |= (
            bl1_attach_flag == utils.NO_ATTACH and abkl1_attach != utils.ATTACH_LESS
        )

        # 3) b_l0 full load, not access bl1
        invalid_choice |= bl1_attach_flag != utils.NO_ATTACH and bl0_attach_flag == utils.ATTACH_FULL_LOAD

        # 4) when support_l0c2out, c_ub_pb is invalid
        invalid_choice |= self.support_l0c2out and c_ub_pb == utils.DB_ON

        # 5) when support_l0c2out, load3d_special_flag is invalid
        invalid_choice |= self.support_l0c2out and load3d_special_flag == 1

        # 6) when pad >= filter, only use not fullyload tilingkey
        invalid_choice |= (pad_greater_than_filter == 1
                           and (al1_pb != utils.DB_OFF or bl1_pb != utils.DB_OFF or l0c_pb != utils.DB_OFF
                                or c_ub_pb != utils.DB_OFF or abkl1_attach != utils.ATTACH_LESS or al1_attach_flag
                                != utils.ATTACH_LESS or bl1_attach_flag != utils.NO_ATTACH or bl0_attach_flag != 1))

        return invalid_choice

    def _get_calc_info(self):
        self._convert_type(self.a_info, self.b_info)
        self.k_d, self.k_h, self.k_w = self.b_info[1], self.b_info[3], self.b_info[4]
        self.k_cin = self.b_info[2] * self.b_info[5]
        self.k_cout = self.b_info[0]

        self.pad_mode = "FIX"
        # currently, in dynamic_dhw, when padding is SAME, pad_mode is "VAR"
        if any(isinstance(i, PrimExpr) for i in self.tiling_info["pad"]):
            self.pad_mode = "VAR"
            self.tiling_info["pad"] = [-1, -1, -1, -1, -1, -1]
        self.padf, self.padb, self.padu, self.padd, self.padl, self.padr =\
            self.tiling_info["pad"]
        self.stride_d, self.stride_h, self.stride_w = self.tiling_info["stride"]
        self.dilation_d, self.dilation_h, self.dilation_w = \
            self.tiling_info["dilation"]
        self.k_d_dilation = (self.k_d - 1) * self.dilation_d + 1
        self.k_h_dilation = (self.k_h - 1) * self.dilation_h + 1
        self.k_w_dilation = (self.k_w - 1) * self.dilation_w + 1

    def _get_output_d(self, d_in):
        if not d_in:
            return None
        if self.pad_mode == "VAR":
            return utils.icd(d_in, self.stride_d)
        return (d_in + self.padf + self.padb - self.dilation_d *
                (self.k_d - 1) - 1) // self.stride_d + 1

    def _get_output_h(self, h_in):
        if not h_in:
            return None
        if self.pad_mode == "VAR":
            return utils.icd(h_in, self.stride_h)
        return (h_in + self.padu + self.padd - self.dilation_h *
                (self.k_h - 1) - 1) // self.stride_h + 1

    def _get_output_w(self, w_in):
        if not w_in:
            return None
        if self.pad_mode == "VAR":
            return utils.icd(w_in, self.stride_w)
        return (w_in + self.padl + self.padr - self.dilation_w *
                (self.k_w - 1) - 1) // self.stride_w + 1

    def _calc_pads(self, d_in, h_in, w_in):
        pad_d = utils.align(d_in, self.stride_d) - self.stride_d + \
            self.k_d_dilation - d_in
        pad_d = max(pad_d, 0)
        pad_front = pad_d // 2
        pad_back = pad_d - pad_front

        pad_h = utils.align(h_in, self.stride_h) - self.stride_h + \
            self.k_h_dilation - h_in
        pad_h = max(pad_h, 0)
        pad_up = pad_h // 2
        pad_down = pad_h - pad_up

        pad_w = utils.align(w_in, self.stride_w) - self.stride_w + \
            self.k_w_dilation - w_in
        pad_w = max(pad_w, 0)
        pad_left = pad_w // 2
        pad_right = pad_w - pad_left
        return [pad_front, pad_back, pad_up, pad_down, pad_left, pad_right]

    def _preprocess_tiling(self, tiling_in):
        """
        preprocess tiling for get tiling range
        """

        tiling = copy.deepcopy(tiling_in)
        if tiling["AL1_shape"]:
            tiling["AL1_shape"][0] = tiling["AL1_shape"][0] * tiling["AL1_shape"][-1] // \
                (self.k_h * self.k_w * utils.CUBE_SIZE)
        if tiling["BL1_shape"]:
            tiling["BL1_shape"][0] = tiling["BL1_shape"][0] * tiling["BL1_shape"][-1] // \
                (self.k_h * self.k_w * utils.CUBE_SIZE)
        return tiling

    def _get_al1_bound(self, tiling, current_size):
        """
        get al1 bound info

        Parameters
        ----------
        tiling : dict, result of tiling fetch

        current_size : int, size of w

        Returns
        -------
        int, al1_load_length (al1_bound) in M axis

        """

        # shape info
        w_i = current_size
        out_w = self._get_output_w(w_i)

        pad_lis = [self.padf, self.padb, self.padu, self.padd, self.padl, self.padr]
        strideh_opti_flag = self.k_h == 1 and self.stride_h > 1

        if len(tiling['AL1_shape']) == 1:
            tiling['AL1_shape'].append(1)

        # M axis theorically loading length in al1
        al1_m_data = tiling['CL0_matrix'][1] * utils.FP16_M * tiling['AL1_shape'][1]

        # load2d instructions refer to data_mov with raw lens
        if (self.pad_mode == "VAR" or sum(pad_lis) == 0) \
            and (self.stride_h * self.stride_w * self.stride_d == 1) \
                and (self.k_h * self.k_w * self.k_d == 1):
            return al1_m_data

        # load3d instructions refer to load extra lines with pad/stride/filter
        if al1_m_data % out_w == 0:
            # full line could load without extra lines
            extend_h = 0
        elif (al1_m_data * 2) % out_w == 0:
            # every 2 load3d covered only 1 extra line
            extend_h = 1
        else:
            # other situations need 2 extra lines in case
            extend_h = 2
        l1_ho = al1_m_data // out_w + extend_h

        # calculate input lines (hi) from output lines (ho)
        if not strideh_opti_flag:
            li_hi = self.k_h + (l1_ho - 1) * self.stride_h
        else:
            li_hi = self.k_h + (l1_ho - 1)

        return li_hi * w_i

    def _check_tiling_match(self, tiling, current_w):
        """

        check whether this tiling matches the shape

        Parameters
        ----------
        tiling : dict, result of tiling fetch

        current_size : int, size of h,w

        Returns
        -------
        bool, True: match
            False: do not match

        """

        # get M axis length in al1
        al1_bound = self._get_al1_bound(tiling, current_w)

        # fmap size in L1 ( M * K * db * 2byte)
        fmap_l1_size = utils.FP16_SIZE * al1_bound * tiling['AL1_shape'][0] * \
            utils.FP16_K * tiling['manual_pingpong_buffer']['AL1_pbuffer']

        # filter size
        if tiling['BL1_shape'] is None:
            # not using BL1
            filter_l1_size = 0
        elif len(tiling['BL1_shape']) == 0:
            # fully load in BL1
            filter_l1_size = utils.FP16_SIZE * self.k_cout * self.k_cin * self.k_h * \
                self.k_w * self.k_d / tiling['block_dim'][1]
        else:
            # fmap size in L1 ( K * N * db * 2byte)
            filter_l1_size = utils.FP16_SIZE * tiling['BL1_shape'][1] * \
                tiling['CL0_matrix'][0] * utils.FP16_N * tiling['BL1_shape'][0] * \
                utils.FP16_K * self.k_h * self.k_w * \
                tiling['manual_pingpong_buffer']['BL1_pbuffer']

        # check exceed L1 buffer
        if int(fmap_l1_size) + int(filter_l1_size) > tbe_platform_info.get_soc_spec("L1_SIZE"):
            return False

        # get m axis length in cub
        fused_num = self.var_map.get("fused_num", 0)
        tensor_num = fused_num + 2 if fused_num > 0 else 1
        cub_bound = (tiling['CL0_matrix'][0] * tiling['CL0_matrix'][1] *
                     utils.FP16_M * DTYPE_BYTE_MAPPING.get(self.c_type))

        return cub_bound * tensor_num <= tbe_platform_info.get_soc_spec("UB_SIZE")

    def _check_tiling_match_d(self, current_size):
        """

        check whether this tiling matches the shape d

        Parameters
        ----------
        current_size : int, size of [d, h, w]

        Returns
        -------
        bool, True: match
            False: do not match
        """

        pad_front, pad_back, *_ = self._calc_pads(*current_size)

        return pad_front == 0 and pad_back == 0

    def _get_batch_range(self, paras):
        """
        get batch covering range
        """
        batch = paras
        if "batch_n" in self.var_map:
            core_num = tbe_platform_info.get_soc_spec("CORE_NUM")
            if batch >= core_num:
                return core_num, -1
            if core_num == N_BASE:
                return 1, -1
            batch_log = int(math.log(batch, N_BASE))
            return N_BASE ** batch_log, N_BASE ** (int(batch_log + 1))
        return batch, batch


class Conv3dStaticTiling(CubeStaticTilingOp):
    def __init__(self, out_list):
        super().__init__(out_list)
        self._tensor_map = copy.deepcopy(Conv3DParam.tensor_map)
        self.fixpipe_tensor = None
        self._init_tensor_op()
        self.ub_fusion_flag = self._tensor_map.get("dsl_flag") and self._tensor_map.get("c_ub") is not None
        self.w_dtype = Conv3DParam.tiling_info_dict.get('b_dtype')
        self.in_dtype = Conv3DParam.tiling_info_dict.get('a_dtype')
        self._fused_op_num = 0
        self.requant_multi_group_flag = self._get_requant_multi_group()
        self._set_tiling_info_dict()

    @staticmethod
    def _get_tiling_batch(batch_size):
        device_core_num = tbe_platform_info.get_soc_spec("CORE_NUM")
        if batch_size > 1 and device_core_num > 1:
            if batch_size <= device_core_num:
                return batch_size
            else:
                for tmp_dim in range(device_core_num, 0, -1):
                    if batch_size % tmp_dim == 0:
                        break
                return tmp_dim
        else:
            return 1

    def _init_tensor_op(self):
        color_op = AutoScheduleOp(self.res)
        self.body_ops = color_op.body_ops
        self.output_ops = color_op.output_ops
        if "fixpipe" in self.output_ops[0].get("op"):
            _, self.fixpipe_tensor, _ = get_fixpipe_tensor(self.body_ops, self._tensor_map)
        for lop in self.body_ops:
            if lop['op'] == 'fixpipe':
                continue
            self._get_fused_tensor(lop)

    def _set_tiling_info_dict(self):
        self.tiling_info_dict = Conv3DParam.tiling_info_dict
        if self.tiling_info_dict.get('default_tiling') is not None:
            self.tiling_info_dict.pop('default_tiling')
        if self._tensor_map.get("c_ub") is not None:
            self._fused_op_num = self._get_fused_op_num()
        if self.tiling_info_dict.get('c_dtype') is not None:
            self.tiling_info_dict['c_dtype'] = self.res.dtype
        self.tiling_info_dict["fused_coefficient"] = [0, 0, self._fused_op_num]
        update_info_dict(Conv3DParam.support_l0c_to_out_flag, self.fixpipe_tensor,
                         None, self.tiling_info_dict)

    def _get_fused_op_num(self):
        if self.w_dtype != 'int8':
            fuse_op_num = len(self.body_ops) - _CONV_NUM
            if not self._tensor_map.get("l0a_load2d_flag"):
                fuse_op_num -= 1
            bias_flag = self.tiling_info_dict.get("bias_flag")
            if bias_flag:
                fuse_op_num -= 1
            return fuse_op_num

        not_count_list = []
        for item in Conv3DParam.inline_tensors:
            if item in self._tensor_map:
                not_count_list.append(self._tensor_map.get(item))
        start_node = self._tensor_map["c_ub"]
        if self.ub_fusion_flag:
            for item in Conv3DParam.ub_start_tensor:
                if item in self._tensor_map:
                    start_node = self._tensor_map.get(item)
                    break
        multi_ub = CalculateMultiUB(start_node, self.res, not_count_list)
        ub_res, _ = multi_ub.calculate_start()
        fuse_op_num = ub_res / CalculateMultiUB.BYTES_DTYPE.get(self.res.dtype) - 1
        return fuse_op_num

    def _get_fused_tensor(self, lop):
        if lop['op'] in Conv3DParam.inline_tensors or lop['op'] in Conv3DParam.ub_start_tensor:
            self._tensor_map[lop['op']] = lop['dst_buffer']
        elif lop['op'] == 'conv_vector_remove_pad':
            self._tensor_map[lop['op']] = lop['dst_buffer']

    def _support_optiling(self, is_binary_const=True):
        """
        Determine whether it is supported dyn_const_tiling and cache_tiling
        """
        return False

    def _get_tiling_ml0_bl1shape(self):
        """
        get default tiling max m_l0 and BL1_shape for conv3d
        """
        config = tbe_platform.CUBE_MKN[self.w_dtype]
        ci0 = config['mac'][1]
        l1_buffer_size = tbe_platform_info.get_soc_spec("L1_SIZE")
        support_l0c2out = tbe_platform_info.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out")
        bias_flag = Conv3DParam.tiling_info_dict.get("bias_flag")
        in_size_w = Conv3DParam.tiling_info_dict["a_shape"][-2]
        padw = Conv3DParam.tiling_info_dict["pad"][4:6]
        cout = Conv3DParam.tiling_info_dict["b_shape"][0]
        kernel_w = Conv3DParam.tiling_info_dict["b_shape"][-2]
        kernel_h = Conv3DParam.tiling_info_dict["b_shape"][-3]
        dilationh = Conv3DParam.tiling_info_dict["dilation"][1]
        dilationw = Conv3DParam.tiling_info_dict["dilation"][2]
        stridew = Conv3DParam.tiling_info_dict["stride"][2]
        strideh = Conv3DParam.tiling_info_dict["stride"][1]
        w_out = (in_size_w + padw[0] + padw[1] - ((kernel_w - 1) * dilationw + 1)) // stridew + 1

        bl1_shape = None
        # check filter load directly into L0B firstly
        in_dtype_byte = DTYPE_BYTE_MAPPING.get(self.in_dtype)
        for m_target in range(32, -1, -1):
            tmp1 = ((m_target * DTYPE_BIT_MAPPING.get('float16')) + w_out - 1) // w_out
            tmp2 = ((tmp1 * strideh) + (kernel_h - 1) * dilationh + 1) * in_size_w
            max_feature_map = 1 * ci0 * tmp2 * 2 * in_dtype_byte
            bias_l1_size = cout * in_dtype_byte if support_l0c2out and bias_flag else 0  # now bias full load
            if max_feature_map + bias_l1_size <= l1_buffer_size:
                break

        if m_target == 0:
            bl1_shape = [1]
            for m_target in range(32, -1, -1):
                tmp1 = ((m_target * DTYPE_BIT_MAPPING.get('float16')) + w_out - 1) // w_out
                tmp2 = ((tmp1 * strideh) + (kernel_h - 1) * dilationh + 1) * in_size_w
                max_feature_map = 1 * ci0 * tmp2 * 2 * in_dtype_byte
                bl1_size = ci0 * ci0 * in_dtype_byte
                bias_l1_size = ci0 * in_dtype_byte if support_l0c2out and bias_flag else 0
                if max_feature_map + bl1_size + bias_l1_size < l1_buffer_size:
                    break
        return m_target, bl1_shape

    def _get_default_tiling(self):
        """
        get default tiling for conv3d
        """
        tiling = {}
        batch_size = Conv3DParam.tiling_info_dict["a_shape"][0]
        m_target, bl1_shape = self._get_tiling_ml0_bl1shape()
        tiling_m, tiling_n = self._get_tiling_mn(m_target)
        tiling_k = 1
        tiling["AL1_shape"] = [1]
        tiling["BL1_shape"] = bl1_shape
        tiling["AL0_matrix"] = [tiling_m, tiling_k, 16, 16]
        tiling["BL0_matrix"] = [tiling_k, tiling_n, 16, 16]
        tiling["CL0_matrix"] = [tiling_n, tiling_m, 16, 16]
        tiling["L0C_OUTPUT_matrix"] = [tiling_n, tiling_m, 16, 16]
        tiling["manual_pingpong_buffer"] = {'AL1_pbuffer': 1, 'BL1_pbuffer': 1,
                                            'AL0_pbuffer': 1, 'BL0_pbuffer': 1,
                                            'CL0_pbuffer': 1, 'L0C_OUTPUT_pbuffer': 1, 'UBG_pbuffer': 1}
        tiling["block_dim"] = [self._get_tiling_batch(batch_size), 1, 1]
        tiling["scale_drq_split_flag"] = True
        tiling["bias_split_flag"] = True
        tiling["A_overhead_opt_flag"] = 0
        tiling["B_overhead_opt_flag"] = 0
        tiling["n_bef_batch_flag"] = 0
        tiling['default_tiling'] = True
        return tiling

    def _get_tiling_mn(self, m_target):
        tiling_n = 1
        if self.requant_multi_group_flag:
            tiling_n = self._tensor_map['group_dict']['cout_g'] // _TILING_FLOAT16_MKN
            for m in range(m_target, 0, -1):
                l0c_used_size = (m * tiling_n * _TILING_FLOAT16_MKN * _TILING_FLOAT16_MKN *
                                 DTYPE_BYTE_MAPPING.get('int32') * 2)
                if l0c_used_size < tbe_platform_info.get_soc_spec('L0C_SIZE'):
                    m_target = m
                    break
        elif self.res.dtype == 'int8':
            tiling_n = 2
        return m_target, tiling_n

    def _get_requant_multi_group(self):
        cout1_g = self._tensor_map['group_dict']['cout_g'] // _TILING_FLOAT16_MKN
        real_g = self._tensor_map['group_dict']['real_g']
        return (cout1_g % 2 == 1 and real_g > 1 and self.res.dtype == 'int8')

    def _get_and_transfer_cache_tiling(self):
        """
        get cache_tiling and transfer it to static tiling
        """
        log.error("[optiling] Conv3dBackpropFilter does not currently support cachtiling")
