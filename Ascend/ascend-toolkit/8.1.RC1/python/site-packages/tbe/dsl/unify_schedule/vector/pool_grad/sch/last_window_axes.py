#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright 2023-2024 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
last window axes schedule
"""

from tbe import tvm
from tbe.dsl.base import operation
from tbe.dsl.compute.constants import ComputeType
from tbe.dsl.unify_schedule import schedule
from tbe.dsl.unify_schedule import util
from tbe.dsl.unify_schedule.constants import Pattern
from tbe.dsl.unify_schedule.constants import PoolGradPattern
from tbe.dsl.unify_schedule.vector.pool_grad import pool_grad_schedule
from tbe.dsl.unify_schedule.vector.pool_grad import pool_grad_tilingcase


class LastWindowAxes(pool_grad_schedule.PoolGradSchedule, schedule.Schedule):
    """
    Support nlast window axis pooling, contains:
    1. (n, c, h, w)
    2. (n, c, d, h, w)
    """
    def __init__(self, outs, tiling_case):
        super().__init__(outs, tiling_case)

        self._x_t = None
        self._y_t = None
        self._dy_t = None

        self._dx_t = None
        self._dx_depad = None

    @classmethod
    def get_supported_pattern(cls):
        return [Pattern.POOL_GRAD]

    @classmethod
    def get_supported_sub_pattern(cls):
        return PoolGradPattern.LAST_WINDOW_AXIS

    def _get_coexist(self):
        # 'TODO, should be 3 or 4? Depends on fp32 transpose emit insn
        # 'coexist = 5
        # 'if self._tiling_case.strategy in (pool_grad_tilingcase.Strategy.UB_RK_BLOCK_A,
        # '                                 pool_grad_tilingcase.Strategy.UB_RK_BLOCK_R):
        # '   coexist += 1
        if util.is_v100() or util.is_v200():
            return 6
        return 5

    def _do_transpose(self):
        def transpose_input(x):
            x_copy = self._sch.cache_read(x, "local.UB", self._sch.to_tensors(self._sch[x].consumers))
            x_copy = self._sch[x_copy]
            x_t = x_copy.transpose(*x_copy.op.axis[1:], x_copy.op.axis[0], inline=False)
            x_copy.compute_inline()
            return x_t

        x_pad = self._sch.get_stages(compute_type=ComputeType.PAD)[0]
        x_pad.transpose(*x_pad.op.axis[1:], x_pad.op.axis[0])

        x_img2col = self._sch.get_stages(compute_type=ComputeType.IMG2COL)[0]
        x_img2col.transpose(x_img2col.op.axis[0], *x_img2col.op.axis[2:], x_img2col.op.axis[1])

        scan = self._sch.get_stages(compute_type=ComputeType.SCAN)[0]
        scan_t = self._sch.cache_write(scan.tensor,
                                       "local.UB",
                                       need_transpose=True,
                                       dst_shape=[0, *range(2, len(scan.tensor.shape)), 1])
        scan_t.compute_type = scan.compute_type
        scan_t.tag = scan.tag
        scan.compute_inline()

        dp = self._sch[self._dp]
        for x in dp.ancestors:
            if x.is_elewise() or x.is_cast():
                x.transpose(x.op.axis[0], *x.op.axis[2:], x.op.axis[1])
                continue

        self._x_t = transpose_input(self._inputs_local.x)
        self._y_t = transpose_input(self._inputs_local.y)
        self._dy_t = transpose_input(self._inputs_local.dy)

        dx_stage = self._sch[self._dx_local]
        dx_stage.reorder(*dx_stage.op.axis[1:], dx_stage.op.axis[0])
        self._dx_depad = self._sch.cache_write(self._dx_local, "local.UB")
        self._dx_t = self._dx_local

        self._sch[self._dx_depad].compute_type = dx_stage.compute_type
        self._sch[self._dx_depad].tag = dx_stage.tag
        dx_stage.compute_type = ComputeType.TRANSPOSE
        dx_stage.tag = "transpose"

        self._dp = dp.transpose(*dp.op.axis[1:], dp.op.axis[0])

    def _do_align(self):
        self._align_for_transpose()

        align_factor = self._get_align_factor()

        for x in self._sch.get_stages(scope="local.UB"):
            if x.is_dma_in() or x.is_scan_component():
                continue

            if x.is_scan():
                x.compute_align(x.op.spatial_axis_[-1], align_factor)
                continue

            if x == self._sch[self._dx_t]:
                continue

            x.compute_align(x.op.axis[-1], align_factor)

        # fill pad 0 for reduce op
        dy_stage = self._sch[self._inputs_local.dy]
        dy_dtype = self._inputs_local.dy.dtype
        dy_stage.compute_align(dy_stage.op.axis[0], align_factor, tvm.const(0, dy_dtype))

        align_k_factor = self._get_k_align_factor()
        for x in self._sch.get_stages(dtype="uint1"):
            if x.is_scan_component():
                continue

            if x.is_scan():
                x.storage_align(x.op.scan_axis, align_k_factor, 0)
                continue

            x.storage_align(x.op.axis[0], align_k_factor, 0)

    def _align_for_transpose(self):
        def ub_ah():
            # x_local_stage is x.local.UB
            x_local_stage.compute_align(x_local_stage.op.axis[-1], transpose_factor, tvm.const(0, "float32"))

            # x_t_stage is x.local.UB.local.UB.local.UB
            x_t_stage.compute_align(x_t_stage.op.axis[-1], align_factor)
            x_t_stage.compute_align(x_t_stage.op.axis[-2], transpose_factor)

            # dx_t_stage is depad.local.UB
            dx_t_stage.compute_align(dx_t_stage.op.axis[-1], transpose_factor)

            # dx_depad_stage is depad.local.UB.local.UB
            dx_depad_stage.compute_align(dx_depad_stage.op.axis[-1], align_factor)
            dx_depad_stage.compute_align(dx_depad_stage.op.axis[-2], transpose_factor)

        def ub_ro():
            # x_local_stage is x.local.UB
            x_local_stage.compute_align(x_local_stage.op.axis[-1], transpose_factor, tvm.const(0, "float32"))

            # x_t_stage is x.local.UB.local.UB.local.UB
            x_t_stage.compute_align(x_t_stage.op.axis[-1], align_factor)
            x_t_stage.compute_align(x_t_stage.op.axis[-2], transpose_factor)

            # dx_t_stage is depad.local.UB
            dx_t_stage.compute_align(dx_t_stage.op.axis[-1], transpose_factor)

            # dx_depad_stage is depad.local.UB.local.UB
            dx_depad_stage.compute_align(dx_depad_stage.op.axis[-1], align_factor)
            dx_depad_stage.compute_align(dx_depad_stage.op.axis[-2], transpose_factor)

        def ub_rk():
            # x_local_stage is x.local.UB
            x_local_stage.compute_align(x_local_stage.op.axis[-1], transpose_factor, tvm.const(0, "float32"))

            # x_t_stage is x.local.UB.local.UB.local.UB
            x_t_stage.compute_align(x_t_stage.op.axis[-1], align_factor)
            x_t_stage.compute_align(x_t_stage.op.axis[-2], transpose_factor)

            # dx_t_stage is depad.local.UB
            dx_t_stage.compute_align(dx_t_stage.op.axis[-1], transpose_factor)

            # dx_depad_stage is depad.local.UB.local.UB
            dx_depad_stage.compute_align(dx_depad_stage.op.axis[-1], align_factor)
            dx_depad_stage.compute_align(dx_depad_stage.op.axis[-2], transpose_factor)

        align_factor, transpose_factor = self._get_align_factor(), self._get_transpose_factor()

        ub_split_idx = self._tiling_case.ub_split_idx

        x_t_stage, dx_t_stage, dx_depad_stage = self._sch[self._x_t], self._sch[self._dx_t], self._sch[self._dx_depad]
        dx_gm_stage = self._sch[self._dx]
        dx_depad_stage = self._sch[self._dx_depad]
        x_local_stage = self._sch[self._inputs_local.x]
        y_local_stage, dy_local_stage = self._sch[self._inputs_local.y], self._sch[self._inputs_local.dy]

        y_local_stage.storage_align(y_local_stage.op.axis[0], transpose_factor, 0)
        dy_local_stage.storage_align(dy_local_stage.op.axis[0], transpose_factor, 0)

        strategy, strategy_enum = self._tiling_case.strategy, pool_grad_tilingcase.Strategy
        if strategy in (strategy_enum.UB_AH_BLOCK_A,):
            ub_ah()
        elif strategy in (strategy_enum.UB_RO_BLOCK_A, strategy_enum.UB_RO_BLOCK_R):
            ub_ro()
        elif strategy in (strategy_enum.UB_RK_BLOCK_A, strategy_enum.UB_RK_BLOCK_R):
            ub_rk()

    def _do_emit_insn(self):
        def make_perm_call(perm_):
            if perm_ is not None:
                return tvm.call_intrin("handle", 'tir.tvm_tuple', *perm_)
            return None

        def calc_transpose_perm():
            in_perm_, out_perm_ = None, None
            axes_len = len(self._dp.shape)
            ub_split_idx = self._tiling_case.ub_split_idx

            if self._tiling_case.strategy == pool_grad_tilingcase.Strategy.UB_AH_BLOCK_A:
                in_perm_ = [*range(1, axes_len), 0]
                out_perm_ = [axes_len-1, *range(axes_len-1)]
            elif self._tiling_case.strategy in (pool_grad_tilingcase.Strategy.UB_RO_BLOCK_A,
                                                pool_grad_tilingcase.Strategy.UB_RO_BLOCK_R,
                                                pool_grad_tilingcase.Strategy.UB_RK_BLOCK_A,
                                                pool_grad_tilingcase.Strategy.UB_RK_BLOCK_R,):
                in_perm_ = [*range(1, axes_len-ub_split_idx), 0]
                out_perm_ = [axes_len-ub_split_idx, *range(axes_len-ub_split_idx)]

            return make_perm_call(in_perm_), make_perm_call(out_perm_)

        def calc_transpose_attrs(perm):
            attrs = {"is_trans_align": 1}
            if perm is not None:
                attrs["src_in_dst_order"] = perm

            if not(util.is_v100() or util.is_v200()):
                attrs["enable_vnchwconv_b32"] = 1 if operation.in_dynamic() else 2

            return attrs

        in_perm, out_perm = calc_transpose_perm()

        self._sch[self._x_t].emit(attrs=calc_transpose_attrs(in_perm))
        self._sch[self._y_t].emit(attrs=calc_transpose_attrs(in_perm))
        self._sch[self._dy_t].emit(attrs=calc_transpose_attrs(in_perm))

        self._sch[self._dx_t].emit(attrs=calc_transpose_attrs(out_perm))

        super()._do_emit_insn()
