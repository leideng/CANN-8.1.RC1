#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2022. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
tiling key
"""
from enum import IntEnum
from typing import Tuple
from typing import Union
from tbe.common.utils.errormgr import get_error_message

TILING_KEY_WIDTH = 16
SCHEDULE_TYPE_LEN = 2
ONE_HEX_BITS = 4
CONST_MODE_KEY = 0xFFF
EMPTY_MODE_KEY = 0xEFF
CLEAR_KEY = 0x0
MODE_BEGIN_INDEX = 4
PATTERN_BEGIN_INDEX = 7
TILING_SPLIT_BEGIN_INDEX = 12
SPLIT_FLAG_INDEX = 11
BLOCK_AXIS_INDEX = 14
DOUBLE_SPLIT_BLOCK_AXIS_INDEX = 13
UB_AXIS_0_INDEX = 14
UB_AXIS_1_INDEX = 15
MODE_LEN = 3
PATTERN_LEN = 4
TILING_SPLIT_LEN = 4


class ScheduleType(IntEnum):
    ELETWISE = 0x10
    BROADCAST = 0x11
    COMMONREDUCE = 0x12
    TUPLEREDUCE = 0x13
    NORM = 0x14
    CONCAT = 0x15
    SPLIT = 0x16
    GATHER = 0x17
    TRANSPOSE = 0x18
    TRANSDATA = 0x19
    SLICE = 0x1A
    POOLING = 0x1B
    POOLING_WITH_ARG = 0x21
    SORT = 0x1C
    SPARSEAPPLY = 0x1D
    SCATTER = 0x1E
    RESIZE = 0x1F
    POOLING_GRAD = 0x22


def _index_to_positive(index: int):
    if index < 0:
        return index + TILING_KEY_WIDTH
    return index


def _set_tiling_key_error(message: str):
    dict_args = {
        "errCode": "E90001",
        "detailed_cause": message
    }
    raise RuntimeError(dict_args, get_error_message(dict_args))


def _check_index(start: int, end: int):
    if end <= start:
        _set_tiling_key_error("index error, end index needs to be greater than start index")
    if start < -TILING_KEY_WIDTH or end > TILING_KEY_WIDTH:
        _set_tiling_key_error(f"index out of the bound, it should [{-TILING_KEY_WIDTH}, {TILING_KEY_WIDTH})")


def _check_value(value: int, start: int, end: int):
    if abs(value) >= (1 << ((end - start) * ONE_HEX_BITS)):
        _set_tiling_key_error("value is too large, out of the bound")


def _get_item_min_max_index(item: Union[slice, int]):
    step = 1
    if isinstance(item, slice):
        min_index = _index_to_positive(item.start)
        max_index = _index_to_positive(item.stop)
        step = item.step or 1
    else:
        min_index = _index_to_positive(item)
        max_index = min_index + 1
    if step == -1:
        min_index, max_index = max_index, min_index
    _check_index(min_index, max_index)
    if abs(step) != 1:
        _set_tiling_key_error("step must be 1 or -1")
    return min_index, max_index


class TilingKey:

    def __init__(self, schedule_type: ScheduleType):
        self.__tiling_key = ['0'] * TILING_KEY_WIDTH
        self.__tiling_key[0:SCHEDULE_TYPE_LEN] = format(schedule_type, 'x').rjust(SCHEDULE_TYPE_LEN, '0')

    def __setitem__(self, key: Union[slice, int], value: int):
        min_index, max_index = _get_item_min_max_index(key)
        _check_value(value, min_index, max_index)
        if value < 0:
            value = value & (1 << (max_index - min_index) - 1)
        self.__tiling_key[key] = format(value, 'x').rjust(max_index - min_index, '0')

    def __getitem__(self, item: Union[slice, int]):
        min_index, max_index = _get_item_min_max_index(item)
        tiling_key_str = ''.join(self.__tiling_key[min_index:max_index])
        return int(tiling_key_str, base=16)

    @property
    def tiling_key(self):
        return self.get_value()

    @property
    def mode(self):
        return self.get_value(MODE_BEGIN_INDEX, MODE_BEGIN_INDEX + MODE_LEN)

    @property
    def pattern(self):
        return self.get_value(PATTERN_BEGIN_INDEX, PATTERN_BEGIN_INDEX + PATTERN_LEN)

    @property
    def split_flag(self):
        return self.get_value(SPLIT_FLAG_INDEX, SPLIT_FLAG_INDEX + 1)

    @property
    def block_axis(self):
        return self.get_value(BLOCK_AXIS_INDEX, BLOCK_AXIS_INDEX + 1)

    @property
    def double_split_block_axis(self):
        return self.get_value(DOUBLE_SPLIT_BLOCK_AXIS_INDEX, DOUBLE_SPLIT_BLOCK_AXIS_INDEX + 1)

    @property
    def ub_axis(self):
        return self.get_value(UB_AXIS_1_INDEX, UB_AXIS_1_INDEX + 1)

    @property
    def double_split_ub_axis(self):
        return (self.get_value(UB_AXIS_0_INDEX, UB_AXIS_0_INDEX + 1),
                self.get_value(UB_AXIS_1_INDEX, UB_AXIS_1_INDEX + 1))

    @mode.setter
    def mode(self, mode: int):
        """
        set mode value, index range is [4, 7)
        :param mode:
        :return:
        """
        self.set_value(mode, MODE_BEGIN_INDEX, MODE_BEGIN_INDEX + MODE_LEN)

    @pattern.setter
    def pattern(self, pattern: int):
        """
        set pattern value, index range is [7, 11)
        :param pattern:
        :return:
        """
        self.set_value(pattern, PATTERN_BEGIN_INDEX, PATTERN_BEGIN_INDEX + PATTERN_LEN)

    @split_flag.setter
    def split_flag(self, split_falg: int):
        """
        set split flag, index is 11
        :param split_falg:
        :return:
        """
        self.set_value(split_falg, SPLIT_FLAG_INDEX, SPLIT_FLAG_INDEX + 1)

    @block_axis.setter
    def block_axis(self, block_axis: int):
        """
        set block split axis, index is 14
        :param block_axis:
        :return:
        """
        self.set_value(block_axis, BLOCK_AXIS_INDEX, BLOCK_AXIS_INDEX + 1)

    @double_split_block_axis.setter
    def double_split_block_axis(self, block_axis: int):
        """
        set block split axis, index is 13
        :param block_axis:
        :return:
        """
        self.set_value(block_axis, DOUBLE_SPLIT_BLOCK_AXIS_INDEX, DOUBLE_SPLIT_BLOCK_AXIS_INDEX + 1)

    @ub_axis.setter
    def ub_axis(self, ub_axis: int):
        """
        set ub split axis, index is 15
        :param ub_axis:
        :return:
        """
        self.set_value(ub_axis, UB_AXIS_1_INDEX, UB_AXIS_1_INDEX + 1)

    @double_split_ub_axis.setter
    def double_split_ub_axis(self, ub_axes: Tuple[int, int]):
        """
        set ub split axis
        :param ub_axes:
        :return:
        """
        if len(ub_axes) != 2:
            raise RuntimeError
        self.set_value(ub_axes[0], UB_AXIS_0_INDEX, UB_AXIS_0_INDEX + 1)
        self.set_value(ub_axes[1], UB_AXIS_1_INDEX, UB_AXIS_1_INDEX + 1)

    def get_value(self, begin: int = 0, end: int = TILING_KEY_WIDTH):
        begin = _index_to_positive(begin)
        end = _index_to_positive(end)
        _check_index(begin, end)
        tiling_key_str = ''.join(self.__tiling_key[begin:end])
        return int(tiling_key_str, base=16)

    def set_value(self, value: int, begin: int, end: int):
        """
        set tiling key value, index range is [begin, end)
        :param value:
        :param begin:
        :param end:
        :return:
        """
        begin = _index_to_positive(begin)
        end = _index_to_positive(end)
        _check_index(begin, end)
        _check_value(value, begin, end)
        self.__tiling_key[begin:end] = format(value, 'x').rjust(end - begin, '0')

    def set_const_mode(self):
        self.set_value(CONST_MODE_KEY, MODE_BEGIN_INDEX, MODE_BEGIN_INDEX + MODE_LEN)

    def set_empty_mode(self):
        self.set_value(EMPTY_MODE_KEY, MODE_BEGIN_INDEX, MODE_BEGIN_INDEX + MODE_LEN)

    def clear_mode(self):
        self.mode = CLEAR_KEY

    def clear_pattern(self):
        self.pattern = CLEAR_KEY

    def clear_split_flag(self):
        self.split_flag = CLEAR_KEY

    def clear_split_axis(self):
        self.set_value(CLEAR_KEY, TILING_SPLIT_BEGIN_INDEX, TILING_SPLIT_BEGIN_INDEX + TILING_SPLIT_LEN)

    def clear_all_optional_key(self):
        self.clear_mode()
        self.clear_pattern()
        self.clear_split_axis()
        self.clear_split_flag()
