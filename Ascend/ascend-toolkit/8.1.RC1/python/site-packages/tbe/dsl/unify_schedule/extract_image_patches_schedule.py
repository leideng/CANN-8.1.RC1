#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2021 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
extract image patches schedule
"""
import te.platform as te_platform
from tbe import tvm
from tbe.common import platform as tbe_platform
from tbe.dsl.base import operation
from tbe.dsl.base.operation import get_context
from tbe.dsl.base.operation import register_schedule
from tbe.dsl.base.operation import var

from .constants import Pattern
from .extract_image_patches_tilingcase import Constant
from .extract_image_patches_without_cbuf_schedule import ExtractImagePatchesWithoutCbufSchedule
from .extract_image_patches_nchw_schedule import EIPNCHWSchedule

BLOCK_IDX = "blockIdx.x"
VALID = "VALID"
KHKW_AXIS_INDEX = 2


@register_schedule(pattern=Pattern.EXTRACT_IMAGE_PATCHES)
def schedule(outs, tiling_case):
    """
    schedule for extract_image_patch dynamic shape
    """
    if tiling_case.key >= 20000:
        return EIPNCHWSchedule(outs, tiling_case).do_schedule()

    if tiling_case.key >= 10000:  # refer to extract_image_patches_without_cbuf_tilingcase.py
        return ExtractImagePatchesWithoutCbufSchedule(outs, tiling_case).do_schedule()

    extract_image_patches_info = operation.get_context().get_current_compute().get("extract_image_patches_info")
    return ExtractImagePatchesSchedule(outs, tiling_case, extract_image_patches_info).do_schedule()


class ExtractImagePatchesSchedule:
    """
    ExtractImagePatchesSchedule
    """

    def __init__(self, outs, tiling_case, extract_image_patches_info):
        self.outs = outs
        self.output_res = outs[0]
        self.graph_info = dict()
        self.extract_image_patches_info = extract_image_patches_info
        self._sch = None
        self._tiling_case = tiling_case
        self._tiling_key = self._tiling_case.key
        self.split_axis_factor = None
        self.align_block_size = 0
        self.avg_split_ub_size = 0
        self.used_ub_size = 0
        self.type_size = 0
        self.fmap_n = 0
        self.fmap_c1 = 0
        self.fmap_h = 0
        self.fmap_w = 0
        self.fmap_c0 = 0
        self.howo = 0
        self.khkw = 0
        self.cut_h_col = 0
        self.cut_h_row_s = 0
        self.cut_h_row = 0
        self.cut_w_row = 0
        self.lcm_out_w = 0
        self.out_w = 0
        self.c_out = 0
        self.kernel_w = 0
        self.dtype_input = ""
        self.device_core_num = 0
        self.pre_com_fmap_w_c0 = 0
        self.pre_com_fmap_c1_w_c0 = 0
        self.multi_core_factor_0 = 0
        self.move_rate_cut_col = 0.0
        self.extract_params = dict()
        self.setfmatrix_dict = dict()
        self.padding_type = ""
        self.tiling_strategy = dict()
        self.res_axis_all_list = []
        self.workspace_res_axis_all_list = []
        self.workspace_res = None
        self.reorder_res_axis_list = []
        self.reorder_workspace_axis_list = []
        self.is_merge_subgraph = False
        self.use_reg_move = False
        self.reg_mov_ub = None
        self.multi_core_map = dict()
        self.is_const = False
        self._prepare_relative_params()

        self.res_ub_available_size = 0
        self.workspace_ub_available_size = 0
        self.l1_available_size = 0

        self.l1_tiling_axis = None
        self.workspace_tiling_axis = None
        self.ub_tiling_axis = None
        self.block_nparts = None
        self.l1_factor = None
        self.workspace_factor = None
        self.ub_factor = None
        self.out_w_align_factor = None

        self.hi_extent = None
        self.kh_extent = None
        self.kw_extent = None
        self.khkw_extent = None
        self.fractal_howo_extent = None

    def do_schedule(self):
        """
        do schedule

        Returns:
            schedule
        """
        self._do_create_schedule()
        self._sch.tiling_key = self._tiling_key

        self._do_cache_write()
        self._do_set_scope()
        self._do_buffer_align()
        self._do_storage_bound()
        self._set_var_range()
        self._do_compute_inline()
        self._do_tiling()
        self._do_multi_core()
        self._do_compute_at()
        self._do_double_buffer()
        self._do_set_constraint()
        self._do_buffer_tile()
        self._do_emit_insn()
        self._do_pragma()
        return self._sch

    # 'pylint: disable=too-many-statements,too-many-branches,too-many-locals,too-many-lines
    def _prepare_relative_params(self):
        self.graph_info = self.extract_image_patches_info.graph_info
        self.extract_params = self.extract_image_patches_info.extract_params
        self.setfmatrix_dict = self.extract_image_patches_info.setfmatrix_dict

        self.var_map = self.extract_image_patches_info.var_map
        self.ori_shape_range = self.extract_image_patches_info.ori_shape_range
        self.ori_cin_range = self.extract_image_patches_info.ori_cin_range
        self.is_const = self.extract_image_patches_info.is_const

        self.align_block_size = self.extract_image_patches_info.align_block_size
        self.type_size = self.extract_image_patches_info.type_size
        self.device_core_num = self.extract_image_patches_info.device_core_num
        self.out_h = self.extract_image_patches_info.out_h
        self.out_w = self.extract_image_patches_info.out_w
        self.padding_type = self.extract_image_patches_info.padding_type
        self.fmap_h = self.extract_image_patches_info.fmap_h
        self.fmap_w = self.extract_image_patches_info.fmap_w
        self.kernel_h = self.extract_image_patches_info.kernel_h
        self.kernel_w = self.extract_image_patches_info.kernel_w
        self.dilate_h = self.extract_image_patches_info.dilate_h
        self.dilate_w = self.extract_image_patches_info.dilate_w
        self.khkw = self.extract_image_patches_info.khkw
        self.dtype_input = self.extract_image_patches_info.dtype_input

    def _do_create_schedule(self):
        workspace_res = self.graph_info["workspace_res"]
        self.outs.append(workspace_res)
        self._sch = tvm.create_schedule(self.output_res.op)
        self.is_merge_subgraph = True

    def _do_cache_write(self):
        if self._tiling_case.is_ori_cin_align or self._tiling_case.ub_tiling_axis == len(self.output_res.shape) - 1:
            return
        self.use_reg_move = True
        self.reg_mov_ub = self._sch.cache_write(self.output_res, tbe_platform.scope_ubuf)

    def _do_set_scope(self):
        self._sch[self.graph_info["fmap_in_l1"]].set_scope(tbe_platform.scope_cbuf)
        self._sch[self.graph_info["fmap_fractal"]].set_scope(tbe_platform.scope_ubuf)
        self._sch[self.graph_info["split_c1_ub"]].set_scope(tbe_platform.scope_ubuf)
        self._sch[self.graph_info["transpose_ub"]].set_scope(tbe_platform.scope_ubuf)
        self._sch[self.graph_info["merge_hw_ub"]].set_scope(tbe_platform.scope_ubuf)
        self._sch[self.graph_info["merge_co_ub"]].set_scope(tbe_platform.scope_ubuf)
        self._sch[self.graph_info["ub_res"]].set_scope(tbe_platform.scope_ubuf)

    def _do_buffer_align(self):
        self._sch[self.graph_info["fmap_in_l1"]].buffer_align((1, 1), (1, 1), (1, 1), (1, 1),
                                                              (1, self.align_block_size))
        self._sch[self.graph_info["fmap_fractal"]].buffer_align((1, 1), (1, 1), (1, 1), (1, Constant.BLOCK_SIZE),
                                                                (1, self.align_block_size))
        self._sch[self.graph_info["split_c1_ub"]].buffer_align((1, 1), (1, 1), (1, 1), (1, 1), (1, Constant.BLOCK_SIZE),
                                                               (1, self.align_block_size))
        self._sch[self.graph_info["transpose_ub"]].buffer_align((1, 1), (1, 1), (1, Constant.BLOCK_SIZE), (1, 1),
                                                                (1, 1), (1, self.align_block_size))

        if self._tiling_case.is_ori_cin_align:
            return

        if not self._tiling_case.ori_cin_large_than_one_block_size:
            self._sch[self.graph_info["ub_res"]].buffer_align((1, 1), (1, 1), (1, 1), (1, self.align_block_size))
        else:
            self._sch[self.graph_info["ub_res"]].buffer_align((1, 1), (1, self.align_block_size))

    def _do_storage_bound(self):
        use_db_coef = 2 if self._tiling_case.is_db else 1
        l1_storage_bound = Constant.SIZE_L1 // self.type_size

        res_coexistingquantities = 2
        workspace_coexistingquantities = res_coexistingquantities
        if not self._tiling_case.is_ori_cin_align and \
                (self._tiling_case.ub_tiling_axis == (len(self.output_res.shape) - 1)):
            res_coexistingquantities = 1

        workspace_storage_bound = Constant.SIZE_UB // self.type_size // use_db_coef // workspace_coexistingquantities
        res_storage_bound = Constant.SIZE_UB // self.type_size // use_db_coef // res_coexistingquantities

        self._sch[self.graph_info["fmap_in_l1"]].set_buffer_size(l1_storage_bound)
        self._sch[self.graph_info["fmap_fractal"]].set_buffer_size(workspace_storage_bound)
        self._sch[self.graph_info["split_c1_ub"]].set_buffer_size(workspace_storage_bound)
        self._sch[self.graph_info["transpose_ub"]].set_buffer_size(workspace_storage_bound)
        self._sch[self.graph_info["merge_hw_ub"]].set_buffer_size(workspace_storage_bound)
        self._sch[self.graph_info["merge_co_ub"]].set_buffer_size(workspace_storage_bound)
        self._sch[self.graph_info["ub_res"]].set_buffer_size(res_storage_bound)

        if self.use_reg_move:
            self._sch[self.reg_mov_ub].set_buffer_size(res_storage_bound)

        self.res_ub_available_size = res_storage_bound
        self.workspace_ub_available_size = workspace_storage_bound
        self.l1_available_size = l1_storage_bound

    def _check_dilate_value(self, kernel_dilate, dim_idx):
        if not isinstance(kernel_dilate, int):
            return False
        if self.ori_shape_range[dim_idx][0] >= kernel_dilate:
            return False
        if self.ori_shape_range[dim_idx][1] is not None and self.ori_shape_range[dim_idx][1] < kernel_dilate:
            return False
        return True

    def _set_var_range(self):
        if not isinstance(self.var_map["fmap_n"], int):
            self._sch.set_var_range(self.var_map["fmap_n"], self.ori_shape_range[0][0], self.ori_shape_range[0][1])
        if not isinstance(self.var_map["fmap_h"], int):
            kernel_dilate_h = (self.kernel_h - 1) * self.dilate_h + 1
            if self.padding_type == VALID and self._check_dilate_value(kernel_dilate_h, 1):
                self.ori_shape_range[1][0] = kernel_dilate_h
            self._sch.set_var_range(self.var_map["fmap_h"], self.ori_shape_range[1][0], self.ori_shape_range[1][1])
        if not isinstance(self.var_map["fmap_w"], int):
            kernel_dilate_w = (self.kernel_w - 1) * self.dilate_w + 1
            if self.padding_type == VALID and self._check_dilate_value(kernel_dilate_w, 2):
                self.ori_shape_range[2][0] = kernel_dilate_w
            self._sch.set_var_range(self.var_map["fmap_w"], self.ori_shape_range[2][0], self.ori_shape_range[2][1])

        if not isinstance(self.var_map["origin_c_in"], int):
            c1_lower = (self.ori_cin_range[0] + self.align_block_size - 1) // self.align_block_size
            if self.ori_cin_range[1]:
                c1_upper = (self.ori_cin_range[1] + self.align_block_size - 1) // self.align_block_size
            else:
                c1_upper = self.ori_cin_range[1]
            if self._tiling_case.ori_cin_large_than_one_block_size and self._tiling_case.ub_tiling_axis == 0:
                self._sch.set_var_range(self.var_map["origin_c_in"], self.ori_cin_range[0], self.res_ub_available_size)
                if not isinstance(self.var_map["c1"], int):
                    self._sch.set_var_range(self.var_map["c1"], c1_lower,
                                            self.res_ub_available_size // self.align_block_size)
            elif self._tiling_case.ori_cin_large_than_one_block_size and self._tiling_case.ub_tiling_axis == 1:
                self._sch.set_var_range(self.var_map["origin_c_in"], self.res_ub_available_size // 2,
                                        self.ori_cin_range[1])
                if not isinstance(self.var_map["c1"], int):
                    self._sch.set_var_range(self.var_map["c1"],
                                            self.res_ub_available_size // (2 * self.align_block_size), c1_upper)
            else:
                self._sch.set_var_range(self.var_map["origin_c_in"], self.ori_cin_range[0], self.ori_cin_range[1])
                if not isinstance(self.var_map["c1"], int):
                    self._sch.set_var_range(self.var_map["c1"], c1_lower, c1_upper)

    def _do_tiling(self):
        self.l1_tiling_axis = self._tiling_case.l1_tiling_axis
        self.workspace_tiling_axis = self._tiling_case.workspace_tiling_axis
        self.ub_tiling_axis = self._tiling_case.ub_tiling_axis

        if self._tiling_case.block_nparts is not None:
            self.block_nparts = self._tiling_case.block_nparts
        else:
            self.block_nparts = var("block_nparts", (1, self.device_core_num))

        if self._tiling_case.l1_factor is not None:
            self.l1_factor = self._tiling_case.l1_factor
        else:
            self.l1_factor = var("l1_factor", (1, self.l1_available_size // self.align_block_size))

        if self._tiling_case.workspace_factor is not None:
            self.workspace_factor = self._tiling_case.workspace_factor
        else:
            self.workspace_factor = var("workspace_factor",
                                        (1, self.workspace_ub_available_size // self.align_block_size))

        if self._tiling_case.ub_factor is not None:
            self.ub_factor = self._tiling_case.ub_factor
        else:
            self.ub_factor = var("ub_factor", (1, self.res_ub_available_size // self.align_block_size))

        if self._tiling_case.out_w_align_factor is not None:
            self.out_w_align_factor = self._tiling_case.out_w_align_factor
        else:
            self.out_w_align_factor = var("out_w_align_factor", (1, self.l1_available_size // self.align_block_size))

        if self._tiling_case.is_ori_cin_align:
            self._do_tiling_align()
        elif not self._tiling_case.ori_cin_large_than_one_block_size:
            self._do_tiling_non_align_none_fuse_res_axis()
        else:
            self._do_tiling_non_align_fuse_res_axis()

    def _do_tiling_align(self):
        res_outer_split_axis = []
        res_inner_split_axis = []
        res_axis_list = list(self.output_res.op.axis).copy()

        res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[0], factor=1)
        res_outer_split_axis.append(res_axis_outer)
        res_inner_split_axis.append(res_axis_inner)

        c1_axis, c0_axis = self._sch[self.output_res].split(res_axis_list[3], factor=self.align_block_size)
        c1_axis_outer, c1_axis_inner = self._sch[self.output_res].split(c1_axis, factor=1)
        res_outer_split_axis.append(c1_axis_outer)
        res_inner_split_axis.append(c1_axis_inner)

        # howo split l1 tiling_axis, khkw split ub_tiling_axis
        if self.l1_tiling_axis != self.ub_tiling_axis:
            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.l1_tiling_axis],
                                                                              factor=self.l1_factor)
            res_axis_inner_outer, res_axis_inner_inner = self._sch[self.output_res].split(
                res_axis_inner, factor=self.out_w_align_factor)
            res_outer_split_axis.append(res_axis_outer)
            res_outer_split_axis.append(res_axis_inner_outer)
            res_inner_split_axis.append(res_axis_inner_inner)
            l1_at_axis = res_axis_outer

            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.ub_tiling_axis],
                                                                              factor=self.ub_factor)
            res_outer_split_axis.append(res_axis_outer)
            res_inner_split_axis.append(res_axis_inner)
            ub_at_axis = res_axis_outer
        elif self.l1_tiling_axis == self.ub_tiling_axis and self.ub_tiling_axis == 1:
            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.l1_tiling_axis],
                                                                              factor=self.l1_factor)
            res_axis_inner_outer, res_axis_inner_inner = self._sch[self.output_res].split(res_axis_inner,
                                                                                          factor=self.ub_factor)
            res_outer_split_axis.append(res_axis_outer)
            res_outer_split_axis.append(res_axis_inner_outer)
            res_inner_split_axis.append(res_axis_inner_inner)
            l1_at_axis = res_axis_outer
            ub_at_axis = res_axis_inner_outer

            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(
                res_axis_list[self.l1_tiling_axis + 1], factor=self.output_res.shape[self.l1_tiling_axis + 1])
            res_outer_split_axis.append(res_axis_outer)
            res_inner_split_axis.append(res_axis_inner)
        else:
            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.l1_tiling_axis - 1],
                                                                              factor=self.out_w_align_factor)
            res_outer_split_axis.append(res_axis_outer)
            res_inner_split_axis.append(res_axis_inner)

            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.l1_tiling_axis],
                                                                              factor=self.l1_factor)
            res_axis_inner_outer, res_axis_inner_inner = self._sch[self.output_res].split(res_axis_inner,
                                                                                          factor=self.ub_factor)
            res_outer_split_axis.append(res_axis_outer)
            res_outer_split_axis.append(res_axis_inner_outer)
            res_inner_split_axis.append(res_axis_inner_inner)
            l1_at_axis = res_axis_outer
            ub_at_axis = res_axis_inner_outer

        res_inner_split_axis.append(c0_axis)
        res_axis_all_list = res_outer_split_axis + res_inner_split_axis
        self._sch[self.output_res].reorder(*res_axis_all_list)

        ub_at_axis_index = res_axis_all_list.index(ub_at_axis)
        if ub_at_axis_index > 2:
            fuse_end_axis_index = 2
        else:
            fuse_end_axis_index = ub_at_axis_index
        fuse_axis_list = res_axis_all_list[:fuse_end_axis_index + 1]
        fuse_axis = self._sch[self.output_res].fuse(*fuse_axis_list)
        block_outer, block_inner = self._sch[self.output_res].split(fuse_axis, nparts=self.block_nparts)
        self.reorder_res_axis_list = [block_outer, block_inner] + res_axis_all_list[fuse_end_axis_index + 1:]

        if ub_at_axis_index <= 2:
            ub_at_axis = block_inner
        if l1_at_axis in fuse_axis_list:
            l1_at_axis = block_inner

        self.tiling_strategy[self.output_res] = dict()
        self.tiling_strategy[self.output_res]["l1_at_axis"] = l1_at_axis
        self.tiling_strategy[self.output_res]["ub_at_axis"] = ub_at_axis
        self.multi_core_map[self.output_res] = block_outer
        self.tiling_strategy[self.output_res]["ub_inner_axis"] = res_inner_split_axis[0]
        self.res_axis_all_list = res_axis_all_list

    def _do_tiling_non_align_fuse_res_axis(self):
        res_axis_list = list(self.output_res.op.axis).copy()

        workspace_res = self.graph_info["workspace_res"]
        workspace_res_outer_split_axis = []
        workspace_res_inner_split_axis = []
        workspace_res_axis_list = list(workspace_res.op.axis).copy()

        workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(workspace_res_axis_list[0],
                                                                                            factor=1)
        workspace_res_outer_split_axis.append(workspace_res_axis_outer)
        workspace_res_inner_split_axis.append(workspace_res_axis_inner)

        workspace_c1_axis, workspace_c0_axis = self._sch[workspace_res].split(workspace_res_axis_list[3],
                                                                              factor=self.align_block_size)
        workspace_c1_axis_outer, workspace_c1_axis_inner = self._sch[workspace_res].split(workspace_c1_axis, factor=1)
        workspace_res_outer_split_axis.append(workspace_c1_axis_outer)
        workspace_res_inner_split_axis.append(workspace_c1_axis_inner)

        # howo split l1 tiling_axis, khkw split ub_tiling_axis
        if self.l1_tiling_axis != self.workspace_tiling_axis:
            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.l1_tiling_axis], factor=self.l1_factor)
            workspace_res_axis_inner_outer, workspace_res_axis_inner_inner = self._sch[workspace_res].split(
                workspace_res_axis_inner, factor=self.out_w_align_factor)
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_outer_split_axis.append(workspace_res_axis_inner_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner_inner)
            l1_at_axis = workspace_res_axis_outer

            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.workspace_tiling_axis], factor=self.workspace_factor)
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner)
            workspace_at_axis = workspace_res_axis_outer
        elif self.l1_tiling_axis == self.workspace_tiling_axis and self.workspace_tiling_axis == 1:
            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.l1_tiling_axis], factor=self.l1_factor)
            workspace_res_axis_inner_outer, workspace_res_axis_inner_inner = self._sch[workspace_res].split(
                workspace_res_axis_inner, factor=self.workspace_factor)
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_outer_split_axis.append(workspace_res_axis_inner_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner_inner)
            l1_at_axis = workspace_res_axis_outer
            workspace_at_axis = workspace_res_axis_inner_outer

            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.l1_tiling_axis + 1], factor=workspace_res.shape[self.l1_tiling_axis + 1])
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner)
        else:
            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.l1_tiling_axis - 1], factor=self.out_w_align_factor)
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner)

            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.l1_tiling_axis], factor=self.l1_factor)
            workspace_res_axis_inner_outer, workspace_res_axis_inner_inner = self._sch[workspace_res].split(
                workspace_res_axis_inner, factor=self.workspace_factor)
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_outer_split_axis.append(workspace_res_axis_inner_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner_inner)
            l1_at_axis = workspace_res_axis_outer
            workspace_at_axis = workspace_res_axis_inner_outer

        workspace_res_inner_split_axis.append(workspace_c0_axis)
        workspace_res_axis_all_list = workspace_res_outer_split_axis + workspace_res_inner_split_axis
        self._sch[workspace_res].reorder(*workspace_res_axis_all_list)

        res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.ub_tiling_axis],
                                                                          factor=self.ub_factor)

        res_axis_all_list = res_axis_list[:self.ub_tiling_axis] + \
            [res_axis_outer, res_axis_inner] + res_axis_list[self.ub_tiling_axis+1:]
        res_fuse_axis = self._sch[self.output_res].fuse(*res_axis_all_list[:-2])

        res_block_outer, res_block_inner = self._sch[self.output_res].split(res_fuse_axis, nparts=self.block_nparts)

        if self.ub_tiling_axis == 0:
            self.reorder_res_axis_list = [res_block_outer, res_block_inner, res_axis_inner, res_axis_all_list[-1]]
            ub_at_axis = res_block_inner
        else:
            self.reorder_res_axis_list = [res_block_outer, res_block_inner, res_axis_outer, res_axis_inner]
            ub_at_axis = res_axis_outer

        self.reorder_workspace_axis_list = workspace_res_axis_all_list
        self.multi_core_map[self.output_res] = res_block_outer
        self.tiling_strategy[self.output_res] = dict()
        self.tiling_strategy[workspace_res] = dict()
        self.tiling_strategy[workspace_res]["l1_at_axis"] = l1_at_axis
        self.tiling_strategy[workspace_res]["workspace_at_axis"] = workspace_at_axis
        self.tiling_strategy[workspace_res]["workspace_inner_axis"] = workspace_res_inner_split_axis[0]
        self.tiling_strategy[self.output_res]["ub_at_axis"] = ub_at_axis
        self.tiling_strategy[self.output_res]["ub_inner_axis"] = res_axis_inner
        self.workspace_res = workspace_res
        self.workspace_res_axis_all_list = workspace_res_axis_all_list
        self.res_axis_all_list = res_axis_all_list

    def _do_tiling_non_align_none_fuse_res_axis(self):
        res_outer_split_axis = []
        res_inner_split_axis = []
        res_axis_list = list(self.output_res.op.axis).copy()

        workspace_res = self.graph_info["workspace_res"]
        workspace_res_outer_split_axis = []
        workspace_res_inner_split_axis = []
        workspace_res_axis_list = list(workspace_res.op.axis).copy()

        workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(workspace_res_axis_list[0],
                                                                                            factor=1)
        workspace_res_outer_split_axis.append(workspace_res_axis_outer)
        workspace_res_inner_split_axis.append(workspace_res_axis_inner)

        res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[0], factor=1)
        res_outer_split_axis.append(res_axis_outer)
        res_inner_split_axis.append(res_axis_inner)

        workspace_c1_axis, workspace_c0_axis = self._sch[workspace_res].split(workspace_res_axis_list[3],
                                                                              factor=self.align_block_size)
        workspace_c1_axis_outer, workspace_c1_axis_inner = self._sch[workspace_res].split(workspace_c1_axis, factor=1)
        workspace_res_outer_split_axis.append(workspace_c1_axis_outer)
        workspace_res_inner_split_axis.append(workspace_c1_axis_inner)

        res_c1_axis, res_c0_axis = self._sch[self.output_res].split(res_axis_list[3], factor=self.align_block_size)
        res_c1_axis_outer, res_c1_axis_inner = self._sch[self.output_res].split(res_c1_axis, factor=1)
        res_outer_split_axis.append(res_c1_axis_outer)
        res_inner_split_axis.append(res_c1_axis_inner)

        # howo split l1 tiling_axis, khkw split ub_tiling_axis
        if self.l1_tiling_axis != self.workspace_tiling_axis:
            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.l1_tiling_axis], factor=self.l1_factor)
            workspace_res_axis_inner_outer, workspace_res_axis_inner_inner = self._sch[workspace_res].split(
                workspace_res_axis_inner, factor=self.out_w_align_factor)
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_outer_split_axis.append(workspace_res_axis_inner_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner_inner)
            l1_at_axis = workspace_res_axis_outer

            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.workspace_tiling_axis], factor=self.workspace_factor)
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner)
            workspace_at_axis = workspace_res_axis_outer

            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.l1_tiling_axis],
                                                                              factor=self.l1_factor)
            res_axis_inner_outer, res_axis_inner_inner = self._sch[self.output_res].split(
                res_axis_inner, factor=self.out_w_align_factor)
            res_outer_split_axis.append(res_axis_outer)
            res_outer_split_axis.append(res_axis_inner_outer)
            res_inner_split_axis.append(res_axis_inner_inner)
            res_l1_at_axis = res_axis_outer

            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.workspace_tiling_axis],
                                                                              factor=self.workspace_factor)
            res_outer_split_axis.append(res_axis_outer)
            res_inner_split_axis.append(res_axis_inner)
            res_at_axis = res_axis_outer

        elif self.l1_tiling_axis == self.workspace_tiling_axis and self.workspace_tiling_axis == 1:
            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.l1_tiling_axis], factor=self.l1_factor)
            workspace_res_axis_inner_outer, workspace_res_axis_inner_inner = self._sch[workspace_res].split(
                workspace_res_axis_inner, factor=self.workspace_factor)
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_outer_split_axis.append(workspace_res_axis_inner_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner_inner)
            l1_at_axis = workspace_res_axis_outer
            workspace_at_axis = workspace_res_axis_inner_outer

            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.l1_tiling_axis + 1], factor=workspace_res.shape[self.l1_tiling_axis + 1])
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner)

            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.l1_tiling_axis],
                                                                              factor=self.l1_factor)
            res_axis_inner_outer, res_axis_inner_inner = self._sch[self.output_res].split(res_axis_inner,
                                                                                          factor=self.workspace_factor)
            res_outer_split_axis.append(res_axis_outer)
            res_outer_split_axis.append(res_axis_inner_outer)
            res_inner_split_axis.append(res_axis_inner_inner)
            res_l1_at_axis = res_axis_outer
            res_at_axis = res_axis_inner_outer

            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(
                res_axis_list[self.l1_tiling_axis + 1], factor=self.output_res.shape[self.l1_tiling_axis + 1])
            res_outer_split_axis.append(res_axis_outer)
            res_inner_split_axis.append(res_axis_inner)
        else:
            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.l1_tiling_axis - 1], factor=self.out_w_align_factor)
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner)

            workspace_res_axis_outer, workspace_res_axis_inner = self._sch[workspace_res].split(
                workspace_res_axis_list[self.l1_tiling_axis], factor=self.l1_factor)
            workspace_res_axis_inner_outer, workspace_res_axis_inner_inner = self._sch[workspace_res].split(
                workspace_res_axis_inner, factor=self.workspace_factor)
            workspace_res_outer_split_axis.append(workspace_res_axis_outer)
            workspace_res_outer_split_axis.append(workspace_res_axis_inner_outer)
            workspace_res_inner_split_axis.append(workspace_res_axis_inner_inner)
            l1_at_axis = workspace_res_axis_outer
            workspace_at_axis = workspace_res_axis_inner_outer

            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.l1_tiling_axis - 1],
                                                                              factor=self.out_w_align_factor)
            res_outer_split_axis.append(res_axis_outer)
            res_inner_split_axis.append(res_axis_inner)

            res_axis_outer, res_axis_inner = self._sch[self.output_res].split(res_axis_list[self.l1_tiling_axis],
                                                                              factor=self.l1_factor)
            res_axis_inner_outer, res_axis_inner_inner = self._sch[self.output_res].split(res_axis_inner,
                                                                                          factor=self.workspace_factor)
            res_outer_split_axis.append(res_axis_outer)
            res_outer_split_axis.append(res_axis_inner_outer)
            res_inner_split_axis.append(res_axis_inner_inner)
            res_l1_at_axis = res_axis_outer
            res_at_axis = res_axis_inner_outer

        workspace_res_inner_split_axis.append(workspace_c0_axis)
        res_inner_split_axis.append(res_c0_axis)

        workspace_res_axis_all_list = workspace_res_outer_split_axis + workspace_res_inner_split_axis
        self._sch[workspace_res].reorder(*workspace_res_axis_all_list)

        res_axis_all_list = res_outer_split_axis + res_inner_split_axis
        self._sch[self.output_res].reorder(*res_axis_all_list)

        res_l1_axis_index = res_axis_all_list.index(res_l1_at_axis)
        if res_l1_axis_index > 2:
            fuse_end_axis_index = 2
        else:
            fuse_end_axis_index = res_l1_axis_index
        res_fuse_axis_list = res_axis_all_list[:fuse_end_axis_index + 1]
        res_fuse_axis = self._sch[self.output_res].fuse(*res_fuse_axis_list)
        res_block_outer, res_block_inner = self._sch[self.output_res].split(res_fuse_axis, nparts=self.block_nparts)
        if res_l1_at_axis in res_fuse_axis_list:
            res_l1_at_axis = res_block_inner
        self.reorder_workspace_axis_list = workspace_res_axis_all_list
        self.reorder_res_axis_list = [res_block_outer, res_block_inner] + res_axis_all_list[fuse_end_axis_index + 1:]

        self.multi_core_map[self.output_res] = res_block_outer
        self.tiling_strategy[self.output_res] = dict()
        self.tiling_strategy[workspace_res] = dict()
        self.tiling_strategy[workspace_res]["l1_at_axis"] = l1_at_axis
        self.tiling_strategy[workspace_res]["workspace_at_axis"] = workspace_at_axis
        self.tiling_strategy[workspace_res]["workspace_inner_axis"] = workspace_res_inner_split_axis[0]
        self.tiling_strategy[self.output_res]["ub_at_axis"] = res_at_axis
        self.tiling_strategy[self.output_res]["res_l1_at_axis"] = res_l1_at_axis
        self.tiling_strategy[self.output_res]["ub_inner_axis"] = res_inner_split_axis[0]
        self.workspace_res = workspace_res
        self.workspace_res_axis_all_list = workspace_res_axis_all_list
        self.res_axis_all_list = res_axis_all_list

    def _do_multi_core(self):
        block_idx = tvm.thread_axis(BLOCK_IDX)
        for tensor, bind_axis in self.multi_core_map.items():
            self._sch[tensor].bind(bind_axis, block_idx)

    def _do_compute_inline(self):
        if self._tiling_case.is_ori_cin_align:
            self._sch[self.graph_info["workspace_res"]].compute_inline()
            self._sch[self.graph_info["ub_res"]].compute_inline()
        self._sch[self.graph_info["merge_co_ub"]].compute_inline()
        self._sch[self.graph_info["merge_hw_ub"]].compute_inline()
        self._sch[self.graph_info["split_c1_ub"]].compute_inline()

    def _do_compute_at(self):
        if self._tiling_case.is_ori_cin_align:
            l1_at_axis = self.tiling_strategy[self.output_res]["l1_at_axis"]
            ub_at_axis = self.tiling_strategy[self.output_res]["ub_at_axis"]
            # l1 tensor
            self._sch[self.graph_info["fmap_in_l1"]].compute_at(self._sch[self.output_res], l1_at_axis)

            # ub tensor
            self._sch[self.graph_info["transpose_ub"]].compute_at(self._sch[self.output_res], ub_at_axis)
            self._sch[self.graph_info["fmap_fractal"]].compute_at(self._sch[self.output_res], ub_at_axis)
        else:
            l1_at_axis = self.tiling_strategy[self.workspace_res]["l1_at_axis"]
            workspace_at_axis = self.tiling_strategy[self.workspace_res]["workspace_at_axis"]
            ub_at_axis = self.tiling_strategy[self.output_res]["ub_at_axis"]
            # l1 tensor
            self._sch[self.graph_info["fmap_in_l1"]].compute_at(self._sch[self.workspace_res], l1_at_axis)

            # ub tensor before  workspace tensor
            self._sch[self.graph_info["transpose_ub"]].compute_at(self._sch[self.workspace_res], workspace_at_axis)
            self._sch[self.graph_info["fmap_fractal"]].compute_at(self._sch[self.workspace_res], workspace_at_axis)

            # ub tensor after  workspace tensor
            self._sch[self.graph_info["ub_res"]].compute_at(self._sch[self.output_res], ub_at_axis)
            if self.use_reg_move:
                if not self._tiling_case.ori_cin_large_than_one_block_size and \
                        self._tiling_case.ub_tiling_axis == KHKW_AXIS_INDEX:
                    self._sch[self.reg_mov_ub].storage_align(self.reg_mov_ub.op.axis[-3], self.align_block_size, 0)
                self._sch[self.reg_mov_ub].compute_at(self._sch[self.output_res], ub_at_axis)
            if self.is_merge_subgraph:
                if not self._tiling_case.ori_cin_large_than_one_block_size:
                    workspace_res_at_axis = self.tiling_strategy[self.output_res]["res_l1_at_axis"]
                else:
                    workspace_res_at_axis = self.reorder_res_axis_list[0]
                self._sch[self.workspace_res].compute_at(self._sch[self.output_res], workspace_res_at_axis)

    def _do_double_buffer(self):
        if not self._tiling_case.is_db:
            return
        self._sch[self.graph_info["fmap_in_l1"]].double_buffer()
        self._sch[self.graph_info["transpose_ub"]].double_buffer()
        self._sch[self.graph_info["fmap_fractal"]].double_buffer()

        if not self._tiling_case.is_ori_cin_align:
            self._sch[self.graph_info["ub_res"]].double_buffer()

        if self.use_reg_move:
            self._sch[self.reg_mov_ub].double_buffer()

    def _do_set_constraint(self):
        if self.is_const:
            return
        if self.padding_type == VALID and not (isinstance(self.fmap_h, int)
                                               or isinstance(self.fmap_h, tvm.tir.IntImm)):
            self._sch.set_constraint(self.fmap_h >= self.kernel_h)
        if self.padding_type == VALID and not (isinstance(self.fmap_w, int)
                                               or isinstance(self.fmap_w, tvm.tir.IntImm)):
            self._sch.set_constraint(self.fmap_w >= self.kernel_w)
        if not (isinstance(self.out_h, int) or isinstance(self.out_h, tvm.tir.IntImm)):
            self._sch.set_constraint(self.out_h >= 1)
        if not (isinstance(self.out_w, int) or isinstance(self.out_w, tvm.tir.IntImm)):
            self._sch.set_constraint(self.out_w >= 1)

        if self._tiling_case.is_ori_cin_align:
            if not isinstance(self.ub_factor, int) and self.ub_tiling_axis == KHKW_AXIS_INDEX:
                self._sch.set_constraint(self.ub_factor <= self.kernel_h * self.kernel_w)
        else:
            if not isinstance(self.workspace_factor, int) and self.workspace_tiling_axis == KHKW_AXIS_INDEX:
                self._sch.set_constraint(self.workspace_factor <= self.kernel_h * self.kernel_w)

    def _do_buffer_tile(self):
        if self._tiling_case.is_ori_cin_align:
            if not (self.l1_tiling_axis == self.ub_tiling_axis and self.ub_tiling_axis == KHKW_AXIS_INDEX):
                return
        else:
            if not (self.l1_tiling_axis == self.workspace_tiling_axis and \
                    self.workspace_tiling_axis == KHKW_AXIS_INDEX):
                return

        padding_h_before = get_context().get("padding_h_before")
        padding_h_after = get_context().get("padding_h_after")

        self.hi_extent = tvm.select(
            Constant.SIZE_L1 / self.type_size / self.align_block_size / self.fmap_w > self.fmap_h,
            self.fmap_h + padding_h_before + padding_h_after,
            Constant.SIZE_L1 / self.type_size / self.align_block_size / self.fmap_w)

        self.fractal_howo_extent = tvm.floordiv(self.out_w_align_factor + Constant.BLOCK_SIZE - 1, Constant.BLOCK_SIZE)

        khkw_factor = self.ub_factor if self._tiling_case.is_ori_cin_align else self.workspace_factor
        self.kh_extent = tvm.select(khkw_factor > self.kernel_w, tvm.floordiv(khkw_factor, self.kernel_w), 1)
        self.kw_extent = tvm.select(khkw_factor > self.kernel_w, self.kernel_w, khkw_factor)
        self.khkw_extent = khkw_factor
        self._sch[self.graph_info["fmap_in_l1"]].buffer_tile((None, None), (None, 1), (None, self.hi_extent),
                                                             (None, None), (None, None))
        self._sch[self.graph_info["fmap_fractal"]].buffer_tile((None, None), (None, self.fractal_howo_extent),
                                                               (None, self.khkw_extent), (None, None), (None, None))

    def _do_emit_insn(self):
        ub_inner_axis = self.tiling_strategy[self.output_res]["ub_inner_axis"]
        self._sch[self.graph_info["fmap_in_l1"]].emit_insn(self.graph_info["fmap_in_l1"].op.axis[0],
                                                           te_platform.DMA_COPY)
        self._sch[self.graph_info["fmap_fractal"]].emit_insn(self.graph_info["fmap_fractal"].op.axis[0], "im2col_v2",
                                                             self.setfmatrix_dict)

        if self._tiling_case.use_dma_no_overlap:
            self._sch[self.output_res].emit_insn(ub_inner_axis, te_platform.DMA_COPY,
                                                 {"no_overlap": "process_data_smaller_than_one_block_by_calcute_index"})
        elif not self._tiling_case.is_ori_cin_align:
            self._sch[self.output_res].emit_insn(ub_inner_axis, te_platform.DMA_COPY, {"no_overlap": "default"})
        else:
            self._sch[self.output_res].emit_insn(ub_inner_axis, te_platform.DMA_COPY)

        if self._tiling_case.is_ori_cin_align:
            self._sch[self.graph_info["transpose_ub"]].emit_insn(self.graph_info["transpose_ub"].op.axis[0],
                                                                 te_platform.DMA_COPY)
            return

        if self.dtype_input in ("int8", "uint8"):
            self._sch[self.graph_info["transpose_ub"]].emit_insn(self.graph_info["transpose_ub"].op.axis[0],
                                                                 te_platform.DMA_COPY)
        else:
            self._sch[self.graph_info["transpose_ub"]].emit_insn(self.graph_info["transpose_ub"].op.axis[0],
                                                                 te_platform.insn_cmd.ADDVS)

        workspace_inner_axis = self.tiling_strategy[self.workspace_res]["workspace_inner_axis"]
        self._sch[self.workspace_res].emit_insn(workspace_inner_axis, te_platform.DMA_COPY)
        self._sch[self.graph_info["ub_res"]].emit_insn(self.graph_info["ub_res"].op.axis[0], te_platform.DMA_COPY)

        if self.use_reg_move:
            if self._tiling_case.ori_cin_as_one_special_type:
                self._sch[self.reg_mov_ub].emit_insn(self.reg_mov_ub.op.axis[0], "vector_reduce_sum")
            else:
                self._sch[self.reg_mov_ub].emit_insn(self.reg_mov_ub.op.axis[0], te_platform.DATA_MOV)

    def _do_pragma(self):
        if self.is_const:
            return

        append_id = tvm.call_extern("int32", "axis_group", 1, "append")

        for _, axis in enumerate(self.graph_info["fmap_in_l1"].op.axis):
            self._sch[self.graph_info["fmap_in_l1"]].pragma(axis, "axis_group", append_id)

        if self._tiling_case.ub_tiling_axis == KHKW_AXIS_INDEX:
            if not self._tiling_case.ori_cin_large_than_one_block_size:
                res_axis_group_axis_list = self.reorder_res_axis_list[-2:]
            else:
                res_axis_group_axis_list = []
            if not self._tiling_case.is_ori_cin_align:
                workspace_axis_group_axis_list = self.reorder_workspace_axis_list[-2:]
            else:
                workspace_axis_group_axis_list = []
        elif self.khkw == 1:
            if not self._tiling_case.ori_cin_large_than_one_block_size:
                res_axis_group_axis_list = [self.reorder_res_axis_list[-3], self.reorder_res_axis_list[-1]]
            else:
                res_axis_group_axis_list = []
            if not self._tiling_case.is_ori_cin_align:
                workspace_axis_group_axis_list = [
                    self.reorder_workspace_axis_list[-3], self.reorder_workspace_axis_list[-1]
                ]
            else:
                workspace_axis_group_axis_list = []
        else:
            if not self._tiling_case.ori_cin_large_than_one_block_size:
                res_axis_group_axis_list = self.reorder_res_axis_list[-3:]
            else:
                res_axis_group_axis_list = []
            if not self._tiling_case.is_ori_cin_align:
                workspace_axis_group_axis_list = self.reorder_workspace_axis_list[-3:]
            else:
                workspace_axis_group_axis_list = []

        for _, axis in enumerate(res_axis_group_axis_list):
            self._sch[self.output_res].pragma(axis, "axis_group", append_id)

        if self._tiling_case.is_ori_cin_align:
            return

        for _, axis in enumerate(workspace_axis_group_axis_list):
            self._sch[self.workspace_res].pragma(axis, "axis_group", append_id)
        for _, axis in enumerate(self.graph_info["ub_res"].op.axis):
            self._sch[self.graph_info["ub_res"]].pragma(axis, "axis_group", append_id)
