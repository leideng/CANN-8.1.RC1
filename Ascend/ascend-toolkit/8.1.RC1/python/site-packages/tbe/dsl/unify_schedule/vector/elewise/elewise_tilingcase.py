#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
elewise tiling case
"""
from enum import Enum
from enum import auto
from typing import Optional
from tbe.dsl.base import operation
from tbe.dsl.base.operation import get_op_context
from tbe.dsl.base.operation import register_build_pointcut
from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.platform import SHORT_SOC_VERSION

from ... import util
from ...computation import Computation
from ...constants import CompileInfo
from ...constants import DTYPE_BYTE_MAPPING
from ...constants import ElewisePattern
from ...constants import Pattern


class ConstParams:
    """
    elewise tilingcase const params
    """
    DEFAULT = "default"
    STATIC = "static"

    COMMON_BLOCK_SIZE = 32
    BLOCK_TILING_AXIS = 2
    BLOCK_VAR_CONST = 20000
    DB_FACTOR = 2
    DB_KEY = 10000
    NB_KEY = 20000
    DIM_INDEX = 1
    DIM_INDEX_CONST = 100
    INPUT_INDEX = 2
    INT32_MAX = 2147483647
    ORI_DIM_VAR_CONST = 40000
    PATTERN_DIV_VALUE = 1000
    PATTERN_LEN = 3
    SHAPE_VAR_CONST = 10000
    TILING_DIV_VALUE = 100000
    UB_TILING_AXIS = 2
    UB_VAR_CONST = 30000
    N_BUFFER_COEXISTING_QUANTITY = 5
    N_BUFFER_DIV_VALUE = 10000


class ClassifyMode:
    """
    ClassifyMode
    """
    ALL_FUSE = "all_fuse"
    CONST = "const"
    EMPTY = "empty"
    DISABLE_FUSE = "disable_fuse"


class ClassifyPattern:
    """
    ClassifyPattern
    """
    BROADCAST_SCALAR = "broadcast_scalar"
    CONST_SHAPE_DIFF = "const_shape_diff"
    CONST_SHAPE_SAME = "const_shape_same"
    DISABLE_FUSE = "disable_fuse"
    EMPTY = "empty"
    FRACTAL_FORMAT = "fractal_format"
    ONE_RANK = "one_rank"
    PURE_ELEWISE = "pure_elewise"
    SCALAR_BROADCAST = "scalar_broadcast"


class TilingStrategy(Enum):
    """
    TilingStrategy
    """
    ALL_FUSE = auto()
    CONST = auto()
    EMPTY = auto()
    DISABLE_FUSE = auto()
    STATIC = auto()


BASE_MODE_KEY = {
    ClassifyMode.ALL_FUSE: {ClassifyPattern.PURE_ELEWISE: 210000000,
                            ClassifyPattern.BROADCAST_SCALAR: 223000000,
                            ClassifyPattern.SCALAR_BROADCAST: 232000000,
                            ClassifyPattern.ONE_RANK: 220000000},
    ClassifyMode.CONST: {ClassifyPattern.CONST_SHAPE_DIFF: 100000000,
                         ClassifyPattern.CONST_SHAPE_SAME: 100000000},
    ClassifyMode.EMPTY: {ClassifyPattern.EMPTY: 2147483647},
    ClassifyMode.DISABLE_FUSE: {ClassifyPattern.FRACTAL_FORMAT: 211100000,
                                ClassifyPattern.DISABLE_FUSE: 244400000}
}


def is_nb_key(tiling_key):
    """
    check if the tiling key is nb key
    """
    _pattern_key = tiling_key % ConstParams.TILING_DIV_VALUE
    if (_pattern_key // ConstParams.N_BUFFER_DIV_VALUE * ConstParams.N_BUFFER_DIV_VALUE) == ConstParams.NB_KEY:
        return True
    return False


def get_pattern_key(tiling_key):
    """
    elewise pattern key calculation
    """
    _pattern_key = tiling_key // ConstParams.TILING_DIV_VALUE % ConstParams.PATTERN_DIV_VALUE
    if is_nb_key(tiling_key):
        _pattern_key += 1
    return str(_pattern_key).ljust(ConstParams.PATTERN_LEN, '0')


def calc_elewise_base_info(sch_context, base_info):
    """
    set elewise base info of each tiling_key for tiling
    """
    block_size_bytes = util.get_ub_block_size()
    cur_ub_size = sch_context.get(CompileInfo.UB_SIZE)
    cur_max_dtype_size = sch_context.get(CompileInfo.MAX_DTYPE)
    cur_coexisting_quantity = sch_context.get(CompileInfo.COEXISTING_QUANTITY)
    cur_core_num = sch_context.get(CompileInfo.CORE_NUM)
    pattern_key = get_pattern_key(sch_context.get("_tiling_key"))

    max_available_ub = (((cur_ub_size // cur_coexisting_quantity) // block_size_bytes) *
                        block_size_bytes) // cur_max_dtype_size
    max_available_ub_db = (((cur_ub_size // ConstParams.DB_FACTOR // cur_coexisting_quantity) //
                            block_size_bytes) * block_size_bytes) // cur_max_dtype_size
    default_base_info = [cur_core_num, cur_max_dtype_size, max_available_ub, max_available_ub_db]
    last_base_info = base_info.get(pattern_key, default_base_info)
    base_info[pattern_key] = [max(cur_core_num, last_base_info[0]),
                                max(cur_max_dtype_size, last_base_info[1]),
                                min(max_available_ub, last_base_info[2]),
                                min(max_available_ub_db, last_base_info[3])]


def elewise_vars_to_int(_var_names):
    """
    translate string format vars into nums
    """
    var_nums = []
    for name in _var_names:
        if name[0] != '_':
            continue
        names = name[1:].split('_')
        if names[0] == 'dim':
            var_nums.append(ConstParams.SHAPE_VAR_CONST +
                            int(names[ConstParams.DIM_INDEX]) * ConstParams.DIM_INDEX_CONST +
                            int(names[ConstParams.INPUT_INDEX]))
        elif names[0] == 'block':
            var_nums.append(ConstParams.BLOCK_VAR_CONST + int(names[ConstParams.BLOCK_TILING_AXIS]))
        elif names[0] == 'ub':
            var_nums.append(ConstParams.UB_VAR_CONST + int(names[ConstParams.UB_TILING_AXIS]))
        elif names[0] == 'ori':
            var_nums.append(ConstParams.ORI_DIM_VAR_CONST)
    return var_nums


def dfs_sub_graph(input_tensors: set, dtypes: list, out, visited_tensors: set):
    for tensor_i in out.op.input_tensors:
        if util.is_placeholder(tensor_i):
            input_tensors.add(tensor_i)
            dtypes.append(tensor_i.dtype)
        if tensor_i in visited_tensors:
            continue
        visited_tensors.add(tensor_i)
        dfs_sub_graph(input_tensors, dtypes, tensor_i, visited_tensors)


# noinspection PyMethodMayBeStatic
class ElewiseComputation(Computation):
    """
    ElewiseComputation
    """

    def __init__(self, outs, option):
        self.outs = list(outs) if isinstance(outs, (list, tuple)) else [outs]
        self.option = option

    def do_tiling_case(self):
        """calculate and set elewise tiling res for each tilingcase for corresponding schedule
        Returns:
            list: tiling case res
        Raises:
            RuntimeError: error occurred when getting wrong mode.
        """
        # get the max output len and dtype
        max_len = max(len(out.shape) for out in self.outs)
        max_dtype = max(DTYPE_BYTE_MAPPING.get(out.dtype) for out in self.outs)

        # elewise all computes exist attrs of mode and pattern
        mode = operation.get_context().get_current_compute().get("_mode")
        pattern = operation.get_context().get_current_compute().get(CompileInfo.PATTERN)
        base_key = BASE_MODE_KEY.get(mode).get(pattern)

        # calculate tiling by classify mode
        if mode == ClassifyMode.ALL_FUSE:
            return self._calc_all_fuse_tiling_case(base_key, max_dtype, self._default_db_func, self._nb_func)
        if mode == ClassifyMode.CONST or operation.get_context().get_mode() == ConstParams.STATIC:
            return self._calc_const_tiling_case(base_key, max_len)
        if mode == ClassifyMode.EMPTY:
            return self._calc_empty_tiling_case()
        if mode == ClassifyMode.DISABLE_FUSE:
            return self._calc_disable_fuse_tiling_case(base_key, max_len, self._default_db_func, self._nb_func)
        return []

    def get_sub_pattern(self):
        return ElewisePattern.E_0

    @classmethod
    def get_instance(cls, outs, option):
        return cls(outs, option)

    @classmethod
    def get_supported_pattern(cls):
        return [Pattern.ELEMWISE]

    @classmethod
    def get_supported_soc(cls):
        return [ConstParams.DEFAULT]

    def _default_db_func(self):
        return True

    def _nb_func(self):
        visited_tensors = set()
        input_tensors = set()
        dtypes = []
        for tensor_i in self.outs:
            dfs_sub_graph(input_tensors, dtypes, tensor_i, visited_tensors)
            dtypes.append(tensor_i.dtype)
        op_info = get_op_context().get_op_info()
        if op_info and len(op_info) == 1:
            op_type = op_info[0].op_type
            if op_type in ("Add", "Mul") and all(dtype == "bfloat16" for dtype in dtypes):
                operation.add_compile_info_inner("_can_enable_n_buffer", True)
                return True
        return False

    def _calc_all_fuse_tiling_case(self, base_key, dtype, enable_db_func, enable_nb_func):
        dounds_factor = util.get_ub_block_size() / ConstParams.COMMON_BLOCK_SIZE
        type_dounds = {
            1: (1, int(32767 * dounds_factor)),
            2: (1, int(32767 * dounds_factor)),
            4: (1, int(16383 * dounds_factor)),
            8: (1, int(8191 * dounds_factor)),
        }
        tiling_case = []
        all_fuse_tiling_case = ElewiseTilingCase()
        all_fuse_tiling_case.set_all_fuse_tiling_case(base_key, type_dounds.get(DTYPE_BYTE_MAPPING.get(dtype)))
        tiling_case.append(all_fuse_tiling_case)

        if enable_nb_func():
            all_fuse_nb_tiling_case = ElewiseTilingCase()
            all_fuse_nb_tiling_case.set_all_fuse_tiling_case(base_key + ConstParams.NB_KEY,
                                                             type_dounds.get(DTYPE_BYTE_MAPPING.get(dtype)),
                                                             enable_db=False, enable_nb=True)
            tiling_case.append(all_fuse_nb_tiling_case)

        if enable_db_func():
            all_fuse_db_tiling_case = ElewiseTilingCase()
            all_fuse_db_tiling_case.set_all_fuse_tiling_case(base_key + ConstParams.DB_KEY,
                                                             type_dounds.get(DTYPE_BYTE_MAPPING.get(dtype)),
                                                             enable_db=True, enable_nb=False)
            tiling_case.append(all_fuse_db_tiling_case)

        return tiling_case

    def _calc_const_tiling_case(self, base_key, dim_len):
        base_key = operation.get_context().get("_elewise_const_base_key") or base_key
        const_tiling_case = ElewiseTilingCase()
        const_tiling_case.set_const_tiling_case(base_key, dim_len == 1)
        operation.get_context().add("_elewise_const_base_key", base_key + 1)
        return [const_tiling_case]

    def _calc_disable_fuse_tiling_case(self, base_key, dim_len, enable_db_func, enable_nb_func):
        tiling_case = []
        # do split
        block_axis = 0
        for index in range(dim_len):
            tiling_key = base_key + block_axis * dim_len + index
            disable_fuse_case = ElewiseTilingCase()
            disable_fuse_case.set_disable_fuse_tiling_case(tiling_key, block_axis, index, dim_len == 1)
            tiling_case.append(disable_fuse_case)

            if enable_db_func():
                tiling_key = base_key + block_axis * dim_len + index + ConstParams.DB_KEY
                disable_fuse_db_case = ElewiseTilingCase()
                disable_fuse_db_case.set_disable_fuse_tiling_case(tiling_key,
                                                                  block_axis,
                                                                  index,
                                                                  dim_len == 1,
                                                                  enable_db=True,
                                                                  enable_nb=False)
                tiling_case.append(disable_fuse_db_case)

            if enable_nb_func():
                tiling_key = base_key + block_axis * dim_len + index + ConstParams.NB_KEY
                disable_fuse_nb_case = ElewiseTilingCase()
                disable_fuse_nb_case.set_disable_fuse_tiling_case(tiling_key,
                                                                  block_axis,
                                                                  index,
                                                                  dim_len == 1,
                                                                  enable_db=False,
                                                                  enable_nb=True)
                tiling_case.append(disable_fuse_nb_case)
        return tiling_case

    def _calc_empty_tiling_case(self):
        empty_tiling_case = ElewiseTilingCase()
        empty_tiling_case.set_const_tiling_case(ConstParams.INT32_MAX)
        return [empty_tiling_case]


def _pre_build():
    """
    elewise schedule pre build for adding compile infos such as digital base_info for tiling
    """
    def _add_const_compile_info():
        const_shapes, const_block_dims = [], []
        for const_compute in cpt_computes:
            const_shapes.append(const_compute.get("_elewise_const_shape"))
            const_block_dims.append(const_compute.get("_elewise_const_block_dim"))
        operation.add_compile_info_inner(CompileInfo.ELEWISE_CONST_DIMS, const_block_dims)
        operation.add_compile_info_inner(CompileInfo.ELEWISE_CONST_SHAPES, const_shapes)

    def _add_dynamic_compile_info():
        """
        collecting all variable in 3-level context(op, compute, schedule) and translating these vars into nums
        """
        base_info = {}
        compile_vars = {}
        for cpt in cpt_computes:
            if cpt.get("_mode") == ClassifyMode.EMPTY or len(cpt.get_schedules()) == 0:
                continue
            for sch_context in cpt.get_schedules():
                # rl search
                if sch_context.get("sch_pattern") == "rl_sch":
                    continue
                # collect tiling info for each pattern
                calc_elewise_base_info(sch_context, base_info)

                # collect all vars for numeralization including op_vars, compute_vars and schedule_vars
                te_vars = operation.get_context().get_vars() + cpt.get_vars() + sch_context.get_vars()
                var_names = [x.get_name() for x in te_vars]
                compile_vars[sch_context.get("_tiling_key")] = elewise_vars_to_int(var_names)

        if base_info:
            operation.add_compile_info_inner(CompileInfo.BASE_INFO, base_info)

        if compile_vars:
            operation.add_compile_info_inner(CompileInfo.ELEWISE_VARS, compile_vars)

    def _set_special_build_config():
        # add build config
        operation.add_build_arg("double_buffer_non_reuse", True)
        # close double calculation switch
        operation.add_build_arg("enable_vector_2x", False)
        # enable_s64_to_s32: in register base mode, pass will recognize VF paras as int32 even if para dtype is int32
        operation.add_build_arg("enable_s64_to_s32", True)
        # if enable mask count, schedule use mask counter mode
        if util.is_v220():
            operation.add_build_arg("enable_mask_counter_mode", "default_counter")

    _set_special_build_config()

    # is_const_shapes: judge whether all unknown shapes inferable
    is_const_shapes = False
    cpt_computes = operation.get_context().get_computes()
    for cpt in cpt_computes:
        classify_mode = cpt.get("_mode")
        if classify_mode == ClassifyMode.CONST:
            is_const_shapes = True

    operation.add_compile_info_inner(CompileInfo.IS_CONST_SHAPES, is_const_shapes)
    operation.add_compile_info_inner("_enable_vector_core", get_soc_spec(SHORT_SOC_VERSION) == "Ascend310P")
    if is_const_shapes:
        _add_const_compile_info()
    else:
        _add_dynamic_compile_info()


@register_build_pointcut(pattern=Pattern.ELEMWISE)
def build_pointcut(func, *args, **kwargs):
    """
    build pointcut
    """
    _pre_build()
    func(*args, **kwargs)


class ElewiseTilingCase:
    """
    Elewise Tiling Case
    """

    def __init__(self):
        self._tiling_key = ConstParams.INT32_MAX
        self._tiling_strategy: Optional[Enum] = None
        self._block_split_axis = None
        self._ub_split_axis = None
        self._ub_factor_bound = None
        self._enable_db = False
        self._enable_nb = False
        self._is_one_dim = False

    @property
    def tiling_key(self):
        """
        elewise tiling_key for schedule
        """
        return self._tiling_key

    @property
    def tiling_strategy(self):
        """
        elewise tiling_strategy for schedule
        """
        return self._tiling_strategy

    @property
    def block_split_axis(self):
        """
        elewise block_split_axis for schedule
        """
        return self._block_split_axis

    @property
    def ub_split_axis(self):
        """
        elewise ub_split_axis for schedule
        """
        return self._ub_split_axis

    @property
    def ub_factor_bound(self):
        """
        elewise ub_factor_bound for schedule
        """
        return self._ub_factor_bound

    @property
    def enable_db(self):
        """
        elewise enable_db for schedule
        """
        return self._enable_db

    @property
    def enable_nb(self):
        """
        elewise enable_nb for schedule
        """
        return self._enable_nb

    @property
    def is_one_dim(self):
        """
        elewise is_one_dim for schedule
        """
        return self._is_one_dim

    def set_const_tiling_case(self, key, is_one_dim=False):
        """
        set const tiling case
        """
        self._tiling_strategy = TilingStrategy.CONST
        self._tiling_key = key
        self._is_one_dim = is_one_dim

    def set_all_fuse_tiling_case(self, key, ub_factor_bound, enable_db=False, enable_nb=False):
        """
        set all fuse tiling case
        """
        self._tiling_strategy = TilingStrategy.ALL_FUSE
        self._tiling_key = key
        self._block_split_axis = 0
        self._ub_split_axis = 0
        self._ub_factor_bound = ub_factor_bound
        self._enable_db = enable_db
        self._enable_nb = enable_nb
        self._is_one_dim = True

    def set_disable_fuse_tiling_case(self, key, block_split_axis, ub_split_axis,
                                     is_one_dim=False, enable_db=False, enable_nb=False):
        """
        set partial fuse tiling case
        """
        self._tiling_strategy = TilingStrategy.DISABLE_FUSE
        self._tiling_key = key
        self._block_split_axis = block_split_axis
        self._ub_split_axis = ub_split_axis
        self._enable_db = enable_db
        self._enable_nb = enable_nb
        self._is_one_dim = is_one_dim
