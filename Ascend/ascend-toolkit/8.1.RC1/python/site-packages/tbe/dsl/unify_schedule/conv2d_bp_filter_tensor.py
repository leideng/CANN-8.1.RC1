#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
dw tensor util
"""
from tbe.dsl.compute.conv2d_backprop_filter_compute import DynamicConv2dBpFilterParams

from .cube_tensor import TensorCube


class TensorConv2dBackPropFilter(TensorCube):
    """
    use to get tensor for dw
    """

    def __init__(self, res_list):
        super().__init__(res_list)
        self._init_tensor_map()

    def get_tensor_and_para_map(self):
        """
        get the tensor and para for matmul
        """
        return [*self.all_tensor, self.tensor_map, self.para_map]

    def _init_tensor_map(self):
        if self.last_tensor.op.tag == "FZ_trans_NHWC":
            self.tensor_map["dw_ddr"] = self.last_tensor.op.input_tensors[0]
        else:
            self.tensor_map["dw_ddr"] = self.last_tensor

        if self.tensor_map.get("dw_ddr").op.tag == "conv2d_backprop_filter_c_split":
            self.tensor_map["dw_cc"] = self.tensor_map.get("dw_ddr").op.input_tensors[0]
        elif self.tensor_map.get("dw_ddr").op.tag == "fixpipe_reform":
            fixpipe_tensor = self.tensor_map.get("dw_ddr").op.input_tensors[0]
            self.tensor_map["dw_cc"] = fixpipe_tensor.op.input_tensors[0]
        else:
            self.tensor_map["dw_cc"] = self.tensor_map.get("dw_ddr")

        self.tensor_map["grads_fractal"] = self.tensor_map.get("dw_cc").op.input_tensors[0]
        self.tensor_map["grads_matrix"] = self.tensor_map.get("grads_fractal").op.input_tensors[0]
        self.tensor_map["grads"] = self.tensor_map.get("grads_matrix").op.input_tensors[0]
        self.tensor_map["fmap_fractal"] = self.tensor_map.get("dw_cc").op.input_tensors[1]
        if self.tensor_map.get("fmap_fractal").op.tag == "fmap_2_fractal_dma":
            fmap_fractal_before = self.tensor_map.get("fmap_fractal").op.input_tensors[0]
            self.tensor_map["fmap_matrix"] = fmap_fractal_before.op.input_tensors[0]
        else:
            self.tensor_map["fmap_matrix"] = self.tensor_map.get("fmap_fractal").op.input_tensors[0]
        self.tensor_map["fmap"] = self.tensor_map.get("fmap_matrix").op.input_tensors[0]
        if self.tensor_map.get("fmap").op.tag == "fmap_ub_for_dma":
            self.tensor_map["fmap_ub"] = self.tensor_map.get("fmap_matrix").op.input_tensors[0]
            self.tensor_map["fmap"] = self.tensor_map.get("fmap_ub").op.input_tensors[0]
        if DynamicConv2dBpFilterParams.strideh_read_flag:
            self.tensor_map["fmap_l1_name"] = self.tensor_map.get("fmap_matrix").op.input_tensors[0]
            self.tensor_map["fmap"] = self.tensor_map.get("fmap_l1_name").op.input_tensors[0]
