 #!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
segment tiling case
"""
from enum import Enum
from enum import auto
from functools import reduce
from typing import Any

from tbe.tvm import Var
from tbe.dsl.base import operation
from tbe.dsl.base.operation import register_build_pointcut

from tbe.common.platform import platform_info as tbe_platform_info
from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.platform.platform_info import ASCEND_910B
from tbe.common.platform.platform_info import ASCEND_910_93
from tbe.common.platform.platform_info import ASCEND_910H
from tbe.common.platform.platform_info import ASCEND_910
from tbe.common.platform.platform_info import ASCEND_610
from tbe.common.platform.platform_info import ASCEND_610B
from tbe.common.platform.platform_info import SD3403
from tbe.common.platform.platform_info import ASCEND_SD
from tbe.common.platform.platform_info import ASCEND_310
from tbe.common.platform.platform_info import ASCEND_310P
from tbe.common.platform.platform_info import ASCEND_310B
from tbe.common.platform.platform_info import AS31XM1
from tbe.common.platform.platform_info import ASCEND_031
from tbe.common.platform.platform_info import BS9SX1A
from tbe.common.platform.platform_info import SHORT_SOC_VERSION

from ... import util
from ...computation import Computation
from ...constants import CompileInfo
from ...constants import SegmentPattern
from ...constants import Pattern
from ...constants import DTYPE_BYTE_MAPPING
from ...constants import AtomicSupportMapDefault
from ...constants import AtomicSupportMap310P
from ...constants import AtomicSupportMap910BC

# scatter mode
CONST = "const"
EMPTY = "empty"
BLOCK_SIZE_BYTE = 32
NUM_SIZE = 3
DEFAULT = "default"

REMOVE_PAD_DTYPE = {
    "int8": 64, "uint8": 64, "int16": 160, "uint16": 160, "float16": 160, "int32": 168, "uint32": 168, "float": 168,
    "float32": 168, "int64": 168, "uint64": 168, "bfloat16": 160}

SUPPORTED_ATOMIC_OP = {
    "norm": ("segment_sum", "segmentensor_sum"),
    "next": ("segmentensor_sum", "segmentensor_min", "segmentensor_max")
}


class SegmentCompileInfo:
    """
    Built-in Compile info keys
    """
    CUSTOM_INFO = "_custom_info"
    SEGMENT_TYPE = "_segment_type"
    VAR_DTYPE_SIZE = "_var_dtype_size"
    ID_DTYPE_SIZE = "_id_dtype_size"
    VAR_NUM = "_var_num"
    ID_NUM = "_id_num"
    CACHE_NUM = "_cache_num"
    PATTERN = "pattern"
    OUTPUT_NUM = "_output_num"
    IS_SUPPORT_ATOMIC = "_is_support_atomic"
    IS_SUPPORT_CACHE = "_is_support_cache"
    CACHE_THRESHOLD = "_cache_threshold"
    CONST_AXIS = "_const_axis"
    TENSOR_SIZES = "_tensor_sizes"
    FAKE_SCHEDULE = "_fake_schedule"
    STATIC_SUCCESS = "_static_success"
    STATIC_CLOSE_PASS = "_static_close_pass"
    BASE_SCHEDULE_PATTERN_ATOMIC = 10
    BASE_SCHEDULE_PATTERN_NO_ATOMIC = 30
    IMPL_MODE = "_impl_mode"
    NUM_SEGMENT = "_num_segment"
    IS_CACHE = "_is_cache"
    CACHE_START = "_cache_start"


class TilingStrategy(Enum):
    """
    TilingStrategy
    """
    DYNAMIC = auto()
    STATIC = auto()
    CONST = auto()
    EMPTY = auto()
    ZEROS = auto()


class SegmentComputation(Computation):
    """
    ScatterComputation
    """
    def __init__(self, outs, option):
        self.outs = outs
        self.option = option
        self.out = self.outs[0] if isinstance(self.outs, (list, tuple)) else self.outs
        self.op_type = util.get_dsl_insn(self.out)
        self.out_dtype = self.out.dtype
        self.out_shape = util.shape_to_list(self.out.shape)
        self.is_schedule_zero = operation.get_context().get_current_compute().get("_zero_shape")
        self.is_small_1_block = operation.get_context().get_current_compute().get("_is_small_1_block")
        self.is_small_1_repeat = operation.get_context().get_current_compute().get("_is_small_1_repeat")
        self.is_more_1_repeat = operation.get_context().get_current_compute().get("_is_more_1_repeat")

    @classmethod
    def get_instance(cls, outs, option):  # type: (list[Any], dict[str, Any]) -> "Computation"
        return cls(outs, option)

    @classmethod
    def get_supported_pattern(cls):  # type: () -> list[str]
        return [Pattern.SEGMENT]

    @classmethod
    def get_supported_soc(cls):  # type: () -> list[str]
        return [DEFAULT]

    @staticmethod
    def gen_atomic_cases(params_list, check_list,
                         set_mask=False, is_more_1_repeat=False):
        set_mask_key = int(set_mask) * 10000
        atomic_cases = []
        if check_list[1]:
            is_need_align_pad_key = 1000
            is_cache_key = int(check_list[2]) * 100
            tiling_key = params_list[0] + is_need_align_pad_key + is_cache_key + set_mask_key
            atomic_cases.append({
                "key": tiling_key + 1000,
                "block_tiling_norm_axis": None,
                "block_tiling_reduce_axis": 0,
                "ub_tiling_norm_axis": None,
                "ub_tiling_reduce_axis": 0,
                "tiling_strategy": params_list[1],
                "segment_axis": params_list[2],
                "is_db": False,
                "is_need_storage_align": True,
                "is_need_align_pad": check_list[1],
                "is_atomic": True,
                "impl_mode": check_list[0],
                "is_cache": check_list[2],
                "num_segments": params_list[3],
                "op_type": params_list[4],
                "move_pad": params_list[5],
                "is_set_mask": set_mask
            })
        else:
            is_cache_key = int(check_list[2]) * 100
            tiling_key = params_list[0]
            atomic_cases.append({
                "key": tiling_key + is_cache_key + 1000 + set_mask_key,
                "block_tiling_norm_axis": None,
                "block_tiling_reduce_axis": 0,
                "ub_tiling_norm_axis": None,
                "ub_tiling_reduce_axis": 0,
                "tiling_strategy": params_list[1],
                "segment_axis": params_list[2],
                "is_db": False,
                "is_need_storage_align": True,
                "is_need_align_pad": False,
                "is_atomic": True,
                "impl_mode": check_list[0],
                "is_cache": check_list[2],
                "num_segments": params_list[3],
                "op_type": params_list[4],
                "move_pad": params_list[5],
                "is_set_mask": set_mask
            })
            if not check_list[2] and not set_mask and is_more_1_repeat:
                atomic_cases.append({
                    "key": tiling_key + 1000 + 1,
                    "block_tiling_norm_axis": None,
                    "block_tiling_reduce_axis": 0,
                    "ub_tiling_norm_axis": 1,
                    "ub_tiling_reduce_axis": 0,
                    "tiling_strategy": params_list[1],
                    "segment_axis": params_list[2],
                    "is_db": False,
                    "is_need_storage_align": True,
                    "is_need_align_pad": False,
                    "is_atomic": True,
                    "impl_mode": check_list[0],
                    "is_cache": False,
                    "num_segments": params_list[3],
                    "op_type": params_list[4],
                    "move_pad": params_list[5],
                    "is_set_mask": False
                })
        return atomic_cases

    @staticmethod
    def gen_no_atomic_cases(params_list, impl_mode, is_need_align_pad, is_cache, is_core_x, set_mask=False):
        set_mask_key = int(set_mask) * 10000
        no_atomic_cases = []
        if is_need_align_pad:
            is_need_align_pad_key = 1000
            cache_key = int(is_cache) * 100
            tiling_key = params_list[0] + is_need_align_pad_key + cache_key + set_mask_key
            no_atomic_cases.append({
                "key": tiling_key + 3000,
                "block_tiling_norm_axis": 0,
                "block_tiling_reduce_axis": None,
                "ub_tiling_norm_axis": None,
                "ub_tiling_reduce_axis": 0,
                "tiling_strategy": params_list[1],
                "segment_axis": params_list[2],
                "is_db": False,
                "is_need_storage_align": True,
                "is_need_align_pad": is_need_align_pad,
                "is_atomic": False,
                "impl_mode": impl_mode,
                "is_cache": is_cache,
                "is_core_x": False,
                "num_segments": params_list[3],
                "op_type": params_list[4],
                "move_pad": params_list[5],
                "is_set_mask": set_mask
            })
        elif not is_need_align_pad and not is_core_x:
            cache_key = int(is_cache) * 100
            tiling_key = params_list[0]
            no_atomic_cases.append({
                "key": tiling_key + cache_key + 3000 + set_mask_key,
                "block_tiling_norm_axis": 0,
                "block_tiling_reduce_axis": None,
                "ub_tiling_norm_axis": None,
                "ub_tiling_reduce_axis": 0,
                "tiling_strategy": params_list[1],
                "segment_axis": params_list[2],
                "is_db": False,
                "is_need_storage_align": True,
                "is_need_align_pad": is_need_align_pad,
                "is_atomic": False,
                "impl_mode": impl_mode,
                "is_cache": is_cache,
                "is_core_x": False,
                "num_segments": params_list[3],
                "op_type": params_list[4],
                "move_pad": params_list[5],
                "is_set_mask": set_mask
            })
        elif not is_need_align_pad and is_core_x:
            tiling_key = params_list[0]
            no_atomic_cases.append({
                "key": tiling_key + 5000,
                "block_tiling_norm_axis": 1,
                "block_tiling_reduce_axis": None,
                "ub_tiling_norm_axis": None,
                "ub_tiling_reduce_axis": 0,
                "tiling_strategy": params_list[1],
                "segment_axis": params_list[2],
                "is_db": False,
                "is_need_storage_align": True,
                "is_need_align_pad": False,
                "is_atomic": False,
                "impl_mode": impl_mode,
                "is_cache": False,
                "is_core_x": True,
                "num_segments": params_list[3],
                "op_type": params_list[4],
                "move_pad": params_list[5],
                "is_set_mask": False
            })
            no_atomic_cases.append({
                "key": tiling_key + 5000 + 1,
                "block_tiling_norm_axis": 1,
                "block_tiling_reduce_axis": None,
                "ub_tiling_norm_axis": 1,
                "ub_tiling_reduce_axis": 0,
                "tiling_strategy": params_list[1],
                "segment_axis": params_list[2],
                "is_db": False,
                "is_need_storage_align": True,
                "is_need_align_pad": False,
                "is_atomic": False,
                "impl_mode": impl_mode,
                "is_cache": False,
                "is_core_x": True,
                "num_segments": params_list[3],
                "op_type": params_list[4],
                "move_pad": params_list[5],
                "is_set_mask": False
            })
        else:
            tiling_key = params_list[0]
            no_atomic_cases.append({
                "key": tiling_key + 3000 + 1,
                "block_tiling_norm_axis": 0,
                "block_tiling_reduce_axis": None,
                "ub_tiling_norm_axis": 1,
                "ub_tiling_reduce_axis": 0,
                "tiling_strategy": params_list[1],
                "segment_axis": params_list[2],
                "is_db": False,
                "is_need_storage_align": True,
                "is_need_align_pad": is_need_align_pad,
                "is_atomic": False,
                "impl_mode": impl_mode,
                "is_cache": False,
                "is_core_x": False,
                "num_segments": params_list[3],
                "op_type": params_list[4],
                "move_pad": params_list[5],
                "is_set_mask": False
            })
        return no_atomic_cases

    @staticmethod
    def gen_all_out_cases(params_list, is_atomic, is_need_align_pad, spe_ver=False, set_mask=False):
        tiling_case = []
        atomic_key = int(is_atomic) * 10
        cache_key = 100
        set_mask_key = int(set_mask) * 10000
        align_pad_key = int(is_need_align_pad) * 1000
        tiling_key = params_list[0] + atomic_key + cache_key + align_pad_key + 7000 + set_mask_key

        if is_atomic:
            all_cache = spe_ver is not True
            tiling_case.append({
                "key": tiling_key,
                "block_tiling_norm_axis": None,
                "block_tiling_reduce_axis": 0,
                "ub_tiling_norm_axis": None,
                "ub_tiling_reduce_axis": 0,
                "tiling_strategy": params_list[1],
                "segment_axis": params_list[2],
                "is_db": False,
                "is_need_storage_align": True,
                "is_need_align_pad": is_need_align_pad,
                "is_atomic": True,
                "impl_mode": 1,
                "is_cache": True,
                "all_cache": all_cache,
                "num_segments": params_list[3],
                "op_type": params_list[4],
                "move_pad": params_list[5],
                "is_set_mask": set_mask
            })
        else:
            tiling_case.append({
                "key": tiling_key,
                "block_tiling_norm_axis": 0,
                "block_tiling_reduce_axis": None,
                "ub_tiling_norm_axis": None,
                "ub_tiling_reduce_axis": 0,
                "tiling_strategy": params_list[1],
                "segment_axis": params_list[2],
                "is_db": False,
                "is_need_storage_align": True,
                "is_need_align_pad": is_need_align_pad,
                "is_atomic": False,
                "impl_mode": 1,
                "is_cache": True,
                "all_cache": False,
                "is_core_x": False,
                "num_segments": params_list[3],
                "op_type": params_list[4],
                "move_pad": params_list[5],
                "is_set_mask": set_mask
            })
        return tiling_case

    def do_tiling_case(self):
        is_static = operation.get_op_mode() == "static"
        segment_axis = operation.get_context().get("_segment_axis")
        impl_mode = operation.get_context().get("_impl_mode")
        num_segments = operation.get_context().get("_num_segment")
        if self.is_schedule_zero:
            tiling_key = 770000000
            return [
                {
                    "key": tiling_key,
                    "block_tiling_norm_axis": None,
                    "block_tiling_reduce_axis": 0,
                    "ub_tiling_norm_axis": None,
                    "ub_tiling_reduce_axis": 0,
                    "tiling_strategy": TilingStrategy.ZEROS,
                    "segment_axis": segment_axis,
                    "is_db": False,
                    "is_need_storage_align": True,
                    "is_need_align_pad": False,
                    "is_atomic": True,
                    "impl_mode": impl_mode,
                    "is_cache": False,
                    "num_segments": 1,
                    "op_type": self.op_type,
                    "is_zero": True,
                    "is_set_mask": False,
                    "all_cache": False,
                }]
        # const/dynamic
        tiling_strategy = TilingStrategy.STATIC if is_static else TilingStrategy.DYNAMIC
        return self._calc_segment(segment_axis, impl_mode, tiling_strategy, num_segments)

    def get_sub_pattern(self):
        return SegmentPattern.NORMAL_SCHEDULE

    def _calc_segment(self, segment_axis, impl_mode, strategy, num_segments):
        outshape = operation.get_context().get("_output_shape")
        id_shape = operation.get_context().get("_id_shape")
        base_key = 770000000
        if self.is_small_1_repeat:
            base_key = base_key + 100000
        elif self.is_more_1_repeat:
            base_key = base_key + 200000
        move_pad = 0
        cur_version = get_soc_spec(SHORT_SOC_VERSION)
        soc_spe = cur_version in [ASCEND_310B, AS31XM1, ASCEND_031]
        operation.get_context().add("_is_spe_soc", soc_spe)
        if tbe_platform_info.api_check_support("tik.data_move_pad"):
            move_pad = 1
        def _if_support_atomic():
            if cur_version in [ASCEND_310P, ASCEND_610, ASCEND_610B, SD3403, ASCEND_SD, BS9SX1A]:
                atomic_map = AtomicSupportMap310P
                platform_type = "norm"
            elif cur_version in [ASCEND_910B, ASCEND_910_93, ASCEND_910H]:
                atomic_map = AtomicSupportMap910BC
                platform_type = "next"
            elif cur_version in [ASCEND_310B, AS31XM1, ASCEND_031]:
                atomic_map = AtomicSupportMap910BC
                platform_type = "norm"
            else:
                platform_type = "norm"
                atomic_map = AtomicSupportMapDefault
            if cur_version == ASCEND_310:
                return False
            elif self.out_dtype in atomic_map.get("support_dtype") and \
                    self.op_type in SUPPORTED_ATOMIC_OP.get(platform_type):
                return True
            else:
                return False

        def _if_support_all_out(num, mark):
            if self.out_dtype == "bfloat16":
                num = num + 1
            var_total_size = abs(reduce(lambda x, y: x * y, outshape)) * DTYPE_BYTE_MAPPING.get(self.out_dtype)
            if mark:
                total_ub_size = util.get_ub_size()
                return var_total_size <= 3 * total_ub_size // 2
            else:
                total_ub_size = util.get_ub_size() - 32
                return var_total_size <= total_ub_size // num

        cases = []
        is_need_align_pad = self.out_dtype in REMOVE_PAD_DTYPE.keys() and (isinstance(self.out_shape[-1], Var) or (
                isinstance(self.out_shape[-1], int) and self.out_shape[-1] <= REMOVE_PAD_DTYPE.get(self.out_dtype)))
        ub_size = (util.get_ub_size() - BLOCK_SIZE_BYTE) // NUM_SIZE
        tensor_space = ub_size // BLOCK_SIZE_BYTE * BLOCK_SIZE_BYTE
        if self.out_dtype == "float16":
            dtype_size = 2
            one_repeat = 128
        else:
            dtype_size = 4
            one_repeat = 64
        num_x = int(tensor_space // dtype_size)
        if (-1 in id_shape) or (-2 in id_shape):
            is_large_id = True
        else:
            is_large_id = abs(reduce(lambda x, y: x * y, id_shape)) > 1000
        is_x_core = isinstance(self.out_shape[-1], Var) or (isinstance(self.out_shape[-1], int) and
                                                            self.out_shape[-1] > num_x)
        is_special = isinstance(self.out_shape[-1], Var) or (isinstance(self.out_shape[-1], int) and
                                                             self.out_shape[-1] == 1)
        is_set_mask = not soc_spe and (isinstance(self.out_shape[-1], Var) or (isinstance(self.out_shape[-1], int) and (self.out_shape[-1] <= one_repeat or self.out_shape[-1] % one_repeat == 0)))
        params_list = [base_key, strategy, segment_axis, num_segments, self.op_type, move_pad]
        if _if_support_atomic() and _if_support_all_out(3, (not soc_spe)) and is_large_id:
            if is_need_align_pad and is_set_mask:
                cases.extend(self.gen_all_out_cases(params_list, True, True, soc_spe, is_set_mask))
                cases.extend(self.gen_all_out_cases(params_list, True, False, soc_spe, is_set_mask))
                cases.extend(self.gen_all_out_cases(params_list, True, True, soc_spe, False))
                cases.extend(self.gen_all_out_cases(params_list, True, False, soc_spe, False))
            elif is_need_align_pad and not is_set_mask:
                cases.extend(self.gen_all_out_cases(params_list, True, True, soc_spe, False))
                cases.extend(self.gen_all_out_cases(params_list, True, False, soc_spe, False))
            elif not is_need_align_pad and is_set_mask:
                cases.extend(self.gen_all_out_cases(params_list, True, False, soc_spe, True))
                cases.extend(self.gen_all_out_cases(params_list, True, False, soc_spe, False))
            else:
                cases.extend(self.gen_all_out_cases(params_list, True, False, soc_spe, False))
        if not _if_support_atomic() and _if_support_all_out(4, False):
            if is_need_align_pad and is_set_mask:
                cases.extend(self.gen_all_out_cases(params_list, False, True, soc_spe, is_set_mask))
                cases.extend(self.gen_all_out_cases(params_list, False, False, soc_spe, is_set_mask))
                cases.extend(self.gen_all_out_cases(params_list, False, True, soc_spe, False))
                cases.extend(self.gen_all_out_cases(params_list, False, False, soc_spe, False))
            elif is_need_align_pad and not is_set_mask:
                cases.extend(self.gen_all_out_cases(params_list, False, True, soc_spe, False))
                cases.extend(self.gen_all_out_cases(params_list, False, False, soc_spe, False))
            elif not is_need_align_pad and is_set_mask:
                cases.extend(self.gen_all_out_cases(params_list, False, False, soc_spe, is_set_mask))
                cases.extend(self.gen_all_out_cases(params_list, False, False, soc_spe, False))
            else:
                cases.extend(self.gen_all_out_cases(params_list, False, False, soc_spe, False))
        if _if_support_atomic() and is_special and self.is_small_1_block:
            special_key = base_key + 4000
            special_list = [special_key, strategy, segment_axis, num_segments, self.op_type, move_pad]
            cases.extend(self.gen_atomic_cases(special_list, [impl_mode, True, True], (not soc_spe)))
        if _if_support_atomic():
            if is_need_align_pad:
                if not impl_mode:
                    cases.extend(self.gen_atomic_cases(params_list, [impl_mode, True, 0], False))
                    cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, 0], False,
                                                       self.is_more_1_repeat))
                if impl_mode:
                    if is_set_mask:
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, True, impl_mode], True))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, impl_mode], True))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, True, impl_mode], False))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, impl_mode], False))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, True, 0], False))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, 0], False,
                                                           self.is_more_1_repeat))
                    else:
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, True, impl_mode], False))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, impl_mode], False))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, True, 0], False))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, 0], False,
                                                           self.is_more_1_repeat))
            else:
                if not impl_mode:
                    cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, 0], False,
                                                       self.is_more_1_repeat))
                if impl_mode:
                    if is_set_mask:
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, impl_mode], True))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, impl_mode], False))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, 0], False,
                                                           self.is_more_1_repeat))
                    else:
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, impl_mode], False))
                        cases.extend(self.gen_atomic_cases(params_list, [impl_mode, False, 0], False,
                                                           self.is_more_1_repeat))
        else:
            if is_need_align_pad and not is_x_core:
                if not impl_mode:
                    cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, 0, False, False))
                    cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, False, False))
                if impl_mode:
                    if is_set_mask:
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, impl_mode, False, is_set_mask))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, impl_mode, False, is_set_mask))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, impl_mode, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, impl_mode, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, 0, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, False, False))
                    else:
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, impl_mode, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, impl_mode, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, 0, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, False, False))
            elif is_need_align_pad and is_x_core:
                if not impl_mode:
                    cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, 0, False, False))
                    cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, False, False))
                if impl_mode:
                    if is_set_mask:
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, impl_mode, False, True))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, impl_mode, False, True))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, impl_mode, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, impl_mode, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, 0, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, False, False))
                    else:
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, impl_mode, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, impl_mode, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, True, 0, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, False, False))
                cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, True, False))
            else:
                if not impl_mode:
                    cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, False, False))
                if impl_mode:
                    if is_set_mask:
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, impl_mode, False, True))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, impl_mode, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, False, False))
                    else:
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, impl_mode, False, False))
                        cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, False, False))
                cases.extend(self.gen_no_atomic_cases(params_list, impl_mode, False, 0, True, False))
        return cases


def _pre_build(schedules_list):
    def _flatten_sch(_schedules: list):
        for sub_schs in schedules_list:
            if isinstance(sub_schs, list):
                _schedules.extend(sub_schs)
            else:
                _schedules.append(sub_schs)

    def _name_to_int(_var_names):
        new_var_names = []
        for name in _var_names:
            if name[0] != "_":
                continue
            names = name[1:].split("_")
            if names[0] == "x":
                new_var_names.append(10000 + int(names[2]))
            elif names[0] == "num" and names[1] == "segments":
                new_var_names.append(20000 + int(names[2]))
            elif names[0] == "block":
                new_var_names.append(30000 + int(names[2]))
            elif names[0] == "ub":
                if names[1] == "norm":
                    new_var_names.append(40000 + int(names[3]))
                elif names[1] == "reduce":
                    new_var_names.append(50000 + int(names[3]))
            elif names[0] == "segment":
                if names[1] == "cache" and names[2] == "num":
                    new_var_names.append(60000 + int(names[3]))
                elif names[1] == "cache" and names[2] == "start":
                    new_var_names.append(70000 + int(names[3]))
                elif names[1] == "last" and names[2] == "dim":
                    new_var_names.append(80000 + int(names[3]))
        return new_var_names
    # set special build cfg
    operation.add_build_arg("double_buffer_non_reuse", True)

    # static buildcfg
    is_close_pass = operation.get_context().get(SegmentCompileInfo.STATIC_CLOSE_PASS)
    if operation.get_op_mode() == "static" and is_close_pass:
        operation.add_build_arg("out_of_bound_sync_check", False)
    cpt_computes = operation.get_context().get_computes()

    schedules = []
    _flatten_sch(schedules)

    te_vars_list = []
    op_vars = operation.get_context().get_vars()
    cpt_cores, cpt_ub_size = [], []
    cpt_var_dtype, cpt_id_dtype, cpt_segment_type = [], [], []
    is_support_atomic = []
    tensor_sizes = {}

    for cpt in cpt_computes:
        cpt_vars = cpt.get_vars()
        for sch_context in cpt.get_schedules():
            if sch_context.get(SegmentCompileInfo.FAKE_SCHEDULE):
                continue

            cpt_cores.append(sch_context.get(CompileInfo.CORE_NUM))
            cpt_ub_size.append(sch_context.get(CompileInfo.UB_SIZE))
            cpt_var_dtype.append(sch_context.get(SegmentCompileInfo.VAR_DTYPE_SIZE))
            cpt_id_dtype.append(sch_context.get(SegmentCompileInfo.ID_DTYPE_SIZE))
            cpt_segment_type.append(sch_context.get(SegmentCompileInfo.SEGMENT_TYPE))

            is_support_atomic.append(sch_context.get(SegmentCompileInfo.IS_SUPPORT_ATOMIC))
            impl_mode = sch_context.get(SegmentCompileInfo.IMPL_MODE)
            num_segment = sch_context.get(SegmentCompileInfo.NUM_SEGMENT)
            pattern = sch_context.get(SegmentCompileInfo.PATTERN)
            var_num = sch_context.get(SegmentCompileInfo.VAR_NUM)
            id_num = sch_context.get(SegmentCompileInfo.ID_NUM)
            cache_ub_num = sch_context.get(SegmentCompileInfo.CACHE_NUM)
            sch_vars = sch_context.get_vars()
            te_vars_list.append(op_vars + cpt_vars + sch_vars)

            if pattern not in tensor_sizes.keys():
                tensor_sizes[pattern] = [var_num, id_num, cache_ub_num]

        base_info = [max(cpt_cores), min(cpt_ub_size), max(cpt_segment_type), max(cpt_var_dtype),
                     max(cpt_id_dtype)]
        operation.add_compile_info_inner(CompileInfo.BASE_INFO, base_info)
        special_soc = operation.get_context().get("_is_spe_soc")
        custom_info = [min(is_support_atomic), impl_mode, num_segment, special_soc]
        operation.add_compile_info_inner(SegmentCompileInfo.CUSTOM_INFO, custom_info)
        operation.add_compile_info_inner(SegmentCompileInfo.TENSOR_SIZES, tensor_sizes)

        compile_vars = {}
        for sch, te_vars in zip(schedules, te_vars_list):
            if sch is None:
                continue
            var_names = [x.get_name() for x in te_vars]
            compile_vars[sch.tiling_key] = _name_to_int(var_names)
        operation.add_compile_info_inner("_segment_vars", compile_vars)


@register_build_pointcut(pattern=Pattern.SEGMENT)
def build_pointcut(func, *args, **kwargs):
    """
    build_pointcut
    :param func:
    :param args:
    :param kwargs:
    :return:
    """
    _pre_build(args[0])
    func(*args, **kwargs)

