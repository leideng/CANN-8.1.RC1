#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2021 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
avg_pool_update tiling case
"""
import copy

from typing import Any
from typing import Callable
from typing import Dict
from typing import Set
from typing import List
from typing import Iterable
from typing import Optional
from typing import Tuple
from typing import Union
from tbe.tvm import PlaceholderOp
from tbe.tvm import Tensor
from tbe.dsl.base.operation import add_compile_info_inner
from tbe.dsl.base.operation import get_compile_info
from tbe.dsl.base.operation import get_context
from tbe.dsl.base.operation import register_tiling_case
from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.utils import op_tiling, log
from tbe.common.utils.op_util.op_util_avg_pool_update import TILING_TEMPLATE
from tbe.common.utils.op_util.op_util_avg_pool_update import TilingKeyOffset, TilingCaseValueCollection, TilingKeyName

from .constants import Pattern
from . import util

CONST = "const"


class AvgpoolUpdateGraphInfo:
    """
    Operator Compute Graph Info collector and container
    """
    def __init__(self, output_tensors: Iterable[Tensor]):
        # Basic Info
        self.output_tensor_set: Set[Tensor] = set(output_tensors)
        self.tensor_consumers_map: Optional[Dict[Tensor, Set[Tensor]]] = None
        self.tensor_producers_map: Optional[Dict[Tensor, Set[Tensor]]] = None
        self.tensor_list: Optional[List[Tensor]] = None

        # Extra info initialized by hooks
        self.input_tensor_set: Set[Tensor] = set()
        self.non_gm_input_tensor_set: Set[Tensor] = set()

        # Do info collection
        self.collect_info()

    @staticmethod
    def dfs_compute_graph(root_tensor: Union[Iterable[Tensor], Tensor],
                            hooks: Tuple[Tuple[Callable[[Tensor], bool],
                            Callable[[Tensor], Any],
                            Callable[[Tensor], Any]], ...]):
        def recursive_func(_root_tensor: Tensor,
                           _visited_list: Set[Tensor],
                           _tensor_consumers_map: Dict[Tensor, Union[Set[Tensor]]],
                           _tensor_producers_map: Dict[Tensor, Union[Set[Tensor]]],
                           _hooks: Tuple[Tuple[Callable[[Tensor], bool],
                                               Callable[[Tensor], Any],
                                               Callable[[Tensor], Any]], ...]):
            _visited_list.add(_root_tensor)
            _tensor_producers_map.setdefault(_root_tensor, set())
            _tensor_consumers_map.setdefault(_root_tensor, set())

            for hook in hooks:
                if hook[0](_root_tensor):
                    hook[1](_root_tensor)
                else:
                    hook[2](_root_tensor)

            for in_tensor in _root_tensor.op.input_tensors:
                _tensor_consumers_map.setdefault(in_tensor, set())
                _tensor_consumers_map[in_tensor].add(_root_tensor)
                _tensor_producers_map[_root_tensor].add(in_tensor)
                recursive_func(in_tensor,
                               _visited_list,
                               _tensor_consumers_map,
                               _tensor_producers_map,
                               _hooks)

        visited_list = set()
        tensor_consumers_map = {}
        tensor_producers_map = {}
        if isinstance(root_tensor, (list, tuple, set)):
            for tensor in root_tensor:
                recursive_func(tensor,
                               visited_list,
                               tensor_consumers_map,
                               tensor_producers_map,
                               hooks)
        elif isinstance(root_tensor, Tensor):
            recursive_func(root_tensor,
                           visited_list,
                           tensor_consumers_map,
                           tensor_producers_map,
                           hooks)
        else:
            raise RuntimeError("dfs_compute_graph supports [list,tuple,Tensor]. Received %s" % str(type(root_tensor)))
        return list(visited_list), tensor_consumers_map, tensor_producers_map

    @staticmethod
    def check_placeholder(tensor):
        return isinstance(tensor.op, PlaceholderOp)

    def add_input_tensor_set(self, tensor):
        self.input_tensor_set.add(tensor)

    def add_non_gm_input_tensor_set(self, tensor):
        if not tensor.op.input_tensors:
            self.non_gm_input_tensor_set.add(tensor)

    def collect_info(self):
        hook_funcs = (
            self.check_placeholder, self.add_input_tensor_set, self.add_non_gm_input_tensor_set)
        self.tensor_list, self.tensor_consumers_map, self.tensor_producers_map = \
            self.dfs_compute_graph(self.output_tensor_set, (hook_funcs,))


class AvgPoolUpdateTilingCase:
    def __init__(self, tiling_data, data_dtype="float16", data_format="NCHW", mode=CONST):
        self.data_dtype = data_dtype
        self.data_format = data_format
        if self.data_dtype == "float32" and mode == CONST:
            self.block_nparts_n = tiling_data.get("block_nparts_n")
            self.block_nparts_h = tiling_data.get("block_nparts_h")
            self.block_nparts_w = tiling_data.get("block_nparts_w")
            self.block_nparts_c = tiling_data.get("block_nparts_c")
            self.ub_factor_n = tiling_data.get("ub_factor_n")
            self.ub_factor_h = tiling_data.get("ub_factor_h")
            self.ub_factor_w = tiling_data.get("ub_factor_w")
            self.ub_factor_c = tiling_data.get("ub_factor_c")
            self.reorder_n_c_flag = tiling_data.get("reorder_n_c_flag")
        else:
            self.block_nparts_m = tiling_data.get("block_nparts_m")
            self.block_nparts_n = tiling_data.get("block_nparts_n")
            self.block_nparts_c1 = tiling_data.get("block_nparts_c1")
            self.ub_factor_m = tiling_data.get("ub_factor_m")
            self.ub_factor_n = tiling_data.get("ub_factor_n")
            self.ub_factor_c1 = tiling_data.get("ub_factor_c1")
            self.reorder_n_c1_flag = tiling_data.get("reorder_n_c1_flag")
        self.enable_db = tiling_data.get("enable_db")
        self.tiling_key = self._calc_tiling_key(mode == CONST)

    def _calc_tiling_key(self, is_const: bool):
        if is_const:
            return 0  # an arbitrary tiling key in const case

        if self.data_dtype == "float32":
            raise RuntimeError("AvgpoolUpdate does not support float32 dynamic shapes at the moment!")

        tiling_key = int(0)
        tiling_key |= self.reorder_n_c1_flag << TilingKeyOffset.OFFSET_REORDER_N_C1_FLAG
        tiling_key |= self.enable_db << TilingKeyOffset.OFFSET_DB

        return tiling_key


def add_compile_info_avg_pool_update(mode=CONST):
    add_compile_info_inner("_is_const_shapes", mode == CONST)
    add_compile_info_inner("_vector_core_cnt", int(get_soc_spec("VECTOR_CORE_CNT")))
    add_compile_info_inner("_ub_size", get_soc_spec("UB_SIZE"))
    if get_soc_spec("SHORT_SOC_VERSION") == "Ascend910":
        add_compile_info_inner("_vector_core_cnt", int(get_soc_spec("CORE_NUM")))


def get_const_tiling_case(graph_info):
    """
    get const tiling case
    """
    add_compile_info_avg_pool_update()
    inputs = []
    input_tensor = tuple(graph_info.input_tensor_set)[0]
    input_shape = util.shape_to_list(input_tensor.shape)
    input_dtype = input_tensor.dtype
    input_format = input_tensor.op.attrs.get("ori_format")

    for _input in graph_info.input_tensor_set:
        inputs.append({"shape": util.shape_to_list(_input.shape),
                       "dtype": _input.dtype, "format": input_format})
    outputs = [{"shape": input_shape, "dtype": input_dtype}]
    run_info = op_tiling.do_op_tiling("AutoTiling", get_compile_info(), inputs, outputs)
    if not run_info.get("tiling_data"):
        raise RuntimeError("AvgpoolUpdate obtain optiling failed")
    if input_dtype == "float32":
        tiling_format = {
            "enable_db": "int",
            "block_nparts_h": "int",
            "block_nparts_w": "int",
            "block_nparts_n": "int",
            "block_nparts_c": "int",
            "ub_factor_h": "int",
            "ub_factor_w": "int",
            "ub_factor_n": "int",
            "ub_factor_c": "int",
            "reorder_n_c_flag": "int"
        }
    else:
        tiling_format = {
            "enable_db": "int",
            "block_nparts_m": "int",
            "block_nparts_n": "int",
            "block_nparts_c1": "int",
            "ub_factor_m": "int",
            "ub_factor_n": "int",
            "ub_factor_c1": "int",
            "reorder_n_c1_flag": "int"
        }
    tiling_data = op_tiling.decode(run_info.get("tiling_data"), tiling_format)
    tiling_case = AvgPoolUpdateTilingCase(tiling_data, input_dtype, input_format)
    return [tiling_case]


def get_template_tiling_cases(mode):
    add_compile_info_avg_pool_update(mode)

    template_tiling_case_list = []
    for reorder_n_c1 in TilingCaseValueCollection.VALUE_REORDER_N_C1_FLAG_LIST:
        for enable_db in TilingCaseValueCollection.VALUE_DB_LIST:
            template = copy.deepcopy(TILING_TEMPLATE)
            template[TilingKeyName.REORDER_N_C1_FLAG] = reorder_n_c1
            template[TilingKeyName.ENABLE_DB] = enable_db
            tiling_case = AvgPoolUpdateTilingCase(template, mode=mode)
            template_tiling_case_list.append(tiling_case)

    return template_tiling_case_list


@register_tiling_case(pattern=Pattern.AvgPoolUpdate)
def calc_tiling_case(outs, option=None):
    """
    AvgPoolUpdate tilingcase
    """
    outs = list(outs) if isinstance(outs, (list, tuple)) else [outs]
    if len(outs) != 1:
        raise RuntimeError("AvgpoolUpdate doesn not multiple input tensors!")

    current_compute = get_context().get_current_compute()
    mode = current_compute.get("_mode")
    log.debug("[avg_pool_update] current_compute mode is {}".format(mode))
    graph_info = AvgpoolUpdateGraphInfo(outs)
    current_compute.add("_graph_info", graph_info)

    tiling_case_list = []
    if mode == CONST:
        tiling_case_list += get_const_tiling_case(graph_info)
    else:
        tiling_case_list += get_template_tiling_cases(mode)
    return tiling_case_list
