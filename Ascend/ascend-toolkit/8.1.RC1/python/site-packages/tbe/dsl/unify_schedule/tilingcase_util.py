#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
tiling case utils
"""

from __future__ import absolute_import

import collections
import copy
import math
import warnings

from tbe.common.utils import decode
from tbe.dsl.base.operation import get_context as op_get_context
from tbe.tvm.ir import PrimExpr


N_DIM = 0
C_DIM = 1
H_DIM = 2
W_DIM = 3
H_DIM_2D = 0
W_DIM_2D = 1
RANGE_DIM_LEN = 2
FORMAT_HW_DIM = 2
VALID_TILING_POS = 2
FORMAT_NCHW_DIM = 4
FORMAT_NC1HWC0_DIM = 5
DYNAMIC_FLAG = -1
UNKNOWN_FLAG = -2
UNKNOWN_SHAPE = [-2]
DIM_TO_NAME = {0: "N", 2: "H", 3: "W"}
INPUT_SIZE_DEFAULT_SHAPE = [4]
DX_OP_TYPE = ["deconvolution", "conv2d_transpose", "conv2d_backprop_input"]
_K_MIN_RANGE = 1
_K_MAX_RANGE = 4096
_K_DIM_SIZE = 5
BinaryTilingItem = collections.namedtuple('BinaryTilingItem', 'name offset bits valid_len')

def ceil_div(x_1, x_2):
    """
    ceil divide for inputs
    """

    if x_1 is None:
        return x_1
    if x_2 == 0:
        raise RuntimeError("conv2dbp division by zero")
    return (x_1 + x_2 - 1) // x_2


def _calc_output(x_in, k_size, pads, stride, dilation):
    if not x_in:
        return None
    return (x_in + pads[0] + pads[1] - dilation * (k_size - 1) - 1) // stride + 1


def _calc_upper(lower, upper):
    if (upper > 1) and (upper > lower):
        upper -= 1
    return upper


def _calc_ceil(x_1, x_2):
    """
    do ceiling division

    Parameters
    ----------
    x_1: int
    x_2: int
    Returns
    -------
    result
    """
    if x_2 == 0:
        raise RuntimeError("division by zero")
    return (x_1 + x_2 - 1) // x_2


def pos_from_format(ele_format):
    """
    get value from ele_format
    """
    pos_n = ele_format.find('N')
    pos_c = ele_format.find('C')
    pos_h = ele_format.find('H')
    pos_w = ele_format.find('W')
    return {"pos_n": pos_n, "pos_c": pos_c, "pos_h": pos_h, "pos_w": pos_w}


def _get_idx_shape_from_format(obj_format, obj_shape):
    """
    get index and shape from ele_format
    """
    idx_n = obj_format.find('N')
    idx_d = obj_format.find('D')
    idx_h = obj_format.find('H')
    idx_w = obj_format.find('W')
    idx_c = obj_format.find('C')
    return [idx_n, idx_d, idx_h, idx_w, idx_c],\
           [obj_shape[idx_n], obj_shape[idx_d], obj_shape[idx_h], obj_shape[idx_w], obj_shape[idx_c]]


def is_valid_tiling(tiling):
    # 32 denotes invalid tiling
    if tiling is None or tiling.get("AL0_matrix")[VALID_TILING_POS] == 32:
        return False
    return True


def construct_tiling_case(tiling_strategy, tiling_key=None, tiling_data=None):
    return {'key': tiling_key, 'tiling_strategy': tiling_strategy, 'tiling_data': tiling_data}


def parse_run_info(run_info):
    tiling_key = run_info.get("tiling_key")
    tiling_data_bin = run_info.get("tiling_data")

    tbe_vars = op_get_context().get_vars()
    # sample of tiling_format is "block_axis": "int"
    tiling_format = {x.get_name(): x.get_tvm_var().dtype for x in tbe_vars}
    tiling_data = decode(tiling_data_bin, tiling_format)
    return tiling_key, tiling_data


class Conv2dBackpropParaProcess():
    """
    class of param check and preprocess for dynamic conv2d_backprop_input
    """

    def __init__(self, paras):
        self.paras = paras
        self.groups = paras.get("groups")
        self.strides = paras.get("strides")
        self.pads = paras.get("pads")
        self.dilations = paras.get("dilations")
        self.valid_paras = {
            "nhw_min": 1,
            "hw_max": 4096,
            "valid_format": {"weights": ("NCHW", "NHWC", "HWCN"),
                             "input": ("NCHW", "NHWC"),
                             "output": ("NCHW", "NHWC")},
            "valid_dtype": ("float16", "int8", "int32")
        }
        self.op_type = "conv2d_backprop_input"
        self.filters = paras.get("filters")
        self.out_backprop = paras.get("out_backprop")
        self.data_format = paras.get("data_format")
        self.dtype = paras.get("filters").get("dtype")

    @staticmethod
    def _is_dynamic_pad(pads):
        return any(isinstance(pad, PrimExpr) for pad in pads)

    @staticmethod
    def _get_lower_input(y_in, k_size, pads, stride, dilation):
        if not y_in:
            return y_in
        return stride * (y_in - 1) + dilation * (k_size - 1) + 1 - pads[0] - pads[1]

    @staticmethod
    def _get_higher_input(y_in, k_size, pads, stride, dilation):
        if not y_in:
            return y_in
        return stride * (y_in - 1) + dilation * (k_size - 1) + 1 - pads[0] - pads[1] + stride - 1

    def get_input_nchw(self, in_shape, in_format, in_range=None):
        """
        get input shape and range of nchw format
        """

        pos = pos_from_format(in_format)
        pos_n = pos.get("pos_n")
        pos_c = pos.get("pos_c")
        pos_h = pos.get("pos_h")
        pos_w = pos.get("pos_w")
        in_shape = [in_shape[pos_n], in_shape[pos_c], in_shape[pos_h], in_shape[pos_w]]
        if in_range:
            if len(in_range) == FORMAT_NCHW_DIM:
                in_range = [in_range[pos_n], in_range[pos_c], in_range[pos_h], in_range[pos_w]]
            # range in NC1HWC0 format sometimes
            elif len(in_range) == FORMAT_NC1HWC0_DIM:
                in_range = [in_range[N_DIM], (in_shape[C_DIM], in_shape[C_DIM]), in_range[H_DIM], in_range[W_DIM]]
            return in_shape, [tuple(r) if r else r for r in in_range]
        return in_shape

    def get_input_range(self, w_shape, dy_range, dx_range=None):
        """
        calculate input range
        """
        new_dy_range = copy.deepcopy(dy_range)
        if self._is_dynamic_pad(self.pads):
            dx_h_lower, dx_h_upper, h_correct_range_flag = self._get_input_range_by_dynamic_pad(
                new_dy_range, dy_range, w_shape, H_DIM)
            dx_w_lower, dx_w_upper, w_correct_range_flag = self._get_input_range_by_dynamic_pad(
                new_dy_range, dy_range, w_shape, W_DIM)
        else:
            dx_h_lower, dx_h_upper, h_correct_range_flag = self._get_input_range_by_static_pad(
                new_dy_range, dy_range, w_shape, H_DIM)
            dx_w_lower, dx_w_upper, w_correct_range_flag = self._get_input_range_by_static_pad(
                new_dy_range, dy_range, w_shape, W_DIM)

        correct_range_flag = h_correct_range_flag or w_correct_range_flag
        if dx_h_upper and dx_h_lower > dx_h_upper:
            dx_h_lower = dx_h_upper
        if dx_w_upper and dx_w_lower > dx_w_upper:
            dx_w_lower = dx_w_upper
        if dx_range:
            return [dx_range[N_DIM], dx_range[C_DIM], (dx_h_lower, dx_h_upper), (dx_w_lower, dx_w_upper)]
        return [dy_range[N_DIM], (w_shape[C_DIM], w_shape[C_DIM]),
                (dx_h_lower, dx_h_upper), (dx_w_lower, dx_w_upper)], correct_range_flag, new_dy_range

    def get_output_range(self, w_shape, in_range, out_range=None):
        """
        calculate output range
        """
        def _get_output(x_in, k_size, pads, stride, dilation):
            if not x_in:
                return x_in
            return (x_in + pads[0] + pads[1] - dilation * (k_size - 1) - 1) // stride + 1
        correct_range_flag = False
        new_in_range = copy.deepcopy(in_range)
        if self._is_dynamic_pad(self.pads):
            out_h_lower = ceil_div(in_range[H_DIM][0], self.strides[H_DIM])
            out_h_upper = ceil_div(in_range[H_DIM][1], self.strides[H_DIM])
            out_w_lower = ceil_div(in_range[W_DIM][0], self.strides[W_DIM])
            out_w_upper = ceil_div(in_range[W_DIM][1], self.strides[W_DIM])
        else:
            out_h_lower = _get_output(in_range[H_DIM][0], w_shape[H_DIM],
                                      (self.pads[0], self.pads[1]), self.strides[H_DIM],
                                      self.dilations[H_DIM])
            out_h_upper = _get_output(in_range[H_DIM][1], w_shape[H_DIM],
                                      (self.pads[0], self.pads[1]), self.strides[H_DIM],
                                      self.dilations[H_DIM])
            out_w_lower = _get_output(in_range[W_DIM][0], w_shape[W_DIM],
                                      (self.pads[2], self.pads[3]), self.strides[W_DIM],
                                      self.dilations[W_DIM])
            out_w_upper = _get_output(in_range[W_DIM][1], w_shape[W_DIM],
                                      (self.pads[2], self.pads[3]), self.strides[W_DIM],
                                      self.dilations[W_DIM])
        if out_h_lower < self.valid_paras.get("nhw_min"):
            out_h_lower = max(out_h_lower, self.valid_paras.get("nhw_min"))
            new_in_range[H_DIM] = (self._get_lower_input(out_h_lower, w_shape[H_DIM], (self.pads[0], self.pads[1]),
                                                         self.strides[H_DIM],
                                                         self.dilations[H_DIM]), new_in_range[H_DIM][1])
            correct_range_flag = True
            warnings.warn("The output calculated based on the lower limit of the input h " +
                          "range is less than 1, and the lower limit of the output h range is corrected " +
                          "as {}".format(out_h_lower))
        if out_h_upper and out_h_upper > self.valid_paras.get("hw_max"):
            out_h_upper = min(out_h_upper, self.valid_paras.get("hw_max"))
            new_in_range[H_DIM] = (new_in_range[H_DIM][0],
                                   self._get_higher_input(out_h_upper, w_shape[H_DIM], (self.pads[0], self.pads[1]),
                                                          self.strides[H_DIM], self.dilations[H_DIM]))
            correct_range_flag = True
            warnings.warn("The output calculated based on the higher limit of the input h " +
                          "range is more than 4096, and the higher limit of the output h range is corrected " +
                          "as {}".format(out_h_upper))
        if out_w_lower < self.valid_paras.get("nhw_min"):
            out_w_lower = max(out_w_lower, self.valid_paras.get("nhw_min"))
            new_in_range[W_DIM] = (self._get_lower_input(out_w_lower, w_shape[W_DIM], (self.pads[2], self.pads[3]),
                                                         self.strides[W_DIM],
                                                         self.dilations[W_DIM]), new_in_range[W_DIM][1])
            correct_range_flag = True
            warnings.warn("The output calculated based on the lower limit of the input w " +
                          "range is less than 1, and the lower limit of the output w range is corrected " +
                          "as {}".format(out_w_lower))
        if out_w_upper and out_w_upper > self.valid_paras.get("hw_max"):
            out_w_upper = min(out_w_upper, self.valid_paras.get("hw_max"))
            new_in_range[W_DIM] = (new_in_range[W_DIM][0],
                                   self._get_higher_input(out_w_upper, w_shape[W_DIM], (self.pads[2], self.pads[3]),
                                                          self.strides[W_DIM], self.dilations[W_DIM]))
            correct_range_flag = True
            warnings.warn("The output calculated based on the higher limit of the input w " +
                          "range is more than 4096, and the higher limit of the output w range is corrected " +
                          "as {}".format(out_w_upper))
        if out_h_upper and out_h_lower > out_h_upper:
            out_h_lower = out_h_upper
        if out_w_upper and out_w_lower > out_w_upper:
            out_w_lower = out_w_upper
        if out_range:
            return [out_range[N_DIM], out_range[C_DIM], (out_h_lower, out_h_upper), (out_w_lower, out_w_upper)]
        return [in_range[N_DIM], (w_shape[N_DIM], w_shape[N_DIM]),
                (out_h_lower, out_h_upper), (out_w_lower, out_w_upper)], correct_range_flag, new_in_range

    def _get_input_range_by_dynamic_pad(self, new_dy_range, dy_range, w_shape, dim_idx):
        correct_range_flag = False
        dim_name = "h"
        pads = (self.pads[0], self.pads[1])
        if dim_idx == W_DIM:
            dim_name = "w"
            pads = (self.pads[2], self.pads[3])

        dx_lower = (dy_range[dim_idx][0] - 1) * self.strides[dim_idx] + 1
        if not dy_range[dim_idx][1]:
            dx_upper = dy_range[dim_idx][1]
        else:
            dx_upper = dy_range[dim_idx][1] * self.strides[dim_idx]
            if dx_upper > self.valid_paras.get("hw_max"):
                dx_upper = min(dx_upper, self.valid_paras.get("hw_max"))
                new_dy_range[dim_idx] = (new_dy_range[dim_idx][0],
                                         self._get_output(dx_upper, w_shape[dim_idx], pads, self.strides[dim_idx],
                                                          self.dilations[dim_idx]))
                correct_range_flag = True
                warnings.warn("The input calculated based on the upper limit of the output {} "
                              "range is more than 4096, and the upper limit of the input {} range is corrected "
                              "as {}".format(dim_name, dim_name, dx_upper))
        return dx_lower, dx_upper, correct_range_flag

    def _get_input_range_by_static_pad(self, new_dy_range, dy_range, w_shape, dim_idx):
        def _get_output(x_in, k_size, pads, stride, dilation):
            if not x_in:
                return x_in
            if self._is_dynamic_pad(pads):
                return ceil_div(x_in, stride)
            else:
                return (x_in + pads[0] + pads[1] - dilation * (k_size - 1) - 1) // stride + 1

        correct_range_flag = False
        dim_name = "h"
        pads = (self.pads[0], self.pads[1])
        if dim_idx == W_DIM:
            dim_name = "w"
            pads = (self.pads[2], self.pads[3])

        dx_lower = self._get_lower_input(dy_range[dim_idx][0], w_shape[dim_idx], pads, self.strides[dim_idx],
                                         self.dilations[dim_idx])
        if dx_lower < self.valid_paras.get("nhw_min"):
            dx_lower = max(dx_lower, self.valid_paras.get("nhw_min"))
            new_dy_range[dim_idx] = (_get_output(dx_lower, w_shape[dim_idx], pads, self.strides[dim_idx],
                                                 self.dilations[dim_idx]), new_dy_range[dim_idx][1])
            correct_range_flag = True
            warnings.warn("The input calculated based on the lower limit of the output {} "
                          "range is less than 1, and the lower limit of the input {} range is corrected "
                          "as {}".format(dim_name, dim_name, dx_lower))
        if not dy_range[dim_idx][1]:
            dx_upper = dy_range[dim_idx][1]
        else:
            dx_upper = self._get_higher_input(dy_range[dim_idx][1], w_shape[dim_idx], pads, self.strides[dim_idx],
                                              self.dilations[dim_idx])
            if dx_upper > self.valid_paras.get("hw_max"):
                dx_upper = min(dx_upper, self.valid_paras.get("hw_max"))
                new_dy_range[dim_idx] = (new_dy_range[dim_idx][0],
                                         _get_output(dx_upper, w_shape[dim_idx], pads, self.strides[dim_idx],
                                                     self.dilations[dim_idx]))
                correct_range_flag = True
                warnings.warn("The input calculated based on the upper limit of the output {} "
                              "range is more than 4096, and the upper limit of the input {} range is corrected "
                              "as {}".format(dim_name, dim_name, dx_upper))
        return dx_lower, dx_upper, correct_range_flag


class Conv3dBackpropParaProcess():
    """
    class of param check and preprocess for dynamic conv3d_backprop_input
    """
    def __init__(self, para_dict, pad_mode):
        self.para_dict = para_dict
        self.pad_mode = pad_mode
        self.strides = para_dict.get("strides") # ndhwc
        self.pads = para_dict.get("pads")
        self.dilations = para_dict.get("dilations") # ndhwc
        self.groups = para_dict.get("groups")
        self.filter = para_dict.get("ori_tensors").get("filter")
        self.out_backprop = para_dict.get("ori_tensors").get("out_backprop")
        self.y = para_dict.get("ori_tensors").get("y")
        self.input_size = para_dict.get("ori_tensors").get("input_size")


    def get_dx_range(self, dy_range):
        """
        get dx_range according to dy_range
        """
        _, shape_filter_ndhwc = _get_idx_shape_from_format(self.filter["ori_format"],
                                                           self.filter["ori_shape"])
        _, shape_y_ndhwc = _get_idx_shape_from_format(self.y["ori_format"],
                                                      self.y["ori_shape"])
        idx_out_backprop_ndhwc, shape_out_backprop_ndhwc = _get_idx_shape_from_format(self.out_backprop["ori_format"],
                                                                                      self.out_backprop["ori_shape"])
        _, filter_d, filter_h, filter_w, _ = shape_filter_ndhwc
        _, dx_d, dx_h, dx_w, _ = shape_y_ndhwc
        idx_out_backprop_n, idx_out_backprop_d, idx_out_backprop_h, idx_out_backprop_w, _ = idx_out_backprop_ndhwc
        stride_d, stride_h, stride_w = \
            self.strides[1], self.strides[2], self.strides[3]
        dilations_d, dilations_h, dilations_w = \
            self.dilations[1], self.dilations[2], self.dilations[3]
        pad_front, pad_back, pad_up, pad_down, pad_left, pad_right = \
            self.pads[0], self.pads[1], self.pads[2], self.pads[3], self.pads[4], self.pads[5]
        kdext = (filter_d - 1) * dilations_d + 1
        khext = (filter_h - 1) * dilations_h + 1
        kwext = (filter_w - 1) * dilations_w + 1
        dy_n = shape_out_backprop_ndhwc[idx_out_backprop_n]

        dx_range_ndhw = [1, 1, 1, 1]
        dx_range_ndhw[0] = [dy_n, dy_n]
        dx_range_ndhw[1] = [dx_d, dx_d]
        dx_range_ndhw[2] = [dx_h, dx_h]
        dx_range_ndhw[3] = [dx_w, dx_w]

        if len(dy_range) == _K_DIM_SIZE:
            dx_range_ndhw[0] = dy_range[idx_out_backprop_n]
            if dx_d == -1:
                attr_param_d = [stride_d, kdext, pad_front + pad_back]
                self._set_conv3dx_dim_range(1, idx_out_backprop_d, attr_param_d, dx_range_ndhw, dy_range)
            if dx_h == -1:
                attr_param_h = [stride_h, khext, pad_up + pad_down]
                self._set_conv3dx_dim_range(2, idx_out_backprop_h, attr_param_h, dx_range_ndhw, dy_range)
            if dx_w == -1:
                attr_param_w = [stride_w, kwext, pad_left + pad_right]
                self._set_conv3dx_dim_range(3, idx_out_backprop_w, attr_param_w, dx_range_ndhw, dy_range)
        return dx_range_ndhw

    def get_dy_range(self, dx_range_ndhwc):
        """
        get dy_range according to dx_range
        """
        dx_range_n, dx_range_d, dx_range_h, dx_range_w, dx_range_c = dx_range_ndhwc
        _, shape_filter_ndhwc = _get_idx_shape_from_format(self.filter["ori_format"],
                                                           self.filter["ori_shape"])
        _, shape_out_backprop_ndhwc = _get_idx_shape_from_format(self.out_backprop["ori_format"],
                                                                 self.out_backprop["ori_shape"])
        _, filter_d, filter_h, filter_w, _ = shape_filter_ndhwc
        if not all(i == 0 for i in self.pads):
            out_d_upper, out_h_upper, out_w_upper = None, None, None
            out_d_lower = _calc_ceil(dx_range_d[0], self.strides[1])
            if dx_range_d[1]:
                out_d_upper = _calc_ceil(dx_range_d[1], self.strides[1])

            out_h_lower = _calc_ceil(dx_range_h[0], self.strides[2])
            if dx_range_h[1]:
                out_h_upper = _calc_ceil(dx_range_h[1], self.strides[2])

            out_w_lower = _calc_ceil(dx_range_w[0], self.strides[3])
            if dx_range_w[1]:
                out_w_upper = _calc_ceil(dx_range_w[1], self.strides[3])
        else:
            out_d_lower = _calc_output(dx_range_d[0],
                                       filter_d,
                                       (self.pads[0], self.pads[1]),
                                       self.strides[1],
                                       self.dilations[1])
            if out_d_lower < 1:
                fmap_range_d_lower = min(filter_d, dx_range_d[1]) if dx_range_d[1] else filter_d
                fmap_range_d = (fmap_range_d_lower, dx_range_d[1])
                out_d_lower = _calc_output(fmap_range_d[0],
                                           filter_d,
                                           (self.pads[0], self.pads[1]),
                                           self.strides[1],
                                           self.dilations[1])
            out_d_upper = _calc_output(dx_range_d[1],
                                       filter_d,
                                       (self.pads[0], self.pads[1]),
                                       self.strides[1],
                                       self.dilations[1])

            out_h_lower = _calc_output(dx_range_h[0],
                                       filter_h,
                                       (self.pads[2], self.pads[3]),
                                       self.strides[2],
                                       self.dilations[2])
            if out_h_lower < 1:
                fmap_range_h_lower = min(filter_h, dx_range_h[1]) if dx_range_h[1] else filter_h
                fmap_range_h = (fmap_range_h_lower, dx_range_h[1])
                out_h_lower = _calc_output(fmap_range_h[0],
                                           filter_h,
                                           (self.pads[2], self.pads[3]),
                                           self.strides[2],
                                           self.dilations[2])
            out_h_upper = _calc_output(dx_range_h[1],
                                       filter_h,
                                       (self.pads[2], self.pads[3]),
                                       self.strides[2],
                                       self.dilations[2])

            out_w_lower = _calc_output(dx_range_w[0],
                                       filter_w,
                                       (self.pads[4], self.pads[5]),
                                       self.strides[3],
                                       self.dilations[3])
            if out_w_lower < 1:
                fmap_range_w_lower = min(filter_w, dx_range_w[1]) if dx_range_w[1] else filter_w
                fmap_range_w = (fmap_range_w_lower, dx_range_w[1])
                out_w_lower = _calc_output(fmap_range_w[0],
                                           filter_w,
                                           (self.pads[4], self.pads[5]),
                                           self.strides[3],
                                           self.dilations[3])
            out_w_upper = _calc_output(dx_range_w[1],
                                       filter_w,
                                       (self.pads[4], self.pads[5]),
                                       self.strides[3],
                                       self.dilations[3])

        dy_range = [(dx_range_n[0], dx_range_n[1]),
                    (out_d_lower, _calc_upper(out_d_lower, out_d_upper)),
                    (out_h_lower, _calc_upper(out_h_lower, out_h_upper)),
                    (out_w_lower, _calc_upper(out_w_lower, out_w_upper)),
                    (shape_out_backprop_ndhwc[-1], shape_out_backprop_ndhwc[-1])
                    ]
        return dy_range

    def _set_conv3dx_dim_range(self, dx_pos, dy_pos, attr_param, dx_range, dy_range):
        stride, kernel, pad = attr_param[0], attr_param[1], attr_param[2]
        low, high = dy_range[dy_pos][0], dy_range[dy_pos][1]
        if self.pad_mode == "VAR":
            dx_range[dx_pos][0] = stride * (low - 1) + 1
            dx_range[dx_pos][1] = stride * high
        else:
            dx_range[dx_pos][0] = stride * (low - 1) + kernel - pad
            dx_range[dx_pos][1] = stride * (high - 1) + kernel - pad + stride - 1
        dx_range[dx_pos][0] = max(dx_range[dx_pos][0], _K_MIN_RANGE)
        if high == -1:
            dx_range[dx_pos][1] = high
        else:
            dx_range[dx_pos][1] = min(dx_range[dx_pos][1], _K_MAX_RANGE)
