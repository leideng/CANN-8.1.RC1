#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
scatter tiling case
"""
from enum import Enum
from enum import auto
from functools import reduce
from typing import Any

from tbe.tvm import Var

from tbe.dsl.base import operation
from tbe.dsl.base.operation import register_build_pointcut

from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.platform.platform_info import ASCEND_910B
from tbe.common.platform.platform_info import ASCEND_910_93
from tbe.common.platform.platform_info import ASCEND_910H
from tbe.common.platform.platform_info import ASCEND_610
from tbe.common.platform.platform_info import ASCEND_610B
from tbe.common.platform.platform_info import SD3403
from tbe.common.platform.platform_info import ASCEND_SD
from tbe.common.platform.platform_info import ASCEND_310P
from tbe.common.platform.platform_info import ASCEND_310B
from tbe.common.platform.platform_info import AS31XM1
from tbe.common.platform.platform_info import ASCEND_031
from tbe.common.platform.platform_info import BS9SX1A
from tbe.common.platform.platform_info import SHORT_SOC_VERSION

from ... import util
from ...computation import Computation

from ...constants import CompileInfo
from ...constants import ScatterPattern
from ...constants import Pattern
from ...constants import DTYPE_BYTE_MAPPING
from ...constants import AtomicSupportMapDefault
from ...constants import AtomicSupportMap310P
from ...constants import AtomicSupportMap910BC

# scatter mode
CONST = "const"
EMPTY = "empty"

DEFAULT = "default"

REMOVE_PAD_DTYPE = {
    "int8": 64, "uint8": 64, "int16": 160, "uint16": 160, "float16": 160,
    "int32": 168, "uint32": 168, "float": 168,
    "float32": 168, "int64": 168, "uint64": 168}

SUPPORTED_ATOMIC_OP = {
    "norm": ("scatter_add", "scatter_nd_add", "scatter_nd"),
    "next": ("scatter_add", "scatter_max", "scatter_min",
             "scatter_nd_add", "scatter_nd_max", "scatter_nd_min", "scatter_nd")
}

ATOMIC_CASES_KEY = 1000
CACHED_VAR_CASES_KEY = 3000
BASE_CASES_KEY = 5000
ALIGN_PAD_KEY = 1000
SPECIAL_PATTERN_THRESHOLD = 3
BLOCK_SIZE_BYTE = 32


class TilingThreshold:
    """
    Define threshold for tiling
    """
    VAR_CACHE_THRESHOLD = 1
    TILING_TAIL_AXIS_THRESHOLD = 32


class ScatterCompileInfo:
    """
    Built-in Compile info keys
    """
    CUSTOM_INFO = "_custom_info"
    SCATTER_TYPE = "_scatter_type"
    OP_TYPE = "_op_type"
    SCATTER_ND_SHAPE = "_scatter_nd_shape"
    VAR_DTYPE_SIZE = "_var_dtype_size"
    INDICES_DTYPE_SIZE = "_indices_dtype_size"
    UPDATE_DTYPE_SIZE = "_update_dtype_size"
    VAR_NUM = "_params_num"
    INDICES_NUM = "_indices_num"
    UPDATE_NUM = "_update_num"
    IS_SUPPORT_ATOMIC = "_is_support_atomic"
    CACHE_THRESHOLD = "_cache_threshold"
    RANK_THRESHOLD = "_rank_threshold"
    TAIL_AXIS_THRESHOLD = "_tail_axis_threshold"
    SPECIAL_PATTERN = "_special_pattern"
    CONST_AXIS = "_const_axis"
    TENSOR_SIZES = "_tensor_sizes"
    FAKE_SCHEDULE = "_fake_schedule"
    STATIC_SUCCESS = "_static_success"
    STATIC_CLOSE_PASS = "_static_close_pass"
    BASE_SCHEDULE_PATTERN = 5
    SOC_VERSION = "_soc_version"


class TilingStrategy(Enum):
    """
    TilingStrategy
    """
    DYNAMIC = auto()
    STATIC = auto()
    CONST = auto()
    EMPTY = auto()
    ZEROS = auto()


class ScatterComputation(Computation):
    """
    ScatterComputation
    """

    def __init__(self, outs, option):
        self.outs = outs
        self.option = option
        self.is_schedule_zero = operation.get_context().get_current_compute().get("_zero_shape")

    @classmethod
    def get_instance(cls, outs, option):  # type: (list[Any], dict[str, Any]) -> "Computation"
        return cls(outs, option)

    @classmethod
    def get_supported_pattern(cls):  # type: () -> list[str]
        return [Pattern.SCATTER]

    @classmethod
    def get_supported_soc(cls):  # type: () -> list[str]
        return [DEFAULT]

    @staticmethod
    def gen_atomic_cases(op_type, dim_len, base_key, strategy, scatter_axis, is_need_align_pad):
        atomic_cases = []
        # ub tilling for sparse axis
        is_need_align_pad_key = int(is_need_align_pad) * ALIGN_PAD_KEY
        tiling_key = base_key + is_need_align_pad_key
        atomic_cases.append({
            "key": tiling_key + ATOMIC_CASES_KEY,
            "block_tiling_norm_axis": None,
            "block_tiling_sparse_axis": 0,
            "ub_tiling_norm_axis": None,
            "ub_tiling_sparse_axis": 0,
            "tiling_strategy": strategy,
            "op_type": op_type,
            "scatter_axis": scatter_axis,
            "store_area": 0,
            "is_db": False,
            "is_need_storage_align": not is_need_align_pad,
            "is_need_align_pad": is_need_align_pad,
            "is_atomic": True
        })
        if not is_need_align_pad:
            # ub tilling for norm[-1] axis
            tiling_key = base_key + dim_len - 1
            atomic_cases.append({
                "key": tiling_key + ATOMIC_CASES_KEY,
                "block_tiling_norm_axis": None,
                "block_tiling_sparse_axis": 0,
                "ub_tiling_norm_axis": dim_len - 1,
                "ub_tiling_sparse_axis": 0,
                "tiling_strategy": strategy,
                "op_type": op_type,
                "scatter_axis": scatter_axis,
                "store_area": 0,
                "is_db": False,
                "is_need_storage_align": False,
                "is_need_align_pad": False,
                "is_atomic": True
            })

        return atomic_cases

    @staticmethod
    def gen_cached_var_cases(op_type, dim_len, base_key, strategy, scatter_axis, is_need_align_pad):
        cached_var_cases = []
        is_need_align_pad_key = int(is_need_align_pad) * ALIGN_PAD_KEY
        base_key += is_need_align_pad_key
        for i in range(dim_len - 1):
            for j in range(i, dim_len - 1):
                tiling_key = base_key + i * dim_len + j
                cached_var_cases.append({
                    "key": tiling_key + CACHED_VAR_CASES_KEY,
                    "block_tiling_norm_axis": i,
                    "block_tiling_sparse_axis": None,
                    "ub_tiling_norm_axis": j,
                    "ub_tiling_sparse_axis": 0,
                    "tiling_strategy": strategy,
                    "op_type": op_type,
                    "scatter_axis": scatter_axis,
                    "store_area": 1,
                    "is_db": False,
                    "is_need_storage_align": not is_need_align_pad,
                    "is_need_align_pad": is_need_align_pad,
                    "is_need_remove_pad": is_need_align_pad
                })
        return cached_var_cases

    @staticmethod
    def gen_without_cached_cases(op_type, dim_len, base_key, strategy, scatter_axis, is_need_align_pad):
        without_cached_cases = []
        is_need_align_pad_key = int(is_need_align_pad) * ALIGN_PAD_KEY
        for i in range(dim_len - 1):
            tiling_key = base_key + is_need_align_pad_key + i * dim_len
            without_cached_cases.append({
                "key": tiling_key + BASE_CASES_KEY,
                "block_tiling_norm_axis": i,
                "block_tiling_sparse_axis": None,
                "ub_tiling_norm_axis": None,
                "ub_tiling_sparse_axis": 0,
                "tiling_strategy": strategy,
                "op_type": op_type,
                "scatter_axis": scatter_axis,
                "store_area": 1,
                "is_sparse_cache": True,
                "is_db": False,
                "is_need_storage_align": not is_need_align_pad,
                "is_need_align_pad": is_need_align_pad
            })

        if not is_need_align_pad:
            # ub tilling for norm[-1] axis
            for i in range(dim_len):
                tiling_key = base_key + dim_len - 1 + i * dim_len
                without_cached_cases.append({
                    "key": tiling_key + BASE_CASES_KEY,
                    "block_tiling_norm_axis": i,
                    "block_tiling_sparse_axis": None,
                    "ub_tiling_norm_axis": dim_len - 1,
                    "ub_tiling_sparse_axis": 0,
                    "tiling_strategy": strategy,
                    "op_type": op_type,
                    "scatter_axis": scatter_axis,
                    "store_area": 1,
                    "is_sparse_cache": True,
                    "is_db": False,
                    "is_need_storage_align": False,
                    "is_need_align_pad": False
                })

        return without_cached_cases

    def do_tiling_case(self):
        is_static = operation.get_op_mode() == "static"
        scatter_axis = operation.get_context().get("_scatter_axis")
        rank = operation.get_context().get_current_compute().get("_rank")
        if self.is_schedule_zero:
            op_type = self._get_op_type()
            tiling_key = 880000000
            return [
                {
                    "key": tiling_key ,
                    "block_tiling_norm_axis": None,
                    "block_tiling_sparse_axis": 0,
                    "ub_tiling_norm_axis": None,
                    "ub_tiling_sparse_axis": 0,
                    "tiling_strategy": TilingStrategy.ZEROS,
                    "op_type": op_type,
                    "scatter_axis": scatter_axis,
                    "store_area": 0,
                    "is_db": False,
                    "is_need_storage_align": False,
                    "is_need_align_pad": False,
                    "is_atomic": True
                }]

        # const/dynamic
        tiling_strategy = TilingStrategy.STATIC if is_static else TilingStrategy.DYNAMIC
        return self._calc_scatter(scatter_axis, tiling_strategy, rank)

    def get_sub_pattern(self):  # type: () -> str
        return ScatterPattern.NORMAL_SCHEDULE

    def _get_op_type(self):
        out = self.outs[0] if isinstance(self.outs, (list, tuple)) else self.outs
        return util.get_dsl_insn(out)

    def _calc_scatter(self, scatter_axis, strategy, rank):
        def _if_support_atomic():
            if cur_version in [ASCEND_310P, ASCEND_610, ASCEND_610B, SD3403, ASCEND_SD, BS9SX1A]:
                atomic_map = AtomicSupportMap310P
                platform_type = "norm"
            elif cur_version in [ASCEND_910B, ASCEND_910_93, ASCEND_910H, ASCEND_310B, AS31XM1, ASCEND_031]:
                atomic_map = AtomicSupportMap910BC
                platform_type = "norm"
            else:
                platform_type = "norm"
                atomic_map = AtomicSupportMapDefault

            is_support_op_type = True if op_type in SUPPORTED_ATOMIC_OP.get(platform_type) else False
            is_support_dtype = True if out_dtype in atomic_map.get("support_dtype") else False

            return is_support_op_type and is_support_dtype

        def _if_support_cache_var():
            # abs is intended to get min params shape(assume -1 dims value is 1)
            core_num = util.get_core_num()
            var_total_size = abs(reduce(lambda x, y: x * y, ori_var_shape)) * DTYPE_BYTE_MAPPING.get(out_dtype)
            total_ub_size = util.get_ub_size()

            return var_total_size <= total_ub_size * core_num * TilingThreshold.VAR_CACHE_THRESHOLD

        def _is_special_pattern(rank, impl_mode):
            if op_type in ("scatter_update", "scatter_nd_update") and impl_mode == "high_performance":
                global SPECIAL_PATTERN_THRESHOLD
                SPECIAL_PATTERN_THRESHOLD = 5

            return rank <= SPECIAL_PATTERN_THRESHOLD

        def _is_not_align():
            dim_size = out_shape[-1]
            block_align_size = 32
            return (dim_size * DTYPE_BYTE_MAPPING.get(out_dtype)) % block_align_size

        def _is_scatter_update():
            return op_type in ("scatter_update", "scatter_nd_update") and cur_version not in (ASCEND_310B, AS31XM1)

        out = self.outs[0] if isinstance(self.outs, (list, tuple)) else self.outs
        out_shape = util.shape_to_list(out.shape)
        ori_var_shape = operation.get_context().get_current_compute().get("_var_shape")
        impl_mode = operation.get_compile_info().get("impl_mode")
        dim_len = len(out_shape)
        out_dtype = out.dtype
        base_key = self._calc_base_key(rank)
        op_type = self._get_op_type()
        cur_version = get_soc_spec(SHORT_SOC_VERSION)

        cases = []
        is_need_align_pad = out.dtype in REMOVE_PAD_DTYPE.keys() and (isinstance(out_shape[-1], Var) or (
                isinstance(out_shape[-1], int) and out_shape[-1] <= REMOVE_PAD_DTYPE.get(out_dtype) and
                _is_not_align()))
        
        is_310p_static_less_than_block = (cur_version == ASCEND_310P) and (isinstance(out_shape[-1], int)) and (
            out_shape[-1] * DTYPE_BYTE_MAPPING.get(out_dtype) < BLOCK_SIZE_BYTE)

        if _is_special_pattern(rank, impl_mode):
            # High coordinate dimensions may cause poor cache template performance
            max_cache_rank = 3
            if _is_scatter_update() and impl_mode == "high_performance":
                if not is_need_align_pad:
                    cases.extend(self.gen_atomic_cases(op_type, dim_len, base_key, strategy, scatter_axis, False))
                else:
                    cases.extend(self.gen_atomic_cases(op_type, dim_len, base_key, strategy, scatter_axis, True))
                    cases.extend(self.gen_atomic_cases(op_type, dim_len, base_key, strategy, scatter_axis, False))

                if _if_support_cache_var():
                    if not is_need_align_pad:
                        cases.extend(
                            self.gen_cached_var_cases(op_type, dim_len, base_key, strategy, scatter_axis, False))
                    else:
                        cases.extend(
                            self.gen_cached_var_cases(op_type, dim_len, base_key, strategy, scatter_axis, True))
                        cases.extend(
                            self.gen_cached_var_cases(op_type, dim_len, base_key, strategy, scatter_axis, False))
            elif _if_support_atomic() and (not is_310p_static_less_than_block):
                if not is_need_align_pad:
                    cases.extend(self.gen_atomic_cases(op_type, dim_len, base_key, strategy, scatter_axis, False))
                else:
                    cases.extend(self.gen_atomic_cases(op_type, dim_len, base_key, strategy, scatter_axis, True))
                    cases.extend(self.gen_atomic_cases(op_type, dim_len, base_key, strategy, scatter_axis, False))

            elif _if_support_cache_var() and op_type != "scatter_nd" and rank <= max_cache_rank:
                if not is_need_align_pad:
                    cases.extend(self.gen_cached_var_cases(op_type, dim_len, base_key, strategy, scatter_axis, False))
                else:
                    cases.extend(self.gen_cached_var_cases(op_type, dim_len, base_key, strategy, scatter_axis, True))
                    cases.extend(self.gen_cached_var_cases(op_type, dim_len, base_key, strategy, scatter_axis, False))

        # base tiling case, cover all condition
        if not is_need_align_pad:
            cases.extend(self.gen_without_cached_cases(op_type, dim_len, base_key, strategy, scatter_axis, False))
        else:
            cases.extend(self.gen_without_cached_cases(op_type, dim_len, base_key, strategy, scatter_axis, True))
            cases.extend(self.gen_without_cached_cases(op_type, dim_len, base_key, strategy, scatter_axis, False))

        return cases

    def _calc_base_key(self, rank):
        base_key = 880000000
        # add pattern
        base_key += rank * 10000

        return base_key


def _pre_build(schedules_list):
    def _flatten_sch(_schedules: list):
        for sub_schs in schedules_list:
            if isinstance(sub_schs, list):
                _schedules.extend(sub_schs)
            else:
                _schedules.append(sub_schs)

    def _name_to_int(_var_names):
        new_var_names = []
        for name in _var_names:
            if name[0] != "_":
                continue
            names = name[1:].split("_")
            if names[0] == "var":
                new_var_names.append(10000 + int(names[2]))
            elif names[0] == "indices":
                new_var_names.append(20000 + int(names[2]))
            elif names[0] == "update":
                new_var_names.append(30000 + int(names[2]))
            elif names[0] == "block":
                new_var_names.append(40000 + int(names[2]))
            elif names[0] == "ub":
                if names[1] == "norm":
                    new_var_names.append(50000 + int(names[3]))
                elif names[1] == "sparse":
                    new_var_names.append(60000 + int(names[3]))

        return new_var_names

    # set special build cfg
    operation.add_build_arg("double_buffer_non_reuse", True)

    # static buildcfg
    is_close_pass = operation.get_context().get(ScatterCompileInfo.STATIC_CLOSE_PASS)
    if operation.get_op_mode() == "static" and is_close_pass:
        operation.add_build_arg("out_of_bound_sync_check", False)

    cpt_computes = operation.get_context().get_computes()

    schedules = []
    _flatten_sch(schedules)

    te_vars_list = []
    op_vars = operation.get_context().get_vars()
    cpt_cores, cpt_ub_size = [], []
    cpt_var_dtype, cpt_indices_dtype, cpt_update_dtype, cpt_scatter_type = [], [], [], []
    is_support_atomic = []
    tensor_sizes = {}
    _op_type = 0
    _scatter_nd_shape = {}

    for cpt in cpt_computes:
        cpt_vars = cpt.get_vars()
        for sch_context in cpt.get_schedules():
            if sch_context.get(ScatterCompileInfo.FAKE_SCHEDULE):
                continue
            cpt_cores.append(sch_context.get(CompileInfo.CORE_NUM))
            cpt_ub_size.append(sch_context.get(CompileInfo.UB_SIZE))
            cpt_var_dtype.append(sch_context.get(ScatterCompileInfo.VAR_DTYPE_SIZE))
            cpt_indices_dtype.append(sch_context.get(ScatterCompileInfo.INDICES_DTYPE_SIZE))
            cpt_update_dtype.append(sch_context.get(ScatterCompileInfo.UPDATE_DTYPE_SIZE))
            cpt_scatter_type.append(sch_context.get(ScatterCompileInfo.SCATTER_TYPE))

            is_support_atomic.append(sch_context.get(ScatterCompileInfo.IS_SUPPORT_ATOMIC))
            special_pattern = sch_context.get(ScatterCompileInfo.SPECIAL_PATTERN)
            var_num = sch_context.get(ScatterCompileInfo.VAR_NUM)
            indices_num = sch_context.get(ScatterCompileInfo.INDICES_NUM)
            update_num = sch_context.get(ScatterCompileInfo.UPDATE_NUM)
            _op_type = sch_context.get(ScatterCompileInfo.OP_TYPE)

            sch_vars = sch_context.get_vars()
            te_vars_list.append(op_vars + cpt_vars + sch_vars)

            if special_pattern not in tensor_sizes.keys():
                tensor_sizes[special_pattern] = [var_num, indices_num, update_num]

            _scatter_nd_shape["0"] = operation.get_context().get(ScatterCompileInfo.SCATTER_ND_SHAPE)

        base_info = [max(cpt_cores), min(cpt_ub_size), max(cpt_scatter_type), max(cpt_var_dtype),
                     max(cpt_indices_dtype), max(cpt_update_dtype)]
        operation.add_compile_info_inner(CompileInfo.BASE_INFO, base_info)

        custom_info = [min(is_support_atomic), SPECIAL_PATTERN_THRESHOLD,
                       TilingThreshold.VAR_CACHE_THRESHOLD, TilingThreshold.TILING_TAIL_AXIS_THRESHOLD, _op_type]
        operation.add_compile_info_inner(ScatterCompileInfo.CUSTOM_INFO, custom_info)
        operation.add_compile_info_inner(ScatterCompileInfo.TENSOR_SIZES, tensor_sizes)
        operation.add_compile_info_inner(ScatterCompileInfo.SCATTER_ND_SHAPE, _scatter_nd_shape)
        operation.add_compile_info_inner(ScatterCompileInfo.SOC_VERSION, get_soc_spec(SHORT_SOC_VERSION))

        compile_vars = {}
        for sch, te_vars in zip(schedules, te_vars_list):
            if sch is None:
                continue
            var_names = [x.get_name() for x in te_vars]
            compile_vars[sch.tiling_key] = _name_to_int(var_names)
        operation.add_compile_info_inner("_scatter_vars", compile_vars)


@register_build_pointcut(pattern=Pattern.SCATTER)
def build_pointcut(func, *args, **kwargs):
    """
    build_pointcut
    :param func:
    :param args:
    :param kwargs:
    :return:
    """
    _pre_build(args[0])
    func(*args, **kwargs)
