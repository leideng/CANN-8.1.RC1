#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
extract_image_patches tiling
"""
from copy import deepcopy

from tbe.dsl.base.operation import register_tiling_case
from tbe.common import platform as tbe_platform
from tbe.dsl.base.operation import add_compile_info
from tbe.dsl.base.operation import get_context
from tbe.dsl.base.operation import get_op_context
from tbe.dsl.base.operation import get_compile_info
from tbe.common.utils import op_tiling
from tbe.common.utils import decode
from tbe import tvm
from .constants import Pattern
from . import util
from .extract_image_patches_without_cbuf_tilingcase import calc_extract_image_patches_without_cbuf
from .extract_image_patches_nchw_tilingcase import eip_nchw_tiling_case

DB_BASE_KEY = 10000
NON_ALIGN_BASE_KEY = 1000
NON_ALIGN_BASE_KEY_CIN_AS_ONE = 2000
NON_ALIGN_BASE_KEY_USE_DMA_NO_OVERLAP = 3000
L1_BASE_KEY = 100
WORKSPACE_BASE_KEY = 10
UB_BASE_KEY = 1
ISDB = False
ISVAR = False
ISOPENMERGEGRAPH = True


# 'pylint: disable=too-few-public-methods
class Constant:
    """
    This class for Constant.
    """
    BLOCK_SIZE = 16
    BLOCK_SIZE_INT8 = 32

    DOUBLE_BUFFER = 2
    FP16_SIZE = 2
    INT8_SIZE = 1
    NEED_UB_SPACE_NUM = 2
    SIZE_L1 = tbe_platform.get_soc_spec(tbe_platform.L1_SIZE)
    SIZE_UB = tbe_platform.get_soc_spec(tbe_platform.UB_SIZE)
    LOAD3D_REPEAT_TIME_LIMIT = 255


def calc_tilingcase_key_dynamic(tilingcase):
    l1_tiling_axis = tilingcase.l1_tiling_axis
    workspace_tiling_axis = tilingcase.workspace_tiling_axis
    ub_tiling_axis = tilingcase.ub_tiling_axis
    is_ori_cin_align = tilingcase.is_ori_cin_align
    ori_cin_large_than_one_block_size = tilingcase.ori_cin_large_than_one_block_size
    is_db = tilingcase.is_db

    key = l1_tiling_axis * L1_BASE_KEY + workspace_tiling_axis * WORKSPACE_BASE_KEY + ub_tiling_axis * UB_BASE_KEY
    # use_dma_no_overlap, ori_cin_as_one_special_type, is_ori_cin_align
    if tilingcase.ori_cin_as_one_special_type and (not is_ori_cin_align) and tilingcase.use_dma_no_overlap:
        # out_w is a big prime number and cin is 1.
        key += 7000
    elif (not is_ori_cin_align) and tilingcase.use_dma_no_overlap:
        # out_w is a big prime number but cin is not 1.
        key += 5000
    elif tilingcase.ori_cin_as_one_special_type and (not is_ori_cin_align):
        # out_w is not a big prime number but cin is one.
        key += 3000
    elif not is_ori_cin_align and ori_cin_large_than_one_block_size:
        # cin is not aliged and cin is larger than block_size.
        key += 2000
    elif not is_ori_cin_align:
        # other cin not aligned case.
        key += 1000

    if is_db:
        key += DB_BASE_KEY

    tilingcase.key = key


@register_tiling_case(pattern=Pattern.EXTRACT_IMAGE_PATCHES)
def calc_extract_image_patches(outs, option=None):
    """
    tiling_case func for extract_image_patches dynamic shape

    Parameters
    ----------
    outs: tvm tensor or list of tvm tensor, results for tvm compute

    Returns
    -------
    list of dict, each dict for a tiling case
    """
    if get_compile_info().get("nchw_format"):
        return eip_nchw_tiling_case(outs)

    is_const_shape = get_context().get("is_const_shape")
    if is_const_shape:
        run_info = get_context().get("run_info")
        tiling_key = run_info.get("tiling_key")
        if tiling_key >= 10000:
            tiling_format = {
                "multi_core_factor": "int",
                "workspace_factor": "int",
                "y_factor": "int"
            }
        else:
            tiling_format = {
                "block_nparts": "int",
                "l1_factor": "int",
                "workspace_factor": "int",
                "ub_factor": "int",
                "out_w_align_factor": "int"
            }
        tiling_data = decode(run_info.get("tiling_data"), tiling_format)
        const_tilingcase = ExtractImagePatchesTilingCase()
        const_tilingcase.key = tiling_key
        const_tilingcase.multi_core_factor = tiling_data.get("multi_core_factor")
        const_tilingcase.workspace_factor = tiling_data.get("workspace_factor")
        const_tilingcase.y_factor = tiling_data.get("y_factor")

        workspaces = run_info.get("workspaces")
        workspace_dict_in_json = {
            "num": 1,
            "size": workspaces,
            "type": [0],
        }
        get_op_context().add_build_json_result("workspace", workspace_dict_in_json)
        return [const_tilingcase]

    if "compute_without_cbuf" in outs[0].op.attrs:
        workspace_dict_in_json = {
            "num": 1,
            "size": [-1],
            "type": [0],
        }
        get_op_context().add_build_json_result("workspace", workspace_dict_in_json)
        return calc_extract_image_patches_without_cbuf(outs)

    res_shape = util.shape_to_list(outs[0].shape)
    extract_image_patches_info = ExtractImagePatchesInfo(outs)
    get_context().get_current_compute().add("extract_image_patches_info", extract_image_patches_info)
    _add_compile_info(extract_image_patches_info)

    is_origin_cin_align = get_context().get_current_compute().get("is_origin_cin_align")

    if extract_image_patches_info.is_const:
        tilingcase_list = _const_gen_tilingcase(res_shape, is_origin_cin_align, extract_image_patches_info)
    else:
        workspace_dict_in_json = {
            "num": 1,
            "size": [-1],
            "type": [0],
        }
        get_op_context().add_build_json_result("workspace", workspace_dict_in_json)
        tilingcase_list = _common_gen_tilingcase(res_shape, is_origin_cin_align, extract_image_patches_info)

    for tilingcase in tilingcase_list:
        calc_tilingcase_key_dynamic(tilingcase)
    return tilingcase_list


def _const_gen_tilingcase(shape, is_origin_cin_align, extract_image_patches_info):

    def _add_workspace_info_to_json():
        type_size = extract_image_patches_info.type_size
        fmap_n = extract_image_patches_info.fmap_n
        out_h = extract_image_patches_info.out_h
        out_w = extract_image_patches_info.out_w
        c_out = extract_image_patches_info.c_out
        workspace_size = [
            type_size * fmap_n * out_h * out_w * c_out,
        ]
        workspace_dict_in_json = {
            "num": 1,
            "size": workspace_size,
            "type": [0],
        }
        get_op_context().add_build_json_result("workspace", workspace_dict_in_json)

    graph_info = extract_image_patches_info.graph_info
    input_tensor = graph_info.get("fmap_in_l1")
    output_tensor = extract_image_patches_info.output_res
    input_tensor_shape = util.shape_to_list(input_tensor.shape)
    ori_shape = [
        extract_image_patches_info.fmap_n, extract_image_patches_info.fmap_h, extract_image_patches_info.fmap_w,
        extract_image_patches_info.origin_c_in
    ]
    ori_shape = util.shape_to_list(ori_shape)
    input_list = [{
        "shape": input_tensor_shape,
        "ori_shape": ori_shape,
        "format": "NC1HWC0",
        "ori_format": "NHWC",
        "dtype": input_tensor.dtype
    }]
    output_list = [{"shape": shape, "dtype": output_tensor.dtype}]
    attr_list = [{"name": "ksizes", "dtype": "list_int", "value": [1] + extract_image_patches_info.ksize_hw + [1]},
                 {"name": "strides", "dtype": "list_int", "value": [1] + extract_image_patches_info.stride_hw + [1]},
                 {"name": "rates", "dtype": "list_int", "value": [1] + extract_image_patches_info.dilate_hw + [1]},
                 {"name": "padding", "dtype": "string", "value": extract_image_patches_info.padding_type}]
    run_info = op_tiling.do_op_tiling(get_context().get_op_type(),
                                      get_compile_info(), input_list, output_list, None, None, attr_list)

    tiling_format = {
        "block_nparts": "int",
        "l1_tiling_axis": "int",
        "l1_factor": "int",
        "workspace_tiling_axis": "int",
        "workspace_factor": "int",
        "ub_tiling_axis": "int",
        "ub_factor": "int",
        "out_w_align_factor": "int",
        "is_db": "int"
    }
    tiling_data = decode(run_info.get("tiling_data"), tiling_format)

    const_tilingcase = ExtractImagePatchesTilingCase()
    const_tilingcase.block_nparts = tiling_data.get("block_nparts")
    const_tilingcase.l1_tiling_axis = tiling_data.get("l1_tiling_axis")
    const_tilingcase.workspace_tiling_axis = tiling_data.get("workspace_tiling_axis")
    const_tilingcase.ub_tiling_axis = tiling_data.get("ub_tiling_axis")
    const_tilingcase.l1_factor = tiling_data.get("l1_factor")
    const_tilingcase.workspace_factor = tiling_data.get("workspace_factor")
    const_tilingcase.ub_factor = tiling_data.get("ub_factor")
    const_tilingcase.out_w_align_factor = tiling_data.get("out_w_align_factor")
    const_tilingcase.is_ori_cin_align = is_origin_cin_align
    const_tilingcase.is_db = True if tiling_data.get("is_db") else False
    const_tilingcase.ori_cin_as_one_special_type = (extract_image_patches_info.origin_c_in == 1
                                                    and extract_image_patches_info.dtype_input not in ("int8", "uint8"))
    is_dma_less_than_block_size = ((const_tilingcase.ub_tiling_axis == 2)
                                   and const_tilingcase.ub_factor * extract_image_patches_info.origin_c_in <
                                   extract_image_patches_info.align_block_size)
    const_tilingcase.use_dma_no_overlap = (not is_origin_cin_align and is_dma_less_than_block_size)
    const_tilingcase.ori_cin_large_than_one_block_size = (extract_image_patches_info.origin_c_in >
                                                          extract_image_patches_info.align_block_size)
    if not const_tilingcase.is_ori_cin_align and get_op_context() and get_op_context().get_op_mode() != "dynamic":
        _add_workspace_info_to_json()

    return [const_tilingcase]


def _gen_common_cin_large_than_block_size_case(begin_idx, end_idx, base_case, extract_image_patches_info, case_list):
    khkw = extract_image_patches_info.khkw
    use_db_coef = 2 if base_case.is_db else 1
    ub_storage_bound = extract_image_patches_info.ub_storage_bound // use_db_coef
    base_case.is_ori_cin_align = False
    base_case.ori_cin_large_than_one_block_size = True
    ori_cin_range = extract_image_patches_info.ori_cin_range
    if ori_cin_range[1] is not None and ori_cin_range[1] < ub_storage_bound:
        fuse_res_axis = [0]
    elif ori_cin_range[0] > ub_storage_bound:
        fuse_res_axis = [1]
    else:
        fuse_res_axis = [0, 1]
    for idx in range(begin_idx, end_idx):
        # l1_tiling_axis and ub_tiling_axis both cut howo or both cut khkw
        for ub_idx in fuse_res_axis:
            l1_ub_equal_case = deepcopy(base_case)
            l1_ub_equal_case.l1_tiling_axis = idx
            l1_ub_equal_case.workspace_tiling_axis = idx
            l1_ub_equal_case.ub_tiling_axis = ub_idx
            if isinstance(khkw, tvm.expr.Mul) or (idx == 1 and khkw <= Constant.LOAD3D_REPEAT_TIME_LIMIT) or (idx != 1):
                case_list.append(l1_ub_equal_case)

        if end_idx - idx <= 1:
            continue

        # l1_tiling_axis cut howo ub_tiling_axis cut khkw
        for ub_idx in fuse_res_axis:
            l1_ub_nequal_case = deepcopy(base_case)
            l1_ub_nequal_case.l1_tiling_axis = idx
            l1_ub_nequal_case.workspace_tiling_axis = idx + 1
            l1_ub_nequal_case.ub_tiling_axis = ub_idx
            case_list.append(l1_ub_nequal_case)


def _common_gen_tilingcase(shape, is_origin_cin_align, extract_image_patches_info):
    ori_cin_range = get_context().get_current_compute().get("ori_cin_range")
    origin_cin = shape[-1]
    common_cases = []
    khkw = extract_image_patches_info.khkw
    base_case = ExtractImagePatchesTilingCase()
    begin_idx = 1
    end_idx = 3

    # aligned tilingcase
    if is_origin_cin_align:
        for idx in range(begin_idx, end_idx):
            # l1 ub both cut howo or both cut khkw
            l1_ub_equal_case = deepcopy(base_case)
            l1_ub_equal_case.l1_tiling_axis = idx
            l1_ub_equal_case.ub_tiling_axis = idx
            if isinstance(khkw, tvm.expr.Mul) or (idx == 1 and khkw <= Constant.LOAD3D_REPEAT_TIME_LIMIT) or (idx != 1):
                common_cases.append(l1_ub_equal_case)

            # l1_tiling_axis cut howo, ub_tiling_axis cut khkw, l1_tiling_axis + 1 = ub_tiling_axis
            if end_idx - idx > 1:
                l1_ub_nequal_case = deepcopy(base_case)
                l1_ub_nequal_case.l1_tiling_axis = idx
                l1_ub_nequal_case.ub_tiling_axis = idx + 1
                common_cases.append(l1_ub_nequal_case)

    # merge_subgraph tilingcase: non_align cin and cin < align_block_size
    elif not is_origin_cin_align and (ori_cin_range[1] is not None
                                      and ori_cin_range[1] < extract_image_patches_info.align_block_size):
        base_case.is_ori_cin_align = False
        origin_cin_one = (int(origin_cin) == 1) if (isinstance(origin_cin, int)
                                                    or isinstance(origin_cin, tvm.tir.IntImm)) else False
        base_case.ori_cin_as_one_special_type = (origin_cin_one
                                                 and extract_image_patches_info.dtype_input not in ("int8", "uint8"))
        for idx in range(begin_idx, end_idx):
            # l1 ub both cut howo or both cut khkw
            l1_ub_equal_case = deepcopy(base_case)
            l1_ub_equal_case.l1_tiling_axis = idx
            l1_ub_equal_case.workspace_tiling_axis = idx
            l1_ub_equal_case.ub_tiling_axis = idx
            if isinstance(khkw, tvm.expr.Mul) or (idx == 1 and khkw <= Constant.LOAD3D_REPEAT_TIME_LIMIT) or (idx != 1):
                common_cases.append(l1_ub_equal_case)
                if idx != 1:
                    use_dma_no_overlap_case = deepcopy(l1_ub_equal_case)
                    use_dma_no_overlap_case.use_dma_no_overlap = True
                    common_cases.append(use_dma_no_overlap_case)

            if end_idx - idx <= 1:
                continue

            # l1_tiling_axis cut howo, ub_tiling_axis cut khkw, l1_tiling_axis + 1 = ub_tiling_axis
            l1_ub_nequal_case = deepcopy(base_case)
            l1_ub_nequal_case.l1_tiling_axis = idx
            l1_ub_nequal_case.workspace_tiling_axis = idx + 1
            l1_ub_nequal_case.ub_tiling_axis = idx + 1
            common_cases.append(l1_ub_nequal_case)

            use_dma_no_overlap_case = deepcopy(l1_ub_nequal_case)
            use_dma_no_overlap_case.use_dma_no_overlap = True
            common_cases.append(use_dma_no_overlap_case)
    else:
        _gen_common_cin_large_than_block_size_case(begin_idx, end_idx, base_case, extract_image_patches_info,
                                                   common_cases)
        if ISDB:
            base_case.is_db = True
            _gen_common_cin_large_than_block_size_case(begin_idx, end_idx, base_case, extract_image_patches_info,
                                                       common_cases)

    if ISDB:
        db_common_cases = []
        common_cases_base = deepcopy(common_cases)
        for case in common_cases_base:
            if not case.ori_cin_large_than_one_block_size:
                case.is_db = True
                db_common_cases.append(case)

        return common_cases + db_common_cases
    else:
        return common_cases


class ExtractImagePatchesTilingCase:

    def __init__(self):
        self.key = 2**31 - 1
        self.l1_tiling_axis = None
        self.workspace_tiling_axis = 0
        self.ub_tiling_axis = None

        self.block_nparts = None
        self.l1_factor = None
        self.workspace_factor = None
        self.ub_factor = None
        self.out_w_align_factor = None
        self.is_ori_cin_align = True
        self.is_db = False
        self.multi_core_factor = None
        self.y_factor = None
        # dtype not in "int8" and "uint8", and cin is 1
        self.ori_cin_as_one_special_type = False
        self.use_dma_no_overlap = False
        self.ori_cin_large_than_one_block_size = False


def _add_compile_info(extract_image_patches_info):
    add_compile_info("envWithoutCbuf", False)

    add_compile_info("SIZE_L1", Constant.SIZE_L1)
    add_compile_info("SIZE_UB", Constant.SIZE_UB)

    add_compile_info("paddingType", extract_image_patches_info.padding_type)
    add_compile_info("socVersion", extract_image_patches_info.soc_version)
    add_compile_info("usedUbSize", extract_image_patches_info.used_ub_size)
    add_compile_info("avgSplitUbSize", extract_image_patches_info.avg_split_ub_size)
    add_compile_info("dtypeInput", extract_image_patches_info.dtype_input)
    add_compile_info("coreNum", extract_image_patches_info.device_core_num)
    add_compile_info("isConst", extract_image_patches_info.is_const)
    add_compile_info("isBinary", extract_image_patches_info.is_binary)
    add_compile_info("isDB", ISDB)
    add_compile_info("isVar", ISVAR)


def _collect_graph_info(output_res):
    graph_tensors = {}
    graph_tensors["ub_res"] = output_res[0].op.input_tensors[0]
    graph_tensors["workspace_res"] = graph_tensors.get("ub_res").op.input_tensors[0]
    graph_tensors["merge_co_ub"] = graph_tensors.get("workspace_res").op.input_tensors[0]
    graph_tensors["merge_hw_ub"] = graph_tensors.get("merge_co_ub").op.input_tensors[0]
    graph_tensors["transpose_ub"] = graph_tensors.get("merge_hw_ub").op.input_tensors[0]
    graph_tensors["split_c1_ub"] = graph_tensors.get("transpose_ub").op.input_tensors[0]
    graph_tensors["fmap_fractal"] = graph_tensors.get("split_c1_ub").op.input_tensors[0]
    graph_tensors["fmap_in_l1"] = graph_tensors.get("fmap_fractal").op.input_tensors[0]
    return graph_tensors


class ExtractImagePatchesInfo:

    def __init__(self, outs):
        self.device_core_num = util.get_core_num()
        self.padding_type = get_context().get("paddingType")
        self.soc_version = get_context().get("soc_version")
        self.ori_shape_range = get_context().get("ori_shape_range")
        self.ori_cin_range = get_context().get_current_compute().get("ori_cin_range")
        self.is_const = get_context().get("is_const_shape")
        self.is_binary = get_context().get("is_binary")
        self.var_map = get_context().get("var_map")

        self.graph_info = _collect_graph_info(outs)
        self.dtype_input = self.graph_info.get("ub_res").dtype
        if self.dtype_input in ("int8", "uint8"):
            self.align_block_size = Constant.BLOCK_SIZE_INT8
            self.type_size = Constant.INT8_SIZE
        else:
            self.align_block_size = Constant.BLOCK_SIZE
            self.type_size = Constant.FP16_SIZE

        self.output_res = outs[0]
        self.extract_params = dict()
        extract_map = self.output_res.op.attrs["extract_params"]
        for key, value in extract_map.items():
            if hasattr(value, "value"):
                self.extract_params[key] = value.value
            else:
                self.extract_params[key] = value
        fmap_shape = self.extract_params.get("fmap_shape")
        self.fmap_n = fmap_shape[0]
        self.fmap_c1 = fmap_shape[1]
        self.fmap_h = fmap_shape[2]
        self.fmap_w = fmap_shape[3]
        self.fmap_c0 = fmap_shape[4]

        self.out_h = self.extract_params.get("out_h")
        self.out_w = self.extract_params.get("out_w")
        self.origin_c_in = self.extract_params.get("origin_c_in")

        self.setfmatrix_dict = dict()
        setfmatrix_map = self.output_res.op.attrs["setfmatrix_dict"]
        for key, value in setfmatrix_map.items():
            if hasattr(value, "value"):
                self.setfmatrix_dict[key] = value.value
            else:
                self.setfmatrix_dict[key] = value

        self.setfmatrix_dict["set_fmatrix"] = 1
        self.setfmatrix_dict["conv_fm_c1"] = 1
        self.setfmatrix_dict["conv_fm_c0"] = self.fmap_c0
        self.setfmatrix_dict["group_flag"] = 0
        self.setfmatrix_dict["l1_group_flag"] = 0

        self.kernel_h = self.setfmatrix_dict.get("conv_kernel_h")
        self.kernel_w = self.setfmatrix_dict.get("conv_kernel_w")
        self.dilate_h = self.setfmatrix_dict.get("conv_dilation_h")
        self.dilate_w = self.setfmatrix_dict.get("conv_dilation_w")
        stride_h = self.setfmatrix_dict.get("conv_stride_h")
        stride_w = self.setfmatrix_dict.get("conv_stride_w")

        self.used_ub_size = Constant.SIZE_UB // self.type_size // Constant.DOUBLE_BUFFER
        self.avg_split_ub_size = self.used_ub_size // Constant.NEED_UB_SPACE_NUM

        self.khkw = self.kernel_h * self.kernel_w
        self.c_out = self.khkw * self.fmap_c1 * self.fmap_c0
        self.ksize_hw = [self.kernel_h, self.kernel_w]
        self.stride_hw = [stride_h, stride_w]
        self.dilate_hw = [self.dilate_h, self.dilate_w]
        self.ub_storage_bound = Constant.SIZE_UB // self.type_size
