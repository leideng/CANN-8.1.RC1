#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2023-2024 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
stage info
"""
import dataclasses
from typing import List
from typing import Optional
from typing import Type

from tbe.tvm import Stage
from tbe.tvm.tir import IterVar

from . import node_base_info
from . import tensor_info
from .. import constants
from .. import helper
from ..... import util as unify_helper


@dataclasses.dataclass
class AlignInfo:
    actual_aligned: bool = True
    enable_align: bool = False
    align_factor: int = None


@dataclasses.dataclass
class SplitInfo:
    factor: int = None
    nparts: int = None
    ori_axis: IterVar = None
    outer_axis: IterVar = None
    inner_axis: IterVar = None


@dataclasses.dataclass
class StageFlags:
    cache_read_flag: bool = False
    cache_write_flag: bool = False
    cache_clone_flag: bool = False
    compute_inline_flag: bool = False
    split_flag: bool = False
    rfactor_flag: bool = False
    double_buffer_flag: bool = False
    mem_unique_flag: bool = False
    compute_root_flag: bool = False


class StageBase():
    def __init__(self, tvm_stage):
        self._tvm_stage: Stage = tvm_stage
        self._flags: StageFlags = StageFlags()
        self._compute_inlined_stage_obj: Optional["StageBase"] = None
        self._reuse_tensor_obj_list: List[Type[tensor_info.TensorBase]] = []
        self._align_info: AlignInfo = AlignInfo()
        self._split_info_list: List[SplitInfo] = []
        self._buffer_ele_num = -1

    def __eq__(self, stage_base_obj):
        return self._tvm_stage == stage_base_obj.tvm_stage

    def __hash__(self):
        return self._tvm_stage.__hash__()

    def __ne__(self, stage_base_obj):
        return self._tvm_stage != stage_base_obj.tvm_stage

    def __repr__(self):
        return self._tvm_stage.__repr__()

    @property
    def tvm_stage(self):
        return self._tvm_stage

    @property
    def flags(self):
        return self._flags

    @flags.setter
    def flags(self, value):
        self._flags = value

    @property
    def compute_inlined_stage_obj(self):
        return self._compute_inlined_stage_obj

    @compute_inlined_stage_obj.setter
    def compute_inlined_stage_obj(self, value):
        self._compute_inlined_stage_obj = value

    @property
    def reuse_tensor_obj_list(self):
        return self._reuse_tensor_obj_list

    @property
    def align_info(self):
        return self._align_info

    @align_info.setter
    def align_info(self, value):
        self._align_info = value

    @property
    def split_info_list(self):
        return self._split_info_list

    @property
    def buffer_ele_num(self):
        return self._buffer_ele_num

    def copy(self, ori_stage_obj):
        self._flags = ori_stage_obj.flags
        self._compute_inlined_stage_obj = ori_stage_obj.compute_inlined_stage_obj
        self._align_info = ori_stage_obj.align_info
        self._split_info_list = ori_stage_obj.split_info_list[:]
        self._buffer_ele_num = ori_stage_obj.buffer_ele_num
        self._reuse_tensor_obj_list = ori_stage_obj.reuse_tensor_obj_list[:]

    def unify_storage_align(self, axis, factor, offset):
        self._tvm_stage.storage_align(axis, factor, offset)

    def unify_compute_align(self, axis, factor, pad=None):
        self._tvm_stage.compute_align(axis, factor, pad)

    def unify_bind_buffer(self, axis, stride, offset):
        self._tvm_stage.bind_buffer(axis, stride, offset)

    def unify_compute_inline(self, instant=False):
        self._tvm_stage.compute_inline(instant)
        self._flags.compute_inline_flag = True

    def unify_set_scope(self, scope):
        self._tvm_stage.set_scope(scope)

    def unify_split(self, axis, factor=None, nparts=None):
        outer, inner = self._tvm_stage.split(axis, factor=factor, nparts=nparts)
        self._flags.split_flag = True
        self._split_info_list.append(SplitInfo(factor, nparts, axis, outer, inner))

        return outer, inner

    def unify_fuse(self, *args):
        return self._tvm_stage.fuse(*args)

    def unify_bind(self, ivar, thread_ivar):
        self._tvm_stage.bind(ivar, thread_ivar)

    def unify_compute_at(self, target_stage_obj, axis):
        self._tvm_stage.compute_at(target_stage_obj.tvm_stage, axis)

    def unify_compute_root(self):
        self._tvm_stage.compute_root()
        self._flags.compute_root_flag = True

    def unify_reorder(self, *args):
        self._tvm_stage.reorder(*args)

    def unify_emit_insn(self, axis, insn_value, insn_attrs=None):
        local_attrs = {} if insn_attrs is None else insn_attrs
        self._tvm_stage.emit_insn(axis, insn_value, attrs=local_attrs)

    def unify_reused_by(self, *args, **kwargs):
        self._tvm_stage.reused_by(*[s.tvm_tensor for s in args], **kwargs)
        if args:
            self._reuse_tensor_obj_list = list(args)

    def unify_mem_unique(self):
        self._tvm_stage.mem_unique()
        self._flags.mem_unique_flag = True

    def unify_double_buffer(self):
        self._tvm_stage.double_buffer()
        self._flags.double_buffer_flag = True

    def unify_buffer_size(self, bound):
        self._tvm_stage.set_buffer_size(bound)
        self._buffer_ele_num = bound

    def unify_set_store_predicate(self, predicate):
        self._tvm_stage.set_store_predicate(predicate)

    def is_ub_scope(self):
        return self._tvm_stage.scope == constants.UB_SCOPE


class BroadcastStage(node_base_info.BroadcastNodeBase, StageBase):
    def __init__(self, tvm_stage):
        node_base_info.BroadcastNodeBase.__init__(self)
        StageBase.__init__(self, tvm_stage)
        self._length = len(tvm_stage.op.axis)
        self._broadcast_axes_indices = self._get_broadcast_axes_indices()
        self._node_pattern = self._get_node_pattern()

    def is_support_inline(self):
        if len(self._broadcast_axes_indices) == self._length:
            return True

        if self.is_last_broadcast():
            return False

        if not self._align_info.enable_align and not self._align_info.actual_aligned:
            return False

        return True

    def _get_broadcast_axes_indices(self):
        if hasattr(self._tvm_stage.op, "input_tensors") and self._tvm_stage.op.input_tensors:
            if hasattr(self._tvm_stage.op.input_tensors[0].op, "axis"):
                src_axes = list(self._tvm_stage.op.input_tensors[0].op.axis)
            else:
                # src may be placeholder
                src_axes = list(self._tvm_stage.op.input_tensors[0].shape)
        else:
            src_axes = None

        if src_axes is None:
            return list(range(self._length))

        src_axes_len = len(src_axes)
        # add 1 to the front
        if src_axes_len < self._length:
            src_axes = [1] * (self._length - src_axes_len) + src_axes

        dst_axes = self._tvm_stage.op.axis
        broadcast_axes_indices = []
        for idx in range(self._length):
            if isinstance(src_axes[idx], IterVar):
                if not helper.judge_the_equality_of_iter_vars(src_axes[idx], dst_axes[idx]):
                    broadcast_axes_indices.append(idx)
            else:
                if helper.compare_value_vs_value(src_axes[idx], 1, constants.CmpOp.EQ):
                    broadcast_axes_indices.append(idx)

        return broadcast_axes_indices


class ReduceStage(node_base_info.ReduceNodeBase, StageBase):
    def __init__(self, tvm_stage):
        node_base_info.ReduceNodeBase.__init__(self)
        StageBase.__init__(self, tvm_stage)
        self._before_reduce_shape_length = len(tvm_stage.op.input_tensors[0].shape)
        self._after_reduce_shape_length = len(tvm_stage.op.axis)
        self._reduce_axes_indices = self._get_reduce_axes_indices()
        self._keep_dims = self._before_reduce_shape_length == self._after_reduce_shape_length
        self._node_pattern = self._get_node_pattern()

    @property
    def keep_dims(self):
        return self._keep_dims

    @keep_dims.setter
    def keep_dims(self, value):
        self._keep_dims = value

    def _get_reduce_axes_indices(self):
        return unify_helper.get_reduce_axis_indexes(self._tvm_stage)


class DataMoveStage(node_base_info.DataMoveNodeBase, StageBase):
    def __init__(self, tvm_stage):
        node_base_info.DataMoveNodeBase.__init__(self)
        StageBase.__init__(self, tvm_stage)


class CommonStage(node_base_info.CommonNodeBase, StageBase):
    def __init__(self, tvm_stage):
        node_base_info.CommonNodeBase.__init__(self)
        StageBase.__init__(self, tvm_stage)
