#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
pooling helper
"""
from enum import Enum

from tbe.common.utils.errormgr import get_error_message

from ...constants import INSN_MAPPING
from ...util import get_dsl_insn


class PoolingConstants:
    """
    constants of pooling
    """
    ELEWISE_TAG = "elewise"
    PAD_TAG = "pad_window"
    REDUCE_WINDOW_TAG = "reduce_window"

    CONST = "const"
    CONST_MODE_KEY = 0xfff
    POOLING_SCH_ID = 0x1b

    BLOCK_IDX = "blockIdx.x"
    LOCAL_UB = "local.UB"
    STORAGE_BOUND = "storage_bound"
    NO_OVERLAP = "no_overlap"
    DMA_COPY = "dma_copy"
    PHONY_INSN = "phony_insn"

    WINDOW = "window"

    WINDOW_SPLIT_THRESHOLD = 125

    WINDOW_AXES_TYPE_AND_KEY_MAP = {
        "normal": 0,
        "split": 1,
        "none_reduce": 2,
        "global_reduce": 3,
    }


class PoolingSchType(Enum):
    """
    sch type
    """
    COMMON = "common"
    WINDOW_SPLIT = "window_split"


def raise_error(message):
    """
    raise error
    """
    dict_args = {"errCode": "E90003", "detailed_cause": message}
    raise RuntimeError(dict_args, get_error_message(dict_args))


def get_insn(tensor):
    """
    get insn
    """
    insn = get_dsl_insn(tensor)

    return INSN_MAPPING.get(insn, insn)


def reorder_reduce_window_shape(shape, window_indices, is_reduce_last_axis):
    """
    reorder reduce window shape: A0 W0 A1 W1 W2 A2 -> A0 A1 W0 W1 W2 A2
    """
    return _reorder_reduce_last_shape(shape, window_indices) if is_reduce_last_axis else \
        _reorder_reduce_nlast_shape(shape, window_indices)


def _reorder_reduce_last_shape(shape, window_indices):
    ori_to_reorder_axis_map = {}
    reorder_to_ori_axis_map = {}
    reordered_shape = []
    temp_axis = 0
    for i, ele in enumerate(shape):
        if i not in window_indices:
            reordered_shape.append(ele)
            reorder_to_ori_axis_map[temp_axis] = i
            ori_to_reorder_axis_map[i] = temp_axis
            temp_axis += 1

    for i, ele in enumerate(shape):
        if i in window_indices:
            reordered_shape.append(ele)
            reorder_to_ori_axis_map[temp_axis] = i
            ori_to_reorder_axis_map[i] = temp_axis
            temp_axis += 1

    return reordered_shape, reorder_to_ori_axis_map, ori_to_reorder_axis_map


def _reorder_reduce_nlast_shape(shape, window_indices):
    last_none_reduce_axis = max(window_indices) + 1
    ori_to_reorder_axis_map = {}
    reorder_to_ori_axis_map = {}
    reordered_shape = list(shape)
    temp_axis = last_none_reduce_axis - 1
    for i in range(len(window_indices) - 1, -1, -1):
        reordered_shape[temp_axis] = shape[window_indices[i]]
        reorder_to_ori_axis_map[temp_axis] = window_indices[i]
        ori_to_reorder_axis_map[window_indices[i]] = temp_axis
        temp_axis -= 1

    for i in range(last_none_reduce_axis - 1, -1, -1):
        if i not in window_indices:
            reordered_shape[temp_axis] = shape[i]
            reorder_to_ori_axis_map[temp_axis] = i
            ori_to_reorder_axis_map[i] = temp_axis
            temp_axis -= 1

    for i in range(last_none_reduce_axis, len(shape)):
        reorder_to_ori_axis_map[i] = i
        ori_to_reorder_axis_map[i] = i

    return reordered_shape, reorder_to_ori_axis_map, ori_to_reorder_axis_map


def judge_tvm_shape_equal(shape_a, shape_b):
    """
    compare two tvm shape
    """
    length_a = len(shape_a)
    length_b = len(shape_b)
    if length_a != length_b:
        return False

    for _, (dim_a, dim_b) in enumerate(zip(shape_a, shape_b)):
        has_value = hasattr(dim_a, "value") and hasattr(dim_b, "value")
        has_name = hasattr(dim_a, "name") and hasattr(dim_b, "name")
        if has_value:
            if dim_a.value != dim_b.value:
                return False
        elif has_name:
            if dim_a.name != dim_b.name:
                return False
        else:
            if dim_a != dim_b:
                return False

    return True
