#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
cube ops tiling case base class
"""

import copy
import itertools
import math
from abc import abstractmethod
from collections import deque
from functools import reduce

from tbe import tvm
from tbe.common.context import get_context
from tbe.common.platform import platform_info as tbe_platform_info
from tbe.common.tiling import get_tiling_type
from tbe.common.tiling import set_tiling_type
from tbe.common.tiling import tiling_api
from tbe.common.utils import decode
from tbe.common.utils import do_op_tiling
from tbe.common.utils import log
from tbe.common.utils.errormgr import error_manager_cube as cube_err
from tbe.common.utils.op_util.op_util_cube import decode_tiling_v1_to_v2
from tbe.dsl.base.operation import add_compile_info
from tbe.dsl.base.operation import add_exclude_buildargs_var
from tbe.dsl.base.operation import get_compile_info
from tbe.dsl.base.operation import get_context as get_base_op_context
from tbe.dsl.base.operation import get_op_context
from tbe.dsl.classifier.util import LoadModeType
from tbe.dsl.static_schedule.util import get_op_impl_mode_enum
from tbe.tvm.ir import PrimExpr
from tbe.tvm.tir import IntImm

C0_SIZE = 16
W_DELTA = 1
H_LEN = 400
W_LEN = 400
NHW_RANGE_LEN = 6
MAX_RANGE = 2**31 - 1
NDHW_RANGE_LEN = 8
BLOCK_DIM_SIZE = 4
INVALID_TILING_FLAG = 32
# For do_op_tiling, Attrs supported dtypes: bool/float/float32/int/int32/list_bool/
# list_float/list_float32/list_int/list_int32/list_list_int/list_list_int32/list_str/str
TYPE_TO_STR = {int: "int", str: "str", bool: "bool", tuple: "tuple_int", list: "list_int"}


class CubeTilingOp:
    """
    tiling public const and func
    """
    def __init__(self, tiling_info, dynamic_mode, var_map=None):
        self.tiling_info = tiling_info
        self.key = None
        self.var_map = var_map
        self.dynamic_mode = dynamic_mode
        self.op_type = None
        self.binary_mode = 0
        self.load_mode = 0
        self.strideh_read_flag = False

    @staticmethod
    def _convert_type(*info_items):
        """
        convert tvm var to -1
        """
        for item in info_items:
            for i, element in enumerate(item):
                if isinstance(element, IntImm):
                    item[i] = int(element)
                elif isinstance(element, PrimExpr):
                    item[i] = -1

    @staticmethod
    def get_batch_range(batch, paras):
        """
        get batch covering range
        """
        if "batch_n" in paras.get("var_map"):
            core_num = tbe_platform_info.get_soc_spec("CORE_NUM")
            batch_max = MAX_RANGE
            if batch > MAX_RANGE:
                batch_max = batch
            if batch >= core_num:
                return core_num, batch_max
            if core_num == TilingUtils.N_BASE:
                return 1, batch_max
            batch_log = int(math.log(batch, TilingUtils.N_BASE))
            return TilingUtils.N_BASE ** batch_log, TilingUtils.N_BASE ** (int(batch_log + 1))
        return batch, batch

    @staticmethod
    def get_h_range(fmap_h, tiling, paras):
        """
        get h covering range
        """
        if "dx_h" in paras.get("var_map") or "fmap_h" in paras.get("var_map"):
            if not tiling["AL1_shape"]:
                return 1, fmap_h
            hi_min = TilingUtils.HW_MIN
            if paras.get("pad_mode") != "VAR":
                hi_min = max(paras.get("k_h") - paras.get("pads")[2] - paras.get("pads")[3], hi_min)
            hi_min = max(hi_min, fmap_h - H_LEN)
            hi_max = min(TilingUtils.NHW_MAX, fmap_h + H_LEN)
            return hi_min, hi_max
        return fmap_h, fmap_h

    @staticmethod
    def check_tiling_match(tiling, current_w, current_h):
        """
        check whether this tiling matches the shape

        Parameters
        ----------
        tiling : dict, result of tiling fetch

        current_w : int, size of w

        current_h : int, size of h

        Returns
        -------
        bool, True: match
        False: do not match

        """

    @staticmethod
    def get_default_range(tgt_area):
        """
        get default range
        Parameters
        ----------
        tgt_area: tuple, target area to be covered

        Returns
        -------
        tgt_area: list, target area to be covered
        """
        return [bound if bound is not None else MAX_RANGE for bound in tgt_area]

    @staticmethod
    def get_hardware_info():
        base_info_keys = [
            tbe_platform_info.UB_SIZE, tbe_platform_info.L2_SIZE, tbe_platform_info.L1_SIZE, tbe_platform_info.L0A_SIZE,
            tbe_platform_info.L0B_SIZE, tbe_platform_info.L0C_SIZE, tbe_platform_info.CORE_NUM,
            tbe_platform_info.BT_SIZE, "load3d_constraints"
        ]
        intrinsic_keys = [
            "Intrinsic_data_move_l12ub", "Intrinsic_data_move_l0c2ub", "Intrinsic_fix_pipe_l0c2out",
            "Intrinsic_data_move_out2l1_nd2nz"
        ]
        hardware_info = {}
        for key in base_info_keys:
            hardware_info[key] = tbe_platform_info.get_soc_spec(key)

        for key in intrinsic_keys:
            hardware_info[key] = tbe_platform_info.intrinsic_check_support(key)
        return hardware_info

    @staticmethod
    def get_dyn_constant_tiling(tiling_cases, tiling_data, tiling_key, op_name):
        dynamic_vars = get_base_op_context().get_current_compute().get_vars()
        for x in dynamic_vars:
            add_exclude_buildargs_var(x)
        if tiling_key is not None:
            for tiling in tiling_cases:
                if tiling.get("key") == tiling_key:
                    log.info("[in dynamic constantization scene]hit the target tiling: {}".format(tiling_key))
                    tiling["tiling_strategy"]["binary_tiling_data"] = tiling_data
                    return [tiling]
            cube_err.raise_err_specific(op_name, "[in dynamic constantization scene] do not hit the target tiling.")
            return []
        return None

    @staticmethod
    def _get_choice_list():
        """
        get binary template choice list
        """
        pass

    @abstractmethod
    def get_repo_tiling(self):
        """
        get tiling from repository

        Returns
        -------
        tiling: shape and tiling retrieved from repository
        """

    @abstractmethod
    def get_costmodel_tiling(self, shape):
        """
        get tiling using cost model

        Parameters
        ----------
        shape: specified shape to get tiling

        Returns
        -------
        tiling: tiling retrieved by cost model
        """

    @abstractmethod
    def get_tiling_range(self, tiling_in, shape_info):
        """
        get the covered area of a tiling

        Parameters
        ----------
        tiling_in : dict, result of tiling fetch

        shape_info : list, size of fmap_shape

        Returns
        -------
        list, range covered for tiling_in
        """

    @abstractmethod
    def assembly_case(self, tiling_strategy, covered, cnt):
        """
        tiling_strategy : dict, result of tiling fetch

        covered : list, size of dymanic element

        cnt: index of tiling

        Returns
        -------
        tiling_case, range covered for tiling
        """

    def get_w_range(self, fmap_h, fmap_w, tiling, paras):
        """
        get w covering range
        """
        if "dx_w" in paras.get("var_map") or "fmap_w" in paras.get("var_map"):
            if not tiling["AL1_shape"]:
                return 1, fmap_w
            wi_min = TilingUtils.HW_MIN
            if paras.get("pad_mode") != "VAR":
                wi_min = max(paras.get("k_w") - paras.get("pads")[0] - paras.get("pads")[1], wi_min)
            support_w_min = wi_min
            cur_w_size = fmap_w
            # searching up-ward fo rw_max
            while self.check_tiling_match(tiling, cur_w_size, fmap_h) and cur_w_size > support_w_min:
                wi_min = cur_w_size
                cur_w_size = cur_w_size - W_DELTA
            # searching down-ward for w_min
            cur_w_size = fmap_w
            while self.check_tiling_match(tiling, cur_w_size, fmap_h) and cur_w_size <= TilingUtils.NHW_MAX:
                wi_max = cur_w_size
                cur_w_size = cur_w_size + W_DELTA

            wi_min = max(wi_min, fmap_w - W_LEN)
            wi_max = min(wi_max, fmap_w + W_LEN)
            if wi_min > wi_max:
                return 0, 0
            return wi_min, wi_max
        return fmap_w, fmap_w

    def get_cache_tiling(self, strideh_read_flag=None, load_mode=None):
        '''
        Generate tiling cases based on combinations of all attach flags.

        Returns
        ----------
        tiling_cases: list of all tiling templates.
        '''
        if load_mode is not None:
            self.load_mode = load_mode
        if strideh_read_flag is not None:
            self.strideh_read_flag = strideh_read_flag
        b_dtype = 'b_dtype' if 'b_dtype' in self.tiling_info.keys() else 'B_dtype'
        block_reduce = tbe_platform_info.CUBE_MKN.get(self.tiling_info[b_dtype]).get('mac')[1]
        cache_tiling_all = {}
        choice_list = self._get_choice_list()
        for choice in choice_list:
            if self._check_invalid_choice(choice):
                continue

            cache_tiling = {
                'block_dim': [-1, -1, -1, -1, 1],
                'g_dim': -1,
                'AL0_matrix': [-1, -1, TilingUtils.CUBE_SIZE, block_reduce, 1],
                'BL0_matrix': [-1, -1, TilingUtils.CUBE_SIZE, block_reduce, 1],
                'CL0_matrix': [-1, -1, TilingUtils.CUBE_SIZE, TilingUtils.CUBE_SIZE, 1],
                'L0C_OUTPUT_matrix': [-1, -1, TilingUtils.CUBE_SIZE, TilingUtils.CUBE_SIZE, 1],
                'BUB_shape': [-1, -1, 1, 1],
                'AL1_shape': [-1, -1, 1, 1], 'BL1_shape': [-1, -1, 1, 1],
                'AUB_shape': [-1, -1, 1, 1],
                'control_reorder_flag': 0,
                'special_optimize_flag': 0, 'UB_channel_wise_input': [None, None, False],
                'manual_pingpong_buffer': {'AUB_pbuffer': TilingUtils.DB_ON, 'BUB_pbuffer': TilingUtils.DB_ON,
                'AL1_pbuffer': TilingUtils.DB_ON, 'BL1_pbuffer': TilingUtils.DB_ON,
                'AL0_pbuffer': TilingUtils.DB_ON, 'BL0_pbuffer': TilingUtils.DB_ON, 'CL0_pbuffer': TilingUtils.DB_ON,
                'UBG_pbuffer': TilingUtils.DB_OFF, "INPUT_L1_FB_pbuffer": TilingUtils.DB_OFF,
                "INPUT_L1_BT_pbuffer": TilingUtils.DB_OFF,
                'INPUT_L1_eltwise_pbuffer': TilingUtils.DB_OFF, 'L0C_OUTPUT_pbuffer': TilingUtils.DB_ON},
                'attach_at_flag': {'cub_attach_flag': TilingUtils.ATTACH_LESS,
                'cl0_attach_flag': TilingUtils.ATTACH_LARGE, 'al0_attach_flag': TilingUtils.ATTACH_LESS,
                'bl0_attach_flag': TilingUtils.ATTACH_LESS,
                'al1_attach_flag': -1, 'bl1_attach_flag': -1, 'aub_attach_flag': TilingUtils.ATTACH_LESS,
                'abkl1_attach_flag': -1},
                'load3d_special_flag': 0,
                'conv1d_flag': 0,
                'pad_greater_than_filter': 0,
            }
            cache_tiling, tiling_id = self._gen_cache_tiling(cache_tiling, choice)
            cache_tiling_all[tiling_id] = [[], cache_tiling, []]

        tiling_cases = []
        for k, v in cache_tiling_all.items():
            tiling_cases.append(self.assembly_case(v[1], v[0], k))

        return tiling_cases

    def _gen_cache_tiling(self, cache_tiling, choice):
        """
        gen template tilingId
        """
        raise NotImplementedError()

    def _check_invalid_choice(self, choice):
        al1_pb, abkl1_attach, al1_attach_flag, bl1_attach_flag, load3d_special_flag, *_ = choice
        # 1) a_l1 full_load or a_l1 full_k, b_l1 full_load or full_k: a_kl1 equals a_bkl1;
        invalid_choice = (
            al1_attach_flag in (TilingUtils.ATTACH_FULL_LOAD, TilingUtils.ATTACH_EQUAL) and
            bl1_attach_flag in (TilingUtils.ATTACH_FULL_LOAD, TilingUtils.ATTACH_EQUAL) and
            abkl1_attach != TilingUtils.ATTACH_FULL_LOAD
        )

        # 2) a_l1 full_load or full_k, b_l1 k_split: a_kl1 > b_kl1 & reorder_l1_mn is 1;
        invalid_choice |= (
            al1_attach_flag in (TilingUtils.ATTACH_FULL_LOAD, TilingUtils.ATTACH_EQUAL) and
            bl1_attach_flag == TilingUtils.ATTACH_LESS and
            (abkl1_attach != TilingUtils.ATTACH_EQUAL)
        )

        # 3) a_l1 k_split, b_l1 full_load or full_k: a_kl1 < b_kl1 & reorder_l1_mn is 0;
        invalid_choice |= (
            al1_attach_flag == TilingUtils.ATTACH_LESS and
            bl1_attach_flag in (TilingUtils.ATTACH_FULL_LOAD, TilingUtils.ATTACH_EQUAL) and
            abkl1_attach != TilingUtils.ATTACH_LESS
        )

        # 4) a_l1 full_load to a_l1_pb off
        invalid_choice |= (
            al1_attach_flag == TilingUtils.ATTACH_FULL_LOAD and
            al1_pb != TilingUtils.DB_OFF
        )

        # 5) load3d_special_flag and load2d/load3d_w_split/dma_cpy is invalid
        invalid_choice |= (load3d_special_flag == 1 and self.load_mode in
                           [LoadModeType.LOAD2D, LoadModeType.W_SPLIT_LOAD3D, LoadModeType.DMA_CPY])

        return invalid_choice


class TilingSelection:
    """
    Select tiling
    """
    def __init__(self, tiling_op: CubeTilingOp, cnt=None):
        """
        init TilingSelection
        Parameters
        ----------
        tiling_op: CubeTilingOp
        cnt: initial value of tiling key counter
        """
        self.op = tiling_op
        if not isinstance(cnt, int):
            cnt = 10000
            fuzz_build = get_context().get_build_type() == "fuzzily_build"
            if fuzz_build:
                # >>> start: get kernel id
                kernel_id = get_context().get_addition("max_kernel_id")
                valid = isinstance(kernel_id, int) and kernel_id > -2
                if valid:
                    cnt = kernel_id + 1
                # <<< end: get kernel id
        self.seed_cnt = itertools.count(cnt)

    @staticmethod
    def _modify_conv2d_tiling_batch(conv2d_modify_tiling, seed):
        """
        modify conv2d tiling batch
        """
        if conv2d_modify_tiling:
            tiling = seed["tiling"]
            tiling["n_bef_batch_flag"] = 1
            seed["tiling"] = tiling
        return seed

    @staticmethod
    def _select_tiling(tgt_area, repo_tilings):
        """
        select repo seeds tiling to cover target area

        Parameters
        ----------
        tgt_area: tuple, hw range to be covered (n_min, n_max, h_min, h_amx, w_min, w_max)
        repo_tilings: dict, repo seeds tilings with id

        Returns
        -------
        res: default_dict, tilings with covered area
        rest_area: deque, uncovered areas
        """

        sort_tiling_list = sorted(repo_tilings.items(),
                                  key=lambda x: _cal_overlap(tgt_area, x[1][0])[0],
                                  reverse=True)
        rest_area = set()
        rest_area.add(tgt_area)

        for _, t_info in sort_tiling_list:
            generate_area = set()
            delete_area = set()
            for ra in rest_area:
                overlap, _ = _cal_overlap(ra, t_info[0])
                if overlap == 0:
                    continue
                generate_area |= set(_cut_rectangle(ra, t_info[0]))
                delete_area.add(ra)
            rest_area = (rest_area - delete_area) | generate_area

        return deque(rest_area)

    def calc_tiling(self, target_area, var_names=()):
        """
        calculate tilings

        Parameters
        ----------
        target_area: tuple, target area to be covered

        Returns
        -------
        tilings_cases: list, calculated tilings
        """
        if self.op.op_type not in ("conv2d", "conv2d_backprop_input"):
            add_compile_info("hardware_info", self.op.get_hardware_info())

        if self.op.op_type in ("conv2d", "conv2d_backprop_input", "conv2d_backprop_filter"):
            tiling_cases = self._handle_dynamic_nhw(target_area, var_names)
        elif self.op.op_type in ("conv3d_backprop_input", "convolution_3d", "conv3d_bp_filter"):
            tiling_cases = self._handle_dynamic_ndhw(target_area, var_names)
        else:
            add_compile_info("dynamic_mode", self.op.dynamic_mode)
            if self.op.dynamic_mode in ("dynamic_mkn", "dynamic_mknb", "weight_quant_bmm"):
                tiling_cases = self._calc_matmul(target_area)
            else:
                raise RuntimeError("Only dynamic_hw/dynamic_batch "
                                   "is supported")
        self._handle_block_dim(tiling_cases)
        return tiling_cases

    def covered_cost_model_batch_v2(self, cost_cases, tiling_selections):
        """
        for batch_v2 mode, calc covered space of cost_model
        """
        while cost_cases:
            for _ in range(len(cost_cases)):
                cut_range = cost_cases.popleft()
                cost_seed = self.op.get_costmodel_tiling(sum(cut_range) // 2)
                seed_range = self.op.get_batch_range(cost_seed['tiling'],
                                                     cost_seed[self.op.key])
                overlap_line = _cal_overlap_line(cut_range, seed_range)
                if overlap_line:
                    cost_cases.extend(_cut_line(cut_range, seed_range))
                    tiling_selections[next(self.seed_cnt)] = \
                        [cost_seed['tiling'], overlap_line]
                else:
                    raise RuntimeError("totally uncovered!!!")
        return tiling_selections

    def _handle_dynamic_nhw(self, target_area, var_names):
        """
        handle dynamic nhw
        Parameters
        ----------
        target_area: tuple, target area to be covered

        var_names: list or tuple, var name

        Returns
        -------
        tiling_cases: list, tiling result
        """
        batch_name, h_name, w_name = var_names
        tgt_area = [*target_area.get(batch_name), *target_area.get(h_name), *target_area.get(w_name)]
        if self.op.op_type in ("conv2d", "QuantConv2D") and self.op.cache_tiling_flag:
            template_candidates = self.op.get_cache_tiling()
            tiling_cases = [self.op.assembly_case(v[1], v[0], k) for k, v in template_candidates.items()]
            add_compile_info("tiling_type", "binary")
            return tiling_cases
        if self.op.binary_mode:
            if self.op.op_type in ("conv2d_backprop_input", "conv2d_backprop_filter"):
                ub_fusion_para = self.op.get_ub_fusion_para()
                aub_num = ub_fusion_para.get("aub_num")
                bub_num = ub_fusion_para.get("bub_num")
                cub_num = ub_fusion_para.get("cub_num")
            else:
                raise RuntimeError("Binary mode only supports conv2d_backprop_input and conv2d_backprop_filter")
            add_compile_info("aub_num", aub_num)
            add_compile_info("bub_num", bub_num)
            add_compile_info("cub_num", cub_num)
            add_compile_info("tiling_type", "binary")
            add_compile_info("binary_mode", self.op.binary_mode)
            tiling_cases = self.op.get_cache_tiling()
        elif None in tgt_area:
            seed_cnt = next(self.seed_cnt)
            default_tiling = self.op.get_default_tiling(target_area.get(w_name)[0])
            tiling_cases = [self.op.assembly_case(default_tiling, tgt_area, seed_cnt)]
            add_compile_info("tiling_type", "default_tiling")
            add_compile_info("default_range", {str(seed_cnt): self.op.get_default_range(tgt_area)})
        else:
            add_compile_info("tiling_type", "dynamic_tiling")
            if h_name in self.op.var_map or w_name in self.op.var_map:
                tiling_cases = self._calc_nhw([target_area.get(key) for key in target_area])
            elif batch_name in self.op.var_map:
                tiling_cases = self._calc_batch([target_area.get("batch_n")])
            else:
                raise RuntimeError("Only dynamic N/H/W is supported")
        return tiling_cases

    def _handle_dynamic_ndhw(self, target_area, var_names):
        """
        handle dynamic ndhw
        Parameters
        ----------
        tgt_area: tuple, target area to be covered

        var_names: list or tuple, var name

        Returns
        -------
        tiling_cases: list, tiling result
        """
        batch_name, d_name, h_name, w_name = var_names
        tgt_area = [*target_area.get(batch_name), *target_area.get(d_name),
                    *target_area.get(h_name), *target_area.get(w_name)]
        if self.op.binary_mode:
            add_compile_info("tiling_type", "binary")
            add_compile_info("binary_mode", self.op.binary_mode)
            tiling_cases = self.op.get_cache_tiling()
        elif None in tgt_area:
            seed_cnt = next(self.seed_cnt)
            default_tiling = self.op.get_default_tiling()
            tiling_cases = [self.op.assembly_case(default_tiling, tgt_area, seed_cnt)]
            add_compile_info("tiling_type", "default_tiling")
            add_compile_info("default_range", {str(seed_cnt): self.op.get_default_range(tgt_area)})
        else:
            add_compile_info("tiling_type", "dynamic_tiling")
            if h_name in self.op.var_map or w_name in self.op.var_map or d_name in self.op.var_map:
                tiling_cases = self._calc_ndhw([target_area.get(key) for key in target_area])
            elif batch_name in self.op.var_map:
                batch_func_map = {"conv3d_bp_filter": self._calc_batch_v2}
                batch_func = batch_func_map.get(self.op.op_type, self._calc_batch)
                tiling_cases = batch_func([target_area.get("batch_n")])
            else:
                raise RuntimeError("Only dynamic N/D/H/W is supported")
        return tiling_cases

    def _handle_block_dim(self, tiling_cases):
        """
        handle block dim
        Parameters
        ----------
        tiling_cases: list, tiling result
        """
        tiling_blockdim = {}
        correct_range_flag = False
        for case in tiling_cases:
            if (self.op.op_type in ("conv3d_backprop_input") and not self.op.binary_mode and
                case['tiling_strategy']['BUB_shape'] is not None):
                tiling_blockdim[case['key']] = (case["block_dim"] if "block_dim" in case else
                                                int(reduce(lambda x, y: x * y,
                                                case['tiling_strategy']['block_dim'])) *
                                                case['tiling_strategy']['BUB_shape'][0])
            elif (-1 in case['tiling_strategy']['block_dim']
                  or any(isinstance(x, tvm.tir.expr.Var) for x in case['tiling_strategy']['block_dim'])):
                continue
            else:
                tiling_blockdim[case['key']] = (case["block_dim"] if "block_dim" in case else
                    int(reduce(lambda x, y: x * y, case['tiling_strategy']['block_dim'][:BLOCK_DIM_SIZE])))
            correct_range_flag = case.get("correct_range_flag")
        if self.op.op_type in ("conv2d_backprop_input", ):
            tiling_blockdim.update(get_compile_info().get("block_dim", {}))
        add_compile_info("block_dim", tiling_blockdim)
        add_compile_info("correct_range_flag", correct_range_flag)

    def _modify_core_num(self, seed):
        """
        modify core num tilings

        Parameters
        ----------
        seed: dict, tiling seed

        Returns
        -------
        tiling: dict, tiling
        """
        tiling = seed.get("tiling")
        if self.op.op_type != "conv2d":
            return tiling
        block_dims = tiling.get("block_dim")
        block_nums = block_dims[0] * block_dims[1] * block_dims[2]
        if block_nums < tbe_platform_info.get_soc_spec("CORE_NUM"):
            modify_block_batch = seed["A_shape"][0] > 1 and block_dims[0] < seed["A_shape"][0] and \
                                 seed["A_shape"][0] * block_dims[1] * block_dims[2] <= \
                                     tbe_platform_info.get_soc_spec("CORE_NUM")
            if modify_block_batch:
                tiling["block_dim"][0] = seed["A_shape"][0]
                block_dims = tiling["block_dim"]
        tiling_valid = tiling["BL0_matrix"] and tiling["BL1_shape"]
        if tiling_valid:
            co1 = (seed["B_shape"][0] + C0_SIZE - 1) // C0_SIZE
            modify_block_n = block_dims[1] * tiling["BL1_shape"][1] * tiling["BL0_matrix"][1] * 2 < co1 and \
                             co1 // (tiling["BL1_shape"][1] * tiling["BL0_matrix"][1] * 2) * block_dims[0] * \
                             block_dims[2] <= tbe_platform_info.get_soc_spec("CORE_NUM")
            if modify_block_n:
                tiling["block_dim"][1] = co1 // (tiling["BL1_shape"][1] * tiling["BL0_matrix"][1] * 2)
                block_dims = tiling["block_dim"]
        block_nums = block_dims[0] * block_dims[1] * block_dims[2]
        tiling_valid = block_nums < tbe_platform_info.get_soc_spec("CORE_NUM") and tiling["AL1_shape"]
        if tiling_valid:
            hout = self.op.get_output_h(seed["A_shape"][2])
            wout = self.op.get_output_w(seed["A_shape"][3])
            tmp = hout * wout // (tiling["AL0_matrix"][0] * C0_SIZE * tiling["AL1_shape"][1] * block_dims[2])
            if tmp >= 1:
                tmp = tiling["AL0_matrix"][0] * C0_SIZE * tiling["AL1_shape"][1]
                used_core_num = block_dims[0] * block_dims[1]
                tiling["block_dim"][2] = min(
                    (hout*wout + tmp - 1) // tmp, tbe_platform_info.get_soc_spec("CORE_NUM") // used_core_num)

        return tiling

    def _calc_nhw(self, tgt_area):
        """
        calculate tilings for dynamic hw mode

        Parameters
        ----------
        tgt_area: tuple, hw range to be covered (h_min, h_amx, w_min, w_max)

        Returns
        -------
        tilings_cases: list, calculated tilings
        """

        def _correct_seed_range(seed_area):
            funcs = (max, min, max, min, max, min)
            return [func(ta, sa) for func, ta, sa in zip(funcs, tgt_area, seed_area)]

        tgt_area = reduce(lambda x, y: x + y, tgt_area)
        candidates = {}
        repo_seeds = self.op.get_repo_tiling()
        seed_points = set()
        seed_points_dup = set()

        for seed in repo_seeds:
            seed_nhw = (seed[self.op.key][0], seed[self.op.key][2],
                        seed[self.op.key][3])
            seed["tiling"] = self._modify_core_num(seed)
            seed_range = self.op.get_tiling_range(seed['tiling'], seed[self.op.key])
            if seed_range[1] == -1:
                seed_range[1] = tgt_area[1]
            seed_range = seed_range[0] if isinstance(seed_range[0], list) else seed_range

            if seed_nhw in seed_points_dup or _cal_overlap(seed_range, tgt_area)[0] == 0:
                seed_points_dup.add(seed_nhw)
                continue
            seed_points_dup.add(seed_nhw)
            seed_points.add(seed_nhw)
            seed_range = _correct_seed_range(seed_range)
            candidates[next(self.seed_cnt)] = [seed_range, seed['tiling'], seed_nhw]

        cost_cases = self._select_tiling(tgt_area, candidates)
        tiling_cases = [self.op.assembly_case(v[1], v[0], k) for k, v in candidates.items()]

        self._add_repo_compile_info(candidates)

        # call cost model
        cost_tilings, cost_range = self._calc_costmodel(cost_cases)
        tiling_cases += cost_tilings
        if not tiling_cases:
            raise RuntimeError("No tiling generated for this shape and range")

        add_compile_info("cost_range", cost_range)
        return tiling_cases

    def _add_repo_compile_info(self, candidates):
        add_compile_info("repo_seeds", {k: v[-1] for k, v in candidates.items()})
        repo_range = {k: v[0] for k, v in candidates.items()}
        add_compile_info("repo_range", repo_range)
        if "trans_a" in self.op.tiling_info and "trans_b" in self.op.tiling_info:
            add_compile_info("attrs", {"transpose_a": self.op.tiling_info["trans_a"],
            "transpose_b": self.op.tiling_info["trans_b"]})

    def _calc_matmul(self, target_area):
        """
        calculate tilings for dynamic mkn or bmkn mode

        Parameters
        ----------
        target_area:list, range to be covered [[m_min, m_max], [k_min, k_max],
                 [n_min, n_max],[batch_min, batch_max]], batch value exsit when
                 dynamic_mknb mode

        Returns
        -------
        tilings_cases: list, calculated tilings
        """
        tiling_cases = []
        if self.op.use_cache_tiling:
            cache_tiling_candidates = self.op.get_cache_tiling()
            tiling_cases = [self.op.assembly_case(v[2], v[1], v[0], k) for k, v in cache_tiling_candidates.items()]
        return tiling_cases

    def _calc_ndhw(self, tgt_area):
        """
        calculate tilings for dynamic ndhw mode

        Parameters
        ----------
        tgt_area: tuple, dhw range to be covered (n_min, n_max, d_min, d_max, h_min, h_max,
                                                  w_min, w_max)

        Returns
        -------
        tilings_cases: list, calculated tilings
        """

        def _correct_seed_range(seed_area):
            funcs = (max, min, max, min, max, min, max, min)
            return [func(ta, sa) for func, ta, sa in zip(funcs, tgt_area,
                                                         seed_area)]
        tgt_area = reduce(lambda x, y: x + y, tgt_area)
        candidates = {}
        repo_seeds = self.op.get_repo_tiling()
        seed_points = set()

        for seed in repo_seeds:
            seed_ndhw = (seed[self.op.key][0], seed[self.op.key][1],
                        seed[self.op.key][2], seed[self.op.key][3])
            if self.op.op_type in ("convolution_3d", "conv3d_bp_filter"):
                # a shape format is ndc1hwc0
                seed_ndhw = (seed[self.op.key][0], seed[self.op.key][1],
                            seed[self.op.key][3], seed[self.op.key][4])

            seed_range = self.op.get_tiling_range(seed['tiling'], seed[self.op.key])
            if seed_range[1] == -1:
                seed_range[1] = tgt_area[1]
            if seed_range[3] == -1:
                seed_range[3] = tgt_area[3]
            if seed_ndhw in seed_points or _cal_overlap(seed_range, tgt_area)[0] == 0:
                continue
            seed_points.add(seed_ndhw)
            seed_range = _correct_seed_range(seed_range)
            candidates[next(self.seed_cnt)] = [seed_range, seed['tiling'],
                                               seed_ndhw]

        cost_cases = self._select_tiling(tgt_area, candidates)
        tiling_cases = [
            self.op.assembly_case(v[1], v[0], k) for k, v in candidates.items()]
        self._add_repo_compile_info(candidates)

        # call cost model
        cost_tilings, cost_range = self._calc_costmodel(cost_cases)
        tiling_cases += cost_tilings
        if not tiling_cases:
            raise RuntimeError("No tiling generated for this shape and range")

        add_compile_info("cost_range", cost_range)
        return tiling_cases

    def _remove_duplicate_repo_tilings(self, tiling_seeds, batch_range, repo_seeds):
        """
        remove duplicate repo tilings

        Parameters
        ----------
        tiling_seeds: list, shape info and tiling info

        batch_range: list, batch dim range

        repo_seeds: dict, repo_seeds shape

        Returns
        -------
        repo_selections: dict, tiling_info and batch range

        repo_seeds: dict, repo_seeds shape
        """
        # using repo seeds
        repo_selections = {}
        tiling_seeds.sort(key=lambda x: (x['A_shape'][0], x['tiling']['block_dim'][0]))
        # remove duplicate repo tilings
        tiling_seeds_unique = []
        for i, seed in enumerate(tiling_seeds):
            if seed['A_shape'][0] == tiling_seeds[i - 1]['A_shape'][0]:
                continue
            tiling_seeds_unique.append(seed)
        lower_bound = batch_range[0]
        for i, seed in enumerate(tiling_seeds_unique[:-1]):
            next_batch = tiling_seeds_unique[i + 1]['A_shape'][0]
            if next_batch <= lower_bound:
                continue
            seed_cnt = next(self.seed_cnt)
            tiling_block_dims = seed["tiling"]["block_dim"]
            block_nums = tiling_block_dims[0]*tiling_block_dims[1]*tiling_block_dims[2]
            if block_nums < tbe_platform_info.get_soc_spec("CORE_NUM"):
                seed["tiling"]["block_dim"][0] = (tbe_platform_info.get_soc_spec("CORE_NUM")
                // (tiling_block_dims[1]*tiling_block_dims[2]))
            conv2d_modify_tiling = self.op.op_type == "conv2d" and \
                                   seed['A_shape'][0] > seed["tiling"]["block_dim"][0] and \
                                   seed["tiling"]["BL1_shape"] and seed["tiling"]["BL1_shape"][0] == \
                                   seed["B_shape"][1] * seed["B_shape"][2] * seed["B_shape"][3] * seed["B_shape"][4]
            seed = self._modify_conv2d_tiling_batch(conv2d_modify_tiling, seed)
            # cover upper range
            repo_selections[seed_cnt] = [seed['tiling'], (lower_bound, min(next_batch - 1, batch_range[1]))]
            lower_bound = next_batch
            repo_seeds[seed_cnt] = seed['A_shape'][0]
            if lower_bound > batch_range[1]:
                break
        else:
            seed_cnt = next(self.seed_cnt)
            repo_seeds[seed_cnt] = tiling_seeds[-1]['A_shape'][0]
            repo_selections[seed_cnt] = [tiling_seeds[-1]['tiling'], (lower_bound, batch_range[1])]
        return repo_selections, repo_seeds

    def _calc_batch(self, tgt_area):
        """
        calculate tilings for dynamic batch mode

        Parameters
        ----------
        tgt_area: tuple, batch range to be covered

        Returns
        -------
        tilings_cases: list, calculated tilings
        """

        batch_range = tuple(tgt_area[0])
        tiling_cases = []
        tiling_seeds = self.op.get_repo_tiling()
        repo_seeds = {}

        # for default tiling
        conv3d_default_tiling_mode = None in batch_range and self.op.op_type == "convolution_3d"
        if conv3d_default_tiling_mode:
            batch_range = [batch_range[0], MAX_RANGE]
            cur_seed = next(self.seed_cnt)
            default_tiling = self.op.get_default_tiling()
            tiling_cases.append(
                self.op.assembly_case(default_tiling, batch_range, cur_seed))
            add_compile_info("tiling_range", {cur_seed: batch_range})
            add_compile_info("repo_seeds", repo_seeds)
            return tiling_cases

        # call cost model
        if not tiling_seeds:
            cur_seed = next(self.seed_cnt)
            cost_seed = self.op.get_costmodel_tiling(sum(batch_range) // 2)
            if self.op.op_type == "conv2d_backprop_input":
                tiling = copy.deepcopy(cost_seed.get("tiling"))
                if tiling["AL1_shape"]:
                    tiling["AL1_shape"][0] = tiling["AL1_shape"][0] // (cost_seed.get("B_shape")[2] * \
                                             cost_seed.get("B_shape")[3] * TilingUtils.CUBE_SIZE)
                if tiling["BL1_shape"]:
                    tiling["BL1_shape"][0] = tiling["BL1_shape"][0] // (cost_seed.get("B_shape")[2] * \
                                             cost_seed.get("B_shape")[3] * TilingUtils.CUBE_SIZE)
                if not self.op.check_tiling_match(tiling, cost_seed.get("C_shape")[3], cost_seed.get("C_shape")[2]):
                    raise RuntimeError("Input range is too large, the minimum tiling may exceed L1_Buffer")
            tiling_cases.append(
                self.op.assembly_case(cost_seed['tiling'], batch_range, cur_seed))
            add_compile_info("tiling_range", {cur_seed: batch_range})
            add_compile_info("repo_seeds", repo_seeds)
            return tiling_cases

        repo_selections, repo_seeds = self._remove_duplicate_repo_tilings(tiling_seeds, batch_range, repo_seeds)

        add_compile_info("tiling_range", {k: v[1] for k, v in repo_selections.items()})
        add_compile_info("repo_seeds", repo_seeds)
        tiling_cases = [self.op.assembly_case(v[0], v[1], k)
                        for k, v in repo_selections.items()]

        return tiling_cases

    def _calc_batch_v2(self, tgt_area):
        """
        for some op_type, dynamic batch tiling have restricted coverage
        """

        batch_range = tuple(tgt_area[0])
        repo_seeds = {}

        # get tiling range
        candidates = []
        seed_points = set()
        for seed in self.op.get_repo_tiling():
            seed_n = seed[self.op.key][0]
            seed_n_invalid = seed_n < batch_range[0] or seed_n > batch_range[1] or seed_n in seed_points
            if seed_n_invalid:
                continue
            seed_points.add(seed_n)
            candidates.append((self.op.get_batch_range(seed['tiling'], seed[self.op.key]), seed['tiling'], seed_n))
        candidates.sort(key=lambda x: x[2])

        # add sentinel seed
        candidates.append((None, None, batch_range[1] + 1))

        tiling_selections = {}
        cost_cases = deque()
        lower_bound = batch_range[0]
        covered = {}
        for i, seed in enumerate(candidates[:-1]):
            covered["lower_covered"], covered["upper_covered"] = seed[0]
            if covered.get("lower_covered") > lower_bound:
                cost_cases.append((lower_bound, covered.get("lower_covered") - 1))
                lower_bound = covered.get("lower_covered")
            covered["upper_covered"] = min(covered.get("upper_covered"), candidates[i + 1][2] - 1)
            seed_cnt = next(self.seed_cnt)
            tiling_selections[seed_cnt] = [seed[1], (lower_bound, covered.get("upper_covered"))]
            repo_seeds[seed_cnt] = seed[2]
            lower_bound = covered.get("upper_covered") + 1
            if lower_bound > batch_range[1]:
                break
        else:
            cost_cases.append((lower_bound, batch_range[1]))

        # covered by cost_model
        tiling_selections = self.covered_cost_model_batch_v2(cost_cases, tiling_selections)

        add_compile_info("tiling_range", {k: v[1] for k, v in tiling_selections.items()})
        add_compile_info("repo_seeds", repo_seeds)
        return [self.op.assembly_case(v[0], v[1], k) for k, v in tiling_selections.items()]

    def _calc_costmodel_range(self, cost_info, cut_range, cost_tilings, tiling_range):
        """
        calculate cost model range

        Parameters
        ----------
        cost_info: list, include cost_seed and cost_cases

        cut_range: list, cut range

        cost_tilings: list , cost tiling info

        tiling_range: list, each item means covered areas of a tiling cases

        Returns
        -------
        cost tilings: list, tilings calculated by cost model

        tiling_range: list, each item means covered areas of a tiling cases

        cost_cases: deque, uncovered area in (t, b, l, r) rectangle or cube format
        """
        cost_seed, cost_cases = cost_info
        seed_range = self.op.get_tiling_range(cost_seed['tiling'], cost_seed[self.op.key])
        if isinstance(seed_range[0], list):
            is_overlap, covered_area = _cal_overlap(cut_range, seed_range[0])
            _, covered_area_self = _cal_overlap(cut_range, seed_range[1])
            gen_rects = _cut_rectangle(cut_range, seed_range[0], seed_range[1])
            cost_cases.extend(gen_rects)
            if is_overlap:
                cur_seed_cnt = next(self.seed_cnt)
                cost_tilings.append(
                    self.op.assembly_case(cost_seed['tiling'], covered_area, cur_seed_cnt))
                tiling_range[cur_seed_cnt] = covered_area
            cur_seed_cnt = next(self.seed_cnt)
            cost_tilings.append(
                self.op.assembly_case(cost_seed['tiling'], covered_area_self, cur_seed_cnt))
            tiling_range[cur_seed_cnt] = covered_area_self
        else:
            if seed_range[1] == -1:
                seed_range[1] = cut_range[1]
            if seed_range[3] == -1:
                seed_range[3] = cut_range[3]

            is_overlap, covered_area = _cal_overlap(cut_range, seed_range)
            if is_overlap:
                gen_rects = _cut_rectangle(cut_range, seed_range)
                cost_cases.extend(gen_rects)
            else:
                raise RuntimeError("totally uncovered, need_range is {}".format(str(cut_range)),
                                    "seed_range is {}".format(str(seed_range)))

            cur_seed_cnt = next(self.seed_cnt)
            cost_tilings.append(
                self.op.assembly_case(cost_seed['tiling'], covered_area,
                                    cur_seed_cnt))
            tiling_range[cur_seed_cnt] = covered_area
        return cost_tilings, tiling_range, cost_cases

    def _calc_costmodel(self, cost_cases):
        """
        calculate cost model to cover rest area after repo seeds

        Parameters
        ----------
        cost_cases: deque, uncovered area in (t, b, l, r) rectangle or
            cube format

        tiling_range: list, each item means covered areas of a tiling cases

        Returns
        -------
        cost tilings: list, tilings calculated by cost model
        """

        cost_tilings = []
        tiling_range = {}
        while cost_cases:
            cost_len = len(cost_cases)
            for _ in range(cost_len):
                cut_range = cost_cases.popleft()
                conv2d_situation = self.op.op_type in ("conv2d", "conv2d_backprop_input", "conv2d_backprop_filter") \
                                   and len(cut_range) == NHW_RANGE_LEN
                conv3d_situation = self.op.op_type in ("conv3d_backprop_input", "convolution_3d", "conv3d_bp_filter") \
                                   and len(cut_range) == NDHW_RANGE_LEN
                seed_shape = tuple(cut_range[1::2])
                if conv2d_situation:
                    seed_shape = (cut_range[0], cut_range[3], cut_range[5])
                elif conv3d_situation:
                    seed_shape = (cut_range[0], cut_range[3], cut_range[5], cut_range[7])
                cost_seed = self.op.get_costmodel_tiling(seed_shape)
                if self.op.op_type == "conv2d_backprop_input" and not self.op.check_tiling_al0(cost_seed):
                    cost_cases.append((cut_range[0], cut_range[1], cut_range[2],
                                       cut_range[3], cut_range[4], cut_range[5] - 1))
                    continue
                cost_info = [cost_seed, cost_cases]
                cost_tilings, tiling_range, cost_cases = self._calc_costmodel_range(cost_info, cut_range,
                                                                                    cost_tilings, tiling_range)
        return cost_tilings, tiling_range


def _cal_overlap(rect1, rect2):
    """
    rect1, rect2: rectangle in (top, bottom, left, right) or
        (front, back, top, bottom, left, right) format
    """
    funcs = [max if i % 2 == 0 else min for i in range(len(rect1))]
    intersection = [func(pos1, pos2) for func, pos1, pos2 in zip(funcs, rect1, rect2)]
    overlaps = [0 if start > end else end - start + 1 for start, end in
                zip(intersection[0::2], intersection[1::2])]
    overlap = reduce(lambda x, y: x * y, overlaps)

    return (overlap, intersection)


def _cal_overlap_line(line1, line2):
    if line1[0] > line2[1] or line1[1] < line2[0]:
        return ()
    return (max(line1[0], line2[0]), min(line1[1], line2[1]))


def _cut_rectangle(base, cut, cut_self=()):
    """
    base, cut: rectangle in (top, bottom, left, right) format
    """

    gen_rects = []
    rect = list(base)
    i = 0
    while i < len(base):
        if i % 2 != 0:
            i = i + 2
            continue

        if cut[i] > base[i]:
            rect_tmp = copy.deepcopy(rect)
            rect_tmp[i] = base[i]
            rect_tmp[i + 1] = cut[i] - 1
            gen_rects.append(rect_tmp)

        if cut[i + 1] < base[i + 1]:
            rect_tmp = copy.deepcopy(rect)
            rect_tmp[i] = cut[i + 1] + 1
            rect_tmp[i + 1] = base[i + 1]
            gen_rects.append(rect_tmp)

        rect[i] = max(base[i], cut[i])
        rect[i + 1] = min(base[i + 1], cut[i + 1])

        i = i + 2

    if cut_self:
        cut_self = _cal_overlap(base, cut_self)[1]
        for index, rect in enumerate(gen_rects):
            if rect[:4] == cut_self[:4] and rect[-1] == cut_self[-1]:
                gen_rects[index][-1] -= 1
    gen_rects = [tuple(rect) for rect in gen_rects]
    return gen_rects


def _cut_line(base_line, cut_line):
    segments = []
    if base_line[0] < cut_line[0]:
        segments.append([base_line[0], cut_line[0] - 1])
    if base_line[1] > cut_line[1]:
        segments.append([cut_line[1] + 1, base_line[1]])
    return segments


def _set_param_of_op_tiling(input_list, input_name, local_context):
    input_list.append({
        "shape": local_context.get_addition(input_name).get("shape"),
        "ori_shape": local_context.get_addition(input_name).get("ori_shape"),
        "dtype": local_context.get_addition(input_name).get("dtype"),
        "format": local_context.get_addition(input_name).get("format"),
        "ori_format": local_context.get_addition(input_name).get("ori_format")
    })


def _do_bp_filter_op_tiling_helper(op_name):
    """
    The common do_op_tiling process of DW operators
    """
    context = get_op_context()
    inputs = []
    outputs = []
    _set_param_of_op_tiling(inputs, "x", context)
    _set_param_of_op_tiling(inputs, "filter_size", context)
    _set_param_of_op_tiling(inputs, "out_backprop", context)
    _set_param_of_op_tiling(outputs, "y", context)
    attrs = ()
    origin_attrs = copy.deepcopy(context.get_addition("attrs"))
    origin_attrs.pop("kernel_name", None)
    for attr_name, attr_value in origin_attrs.items():
        if type(attr_value) == tuple:
            attr_value = list(attr_value)
        attrs += ({"name": attr_name, "dtype": TYPE_TO_STR.get(type(attr_value), None), "value": attr_value},)
    impl_mode = get_op_impl_mode_enum(op_name)
    attrs += ({"name": "padding", "dtype": "str", "value": ""},)
    attrs += ({"name": "from_depthwise", "dtype": "bool", "value": False},)
    attrs += ({"name": "_op_impl_mode_enum", "dtype": "int", "value": impl_mode},)
    run_info = do_op_tiling(op_name, get_compile_info(), inputs, outputs, None, None, attrs)
    return run_info


def _do_conv3d_op_tiling_helper(op_name):
    """
    The common do_op_tiling process of DW operators
    """
    context = get_op_context()
    inputs = []
    outputs = []
    _set_param_of_op_tiling(inputs, "fmap", context)
    _set_param_of_op_tiling(inputs, "weight", context)
    if context.get_addition("bias"):
        _set_param_of_op_tiling(inputs, "bias", context)
    _set_param_of_op_tiling(outputs, "output", context)
    attrs = ()
    origin_attrs = copy.deepcopy(context.get_addition("attrs"))
    origin_attrs.pop("kernel_name", None)
    for attr_name, attr_value in origin_attrs.items():
        if type(attr_value) == tuple:
            attr_value = list(attr_value)
        attrs += ({"name": attr_name, "dtype": TYPE_TO_STR.get(type(attr_value), None), "value": attr_value},)
    impl_mode = get_op_impl_mode_enum(op_name)
    attrs += ({"name": "padding", "dtype": "str", "value": ""},)
    attrs += ({"name": "_op_impl_mode_enum", "dtype": "int", "value": impl_mode},)
    run_info = do_op_tiling(op_name, get_compile_info(), inputs, outputs, None, None, attrs)
    return run_info


def get_op_tiling(op_name, tiling_data_key):
    if op_name in ["Conv3D"]:
        run_info = _do_conv3d_op_tiling_helper(op_name)
    else:
        run_info = _do_bp_filter_op_tiling_helper(op_name)
    tiling_format = {name: "int" for name in tiling_data_key}
    log.debug("[{}][in dynamic constantization scene]var_num: {},var_map: {}".format(
        op_name, len(tiling_format), tiling_format))
    tiling_data = decode(run_info.get("tiling_data"), tiling_format)
    tiling_key = run_info.get("tiling_key")
    log.info("[{}][in dynamic constantization scene]tiling_key: {}".format(op_name, tiling_key))
    log.debug("[{}][in dynamic constantization scene]tiling_data: {}".format(op_name, tiling_data))
    return tiling_data, tiling_key


class TilingUtils:
    """
    tilingcase public const and func
    """
    FP16_M = 16
    FP16_K = 16
    FP16_N = 16
    FP16_SIZE = 2
    CUBE_SIZE = 16
    DB_ON = 2
    DB_OFF = 1
    N_BASE = 2
    HW_MIN = 1
    ATTACH_FULL_LOAD = 0
    ATTACH_EQUAL = 1
    ATTACH_LESS = 2
    ATTACH_LARGE = 3
    NO_ATTACH = 3
    ABUB_FULL_LOAD = 2
    ABUB_INNER_FULL_LOAD = 1
    ABUB_NOT_FULL_LOAD = 0
    # m, k in l1 is equal to m, k in ub
    ABUB_FULL_LOAD_MM = 1
    ABUB_NOT_FULL_LOAD_MM = 0
    NHW_MAX = 4096
    NO_BINARY = 0
    NC1HWC0 = 1
    NCHW = 2

    @staticmethod
    def icd(num_a, num_b):
        """
        upper division
        """
        return (num_a + num_b - 1) // num_b

    @staticmethod
    def align(num_a, num_b):
        """
        upper round
        """
        return TilingUtils.icd(num_a, num_b) * num_b

    @staticmethod
    def trans_to_int(num):
        """
        trans parameters to int
        Parameters
        ----------
        num: str, need to trans

        Returns
        -------
        num: int, type is int
        """
        return num if not num else int(num)


class CubeStaticTilingOp:
    """
    static tiling public func
    """
    def __init__(self, out_list):
        self.tiling_info_dict = None
        self.tiling = None
        self.res = out_list[0]
        self.kernel_name = ""

    @staticmethod
    def _check_repository_tiling(tiling):
        """
        check the tiling whether is from repository
        """
        if all(value == 0 for value in tiling['AL0_matrix']):
            return False
        return True

    @staticmethod
    def _get_value(ele):
        return [ele.value if isinstance(ele, tvm.tir.IntImm) else ele][0]

    @staticmethod
    def _is_valid_tiling(tiling):
        return not tiling.get("AL0_matrix")[2] == INVALID_TILING_FLAG

    @staticmethod
    def _is_single_op():
        return get_op_context().get_addition("fusion_op") is None

    def get_tiling_info_dict(self):
        return self.tiling_info_dict

    def get_static_tiling(self):
        """
        Tiling acquisition is performed in order according to the following process
        1. repo_tiling
        2. dyn_const_tiling, Scenarios that are already supported by bianry
        3. cache_tiling, Scenarios that are already supported by cachetiling
        4. costmodel_tiling
        5. default_tiling
        """
        tiling, is_tiling_from_repo = self._get_tiling_from_repository()
        if is_tiling_from_repo and self._is_valid_tiling(tiling):
            log.info("[tiling route][{}]from repository".format(self.kernel_name))
            self.tiling = tiling
        else:
            if self._is_single_op() and self._support_optiling():
                log.info("[tiling route][{}]dynamic constantization".format(self.kernel_name))
                self.res.op.attrs["is_dynamic_constantization"] = True
                self.tiling = tiling_api.get_tiling(self.tiling_info_dict)
            elif self._support_optiling(is_binary_const=False):
                self.tiling = self._get_and_transfer_cache_tiling()
            else:
                log.info("[tiling route][{}]from costmodel".format(self.kernel_name))
                self.tiling = tiling_api.get_tiling(self.tiling_info_dict)
            if not self._is_valid_tiling(self.tiling):
                log.info("[tiling route][{}]default tiling".format(self.kernel_name))
                self.tiling = self._get_default_tiling()
        decode_tiling_v1_to_v2(self.tiling)
        log.debug("[static tiling] {}".format(self.tiling))

    def _get_tiling_from_repository(self):
        """
        get repo tiling for op
        """
        current_tiling_type = get_tiling_type()
        set_tiling_type("repository_tiling")
        tiling = tiling_api.get_tiling(self.tiling_info_dict)
        is_tiling_from_repo = self._check_repository_tiling(tiling)
        set_tiling_type(current_tiling_type)
        return tiling, is_tiling_from_repo

    @abstractmethod
    def _set_tiling_info_dict(self):
        """
        set the input parameter required for the get_tiling interface
        """

    @abstractmethod
    def _support_optiling(self, is_binary_const=True):
        """
        Determine whether it is supported dyn_const_tiling and cache_tiling
        """

    @abstractmethod
    def _get_default_tiling(self):
        """
        get default tiling for op
        """

    @abstractmethod
    def _get_and_transfer_cache_tiling(self):
        """
        get cache_tiling and transfer it to static tiling
        """


class ConvBpFilterTilingIdOffset():
    # tiling_id offset
    def __init__(self):
        self.linear_embedding_opti_flag = 17
        self.strideh_read_flag = 16
        self.db_al1_offset = 15
        self.db_bl1_offset = 14
        self.db_l0c_offset = 13
        self.abkl1_attach_flag_offset = 11
        self.al1_attach_flag_offset = 9
        self.bl1_attach_flag_offset = 7
        self.min_kl1_cmp_kl0_offset = 6
        self.load3d_special_flag = 5
        self.conv1d_flag = 4
        self.load_mode_offset = 2
        self.binary_mode_offset = 0
