#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
cube schedule
"""

from tbe import tvm
from tbe.dsl.base.operation import register_schedule
from tbe.dsl.static_schedule.conv_schedule import CceConvOp
from tbe.dsl.static_schedule.conv2d_backprop_filter_schedule import \
    CceConv2dBackpropFilterOp
from tbe.dsl.static_schedule.conv2d_backprop_input_schedule import \
    CceConv2dBackpropInputOp
from tbe.dsl.static_schedule.conv3d_backprop_filter_schedule import \
    CceConv3dBackpropFilterOp
from tbe.dsl.static_schedule.gemm_integrated_schedule import gemm_schedule
from tbe.dsl.static_schedule.gemm_ub_schedule import GemmUbSchedule
from tbe.dsl.static_schedule.dilation_schedule import dilation_schedule
from tbe.dsl.static_schedule.weight_quant_bmm_schedule import weight_quant_bmm_schedule
from tbe.dsl.static_schedule.conv2d_backprop_input_ub_schedule import CceConv2dBackpropInputUbOp
from .constants import Pattern


@register_schedule(pattern=Pattern.CONV3D_BACKPROP_FILTER)
def schedule_conv3d_bp_filter(outs, tiling_case):
    """
    schedule for conv3d_backprop_filter op
    """

    return ConvSchedule(outs, tiling_case).do_conv3dbp_filter_schedule()


@register_schedule(pattern=Pattern.CONV2D_BACKPROP_FILTER)
def schedule_conv2d_bp_filter(outs, tiling_case):
    """
    schedule for conv2d_backprop_filter op
    """

    return ConvSchedule(outs, tiling_case).do_conv2dbp_filter_schedule()


@register_schedule(pattern=Pattern.CONV2D_BACKPROP_INPUT_UB)
def schedule_conv2d_transpose(outs, tiling_case):
    """
    schedule for conv2d backprop input dynamic shape
    """

    return ConvSchedule(outs, tiling_case).do_conv2d_transpose_schedule()


@register_schedule(pattern=Pattern.MATMUL_UB_TO_UB)
def schedule_gemm_ub(outs, tiling_case):
    """
    schedule for conv2d_backprop_filter op
    """

    return ConvSchedule(outs, tiling_case).do_gemm_ub_schedule()


@register_schedule(pattern=Pattern.MAT_MUL)
@register_schedule(pattern=Pattern.BATCH_MATMUL)
def schedule_matmul(outs, tiling_case):
    """
    schedule for matmul op
    """

    return ConvSchedule(outs, tiling_case).do_mat_mul_schedule()


@register_schedule(pattern=Pattern.DILATION)
def schedule_dilation(outs, tiling_case):
    """
    schedule for dilation
    """

    return ConvSchedule(outs, tiling_case).do_dilation_schedule()


@register_schedule(pattern=Pattern.WEIGHT_QUANT_BATCH_MATMUL)
def schedule_weight_quant_bmm(outs, tiling_case):
    """
    schedule for weight_quant_bmm
    """

    return ConvSchedule(outs, tiling_case).do_weight_quant_bmm_schedule()


class ConvSchedule:
    """
    conv-category op schedule
    """

    def __init__(self, outs, tiling_case):
        self._outs = list(outs) if isinstance(outs, (list, tuple)) else [outs]

        self._tiling_case = tiling_case
        self._scope = "local.UB"
        self._schedule_op = None
        self._get_schedule_info()


    def do_conv2d_schedule(self):
        """
        do schedule for conv2d
        """
        self._schedule_op = CceConvOp()
        self._schedule_op.schedule(
            self._outs[0], self._outs, [self._schedule], convbn1_flag=False,
            tiling_case=self._tiling_strategy, var_range=self._var_range)

        return self._schedule

    def do_conv2dbp_input_schedule(self):
        """
        do schedule for conv2dbp_input
        """
        self._schedule_op = CceConv2dBackpropInputOp(
            self._scope, need_tensorize=True, need_pragma=True)
        self._schedule_op.schedule(
            self._outs[0], self._outs, [self._schedule],
            tiling_case=self._tiling_strategy, var_range=self._var_range)

        return self._schedule

    def do_conv2dbp_filter_schedule(self):
        """
        do schedule for conv2dbp_filter
        """
        attach_flags = ("dynamic_l0a_attach", "dynamic_l0b_attach",
                        "dynamic_al1_attach", "dynamic_bl1_attach",
                        "bl1_hw_allin_flag")
        if -1 in self._tiling_strategy.get("block_dim"):
            dynamic_para = {}
        else:
            dynamic_para = {f: self._tiling_strategy.pop(f) for f in attach_flags}
        dynamic_para.update({
            "var_range": self._tiling_case['var_range'],
            "tiling": self._tiling_strategy,
            "tiling_key": self._tiling_case['key']
        })

        self._schedule_op = CceConv2dBackpropFilterOp(
            self._scope, need_tensorize=True, need_pragma=True)
        self._schedule_op.schedule(
            self._outs[0], self._outs, [self._schedule],
            dynamic_para=dynamic_para)

        return self._schedule

    def do_conv2d_transpose_schedule(self):
        """
        do schedule for conv2d_transpose
        """
        self._schedule_op = CceConv2dBackpropInputUbOp()
        self._schedule_op.schedule(self._outs[0], self._outs, [self._schedule],
                                   tiling_case=self._tiling_case, var_range=self._var_range)

        return self._schedule

    def do_conv3dbp_filter_schedule(self):
        """
        do schedule for conv3dbp_filter
        """
        self._schedule_op = CceConv3dBackpropFilterOp(
            self._scope, need_tensorize=True, need_pragma=True)
        self._schedule_op.schedule(
            self._outs[0], self._outs, [self._schedule],
            dynamic_para=self._tiling_case)

        return self._schedule

    def do_mat_mul_schedule(self):
        """
        do schedule for gemm
        """
        sch_list = [self._schedule]
        spec_mid_list = gemm_schedule(self._outs[0], sch_list,
                                      {"tiling_strategy": self._tiling_strategy,
                                       "m_k_n_shape": self._m_k_n_shape,
                                       "var_range": self._var_range,
                                       "tensor_list": self._tensor_list,
                                       "cache_tiling_mgr": self._cache_tiling_mgr,
                                       "tiling_work": self._tiling_work,
                                       "dynamic_seed_shape": self._dynamic_seed_shape,
                                       "compute_param": self._tiling_case.get("compute_param")})
        real_res = [self._outs[0]]
        if len(sch_list) > 1:
            real_res = sch_list[1:]
        return self._schedule, real_res, spec_mid_list

    def do_gemm_ub_schedule(self):
        """
        do schedule for gemm_ub for plateform that only has ubuf
        """
        sch_list = [self._schedule]
        self._schedule_op = GemmUbSchedule(
            self._outs[0], sch_list,
                         {"tiling_strategy": self._tiling_strategy,
                          "tensor_list": self._tensor_list,
                          "param_map": self._param_map})
        self._schedule_op.schedule()
        return self._schedule

    def do_dilation_schedule(self):
        """
        do schedule for dilation
        """
        dilation_schedule(self._outs[0], [self._schedule], tiling_case=self._tiling_case)
        return self._schedule

    def do_weight_quant_bmm_schedule(self):
        """
        do schedule for gemm
        """
        sch_list = [self._schedule]
        spec_mid_list = weight_quant_bmm_schedule(self._outs[0], sch_list,
                                      {"tiling_strategy": self._tiling_strategy,
                                       "m_k_n_shape": self._m_k_n_shape,
                                       "var_range": self._var_range,
                                       "tensor_list": self._tensor_list,
                                       "cache_tiling_mgr": self._cache_tiling_mgr,
                                       "tiling_work": self._tiling_work,
                                       "dynamic_seed_shape": self._dynamic_seed_shape,
                                       "compute_param": self._tiling_case.get("compute_param")})
        real_res = [self._outs[0]]
        if len(sch_list) > 1:
            real_res = sch_list[1:]
        return self._schedule

    def _get_schedule_info(self):
        """
        get scheule info
        """
        self._var_range = self._tiling_case.get('var_range')

        self._schedule = tvm.create_schedule([res.op for res in self._outs])
        self._schedule.tiling_key = self._tiling_case['key']
        self._tiling_strategy = self._tiling_case['tiling_strategy']
        self._m_k_n_shape = self._tiling_case.get('m_k_n_shape')
        self._tensor_list = self._tiling_case.get('tensor_list')
        self._cache_tiling_mgr = self._tiling_case.get('cache_tiling_mgr')
        self._tiling_work = self._tiling_case.get('tiling_work')
        self._dynamic_seed_shape = self._tiling_case.get('dynamic_seed_shape')
        self._param_map = self._tiling_case.get('param_map')