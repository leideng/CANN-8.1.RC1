#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
pooling grad helper
"""
from enum import Enum
from tbe.common.utils.errormgr import get_error_message
from ...constants import INSN_MAPPING
from ...util import get_dsl_insn


class PoolingGradSchType(Enum):
    """
    sch type
    """
    COMMON = "common"
    WINDOW_SPLIT = "window_split"
    STRIDE_1 = "stride_1"
    LARGE_KERNEL = "large_kernel"


class PoolingGradConstants:
    """
    constants of pooling grad
    """
    REDUCE_WINDOW_TAG = "reduce_window"
    REDUCE_SUM_TAG = "reduce_sum"
    INDICES_TAG = "pooling_grad_with_arg_indices"
    INDICES_T_TAG = "x_index"
    VCMP_TAG = "elewise_binary_vcmpv_eq"
    VCMP_SEL_TAG = "elewise_multiple_sel"
    IMG2COL_TAG = "elewise_binary_or"
    PAD_NODE = "x_p"
    DEPAD_NODE = "depad"
    STATIC = "static"
    DYNAMIC = "dynamic"
    STATIC_MODE_KEY = 0xfff
    POOLING_GRAD_SCH_ID = 0x22
    BLOCK_IDX = "blockIdx.x"
    LOCAL_UB = "local.UB"
    STORAGE_BOUND = "storage_bound"
    NO_OVERLAP = "no_overlap"
    DMA_COPY = "dma_copy"
    INDICES_SEQUENCE = "vector_linear_sequence"
    PHONY_INSN = "phony_insn"


def raise_error(message):
    """
    raise error
    """
    dict_args = {"errCode": "E90003", "detailed_cause": message}
    raise RuntimeError(dict_args, get_error_message(dict_args))


def get_insn(tensor):
    """
    get insn
    """
    if tensor.op.tag == PoolingGradConstants.REDUCE_WINDOW_TAG:
        insn = "vector_add"
    else:
        insn = get_dsl_insn(tensor)
    if insn:
        return INSN_MAPPING.get(insn, insn)
    else:
        return "dma_copy"


def judge_tvm_shape_equal(shape_a, shape_b):
    """
    compare two tvm shape
    """
    length_a = len(shape_a)
    length_b = len(shape_b)
    if length_a != length_b:
        return False

    for _, (dim_a, dim_b) in enumerate(zip(shape_a, shape_b)):
        has_value = hasattr(dim_a, "value") and hasattr(dim_b, "value")
        has_name = hasattr(dim_a, "name") and hasattr(dim_b, "name")
        if has_value:
            if dim_a.value != dim_b.value:
                return False
        elif has_name:
            if dim_a.name != dim_b.name:
                return False
        else:
            if dim_a != dim_b:
                return False

    return True


def get_format(format_info):
    format_dict = {0: "NC1HWC0", 1: "NCHW", 2: "NHWC"}
    return format_dict.get(format_info)