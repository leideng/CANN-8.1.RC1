#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2022-2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
max_pool_grad_with_arg
"""
from tbe import tvm

_BLOCK_SIZE = 16
_FP32 = "float32"

MIN_VALUES = {
    "float16": -6.55e04,
    "float32": -3.4e38,
    "int32": -2147483648,
    "int16": -32768,
}


def merge_hwo(src, align_value, node_name):
    def _merge_hwo(indices, src, hwo_shape):
        _n, _do, _c1, _hwo, _c0 = indices

        _in_n = _n
        _in_do = _do
        _in_c1 = _c1
        _in_c0 = _c0

        _in_ho = _hwo // hwo_shape[1]
        _in_wo = _hwo % hwo_shape[1]

        cond = tvm.any(_hwo <= hwo_shape[0] * hwo_shape[1])
        return tvm.select(cond, src[_in_n, _in_do, _in_c1, _in_ho, _in_wo, _in_c0])

    n, do, c1, ho, wo, c0 = src.shape
    hwo = (ho * wo + align_value - 1) // align_value * align_value
    dst_shape = [n, do, c1, hwo, c0]
    return tvm.compute(dst_shape, lambda * i: _merge_hwo(i, src, [ho, wo]), name=node_name)


def split_hwo(src, hwo_shape, node_name):
    def _split_hwo(indices, src, hwo_shape):
        _n, _do, _c1, _window, _ho, _wo, _c0 = indices

        _in_n = _n
        _in_do = _do
        _in_c1 = _c1
        _in_c0 = _c0
        _in_window = _window
        _in_hwo = _ho * hwo_shape[1] + _wo
        return src[_in_n, _in_do, _in_c1, _in_window, _in_hwo, _in_c0]

    n, do, c1, window, hwo, c0 = src.shape
    ho, wo = hwo_shape
    dst_shape = [n, do, c1, window, ho, wo, c0]
    return tvm.compute(dst_shape, lambda * i: _split_hwo(i, src, hwo_shape), name=node_name)


def _col2img(indices, grad, reduce_window, ksize, stride, grad_size):
    _n, _di, _c1, _hi, _wi, _c0 = indices
    do, ho, wo = grad_size[1], grad_size[3], grad_size[4]
    k_d, k_h, k_w = ksize
    s_d, s_h, s_w = stride

    _in_do = (_di - reduce_window // (k_h * k_w)) // s_d
    _in_ho = (_hi - (reduce_window % (k_h * k_w)) // k_w) // s_h
    _in_wo = (_wi - (reduce_window % (k_h * k_w)) % k_w) // s_w

    cond = tvm.all(0 <= _in_do, _in_do < do, 0 <= _in_ho,
                   _in_ho < ho, 0 <= _in_wo, _in_wo < wo)
    res = tvm.select(cond, grad[_n, _in_do, _c1, reduce_window,
                     _in_ho, _in_wo, _c0], tvm.const(0, dtype="float32"))
    return tvm.sum(res, axis=[reduce_window])


def remove_pad(src, pads, node_name):
    def _remove_pad(indices, src, pads):
        _n, _di, _c1, _hi, _wi, _c0 = indices

        _in_n = _n
        _in_di = _di + pads[0]
        _in_c1 = _c1
        _in_hi = _hi + pads[2]
        _in_wi = _wi + pads[4]
        _in_c0 = _c0

        return src[_in_n, _in_di, _in_c1, _in_hi, _in_wi, _in_c0]
        
    p_d_top, p_d_bottom, p_h_top, p_h_bottom, p_w_left, p_w_right = pads
    n, di_pad, c1, hi_pad, wi_pad, c0 = src.shape
    dst_shape = [n, di_pad - p_d_top - p_d_bottom, c1,
                 hi_pad - p_h_top - p_h_bottom, wi_pad - p_w_left - p_w_right, c0]
    return tvm.compute(dst_shape, lambda * i: _remove_pad(i, src, pads), name=node_name)


def max_pool_grad_with_argmax_nchw(x, grad, argmax, para_dict):
    def _col2img(_indices):
        i_nc, i_hp, i_wp = _indices
        r_kh = tvm.reduce_axis((0, kh), name="r_kh")
        r_kw = tvm.reduce_axis((0, kw), name="r_kw")
        r_ho = tvm.reduce_axis((0, ho), name="r_ho")
        r_wo = tvm.reduce_axis((0, wo), name="r_wo")

        dp_cond = tvm.all(i_hp == r_ho * sh + r_kh, i_wp == r_wo * sw + r_kw)
        return tvm.sum(dy_sel[r_kh * kw + r_kw, i_nc, r_ho, r_wo], 
                       axis=[r_kh, r_kw, r_ho, r_wo],
                       conditional_reduce=dp_cond)

    shape_i, shape_o = x.shape, grad.shape
    kh, kw = para_dict.get("ksize")
    sh, sw = para_dict.get("strides")
    pt, pb, pl, pr = para_dict.get("pads")

    nc = shape_i[0]
    hi, wi = shape_i[1], shape_i[2]
    hp, wp = hi + pt + pb, wi + pl + pr
    ho, wo = shape_o[1], shape_o[2]

    shape_x = (nc, hi, wi)
    x_index = tvm.compute(shape_x, lambda i_nc, i_hi, i_wi: (
        i_hi * wi + i_wi).astype(argmax.dtype), name="x_index", tag="pooling_grad_with_arg_indices")

    shape_pad = (nc, hp, wp)
    x_p = tvm.compute(shape_pad,
                      lambda i_nc, i_hp, i_wp: tvm.select(
                          tvm.all(i_hp > pt - 1, i_hp < hp - pb,
                                  i_wp > pl - 1, i_wp < wp - pr),
                          x_index[i_nc, i_hp - pt, i_wp - pl],
                          tvm.const(MIN_VALUES.get(argmax.dtype), dtype=argmax.dtype)),
                      name="x_p")

    shape_img2col = (kh*kw, nc, ho, wo)
    x_img2col = tvm.compute(shape_img2col,
                            lambda i_khw, i_nc, i_ho, i_wo:
                                x_p[i_nc, i_ho*sh +
                                    tvm.floordiv(i_khw, kw), i_wo*sw + tvm.floormod(i_khw, kw)],
                            name="x_img2col", tag="elewise_binary_or")

    mask0 = tvm.compute(shape_img2col,
                        lambda i_khw, i_nc, i_ho, i_wo:
                            tvm.expr.EQ(
                                argmax[i_nc, i_ho, i_wo], x_img2col[i_khw, i_nc, i_ho, i_wo]).astype("uint1"),
                        name="mask0", tag="elewise_binary_vcmpv_eq")

    dy_sel = tvm.compute(shape_img2col,
                         lambda i_khw, i_nc, i_ho, i_wo:
                         tvm.select(mask0[i_khw, i_nc, i_ho, i_wo],
                                    grad[i_nc, i_ho, i_wo], tvm.const(0, dtype=grad.dtype)),
                         name="dy_sel", tag="elewise_multiple_sel")

    dp = tvm.compute(shape_pad, lambda *i: _col2img(i),
                     name="dp", tag="reduce_sum")

    dx = tvm.compute(shape_i, lambda i_nc, i_hi,
                     i_wi: dp[i_nc, i_hi + pt, i_wi + pl], name="depad")

    return dx


def max_pool_grad_with_argmax_nhwc(x, grad, argmax, para_dict):
    pass


def max_pool_grad_with_argmax(x, grad, argmax, para_dict):
    if para_dict.get("input_format") == "NCHW":
        return max_pool_grad_with_argmax_nchw(x, grad, argmax, para_dict)
    else:
        return max_pool_grad_with_argmax_nhwc(x, grad, argmax, para_dict)


def max_pool_grad_with_argmax_3d(x, grad, argmax, para_dict):
    n, di, c1, hi, wi, c0 = x.shape
    n, do, c1, ho, wo, c0 = grad.shape
    n, do, c1, window, hwo, c0 = argmax.shape
    ksize = para_dict.get("ksize")
    strides = para_dict.get("strides")
    pads = para_dict.get("pads")
    k_d, k_h, k_w = ksize
    s_d, s_h, s_w = strides
    p_0, p_1, p_2, p_3, p_4, p_5 = pads
    grad_ub = merge_hwo(grad, _BLOCK_SIZE, "grad_ub")
    grad_sel = tvm.compute(argmax.shape,
                           lambda * i: tvm.select(argmax(*i),
                                                  grad_ub(i[0], i[1], i[2], i[4], i[5]),
                                                  tvm.const(0, dtype=para_dict.get("input_dtype"))),
                           name="grad_sel", tag="elewise_binary_cmpsel_eq")
    grad_split_hwo = split_hwo(grad_sel, [ho, wo], "grad_split_hwo")
    if para_dict.get("output_dtype") == "float16":
        grad_sel_fp32 = tvm.compute([n, do, c1, window, ho, wo, c0], lambda * i: grad_split_hwo(
            *i).astype(_FP32), name="grad_sel_fp32", tag="elewise_single_cast")
    else:
        grad_sel_fp32 = grad_split_hwo
    reduce_window = tvm.reduce_axis(
        (0, k_d * k_h * k_w), name="reduce_axis_window")
    res_shape_with_pad = [n, di + p_0 + p_1,
                          c1, hi + p_2 + p_3, wi + p_4 + p_5, c0]
    res_fp32 = tvm.compute(res_shape_with_pad, lambda * i: _col2img(i, grad_sel_fp32,
                           reduce_window, ksize, strides, grad.shape), name="res_fp32", tag="reduce_window")
    if para_dict.get("output_dtype") == "float16":
        res_with_pad = tvm.compute(res_shape_with_pad, lambda * i: res_fp32(*i).astype(
            para_dict.get("output_dtype")), name="res_with_pad", tag="elewise_single_cast")
    else:
        res_with_pad = res_fp32
    res = remove_pad(res_with_pad, pads, "res")
    return res