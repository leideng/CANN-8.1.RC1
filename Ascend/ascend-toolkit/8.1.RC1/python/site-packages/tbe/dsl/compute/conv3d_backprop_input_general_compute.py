#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
conv3d backprop input general compute.
"""

from tbe import tvm
from tbe.common import platform as tbe_platform
from tbe.common.platform import platform_info as tbe_platform_info
from tbe.common.utils import const
from tbe.common.utils.errormgr import error_manager_cube as cube_err
from tbe.dsl.base.operation import get_te_var
from tbe.dsl.compute import conv3d_backprop_input_cube_util as conv3d_dx_utils
from tbe.dsl.compute import cube_util
from tbe.tvm import abs as tvm_abs


class Conv3DDxPattern():
    """
    convolution back propagation

    Parameters
    ----------
    kernel_sizes : shape of weight, [N, D, H, W, C]

    strides :list of strides,
    [stridebatch, strided, strideh, stridew, stridechannel]

    pad: list of padding, [pad_front, pad_tail, pad_top,
    pad_bottom, pad_left, pad_right]

    output_shape : shape of dE/dX, [N, D, H, W, C]

    dilations : list of dilations, [dilations_d, dilations_h, dilations_w]

    kernel_name : name of kernel

    group_dict : information for group

    var_map : information for dynamic shape

    para_dict : params dict for binary compilation

    Returns
    -------
    deconv_pattern_instance : instance of deconv pattern
    """

    def __init__(self, kernel_sizes, strides, pad, output_shape, output_dtype, dilations, kernel_name, group_dict,
                 var_map, dsl_flag, para_dict):
        self.op_tag = "conv3d_backprop_input_"
        self.kernel_name = kernel_name
        self.output_shape = output_shape
        self.output_dtype = output_dtype
        self.group_dict = group_dict
        self.real_g = group_dict.get("real_g")
        self.cin1_g = group_dict.get("cin1_g")
        self.cout_g = group_dict.get("cout_g")
        _, _, self.kernel_d, self.kernel_h, self.kernel_w = kernel_sizes
        _, self.stride_d, self.stride_h, self.stride_w, _ = strides
        _, self.dilation_d, self.dilation_h, self.dilation_w, _ = dilations
        self.pad_head, self.pad_tail, self.pad_up, self.pad_down, self.pad_left, self.pad_right = pad
        self.bp_pads = (0, 0, 0, 0)
        self.dedy_d = 0
        self.dsl_flag = dsl_flag
        self.para_dict = para_dict
        self.binary_flag = para_dict.get(const.BINARY_KEY, False)
        self.var_map = var_map
        self.load3d_special_flag = False
        self.support_l0c_to_out_flag = tbe_platform.intrinsic_check_support("Intrinsic_fix_pipe_l0c2out")
        self.support_l1_to_out_flag = tbe_platform.intrinsic_check_support("Intrinsic_data_move_l12out")

    def generate_a(self, dedy_ddr):
        """
        generate dy_col tensor for mad

        Parameters
        ----------
        dedy_ddr : 6D dE/dY tensor in ddr

        Returns
        ----------
        dy_col: dE/dY tensor of fractal shape in L0A
        """
        dedy_batch, self.dedy_d, dedy_cout1, dedy_h, dedy_w, dedy_cout0 = cube_util.shape_to_list(dedy_ddr.shape)
        # the format of output shape is NDC1HWC0
        _, dedx_d, _, dedx_h, dedx_w, _ = self.output_shape

        if self.binary_flag:
            backprop_pad_h = get_te_var("backprop_pad_h").get_tvm_var()
            backprop_pad_t = get_te_var("backprop_pad_t").get_tvm_var()
            backprop_pad_u = get_te_var("backprop_pad_u").get_tvm_var()
            backprop_pad_d = get_te_var("backprop_pad_d").get_tvm_var()
            backprop_pad_l = get_te_var("backprop_pad_l").get_tvm_var()
            backprop_pad_r = get_te_var("backprop_pad_r").get_tvm_var()
            shape_down_modify = get_te_var("shape_down_modify").get_tvm_var()
            shape_right_modify = get_te_var("shape_right_modify").get_tvm_var()
        else:
            bp_stride_d, bp_stride_h, bp_stride_w = (1, 1, 1)
            backprop_pad_h, backprop_pad_u, backprop_pad_l = ((self.kernel_d - 1) * self.dilation_d - self.pad_head,
                                                              (self.kernel_h - 1) * self.dilation_h - self.pad_up,
                                                              (self.kernel_w - 1) * self.dilation_w - self.pad_left)

            backprop_pad_t = (dedx_d - 1) * bp_stride_d + (
                self.kernel_d - 1) * self.dilation_d + 1 - self.dedy_d * self.stride_d - backprop_pad_h
            backprop_pad_d = (dedx_h - 1) * bp_stride_h + (
                self.kernel_h - 1) * self.dilation_h + 1 - dedy_h * self.stride_h - backprop_pad_u
            backprop_pad_r = (dedx_w - 1) * bp_stride_w + (
                self.kernel_w - 1) * self.dilation_w + 1 - dedy_w * self.stride_w - backprop_pad_l

            shape_tail_modify = (backprop_pad_t - tvm_abs(backprop_pad_t)) // 2
            shape_down_modify = (backprop_pad_d - tvm_abs(backprop_pad_d)) // 2
            shape_right_modify = (backprop_pad_r - tvm_abs(backprop_pad_r)) // 2

            backprop_pad_t = (backprop_pad_t + tvm_abs(backprop_pad_t)) // 2
            backprop_pad_d = (backprop_pad_d + tvm_abs(backprop_pad_d)) // 2
            backprop_pad_r = (backprop_pad_r + tvm_abs(backprop_pad_r)) // 2
        self.bp_pads = (backprop_pad_u, backprop_pad_d, backprop_pad_l, backprop_pad_r)

        def _get_stc_al1_pre_expansion(shape_dy_filling):
            dy_zero = tvm.compute(shape_dy_filling,
                                  lambda batch_idx, dy_deep_idx, kernel_cout1_idx, ho_idx, wo_idx, kernel_cout0_idx: tvm
                                  .convert(0).astype(dedy_ddr.dtype),
                                  name="dy_zero",
                                  tag=self.op_tag + "dy_zero")

            dy_filling = tvm.compute(
                shape_dy_filling,
                lambda batch_idx, dy_deep_idx, kernel_cout1_idx, ho_idx, wo_idx, kernel_cout0_idx: tvm.select(
                    tvm.all(ho_idx % self.stride_h == 0, wo_idx % self.stride_w == 0, kernel_cout1_idx < dedy_cout1),
                    dedy_ddr(batch_idx, dy_deep_idx, kernel_cout1_idx, ho_idx // self.stride_h, wo_idx // self.stride_w,
                             kernel_cout0_idx),
                    dy_zero(batch_idx, dy_deep_idx, kernel_cout1_idx, ho_idx, wo_idx, kernel_cout0_idx)),
                name="dy_filling",
                tag=self.op_tag + "dy_filling",
                attrs={"stride_expand": (self.stride_h, self.stride_w)})

            if shape_down_modify < 0 or shape_right_modify < 0 or shape_tail_modify < 0:
                shape_dy_filling_cut = [
                    dedy_batch, self.dedy_d, self.real_g * self.cout_g // dedy_cout0,
                    dedy_h * self.stride_h + shape_down_modify, dedy_w * self.stride_w + shape_right_modify, dedy_cout0
                ]

                dedy_l1 = tvm.compute(
                    shape_dy_filling_cut,
                    lambda batch_idx, dy_deep, kernel_cout1_idx, ho_idx, wo_idx, kernel_cout0_idx: tvm.select(
                        kernel_cout1_idx < dedy_cout1, dy_filling[batch_idx, dy_deep, kernel_cout1_idx, ho_idx, wo_idx,
                                                                  kernel_cout0_idx]),
                    name="dy_l1",
                    tag=self.op_tag + "dy_l1",
                    attrs={})
            else:
                dedy_l1 = tvm.compute(
                    shape_dy_filling_l1,
                    lambda batch_idx, dy_deep, kernel_cout1_idx, ho_idx, wo_idx, kernel_cout0_idx: tvm.select(
                        kernel_cout1_idx < dedy_cout1, dy_filling[batch_idx, dy_deep, kernel_cout1_idx, ho_idx, wo_idx,
                                                                  kernel_cout0_idx]),
                    name="dy_l1",
                    tag=self.op_tag + "dy_l1")

            return dedy_l1

        def _get_dyn_al1_pre_expansion(shape_dy_filling):
            dy_zero = tvm.compute(shape_dy_filling,
                                  lambda batch_idx, dy_deep_idx, kernel_cout1_idx, ho_idx, wo_idx, kernel_cout0_idx: tvm
                                  .convert(0).astype(dedy_ddr.dtype),
                                  name="dy_zero",
                                  tag=self.op_tag + "dy_zero")

            dy_filling = tvm.compute(
                shape_dy_filling,
                lambda batch_idx, dy_deep_idx, kernel_cout1_idx, ho_idx, wo_idx, kernel_cout0_idx: tvm.select(
                    tvm.all(ho_idx % self.stride_h == 0, wo_idx % self.stride_w == 0, kernel_cout1_idx < dedy_cout1),
                    dedy_ddr(batch_idx, dy_deep_idx, kernel_cout1_idx, ho_idx // self.stride_h, wo_idx // self.stride_w,
                             kernel_cout0_idx)),
                name="dy_filling",
                tag=self.op_tag + "dy_filling",
                attrs={"stride_expand": (self.stride_h, self.stride_w)})

            dy_vn = tvm.compute(shape_dy_filling,
                                lambda *indice: dy_zero(*indice) + dy_filling(*indice),
                                name="dy_vn",
                                tag=self.op_tag + "dy_vn")

            shape_dy_filling_cut = [
                dedy_batch, self.dedy_d, self.real_g * self.cout_g // dedy_cout0,
                dedy_h * self.stride_h + shape_down_modify, dedy_w * self.stride_w + shape_right_modify, dedy_cout0
            ]
            dy_l1_attrs = {}
            if not self.binary_flag and 'dedx_h' in self.var_map:
                info_dy_h = tvm.var("info_dy_h")
                info_dy_h_value = dedy_h * self.stride_h + shape_down_modify
                shape_dy_filling_cut[3] = info_dy_h
                dy_l1_attrs["info_dy_h"] = info_dy_h
                dy_l1_attrs["info_dy_h_value"] = info_dy_h_value

            if not self.binary_flag and 'dedx_w' in self.var_map:
                info_dy_w = tvm.var("info_dy_w")
                info_dy_w_value = dedy_w * self.stride_w + shape_right_modify
                shape_dy_filling_cut[4] = info_dy_w
                dy_l1_attrs["info_dy_w"] = info_dy_w
                dy_l1_attrs["info_dy_w_value"] = info_dy_w_value

            dedy_l1 = tvm.compute(shape_dy_filling_cut,
                                  lambda batch_idx, dy_deep, kernel_cout1_idx, ho_idx, wo_idx, kernel_cout0_idx: tvm.
                                  select(kernel_cout1_idx < dedy_cout1, dy_vn[batch_idx, dy_deep, kernel_cout1_idx,
                                                                              ho_idx, wo_idx, kernel_cout0_idx]),
                                  name="dy_l1",
                                  tag=self.op_tag + "dy_l1",
                                  attrs=dy_l1_attrs)

            return dedy_l1

        shape_dy_filling = (dedy_batch, self.dedy_d, dedy_cout1, dedy_h * self.stride_h, dedy_w * self.stride_w,
                            dedy_cout0)
        if self.support_l1_to_out_flag:
            shape_dy_filling = (dedy_batch, self.dedy_d, self.real_g * self.cout_g // dedy_cout0,
                                dedy_h * self.stride_h + shape_down_modify, dedy_w * self.stride_w + shape_right_modify,
                                dedy_cout0)
        shape_dy_filling_l1 = (dedy_batch, self.dedy_d, self.real_g * self.cout_g // dedy_cout0, dedy_h * self.stride_h,
                               dedy_w * self.stride_w, dedy_cout0)

        if self.binary_flag:
            if self.para_dict.get(const.STRIDE_EXPAND_KEY):
                dedy_l1 = _get_dyn_al1_pre_expansion(shape_dy_filling)
            else:
                dedy_l1 = tvm.compute(shape_dy_filling_l1,
                                      lambda i, j, k, l, m, n: tvm.select(k < dedy_cout1, dedy_ddr(i, j, k, l, m, n)),
                                      name="dy_l1_s1",
                                      tag=self.op_tag + "dy_l1_s1")
        elif self.var_map:
            if self.stride_h > 1 or self.stride_w > 1:
                dedy_l1 = _get_dyn_al1_pre_expansion(shape_dy_filling)
            else:
                dedy_l1 = tvm.compute(shape_dy_filling_l1,
                                      lambda i, j, k, l, m, n: tvm.select(k < dedy_cout1, dedy_ddr(i, j, k, l, m, n)),
                                      name="dy_l1_s1",
                                      tag=self.op_tag + "dy_l1_s1")
        else:
            if self.stride_h > 1 or self.stride_w > 1:
                dedy_l1 = _get_stc_al1_pre_expansion(shape_dy_filling)
            else:
                dedy_l1 = tvm.compute(shape_dy_filling_l1,
                                      lambda i, j, k, l, m, n: tvm.select(k < dedy_cout1, dedy_ddr(i, j, k, l, m, n)),
                                      name="dy_l1_s1",
                                      tag=self.op_tag + "dy_l1_s1")

        attr_dict = {
            "kernel_h": self.kernel_h,
            "kernel_w": self.kernel_w,
            "bp_strides": (1, 1, 1),
            "bp_pads": (backprop_pad_h, backprop_pad_t, backprop_pad_u, backprop_pad_d, backprop_pad_l, backprop_pad_r),
            "dilations": (self.dilation_d, self.dilation_h, self.dilation_w),
            "group_dict": self.group_dict,
            "tag": self.op_tag,
            "binary_flag": self.binary_flag
        }

        conv_pattern = conv3d_dx_utils.Conv3DDxTensorAPattern(attr_dict, self.var_map)
        dedy_l0 = conv_pattern.generate_a(dedy_l1)
        self.load3d_special_flag = conv_pattern.load3d_special_flag

        return dedy_l0

    def generate_b(self, kernel_ddr):
        """
        generate w_col tensor for mad

        Parameters
        ----------
        kernel_ddr : weight tensor of fractal shape before transformation in ddr

        Returns
        ----------
        w_col: w tensor of fractal shape after transformation in L0B
        """
        # fz_3d shape: [real_g*dk*cin1_g*hk*wk, cout1_g, cout0, cin0]
        w_k1, dedy_cout1, dedy_cout0, w_k0 = kernel_ddr.shape
        if not self.binary_flag and w_k1 % (self.kernel_h * self.kernel_w) != 0:
            cube_err.raise_err_specific(
                'conv3d_backprop_input', 'the reduce axis of weight could not be divided by'
                ' {}*{} '.format(self.kernel_h, self.kernel_w))

        if self.binary_flag:
            kernel_cin1 = get_te_var("dedx_cin1_g").get_tvm_var()
            dilation_d_gt_one_flag = self.para_dict.get(const.DILATION_D_GT_ONE_KEY)
        else:
            kernel_cin1 = w_k1 // (self.kernel_w * self.kernel_h * self.real_g * self.kernel_d)
            dilation_d_gt_one_flag = False

        shape_w_l1 = (self.real_g, self.kernel_d, kernel_cin1 * self.kernel_h * self.kernel_w, dedy_cout1, dedy_cout0,
                      w_k0)

        ckk = kernel_cin1 * self.kernel_h * self.kernel_w

        shape_w_l1_dilated = (self.real_g, (self.kernel_d - 1) * self.dilation_d + 1,
                              kernel_cin1 * self.kernel_h * self.kernel_w, dedy_cout1, dedy_cout0, w_k0)

        shape_w_l0b = (self.real_g, (self.kernel_d - 1) * self.dilation_d + 1,
                       dedy_cout1 * self.kernel_h * self.kernel_w, kernel_cin1, w_k0,
                       dedy_cout0)

        def _cal_w_l1(g_idx, w_d, w_k1_idx, kernel_cin1_idx, w_k0_idx, kernel_cout0_idx):
            if dilation_d_gt_one_flag:
                # if dilation_d > 1, filter need expand d dim in l1
                w_l1_d_extraction = tvm.compute(shape_w_l1,
                    lambda g, d, k1, n1, n0, k0: kernel_ddr(g * self.kernel_d * ckk + d * ckk + k1, n1, n0, k0),
                    name="w_l1_d_extraction",
                    tag=self.op_tag + "w_l1_d_extraction")

                w_l1_zero = tvm.compute(shape_w_l1_dilated,
                                        lambda real_g_idx, kernel_deep_idx, k1_idx, n1_idx, n0_idx, k0_idx:
                                        tvm.convert(0.).astype(kernel_ddr.dtype),
                                        name="w_l1_zero",
                                        tag=self.op_tag + "w_l1_zero")

                w_l1 = tvm.compute(shape_w_l1_dilated,
                                   lambda real_g_idx, kernel_deep_idx, k1_idx, n1_idx, n0_idx, k0_idx:
                                   tvm.select(kernel_deep_idx % self.dilation_d == 0,
                                   w_l1_d_extraction(real_g_idx, kernel_deep_idx // self.dilation_d,
                                            k1_idx, n1_idx, n0_idx, k0_idx)),
                                   name="w_l1",
                                   tag=self.op_tag + "w_l1")

                w_l1_vn = tvm.compute(shape_w_l1_dilated,
                                      lambda real_g_idx, kernel_deep_idx, k1_idx, n1_idx, n0_idx, k0_idx:
                                      w_l1_zero[real_g_idx, kernel_deep_idx, k1_idx, n1_idx, n0_idx, k0_idx] +
                                      w_l1[real_g_idx, kernel_deep_idx, k1_idx, n1_idx, n0_idx, k0_idx],
                                      name="w_l1_vn",
                                      tag=self.op_tag + "w_l1_vn")
                w_l1_res = w_l1_vn
            else:
                w_l1_res = tvm.compute(shape_w_l1,
                    lambda g, d, k1, n1, n0, k0: kernel_ddr(g * self.kernel_d * ckk + d * ckk + k1, n1, n0, k0),
                    name="w_l1",
                    tag=self.op_tag + "w_l1")

            return w_l1_res[g_idx, w_d, kernel_cin1_idx * self.kernel_h * self.kernel_w +
                            (self.kernel_h * self.kernel_w - 1 - w_k1_idx %
                            (self.kernel_h * self.kernel_w)), w_k1_idx //
                            (self.kernel_h * self.kernel_w), kernel_cout0_idx, w_k0_idx]

        kernel_l0 = tvm.compute(shape_w_l0b,
                                lambda g_idx, w_d, w_k1_idx, kernel_cin1_idx, w_k0_idx, kernel_cout0_idx:
                                _cal_w_l1(g_idx, w_d, w_k1_idx, kernel_cin1_idx, w_k0_idx, kernel_cout0_idx),
                                name="w_col",
                                tag=self.op_tag + "w_col")

        return kernel_l0

    def generate_c(self, dy_col, w_col, tensor_bias=None):
        """
        generate dx_ddr

        Parameters
        ----------
        dy_col : dE/dY tensor of fractal shape in L0A

        w_col : w tensor of fractal shape after transformation in L0B

        tensor_bias : bias tensor of shape in UB

        Returns
        ----------
        dx_ddr: dx tensor in ddr
        """

        def _add_bias_in_ub(in_tensor0, in_tensor1):
            c_add_vector = tvm.compute(
                in_tensor0.shape,
                lambda *indice: in_tensor0(*indice) +
                                in_tensor1(indice[2], indice[4]),
                name="bias_add_vector")
            return c_add_vector

        def _filling_zero_coordinates(index, sd_gt_kd):
            # sd_gt_kd indicates that an  sd_gt_kd needs to be filled with 0
            dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx = index
            if sd_gt_kd:
                return tvm.any(
                    (dx_deep_idx + self.pad_head -
                     (dx_deep_idx + self.pad_head) // self.stride_d * self.stride_d - kernel_d_dilation) >= 0,
                    dx_deep_idx + self.pad_head >= self.stride_d * self.dedy_d)
            else:
                return dx_deep_idx + self.pad_head >= self.stride_d * (self.dedy_d - 1) + kernel_d_dilation

        def _remain_coordinates(index, dx_col, sd_gt_kd):
            dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx = index
            if sd_gt_kd:
                remain_coordinates_tensor = tvm.select(
                    tvm.all((dx_deep_idx + self.pad_head -
                             (dx_deep_idx + self.pad_head) // self.stride_d * self.stride_d - kernel_d_dilation) < 0,
                            dx_deep_idx + self.pad_head < self.stride_d * self.dedy_d),
                    dx_col[dx_cin1_idx // self.cin1_g, dx_batch_idx, dx_deep_idx,
                           dx_cin1_idx - dx_cin1_idx // self.cin1_g * self.cin1_g, dx_hw_idx,
                           dx_cin0_idx].astype(self.output_dtype))
            else:
                remain_coordinates_tensor = tvm.select(
                    dx_deep_idx + self.pad_head < self.stride_d * (self.dedy_d - 1) + kernel_d_dilation,
                    dx_col[dx_cin1_idx // self.cin1_g, dx_batch_idx, dx_deep_idx,
                           dx_cin1_idx - dx_cin1_idx // self.cin1_g * self.cin1_g, dx_hw_idx,
                           dx_cin0_idx].astype(self.output_dtype))
            return remain_coordinates_tensor

        def _get_dx_ddr():
            if self.stride_d >= self.kernel_d:
                dx_filing_zero = tvm.compute((dx_batch, dx_deep, dx_cin1, dx_hw, dx_c0),
                                             lambda *index: tvm.select(_filling_zero_coordinates(index, True),
                                                                       tvm.const(0, dtype=self.output_dtype)),
                                             name="dx_filing_zero",
                                             tag=self.op_tag + "dx_filing_zero")
            else:
                dx_filing_zero = tvm.compute((dx_batch, dx_deep, dx_cin1, dx_hw, dx_c0),
                                             lambda *index: tvm.select(_filling_zero_coordinates(index, False),
                                                                       tvm.const(0, dtype=self.output_dtype)),
                                             name="dx_filing_zero",
                                             tag=self.op_tag + "dx_filing_zero")
            # float32->output_dtype
            dx_ub = tvm.compute((dx_batch, dx_deep, dx_cin1, dx_hw, dx_c0),
                                lambda dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx: dx_col[
                                    dx_cin1_idx // self.cin1_g, dx_batch_idx, dx_deep_idx, dx_cin1_idx - dx_cin1_idx //
                                    self.cin1_g * self.cin1_g, dx_hw_idx, dx_cin0_idx].astype(self.output_dtype),
                                name="c_ub",
                                tag=self.op_tag + "c_ub")

            dx_ub_vn = tvm.compute((dx_batch, dx_deep, dx_cin1, dx_hw, dx_c0),
                                   lambda dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx:\
                                    dx_ub[dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx] +
                                    dx_filing_zero[dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx],
                                   name="c_ub_vn",
                                   tag=self.op_tag + "c_ub_vn")

            if tensor_bias is not None and tensor_bias.dtype == self.output_dtype:
                dx_ub_vn = _add_bias_in_ub(dx_ub_vn, tensor_bias)

            if self.dsl_flag:
                if self.load3d_special_flag:
                    lambda_express = lambda batch_d_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx:\
                                            dx_ub_vn[batch_d_idx // dedx_d, batch_d_idx % dedx_d,
                                                    dx_cin1_idx, 2 * dx_hw_idx, dx_cin0_idx]
                else:
                    lambda_express = lambda batch_d_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx:\
                                            dx_ub_vn[batch_d_idx // dedx_d, batch_d_idx % dedx_d,
                                                    dx_cin1_idx, dx_hw_idx, dx_cin0_idx]

                dx_ub_out = tvm.compute(
                    (dx_batch * dx_deep, dx_cin1, dedx_h * dedx_w, dx_cin0),
                    lambda_express,
                    name="c_ub_exact_hw",
                    tag="c_ub_exact_hw",
                    attrs={
                        "output_shape": self.output_shape,
                        "output_dtype": self.output_dtype,
                        "stride_d": self.stride_d,
                        "strides": (self.stride_d, self.stride_h, self.stride_w),
                        'depth_pad': (self.pad_head, self.pad_tail),
                        "bp_pads": self.bp_pads,
                        'kernels': (self.kernel_d, self.kernel_h, self.kernel_w),
                        "kernel_name": self.kernel_name,
                        "group_dict": self.group_dict,
                        "binary_flag": self.binary_flag,
                        "special_load3d_flag": self.load3d_special_flag,
                        "dsl_flag": self.dsl_flag
                    })

                return dx_ub_out

            if self.load3d_special_flag:
                dx_ddr = tvm.compute(out_shape,
                                     lambda dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx: dx_ub_vn[
                                         dx_batch_idx, dx_deep_idx, dx_cin1_idx, 2 * dx_hw_idx, dx_cin0_idx],
                                     name="c_ddr",
                                     tag="c_ddr",
                                     attrs={
                                         "output_shape": self.output_shape,
                                         "output_dtype": self.output_dtype,
                                         "stride_d": self.stride_d,
                                         "strides": (self.stride_d, self.stride_h, self.stride_w),
                                         'depth_pad': (self.pad_head, self.pad_tail),
                                         "bp_pads": self.bp_pads,
                                         'kernels': (self.kernel_d, self.kernel_h, self.kernel_w),
                                         "kernel_name": self.kernel_name,
                                         "group_dict": self.group_dict,
                                         "binary_flag": self.binary_flag,
                                         "special_load3d_flag": self.load3d_special_flag
                                     })
            else:
                dx_ddr = tvm.compute(out_shape,
                                     lambda dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx: dx_ub_vn[
                                         dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx],
                                     name="c_ddr",
                                     tag="c_ddr",
                                     attrs={
                                         "output_shape": self.output_shape,
                                         "output_dtype": self.output_dtype,
                                         "stride_d": self.stride_d,
                                         "strides": (self.stride_d, self.stride_h, self.stride_w),
                                         'depth_pad': (self.pad_head, self.pad_tail),
                                         "bp_pads": self.bp_pads,
                                         'kernels': (self.kernel_d, self.kernel_h, self.kernel_w),
                                         "kernel_name": self.kernel_name,
                                         "group_dict": self.group_dict,
                                         "binary_flag": self.binary_flag,
                                         "special_load3d_flag": self.load3d_special_flag
                                     })

            return dx_ddr

        def _get_dx_ddr_vn():
            if self.binary_flag:
                sd_gt_kd_flag = self.para_dict.get(const.SD_KD_MODE_KEY) == const.SD_GT_KD_FLAG
            else:
                sd_gt_kd_flag = self.stride_d > kernel_d_dilation

            dx_filing_zero = tvm.compute(out_shape,
                                         lambda *index: tvm.select(_filling_zero_coordinates(index, sd_gt_kd_flag),
                                                                   tvm.const(0, dtype=self.output_dtype)),
                                         name="dx_filing_zero",
                                         tag=self.op_tag + "dx_filing_zero")

            dx_ddr_zero = tvm.compute(
                out_shape,
                lambda *index: tvm.select(_filling_zero_coordinates(index, sd_gt_kd_flag), dx_filing_zero[index]),
                name="c_ddr_zero",
                tag=self.op_tag + "c_ddr_zero")

            dx_ddr = tvm.compute(out_shape,
                                 lambda *index: _remain_coordinates(index, dx_col, sd_gt_kd_flag),
                                 name="dx_ddr",
                                 tag=self.op_tag + "dx_ddr")

            dx_ddr_vn = tvm.compute(out_shape,
                                    lambda dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx: dx_ddr[
                                        dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx] + dx_ddr_zero[
                                            dx_batch_idx, dx_deep_idx, dx_cin1_idx, dx_hw_idx, dx_cin0_idx],
                                    name="c_ddr_vn",
                                    tag=self.op_tag + "c_ddr_vn",
                                    attrs={
                                        "strides": (self.stride_d, self.stride_h, self.stride_w),
                                        "kernels": (self.kernel_d, self.kernel_h, self.kernel_w),
                                        "dilations": (self.dilation_d, self.dilation_h, self.dilation_w),
                                        "depth_pad": (self.pad_head, self.pad_tail),
                                        "bp_pads": self.bp_pads,
                                        "kernel_name": self.kernel_name,
                                        "output_shape": self.output_shape,
                                        "output_dtype": self.output_dtype,
                                        "group_dict": self.group_dict,
                                        "dedy_d": self.dedy_d,
                                        "stride_d": self.stride_d,
                                        "binary_flag": self.binary_flag,
                                        "special_load3d_flag": self.load3d_special_flag,
                                        "dsl_flag": self.dsl_flag
                                    })
            return dx_ddr_vn

        c_dtype = "float32"
        if tbe_platform_info.get_soc_spec("SHORT_SOC_VERSION") in ("Hi3796CV300ES", "Hi3796CV300CS", "SD3403"):
            c_dtype = "float16"

        if tensor_bias is not None and self.support_l0c_to_out_flag:
            cube_err.raise_err_specific("conv3d_backprop_input", "Bias is not supported on Milan platform")

        # real dx shape
        _, dedx_d, dx_cin1, dedx_h, dedx_w, dx_cin0 = self.output_shape
        mad_config = {
            "tag": self.op_tag,
            "stride_d": self.stride_d,
            "dilation_d": self.dilation_d,
            "kernel_d": self.kernel_d,
            "dedx_d": dedx_d,
            "c_dtype": c_dtype,
            "pad_h": self.pad_head,
            "pad_t": self.pad_tail,
            const.BINARY_KEY: self.binary_flag,
            const.SD_KD_MODE_KEY: self.para_dict.get(const.SD_KD_MODE_KEY)
        }
        mad_pattern = conv3d_dx_utils.Conv3DDxMadPattern(mad_config)
        dx_col = mad_pattern.generate_c(dy_col, w_col)

        # mad dx shape
        _, dx_batch, dx_deep, _, dx_hw, dx_c0 = cube_util.shape_to_list(dx_col.shape)
        out_shape = (dx_batch, dx_deep, dx_cin1, dedx_h * dedx_w, dx_cin0)
        kernel_d_dilation = (self.kernel_d - 1) * self.dilation_d + 1

        if self.support_l1_to_out_flag:
            return _get_dx_ddr_vn()
        else:
            return _get_dx_ddr()
