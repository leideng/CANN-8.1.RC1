#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2022. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the Apache License Version 2.0.
You may not use this file except in compliance with the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
Apache License for more details at
http://www.apache.org/licenses/LICENSE-2.0

resize compute
"""
from __future__ import absolute_import
from __future__ import print_function
from __future__ import division

from tbe import tvm
from tbe.dsl.base import operation
from tbe.dsl.base.operation import get_compile_info
from tbe.common.testing.dsl_source_info import source_info_decorator
from tbe.common.utils.errormgr import get_error_message
from tbe.dsl.base.expr_compare import expr_equal
from tbe.dsl.unify_schedule.vector.resize.resize_tilingcase import ResizeCompileInfo
from .util import shape_to_list


@source_info_decorator()
def resize(images, size, resize_axis, method, align_corners=False, half_pixel_centers=False, dst_dtype="float32"):
    """
    resize images forward H, W dimensions

    Parameters
    ----------
    images : tvm.tensor
        Original tensor
    size : list[int], tuple[int]
        Target H, W
    resize_axis: list[int], tuple[int]
        Indexes of H, W
    method: str
        Resize algorithm, can be 'bilinear', 'nearest_neighbor'
    align_corners: bool
        If true, the centers of the 4 corner pixels of the input and output tensors are aligned
    half_pixel_centers: bool
        Default value is False
    dst_dtype: str
        The output tensor dtype, used for bilinear mode and can be 'float32', 'float16'
    Returns
    -------
    tvm.tensor: A resized Tensor
    """

    def _check_input():
        input_shape = shape_to_list(images.shape)
        for shape in input_shape:
            if (isinstance(shape, int) and shape < 0) or not isinstance(shape, (tvm.tir.PrimExpr, int)):
                dict_args = {
                    "errCode": "E90001",
                    "detailed_cause": "The images' shape value [%s] must be positive integer or tvm expr"
                }
                raise RuntimeError(dict_args, get_error_message(dict_args))
        if not isinstance(size, (list, tuple)):
            dict_args = {"errCode": "E90001", "detailed_cause": "The size must be list or tuple"}
            raise RuntimeError(dict_args, get_error_message(dict_args))
        if not isinstance(resize_axis, (list, tuple)):
            dict_args = {"errCode": "E90001", "detailed_cause": "The resize_axis must be list or tuple"}
            raise RuntimeError(dict_args, get_error_message(dict_args))
        if align_corners and half_pixel_centers and method == "bilinear":
            dict_args = {
                "errCode": "E90001",
                "detailed_cause": "The align_corners and half_pixel_centers cannot all be True simultaneously"
            }
            raise RuntimeError(dict_args, get_error_message(dict_args))
        if method not in ("bilinear", "nearest_neighbor"):
            dict_args = {"errCode": "E90001", "detailed_cause": "The method should be 'bilinear' or 'nearest_neighbor'"}
            raise RuntimeError(dict_args, get_error_message(dict_args))

    def _get_in_hw_idx(idx, src_hw, dst_hw):
        if align_corners:
            float_src_hw = tvm.select(dst_hw > 1, src_hw - 1, src_hw).astype("float")
            float_dst_hw = tvm.max(dst_hw - 1, 1).astype("float")
            in_idx = tvm.div(float_src_hw, float_dst_hw) * idx
            return in_idx

        scale = tvm.div(tvm.const(1.0, "float") * src_hw, dst_hw)
        if half_pixel_centers:
            if method == "nearest_neighbor":
                in_idx = (idx + 0.5) * scale
            else:
                in_idx = (idx + 0.5) * scale - 0.5
        else:
            in_idx = scale * idx
        return in_idx

    def _lerp(tensor_a, tensor_b, scale_f):
        return tensor_a * (tvm.const(1.0, "float") - scale_f) + tensor_b * scale_f

    def _compute_func(*indices):
        nc1_idx, h_idx, w_idx, c0_idx = indices

        in_h_idx = _get_in_hw_idx(h_idx, src_height, dst_height)
        in_w_idx = _get_in_hw_idx(w_idx, src_width, dst_width)
        if method == "nearest_neighbor":
            if align_corners:
                in_h_idx = tvm.round(in_h_idx).astype("int32")
                in_w_idx = tvm.round(in_w_idx).astype("int32")
            else:
                epsilon = 1e-5
                in_h_idx = tvm.floor(in_h_idx + epsilon).astype("int32")
                in_w_idx = tvm.floor(in_w_idx + epsilon).astype("int32")
            h_idx = tvm.min(tvm.max(in_h_idx, 0), src_height - 1)
            w_idx = tvm.min(tvm.max(in_w_idx, 0), src_width - 1)
            if cast_flag:
                value = cast_0(nc1_idx, h_idx, w_idx, c0_idx)
            else:
                value = images(nc1_idx, h_idx, w_idx, c0_idx)
        else:
            h_idx_int = tvm.floor(in_h_idx).astype("int32")
            w_idx_int = tvm.floor(in_w_idx).astype("int32")
            h_idx_lerp = (in_h_idx - h_idx_int).astype("float")
            w_idx_lerp = (in_w_idx - w_idx_int).astype("float")
            idx_range = [0, 1]
            points = [[0 for i in idx_range] for j in idx_range]
            for h in idx_range:
                for w in idx_range:
                    h_idx = tvm.min(tvm.max(h_idx_int + h, 0), src_height - 1)
                    w_idx = tvm.min(tvm.max(w_idx_int + w, 0), src_width - 1)
                    if cast_flag:
                        points[h][w] = cast_0(nc1_idx, h_idx, w_idx, c0_idx)
                    else:
                        points[h][w] = images(nc1_idx, h_idx, w_idx, c0_idx)
            top_diff = _lerp(*points[0], w_idx_lerp)
            bottom_diff = _lerp(*points[1], w_idx_lerp)
            value = _lerp(top_diff, bottom_diff, h_idx_lerp)
        return value

    def _compute_copy(*indices):
        if cast_flag:
            return cast_0(*indices)
        return images(*indices)

    def _compute_broadcast(*indices):
        nc1_idx, c0_idx = indices[0], indices[-1]
        if cast_flag:
            return cast_0(nc1_idx, 0, 0, c0_idx)
        return images(nc1_idx, 0, 0, c0_idx)

    _check_input()
    src_shape = list(images.shape)
    ori_shape = src_shape.copy()
    src_height = src_shape[resize_axis[0]]
    src_width = src_shape[resize_axis[1]]
    dst_height = size[0]
    dst_width = size[1]
    src_shape[resize_axis[0]] = dst_height
    src_shape[resize_axis[1]] = dst_width

    if ResizeCompileInfo.RESIZE_METHOD not in get_compile_info():
        if method == "bilinear":
            operation.add_compile_info_inner(ResizeCompileInfo.RESIZE_METHOD, 0)
        else:
            operation.add_compile_info_inner(ResizeCompileInfo.RESIZE_METHOD, 1)
        operation.add_compile_info_inner(ResizeCompileInfo.ALIGN_CORNERS, align_corners)
        operation.add_compile_info_inner(ResizeCompileInfo.HALF_PIXEL_CENTERS, half_pixel_centers)

    src_dtype = images.dtype.lower()
    dst_dtype = dst_dtype.lower()
    cast_flag = (method == 'bilinear' and src_dtype != "float32")

    if cast_flag:
        cast_0 = tvm.compute(ori_shape,
                             lambda *indices: images(*indices).astype("float"),
                             name="cast_0",
                             tag="resize|vector_conv")

    res = tvm.compute(src_shape, _compute_func, name="resize", tag="resize|vector_resize")
    if expr_equal(src_height, dst_height) is True and expr_equal(src_width, dst_width) is True:
        res = tvm.compute(src_shape, _compute_copy, name="resize", tag="resize|dma_copy")
    elif expr_equal(dst_height, 1) is True and expr_equal(dst_width, 1) is True and half_pixel_centers is False:
        res = tvm.compute(src_shape, _compute_copy, name="resize", tag="resize|dma_copy")
    elif expr_equal(1, src_height) is True and expr_equal(1, src_width) is True:
        res = tvm.compute(src_shape, _compute_broadcast, name="resize", tag="resize|vector_adds")

    if method == 'bilinear' and dst_dtype != res.dtype.lower():
        cast_1 = tvm.compute(src_shape,
                             lambda *indices: res(*indices).astype(dst_dtype),
                             name="cast_1",
                             tag="resize|vector_conv")
        return cast_1
    return res
