#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
slice variable shape
"""
from tbe.common.utils.varshape.variable_shape import register_variable
from tbe.dsl.base import operation


def _simply_slice_shape(input_shape, begin_list, end_list):
    group_shape, group_begin, group_size, group_len = [], [], [], 0
    # fused all normal axis
    for _idx, _shape in enumerate(input_shape):
        _begin, _size = begin_list[_idx], end_list[_idx]
        if _size == _shape:
            _begin = 0
            if _idx == 0:
                group_shape.append(_shape)
                group_begin.append(_begin)
                group_size.append(_size)
                group_len += 1
            else:
                group_shape[group_len - 1] *= _shape
                group_begin[group_len - 1] *= _shape
                group_size[group_len - 1] *= _shape
        else:
            group_shape.append(_shape)
            group_begin.append(_begin)
            group_size.append(_size)
            group_len += 1

    fused_shape, fused_begin, fused_size, fused_idx = [], [], [], 0
    # fuse all slice 1 axis
    for i, _ in enumerate(group_shape):
        if i == 0:
            fused_shape.append(group_shape[i])
            fused_begin.append(group_begin[i])
            fused_size.append(group_size[i])
        else:
            if fused_size[fused_idx] == 1:
                fused_shape[fused_idx] = group_shape[i] * fused_shape[fused_idx]
                fused_begin[fused_idx] = group_shape[i] * fused_begin[fused_idx] + group_begin[i]
                fused_size[fused_idx] = group_size[i]
            else:
                fused_shape.append(group_shape[i])
                fused_begin.append(group_begin[i])
                fused_size.append(group_size[i])
                fused_idx += 1

    return fused_shape, fused_begin, fused_size


@register_variable("slice")
def variable_shape(inputs):
    # type: (list) -> list
    x_info = inputs[0]
    begin_info = inputs[1]
    end_info = inputs[2]

    current_compute = operation.get_context().get_current_compute()
    if 0 in x_info.get("shape"):
        current_compute.add("_zero_shape", True)
    else:
        current_compute.add("_zero_shape", False)

    # new x var
    x_shape = []
    for index, value in enumerate(x_info.get("shape")):
        _var = None
        if value == -1:
            _var = operation.var_inner("_x_dim_{}".format(index), x_info.get("range")[index], "int64")
            x_shape.append(_var)
        else:
            x_shape.append(value)

    dim_len = len(x_info.get("shape"))
    begin_list = []
    size_list = []
    end_list = []
    is_static = operation.get_op_mode() == "static"
    need_simply_shape = False

    for _idx in range(dim_len):
        if "const_value" in begin_info:
            begin_value = begin_info.get("const_value")[_idx]
        else:
            if is_static:
                begin_value = begin_info.get("tensor")[_idx]
                need_simply_shape = True
            else:
                if "lr_depad" in begin_info and _idx == 0:
                    current_compute.add("_lr_depad", True)
                    begin_value = operation.var_inner("_begin_dim_{}".format(_idx), (0, 0), "int64")
                else:
                    begin_value = operation.var_inner("_begin_dim_{}".format(_idx), (0, None), "int64")
        begin_list.append(begin_value)

        if "const_value" in end_info:
            size_value = end_info.get("const_value")[_idx]
        else:
            size_value = operation.var_inner("_size_dim_{}".format(_idx), (1, None), "int64")
        size_list.append(size_value)

    if need_simply_shape:
        x_shape, begin_list, size_list = _simply_slice_shape(x_shape, begin_list, size_list)

    if end_info.get("end_mode") == "size":
        for _begin, _size in zip(begin_list, size_list):
            end_list.append(_begin + _size)
    else:
        end_list = size_list

    return [x_shape, begin_list, end_list]
