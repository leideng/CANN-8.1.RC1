#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2023-2024 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
pool grad variable shape
"""
from tbe.common.utils.varshape.variable_shape import register_variable
from tbe.dsl.base import operation


@register_variable("PoolGrad")
def variable_shape(ins):
    x, y, dy, axes, ksize, strides, pads = ins

    # var shape
    x_shape, x_range = x["shape"], x["range"]
    y_shape, y_range = y["shape"], y["range"]
    dy_shape, dy_range = dy["shape"], dy["range"]
    x_v_shape, y_v_shape, dy_v_shape = [], [], []
    for i, (d_x, r_x, d_y, r_y, d_dy, r_dy) in enumerate(zip(x_shape, x_range,
                                                             y_shape, y_range,
                                                             dy_shape, dy_range)):
        if i in axes:
            var_i = _var(f"_dim_i_{i}", [d_x], [r_x])
            var_o = _var(f"_dim_o_{i}", [d_y, d_dy], [r_y, r_dy])
            x_v_shape.append(var_i)
            y_v_shape.append(var_o)
            dy_v_shape.append(var_o)
        else:
            var_x = _var(f"_dim_{i}", [d_x, d_y, d_dy], [r_x, r_y, r_dy])
            x_v_shape.append(var_x)
            y_v_shape.append(var_x)
            dy_v_shape.append(var_x)

    # var ksize
    ksize_v = []
    for i, a in enumerate(ksize):
        if a == -1:
            a = operation.var_inner(f"_ksize_{i}", (1, None))
        ksize_v.append(a)

    # var strides
    strides_v = []
    for i, a in enumerate(strides):
        if a == -1:
            a = operation.var_inner(f"_stride_{i}", (1, None))
        strides_v.append(a)

    # var pads
    pads_v = []
    for i, p in enumerate(pads or []):
        p_0, p_1 = p[0], p[1]
        if p_0 == -1:
            p_0 = operation.var_inner(f"_pad_{i}_0", (0, None))
        if p_1 == -1:
            p_1 = operation.var_inner(f"_pad_{i}_1", (0, None))
        pads_v.append((p_0, p_1))

    operation.get_context().get_current_compute().add("_key", x.get("_key"))

    return x_v_shape, y_v_shape, dy_v_shape, ksize_v, strides_v, pads_v


def _var(name, dims, ranges):
    dim = max(dims)
    if dim > -1:
        return dim

    r_l, r_h = ranges[0]
    for l, h in ranges[1:]:
        r_l = max(r_l, l)
        r_h = None if None in (r_h, h) else min(r_h, h)

    if r_l == r_h:
        # in this scenario, dim is constant
        return r_l

    return operation.var_inner(name, (r_l, r_h))
