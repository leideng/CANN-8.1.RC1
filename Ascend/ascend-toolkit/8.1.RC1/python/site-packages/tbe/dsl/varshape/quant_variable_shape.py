#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2021-2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
quant variable shape
"""
import functools
from tbe.common.utils.errormgr import get_error_message
from tbe.common.utils.varshape.variable_shape import register_variable
from tbe.dsl.base import operation

C0_MAP = {"float32": 16,
          "float16": 16,
          "int32": 16,
          "uint32": 16,
          "int16": 16,
          "uint16": 16,
          "uint8": 32,
          "int8": 32,
          "int4": 64
          }


@register_variable("quant")
def variable_shape(inputs):
    # type: (list) -> list
    if len(inputs) < 1:
        dict_args = {"errCode": "E90001", "detailed_cause": "input numbers error"}
        raise RuntimeError(dict_args, get_error_message(dict_args))

    d_shapes = [[] for _ in inputs]
    var_index_lists = [[] for _ in inputs]

    def _get_range(_start_dim, _end_dim, _range, _index):
        res = 1
        for _i in range(_start_dim, _end_dim):
            if _range[_i][_index] is None:
                res = None
                return res
            res *= _range[_i][_index]
        return res

    def _get_shape_dim(_start_dim, _end_dim, _shape, _range, _suffix):
        flag1 = True
        flag2 = False
        for k in range(_start_dim, _end_dim):
            flag1 = flag1 and _shape[k] == -1 and _range[k][0] == _range[k][1]
            flag2 = flag2 or _shape[k] == -1
        if flag1:
            val = functools.reduce(lambda x, y: x * y, _range[_start_dim:_end_dim][0])
            d_shape.append(val)
        elif flag2:
            range_start = _get_range(_start_dim, _end_dim, _range, 0)
            range_end = _get_range(_start_dim, _end_dim, _range, 1)
            val = operation.var_inner("_dim_" + str(_suffix), (range_start, range_end))
            d_shape.append(val)
            var_index_list.append(_suffix)
        else:
            val = functools.reduce(lambda x, y: x * y, _shape[_start_dim:_end_dim])
            d_shape.append(val)

    for input_i, d_shape, var_index_list in zip(inputs, d_shapes, var_index_lists):
        shape_x = input_i.get("shape")
        range_x = input_i.get("range")
        format_x = input_i.get("format")
        if "dtype" in input_i:
            dtype_x = input_i.get("dtype")
        elif "data_type" in input_i:
            dtype_x = input_i.get("data_type")
        else:
            raise RuntimeError("need dtype or data_type in input")
        c0 = C0_MAP.get(dtype_x)

        if format_x == "NC1HWC0":
            # NC1HWC0 ->N,C1,H*W,C0
            _get_shape_dim(0, 1, shape_x, range_x, 0)
            _get_shape_dim(1, 2, shape_x, range_x, 1)
            _get_shape_dim(2, 4, shape_x, range_x, 2)
            d_shape.append(c0)
        elif format_x == "FRACTAL_NZ":
            # FRACTAL_NZ -> N,C1,H*W,C0
            if len(shape_x) > 4:
                _get_shape_dim(0, len(shape_x) - 4, shape_x, range_x, 0)
            else:
                d_shape.append(1)
            _get_shape_dim(len(shape_x) - 4, len(shape_x) - 3, shape_x, range_x, 1)
            _get_shape_dim(len(shape_x) - 3, len(shape_x) - 1, shape_x, range_x, 2)
            d_shape.append(c0)
        else:
            # NDC1HWC0 ->N*D,C1,H*W,C0
            _get_shape_dim(0, 2, shape_x, range_x, 0)
            _get_shape_dim(2, 3, shape_x, range_x, 1)
            _get_shape_dim(3, 5, shape_x, range_x, 2)
            d_shape.append(c0)

    compute = operation.get_context().get_current_compute()
    compute.add("var_index_list", var_index_lists[0])
    return d_shapes
