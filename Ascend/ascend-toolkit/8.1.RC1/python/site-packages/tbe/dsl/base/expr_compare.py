#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2019-2022. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
compare expr
"""
import sympy
from tbe.common.utils.errormgr import get_error_message
from tbe.tvm.tir import expr


def is_true(expr, dict_args):
    """
    :param expr: condition
    :param dict_args: error message
    :return: RuntimeError
    """
    if not expr:
        raise RuntimeError(dict_args, get_error_message(dict_args))


class ExprVisitor:
    def visit(self, te_expr):
        if isinstance(te_expr, (int, float)):
            return te_expr
        if isinstance(te_expr, expr.ConstExpr):
            return te_expr.value
        op_name = type(te_expr).__name__.lower()
        op_func = getattr(self, op_name, None)
        if op_func is None:
            dict_args = {
                "errCode": "E90001",
                "detailed_cause": f"Only accept (int, float, ConstExpr, Var, Mul, Max, add, sub, floodiv), "
                                  f"but now is [{type(te_expr)}]"}
            raise RuntimeError(dict_args, get_error_message(dict_args))
        return op_func(te_expr)


class SympyExpr(ExprVisitor):
    def var(self, te_expr):
        return sympy.symbols(te_expr.name)

    def add(self, te_expr):
        return sympy.Add(self.visit(te_expr.a), self.visit(te_expr.b))

    def sub(self, te_expr):
        return sympy.Add(self.visit(te_expr.a), -self.visit(te_expr.b))

    def mul(self, te_expr):
        return sympy.Mul(self.visit(te_expr.a), self.visit(te_expr.b))

    def floordiv(self, te_expr):
        div_q, _ = sympy.div(self.visit(te_expr.a), self.visit(te_expr.b))
        return sympy.floor(div_q)

    def min(self, te_expr):
        return sympy.Min(self.visit(te_expr.a), self.visit(te_expr.b))

    def max(self, te_expr):
        return sympy.Max(self.visit(te_expr.a), self.visit(te_expr.b))


def expr_equal(expr_a, expr_b, condition=None):
    """
    Judge equal for expr, not support for condition now.
    :param expr_a:
    :param expr_b:
    :param condition:
    :return:
    """
    if condition is not None:
        args = {"errCode": "E90001",
                "detailed_cause": "Now, not support condition"}
        raise RuntimeError(args, get_error_message(args))
    sympy_expr = SympyExpr()
    sympy_a = sympy_expr.visit(expr_a)
    sympy_b = sympy_expr.visit(expr_b)
    return sympy_a == sympy_b
