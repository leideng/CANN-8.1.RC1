#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2024-2024 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
Schedule of conv2d winograd.
"""
from collections import deque
from tbe import tvm
from tbe.common.register import set_fusion_buildcfg
from tbe.common.utils.op_util.op_util_conv2d import WINO_IN_TILE_HW, WINO_OUT_TILE_HW
from tbe.dsl.static_schedule.conv_schedule_util import ceil_div, is_wino_res_tensor, is_cub_wino_post_tensor


class WinogradConv:
    """
    Class of Winograd Conv2d
    """
    def __init__(self, conv_param, res):
        """
        class WinogradConv init func.
        """
        self.flag = conv_param.winograd_conv_flag
        self._conv_param = conv_param
        self.wino_res_ho = ceil_div(conv_param.h_out, WINO_OUT_TILE_HW)
        self.wino_res_wo = ceil_div(conv_param.w_out, WINO_OUT_TILE_HW)
        self.wino_res_howo = self.wino_res_ho * self.wino_res_wo
        self.mc_multi_wo_flag = False
        if self.flag and not is_wino_res_tensor(res):
            self.mc_multi_wo_flag = True

    @staticmethod
    def filter_transform_emit_insn(sch, bl0):
        """
        emit insn for winograd filter transform
        """
        sch[bl0].emit_insn(bl0.op.axis[0], "wino_l0b_v2")

    @staticmethod
    def wino_conv_emit_insn(sch, cl0, cl0_pragma_axis, mad_dict):
        """
        emit insn for winograd conv
        """
        sch[cl0].emit_insn(cl0_pragma_axis, "winograd_conv", attrs=mad_dict)

    def fm_transform_emit_insn(self, sch, al1, al0, tiling_param):
        """
        emit insn for winograd fm transform
        """
        sch[al1].emit_insn(al1.op.axis[0], "dma_copy", {"mem_align": 1})
        padding_top, padding_bottom, padding_left, padding_right = self._conv_param.padding
        _, fm_c1, fm_h, fm_w, fm_c0 = al1.shape
        fm_c1_l1 = tiling_param.get("k1_al1", fm_c1)

        wino_attr_dict = {
            "conv_kernel_h": WINO_IN_TILE_HW,
            "conv_kernel_w": WINO_IN_TILE_HW,
            "conv_padding_top": padding_top,
            "conv_padding_bottom": padding_bottom,
            "conv_padding_left": padding_left,
            "conv_padding_right": padding_right,
            "conv_stride_h": 2,
            "conv_stride_w": 2,
            "conv_fm_c": fm_c1_l1 * fm_c0,
            "conv_fm_c1": fm_c1_l1,
            "conv_fm_h": fm_h,
            "conv_fm_w": fm_w,
            "conv_fm_c0": fm_c0
        }
        sch[al0].emit_insn(al0.op.axis[0], "wino_l0a_v2", attrs=wino_attr_dict)

    def winograd_special_process(self, sch, res, tensor_param, tiling_param, attach_axis_dict,
                                 fixpipe_res_list, cache_read_elewise_list):
        """
        Special Process for Winograd Conv2D
        """
        def get_winograd_tensor_set():
            """
            get winograd tensor set
            """
            cub_winopost_set = set()
            wino_res_set = set()
            tensor_queue = deque()
            tensor_queue.append(res)
            while tensor_queue:
                tensor = tensor_queue.popleft()
                if is_cub_wino_post_tensor(tensor):
                    cub_winopost_set.add(tensor)
                if is_wino_res_tensor(tensor):
                    wino_res_set.add(tensor)
                if tensor.op.input_tensors:
                    append_list = list(i for i in tensor.op.input_tensors if i != cl0)
                    tensor_queue.extend(append_list)
            return cub_winopost_set, wino_res_set

        def cub_winopost_inline():
            """
            tensor cub winopost compute_inline
            """
            for tensor in cub_winopost_set:
                sch[tensor].compute_inline()

        def winograd_l0_tensor_buffer_tile():
            """
            buffer_tile for al0/bl0
            """
            m1_offset = temp_axis_l0 * mc_cl0
            m1_extent = tvm.min(mc_cl0, wino_res_m1 - m1_offset)

            sch[al0].buffer_tile((None, None), (None, None),
                                 (0, WINO_IN_TILE_HW), (0, WINO_IN_TILE_HW),
                                 (m1_offset, m1_extent), (None, m0_cl0), (None, None))

            sch[bl0].buffer_tile((None, None), (None, None),
                                 (0, WINO_IN_TILE_HW), (0, WINO_IN_TILE_HW),
                                 (None, None), (None, None))

        def winograd_l1_tensor_buffer_tile():
            """
            buffer_tile for al1
            """
            if al1_attach_res_flag:
                ho_offset_l1 = (temp_axis_l1 * multi_m_al1 * m_cl0) // self.wino_res_wo * WINO_OUT_TILE_HW
                ho_extent_l1 = (ceil_div(multi_m_al1 * m_cl0, self.wino_res_wo) + 1) * WINO_OUT_TILE_HW
            else:
                ho_offset_l1 = (temp_axis_l1 * m_cl0) // self.wino_res_wo * WINO_OUT_TILE_HW
                ho_extent_l1 = (ceil_div(m_cl0, self.wino_res_wo) + 1) * WINO_OUT_TILE_HW

            h_offset_l1 = ho_offset_l1 - padding_top
            h_extent_l1 = ho_extent_l1 - 1 + self._conv_param.filter_h
            w_extent_l1 = self.wino_res_wo * WINO_OUT_TILE_HW - 1 + self._conv_param.filter_w

            sch[al1].buffer_tile((None, None), (None, None), (h_offset_l1, h_extent_l1),
                                 (-padding_left, w_extent_l1), (None, None))

        def winograd_fixpipe_res_buffer_tile():
            """
            buffer_tile for fixpipe_res
            """
            howo_offset = temp_axis_l0 * m_cl0
            howo_extent = tvm.min(m_cl0, self.wino_res_howo - howo_offset)
            sch[cl0].buffer_tile((None, None), (0, WINO_OUT_TILE_HW), (0, WINO_OUT_TILE_HW), (None, None),
                                 (howo_offset, howo_extent), (None, None), (None, None), (None, None), (None, None))
            for idx, fixpipe_res in enumerate(fixpipe_res_list):
                _, _, p1_idx, howo_idx, p2_idx, _ = range(len(fixpipe_res.shape))
                winopost_buffer_tile_list = []
                for i in range(len(fixpipe_res.shape)):
                    winopost_buffer_tile_list.append((None, None))

                winopost_buffer_tile_list[howo_idx] = (howo_offset, howo_extent)
                winopost_buffer_tile_list[p1_idx] = (0, WINO_OUT_TILE_HW)
                winopost_buffer_tile_list[p2_idx] = (0, WINO_OUT_TILE_HW)
                sch[fixpipe_res].buffer_tile(*winopost_buffer_tile_list)

                if cache_read_elewise_list[idx] is None:
                    continue

                for tensor in cache_read_elewise_list[idx]:
                    _, elewise_l1_m_cl0_axis = sch[tensor].split(tensor.op.axis[howo_idx], m_cl0)
                    _, elewise_l1_m_factor_axis = sch[tensor].split(elewise_l1_m_cl0_axis, nparts=1)
                    if partition_slice:
                        sch[tensor].partition(elewise_l1_m_factor_axis, partition_slice)
                    else:
                        sch[tensor].split(elewise_l1_m_factor_axis, res_wo_factor)

        def get_winograd_partition_slice():
            """
            get wo_factor partition slice for Winograd Conv2D
            """
            if m_cl0 % self.wino_res_wo == 0 or self.wino_res_wo % m_cl0 == 0:
                return []

            current_m_idx = temp_axis_l0 * m_cl0
            m_extent = tvm.min(m_cl0, self.wino_res_howo - current_m_idx)
            head_offset = tvm.min(m_extent, self.wino_res_wo - current_m_idx % self.wino_res_wo) - 1
            partition_slice = [(0, head_offset), ]

            max_h_line_per_mc = m_cl0 // self.wino_res_wo + 1
            for loop_h in range(max_h_line_per_mc):
                partition_start = tvm.min(m_extent, head_offset + 1 + loop_h * self.wino_res_wo)
                partition_end = tvm.min(m_extent - 1, head_offset + (loop_h + 1) * self.wino_res_wo)
                if loop_h == max_h_line_per_mc - 1:
                    partition_end = m_extent - 1
                partition_slice.append((partition_start, partition_end))

            return partition_slice

        def set_partition_buildcfg():
            if partition_slice:
                build_config = dict()
                build_config["is_dynamic_shape"] = True
                build_config["enable_loop_partition"] = True
                set_fusion_buildcfg("conv2d", build_config)

        def wino_res_split_partition():
            for wino_res in wino_res_set:
                if wino_res == res:
                    res_m_factor_axis = attach_axis_dict.get("res_m_factor_axis")
                    if partition_slice:
                        sch[wino_res].partition(res_m_factor_axis, partition_slice)
                    else:
                        sch[wino_res].split(res_m_factor_axis, res_wo_factor)
                    continue
                _, _, res_hw_axis, _ = wino_res.op.axis
                res_m_hp1_axis, res_m_wp2_axis = sch[wino_res].split(res_hw_axis, self._conv_param.w_out)
                res_m_h_axis, res_m_p1_axis = sch[wino_res].split(res_m_hp1_axis, WINO_OUT_TILE_HW)
                res_m_w_axis, res_m_p2_axis = sch[wino_res].split(res_m_wp2_axis, WINO_OUT_TILE_HW)
                sch[wino_res].reorder(res_m_p1_axis, res_m_h_axis, res_m_w_axis, res_m_p2_axis)
                res_howo_axis = sch[wino_res].fuse(res_m_h_axis, res_m_w_axis)
                _, res_m_cl0_axis = sch[wino_res].split(res_howo_axis, m_cl0)
                _, res_m_factor_axis = sch[wino_res].split(res_m_cl0_axis, nparts=1)
                if partition_slice:
                    sch[wino_res].partition(res_m_factor_axis, partition_slice)
                    sch[wino_res].emit_insn(wino_res.op.axis[0], "dma_copy")
                else:
                    res_h_factor_axis, res_w_factor_axis = sch[wino_res].split(res_m_factor_axis, res_wo_factor)
                    sch[wino_res].reorder(res_h_factor_axis, res_m_p1_axis, res_w_factor_axis, res_m_p2_axis)
                    sch[wino_res].emit_insn(res_m_p1_axis, "dma_copy")

        if not self.flag:
            return

        al1_tiling = tiling_param.get("al1_tiling")
        ma_al0, _, _, _, _, _ = tiling_param.get("al0_tiling")
        _, mc_cl0, m0_cl0, _, _, _ = tiling_param.get("cl0_tiling")
        m_cl0 = mc_cl0 * m0_cl0
        _, _, m_dim, _ = tiling_param.get("block_dim")
        al0 = tensor_param["al0"]
        bl0 = tensor_param["bl0"]
        cl0 = tensor_param["cl0"]
        al1 = tensor_param["al1"]
        padding_top, _, padding_left, _ = self._conv_param.padding
        wino_res_m1 = ceil_div(self.wino_res_howo, m0_cl0)
        res_wo_factor = min(self.wino_res_wo, m_cl0)

        al1_attach_res_flag = True
        if al1_tiling and tiling_param.get("al1_nparts")[0] != 1:
            al1_attach_res_flag = False
        multi_m_al1 = ceil_div(ceil_div(wino_res_m1, ma_al0), tiling_param.get("al1_nparts")[1])

        temp_axis_l0 = (ceil_div(tiling_param.get("al1_nparts")[1], m_dim) * attach_axis_dict.get("res_m_dim_axis") + \
                       attach_axis_dict.get("singlecore_out2al1_loopm_axis")) * multi_m_al1 + \
                       attach_axis_dict.get("al12al0_loopm_axis")

        if al1_attach_res_flag:
            temp_axis_l1 = (ceil_div(tiling_param.get("al1_nparts")[1], m_dim) * \
                           attach_axis_dict.get("res_m_dim_axis") + \
                           attach_axis_dict.get("singlecore_out2al1_loopm_axis"))
        else:
            temp_axis_l1 = temp_axis_l0

        cub_winopost_set, wino_res_set = get_winograd_tensor_set()
        cub_winopost_inline()

        winograd_l0_tensor_buffer_tile()
        winograd_l1_tensor_buffer_tile()
        partition_slice = get_winograd_partition_slice()
        wino_res_split_partition()
        winograd_fixpipe_res_buffer_tile()
        set_partition_buildcfg()
