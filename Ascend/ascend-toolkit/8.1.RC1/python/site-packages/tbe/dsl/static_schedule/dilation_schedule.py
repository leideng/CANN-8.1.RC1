#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Copyright 2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
dilation schedule
"""
import collections
from functools import reduce

from tbe import tvm
from tbe.common.platform import CORE_NUM
from tbe.common.platform import platform_info as tbe_platform_info
from tbe.common.utils.errormgr import error_manager_cube as err_man
from tbe.dsl.base.operation import get_te_var
from tbe.dsl.compute import util

H_DIM = 1
W_DIM = 2
C0_DIM = 3
MINIMUM_NPART = 1
SplitNpartTuple = collections.namedtuple("SplitNpartTuple", ["h_split_npart", "w_split_npart"])
InputFlagTuple = collections.namedtuple("InputFlagTuple", ["split_h_flag", "binary_flag"])


def _cal_mini_ub(shape_input, shape_out, dtype):
    """
    calculate the mininum ub
    """
    return (reduce(lambda x, y: x * y, shape_input) +
            reduce(lambda x, y: x * y, shape_out)) * util.DTYPE_BYTE.get(dtype)


def _get_attach_axis(input_x, res, core_use, tiling_case, input_flag_tuple):
    """
    get the axis for compute at w_axis or h_axis or block_axis
    """
    split_h_flag = input_flag_tuple.split_h_flag
    binary_flag = input_flag_tuple.binary_flag
    if binary_flag:
        # open double buffer when ub_pb is 2
        double_flag = tiling_case["tiling_strategy"].get("ub_pb") == 2
        attach_axis = tiling_case["tiling_strategy"].get("attach_axis")
        return double_flag, attach_axis

    shape_input = util.shape_to_list(input_x.shape)
    shape_out = util.shape_to_list(res.shape)
    block_inner_parts = util.int_ceil_div(shape_out[0], core_use)
    shape_input = [block_inner_parts, *shape_input[1:]]
    shape_out = [block_inner_parts, *shape_out[1:]]

    ub_size_max = tbe_platform_info.get_soc_spec("UB_SIZE")
    double_flag = False
    attach_axis = C0_DIM
    for attach_dim in range(0, C0_DIM + 1):
        ub_size = _cal_mini_ub(shape_input[attach_dim:], shape_out[attach_dim:], input_x.dtype)
        if ub_size <= ub_size_max:
            attach_axis = attach_dim
            # match the split situation and the attach_axis, if not split_h we return back to split w_axis
            if not split_h_flag and attach_axis == C0_DIM - 1:
                attach_axis = C0_DIM
            if attach_axis <= H_DIM:
                buffer_size = _cal_mini_ub(shape_input[attach_axis:], shape_out[attach_axis:], input_x.dtype)
            else:
                buffer_size = _cal_mini_ub(shape_input[(attach_axis-1):], shape_out[(attach_axis-1):], input_x.dtype)
            if (buffer_size << 1) <= ub_size_max:
                double_flag = True
            break
    return double_flag, attach_axis


def _set_var_range_and_value(sch, binary_flag):
    """
    determine the scope of variables from binary compilation
    """
    if not binary_flag:
        return
    range_max = (-2147483647, 2147483647)
    range_positive_max = (1, 2147483647)
    range_c0 = (1, 64)
    range_core_num = (1, 32)
    range_ub_bound = (256, 262144)

    var_names = [
        "fmap_batch", "fmap_c1", "fmap_h", "fmap_w", "fmap_c0", "dilations_batch", "dilations_c1", "dilations_h",
        "dilations_w", "dilations_c0", "padu", "padd", "padl", "padr", "padding_value", "core_use", "w_split_npart",
        "h_split_npart", "ub_input_bound", "ub_output_bound"
    ]

    range_list = {
        "fmap_batch": range_positive_max,
        "fmap_c1": range_positive_max,
        "fmap_h": range_positive_max,
        "fmap_w": range_positive_max,
        "fmap_c0": range_c0,
        "dilations_batch": range_positive_max,
        "dilations_c1": range_positive_max,
        "dilations_h": range_positive_max,
        "dilations_w": range_positive_max,
        "dilations_c0": range_c0,
        "padu": range_max,
        "padd": range_max,
        "padl": range_max,
        "padr": range_max,
        "padding_value": range_max,
        "core_use": range_core_num,
        "w_split_npart": range_positive_max,
        "h_split_npart": range_positive_max,
        "ub_input_bound": range_ub_bound,
        "ub_output_bound": range_ub_bound,
    }

    for name in var_names:
        sch.set_var_range(get_te_var(name).get_tvm_var(), *range_list.get(name))
    sch.set_var_value(get_te_var("dilations_batch").get_tvm_var(), 1)
    sch.set_var_value(get_te_var("dilations_c1").get_tvm_var(), 1)
    sch.set_var_value(get_te_var("dilations_c0").get_tvm_var(), 1)


def _set_tensor_scope(sch, res, input_x, init_ub):
    """
    set ub scope for tensor
    """
    dilation_ub = sch.cache_write(res, tbe_platform_info.scope_ubuf)
    x_ub = sch.cache_read(input_x, tbe_platform_info.scope_ubuf, [dilation_ub])
    sch[init_ub].set_scope(tbe_platform_info.scope_ubuf)
    return dilation_ub, x_ub


def _bind_multiblock(sch, res, core_use):
    """
    blind multi block upon batch axis
    """
    block_outer, block_inner = sch[res].split(res.op.axis[0], nparts=core_use)
    block_outer_outer, block_outer_inner = sch[res].split(block_outer, 1)
    blockidx = tvm.thread_axis("blockIdx.x")
    sch[res].bind(block_outer_outer, blockidx)
    return [block_outer_outer, block_outer_inner, block_inner]


def _dilation_emitinsn(sch, res, dilation_ub, input_dtype, binary_flag):
    """
    emit insn for all tensor
    """
    dilations_para = util.shape_to_list(res.op.attrs["dilations_para"])
    dilation_n_dim, dilation_h_dim, dilation_w_dim, _ = sch[dilation_ub].op.axis
    h_dim_outer, h_dim_inner = sch[dilation_ub].split(dilation_h_dim, dilations_para[1])
    w_dim_outer, w_dim_inner = sch[dilation_ub].split(dilation_w_dim, dilations_para[2])
    sch[dilation_ub].reorder(h_dim_inner, w_dim_inner, dilation_n_dim, h_dim_outer, w_dim_outer)
    if not binary_flag:
        # unroll need extend to be constant
        sch[dilation_ub].unroll(h_dim_inner)
        sch[dilation_ub].unroll(w_dim_inner)

    dilation_emit = "vector_muls" if input_dtype in ("float16", "float32") else "dma_copy"
    sch[dilation_ub].emit_insn(sch[dilation_ub].op.axis[0], dilation_emit)


def _get_tiling(res, x, binary_flag, tiling_case):
    # add split_h_flag to avoid the situation of npart of h = 1 but we split h_axis
    split_h_flag = False
    if not binary_flag:
        core_use = min(tbe_platform_info.get_soc_spec(CORE_NUM), util.shape_to_list(res.shape)[0])
        w_split_npart = _get_npart_of_w_dim(x, res)
        # judge split h or split w
        if w_split_npart == MINIMUM_NPART:
            h_split_npart = _get_npart_of_h_dim(x, res)
            if h_split_npart == 0:
                h_split_npart = MINIMUM_NPART
            else:
                split_h_flag = True
        else:
            h_split_npart = MINIMUM_NPART
    else:
        core_use = tiling_case["tiling_strategy"].get("core_use")
        w_split_npart = tiling_case["tiling_strategy"].get("w_split_npart")
        h_split_npart = tiling_case["tiling_strategy"].get("h_split_npart")
    split_npart_tuple = SplitNpartTuple(h_split_npart=h_split_npart, w_split_npart=w_split_npart)
    return core_use, split_npart_tuple, split_h_flag


def dilation_schedule(res, sch_list, tiling_case=None):
    """
    schedule enter, auto schedule for cce AI-CORE

    Parameters:
    :param res: tvm.te.tensor
    :param sch_list: list of schedule, use sch_list[0] to return dilation schedule

    Returns:
    True for sucess, False for no schedule
    """
    sch = sch_list[0]
    x = res.op.input_tensors[0]
    init_ub = res.op.input_tensors[1]
    binary_flag = res.op.attrs["binary_flag"]

    # set var range and var value
    _set_var_range_and_value(sch, binary_flag)

    # set scope
    dilation_ub, x_ub = _set_tensor_scope(sch, res, x, init_ub)
    # get tiling
    core_use, split_npart_tuple, split_h_flag = _get_tiling(res, x, binary_flag, tiling_case)
    h_split_npart = split_npart_tuple.h_split_npart
    w_split_npart = split_npart_tuple.w_split_npart
    # bind multi block
    block_axis = _bind_multiblock(sch, res, core_use)
    res_all_axis = [i for i in sch[res].op.axis]
    # split axis h
    _, h_inner = sch[res].split(res_all_axis[H_DIM], nparts=h_split_npart)
    res_all_axis[H_DIM] = h_inner
    # split axis w
    w_outer, w_inner = sch[res].split(res_all_axis[W_DIM], nparts=w_split_npart)
    res_all_axis[W_DIM] = w_inner
    sch[res].reorder(*block_axis, w_outer, *res_all_axis[1:])
    # get attach axis
    input_flag_tuple = InputFlagTuple(split_h_flag=split_h_flag, binary_flag=binary_flag)
    double_flag, attach_axis = _get_attach_axis(x, res, core_use, tiling_case, input_flag_tuple)
    # attach at
    attach_dim = [*block_axis[1:], w_outer, h_inner]
    sch[dilation_ub].compute_at(sch[res], attach_dim[attach_axis])
    sch[init_ub].compute_at(sch[res], attach_dim[attach_axis])
    sch[x_ub].compute_at(sch[res], attach_dim[attach_axis])
    # unroll for dilation
    _dilation_emitinsn(sch, res, dilation_ub, x.dtype, binary_flag)

    # double buffer
    if double_flag:
        sch[dilation_ub].double_buffer()
        sch[init_ub].double_buffer()
        sch[x_ub].double_buffer()
    # reuseby and emit insn
    sch[dilation_ub].reused_by(init_ub)
    sch[init_ub].emit_insn(sch[init_ub].op.axis[0], "vector_dup")
    sch[x_ub].emit_insn(sch[x_ub].op.axis[0], "dma_copy")
    if attach_axis == 0:
        sch[res].emit_insn(block_axis[2], "dma_copy")
    else:
        sch[res].emit_insn(res_all_axis[attach_axis], "dma_copy")
    # set buffer size
    if binary_flag:
        ub_input_bound = tiling_case["tiling_strategy"].get("ub_input_bound")
        ub_output_bound = tiling_case["tiling_strategy"].get("ub_output_bound")
        sch[x_ub].set_buffer_size(ub_input_bound)
        sch[init_ub].set_buffer_size(ub_output_bound)
        sch[dilation_ub].set_buffer_size(ub_output_bound)
        sch.sequential_malloc(tbe_platform_info.scope_ubuf)
    return True


def _get_npart_of_w_dim(input_x, res):
    ub_size_max = tbe_platform_info.get_soc_spec("UB_SIZE")
    shape_input_form_w = util.shape_to_list(input_x.shape)[W_DIM:]
    shape_out_form_w = util.shape_to_list(res.shape)[W_DIM:]
    all_npart_value = _gen_tiling_space(shape_input_form_w[0])
    final_npart = 0
    for npart in all_npart_value:
        # search split_w to get max buffer
        # Magic Operation: add additional "1" part to avoid over-buffer problem during compute_at operation
        shape_input_w_after_splited = util.int_ceil_div(shape_input_form_w[0], npart) + 1
        shape_out_w_after_splited = util.int_ceil_div(shape_out_form_w[0], npart)
        current_ub_size = _cal_mini_ub([shape_input_w_after_splited, *shape_input_form_w[1:]],
                                       [shape_out_w_after_splited, *shape_out_form_w[1:]],
                                       input_x.dtype)
        if current_ub_size <= ub_size_max:
            final_npart = npart
            break
    if final_npart == 0:
        shape_input_w_after_splited = util.int_ceil_div(shape_input_form_w[0], all_npart_value[-1])
        shape_out_w_after_splited = util.int_ceil_div(shape_out_form_w[0], all_npart_value[-1])
        mini_ub_size = _cal_mini_ub([shape_input_w_after_splited, *shape_input_form_w[1:]],
                                    [shape_out_w_after_splited, *shape_out_form_w[1:]],
                                    input_x.dtype)
        err_man.raise_err_common("Dilation", "mini split exceed UB Buffer", "tiling size = {}".format(mini_ub_size))
    return final_npart


def _get_npart_of_h_dim(input_x, res):
    ub_size_max = tbe_platform_info.get_soc_spec("UB_SIZE")
    shape_input_form_h = util.shape_to_list(input_x.shape)[H_DIM:]
    shape_out_form_h = util.shape_to_list(res.shape)[H_DIM:]
    all_npart_value = _gen_tiling_space(shape_input_form_h[0])
    final_npart = 0
    for npart in all_npart_value:
        # Magic Operation: add additional "1" part to avoid over-buffer problem during compute_at operation
        shape_input_h_after_splited = util.int_ceil_div(shape_input_form_h[0], npart) + 1
        shape_out_h_after_splited = util.int_ceil_div(shape_out_form_h[0], npart)
        current_ub_size = _cal_mini_ub([shape_input_h_after_splited, *shape_input_form_h[1:]],
                                       [shape_out_h_after_splited, *shape_out_form_h[1:]],
                                       input_x.dtype)
        if current_ub_size <= ub_size_max:
            final_npart = npart
            break
    # not need to raise error when h final_npart == 0, we return back to split w to take on this situation
    return final_npart


def _gen_tiling_space(shape):
    tiling_space = []
    shape_half = util.int_ceil_div(shape, 2)
    for i in range(1, shape_half + 1):
        tiling_space.append(i)
    tiling_space.append(shape)
    return tiling_space