# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# coding: utf-8
# pylint: disable=invalid-name, import-outside-toplevel
"""Base library for TVM FFI."""
import sys
import os
import ctypes
import numpy as np
from . import libinfo

# ----------------------------
# library loading
# ----------------------------
string_types = (str,)
integer_types = (int, np.int32)
numeric_types = integer_types + (float, np.float32)

# this function is needed for python3
# to convert ctypes.char_p .value back to python str
if sys.platform == "win32":

    def _py_str(x):
        try:
            return x.decode("utf-8")
        except UnicodeDecodeError:
            encoding = "cp" + str(ctypes.cdll.kernel32.GetACP())
        return x.decode(encoding)


    py_str = _py_str
else:
    py_str = lambda x: x.decode("utf-8")


def _load_lib():
    """Load libary by searching possible path."""
    lib_path = libinfo.find_lib_path()
    # The dll search path need to be added explicitly in
    # windows after python 3.8
    if sys.platform.startswith("win32") and sys.version_info >= (3, 8):
        for path in libinfo.get_dll_directories():
            os.add_dll_directory(path)
    lib = ctypes.CDLL(lib_path[0], ctypes.RTLD_GLOBAL)
    lib.TVMGetLastError.restype = ctypes.c_char_p
    return lib, os.path.basename(lib_path[0])


try:
    # The following import is needed for TVM to work with pdb
    import readline  # pylint: disable=unused-import
except ImportError:
    pass

# version number
__version__ = libinfo.__version__
# library instance
_LIB, _LIB_NAME = _load_lib()

# Whether we are runtime only
_RUNTIME_ONLY = "runtime" in _LIB_NAME

# The FFI mode of TVM
_FFI_MODE = os.environ.get("TVM_FFI", "auto")


# ----------------------------
# helper function in ctypes.
# ----------------------------
def c_str(string):
    """Create ctypes char * from a python string
    Parameters
    ----------
    string : string type
        python string

    Returns
    -------
    str : c_char_p
        A char pointer that can be passed to C API
    """
    return ctypes.c_char_p(string.encode("utf-8"))


def c_array(ctype, values):
    """Create ctypes array from a python array

    Parameters
    ----------
    ctype : ctypes data type
        data type of the array we want to convert to

    values : tuple or list
        data content

    Returns
    -------
    out : ctypes array
        Created ctypes array
    """
    return (ctype * len(values))(*values)


def decorate(func, fwrapped):
    """A wrapper call of decorator package, differs to call time

    Parameters
    ----------
    func : function
        The original function

    fwrapped : function
        The wrapped function
    """
    import decorator

    return decorator.decorate(func, fwrapped)


# -----------------------------------------
# Base code for structured error handling.
# -----------------------------------------
# Maps error type to its constructor
ERROR_TYPE = {}


class TVMError(RuntimeError):
    """Default error thrown by TVM functions.

    TVMError will be raised if you do not give any error type specification,
    """


def register_error(func_name=None, cls=None):
    """Register an error class so it can be recognized by the ffi error handler.

    Parameters
    ----------
    func_name : str or function or class
        The name of the error function.

    cls : function
        The function to create the class

    Returns
    -------
    fregister : function
        Register function if f is not specified.

    Examples
    --------
    .. code-block:: python

      @tvm.error.register_error
      class MyError(RuntimeError):
          pass

      err_inst = tvm.error.create_ffi_error("MyError: xyz")
      assert isinstance(err_inst, MyError)
    """
    if callable(func_name):
        cls = func_name
        func_name = cls.__name__

    def register(mycls):
        """internal register function"""
        err_name = func_name if isinstance(func_name, str) else mycls.__name__
        ERROR_TYPE[err_name] = mycls
        return mycls

    if cls is None:
        return register
    return register(cls)


def _valid_error_name(name):
    """Check whether name is a valid error name."""
    return all(x.isalnum() or x in "_." for x in name)


def _find_error_type(line):
    """Find the error name given the first line of the error message.

    Parameters
    ----------
    line : str
        The first line of error message.

    Returns
    -------
    name : str The error name
    """
    if sys.platform == "win32":
        # Stack traces aren't logged on Windows due to a DMLC limitation,
        # so we should try to get the underlying error another way.
        # DMLC formats errors "[timestamp] file:line: ErrorMessage"
        # ErrorMessage is usually formatted "ErrorType: message"
        # We can try to extract the error type using the final ":"
        end_pos = line.rfind(":")
        if end_pos == -1:
            return None
        start_pos = line.rfind(":", 0, end_pos)
        if start_pos == -1:
            err_name = line[:end_pos].strip()
        else:
            err_name = line[start_pos + 1: end_pos].strip()
        if _valid_error_name(err_name):
            return err_name
        return None

    end_pos = line.find(":")
    if end_pos == -1:
        return None
    err_name = line[:end_pos]
    if _valid_error_name(err_name):
        return err_name
    return None


def _find_error_msg(line):
    """Find the error code and error message given
    the first line of the error message.

    Parameters
    ----------
    line : str
        The first line of error message.

    Returns
    -------
    errcode : error code
    errmsg : error message
    """
    err_code = None
    err_msg = None
    start_pos = line.find(": [")
    end_pos = line.find("]")
    if start_pos != -1:
        err_code = line[start_pos + 3:end_pos]
    err_msg = line[end_pos + 1:]
    return err_code, err_msg


def c2pyerror(err_msg):
    """Translate C API error message to python style.

    Parameters
    ----------
    err_msg : str
        The error message.

    Returns
    -------
    new_msg : str
        Translated message.

    err_type : str
        Detected error type.
    """
    arr = err_msg.split("\n")
    if arr[-1] == "":
        arr.pop()
    err_type = _find_error_type(arr[0])
    ret_err_code, ret_err_msg = _find_error_msg(arr[0])
    trace_mode = False
    stack_trace = []
    message = []
    for line in arr:
        if trace_mode:
            if line.startswith("  "):
                stack_trace.append(line)
            else:
                trace_mode = False
        if not trace_mode:
            if line.startswith("Stack trace"):
                trace_mode = True
            else:
                message.append(line)
    out_msg = ""
    if stack_trace:
        out_msg += "Traceback (most recent call last):\n"
        out_msg += "\n".join(reversed(stack_trace)) + "\n"
    err_msg = "".join(message)
    out_msg += "\n"+err_msg
    return ret_err_code, ret_err_msg, out_msg, err_type


def get_errcode_msg(err_code):
    from tbe import tvm
    for err_ in tvm.error_mgr.ERROR_CODE_MESSAGE:
        if err_.get("ErrCode") == err_code:
            return err_
    return None


def py2cerror(err_msg):
    """Translate python style error message to C style.

    Parameters
    ----------
    err_msg : str
        The error message.

    Returns
    -------
    new_msg : str
        Translated message.
    """
    arr = err_msg.split("\n")
    if arr[-1] == "":
        arr.pop()
    trace_mode = False
    stack_trace = []
    message = []
    for line in arr:
        if trace_mode:
            if line.startswith("  "):
                stack_trace.append(line)
            else:
                trace_mode = False
        if not trace_mode:
            if line.find("Traceback") != -1:
                trace_mode = True
            else:
                message.append(line)
    # Remove the first error name if there are two of them.
    # RuntimeError: MyErrorName: message => MyErrorName: message
    head_arr = message[0].split(":", 3)
    if len(head_arr) >= 3 and _valid_error_name(head_arr[1].strip()):
        head_arr[1] = head_arr[1].strip()
        message[0] = ":".join(head_arr[1:])
    # reverse the stack trace.
    out_msg = "\n".join(message)
    if stack_trace:
        out_msg += "\nStack trace:\n"
        out_msg += "\n".join(reversed(stack_trace)) + "\n"
    return out_msg


def get_tik_exception(err_msg, tik_file=None, tik_line=None, err_type=None):
    """if tik debug switch is on, call tik exception process function
    """
    from tbe import tvm
    from tbe.dsl.instrinsic import cce_intrin_md

    cont = os.getenv('CONTEXT_MODELCOMPILING')
    # get error message
    format_error_msg = "{}\n".format(err_msg.rstrip("\n")) if \
        cont and cont.upper() == "TRUE" else \
        "Error: {}\n".format(err_msg.rstrip("\n"))

    # get current location log info
    if tik_file is not None and tik_line is not None:
        context, _ = cce_intrin_md.tik_exception_process_cce(tik_file,
                                                             tik_line)
    else:
        from tbe.tvm.tir.transform.transform_extended import GetCurrentSpan
        span = GetCurrentSpan()
        context, _ = cce_intrin_md.tik_exception_process(span)
    return format_error_msg + context


def get_cce_compile_error(err_type, err_msg):
    """
    example
    err_msg: error /tmp/my_kernel.cce:26:5: error: no matching function XXX
    last_error_msg: no matching function XXX
    json_file: /tmp/my_kernel_loc.json
    cce_line: 26
    """
    import re
    import json
    cce_out_flag = False
    # noinspection PyBroadException
    try:
        err_msg_list = err_msg.split("error:")
        last_error_msg = err_msg_list[1]
        if err_msg_list[0].find(".cce") > 0:
            cce_file_path_lst = re.findall(r"error (.+?).cce:", err_msg_list[0])
            json_file = cce_file_path_lst[0] + "_loc.json"
            cce_file_line_lst = re.findall(r".cce:(.+?):", err_msg_list[0])
            cce_line = cce_file_line_lst[0]
            if not cce_line.isdigit():
                return cce_out_flag, None
            tik_file, tik_line = None, None
            with open(json_file, 'r') as f:
                temp = json.loads(f.read())
                cce_line2loc_lst = temp[0]["cce_line2loc"]
                for dic in cce_line2loc_lst:
                    if dic.get("cce_line", 0) == int(cce_line):
                        tik_file_line = dic.get("loc", [None, None])
                        tik_file, tik_line = tik_file_line[0], tik_file_line[1]
                        break
            if [tik_file, tik_line] == [None, None]:
                return cce_out_flag, None
        else:
            return cce_out_flag, None
        err_msg = get_tik_exception(last_error_msg, tik_file, tik_line,
                                    err_type)
        print("TBEPythonError[EB9999]: compile error" + err_msg)
        cce_out_flag = True

        return cce_out_flag, ERROR_TYPE.get(err_type, TVMError)(last_error_msg)
    except Exception:
        return cce_out_flag, None


def get_last_ffi_error():
    """Create error object given result of TVMGetLastError.

    Returns
    -------
    err : object
        The error object based on the err_msg
    """
    c_err_msg = py_str(_LIB.TVMGetLastError())
    err_code, err_msg, py_err_msg, err_type = c2pyerror(c_err_msg)
    tmp = get_errcode_msg(err_code)
    err_class, err_pcause, err_solution = " "," "," "
    if tmp:
        err_class = tmp.get('ErrClass')
        err_code = "[" + tmp.get('ErrCode') + "]"
        err_msg = tmp.get('ErrMessage')
        err_pcause = tmp.get('suggestion').get('Possible Cause')
        err_solution = tmp.get('suggestion').get('Solution')
    if (err_type != None) and ("TBEPythonError" in err_type):
        out_flag, cce_out_msg = get_cce_compile_error(err_type, err_msg)
        if out_flag:
            return cce_out_msg
    from tbe.common.testing import dsl_source_info
    from tbe.common.buildcfg import get_current_build_config
    from tbe.tvm.tir.transform.transform_extended import GetCurrentSpan,ClearCurrentSpan
    from tbe import tvm
    if err_type == "TVMError" and get_current_build_config("dump_error_info") and get_current_build_config("tik"):
        err_msg = get_tik_exception(err_msg)
    elif err_type == "TVMError" and get_current_build_config("dump_error_info"):
        err_msg = dsl_source_info.get_error_dict_args(err_msg, GetCurrentSpan())

    ClearCurrentSpan()
    if err_type is not None and err_type.startswith("tvm.error."):
        err_type = err_type[10:]

    cont = os.getenv('CONTEXT_MODELCOMPILING')
    if cont and cont.upper() == "TRUE":
        dictArgs = dict()
        if err_code == None:
            err_code = tvm.error_mgr.TBE_DEFAULT_ERROR_CODE
        dictArgs['errClass'] = err_class
        dictArgs['errCode'] = err_code
        dictArgs['message'] = err_msg + py_err_msg
        dictArgs['errPcause'] = err_pcause
        dictArgs['errSolution'] = err_solution
        return ERROR_TYPE.get(err_type, TVMError)(dictArgs)
    else:
        if "Current IR Stmt" in py_err_msg:
            py_err_msg = py_err_msg.split("Current IR Stmt")[0]
        if err_code == None:
            err_code = tvm.error_mgr.TBE_DEFAULT_PYTHON_ERROR_CODE
        dictArgs = dict()
        dictArgs['errClass'] = err_class
        dictArgs['errCode'] = err_code
        dictArgs['message'] = err_msg + py_err_msg
        dictArgs['errPcause'] = err_pcause
        dictArgs['errSolution'] = err_solution
        return ERROR_TYPE.get(err_type, tvm.error_mgr.TBEPythonError)(dictArgs)


def check_call(ret):
    """Check the return value of C API call

    This function will raise exception when error occurs.
    Wrap every API call with this function

    Parameters
    ----------
    ret : int
        return value from API calls
    """
    if ret != 0:
        raise get_last_ffi_error()
