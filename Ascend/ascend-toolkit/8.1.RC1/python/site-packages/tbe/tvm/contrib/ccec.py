#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Example: pylint: disable=invalid-name
"""
Copyright (C) 2016. Huawei Technologies Co., Ltd. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the Apache License Version 2.0.You may not use this file
except in compliance with the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
Apache License for more details at
http://www.apache.org/licenses/LICENSE-2.0

Utility to invoke ccec compiler in the system
"""
from __future__ import absolute_import as _abs

import os
import stat
import subprocess
import sys

from tvm.driver.cce_build_module import time_statistics
from tvm.error_mgr import raise_tbe_python_err, TBE_DEFAULT_PYTHON_ERROR_CODE


class CCECInfo:
    """CCEC Compiler infos."""

    @classmethod
    def _get_exe_path(cls, exe):
        cmd = ["which", exe]
        proc = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        _, _ = proc.communicate()
        if proc.returncode != 0:
            # using default path
            arch = os.popen('arch').read()
            if "x86" in arch:
                exe_path = "/usr/local/Ascend/CANN-1.84/x86_64-linux/ccec_compiler/bin/%s" % exe
            else:
                exe_path = "/usr/local/Ascend/CANN-1.84/aarch64-linux/ccec_compiler/bin/%s" % exe
        else:
            # exe is under current env
            exe_path = exe
        return exe_path

    @classmethod
    def get_exe(cls, item):
        if item not in cls._info:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                 "No item found for cls %s" % type(cls))
        if cls._info.get(item) is None:
            cls._info[item] = cls._get_exe_path(item)
        return cls._info.get(item)

    # ccec compiler, name and path
    _info = {"ccec": None,
             "ld.lld": None,
             }


def current_build_config():
    """Get the current build configuration."""
    # 'pylint: disable=protected-access
    from tvm.ir.transform import PassContext
    pass_ctx = PassContext.current()
    return pass_ctx.config


def switching_compilation_mode():
    """Sitching the current compilatio mode."""
    # 'pylint: disable=protected-access
    from tvm.tir import _ffi_api
    return _ffi_api.SwitchingCompilationMode()


def _get_temp_dir(dirpath, target):
    """Getting the temporary files used in compile and link.

    Parameters
    ----------
    temp : TempDirectory
        instance of class TempDirectory

    target : str
        The target format

    Return
    ------
    temp_code : str
        The temporary code file.

    temp_target : str
        The temporary object file.

    temp_linked_target : str
        The temporary target file.
    """

    if not os.path.isdir(dirpath):
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "%s do not exits" % (dirpath))
    temp_code = None
    temp_target = None

    temp_linked_target = None
    if target == "cce_core":
        temp_code = os.path.realpath(
            os.path.join(dirpath, "my_kernel_core.cce"))
        temp_target = os.path.realpath(
            os.path.join(dirpath, "my_kernel_core.o"))
    elif target == "cce_cpu":
        temp_code = os.path.realpath(
            os.path.join(dirpath, "my_kernel_cpu.cce"))
        temp_target = os.path.realpath(
            os.path.join(dirpath, "my_kernel_cpu_prelink.o"))
        temp_linked_target = os.path.realpath(
            os.path.join(dirpath, "my_kernel_cpu.o"))
    elif target == "cce_cpu_llvm":
        temp_code = os.path.realpath(os.path.join(dirpath, "my_kernel_cpu.ll"))
        temp_target = os.path.realpath(
            os.path.join(dirpath, "my_kernel_cpu_prelink.o"))
        temp_linked_target = os.path.realpath(
            os.path.join(dirpath, "my_kernel_cpu.o"))
    return temp_code, temp_target, temp_linked_target


def _set_vector_fp_ceiling(cmd):
    """Set cce-aicore-fp-ceiling for Hi3519AV200 and ASCEND_310P

    Parameters
    ----------
    cmd : list
        The compile command.

    Return
    ------
    cmd : list
        The compile command.

    """
    from tbe.common.buildcfg.buildcfg_mapping import vector_fp_ceiling
    if current_build_config().get(vector_fp_ceiling) == 1:
        cmd += ["-mllvm", "-cce-aicore-fp-ceiling=1"]
    elif current_build_config().get(vector_fp_ceiling) == 2:
        cmd += ["-mllvm", "-cce-aicore-fp-ceiling=2"]
    else:
        cmd += ["-mllvm", "-cce-aicore-fp-ceiling=0"]
    return cmd


def _set_cce_overflow(cmd):
    cmd += ["-mllvm", "-cce-aicore-record-overflow=false"]
    return cmd


def check_is_regbase_v2():
    from tbe.common.platform.platform_info import get_soc_spec
    from tbe.common.platform.platform_info import ASCEND_310B
    from tbe.common.platform.platform_info import AS31XM1
    from tbe.common.platform.platform_info import ASCEND_031
    from tbe.common.platform.platform_info import ASCEND_610LITE
    from tbe.common.platform.platform_info import BS9SX2A
    from tbe.common.platform.platform_info import MC61AM21A
    from tbe.common.platform.platform_info import ASCEND_910_95

    if get_soc_spec("SHORT_SOC_VERSION") in [ASCEND_031, ASCEND_310B, ASCEND_610LITE, BS9SX2A, 
                                             MC61AM21A, AS31XM1, ASCEND_910_95]:
        return True
    return False

def enable_sanitizer():
    from tbe.common.platform.platform_info import get_soc_spec
    from tbe.common.buildcfg.buildcfg_mapping import op_debug_config
    from tbe.common.platform.platform_info import ASCEND_910B
    from tbe.common.platform.platform_info import ASCEND_910_93
    from tbe.common.platform.platform_info import ASCEND_310P
    support_sanitizer = get_soc_spec("SHORT_SOC_VERSION") in [ASCEND_910B, ASCEND_910_93, ASCEND_310P]
    if "sanitizer" in current_build_config().get(op_debug_config) and support_sanitizer:
        return True
    else:
        return False
# 'pylint: disable=too-many-branches, too-many-locals, too-many-statements
def _build_aicore_compile_cmd(src_file, dst_file, name="", is_ffts_needed=False, is_mix=False):
    """Build the compile command for aicore op.

    Parameters
    ----------
    cce_product_params : TempDirectory
        Instance of class CceProductParams.

    src_file : str
        The file of source code used in compile.

    dst_file : str
        The object file.

    Return
    ------
    cmd : list
        The compile command.

    """
    from tbe.common.platform.platform_info import get_soc_spec
    from tbe.common.platform.platform_info import VEC_BS9SX1A
    from tbe.common.platform.platform_info import AIC_BS9SX1A
    from tbe.common.platform.platform_info import AIC_610B
    from tbe.common.platform.platform_info import VEC_610B
    from tbe.common.platform.platform_info import ASCEND_910
    from tbe.common.platform.platform_info import ASCEND_910B
    from tbe.common.platform.platform_info import ASCEND_910_93
    from tbe.common.platform.platform_info import HI3796CV300ES
    from tbe.common.platform.platform_info import HI3796CV300CS
    from tbe.common.platform.platform_info import SD3403
    from tbe.common.platform.platform_info import ASCEND_610
    from tbe.common.platform.platform_info import ASCEND_310P
    from tbe.common.platform.platform_info import ASCEND_610LITE
    from tbe.common.platform.platform_info import BS9SX2A
    from tbe.common.platform.platform_info import MC61AM21A
    from tbe.common.platform.platform_info import ASCEND_910_95
    from tbe.common.platform.platform_info import COMPILER_ARCH
    from tbe.common.buildcfg.buildcfg_mapping import tbe_debug_level, op_debug_config
    from tbe.common.buildcfg.buildcfg_mapping import enable_cce_licm_safe_hoist
    from tbe.common.buildcfg.buildcfg_mapping import enable_machine_outliner
    from tbe.common.buildcfg.buildcfg_mapping import enable_vector_core
    from tbe.common.buildcfg.buildcfg_mapping import enable_cce_remat_higher_weight
    from te.platform import cce_params
    cce_arch = get_soc_spec(COMPILER_ARCH)
    suffix_list = [cce_params.MIX_AIC_SUFFIX, cce_params.MIX_AIV_SUFFIX]
    ori_name = name
    suffix = ""
    for s in suffix_list:
        if name.count(s) > 0:
            ori_name = name.replace(s, "")
            suffix = s
    from tbe.common.buildcfg.buildcfg_mapping import build_fatbin
    if not current_build_config().get(build_fatbin):
        ori_name = ori_name + "__kernel0"
    is_c220 = get_soc_spec("SHORT_SOC_VERSION") in [ASCEND_910B, ASCEND_910_93]
    is_enable_vector_core = current_build_config().get(enable_vector_core)

    def get_init_cmd():
        optimization_level = "-O2"
        # 2 enable tbe debug : ccec compiler with "O0 - g"
        if current_build_config().get(tbe_debug_level) == 2 or \
                "ccec_O0" in current_build_config().get(op_debug_config):
            optimization_level = "-O0"
        arch = "cce-aicore-only"
        cce_arch_prefix = "cce-aicore-arch"
        cmd = [CCECInfo.get_exe("ccec"),
               "-c",
               optimization_level,
               src_file,
               "--%s=%s" % (cce_arch_prefix, cce_arch),
               "--%s" % arch,
               "-o",
               dst_file]
        if is_c220 or is_enable_vector_core or get_soc_spec("SHORT_SOC_VERSION") == ASCEND_910_95:
            aicore_type = get_soc_spec("AICORE_TYPE")
            from tbe.common.buildcfg.buildcfg_mapping import enforce_mix_mode
            is_need_modify = (is_ffts_needed or is_mix) or \
                             current_build_config().get(enforce_mix_mode)
            if is_need_modify and aicore_type == "AiCore":
                cmd += ["-D", "%s=%s" % (ori_name, ori_name + cce_params.MIX_AIC_SUFFIX)]
            elif is_need_modify and aicore_type == "VectorCore":
                cmd += ["-D", "%s=%s" % (ori_name, ori_name + cce_params.MIX_AIV_SUFFIX)]
        # 2 enable tbe debug : ccec compiler with "O0 - g"
        if current_build_config().get(tbe_debug_level) == 2 or \
                "ccec_g" in current_build_config().get(op_debug_config):
            cmd.append("-g")
        return cmd

    cmd = get_init_cmd()
    if check_is_regbase_v2() and current_build_config().get(tbe_debug_level) == 2 and "-O0" in cmd:
        cmd += ["--cce-ignore-always-inline=false"]
    is_vec_610B = get_soc_spec(
        "SHORT_SOC_VERSION") + get_soc_spec("AICORE_TYPE") in [VEC_BS9SX1A, VEC_610B]
    is_aic_610B = get_soc_spec(
        "SHORT_SOC_VERSION") + get_soc_spec("AICORE_TYPE") in [AIC_BS9SX1A, AIC_610B]
    if get_soc_spec("SHORT_SOC_VERSION") in [ASCEND_910_93, ASCEND_910B]:
        cmd += ["-mllvm", "-cce-aicore-stack-size=32768"]
        cmd += ["-mllvm", "-cce-aicore-function-stack-size=32768"]
        cmd = _set_cce_overflow(cmd)
        cmd += ["-mllvm", "-cce-aicore-addr-transform"]
        if current_build_config().get(enable_cce_remat_higher_weight):
            cmd += ["-mllvm",  "-cce-aicore-weight-for-reg-operand-remat=higher"]
    elif get_soc_spec("SHORT_SOC_VERSION") == ASCEND_910:
        cmd += ["-mllvm", "-cce-aicore-function-stack-size=16000"]
        cmd = _set_cce_overflow(cmd)
    elif get_soc_spec("SOC_VERSION") in [HI3796CV300ES, HI3796CV300CS, SD3403]:
        cmd += ["-mllvm", "-cce-aicore-sk-transform"]
        if get_soc_spec("SOC_VERSION") == "Hi3519AV200":
            cmd = _set_vector_fp_ceiling(cmd)
    elif get_soc_spec("SHORT_SOC_VERSION") == ASCEND_310P:
        cmd = _set_vector_fp_ceiling(cmd)
        cmd = _set_cce_overflow(cmd)
    elif get_soc_spec("SHORT_SOC_VERSION") == ASCEND_610:
        cmd = _set_vector_fp_ceiling(cmd)
    elif is_vec_610B:
        cmd += ["-mllvm", "-cce-aicore-auto-nop-insert=true"]
        cmd += ["-cce-v210-no-uninitialized"]
        cmd += ["-mllvm", "-cce-aicore-addr-transform"]
    elif is_aic_610B:
        cmd += ["-mllvm", "-cce-aicore-addr-transform"]
        cmd += ["-mllvm", "-cce-aicore-function-stack-size=16000"]
        cmd += ["-mllvm", "-cce-aicore-dcci-insert-for-scalar"]
    elif check_is_regbase_v2():
        cmd += ["-mllvm", "-cce-aicore-function-stack-size=16000"]
        cmd += ["-mllvm", "-cce-aicore-addr-transform"]
        cmd += ["-mllvm", "--cce-aicore-or-combine=false"]
        cmd += ["-mllvm", "-instcombine-code-sinking=false"]
        from tbe.common.platform.platform_info import VECTOR_INST_BLOCK_WIDTH
        vec_len = get_soc_spec("VECTOR_REG_WIDTH")
        if vec_len != VECTOR_INST_BLOCK_WIDTH:
            cmd += ["-Xclang", "-fcce-vf-vl=" + str(vec_len)]
    cmd = modify_cmd_by_enable_cce_debug_mode(cmd)
    skt_env = os.getenv('SKT_ENABLE')
    if skt_env == "1":
        from tvm.runtime import cce_runtime
        if cce_runtime.CceFlag.BatchBindOnly is True:
            cmd += ["-mllvm", "-cce-aicore-sk-transform"]
            cce_runtime.CceFlag.BatchBindOnly = False
    if get_soc_spec("SHORT_SOC_VERSION") != ASCEND_610LITE and \
            get_soc_spec("SHORT_SOC_VERSION") != BS9SX2A and \
            get_soc_spec("SHORT_SOC_VERSION") != MC61AM21A and \
            get_soc_spec("SHORT_SOC_VERSION") != ASCEND_910_95:
        cmd += ["--cce-auto-sync=off"]
    if current_build_config().get(enable_cce_licm_safe_hoist):
        cmd += ["-mllvm", "-licm-safe-hoist=true"]
    cmd += ["-mllvm", "-cce-aicore-jump-expand=false"]
    cmd += ["-mllvm", "-cce-aicore-mask-opt=false"]
    if current_build_config().get(enable_machine_outliner):
        cmd += ["-mllvm", "-enable-machine-outliner"]
    if enable_sanitizer():
        cmd[-3] = "-cce-aicore-jump-expand=true"
        cmd += ["--cce-enable-sanitizer", "-g", "-mllvm", "-cce-aicore-long-call"]
    return cmd

def _get_asan_lib_path(sub_arch):
    BISHENG_BIN_PATH = os.path.join(os.getenv('ASCEND_HOME_PATH'), "tools")
    if not os.path.exists(BISHENG_BIN_PATH):
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "bisheng tool path not exist. cannot find asan lib")
    return os.path.join(BISHENG_BIN_PATH, "mssanitizer/lib64", "libsanitizer_stub_" + sub_arch + ".a")

def build_sanitizer_link_cmd(src_file, dst_file):
    """Build the mssanitize link command before link.
    Parameters
    ----------
    src_file : str
        The src object file.

    dst_file : str
        The object file.

    Return
    ------
    cmd : list
        The link command.

    """
    from tbe.common.platform.platform_info import ASCEND_910B
    from tbe.common.platform.platform_info import ASCEND_910_93
    from tbe.common.platform.platform_info import get_soc_spec
    short_soc = get_soc_spec("SHORT_SOC_VERSION")
    if not isinstance(src_file, list):
        src_file = [src_file]
    cmd = [CCECInfo.get_exe("ld.lld"),
           "-m",
           "aicorelinux",
           "-r",
           "-Ttext=0", ]
    cmd.extend(src_file)
    if short_soc in [ASCEND_910B, ASCEND_910_93]:
        asan_lib_path1 = _get_asan_lib_path("dav-c220-cube")
        asan_lib_path2 = _get_asan_lib_path("dav-c220-vec")
        cmd.extend(['--dependent-libraries',
                    asan_lib_path1, asan_lib_path2])
    else:
        asan_lib_path = _get_asan_lib_path("dav-m200")
        cmd.extend(['--dependent-libraries', asan_lib_path])
    cmd.extend([
        "-r",
        "-o",
        "%s" % dst_file,
        ])
    return cmd

def build_compile_cmd_for_def(src_file, dst_file):
    # used for compile simply cce file which contain global var definition only
    cmd = [CCECInfo.get_exe("ccec"),
           "-c",
           "-O2",
           src_file,
           "--%s" % "cce-aicore-only",
           "-o",
           dst_file
           ]
    cmd.extend(["-mllvm", "-cce-aicore-function-stack-size=16000",
                "-mllvm", "-cce-aicore-record-overflow=false",
                "-mllvm", "-cce-aicore-jump-expand=false",
                "-mllvm", "-cce-aicore-addr-transform"])
    return cmd


def modify_cmd_by_enable_cce_debug_mode(cmd):
    """Add --cce-debug-mode to the compile command if trace_store is used on ASCEND_310 or
    ASCEND_910.
    :param cmd: list
        The compile command.
    :return: cmd: list
        The compile command.
    """
    from tbe.common.platform.platform_info import get_soc_spec
    from tbe.common.platform.platform_info import ASCEND_910
    from tbe.common.platform.platform_info import ASCEND_310
    from tbe.common.buildcfg.buildcfg_mapping import enable_cce_debug_mode
    if current_build_config().get(enable_cce_debug_mode):
        if not (ASCEND_910 in get_soc_spec("SOC_VERSION") or ASCEND_310 in get_soc_spec(
                "SOC_VERSION")):
            raise RuntimeError("%s doesn't support trace_store\n" %
                               get_soc_spec("SOC_VERSION"))
        cmd += ["--cce-debug-mode"]
    return cmd


def build_aicore_link_to_relocatable_cmd(src_file, dst_file):
    """Build the link command for aicore op.

    Parameters
    ----------
    src_file : str
        The src object file.

    dst_file : str
        The relocatable object file.

    Return
    ------
    cmd : list
        The link command.

    """
    from tbe.common.platform.platform_info import get_soc_spec
    if not isinstance(src_file, list):
        src_file = [src_file]
    cmd = [CCECInfo.get_exe("ld.lld"),
           "-m",
           "aicorelinux",
           "-r",
           "-Ttext=0", ]
    cmd.extend(src_file)
    short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
    if short_soc_version == "Ascend310B":
        cmd.extend([
            "-static",
            "-z",
            "separate-code",
            "-o",
            "%s" % dst_file,
        ])
    else:
        cmd.extend([
            "-static",
            "-n",
            "-o",
            "%s" % dst_file,
        ])
    return cmd


def _build_aicpu_compile_cmd(target, src_file, dst_file):
    """Build the compile command for aicpu op.

    Parameters
    ----------
    cce_product_params : TempDirectory
        Instance of class CceProductParams.

    target : str
        Types of aicpu, cce_cpu or cce_cpu_llvm

    src_file : str
        The file of source code used in compile.

    dst_file : str
        The object file.

    Return
    ------
    cmd : list
        The compile command.

    """
    from tbe.common.platform.platform_info import get_soc_spec
    from tbe.common.platform.platform_info import COMPILER_ARCH
    from tbe.common.platform.platform_info import ASCEND_910
    from tbe.common.platform.platform_info import ASCEND_910B
    from tbe.common.platform.platform_info import ASCEND_910_93
    from tbe.common.buildcfg.buildcfg_mapping import tbe_debug_level, op_debug_config

    if get_soc_spec("SHORT_SOC_VERSION") in [ASCEND_910, ASCEND_910B, ASCEND_910_93]:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "this platform could not support AICPU")

    optimization_level = "-O2"
    # 2 enable tbe debug : ccec compiler with "O0 - g"
    if current_build_config().get(tbe_debug_level) == 2 or \
            "ccec_O0" in current_build_config().get(op_debug_config):
        optimization_level = "-O0"

    env_path = os.getenv('TVM_AICPU_INCLUDE_PATH')
    if not env_path:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "can not find the TVM_AICPU_INCLUDE_PATH environment variable, please config it")

    if not check_env_variable(env_path):
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "the TVM_AICPU_INCLUDE_PATH environment variable contains sepcial "
                             "code: '|, ;, &, $, &&, ||, >, >>, <' please config it")

    env_path = get_env_real_path(env_path)
    aicpu_support_os = (get_soc_spec(COMPILER_ARCH) == "true")
    arch = "cce-aicpu-only"
    cce_arch_prefix = "cce-aicpu-arch"
    cmd = [CCECInfo.get_exe("ccec"),
           "-c",
           optimization_level,
           src_file,
           "--%s" % arch,
           "--%s=%s" % (cce_arch_prefix, "cortex-a55"),
           "-mcpu=cortex-a55", ]
    # 2 enable tbe debug : ccec compiler with "O0 - g"
    if current_build_config().get(tbe_debug_level) == 2 or \
            "ccec_g" in current_build_config().get(op_debug_config):
        cmd.append("-g")
    if target == "cce_cpu_llvm":
        cmd += ["--target=aarch64-hisilicon-cce", "-fPIC"]
    if aicpu_support_os:
        if target == "cce_cpu":
            cmd += ['--cce-aicpu-no-firmware']
            # Safety_checks
            cmd += ['--cce-aicpu-fstack-protector-all', '-fPIC']
        elif target == "cce_cpu_llvm":
            # must specify -mllvm first
            cmd += ['-mllvm', '-cce-aicpu-no-firmware=true']
    for inc_path in env_path.split(':'):
        if inc_path:
            cmd += ["-I%s" % inc_path]
    cmd += ["-o",
            dst_file, ]
    return cmd


# Example: pylint: disable=too-many-branches, unused-argument
def _build_aicpu_link_cmd(target, src_file, dst_file,
                          lib_name):
    """Build the link command for aicpu op.

    Parameters
    ----------
    cce_product_params : TempDirectory
        Instance of class CceProductParams.

    target : str
        Types of aicpu, cce_cpu or cce_cpu_llvm

    src_file : str
        The file of source code used in compile.

    dst_file : str
        The object file.

    lib_name : str
        lib name of each op, using in soname.

    Return
    ------
    cmd : list
        The link command.

    """
    env_path = os.getenv('TVM_AICPU_LIBRARY_PATH')
    if not env_path:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "can not find the TVM_AICPU_LIBRARY_PATH environment variable, please config it")

    if not check_env_variable(env_path):
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "the TVM_AICPU_INCLUDE_PATH environment variable contains sepcial "
                             "code: '|, ;, &, $, &&, ||, >, >>, <' please config it")

    env_path = get_env_real_path(env_path)
    # bool to indicate aicpu support os in a specified product
    from tbe.common.platform.platform_info import get_soc_spec
    from tbe.common.platform.platform_info import COMPILER_ARCH
    aicpu_support_os = (get_soc_spec(COMPILER_ARCH) == "true")
    # -static: do not link against shared libraries
    # -m :Set target emulation, aicpulinux,aicorelinux,aarch64linux
    #          (see ld.lld --help for detail)
    lib_type = ["-static", "-m", "aicpulinux", "-Ttext", "0"]
    if aicpu_support_os:
        # create a shared library
        lib_type = ["-shared", "-m", "aarch64linux"]

    cmd = [CCECInfo.get_exe("ld.lld")] + lib_type + \
          [src_file, "-ltvm_aicpu", "-lm", "-lc", ]
    # add library search path
    if aicpu_support_os:
        for lib_path in env_path.split(PATH_DELIMITER):
            if lib_path and "aicpu_lib" not in lib_path:
                cmd += ["-L%s" % lib_path]
    else:
        for lib_path in env_path.split(':'):
            if lib_path:
                cmd += ["-L%s" % lib_path,
                        "-L%s/../../../../../toolchain/artifacts/aicpu_lib" % lib_path, ]

    # add include seach path
    env_path = os.getenv('TVM_AICPU_INCLUDE_PATH')
    if not env_path:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "can not find the TVM_AICPU_LIBRARY_PATH environment variable, please config it")

    # if aicpu has deployed OS
    if aicpu_support_os:
        env_path = os.getenv('TVM_AICPU_OS_SYSROOT')
        if not env_path:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                 "can not find the TVM_AICPU_OS_SYSROOT environment variable, please config it")
        if not check_env_variable(env_path):
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                 "the TVM_AICPU_OS_SYSROOT environment variable contains sepcial "
                                 "code: '|, ;, &, $, &&, ||, >, >>, <' please config it")

        env_path = get_env_real_path(env_path)
        lib_includes = env_path
        if not lib_includes:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                 "can not find the TVM_AICPU_OS_SYSROOT environment variable, "
                                 "please config it")

        if lib_includes:
            aarch_path = "aarch64-linux-gnu"
            gnu_path = "/usr/%s" % aarch_path
            if lib_includes == gnu_path:  # developerkit
                cmd += ['-L%s/lib' % lib_includes.strip()]
            else:
                cmd += ['--sysroot=%s' % lib_includes.strip()]
                cmd += ['-L%s/usr/lib64' % lib_includes.strip()]
        cmd += ['-soname=%s.so' % lib_name]
        # Safety_checks
        cmd += ['-z', 'relro', '-z', 'now', '-z', 'noexecstack']

    cmd += ["-o", dst_file]
    return cmd


# write the cmpile_cmd to cce file
def write_compile_cmd_to_cce_file(compile_cmd, dst_file=None):
    if dst_file is None or compile_cmd is None:
        return
    actual_cmd = []
    for arg in compile_cmd:
        if arg[-2:] == '.h' or arg[-4:] == '.cce':
            actual_cmd.append(dst_file)
        else:
            actual_cmd.append(arg)

    with open(dst_file, 'a') as f:
        f.write("// ")
        f.write(" ".join(str(cmd) for cmd in actual_cmd))


def _run_cmd_stack_spill_case(cmd, cmd_type, cce_file=None):
    """Run a shell commond (only support linux) for stack spill case in
     aicore.

    Parameters
    ----------
    cmd : list
        Command to be run.

    cmd_type : str
        Comand type uesd in running.

    Return
    ------
    out : str
        Standard output.

    """
    cmd.append("-mllvm")
    cmd.append("-disable-lsr")
    cmd.append("-fno-unroll-loops")
    write_compile_cmd_to_cce_file(cmd, cce_file)
    proc = subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    (out, _) = proc.communicate()
    if proc.returncode != 0:
        print('run stack spill compile error: ', out.decode())
        msg = "%s error %s:\n" % (cmd_type, out.decode())
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, msg)
    return out


def _run_cmd_stackoverflow_case(cmd, cmd_type, cce_file=None):
    """Run a shell commond (only support linux) for stack overflow case in
     aicore.
    The current compiler's hardware instructions are not friendly to large
    immediate Numbers.
    Add compile options "-mllvm", "-disable-machine-licm" can avoid this
    problem, but it can degrade performance.

    Parameters
    ----------
    cmd : list
        Command to be run.

    cmd_type : str
        Comand type uesd in running.

    Return
    ------
    out : str
        Standard output.

    """
    from tbe.common.platform.platform_info import get_soc_spec
    from tbe.common.platform.platform_info import ASCEND_310P
    from tbe.common.platform.platform_info import ASCEND_310
    cmd.insert(3, "-mllvm")
    cmd.insert(4, "-disable-machine-licm")
    if "-cce-aicore-jump-expand=false" in cmd:
        cmd[cmd.index("-cce-aicore-jump-expand=false")] = "-cce-aicore-jump-expand=true"
    if get_soc_spec("SHORT_SOC_VERSION") == ASCEND_310P:
        cmd.insert(5, "-mllvm")
        cmd.insert(6, "-cce-aicore-function-stack-size=16000")
    elif get_soc_spec("SHORT_SOC_VERSION") == ASCEND_310:
        cmd.insert(5, "-mllvm")
        cmd.insert(6, "-cce-aicore-function-stack-size=8192")
    proc = subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    (out, _) = proc.communicate()
    if proc.returncode != 0:
        _run_cmd_stack_spill_case(cmd, cmd_type, cce_file)
    else:
        write_compile_cmd_to_cce_file(cmd, cce_file)
    return out


def run_cmd(cmd, cmd_type, cce_file=None):
    """Run a shell commond (only support linux).

    Parameters
    ----------
    cmd : list
        Command to be run.

    cmd_type : str
        Comand type uesd in running.

    Return
    ------
    out : str
        Standard output.

    """
    proc = subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    (out, _) = proc.communicate()
    is_compile_cmd = cmd_type == "compile"
    if proc.returncode != 0:
        if is_compile_cmd and "-O0" in cmd and "-g" in cmd:
            switching_compilation_mode()
            cmd[cmd.index("-O0")] = "-O2"
            del cmd[cmd.index("-g")]
            proc_now = subprocess.Popen(
                cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            (out, _) = proc_now.communicate()
            if proc_now.returncode != 0:
                if "--cce-aicore-only" in cmd:
                    _run_cmd_stackoverflow_case(cmd, cmd_type, cce_file)
                else:
                    write_compile_cmd_to_cce_file(cmd, cce_file)
                    print('run cmd compile aicore-only error: ', out.decode())
                    msg = "%s error %s:\n" % (cmd_type, out.decode())
                    raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, msg)
            else:
                write_compile_cmd_to_cce_file(cmd, cce_file)
            return out

        # stack overflow case for aicore compile
        if is_compile_cmd and "--cce-aicore-only" in cmd:
            _run_cmd_stackoverflow_case(cmd, cmd_type, cce_file)
        else:
            if is_compile_cmd:
                write_compile_cmd_to_cce_file(cmd, cce_file)
            print('run cmd compile error: ', out.decode())
            msg = "%s error %s:\n" % (cmd_type, out.decode())
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE, msg)
    elif is_compile_cmd:
        write_compile_cmd_to_cce_file(cmd, cce_file)
    return out


# Example: pylint: disable=unused-argument
def _get_kernel_name(kernel_name, target, path_target):
    """Getting the lib name of op.

    Parameters
    ----------
    code : str
        Source code.

    target : str
        Target format.

    path_target : str
        The target path of op.

    Return
    ------
    kernel name : str
        kernel name of op

    """
    kernel_name = ''
    try:
        if path_target:
            kernel_name = path_target.split(".")[0].split('/')[-1]
        else:
            return kernel_name
    except IndexError as err:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             ("Getting kernel name failed" + err))
    finally:
        pass
    return kernel_name


def _check_tmpdir(dirpath):
    from tbe.common.buildcfg.buildcfg_mapping import tbe_debug_level, op_debug_config
    from tbe.common.buildcfg.buildcfg_mapping import random_cce_file_location
    if current_build_config().get(tbe_debug_level) or \
            "dump" in current_build_config().get(op_debug_config) or \
            not current_build_config().get(random_cce_file_location):
        return
    if sys.platform.startswith('linux'):
        tmp_dir = os.getenv("TMPDIR")
        if not (dirpath.startswith('/tmp')
                or dirpath.startswith('/var/tmp')
                or dirpath.startswith('/usr/tmp')
                or dirpath.startswith(os.path.realpath('/tmp'))
                or dirpath.startswith(os.path.realpath('/var/tmp'))
                or dirpath.startswith(os.path.realpath('/usr/tmp'))
                or (tmp_dir is not None and dirpath.startswith(tmp_dir))):
            raise_tbe_python_err(
                TBE_DEFAULT_PYTHON_ERROR_CODE, "dir path is invalid")
    elif sys.platform.startswith("win32"):
        # Example: pylint: disable=anomalous-backslash-in-string
        if not dirpath.find("AppData\Local\Temp"):
            raise_tbe_python_err(
                TBE_DEFAULT_PYTHON_ERROR_CODE, "dir path is invalid")
    else:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             ("Platform %s is not support now" % sys.platform))


def _dump_cce(kernel_name, temp_code, dump_superkernel_to_h):
    """save the temp cce file

    Parameters
    ----------
    kernel_name : str
        the cce file name is kernel_name.cce

    temp_code: str
        the temp cce file

    Returns
    -------
    None
    """
    from tbe.common.buildcfg.buildcfg_mapping import kernel_meta_parent_dir
    from tbe.common.buildcfg.buildcfg_mapping import build_fatbin
    from tbe.common.buildcfg.buildcfg_mapping import save_temp_cce_file, op_debug_config
    from tbe.common.buildcfg.buildcfg_mapping import dump_to_header_file, enable_model_fusion
    from tbe.common.buildcfg.buildcfg_mapping import dump_cce_code

    def _save_cce_file(kernel_name, temp_file):
        from tbe.common.platform.platform_info import KernelName
        cce_path = os.path.join(current_build_config().get(
            kernel_meta_parent_dir), "kernel_meta")
        if current_build_config().get(build_fatbin):
            cce_path = os.path.join(current_build_config().get(
                kernel_meta_parent_dir), "kernel_meta", KernelName.get_kernel_name())
        if cce_path is not None:
            cce_file_path = ""
            if dump_superkernel_to_h == 0 and (current_build_config().get(save_temp_cce_file) or \
                                               "dump_cce" in current_build_config().get(op_debug_config)):
                cce_file_path = os.path.realpath("%s/%s%s" %
                                                 (os.path.normpath(cce_path),
                                                  kernel_name, ".cce"))
            if current_build_config().get(dump_to_header_file) or \
                    (current_build_config().get(enable_model_fusion) and dump_superkernel_to_h == 1):
                cce_file_path = os.path.realpath("%s/%s%s" %
                                                 (os.path.normpath(cce_path),
                                                  kernel_name, ".h"))
            if not cce_file_path:
                return None
            dir_path = os.path.dirname(cce_file_path)
            if not os.path.isdir(dir_path):
                raise_tbe_python_err(
                    TBE_DEFAULT_PYTHON_ERROR_CODE, "cce file path not exist")
            if temp_file == cce_file_path:
                return cce_file_path
            copy_cmd = ["cp", temp_file, cce_file_path]
            os.chmod(dir_path, stat.S_IRWXU + stat.S_IRGRP)
            run_cmd(copy_cmd, "copy")
            os.chmod(cce_file_path, stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP)
            return cce_file_path
        return None

    real_cce_file_path = _save_cce_file(kernel_name, temp_code)

    if current_build_config().get(dump_cce_code):
        with open(temp_code) as fi:
            print(fi.read())

    return real_cce_file_path


def link_from_relocatable_file_to_final(src_file, dst_file, is_contain_global_def=False, is_mix=True):
    # Input should be relocatable object file (link cmd with -r param), then use this linking without -r .
    # (which means final linking, it would rewrite address for global variable, etc.)
    # !!!ATTENTION!!!
    # You can NOT do any incremental link from the output file generated by linking without -r !
    from tbe.common.platform.platform_info import get_soc_spec
    from tbe.common.buildcfg.buildcfg_mapping import build_fatbin
    from tbe.common.platform.platform_info import COMPILER_ARCH
    if not isinstance(src_file, list):
        src_file = [src_file]
    link_cmd = [CCECInfo.get_exe("ld.lld"),
                "-m",
                "aicorelinux",
                "-Ttext=0",
                ]
    # !!!ATTENTION!!! "-z norelro" is conflict with "-n".
    # If contain global variable definition, the data segment should be 4k aligned, and RELRO should be shutdown.
    # And can not use param "-n"
    if is_contain_global_def:
        link_cmd.extend([
            "-z", "max-page-size=4096",
            "-z", "separate-loadable-segments",
            "-z", "norelro"
        ])
    link_cmd.extend(src_file)
    short_soc_version = get_soc_spec("SHORT_SOC_VERSION")
    if short_soc_version == "Ascend310B":
        link_cmd.extend(["-static",
                         "-z", "separate-code",
                         "-o",
                         "%s" % dst_file,
                         ])
    else:
        if not is_contain_global_def:
            link_cmd.append("-n")  # "-z norelro" is conflict with "-n".
        link_cmd.extend(["-static",
                         "-o",
                         "%s" % dst_file,
                         ])
    if enable_sanitizer() and not current_build_config().get(build_fatbin) and not is_mix:
        from tbe.common.platform.platform_info import ASCEND_910B
        from tbe.common.platform.platform_info import ASCEND_910_93
        from tbe.common.platform.platform_info import ASCEND_310P
        short_soc = get_soc_spec("SHORT_SOC_VERSION")
        if not short_soc in [ASCEND_910B, ASCEND_910_93, ASCEND_310P]:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                "sanitizer do not support ", short_soc)
        soc_name_map = {ASCEND_910B: get_soc_spec(COMPILER_ARCH),
                        ASCEND_910_93: get_soc_spec(COMPILER_ARCH),
                        ASCEND_310P: "dav-m200"}
        asan_static_lib_path = _get_asan_lib_path(soc_name_map[short_soc])
        link_cmd.extend(['--dependent-libraries', asan_static_lib_path])
        run_cmd(link_cmd, "link")
    else:
        run_cmd(link_cmd, "link")


# 'pylint:disable=missing-function-docstring
def get_temp_code(target, dirpath, kernel_name):
    if target in ['cce_core', 'cce_cpu']:
        temp_code = os.path.realpath(
            os.path.join(dirpath, kernel_name + ".cce"))
    elif target == "cce_cpu_llvm":
        temp_code = os.path.realpath(
            os.path.join(dirpath, kernel_name + ".ll"))
    return temp_code


def is_need_link_from_relocatable(is_need_relocating):
    from tbe.common.platform.platform_info import ASCEND_910B, get_soc_spec
    from tbe.common.buildcfg.buildcfg_mapping import enable_multicore_sync_with_atomic, \
        enable_deterministic_mode, duplicate_codes
    from tbe.common.context import get_context
    context = get_context()
    # current build config not build fatbin.
    # 1.Tik global variable need link.
    # 2.Multicore sync with atomic need link
    # 3.Deterministic mode need link.
    # 4.Duplicate code,
    #     not tik global variable.
    #     not Multicore sync with atomic.
    #     not Deterministic mode.
    #   need link. not build fatbin in mix in not link here.
    return context and (context.get_compile_info("global_variable_link")) or is_need_relocating or \
        current_build_config().get(enable_multicore_sync_with_atomic) or \
        current_build_config().get(enable_deterministic_mode) or \
        (current_build_config().get(duplicate_codes) != 0 and
         get_soc_spec("SHORT_SOC_VERSION") == ASCEND_910B) or enable_sanitizer()


# Example: pylint: disable=too-many-locals, too-many-arguments, unused-argument
@time_statistics
def compile_cce(dirpath,
                kernel_name,
                additional_info,
                target="cce_core",
                path_target=None,
                dump_superkernel_to_h=False):
    """Compile cce code with ccec from env.

    Parameters
    ----------
    dirpath : str
        The dir path.

    kernel_name : str
        The kernel name.

    target: str
        The target is "cce_core".

    additional_info : list
        Contain additional info such as is_ffts_needed, is_mix, is_need_relocating, etc.

    path_target : str
        The output file path.

    Return
    ------
    binary : bytearray
        The bytearray of the binary
    """
    from tbe.common.buildcfg.buildcfg_mapping import tbe_debug_level, op_debug_config
    from tbe.common.buildcfg.buildcfg_mapping import random_cce_file_location
    from tbe.common.buildcfg.buildcfg_mapping import enable_vector_core
    assert (len(additional_info) == 3)
    if target not in ["cce_core", "cce_cpu", "cce_cpu_llvm"]:
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "Unknown architecture, does not support now")

    dirpath = os.path.realpath(dirpath)
    _check_tmpdir(dirpath)

    temp_code, temp_target, temp_linked_target = _get_temp_dir(dirpath, target)

    def updata_temp_code(tmp_code):
        if current_build_config().get(tbe_debug_level) or \
                "dump" in current_build_config().get(op_debug_config) or \
                not current_build_config().get(random_cce_file_location):
            return get_temp_code(target, dirpath, kernel_name)
        return tmp_code

    temp_code = updata_temp_code(temp_code)
    if not os.path.exists(temp_code):
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "tmp code file not exits")

    # dump cce if enabled
    real_cce_file_path = _dump_cce(kernel_name, temp_code, dump_superkernel_to_h)

    # compile step, both aicore and aicpu
    file_target = path_target or temp_target
    from tbe.common.buildcfg.buildcfg_mapping import enable_model_fusion
    from tbe.common.buildcfg import GlobalInfoContainer
    if (current_build_config().get(enable_model_fusion) and dump_superkernel_to_h == 1) and \
            GlobalInfoContainer.global_info["is_supernetwork_header"] is False:
        return None

    is_ffts_needed, is_mix, is_need_relocating = additional_info
    if target == "cce_core":
        from tbe.common.platform.platform_info import get_soc_spec
        from tbe.common.platform.platform_info import COMPILER_ARCH
        a = get_soc_spec(COMPILER_ARCH)
        # compile aicore kernel
        compile_cmd = _build_aicore_compile_cmd(temp_code,
                                                file_target, kernel_name, is_ffts_needed, is_mix)
        run_cmd(compile_cmd, "compile", real_cce_file_path)
        from tbe.common.platform.platform_info import ASCEND_910B, ASCEND_910_93, ASCEND_910_95, get_soc_spec
        from tbe.common.buildcfg.buildcfg_mapping import build_fatbin, save_temp_cce_file
        is_target_version = get_soc_spec("SHORT_SOC_VERSION") in [ASCEND_910B, ASCEND_910_93, ASCEND_910_95]
        if not current_build_config().get(build_fatbin) and (not is_mix or not is_target_version) \
                and not current_build_config().get(enable_vector_core):
            if is_need_link_from_relocatable(is_need_relocating):
                link_from_relocatable_file_to_final(file_target, file_target, is_need_relocating, is_mix)
            # delete temp cce if needed
            if not current_build_config().get(save_temp_cce_file) and \
                    not current_build_config().get(random_cce_file_location) and \
                    current_build_config().get(tbe_debug_level) == 0:
                os.remove(temp_code)

    elif target in ('cce_cpu', 'cce_cpu_llvm'):
        # compile aicpu kernel
        file_target = temp_target
        compile_cmd = _build_aicpu_compile_cmd(target,
                                               temp_code, file_target)
        run_cmd(compile_cmd, "compile")
        path_target = path_target or temp_linked_target
        kernel_name = _get_kernel_name(kernel_name, target, path_target)
        link_cmd = _build_aicpu_link_cmd(target,
                                         file_target,
                                         path_target,
                                         kernel_name)
        run_cmd(link_cmd, "link")
    # Example: pylint: disable=pointless-statement
    with open(file_target, "rb") as f:
        try:
            return bytearray(f.read())
        except Exception as e:
            raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                                 ("get byte array error" + e))
        finally:
            f.close()
    return None


def compile_fatbin(sub_path, src_list, dst_file):
    from tbe.common.buildcfg.buildcfg_mapping import incremental_link
    from tbe.common.platform.platform_info import get_soc_spec
    # link each object file of each kernel for fatbin
    if current_build_config().get(incremental_link):
        dst_file = '%s%s' % (dst_file.rstrip(".o"), "_tmp.o")
    src_file = []
    for src in src_list:
        src_file_name = '%s%s' % (os.path.join(sub_path, src['kernelName']), ".o")
        if enable_sanitizer():
            src_tmp_name = '%s%s' % (src_file_name.rstrip(".o"), "_ld2.o")
            link_cmd = build_sanitizer_link_cmd(
                src_file_name, src_tmp_name)
            run_cmd(link_cmd, "link")
            src_file_name = src_tmp_name
        src_file.append(src_file_name)
    link_cmd = build_aicore_link_to_relocatable_cmd(src_file, dst_file)
    run_cmd(link_cmd, "link")


def check_env_variable(env_variable):
    '''
    check if the enviroment variable contains special characters.
    :param env_variable: enviroment variable
    :return:True or False
    '''
    if sys.platform.startswith('linux'):
        spe_code = ['|', ';', '&', '$', '&&', '||', '>', '>>', '<', '`', '\\',
                    '!']
    else:
        spe_code = ['|', '&', '$', '&&', '||', '>', '>>', '<', '`', '!']

    for i in spe_code:
        if i in repr(env_variable):
            return False

    return True


def get_env_real_path(env_variable):
    """
    realpath the env_variable
    :param env_variable: enviroment variable
    :return:real path env
    """
    items = []
    for env_path in env_variable.split(PATH_DELIMITER):
        env_real_path = os.path.realpath(env_path)
        if env_real_path is not None:
            items.append('%s%s' % (env_real_path, PATH_DELIMITER))
    env_variable_real_path = ''.join(items)

    if env_variable_real_path == "":
        raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                             "can not find the environment variable, please config it")

    return env_variable_real_path[0:len(env_variable_real_path) - 1]


# default delimiter for env path
PATH_DELIMITER = ':'
if sys.platform.startswith('linux'):
    PATH_DELIMITER = ':'
elif sys.platform.startswith('win32'):
    PATH_DELIMITER = ';'
else:
    raise_tbe_python_err(TBE_DEFAULT_PYTHON_ERROR_CODE,
                         ('Platform % is not support now' % sys.platform))
