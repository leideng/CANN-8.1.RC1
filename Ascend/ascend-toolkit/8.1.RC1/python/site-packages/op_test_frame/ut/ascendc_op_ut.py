import configparser
import os
import subprocess
from typing import Dict
from typing import Any
from op_test_frame.common.ascend_tbe_op import AscendOpKernel
from op_test_frame.common.ascend_tbe_op import AscendOpKernelRunner
from op_test_frame.ut import op_ut_case_info
from op_test_frame.ut.op_ut import OpUT
from op_test_frame.utils import file_util

ASCENDC_SOC_VERSION_MAP = {
    'Ascend910A': 'dav-c100',
    'Ascend310P1': 'dav-m200',
    'Ascend310P3': 'dav-m200',
    'Ascend610': 'dav-m200'
}


class AscendcOpUt(OpUT):
    def __init__(self, op_type):
        super().__init__(op_type, op_type, None)

    @staticmethod
    def _check_ascendc_compile_params(ascendc_op_path, tikcfw_path):
        if not os.path.isfile(ascendc_op_path):
            raise ValueError('Ascendc op path is not a file')
        if not os.path.isdir(tikcfw_path):
            raise ValueError('Tikcfw path is not a folder')

    @staticmethod
    def _get_ccec_aic_version(ini_path):
        if not os.path.isfile(ini_path):
            return ''
        file_util.check_file_valid(ini_path)
        parser = configparser.ConfigParser()
        parser.read(ini_path)
        if not parser.has_option('version', 'CCEC_AIC_version'):
            return ''
        return parser.get('version', 'CCEC_AIC_version')

    @staticmethod
    def _get_all_soc_info(cfg):
        tikcfw_path = cfg.get('tikcfw_path')
        if not tikcfw_path or not os.path.isdir(tikcfw_path):
            raise ValueError('tikcfw path is not a folder.')
        platform_cfg_path = os.path.join(tikcfw_path, '../../data/platform_config')
        if not os.path.isdir(platform_cfg_path):
            raise ValueError('platform_config path is not a folder.')
        soc_info_dict = {}
        files = os.listdir(platform_cfg_path)
        for file_path in files:
            if '.' not in file_path:
                continue
            soc_version = file_path.split('.')[0]
            ccec_aic_version = AscendcOpUt._get_ccec_aic_version(os.path.join(platform_cfg_path, file_path))
            if not ccec_aic_version:
                continue
            soc_info_dict[soc_version] = ccec_aic_version
        return soc_info_dict

    def _compile_op_kernel(self, run_soc_version, case_info: op_ut_case_info.OpUTCase, check_exist=False,
                           ascendc_compile_cfg: Dict = None):
        if not ascendc_compile_cfg:
            raise ValueError('Ascendc compile config is not available')
        soc_info_dict = self._get_all_soc_info(ascendc_compile_cfg)
        if run_soc_version not in soc_info_dict:
            raise ValueError('Unsupported soc version.')
        soc_info = soc_info_dict.get(run_soc_version)
        ascendc_op_path = ascendc_compile_cfg.get('ascendc_op_path')
        tikcfw_path = ascendc_compile_cfg.get('tikcfw_path')
        self._check_ascendc_compile_params(ascendc_op_path, tikcfw_path)
        if not os.path.exists(OpUT.KERNEL_DIR):
            file_util.makedirs(OpUT.KERNEL_DIR)
        output_path = os.path.join(OpUT.KERNEL_DIR, self._get_kernel_name(run_soc_version, case_info) + '.o')
        ascendc_compile_cmd = ['ccec', '-c', '-x', 'cce', '-O2', ascendc_op_path, '-o', output_path, '-std=c++17',
                               f'--cce-aicore-arch={soc_info}', '--cce-aicore-only', '-mllvm',
                               '-cce-aicore-function-stack-size=16000', '-mllvm', '-cce-aicore-fp-ceiling=2',
                               '-mllvm', '-cce-aicore-record-overflow=False',
                               f'-I{tikcfw_path}', f'-I{tikcfw_path}/impl', f'-I{tikcfw_path}/interface']
        result_compile = subprocess.Popen(ascendc_compile_cmd, shell=False, stdout=subprocess.PIPE,
                                          stderr=subprocess.STDOUT)
        err_msg = None
        while result_compile.poll() is None:
            line = result_compile.stdout.readline().decode().strip()
            if line:
                if not err_msg:
                    err_msg = line
                else:
                    err_msg += os.linesep + line
        return result_compile.returncode == 0, err_msg

    def _run_kernel(self, run_soc_version: str, case_info: op_ut_case_info.OpUTCase, run_cfg: Dict[str, Any] = None):
        bin_path = os.path.join(OpUT.KERNEL_DIR, self._get_kernel_name(run_soc_version, case_info) + ".o")
        input_info_list, output_info_list = self._get_input_outputs(case_info.op_params)
        input_data_list = []
        for input_info in input_info_list:
            self._gen_input_data(input_info)
            input_data_list.append(input_info.get("value"))
        op_kernel = AscendOpKernel(bin_path, ascendc_cfg=run_cfg)
        op_kernel.set_input_info(input_info_list)
        op_kernel.set_output_info(output_info_list)
        simulator_mode = self._get_simulator_mode(run_cfg)
        simulator_dump_path = self._get_simulator_dump_path(simulator_mode, case_info.case_name, run_cfg)
        with AscendOpKernelRunner(simulator_mode=simulator_mode,
                                  soc_version=run_soc_version,
                                  simulator_lib_path=self._get_simulator_lib_path(run_cfg),
                                  simulator_dump_path=simulator_dump_path) as runner:
            output_data_list = runner.run(op_kernel, inputs=input_data_list)

            if not isinstance(output_data_list, (tuple, list)):
                output_data_list = (output_data_list,)
            for output_data in output_data_list:
                if output_data:
                    output_data.sync_from_device()

        for idx, output_info in enumerate(output_info_list):
            output_info["value"] = output_data_list[idx].get_data()
