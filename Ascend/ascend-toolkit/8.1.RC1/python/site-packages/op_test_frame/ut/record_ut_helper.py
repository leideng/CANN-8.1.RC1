# Copyright (c) Huawei Technologies Co., Ltd. 2023. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
ut helper for record
"""
from types import MappingProxyType

from tbe.dsl.base import operation
from tbe.dsl.base.record import record


def test_static(compute_func,
                record_args=(),
                record_kwargs=MappingProxyType({}),
                run_args=(),
                run_kwargs=MappingProxyType({})):
    return _test_compute_func(compute_func,
                              lambda: operation.static(),
                              [record_args, record_kwargs],
                              [run_args, run_kwargs]
                              )


def _test_compute_func(compute_func,
                       context_func,
                       record_xargs,
                       run_xargs,
                       ):
    record_args, record_kwargs = record_xargs[0], record_xargs[1]
    run_args, run_kwargs = run_xargs[0], run_xargs[1]
    with context_func():
        operation.start_record()
        record_outs = compute_func(*record_args, **record_kwargs)
        record_outs = list(record_outs) if isinstance(record_outs, (tuple, list)) else [record_outs]

        operation.start_rerun()
        for a, b in zip(record_args, run_args):
            if isinstance(a, record.Record):
                a.set_ori(b)

        for k, v in record_kwargs.items():
            if isinstance(v, record.Record):
                v.set_ori(run_kwargs[k])

        for x in operation.get_actions():
            x.execute()

        rerun_outs = [x.get_ori() for x in record_outs]

    with context_func():
        run_outs = compute_func(*run_args, **run_kwargs)
        run_outs = list(run_outs) if isinstance(run_outs, (tuple, list)) else [run_outs]

    return _compare(rerun_outs, run_outs)


def _compare(outs1, outs2):
    if len(outs1) != len(outs2):
        return False

    for a, b in zip(outs1, outs2):
        if not _compare_single(a, b):
            return False

    return True


def _compare_single(t1, t2):
    shape1, shape2 = list(t1.shape), list(t2.shape)
    dtype1, dtype2 = t1.dtype, t2.dtype
    tag1, tag2 = t1.op.tag, t2.op.tag

    if (shape1, dtype1, tag1) != (shape2, dtype2, tag2):
        return False

    input_tensors1, input_tensors2 = t1.op.input_tensors, t2.op.input_tensors

    if len(input_tensors1) != len(input_tensors2):
        return False

    for a, b in zip(input_tensors1, input_tensors2):
        if not _compare_single(a, b):
            return False

    return True
