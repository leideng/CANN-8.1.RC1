#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright 2021-2022 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
graph_parser
"""
from tbe.common.utils import log as logger
from op_manager import get_inout_info_from_opstore
from constant import (GraphDefParam, CompileParam, OpcOptions, OpcCompileMode, \
                      GraphDtype, DATA_TYPE, OpParamType, OptionalInOutMode)


class GraphParser:
    """
    define a GraphParser
    parse --graph to json format dict
    """
    def __init__(self, options):
        """
        init class
        """
        self.__graph_def = options.get(OpcOptions.GRAPH_DEF)
        self.__options = options

    def __get_option(self, option):
        """
        get_option
        """
        if option == "":
            logger.warning("Input param option is empty")
            return None

        if option is None:
            logger.warning("Input param option is None")
            return None

        return self.__options.get(option)

    def __set_option(self, option, value):
        """
        set_option
        """
        if option == "":
            logger.warning("Input param option is empty")
            return

        if option is None:
            logger.warning("Input param option is None")
            return

        self.__options[option] = value

    @staticmethod
    def __get_graph_attr_value(attrs, key):
        """
        get graph attr value by key
        """
        if attrs is None:
            return None

        for attr in attrs[CompileParam.ATTRS]:
            if key == attr[CompileParam.NAME]:
                return attr[CompileParam.VALUE]
        return None

    def __group_soc_info(self):
        """
        group soc info
        """
        soc_info_options = {
            OpcOptions.SOC_VERSION: OpcOptions.SOC_VERSION,
            OpcOptions.OP_DEBUG_LEVEL: OpcOptions.OP_DEBUG_LEVEL,
            OpcOptions.IMPL_MODE: OpcOptions.IMPL_MODE,
        }
        soc_info = dict()
        for key, option in soc_info_options.items():
            value = self.__get_option(key)
            if value is not None:
                soc_info[option] = value

        return soc_info

    @staticmethod
    def __feed_list_value(one_attr, value_list):
        """
        feed list value
        """
        val = list()
        dtype = None
        value = None
        if value_list.i != []:
            dtype = GraphDtype.LIST_INT
            for item in value_list.i:
                val.append(item)
            value = val

        elif value_list.s != []:
            dtype = GraphDtype.LIST_STRING
            for item in value_list.s:
                val.append(item.decode("UTF-8"))
            value = val

        elif value_list.b != []:
            dtype = GraphDtype.LIST_BOOL
            for item in value_list.b:
                val.append(item)
            value = val

        elif value_list.f != []:
            dtype = GraphDtype.LIST_FLOAT
            for item in value_list.f:
                val.append(item)
            value = val
        else:
            logger.warn("value list is empty")

        one_attr[CompileParam.DTYPE] = dtype
        one_attr[CompileParam.VALUE] = value

    @staticmethod
    def __feed_list_list_value(one_attr, value_list):
        """
        feed_list_list_value
        """
        val = list()
        for list_list_item in value_list.list_list_i:
            val_list = list()
            for list_item in list_list_item.list_i:
                val_list.append(list_item)
            val.append(val_list)
        one_attr[CompileParam.DTYPE] = GraphDtype.LIST_LIST_INT
        one_attr[CompileParam.VALUE] = val

    @staticmethod
    def __feed_non_list_value(one_attr, value):
        """
        feed_non_list_value
        """
        graph_dtype = value.WhichOneof(CompileParam.VALUE)
        if graph_dtype == 'i' or graph_dtype == 'dt':
            attr_val = value.i
            attr_dtype = GraphDtype.INT

        elif graph_dtype == 's' or graph_dtype == 'bt':
            attr_val = value.s.decode("UTF-8")
            attr_dtype = GraphDtype.STRING

        elif graph_dtype == 'b':
            attr_val = value.b
            attr_dtype = GraphDtype.BOOL

        elif graph_dtype == 'f':
            attr_val = value.f
            attr_dtype = GraphDtype.FLOAT

        else:
            logger.warn("Invalid dtype: %s", graph_dtype)
            return

        one_attr[CompileParam.DTYPE] = attr_dtype
        one_attr[CompileParam.VALUE] = attr_val

    def __group_attr(self, attr_list):
        """
        group_attr
        """
        input_attr_list = list()
        attr = dict()
        variable_attr_value = list()
        for key in attr_list:
            one_attr = dict()
            one_attr[CompileParam.NAME] = key
            value = attr_list[key]

            if value.HasField(CompileParam.LIST):
                value_list = value.list
                self.__feed_list_value(one_attr, value_list)
                if (key == GraphDefParam.VAR_ATTRS):
                    variable_attr_value = one_attr[CompileParam.VALUE]

            elif value.HasField(CompileParam.LIST_LIST_INT):
                list_list_int = value.list_list_int
                self.__feed_list_list_value(one_attr, list_list_int)

            else:
                self.__feed_non_list_value(one_attr, value)

            input_attr_list.append(one_attr)

        if len(input_attr_list) == 0:
            logger.debug("Has no attrs.")
            return None

        input_attr_list_update = self.__parse_value_range_attr(input_attr_list, variable_attr_value)
        attr[CompileParam.ATTRS] = input_attr_list_update
        return attr

    def check_suffix_and_feed_attr(self, suffix, prefix, mode_attr, one_attr, input_attr):
        if suffix == CompileParam.RANGE_MODE:
            mode_attr[prefix] = input_attr[CompileParam.VALUE]
        if suffix == CompileParam.VALUE_LIST:
            one_attr[CompileParam.NAME] = prefix
            if input_attr[CompileParam.DTYPE] == GraphDtype.LIST_INT:
                one_attr[CompileParam.DTYPE] = GraphDtype.INT
            if input_attr[CompileParam.DTYPE] == GraphDtype.LIST_FLOAT:
                one_attr[CompileParam.DTYPE] = GraphDtype.FLOAT
            one_attr[CompileParam.VALUE_LIST] = input_attr[CompileParam.VALUE]
        if suffix == CompileParam.VALUE_RANGE:
            one_attr[CompileParam.NAME] = prefix
            if input_attr[CompileParam.DTYPE] == GraphDtype.LIST_LIST_INT:
                one_attr[CompileParam.DTYPE] = GraphDtype.INT
            if input_attr[CompileParam.DTYPE] == GraphDtype.LIST_LIST_FLOAT:
                one_attr[CompileParam.DTYPE] = GraphDtype.FLOAT
            one_attr[CompileParam.VALUE_RANGE] = input_attr[CompileParam.VALUE]
            one_attr[CompileParam.RANGE_MODE] = mode_attr[prefix]

    def __parse_value_range_attr(self, input_attr_list, variable_attr_value):
        """
        prase variable_attr
        input_attr_list: attrs transform from pbtxt, need to prase
                        value_range/value_list/range_mode from it
        variable_attr_value: prefix of value_range/value_list/range_mode
        eg.
        input:
        {
            'attrs': [
                {
                    'name': '_input_name_key',
                    'dtype': 'list_string',
                    'value': ['bias', 'filter', 'offset_w', 'x']
                }, {
                    'name': 'p_value_list',
                    'dtype': 'list_int',
                    'value': [1, 2, 3]
                }, {
                    'name': 'a_value_range',
                    'dtype': 'list_list_int',
                    'value': [
                        [1, 2]
                    ]
                }, {
                    'name': 'var_attr',
                    'dtype': 'list_string',
                    'value': ['p', 'a', 'c']
                }, {
                    'name': 'a_range_mode',
                    'dtype': 'list_string',
                    'value': ['left_excluded']
                }
            ]
        }

        expect output:
        {
            'attrs': [
            {
                'name': '_input_name_key',
                'dtype': 'list_string',
                'value': ['bias', 'filter', 'offset_w', 'x']
            }, {
                'name': 'var_attr',
                'dtype': 'list_string',
                'value': ['p', 'a', 'c']
            }, {
                'name': 'p',
                'dtype': 'int',
                'value_list': [1, 2, 3]
            }, {
                'name': 'a',
                'dtype': 'int',
                'value_range': [
                    [1, 2]
                ],
                'range_mode': ['left_excluded']
            }]
        }
        """
        if len(variable_attr_value) == 0:
            return input_attr_list

        list_suffix = [CompileParam.RANGE_MODE, CompileParam.VALUE_RANGE, CompileParam.VALUE_LIST]
        ori_attr_name = []
        mode_attr = dict()
        for suffix in list_suffix:
            suffix_len = len(suffix)
            for prefix in variable_attr_value:
                prefix_len = len(prefix)
                for input_attr in input_attr_list:
                    attr_name = input_attr[CompileParam.NAME]
                    if attr_name[:prefix_len] == prefix and attr_name[-suffix_len:] == suffix and \
                         len(attr_name) == prefix_len + suffix_len + 1:
                        ori_attr_name.append(attr_name)
                        one_attr = dict()
                        self.check_suffix_and_feed_attr(suffix, prefix, mode_attr, one_attr, input_attr)
                        if one_attr:
                            input_attr_list.append(one_attr)

        logger.debug("Parse special value attrs are %s", ori_attr_name)
        # filter ori_attrs, eg. a_range_mode, a_value_range, p_value_list
        input_attr_list_update = list()
        for item in input_attr_list:
            if item[CompileParam.NAME] not in ori_attr_name:
                input_attr_list_update.append(item)

        return input_attr_list_update

    @staticmethod
    def __feed_shape_dim(input_shape, input):
        """
        feed_shape_dim
        """
        if input.shape.dim is None:
            return
        for item in input.shape.dim:
            input_shape.append(item)

    def __feed_inout_attr_2_desc(self, input_desc, attr_list):
        """
        feed_inout_attr_2_desc
        """
        if attr_list is None:
            return
        for key in attr_list:
            one_attr = dict()
            value = attr_list[key]

            if value.HasField(CompileParam.LIST):
                value_list = value.list
                self.__feed_list_value(one_attr, value_list)

            elif value.HasField(CompileParam.LIST_LIST_INT):
                list_list_int = value.list_list_int
                self.__feed_list_list_value(one_attr, list_list_int)

            else:
                self.__feed_non_list_value(one_attr, value)

            input_desc[key] = one_attr.get(CompileParam.VALUE)

    @staticmethod
    def __get_real_input_op_name(input_name):
        pos = input_name.rfind(":")
        return input_name[:pos]

    @staticmethod
    def __covert_graph_param_to_op(desc):
        if desc.get(CompileParam.SHAPE_RANGE):
            desc[CompileParam.RANGE] = desc.get(CompileParam.SHAPE_RANGE)
        if desc.get(GraphDefParam.ORIGIN_SHAPE):
            desc[CompileParam.ORI_SHAPE] = desc.get(GraphDefParam.ORIGIN_SHAPE)
            if desc.get(GraphDefParam.ORIGIN_FORMAT):
                desc[CompileParam.ORI_FORMAT] = desc.get(GraphDefParam.ORIGIN_FORMAT)

    @staticmethod
    def __get_attr_value(attrs, key):
        for attr in attrs:
            attr_name = attr.get("name")
            if attr_name == key:
                attr_val = attr.get("value")
                logger.info("Get attr[%s] from attrs.", key)
                return attr_val
        return None

    def __get_inputs_info(self, op_type, attrs):
        """
        generate input_paramType_list, For example:
        conv2d has input (x, filter, bias, offset_w)
        and its optional input is (bias, offset_w)
        so the input_paramType_list is (0, 0, 1, 1)
        0 means non-optional input, 1 means optional input
        """
        if self.__options.get(OpcOptions.OPTIONAL_INPUT_MODE) == OptionalInOutMode.DEFAULT:
            return None
        inputs_paramtype_list = self.__get_attr_value(attrs, "_ir_inputs_value")
        if inputs_paramtype_list is not None:
            return inputs_paramtype_list
        input_name_list = self.__get_attr_value(attrs, "_input_name_key")
        input_name_idx_list = self.__get_attr_value(attrs, "_input_name_value")
        opt_input_list = self.__get_attr_value(attrs, "_opt_input")
        input_info = list()

        if opt_input_list is None:
            input_info, _ = get_inout_info_from_opstore(op_type)
            if input_info is None or input_name_list is None:
                logger.info("Op[type=%s] has no input, no need to check paramType.",
                            str(op_type))
                return None
            for inputi_info in input_info:
                if inputi_info.param_type == OpParamType.OPT:
                    opt_input_list.append(inputi_info.name)
        if opt_input_list is None:
            logger.info("Op[type=%s] has no optional input, no need to generate placeholder.",
                        str(op_type))
            return None
        if len(input_name_list) != len(input_name_idx_list):
            logger.error("Op[type=%s] has incomplete graph infos.",
                         str(op_type))
        input_sorted_list = list()
        for i, in_name in enumerate(input_name_list):
            input_idx = input_name_idx_list[i]
            input_sorted_list.append((in_name, input_idx))

        def take_second(elem):
            return elem[1]
        input_sorted_list.sort(key=take_second)
        inputs_paramtype_list = list()
        for input_name, idx in input_sorted_list:
            if input_name in opt_input_list:
                inputs_paramtype_list.append(1)
            else:
                inputs_paramtype_list.append(0)
        return inputs_paramtype_list

    def __group_op_input_desc(self, op_input_desc, op_input, inputs_paramtype_list):
        inputs_desc = list()
        for i, input in enumerate(op_input_desc):
            input_desc = dict()
            input_desc[CompileParam.NAME] = self.__get_real_input_op_name(op_input[i])
            input_desc[CompileParam.FORMAT] = input.layout
            input_desc[CompileParam.DTYPE] = DATA_TYPE[input.dtype]
            if inputs_paramtype_list is not None and inputs_paramtype_list[i] == 1:
                input_desc[CompileParam.PARAM_TYPE] = "optional"

            input_shape = list()
            self.__feed_shape_dim(input_shape, input)
            if len(input_shape) != 0:
                input_desc[CompileParam.SHAPE] = input_shape

            self.__feed_inout_attr_2_desc(input_desc, input.attr)
            self.__covert_graph_param_to_op(input_desc)

            inputs_desc.append(input_desc)
        return inputs_desc

    def __group_op_output_desc(self, op_output_desc, op_desc):
        outputs_desc = list()
        for i, output in enumerate(op_output_desc):
            output_desc = dict()
            output_desc[CompileParam.NAME] = op_desc.get(CompileParam.NAME)
            output_desc[CompileParam.FORMAT] = output.layout
            output_desc[CompileParam.DTYPE] = DATA_TYPE[output.dtype]
            output_desc[CompileParam.OUTPUT_INDEX] = i
            output_shape = list()
            self.__feed_shape_dim(output_shape, output)
            if len(output_shape) != 0:
                output_desc[CompileParam.SHAPE] = output_shape
            self.__feed_inout_attr_2_desc(output_desc, output.attr)
            self.__covert_graph_param_to_op(output_desc)

            outputs_desc.append(output_desc)
        return outputs_desc

    def __group_op_list(self, graph_def):
        """
        group op list
        """
        op_list = list()
        for op in graph_def.op:
            op_desc = dict()
            op_desc[CompileParam.NAME] = op.name
            op_desc[CompileParam.TYPE] = op.type
            op_desc[CompileParam.ID] = op.id
            op_desc[CompileParam.INPUT] = [op.input[i] for i in range(len(op.input))]
            # op.attr is map<string, AttrDef>
            attrs = self.__group_attr(op.attr)
            if attrs:
                op_desc.update(attrs)
            self.__feed_inout_attr_2_desc(op_desc, op.attr)
            for attr in op_desc["attrs"]:
                if attr.get("name", None) == OpcOptions.SIMPLE_KEY:
                    op_desc[OpcOptions.SIMPLE_KEY] = attr.get("value")
                    break
            inputs_paramtype_list = self.__get_inputs_info(op_desc[CompileParam.TYPE], attrs["attrs"])
            # group input desc
            inputs_desc = self.__group_op_input_desc(op.input_desc, op.input, inputs_paramtype_list)
            op_desc[GraphDefParam.INPUT_DESC] = inputs_desc

            # group output desc
            outputs_desc = self.__group_op_output_desc(op.output_desc, op_desc)
            op_desc[GraphDefParam.OUTPUT_DESC] = outputs_desc

            op_list.append(op_desc)

        return op_list

    def group_compile_param(self):
        graph_def = self.__get_option(OpcOptions.GRAPH_DEF)  # The GRAPH_DEF had been checked


        json_data = dict()
        json_data[GraphDefParam.GRAPH_NAME] = graph_def.name
        json_data[CompileParam.SOC_INFO] = self.__group_soc_info()
        json_data[CompileParam.OP_LIST] = self.__group_op_list(graph_def)
        graph_pattern = self.__get_graph_attr_value(self.__group_attr(graph_def.attr), CompileParam.GRAPH_PATTERN)
        status_check = self.__get_graph_attr_value(self.__group_attr(graph_def.attr), CompileParam.STATUS_CHECK)

        if graph_pattern is not None:
            json_data[CompileParam.GRAPH_PATTERN] = graph_pattern
        if not status_check:
            status_check = "true"
        json_data[CompileParam.STATUS_CHECK] = status_check.lower()

        op_compile_mode = self.__get_option(OpcOptions.OP_COMPILE_MODE)
        if op_compile_mode == OpcCompileMode.SINGLE_OP_GRAPH_MODE:
            self.__set_option(OpcOptions.SINGLE_OP_PARAM, json_data)
            for op in json_data.get(CompileParam.OP_LIST):
                op[OpcOptions.BIN_FILENAME] = self.__get_option(OpcOptions.BIN_FILENAME)

        elif op_compile_mode == OpcCompileMode.FUSION_OP_GRAPH_MODE:
            json_data[CompileParam.FUSION_OP_NAME] = self.__get_option(OpcOptions.BIN_FILENAME)
            self.__set_option(OpcOptions.FUSION_OP_PARAM, json_data)
        else:
            raise RuntimeError("There is --graph, but OP_COMPILE_MODE is config file!")
