#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright 2024-2025 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
 
"""
fusion_op_post_compile
"""
import copy
import json
import os
import copy

from pathlib import Path
from tbe.common.utils import log as logger
from opc_common import (str_to_sha256_hash)
from opc_common import (update_json_file)
from constant import (CompileParam, SupportInfo, OpcOptions, GraphDefParam, OptionalInOutMode, GraphDtype)
from post_compile_base import PostCompilation


class FusionOpPostCompile(PostCompilation):

    @staticmethod
    def __get_graph_pattern_from_op(json_dict):
        """
        get graph_pattern from op attrs
        """
        op_list = json_dict.get(CompileParam.OP_LIST)
        for op in op_list:
            attrs = op.get(CompileParam.ATTRS)
            if attrs is None:
                continue
            for attr in attrs:
                if attr is None:
                    continue
                if attr.get(CompileParam.NAME) == CompileParam.GRAPH_PATTERN:
                    return attr.get(CompileParam.VALUE)
        return None


    def update_supportinfo_to_json_file(self, json_dict, json_file_path):
        """
        fusion op update supportinfo to json file after fusion compile
        """
        logger.debug("Update fusion op support info to json.")
        support_info = self.__generate_graph_support_json(json_dict)
        logger.debug("support_info is {}.".format(support_info))

        if not Path(json_file_path).is_file():
            raise RuntimeError("compile json file[%s] not exist." % json_file_path)

        update_json_file("supportInfo", support_info, json_file_path)

    def __generate_op_in_or_out_supportinfo(self, op_list, is_inputs, is_support_info):
        """
        generate_op_in_or_out_supportinfo
        """
        if is_inputs:
            inputs = []
            non_opt_inputs = list()
            for cur_op in op_list:
                if cur_op.get(GraphDefParam.EXTERNEL_INPUT):
                    continue
                input = list()
                non_opt_input = list()
                is_externel_input = super().get_externel_input(cur_op, op_list, input, non_opt_input)
                if is_externel_input:
                    cur_op[GraphDefParam.EXTERNEL_INPUT] = True
                    inputs.extend(input)
                    non_opt_inputs.extend(non_opt_input)
            return inputs, non_opt_inputs
        else:
            outputs = []
            for cur_op in op_list:
                output = list()
                if super().get_externel_output(cur_op, op_list, output):
                    outputs.extend(output)
            return outputs, []

    def __generate_graph_in_or_out_supportinfo(self, json_dict, is_inputs, is_support_info):
        """
        generate_graph_in_or_out_supportinfo
        """
        op_list = json_dict.get(CompileParam.OP_LIST)
        if op_list is not None:
            in_or_out, non_opt_inputs = self.__generate_op_in_or_out_supportinfo(op_list, is_inputs, is_support_info)
            return in_or_out, non_opt_inputs
        else:
            logger.debug("graph {}'s op_list is null.".format(json_dict.get(GraphDefParam.GRAPH_NAME)))
            return None, None

    def __get_graph_op_params(self, json_dict):
        """
        get graphOpParams from graph
        """
        def _op_attrs_correct(attrs, res):
            for attr in attrs:
                attr_value = attr.get(CompileParam.VALUE)
                if attr_value == "all":
                    op_attr[CompileParam.VALUE] = []
            if attrs:
                res[CompileParam.ATTRS] = attrs

        graph_op_params_list = []
        graph_op_params = []
        graph_op_params_without_impl_mode = []
        op_list = json_dict.get(CompileParam.OP_LIST)
        if op_list is None:
            logger.debug("op_list is null.")
            return None
        for op in op_list:
            op_type = op.get(CompileParam.TYPE)
            if op_type == "Data" or op_type == "Const":
                continue
            impl_or_input_attrs = {}
            op_attrs = op.get(CompileParam.OP_ATTRS)
            if op_attrs is not None:
                _op_attrs_correct(op_attrs, impl_or_input_attrs)
            op_name = op.get(CompileParam.NAME)
            if op_name not in self._fusion_op_impl_mode:
                graph_op_params.append(impl_or_input_attrs)
                graph_op_params_without_impl_mode.append(impl_or_input_attrs)
                continue

            impl_mode, opt_impl_mode_flag = self._fusion_op_impl_mode.get(op_name)
            opt_impl_or_input_attrs = copy.deepcopy(impl_or_input_attrs)
            if opt_impl_mode_flag:
                graph_op_params_without_impl_mode.append(opt_impl_or_input_attrs)
            else:
                graph_op_params_without_impl_mode.append(impl_or_input_attrs)
            impl_or_input_attrs["implMode"] = impl_mode
            graph_op_params.append(impl_or_input_attrs)
        graph_op_params_list.append(graph_op_params)
        if graph_op_params_without_impl_mode not in graph_op_params_list:
            graph_op_params_list.append(graph_op_params_without_impl_mode)
        logger.debug("graph_op_params_list is [%s]", str(graph_op_params_list))
        return graph_op_params_list

    @staticmethod
    def __generate_graph_in_or_out_static_info(in_or_out_info):
        """
        remove not static info from op info
        """
        static_keys = (CompileParam.DTYPE, CompileParam.FORMAT, CompileParam.SHAPE)
        new_inout_infos = list()
        for in_or_out in in_or_out_info:
            if in_or_out is None:
                logger.debug("Input is none. Add none to new_inout_infos.")
                new_inout_infos.append(None)
                continue
            new_op_info = dict()
            for key in static_keys:
                value = in_or_out.get(key, None)
                if value is not None:
                    new_op_info[key] = value
            new_inout_infos.append(new_op_info)
        logger.debug("graph I/O static info is [%s]", new_inout_infos)
        return new_inout_infos

    @staticmethod
    def __generate_graph_op_params_static_info(graph_op_params):
        """
        remove not static info from graph op params
        """
        logger.debug("Generate graph support static key op params %s.", str(graph_op_params))
        new_op_params = copy.deepcopy(graph_op_params)
        for op_param in new_op_params:
            if CompileParam.ATTRS not in op_param:
                continue
            for attr in op_param.get(CompileParam.ATTRS):
                if attr is None:
                    continue
                del attr[CompileParam.NAME]
                if CompileParam.VALUE_RANGE in attr:
                    del attr[CompileParam.VALUE_RANGE]
                    del attr[CompileParam.RANGE_MODE]
                    attr[CompileParam.VALUE] = None
                    continue
                if CompileParam.VALUE_LIST in attr:
                    del attr[CompileParam.VALUE_LIST]
                    attr[CompileParam.VALUE] = None
                    continue
                if CompileParam.VALUE not in attr or attr[CompileParam.VALUE] is None:
                    continue
                if attr[CompileParam.DTYPE] in (GraphDtype.FLOAT, GraphDtype.LIST_FLOAT):
                    attr[CompileParam.VALUE] = None

        return new_op_params

    def __generate_single_static_json(self, json_dict, non_opt_inputs, support_info):
        logger.debug("Generate graph support json_dict static key is %s.", str(json_dict))
        static_key_json = dict()
        # should be in alphabetical order to add in static_key_json, because reuse json is in this order
        build_options = super().get_static_key_build_options(json_dict)
        super().gen_notnone_param(static_key_json, SupportInfo.BUILD_OPTIONS, build_options)

        graph_op_params = self.__generate_graph_op_params_static_info(support_info[SupportInfo.GRAPH_OP_PARAMS])
        super().gen_notnone_param(static_key_json, SupportInfo.GRAPH_OP_PARAMS, graph_op_params)

        opt_input_mode = self._opc_compile_args.get(OpcOptions.OPTIONAL_INPUT_MODE)
        logger.debug("Generate graph support static key inputs, optional input mode is %s.", opt_input_mode)
        inputs = self.__generate_graph_in_or_out_static_info(support_info[SupportInfo.INPUTS])
        if opt_input_mode == OptionalInOutMode.GEN_PLACEHOLDER:
            inputs = non_opt_inputs
        super().gen_notnone_param(static_key_json, SupportInfo.INPUTS, inputs)

        outputs = self.__generate_graph_in_or_out_static_info(support_info[SupportInfo.OUTPUTS])
        super().gen_notnone_param(static_key_json, SupportInfo.OUTPUTS, outputs)
        logger.debug("Generate graph support static key outputs %s.", str(support_info[SupportInfo.OUTPUTS]))

        static_key_json_str = json.dumps(static_key_json, separators=(',', ':'))
        logger.debug("Generate fusion op static key is %s.", str(static_key_json_str))
        return static_key_json_str

    def __generate_static_key_for_support_info(self, json_dict, non_opt_inputs, support_info, graph_op_params_list):
        """
        generate_static_key
        """
        static_key_str = str()
        for graph_op_params in graph_op_params_list:
            logger.debug("Generate graph support op params %s.", str(graph_op_params))
            support_info[SupportInfo.GRAPH_OP_PARAMS] = graph_op_params
            static_key_json_str = self.__generate_single_static_json(json_dict, non_opt_inputs, support_info)
            static_key = str_to_sha256_hash(static_key_json_str)
            if len(static_key_str) == 0:
                static_key_str = static_key
            else:
                static_key_str = static_key_str + "," + static_key
        support_info[SupportInfo.STATIC_KEY] = static_key_str

    def __generate_graph_int64_mode(self, op_list):
        support_info_int64_mode = None
        for op in op_list:
            int64_mode = op.get(CompileParam.INT64_MODE)
            if int64_mode is None:
                continue
            if int64_mode is True:
                support_info_int64_mode = True
                break
            if int64_mode is False:
                support_info_int64_mode = False
        return support_info_int64_mode

    def __generate_graph_support_json(self, json_dict):
        """
        generate supportinfo from graph as json_dict format
        """
        logger.debug("Generate graph support dict with %s.", str(json_dict))
        support_info = {}
        graph_pattern = self.__get_graph_pattern_from_op(json_dict)
        if graph_pattern is not None:
            logger.debug("Get graph_pattern is %s.", graph_pattern)
            support_info[SupportInfo.GRAPH_PATTERN] = graph_pattern
        else:
            logger.error("There is no 'graph_pattern' in --graph=%s.",
                         str(self._opc_compile_args.get(OpcOptions.GRAPH)))

        int64_mode = self.__generate_graph_int64_mode(json_dict[CompileParam.OP_LIST])
        if int64_mode is not None:
            support_info[SupportInfo.INT64_MODE] = int64_mode

        non_opt_inputs = list()
        support_info[SupportInfo.INPUTS], non_opt_inputs = \
            self.__generate_graph_in_or_out_supportinfo(json_dict, True, True)
        self.adjust_support_info_inputoutput(support_info.get(SupportInfo.INPUTS))
        logger.debug("Generate graph support dict inputs %s.", str(support_info.get(SupportInfo.INPUTS)))
        support_info[SupportInfo.OUTPUTS], _ = self.__generate_graph_in_or_out_supportinfo(json_dict, False, True)
        self.adjust_support_info_inputoutput(support_info.get(SupportInfo.OUTPUTS))
        logger.debug("Generate graph support dict outputs %s.", str(support_info.get(SupportInfo.OUTPUTS)))

        graph_op_params_list = self.__get_graph_op_params(json_dict)
        self.__generate_static_key_for_support_info(json_dict, non_opt_inputs, support_info, graph_op_params_list)
        logger.info("Fusion op(Binfilename=%s) final staticKey is %s.",
                    self._opc_compile_args.get(OpcOptions.BIN_FILENAME), support_info[SupportInfo.STATIC_KEY])
        opt_input_mode = self._opc_compile_args.get(OpcOptions.OPTIONAL_INPUT_MODE)
        if opt_input_mode == OptionalInOutMode.GEN_PLACEHOLDER:
            support_info[SupportInfo.OPTIONAL_INPUT_MODE] = opt_input_mode
        super().gen_notnone_param(support_info, "opMode", self._opc_compile_args.get(OpcOptions.OP_MODE, None))
        return support_info