#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2021. Huawei Technologies Co., Ltd. All rights reserved.

Define the main function of auto_tune
"""

import copy
import json
import os
import time
from collections import namedtuple
from typing import List
from typing import Optional

from tbe.common.buildcfg.compatible_interface import set_L1_info
from tbe.common.context import op_context
from tbe.common.tiling.tiling_api import instance_refresh
from te_fusion.parallel_compilation import compile_op
from te_fusion.fusion_util import fusion_op_compute

from auto_tune.common_module.common_util import get_soc_info
from auto_tune.auto_tune_log import LOG_INSTANCE
from auto_tune.op_adapter.op_factory import FactoryOperatorAdapter
from auto_tune.te_fusion_json_keys import TeFusionJsonKeys
from auto_tune.te_fusion_json_keys import OpNodeKeys
from auto_tune.te_fusion_json_keys import InputDescKeys
from auto_tune.te_fusion_json_keys import OutputDescKeys
from auto_tune.util_atc import get_input_size_dtype_file
from auto_tune.util_atc import get_output_size_and_dtype
from auto_tune.util_atc import get_output_size_dtype
from auto_tune.util_atc import OP_TAG_DICT
from auto_tune.util_atc import VERSION_DICT
from auto_tune.util_atc import DDR_MEMORY_TYPE
from auto_tune.util_atc import L1_MEMORY_TYPE

#COMPILE_OP wait time
COMPILE_INTERVAL = 300

DataNodeInfo = namedtuple("DataNodeInfo", ["input_shape_list", "input_dtype_list", "input_ori_shape_list",
                        "input_memory_type_list", "slice_offset_list", "valid_shape_list",
                        "cube_weight_fractal_z", "placeholder_name_list", "l1_addr_offset_list", "l1_fusion_type"])

CubeNodeInfo = namedtuple("CubeNodeInfo", ["cube_ori_shape_list", "cube_dtype_list", "cube_ori_format_list",
    "all_agrs", "output_shape_list", "output_dtype_list", "l1_addr_input_flag", "l1_addr_offset"])


def check_load_json(json_str: str) -> dict:
    """
    check load json success or not
    :param json_str: json path
    :return: json data
    """
    json_data = {}
    try:
        json_data = json.loads(json_str)
    except (ValueError, TypeError):
        raise RuntimeError('Read input data error')
    finally:
        pass
    return json_data


def get_info_from_data_node(output_desc: dict, l1_addr_offset_list: List[int]) -> tuple:
    """
    parse the shape information from op_node
    Parameters
    ----------
    param: op_node, get the infomation of input
    param: l1_addr_offset_list, save l1_addr_offset
    """
    ori_shape = output_desc.get(OutputDescKeys.ORI_SHAPE, [])
    data_type = output_desc.get(OutputDescKeys.DATA_TYPE, "")
    if output_desc.get(OutputDescKeys.TOTAL_SHAPE, []) == []:
        input_shape = output_desc.get(OutputDescKeys.SHAPE, [])
    else:
        input_shape = output_desc.get(OutputDescKeys.TOTAL_SHAPE, [])
    slice_offset = output_desc.get(OutputDescKeys.SLICE_OFFSET, [])
    valid_shape = output_desc.get(OutputDescKeys.VALID_SHAPE, [])
    l1_fusion_type = output_desc.get(OutputDescKeys.L1_FUSION_TYPE, -1)
    addr_type = DDR_MEMORY_TYPE
    if OutputDescKeys.ADDR_TYPE in output_desc:
        addr_type = output_desc.get(OutputDescKeys.ADDR_TYPE)
        if addr_type == L1_MEMORY_TYPE and OutputDescKeys.L1_ADDR_OFFSET in output_desc:
            l1_addr_offset = output_desc.get(OutputDescKeys.L1_ADDR_OFFSET, 0)
            l1_addr_offset_list.append(l1_addr_offset)
    return [ori_shape, data_type, input_shape, slice_offset, valid_shape, addr_type, l1_fusion_type]


def get_cube_info_from_node(op_node: dict) -> tuple:
    """
    parse the cube information from op_node
    Parameters
    ----------
    param: get the infomation of cube_op

    """
    cube_ori_shape_list = []
    cube_dtype_list = []
    cube_ori_format_list = []
    all_agrs = []
    output_shape_list = []
    output_dtype_list = []
    if OpNodeKeys.INPUT_DESC not in op_node:
        raise RuntimeError("Lack of input_desc for op name: %s" % op_node.get("name"))
    l1_addr_flag = 0
    l1_addr_offset = -1
    for input_desc_node in op_node.get(OpNodeKeys.INPUT_DESC):
        cube_ori_shape = None
        cube_ori_format = ""
        cube_dtype = ""
        if input_desc_node.get(InputDescKeys.SHAPE) != "NULL":
            cube_ori_shape = input_desc_node.get(InputDescKeys.ORI_SHAPE, None)
            cube_ori_format = input_desc_node.get(InputDescKeys.ORI_FORMAT, "")
            cube_dtype = input_desc_node.get(InputDescKeys.DATA_TYPE, "")
        cube_ori_shape_list.append(cube_ori_shape)
        cube_dtype_list.append(cube_dtype)
        cube_ori_format_list.append(cube_ori_format)

        # By defualt, only fmp used l1_addr_flag and l1_addr_offset
        l1_addr_flag = max(l1_addr_flag, input_desc_node.get(InputDescKeys.L1_ADDR_FLAG, 0))
        l1_addr_offset = max(l1_addr_offset, input_desc_node.get(InputDescKeys.L1_ADDR_OFFSET, 0))

    for arg in op_node.get(OpNodeKeys.ATTR_DESC, []):
        all_agrs.append(arg)

    for output_desc in op_node.get(OpNodeKeys.OUTPUT_DESC):
        if output_desc is not None:
            if output_desc.get(OutputDescKeys.TOTAL_SHAPE, []) == []:
                output_shape_list.append(output_desc.get(OutputDescKeys.SHAPE, []))
            else:
                output_shape_list.append(output_desc.get(OutputDescKeys.TOTAL_SHAPE, []))
            output_dtype_list.append(output_desc.get(OutputDescKeys.DATA_TYPE, ""))

    return CubeNodeInfo(cube_ori_shape_list, cube_dtype_list, cube_ori_format_list, \
        all_agrs, output_shape_list, output_dtype_list, l1_addr_flag, l1_addr_offset)


def get_input_node_info(op_node: dict, data_node_info: DataNodeInfo) -> DataNodeInfo:
    """
    get input_node information, save in data_node_info
    """
    data_node_desc = op_node.get(OpNodeKeys.OUTPUT_DESC)[0]
    data_node_info.placeholder_name_list.append(data_node_desc.get(OutputDescKeys.NAME))
    # cat placeholder info
    ori_shape = None
    if data_node_desc.get(OutputDescKeys.SHAPE) != "NULL":
        ori_shape, data_type, input_shape, slice_offset, valid_shape, addr_type, tmp_l1_fusion_type = \
            get_info_from_data_node(data_node_desc, data_node_info.l1_addr_offset_list)
        data_node_info.input_shape_list.append(input_shape)
        data_node_info.input_dtype_list.append(data_type)
        data_node_info.input_memory_type_list.append(addr_type)
        data_node_info.slice_offset_list.append(slice_offset)
        data_node_info.valid_shape_list.append(valid_shape)
        data_node_info = data_node_info._replace(l1_fusion_type=tmp_l1_fusion_type)
        if data_node_desc.get(OutputDescKeys.FORMAT) == "FRACTAL_Z":
            data_node_info = data_node_info._replace(cube_weight_fractal_z=data_node_desc.get(OutputDescKeys.SHAPE))
    data_node_info.input_ori_shape_list.append(ori_shape)
    return data_node_info


def get_op_info_from_fusion_json(json_str: str) -> dict:
    """
    parse the op information
    Parameters
    ----------
    param: json_str, the infomation of op
    """
    # get json data
    json_data = check_load_json(json_str)

    op_tag = ""
    fu_op_num = 0
    fu_op_name = []
    ori_op_name = []
    strided_read_input = None

    set_L1_info("op_L1_space", json_data.get(TeFusionJsonKeys.L1_SIZE))
    data_node_info = DataNodeInfo([], [], [], [], [], [], None, [], [], -1)
    cube_node_info = CubeNodeInfo([], [], [], [], [], [], 0, -1)
    # get params from json_data
    for op_node in json_data.get(TeFusionJsonKeys.OP_LIST, []):
        op_type = op_node.get(OpNodeKeys.TYPE)
        if op_type == "Data":
            data_node_info = get_input_node_info(op_node, data_node_info)
            continue
        fu_op_num += 1
        func_name = op_node.get(OpNodeKeys.FUNC_NAME, "")
        fu_op_name.append(func_name)
        if op_node.get(OpNodeKeys.ORI_NAME, ""):
            ori_op_name.append(op_node.get(OpNodeKeys.ORI_NAME))
        if func_name == "strided_read":
            strided_read_input = op_node.get(OpNodeKeys.INPUT_DESC)[0].get("shape", [])

        if op_type not in OP_TAG_DICT:
            continue
        # parse cube node specified by OP_TAG_DICT. By default, json_data only has one cube node
        op_tag = op_type
        cube_node_info = get_cube_info_from_node(op_node)

    output_memory_type_list, output_l1_addr_offset_list = get_final_output_info(json_data)
    # combination the info from the te_fusion op
    op_info_dict = {"op_tag": op_tag, "fu_op_num": fu_op_num, "fu_op_name": fu_op_name,
                    "input_ori_shape_list": data_node_info.input_ori_shape_list,
                    "input_shape_list": data_node_info.input_shape_list,
                    "input_dtype_list": data_node_info.input_dtype_list,
                    "output_shape_list": cube_node_info.output_shape_list,
                    "output_dtype_list": cube_node_info.output_dtype_list,
                    "cube_ori_format_list": cube_node_info.cube_ori_format_list,
                    "cube_ori_shape_list": cube_node_info.cube_ori_shape_list,
                    "cube_dtype_list": cube_node_info.cube_dtype_list,
                    "input_memory_type": data_node_info.input_memory_type_list,
                    "output_memory_type": output_memory_type_list,
                    "output_l1_addr_list": output_l1_addr_offset_list,
                    "input_l1_addr_list": data_node_info.l1_addr_offset_list,
                    "l1_addr_input_flag": cube_node_info.l1_addr_input_flag,
                    "l1_addr_offset": cube_node_info.l1_addr_offset,
                    "slice_offset_list": data_node_info.slice_offset_list,
                    "valid_shape_list": data_node_info.valid_shape_list,
                    "all_agrs": cube_node_info.all_agrs,
                    "strided_read_input": strided_read_input,
                    "fusion_op_name": str(json_data.get("fusion_op_name")),
                    "placeholder_name_list": data_node_info.placeholder_name_list,
                    "cube_weight_fractal_z": data_node_info.cube_weight_fractal_z,
                    "l1_fusion_flag": data_node_info.l1_fusion_type != -1,
                    "ori_op_name": ori_op_name}
    return op_info_dict


def get_final_output_info(json_data: dict) -> tuple:
    """
    get the final output addr_type
    :param outputlist:
    :return:
    """
    func_output_name = []
    for op_node in json_data.get(TeFusionJsonKeys.OP_LIST, []):
        if op_node.get(OpNodeKeys.TYPE) == "Data":
            continue
        for inputs in op_node.get(OpNodeKeys.INPUT_DESC):
            if inputs.get(InputDescKeys.NAME) in func_output_name:
                func_output_name.remove(inputs.get(InputDescKeys.NAME))
        # output_desc new naming rule, the output_desc name is not equal to \
        # op_node["name"], but is appended :1 to the op_node["name"]
        for node in op_node.get(OpNodeKeys.OUTPUT_DESC):
            node_name = node.get(OutputDescKeys.NAME).split(":")[0]
            func_output_name.append(node_name)
    func_output_name = list(set(func_output_name))
    final_output_addr_type_list, final_output_l1_addr_offset_list = get_output(json_data, func_output_name)
    return final_output_addr_type_list, final_output_l1_addr_offset_list


def update_type_offset_list(outputs: dict, names: List[str], type_list: List[int], offset_list: List[int]) -> None:
    """
    update l1 addr offset list
    """
    if outputs.get(OutputDescKeys.NAME) in names:
        output_memory_type = 0
        if OutputDescKeys.ADDR_TYPE in outputs:
            output_memory_type = outputs[OutputDescKeys.ADDR_TYPE]
            if output_memory_type == L1_MEMORY_TYPE and OutputDescKeys.L1_ADDR_OFFSET in outputs:
                offset_list.append(outputs[OutputDescKeys.L1_ADDR_OFFSET])
        type_list.append(output_memory_type)


def get_output(json_data: dict, names: List[str]) -> tuple:
    """
    get output info according to names
    :param json_data:
    :param names:
    :return:
    """
    out_addr_type_list = []
    out_l1_addr_offset_list = []
    for op_node in json_data.get(TeFusionJsonKeys.OP_LIST):
        if op_node.get(OpNodeKeys.TYPE) == "Data":
            continue
        for outputs in op_node.get(OpNodeKeys.OUTPUT_DESC):
            update_type_offset_list(outputs, names, out_addr_type_list, out_l1_addr_offset_list)
    return out_addr_type_list, out_l1_addr_offset_list


def get_compile_res(json_str: str, optune_option: dict) -> dict:
    """
    compile op to get shape_args
    """
    func_in_compile = {
        'prerun': (instance_refresh, ["auto_tiling", None, {}]),
        'postrun':(instance_refresh, ["auto_tiling", None, {}])}

    if not optune_option:
        compiler = compile_op(json_str, func_in_compile)
        while not compiler.get():
            pass
        compile_res = compiler.get()
    else:
        compile_key = "GA_compile_%s_%s" % (os.getpid(), str(time.time()).replace(".", "_")[-9:])
        compile_dict = {}
        compile_dict[compile_key] = {"json_str": json_str, "pre_and_post": func_in_compile}
        compile_task_d = optune_option.get("global_mgr").get("compile_task_d")
        compile_result_d = optune_option.get("global_mgr").get("compile_result_d")
        LOG_INSTANCE.info("Start compile task %s!", compile_key)
        compile_task_d.put(compile_dict)
        compile_begin = time.time()
        more_than_5_mins_flag = False
        while True:
            if compile_key in compile_result_d:
                compile_res = copy.deepcopy(compile_result_d.get(compile_key))
                optune_option.get("global_mgr").get("release_compile_q").put(compile_key)
                break
            if not more_than_5_mins_flag and time.time() - compile_begin > COMPILE_INTERVAL:
                LOG_INSTANCE.warning("compile task %s waits more than 5 mins!", compile_key)
                more_than_5_mins_flag = True
    return compile_res


def get_out_size_type_list(json_str: str, op_info_dict: dict) -> tuple:
    """
    get output type and size lists
    """
    # If fusion op, input/output size need to be calculated
    if op_info_dict.get("fu_op_num") > 1:
        with op_context.OpContext():
            res_tensor_list = fusion_op_compute(json_str)
        out_size_list, out_dtype_list = get_output_size_and_dtype(res_tensor_list)
    else:
        out_size_list, out_dtype_list = get_output_size_dtype(op_info_dict)
    return out_size_list, out_dtype_list


def get_topi_args_from_op_info_dict(topi_args: dict, op_info_dict: dict) -> None:
    """
    get topi_args from op info dict
    """
    topi_args['fusion_op_name'] = op_info_dict.get('fusion_op_name')
    topi_args['kernel_name'] = op_info_dict.get('fusion_op_name')
    topi_args["l1_fusion_flag"] = op_info_dict.get("l1_fusion_flag")
    topi_args['input_memory_type'] = op_info_dict.get('input_memory_type')
    topi_args['output_memory_type'] = op_info_dict.get('output_memory_type')
    topi_args['input_l1_addr_list'] = op_info_dict.get('input_l1_addr_list')
    topi_args['output_l1_addr_list'] = op_info_dict.get('output_l1_addr_list')
    topi_args['l1_addr_input_flag'] = op_info_dict.get('l1_addr_input_flag')
    topi_args['l1_addr_offset'] = op_info_dict.get('l1_addr_offset')
    topi_args['slice_offset_list'] = op_info_dict.get('slice_offset_list')
    topi_args['valid_shape_list'] = op_info_dict.get('valid_shape_list')
    topi_args['cube_weight_fractal_z'] = op_info_dict.get("cube_weight_fractal_z")
    topi_args['ori_op_name'] = str(op_info_dict.get('ori_op_name'))


def parse_case_by_tefusion(json_str: str, data: Optional[dict] = None, optune_option: Optional[dict] = None) -> dict:
    """
    parse the input case by json_str
    Parameters
    ----------
    json_str: the information of op
    data: compress_weight data
    """
    if data is None:
        data = {}
    # get op information from te_fusion's json
    op_info_dict = get_op_info_from_fusion_json(json_str)
    op_tag = op_info_dict.get("op_tag")

    # transform op information to input_params
    try:
        op_adapter = FactoryOperatorAdapter(OP_TAG_DICT.get(op_tag))
        input_params = op_adapter.parse_case_for_atc(op_info_dict)
        op_info_dict["input_params"] = input_params
        case_name = op_adapter.get_case_name_for_atc(op_info_dict)
    except (TypeError, IndexError, KeyError, RuntimeError):
        input_params = {}
        input_params[OP_TAG_DICT.get(op_tag)] = {}
        case_name = op_info_dict.get('fusion_op_name')
    finally:
        pass

    soc_version = get_soc_info().soc_version
    # transform input_params to input_args
    input_args = {}
    input_args['topi_args'] = input_params.get(OP_TAG_DICT.get(op_tag))
    input_args.get('topi_args')['soc_version'] = soc_version
    input_args.get('topi_args')["platform"] = VERSION_DICT.get(soc_version)
    input_args.get('topi_args')['test_case'] = case_name
    # add op_tag to save real op type
    input_args.get('topi_args')['real_op_type'] = op_tag

    # For fusion op, extra info should be add to topi_args for estimate
    input_size_list, input_dtype_list, input_file_list = get_input_size_dtype_file(op_info_dict)
    out_size_list, out_dtype_list = get_out_size_type_list(json_str, op_info_dict)
    input_args.get('topi_args')['json_str'] = json_str
    input_args.get('topi_args')['input_size_list'] = input_size_list
    input_args.get('topi_args')['input_type_list'] = input_dtype_list
    input_args.get('topi_args')['input_file_list'] = input_file_list
    input_args.get('topi_args')['output_size_list'] = out_size_list
    input_args.get('topi_args')['output_type_list'] = out_dtype_list
    input_args.get('topi_args')['compress_flag'] = data.get("compress_flag", False)
    input_args.get('topi_args')['real_data'] = []
    for place_holder in data.get("real_data", {}):
        input_args.get('topi_args')['real_data'].append({
            "index": op_info_dict.get("placeholder_name_list").index(place_holder),
            "data": data.get('real_data')[place_holder]})

    get_topi_args_from_op_info_dict(input_args.get('topi_args'), op_info_dict)

    compile_res = get_compile_res(json_str, optune_option)

    # shape_args must be matched with the param of get_tiling(), otherwise compile will fail
    input_args['shape_args'] = {}
    input_args['shape_args'] = compile_res.get("post_res").get("input_params")
    input_args.get('shape_args')['test_case'] = case_name
    input_args.get('shape_args')['op_name'] = op_info_dict.get('fusion_op_name')
    input_args.get('shape_args')["platform"] = VERSION_DICT.get(soc_version)
    input_args["shape_args"] = dict(sorted(input_args.get("shape_args").items(), key=lambda e: e[0]))

    return input_args


def get_input_args(op_desc: str, data: Optional[dict] = None, option: Optional[dict] = None) -> tuple:
    """
    get_input_args by parse_case_by_tefusion
    """
    # parse_case_by_tefusion
    try:
        input_args = parse_case_by_tefusion(op_desc, data, option)
        LOG_INSTANCE.info("op shape_args: %s", input_args.get("shape_args"))
        return True, input_args
    except (TypeError, RuntimeError, IndexError, KeyError, TimeoutError, AttributeError) as err_info:
        # get json data
        json_data = json.loads(op_desc)
        node_name = str(json_data.get("fusion_op_name"))
        LOG_INSTANCE.warning("The kernel %s doesn't support auto tuning.", node_name)
        LOG_INSTANCE.info("Compile op info is : %s", err_info)
        return False, {}
    finally:
        pass
