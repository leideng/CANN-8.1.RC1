#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

Define tuner with genetic algorithm
"""
import os
import copy
import json
import random
import secrets
import numpy as np

from auto_tune.tuner_alg.tuner import Tuner
from auto_tune.auto_tune_log import LOG_INSTANCE
from auto_tune.auto_tune_log import LOG_PROGRESS_INSTANCE
from auto_tune.common_module.common_util import DEFAULT_COEFFICIENT
from auto_tune.common_module.common_util import EXCEPTIONAL_K_VALUE


class GATuner(Tuner):
    """
    Tuner with genetic algorithm.
    This tuner expands the :code:`ConfigEntity` as gene.

    Parameters
    ----------
    task: store config info for genetic algorithm, object
    ga_args: number of genes in one generation, dict
    elite_num: number of elite to keep, int
    """
    def __init__(self, task: object) -> None:
        # define the location of some feature of tiling
        ga_args = task.ga_args
        super(GATuner, self).__init__(task, ga_args=ga_args)
        # algorithm configurations
        self.elite_num = ga_args.get("elite_num")
        # Pc1 of crossover probability
        self.crossover_rate_pc1 = ga_args.get("crossover_rate_pc1")
        # Pc2 of crossover probability
        self.crossover_rate_pc2 = ga_args.get("crossover_rate_pc2")
        # Pm1 of mutation probability
        self.mutation_rate_pm1 = ga_args.get("mutation_rate_pm1")
        # Pm2 of mutation probability
        self.mutation_rate_pm2 = ga_args.get("mutation_rate_pm2")
        # probs formula type
        self.probs_formula_type = ga_args.get("probs_formula_type")
        # config_space info of tiling feature and tiling space
        self.config_space = task.config_space
        self.dims = task.dims
        self.feasibility = task.feasibility
        self.topi_args = task.topi_args
        # current op is 4To2_structured_sparsity
        self.kakb_constrain_coefficient = DEFAULT_COEFFICIENT if not task.is_sparse else 2 * DEFAULT_COEFFICIENT

        # store the corresponding cycles of tiling individuals for
        # current generation
        self.genes_cycles = []
        # store the elites in tiling individuals for previous generation
        self.elites = []
        self.tiling_inputs = []

        self.ga_end_tune_opf_switch = self.task.common_args.get("ga_end_opf_switch") and ga_args.get("early_stop_flag")
        if self.run_optune:
            self.ga_end_tune_opf_switch = ga_args.get("early_stop_flag")
        self.same_elite_cycle = 0
        # store the corresponding cycles of the elites in
        # tiling individuals for previous generation
        self.elite_cycles = []
        if self.can_tune:
            LOG_PROGRESS_INSTANCE.info("Start kernel %s auto tuning. Total tuning round would be %d.",
                self.task.param.get("kernel_name"), self.total_round)
            LOG_INSTANCE.info("Start kernel %s auto tuning. Total tuning round would be %d, early stop option is %s.",
                self.task.param.get("kernel_name"), self.total_round, self.ga_end_tune_opf_switch)
            # random initialization
            self.initial_by_random()

    @staticmethod
    def is_special_value(value: int) -> bool:
        """
        check if value is exception
        """
        return value == EXCEPTIONAL_K_VALUE

    def update_gene_loc_value_by_limit(self, gene: list,
            loc_ref: int, loc_follow: int, check_flag: bool = False) -> None:
        """
        update some values in gene
        Params
        -------
        loc_ref: the refer location
        loc_follow: the location where value will be changed
        val_flag: the type of change flag
        """
        if check_flag:
            if not gene[loc_ref]:
                return
            # in 4To2_sparsity scenario, if ka is 1, kb shoule be 1, otherwise ka = 2kb
            if self.is_special_value(gene[loc_follow]):
                gene[loc_ref] = gene[loc_follow]
            else:
                gene[loc_follow] = gene[loc_ref] * self.kakb_constrain_coefficient
        else:
            gene[loc_follow] = gene[loc_ref]

    def has_next(self) -> bool:
        """
        Whether has enough individuals for
        the next generation in the tiling space

        Returns
        -------
        has_next: bool
        """
        return len(self.feasibility) >= self.pop_size

    def check_condition(self) -> None:
        """
        check params before updating individuals

        Returns
        -------
        check_condition: None
        """
        if self.elite_num > self.pop_size:
            raise ValueError("The number of elites must be less than population size")
        if self.crossover_rate_pc1 > self.crossover_rate_pc2:
            raise ValueError("The number of crossover_rate_pc1 must be less than crossover_rate_pc2")
        if self.mutation_rate_pm1 > self.mutation_rate_pm2:
            raise ValueError("The number of mutation_rate_pm1 must be less than mutation_rate_pm2")

        for res in self.results:
            # record the cost time of tiling
            self.genes_cycles.append(res.cost)
        if len(self.genes_cycles) != len(self.inputs):
            # Add elites into genes
            raise RuntimeError("the number of individuals is not equal to the number of results")

    def ga_loop(self, current_genes: list, scores_probs: list) -> None:
        """
        generate next generation by crossing and variation
        current_genes: current individual of tiling, list
        scores_probs: dimension scores of current individual of tiling, list

        Returns
        -------
        """
        ga_size = self.pop_size
        ga_population = []
        while ga_size > 0:
            if not self.feasibility:
                LOG_INSTANCE.debug("All the tiling space has been consumed.")
                break
            # calculate the probilities of crossover and mutate
            _pc, _pm, indexes = self.get_probility_crossover_mutate(current_genes, scores_probs)
            # do the crossover of gene; generate the individuals after
            # Crossing and probility of mutate
            gene_crossover = self.crossover_gene(current_genes, scores_probs, _pc, indexes)
            # do the mutate of gene
            new_gene_point = self.mutate_gene(gene_crossover, _pm)
            # add the new gene into visited set,
            # and delete the new gene from the feasibility
            if new_gene_point not in self.feasibility:
                continue
            self.feasibility.remove(new_gene_point)
            ga_population.append(new_gene_point)
            ga_size = ga_size - 1

        self.tiling_inputs = ga_population
        if ga_population:
            self.performance_evaluate(ga_population)
        self.genes_cycles = []

    def is_early_stop_same_elite(self, elite_indexes: list, current_cycles: list) -> bool:
        """
        is early stop same elite
        """
        current_elite_cycle = []
        for ind in elite_indexes:
            current_elite_cycle.append(current_cycles[ind])

        if self.elite_cycles:
            elite_cycles_0 = 1e-8 if self.elite_cycles[0] == 0 else self.elite_cycles[0]
            cycle_diff = abs((self.elite_cycles[0] - current_elite_cycle[0]) / float(elite_cycles_0))
            if cycle_diff < self.task.common_args.get("same_elite_cycle_thr"):
                self.same_elite_cycle += 1
            else:
                self.same_elite_cycle = 0
        else:
            self.same_elite_cycle = 0
        LOG_INSTANCE.debug("same elite cycle: %d", self.same_elite_cycle)
        if self.same_elite_cycle >= self.task.common_args.get("max_same_elite_cycle"):
            return True
        return False

    def update(self) -> bool:
        """
        Update individuals of the tiling according to corresponding results

        Parameters
        ----------
        results: Corresponding results of last iteration
        """
        # check condition
        self.check_condition()
        # reserve elite Sort current_cycles from small to large, and reserve the least cycle elite_num individuals
        current_genes = self.inputs + self.elites
        current_cycles = np.array(self.genes_cycles + self.elite_cycles)
        try:
            elite_indexes = np.argpartition(current_cycles, (self.elite_num - 1))[:self.elite_num]
        except ValueError:
            raise ValueError("The pop_size of GA_ARGS must be greater than 3!")
        finally:
            pass
        # check is is early stop
        if self.ga_end_tune_opf_switch and self.is_early_stop_same_elite(elite_indexes, current_cycles):
            return True
        # upodate elites and elite_cycles
        self.elites, self.elite_cycles = [], []
        for ind in elite_indexes:
            self.elites.append(current_genes[ind])
            self.elite_cycles.append(current_cycles[ind])
        # prepare the data for computing the crossover probability and mutation probability
        current_scores = current_cycles / np.max(current_cycles)
        # probability of each paternal individual that be selectd when the number is smaller,
        # the probability of being selected is higher
        scores = 1 - (current_scores / np.sum(current_scores))
        if self.probs_formula_type == 2:
            scores = scores ** 2
        contrary_probs = scores
        probs = contrary_probs / np.sum(contrary_probs)
        min_score = np.min(current_scores)
        avg_score = np.sum(current_scores) / len(current_scores)

        # crossover point is selected by same probability, which is set by considering the constraints of parameters
        crossover_point_location = self.feature_config.cross_point_locations
        point_probs = []
        for idx, _ in enumerate(self.dims):
            if idx in crossover_point_location:
                point_probs.append(1.0 / len(crossover_point_location))
            else:
                point_probs.append(0)

        scores_probs = [current_scores, min_score, avg_score, probs, point_probs]
        self.ga_loop(current_genes, scores_probs)
        return False

    def initial_by_random(self) -> None:
        """
        Initialization of the first generation population

        Parameters
        ----------

        Returns
        -------
        """
        # get the old best tiling from record file
        surprise_flag, old_best_individual = self.initial_by_record()
        len_old_best_individual = len(old_best_individual) if surprise_flag else 0
        # select the pop_size individuals ramdomly
        if len(self.feasibility) < self.pop_size:
            self.pop_size = len(self.feasibility) + len_old_best_individual
            LOG_INSTANCE.debug("The account of feasibility is insufficient, then pop_size is: %s.", self.pop_size)
        # check pop_size and trial_num
        if self.pop_size > self.n_trial + len_old_best_individual:
            raise ValueError("The value of pop_size can't exceed trial_num.")
        secrets_generator = secrets.SystemRandom()
        if surprise_flag:
            sample_num = self.pop_size - len_old_best_individual
            init_population = secrets_generator.sample(self.feasibility, sample_num)
            for tiling_record in old_best_individual:
                if tiling_record not in self.feasibility:
                    LOG_INSTANCE.warning("Seed tiling is not in config space!")
                    continue
                init_population = [tiling_record] + init_population
        else:
            sample_num = self.pop_size
            init_population = secrets_generator.sample(self.feasibility, sample_num)
        if self.task.common_args.get('training_data_flag', False):
            div = len(self.feasibility) // self.n_trial
            init_population = self.feasibility[0::div]
            self.pop_size = len(init_population)
            self.n_trial = len(init_population)
        # Delete these individuals from available space
        self.feasibility = set(self.feasibility).difference(set(init_population))
        self.tiling_inputs = init_population

        self.performance_evaluate(init_population)

    def get_best_individual_from_file(self) -> tuple:
        """
        get best individual from record file
        """
        best_tiling_record = os.path.realpath(self.task.common_args.get("old_repository_filename"))
        surprise_flag = False
        best_individual = None
        # if the file exist, the read the old tiling from old repository file
        if os.path.exists(best_tiling_record):
            with open(best_tiling_record, "r") as json_f:
                line = json_f.readlines()
            # find whether the case is in the record
            for line_str in line:
                # check the format of config_file
                try:
                    line_dict = json.loads(line_str)
                except ValueError:
                    raise TypeError("The format of old repository file isn't json.")
                finally:
                    pass
                shape_info = line_dict.get("shape", None)
                if shape_info == self.task.param:
                    tiling_info = line_dict.get("tiling", [])
                    best_individual = self.task.entity2point(tiling_info)
                    surprise_flag = True
                    break
        return surprise_flag, best_individual

    def initial_by_record(self) -> tuple:
        """
        Initialize a best tiling from the record file

        Parameters
        ----------

        Returns
        -------
        best_individual: num
        The index of best tiling from the record
        surprise_flag: True or False
        Is there a record of best tiling in the record file
        """
        surprise_flag = False
        best_individual_list = []
        # get the old best tiling from record file
        if self.task.common_args.get("old_repository_filename", ""):
            surprise_flag, best_individual = self.get_best_individual_from_file()
            if surprise_flag:
                best_individual_list.append(best_individual)
        # if the seed_list exist, then get the auto_tiling/cce_tiling seed
        seed_list = self.task.common_args.get('auto_tiling_list', [])
        for seed_tiling in seed_list:
            best_individual = self.task.entity2point(seed_tiling)
            best_individual_list.append(best_individual)
            surprise_flag = True

        return surprise_flag, best_individual_list


    def get_new_genes(self, point1: list, point2: list, point: int, point_probs: int) -> tuple:
        """
        get new genes
        """
        # get two progeny individuals
        new_gene_1 = point1[:point] + point2[point:]
        new_gene_2 = point2[:point] + point1[point:]
        # if the cross point is between ka and kb, the kb is setted to ka, ma is setted to mc
        if point == self.feature_config.BL0_pbuffer_location:
            # limit kb equal to ka, and ma equal to mc
            # kb support full load, when kb==[] or the op is sparse structure, cancel the limit of kb equal to ka
            self.update_gene_loc_value_by_limit(
                new_gene_1, self.feature_config.kb_location, self.feature_config.ka_location, check_flag = True)
            self.update_gene_loc_value_by_limit(
                new_gene_1, self.feature_config.mc_location, self.feature_config.ma_location)
            self.update_gene_loc_value_by_limit(
                new_gene_2, self.feature_config.kb_location, self.feature_config.ka_location, check_flag = True)
            self.update_gene_loc_value_by_limit(
                new_gene_2, self.feature_config.mc_location, self.feature_config.ma_location)
        # if the cross point is between nb and nc, the ma is setted to mc, nb is setted to nc
        if point == self.feature_config.CL0_pbuffer_location:
            # limit ma equal to mc, and nb equal to nc
            self.update_gene_loc_value_by_limit(
                new_gene_1, self.feature_config.mc_location, self.feature_config.ma_location)
            self.update_gene_loc_value_by_limit(
                new_gene_1, self.feature_config.nc_location, self.feature_config.nb_location)
            self.update_gene_loc_value_by_limit(
                new_gene_2, self.feature_config.mc_location, self.feature_config.ma_location)
            self.update_gene_loc_value_by_limit(
                new_gene_2, self.feature_config.nc_location, self.feature_config.nb_location)

        if self.feature_config.is_type_v300 and \
            point in [self.feature_config.AUB_pbuffer_location,
                      self.feature_config.BUB_pbuffer_location,
                      self.feature_config.L0C_OUTPUT_pbuffer_location]:
            # CUB_matrix must be equal to CL0_matrix in no ub fusion cases
            self.update_gene_loc_value_by_limit(
                new_gene_1, self.feature_config.nc_location, self.feature_config.nc_factor_location)
            self.update_gene_loc_value_by_limit(
                new_gene_1, self.feature_config.mc_location, self.feature_config.mc_factor_location)
            self.update_gene_loc_value_by_limit(
                new_gene_1, self.feature_config.batchc_location, self.feature_config.batch_L0C_OUTPUT_location)
            self.update_gene_loc_value_by_limit(
                new_gene_1, self.feature_config.groupc_location, self.feature_config.group_L0C_OUTPUT_location)

            self.update_gene_loc_value_by_limit(
                new_gene_2, self.feature_config.nc_location, self.feature_config.nc_factor_location)
            self.update_gene_loc_value_by_limit(
                new_gene_2, self.feature_config.mc_location, self.feature_config.mc_factor_location)
            self.update_gene_loc_value_by_limit(
                new_gene_2, self.feature_config.batchc_location, self.feature_config.batch_L0C_OUTPUT_location)
            self.update_gene_loc_value_by_limit(
                new_gene_2, self.feature_config.groupc_location, self.feature_config.group_L0C_OUTPUT_location)

        # judge whether the new individual is in the feasibility
        gene_point_1 = self.task.entity2point(new_gene_1)
        gene_point_2 = self.task.entity2point(new_gene_2)

        new_gene = new_gene_1
        if gene_point_1 not in self.feasibility:
            if gene_point_2 not in self.feasibility:
                # if two progeny individuals are not valid, Re-select the crossover point
                point = int(np.random.choice(len(self.dims), size=1, p=point_probs))
                return new_gene, point, True
            new_gene = new_gene_2
        return new_gene, point, False

    def get_probility_crossover_mutate(self, genes: list, scores_probs: list) -> tuple:
        """
        Crossover the chromosome
        According to probility of crossover, crossover the chromosome

        Parameters
        ----------
        genes: Chromosomes of the previous generation
        probs: Probability of each paternal individual that be selectd
        Returns
        -------
        _pc:  probility of crossover
        _pm:  probility of mutate
        """
        scores, min_score, avg_score = scores_probs[0], scores_probs[1], scores_probs[2]
        probs = scores_probs[3]
        index1, index2 = np.random.choice(np.arange(len(genes)), size=2, replace=False, p=probs)

        single_score = (scores[index1] + scores[index2]) / 2
        _k1 = self.crossover_rate_pc1
        _k2 = self.crossover_rate_pc2
        _k3 = self.mutation_rate_pm1
        _k4 = self.mutation_rate_pm2

        _pc = _k2
        _pm = _k4
        if single_score <= avg_score:
            if min_score == avg_score:
                _pc = _k2 - ((_k2 - _k1)*(single_score - avg_score) / ((min_score - avg_score) + 1e-8))
                _pm = _k4 - ((_k4 - _k3)*(single_score - avg_score) / ((min_score - avg_score) + 1e-8))
            else:
                _pc = _k2 - ((_k2 - _k1)*(single_score - avg_score) / (min_score - avg_score))
                _pm = _k4 - ((_k4 - _k3)*(single_score - avg_score) / (min_score - avg_score))
        return _pc, _pm, [index1, index2]

    def crossover_gene(self, genes: list, scores_probs: list, _pc: float, indexes: list) -> tuple:
        """
        Crossover the chromosome
        According to probility of crossover, crossover the chromosome

        Parameters
        ----------
        genes: Chromosomes of the previous generation
        probs: Probability of each paternal individual that be selectd
        _pm:  probility of crossover
        Returns
        -------
        new_gene:  one chromosome that is crossovered
        """
        # according to the score of individual, choice the paternal individual
        scores = scores_probs[0]
        point_probs = scores_probs[4]
        _p1, _p2 = genes[indexes[0]], genes[indexes[1]]
        # according to uniform distribution probability, select the location of crossover points
        point = int(np.random.choice(len(self.dims), size=1, p=point_probs))


        right_person_flag = False
        while not right_person_flag:
            if random.random() < _pc:
                new_gene, point, continue_flag = self.get_new_genes(_p1, _p2, point, point_probs)
                if continue_flag:
                    continue
            else:
                new_gene = _p1 if (scores[indexes[0]] < scores[indexes[1]]) else _p2
            right_person_flag = True

        return new_gene

    def mutate_gene(self, gene_crossover: list, _pm: float) -> tuple:
        """
        Mutate the chromosome
        Traverse the every gene of chromosome, then according to probility of mutation,
        mutate the every gene of chromosome

        Parameters
        ----------
        gene_crossover: one chromosome that is crossovered, the type of gene_crossover is entity of tiling
        _pm: probility of mutation

        Returns
        -------
        new_gene: one chromosome that is mutated
        """
        # define the new chromosome that is mutated
        new_gene = copy.deepcopy(gene_crossover)
        gene_point = None
        # mutable point is selected by same probility,  but some locations are not involved in mutation
        # Mainly consider the configuration of the flag fixed to True
        unmutable_point_location = self.feature_config.unmutable_point_locations

        # if loop over the max_loop, break the loop the max_loop is setted based on the experience value
        max_loop = min(int(len(self.feasibility)), 200)
        loop_cnt = 0
        right_person_flag = False
        feasibility_list = list(self.feasibility)
        while not right_person_flag:
            # Traverse the every gene of chromosome, finish mutation of every gene
            for i in range(len(new_gene)):
                # some loacation of chromosome are not involved in mutation
                if i not in unmutable_point_location and random.random() < _pm:
                    new_gene = self.mutating_no_disturbing(new_gene, i)

            # if the loop over the max_loop, break the loop
            loop_cnt += 1
            if loop_cnt > max_loop:
                LOG_INSTANCE.info("The number of mutations has exceeded MAX_LOOP, " \
                    "and then tiling is randomly selected from the tiling space.")
                # if the size of feasibility is 0, break the process
                if len(self.feasibility) == 0:
                    return self.task.entity2point(new_gene)
                # Time of mutate is over the max_loop, one tiling is randomly selected from the tiling space
                gene_point = random.choice(feasibility_list)
                new_gene = self.task.point2entity(gene_point)
                right_person_flag = True
            else:
                # judge whether the new individual is in the feasibility
                gene_point = self.task.entity2point(new_gene)
                if gene_point in self.feasibility:
                    right_person_flag = True

        return gene_point

    def mutating_no_disturbing(self, gene: list, location: int) -> list:
        """
        Accroding the selected location of gene of chromosome,
        mutate the chromosome

        Parameters
        ----------
        gene: one chromosome for mutation, the type of gene is entity of tiling
        location: location of gene of chromosome for mutation

        Returns
        -------
        new_gene: one chromosome that is mutated
        """
        # get the config_spaec of the gene that is in the specified location
        candidate_option = list(self.config_space.values())[location]
        # get the index of gene in configuration space
        new_gene = copy.deepcopy(gene)
        old_option = new_gene[location]
        # get the length of config space of the gene
        index_max = len(candidate_option)
        if index_max == 1:
            # no candidate for mutating, don't mutate
            return new_gene

        # generate the all chromosome by using the new candidate of the gene
        candidate_gene = []
        for option in candidate_option:
            # old chromosome don't be used as candidate for mutate
            if option == old_option:
                continue
            # generate the new chromosome by using the new_index
            temp_gene_entity = copy.deepcopy(new_gene)
            temp_gene_entity[location] = option

            # constrain the gene of one chromosome
            new_gene_entity = self.constrain_gene(temp_gene_entity, location)
            new_gene_point = self.task.entity2point(new_gene_entity)

            if new_gene_point in self.feasibility:
                candidate_gene.append(new_gene_entity)
        # if no candidate is valid, return the old chromosome
        if len(candidate_gene) == 0:
            return gene

        # random select the mutated chromosome from all candidate of chromosome
        new_gene_index = random.randint(0, (len(candidate_gene) - 1))
        new_gene_mutating = candidate_gene[new_gene_index]

        return new_gene_mutating

    def check_ma(self, location: int, entity_value: object, gene_entity: list) -> None:
        """
        if ma changes, check the mc

        Parameters
        ----------
        location: location of gene of chromosome for mutation
        entity_value: value of gene_entity in location
        gene_entity: one chromosome for mutation, the type of gene_entity is entity
        """
        if location == self.feature_config.ma_location:
            _ma = entity_value
            if _ma is not None:
                if _ma not in self.config_space.get("mc"):
                    raise ValueError("new mc[%s] don't in config_space: %s" % (_ma, self.config_space.get("mc")))
                gene_entity[self.feature_config.mc_location] = _ma

    def check_ka(self, location: int, entity_value: object, gene_entity: list) -> None:
        """
        if ka changes, check the kb

        Parameters
        ----------
        location: location of gene of chromosome for mutation
        entity_value: value of gene_entity in location
        gene_entity: one chromosome for mutation, the type of gene_entity is entity
        """
        if location == self.feature_config.ka_location:
            _kb = gene_entity[self.feature_config.kb_location]
            _ka = entity_value // self.kakb_constrain_coefficient
            if self.is_special_value(entity_value):
                _ka = entity_value
            if _kb != []:
                if _ka not in self.config_space.get("kb"):
                    raise ValueError("new kb[%s] don't in config_space: %s" % (_ka, self.config_space.get("kb")))
                gene_entity[self.feature_config.kb_location] = _ka

    def check_kb(self, location: int, entity_value: object, gene_entity: list) -> None:
        """
        if kb changes, check the ka

        Parameters
        ----------
        location: location of gene of chromosome for mutation
        entity_value: value of gene_entity in location
        gene_entity: one chromosome for mutation, the type of gene_entity is entity
        """
        if location == self.feature_config.kb_location:
            _ka = gene_entity[self.feature_config.ka_location]
            _kb = entity_value * self.kakb_constrain_coefficient
            # in 4to2_sparsity scenario, if ka kb both is 1, do nothing, otherwise, ka shoule be 2kb
            if self.is_special_value(_ka) and self.is_special_value(entity_value):
                _kb = entity_value
            if _kb != []:
                if _kb not in self.config_space.get("ka"):
                    raise ValueError("new ka[%s] don't in config_space: %s" % (_kb, self.config_space.get("ka")))
                gene_entity[self.feature_config.ka_location] = _kb

    def check_nb(self, location: int, entity_value: object, gene_entity: list) -> None:
        """
        if nb changes, check the nc

        Parameters
        ----------
        location: location of gene of chromosome for mutation
        entity_value: value of gene_entity in location
        gene_entity: one chromosome for mutation, the type of gene_entity is entity
        """
        if location == self.feature_config.nb_location:
            _nb = entity_value
            if _nb not in self.config_space.get("nc"):
                raise ValueError("new nc[%s] don't in config_space: %s" % (_nb, self.config_space.get("nc")))
            gene_entity[self.feature_config.nc_location] = _nb

    def check_mc(self, location: int, entity_value: object, gene_entity: list) -> None:
        """
        if mc changes, check the ma

        Parameters
        ----------
        location: location of gene of chromosome for mutation
        entity_value: value of gene_entity in location
        gene_entity: one chromosome for mutation, the type of gene_entity is entity
        """
        if location == self.feature_config.mc_location:
            _mc = entity_value
            _ma = gene_entity[self.feature_config.ma_location]
            if _ma is not None:
                if _mc not in self.config_space.get("ma"):
                    raise ValueError("new ma[%s] don't in config_space: %s" % (_mc, self.config_space.get("ma")))
                gene_entity[self.feature_config.ma_location] = _mc

    def check_nc(self, location: int, entity_value: object, gene_entity: list) -> None:
        """
        if nc changes, check the nb

        Parameters
        ----------
        location: location of gene of chromosome for mutation
        entity_value: value of gene_entity in location
        gene_entity: one chromosome for mutation, the type of gene_entity is entity
        """
        if location == self.feature_config.nc_location:
            _nc = entity_value
            if _nc not in self.config_space.get("nb"):
                raise ValueError("new nb[%s] don't in config_space: %s" % (_nc, self.config_space.get("nb")))
            gene_entity[self.feature_config.nb_location] = _nc

    def constrain_gene(self, gene_entity: list, location: int) -> list:
        """
        Accroding the selected location of gene of chromosome,
        constrain the other gene of chromosome.
        Increase success rate for mutation

        Parameters
        ----------
        gene_entity: one chromosome for mutation, the type of gene_entity is entity
        location: location of gene of chromosome for mutation

        Returns
        -------
        new_gene_entity: one chromosome that is constrained,the type of new_gene_entity is entity
        """
        entity_value = gene_entity[location]
        self.check_ma(location, entity_value, gene_entity)
        self.check_ka(location, entity_value, gene_entity)
        self.check_kb(location, entity_value, gene_entity)
        self.check_nb(location, entity_value, gene_entity)
        self.check_mc(location, entity_value, gene_entity)
        self.check_nc(location, entity_value, gene_entity)

        new_gene_entity = copy.deepcopy(gene_entity)

        return new_gene_entity
