#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2021. Huawei Technologies Co., Ltd. All rights reserved.

Define utils for generate repository
"""

import struct

from typing import Any
from typing import List
from typing import BinaryIO


MAX_VALUE_8_BIT = 255
MAX_VALUE_16_BIT = 65535
MAX_VALUE_32_BIT = 4294967295
BIT_LEN_128 = 128
BIT_LEN_64 = 64
BIT_LEN_32 = 32
BIT_LEN_16 = 16
BIT_LEN_12 = 12
BIT_LEN_8 = 8
BIT_LEN_4 = 4
BIT_LEN_2 = 2
BIT_TO_BYTE = 8
ZERO = 0
ONE = 1
TWO = 2
THREE = 3
# define the type of L1 fusion
DEFAULT_VALUE = -1
L1_NO_FUSION = 2
L2_MEMORY_TYPE = 2
OP_TAG_ENCODE = {
    "conv2d": 0, "convolution": 0, "conv2d_backprop_input": 1, "conv2d_backprop_filter": 2,
    "depthwise_conv2d_forward": 3, "depthwise_bp_input": 4, "depthwise_bp_filter": 5,
    "depthwise_conv2d_native_v200": 6, "matmul": 7, "convolution_3d": 8, "conv3d_backprop_input": 9,
    "conv3d_backprop_filter": 10
}
DTYPE_ENCODE = {
    "uint8": 0,
    "int8": 1,
    "float16": 2,
    "int32": 3,
    "float32": 4,
    "int16": 5,
    "int4": 6,
    "bfloat16": 7
}
# Define the occupied memory of input data type
INPUT_DATA_BYTE_WIDTH = {
    'uint8': 1,
    'int8': 1,
    'float16': 2,
    'int4': 0.5,
    'float32': 4,
    'bfloat16': 2
}
SHAPE_TYPE_LIST = {
    "int4": 64,
    "int8": 32,
    "float16": 16
}


def is_conv3d_op_tag(op_tag: str) -> bool:
    """
    Check if Conv3D type
    """
    return op_tag in OP_TAG_ENCODE and \
           (OP_TAG_ENCODE.get(op_tag) >= OP_TAG_ENCODE.get('convolution_3d')) and \
           (OP_TAG_ENCODE.get(op_tag) <= OP_TAG_ENCODE.get('conv3d_backprop_filter'))


def generate_to_bin(all_bin: list, bin_handle: BinaryIO) -> None:
    """
    write binary to file
    all_bin: list of all binary data
    bin_handle: binary file handle
    """
    for elem in all_bin:
        bin_handle.write(elem)


def num_2_bin(all_bin: list, data: Any, bit_len: int) -> list:
    """
    transfor number to binary
    all_bin: list of all binary data
    data: source number data
    bit_len: bit length of data
    return: binary of data
    """
    def truncate_number(source_data: int, range_bit_len: int) -> int:
        """
        according to the support range, truncate number
        range_data: source number data
        range_bit_len: bit length of data
        return: binary of data
        """
        process_data = source_data
        if source_data > (2 ** range_bit_len - 1):
            process_data = 2 ** range_bit_len - 1
        return process_data

    # process some specifical value
    if data == []:
        data = ((ONE << BIT_LEN_32) - ONE)
    elif data is None:
        data = ZERO
    elif data is False:
        data = ZERO
    elif data is True:
        data = ONE

    des_data = truncate_number(data, bit_len) # the value out of range, it will be truncated
    if bit_len == BIT_LEN_64:
        elem = struct.pack("Q", des_data) # to unsigned long long
        all_bin.append(elem)
    elif bit_len == BIT_LEN_32:
        elem = struct.pack("I", des_data) # to unsigned int
        all_bin.append(elem)
    elif bit_len == BIT_LEN_16:
        elem = struct.pack("H", des_data) # to unsigned short
        all_bin.append(elem)
    elif bit_len == BIT_LEN_8:
        elem = struct.pack("B", des_data) # to 1 byte
        all_bin.append(elem)
    elif bit_len < BIT_LEN_8:
        data = data * (BIT_LEN_2 ** (BIT_LEN_8 - bit_len))
        elem = struct.pack("B", des_data) # to 1 byte
        all_bin.append(elem)
    else:
        raise ValueError("not support value encode for %s" % str(bit_len))

    return all_bin


def str_2_bin(all_bin: list, data: str, bit_len: int) -> list:
    """
    transfor string to binary
    all_bin: list of all binary data
    data: source string data
    bit_len: bit length of data
    return: list of binary data
    """
    if data in DTYPE_ENCODE.keys():
        elem = struct.pack("B", DTYPE_ENCODE.get(data))
        all_bin.append(elem)
        return all_bin

    if data in OP_TAG_ENCODE.keys():
        elem = struct.pack("B", OP_TAG_ENCODE.get(data))
        all_bin.append(elem)
        return all_bin

    byte_len = int(bit_len / BIT_TO_BYTE)
    for char in data: # change 1 char to 1 byte
        elem = struct.pack("s", char.encode('utf-8'))
        all_bin.append(elem)

    i = byte_len - len(data)
    while i > 0: # supplement 0
        elem = struct.pack("B", ZERO)
        all_bin.append(elem)
        i = i - 1
    return all_bin


def num_get_bin(num: int) -> List[str]:
    """
    transfor number to string binary
    num: source number data
    return: string binary data of num
    """
    tmp = []
    num = struct.pack("I", num)
    arr = bytearray(num)
    for elem in arr:
        tmp.append(hex(elem))
    return tmp


def str_get_bin(src: str, bit_len: int) -> List[str]:
    """
    transfor string to string binary
    src: source string data
    bit_len: bit length of src
    return: string binary data of src
    """
    tmp = []
    byte_len = int(bit_len / BIT_TO_BYTE)
    for char in src:
        tmp.append(hex(ord(char))) # get bin of char

    i = byte_len - len(tmp)
    while i > 0:
        tmp.append(hex(ZERO)) # supplement 0
        i = i - 1
    return tmp


def get_check_sum(table_head: list, check_sum_len_bit: int) -> int:
    """
    get checksum value
    table_head: all tablehead info
    check_sum_len_bit: bit length of checksum

    return: checksum value
    """
    bin_list = []
    for i in range(int(len(table_head) / THREE)):
        if table_head[i] == "num":
            bin_list.extend(num_get_bin(table_head[i + int(len(table_head) / THREE)]))
        if table_head[i] == "str":
            bin_list.extend(str_get_bin(table_head[i + int(len(table_head) / THREE)],
                            table_head[i + int(len(table_head) / THREE) * BIT_LEN_2]))
    data_sum = 0
    high_bits = 0
    for i, element in enumerate(bin_list):
        if i % TWO == ZERO:
            # hex to dec
            data_sum = data_sum + int(element, BIT_LEN_16) * (BIT_LEN_2 ** int(check_sum_len_bit / BIT_LEN_4))
        else:
            # hex to dec
            data_sum = data_sum + int(element, BIT_LEN_16)
        while data_sum >= BIT_LEN_2 ** int(check_sum_len_bit / BIT_LEN_2) or high_bits != ZERO:
            high_bits = int(data_sum / (BIT_LEN_2 ** int(check_sum_len_bit / BIT_LEN_2)))
            data_sum = int(data_sum % (BIT_LEN_2 ** int(check_sum_len_bit / BIT_LEN_2))) + high_bits
    check_sum = BIT_LEN_2 ** check_sum_len_bit - ONE - data_sum
    return check_sum


def check_tiling(tiling: list) -> list:
    """
    check dimension 5, 17, 32 in source tiling
    tiling: source tiling of a case
    return: new tiling
    """
    # check dimension 5 in tiling
    if tiling[5] == []:
        tiling[5] = MAX_VALUE_32_BIT
    if tiling[5] is None:
        tiling[5] = ZERO
    # check dimension 17 in tiling
    if tiling[17] == []:
        tiling[17] = MAX_VALUE_32_BIT
    if tiling[17] is None:
        tiling[17] = ZERO
    # check dimension 32 in tiling
    if tiling[32] == []:
        tiling[32] = MAX_VALUE_16_BIT
    if tiling[32] is None:
        tiling[32] = ZERO
    return tiling


def shape_decide_matrix(shape_type: str) -> int:
    """
    get shape decide matrix by shape type
    :param shape_type: data type
    :return:
    """
    return SHAPE_TYPE_LIST.get(shape_type) if SHAPE_TYPE_LIST.get(shape_type) else 16


def is_new_tiling(shape: dict) -> bool:
    """
    b_dtype or B_dtype
    """
    return ((shape.get('l1_fusion_type', -1) != -1 and shape.get('op_type') != "depthwise_conv2d_forward") \
        or shape.get('in_fm_memory_type', [0])[0] == 2 or shape.get('out_fm_memory_type', [0])[0] == 2 \
        or shape.get('op_type') in ("conv2d", "convolution") or is_conv3d_op_tag(shape.get('op_type'))) \
        and shape.get('op_type') != "conv2d_backprop_input"


def get_al0_bl0_matrix(shape: dict) -> tuple:
    """
    get al0 bl0 matrix from shape
    """
    if is_new_tiling(shape):
        al0_matrix3 = shape_decide_matrix(shape.get("b_dtype"))
        bl0_matrix3 = shape_decide_matrix(shape.get("b_dtype"))
    else:
        al0_matrix3 = shape_decide_matrix(shape.get("B_dtype"))
        bl0_matrix3 = shape_decide_matrix(shape.get("B_dtype"))
    return al0_matrix3, bl0_matrix3
