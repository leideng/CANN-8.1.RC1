#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

TelnetClient Class. Here TelnetClient Class is the client for telenet.
"""
import telnetlib
import fcntl
import os
import json

from auto_tune.util_atc import FILE_FLAG
from auto_tune.util_atc import FILE_MODE_640
from auto_tune.auto_tune_log import LOG_INSTANCE

AUTO_TUNE_PATH = os.path.dirname(os.path.realpath(__file__))
CONNECT_TIME = 20
JUDGE_TIME = 5


class TelnetJudge():
    """
    Class for into auto tune Prejudgement condition
    """
    count = 0

    def __init__(self) -> None:
        """
        init telnet connection
        """
        self.info = {}
        self.es_info()
        self.temp_path = os.path.join(os.getcwd(), '.temp_connect.log')
        if not os.path.isfile(self.temp_path):
            with os.fdopen(os.open(self.temp_path, FILE_FLAG, FILE_MODE_640), 'w') as self.connect_file:
                fcntl.flock(self.connect_file.fileno(), fcntl.LOCK_EX)
                self.tel = telnetlib.Telnet()
                self.init_check_env()
                fcntl.flock(self.connect_file.fileno(), fcntl.LOCK_UN)
        else:
            try:
                self.check_err()
            except json.decoder.JSONDecodeError:
                LOG_INSTANCE.debug("config is correctly")
            finally:
                pass

    def check_err(self) -> None:
        """
        check if connect file has errcode
        """
        with open(self.temp_path, "r+") as connect_file:
            fcntl.flock(connect_file.fileno(), fcntl.LOCK_EX)
            dict_args = json.load(connect_file)
            if 'errCode' in dict_args.keys():
                raise RuntimeError(dict_args)
            fcntl.flock(connect_file.fileno(), fcntl.LOCK_UN)

    def init_check_env(self) -> None:
        """
        Check the lhisi environment is configured correctly
        :return: if not, raise Error
        """
        self.connect()
        self.judge_folder()
        self.exist_file()
        json_str = json.dumps({self.info.get("es_ip", None): "connected success"})
        self.connect_file.write(json_str)
        LOG_INSTANCE.info("%s connected success", self.info.get("es_ip"))
        self.close()

    def es_info(self) -> None:
        """
        get the es info from config.json
        :return: es info
        """
        config_file = os.path.join(AUTO_TUNE_PATH, "estimate", "python", "config.json")
        with open(config_file, "r") as file_handle:
            op_param_info = json.load(file_handle)
        self.info = op_param_info.get('es_conf')

    def raise_error(self, dict_args: dict) -> None:
        """
        raise error
        """
        json_str = json.dumps(dict_args)
        self.connect_file.write(json_str)
        raise RuntimeError(dict_args)


    def connect(self) -> None:
        """
        connect to lhisi, if not ,raise error
        :return:
        """
        try:
            self.tel.open(self.info.get("es_ip", None), self.info.get("es_port", None), timeout=CONNECT_TIME)
        except TimeoutError as e:
            self.close()
            LOG_INSTANCE.error("lhisi connected failed: %s" % e)
            self.raise_error({"errCode": 'EC0000', "ip": self.info.get("es_ip"), "port": self.info.get("es_port")})
        finally:
            pass

        self.tel.read_until(b'login: ', JUDGE_TIME)
        self.tel.write(self.info.get("es_user").encode('ascii') + b"\n")
        self.tel.read_until(b'Password: ', JUDGE_TIME)
        self.tel.write(self.info.get("es_password").encode('ascii') + b"\n")
        result = self.tel.read_until(b'# ', JUDGE_TIME)
        if b"Login incorrect" in result:
            self.close()
            self.raise_error({"errCode": "EC0001", "username": self.info.get("es_user")})

    def close(self) -> None:
        """
        close telnet
        """
        self.tel.close()

    def judge_folder(self) -> None:
        """
        judge folder whether or not exits, if not raise error
        :return:
        """
        tss_path = os.path.join(self.info.get('nfs_share_dir'), 'tss')
        command = "%s %s " % ("cd", tss_path)
        self.tel.write(b"\n")
        self.tel.write(command.encode('ascii') + b"\n")
        command_result = self.tel.read_until("#".encode('ascii'), JUDGE_TIME)
        command_result1 = self.tel.read_until("#".encode('ascii'), JUDGE_TIME)
        if (b"No such file or directory" in command_result) or (b"No such file or directory" in command_result1):
            self.close()
            self.raise_error({"errCode": "EC0002", "mount_path": tss_path})

        if (b"Permission denied" in command_result) or (b"Permission denied" in command_result1):
            self.close()
            self.raise_error({"errCode": "EC0004", "mount_path": self.info.get("host_share_dir", os.getcwd())})

    def exist_file(self) -> None:
        """
        judge file whether or not exits, if not raise error
        :return:
        """
        file_path = os.path.join(self.info.get("host_share_dir", os.getcwd()), "tss", "bin", "kernel_perf_comm")
        try:
            with open(file_path, "r"):
                pass
        except FileNotFoundError:
            self.close()
            self.raise_error({"errCode": "EC0003", "mount_path": self.info.get("host_share_dir", os.getcwd())})
        except PermissionError:
            self.close()
            self.raise_error({"errCode": "EC0004", "mount_path": self.info.get("host_share_dir", os.getcwd())})
        finally:
            pass
