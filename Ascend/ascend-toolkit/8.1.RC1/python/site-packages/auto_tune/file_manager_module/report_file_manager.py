#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2022. Huawei Technologies Co., Ltd. All rights reserved.

Define ReportFileManager Classes
"""
import json

from auto_tune.auto_tune_lock import LocalLock
from auto_tune.auto_tune_log import LOG_INSTANCE
from auto_tune.util_atc import get_dict_from_json_file
from auto_tune.common_module.common_util import TuneOpParam
from auto_tune.common_module.common_util import TuneResReport


DECIMAL_NUM = 3


class TuneResultReport:
    """
    TuneResultReport class to manager reporting tune resault
    """
    def __init__(self, input_args: dict, tune_op_params: TuneOpParam):
        """
        report tune result after tune
        Parameters
        ----------
        tune_result_file: (str) tune result file name
        already_in_repo: True means the tiling is already in repo
        """
        # init res data and bank status
        self.tune_success = False
        self.res_data = {}
        self.bank_status = {}
        # init op name op type
        self.build_op_name = ""
        self.tune_mode = ""
        self.ori_op_name = ""
        self.op_type = ""
        if input_args.get("topi_args", None):
            self.ori_op_name = input_args.get("topi_args").get("ori_op_name", "")
            self.op_type = input_args.get('topi_args').get("real_op_type", "")

        # init tune mode: True--optune False--autotune
        self.optune = False
        self.tune_report_info_q = None
        self.tune_result_file = None
        self.job_id = None
        if tune_op_params.option:
            self.optune = True
            self.tune_report_info_q = tune_op_params.option.get("global_mgr").get("tune_report_info_q")
            self.job_id = tune_op_params.option.get("job_id")
        else:
            self.tune_result_file = tune_op_params.tune_result_file
        self.already_in_repo = tune_op_params.already_in_repo
        self.gen_tune_status({}, tune_op_params.already_in_repo)

    def gen_tune_result_status(self, tune_res_report: TuneResReport, build_op_name: str = "") -> None:
        """
        gen_tune_result_status after tune
        Parameters
        ----------
        tune_res_report:
            before: (int) before tune tick
            after: (tuple) best_measure_pair in tune process
        """
        self.tune_success = True # call gen_tune_result_status means tuning success
        before = tune_res_report.before_cost
        after = tune_res_report.after_cost
        update_flag = tune_res_report.update_flag
        exist_repository = tune_res_report.exist_repository
        self.build_op_name = build_op_name if build_op_name else ""
        # update tune_result
        if update_flag:
            before = after + 1 if before <= after else before
        else:
            after = after if before <= after else before + 1
        self.gen_tune_result(before, after)

        if exist_repository:
            tmp_status = {"update": update_flag, "append": False,
                          "reserved": not update_flag, "unsatisfied": False}
        else:
            tmp_status = {"update": False, "append": update_flag, "reserved": False, "unsatisfied": not update_flag}
        self.gen_tune_status(tmp_status, exist_repository)

    def generate_proc_data(self, tune_success: bool, tune_mode: str = "") -> None:
        """
        Generate tune process data files
        Parameters
        ----------
        best_ticks: best ticks of each round in GA tune
        res_data: op cost_time before and after GA tune
        tune_result_file: absolute path of tune_result_file
        Returns: None
        -------
        """
        if not self.ori_op_name:
            LOG_INSTANCE.error("Process data fails to be generated because no fusion_op_name is available.")
            return
        self.tune_success = tune_success
        self.tune_mode = tune_mode
        if self.optune:
            self.report_tune_res_to_opat()
        else:
            self.report_tune_res_to_file()

    def report_tune_res_to_file(self) -> None:
        """
        report tune result to file
        """
        if not self.tune_result_file:
            return
        local_lock = LocalLock(self.tune_result_file)
        local_lock.lock()
        with open(self.tune_result_file, 'r+') as f_handle:
            tune_result = get_dict_from_json_file(f_handle)
            tune_result.setdefault(self.ori_op_name, {})
            if self.res_data:
                tune_result.get(self.ori_op_name)['result_data'] = self.res_data
            if self.bank_status:
                tune_result.get(self.ori_op_name)['status_data'] = self.bank_status
            f_handle.seek(0)
            f_handle.truncate()
            json.dump(tune_result, f_handle, sort_keys=True, indent=4)
        local_lock.unlock()

    def report_tune_res_to_opat(self) -> None:
        """
        report tune result to opat
        """
        res_data = {}
        if self.bank_status.get("bank_update") or self.bank_status.get("bank_append") and self.res_data:
            before_tune = self.res_data.get("before_tune")
            after_tune = self.res_data.get("after_tune")
            res_data["performance_after_tune(us)"] = after_tune
            res_data["performance_before_tune(us)"] = before_tune
            if before_tune > 0:
                res_data["performance_improvement"] = "{:.2%}".format((before_tune - after_tune) / after_tune)
            res_data["update_mode"] = "update" if self.bank_status.get("bank_update") else "add"

        tmp_info = {"job_id": self.job_id,
                    "tune_mode": self.tune_mode,
                    "op_type": self.op_type,
                    "op_name": self.build_op_name,
                    "tune_op_succ": self.tune_success,
                    "status_data": self.bank_status,
                    "result_data": res_data
                    }
        if self.tune_report_info_q:
            self.tune_report_info_q.put(tmp_info)

    def report_tune_res_and_mode_to_opat(self, tune_success: bool, tune_mode: str) -> None:
        self.tune_success = tune_success
        self.tune_mode = tune_mode
        self.report_tune_res_to_opat()

    def gen_tune_result(self, before_res: int, after_res: int) -> None:
        """
        generate tune result and store in self.res_data
        Parameters
        ----------
        before_res: int
        after_res : int
        Returns
        -------
        None
        """
        res_data = {}
        res_data["before_tune"] = round(before_res, DECIMAL_NUM)
        res_data["after_tune"] = round(after_res, DECIMAL_NUM)
        self.res_data = res_data

    def gen_tune_status(self, tune_status: dict, exist_repository: bool) -> None:
        """
        generate tune status and store in self.status_data
        Parameters
        ----------
        bank_hit, bank_update, bank_append, bank_reserved: bool
        Returns
        -------
        None
        """
        status_data = {}
        status_data["bank_hit"] = exist_repository
        status_data["bank_update"] = tune_status.get('update', False)
        status_data["bank_append"] = tune_status.get('append', False)
        status_data["bank_reserved"] = tune_status.get('reserved', exist_repository)
        if self.optune:
            status_data["bank_unsatisfied"] = tune_status.get('unsatisfied', not exist_repository)
        self.bank_status = status_data
