#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

Define the interface for generate repository
"""

import os
import json
import stat
import warnings

from typing import TextIO
from typing import BinaryIO

from auto_tune.gen_repo_utils import L2_MEMORY_TYPE
from auto_tune.gen_repo_utils import MAX_VALUE_16_BIT
from auto_tune.gen_repo_utils import generate_to_bin
from auto_tune.gen_repo_utils import is_conv3d_op_tag
from auto_tune.gen_repo_to_bin import head_2_bin
from auto_tune.gen_repo_to_bin import l1_fusion_shape_2_bin
from auto_tune.gen_repo_to_bin import dx_l1_fusion_shape_2_bin
from auto_tune.gen_repo_to_bin import depthwise_l1_fusion_shape_2_bin
from auto_tune.gen_repo_to_bin import conv2d_shape_2_bin
from auto_tune.gen_repo_to_bin import conv3d_shape_2_bin
from auto_tune.gen_repo_to_bin import shape_2_bin
from auto_tune.gen_repo_to_bin import tiling_2_bin

FILE_FLAG = os.O_WRONLY | os.O_CREAT
FILE_MODE_640 = stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP


def get_bin_from_shape(shape: dict) -> list:
    """
    get bin from case shape
    param: shape in case
    return: bytes list
    """
    tmp_bin = []
    if shape.get('l1_fusion_type', -1) != -1 or L2_MEMORY_TYPE in shape.get('in_fm_memory_type', [0]) \
        or L2_MEMORY_TYPE in shape.get('out_fm_memory_type', [0]):
        if shape.get('op_type') in ('conv2d', 'convolution'):
            tmp_bin = l1_fusion_shape_2_bin(tmp_bin, shape)
        elif shape.get('op_type') == 'conv2d_backprop_input':
            tmp_bin = dx_l1_fusion_shape_2_bin(tmp_bin, shape)
        elif shape.get('op_type') == "depthwise_conv2d_forward":
            tmp_bin = depthwise_l1_fusion_shape_2_bin(tmp_bin, shape)
    else:
        if shape.get('op_type') in ("conv2d", "convolution"):
            # con2d operator using the new TBEConv2dTilingArgs
            tmp_bin = conv2d_shape_2_bin(tmp_bin, shape)
        elif is_conv3d_op_tag(shape.get("op_type")):
            tmp_bin = conv3d_shape_2_bin(tmp_bin, shape)
        elif shape.get('op_type') in ("conv2d_backprop_input", "conv2d_backprop_filter"):
            shape.get("A_shape")[2] = min(shape.get("A_shape")[2], MAX_VALUE_16_BIT)
            shape.get("B_shape")[2] = min(shape.get("B_shape")[2], MAX_VALUE_16_BIT)
            if shape.get("C_shape"):
                shape.get("C_shape")[2] = min(shape.get("C_shape")[2], MAX_VALUE_16_BIT)
            tmp_bin = shape_2_bin(tmp_bin, shape)
        else:
            tmp_bin = shape_2_bin(tmp_bin, shape)
    return tmp_bin


def get_bin_from_repository_case(case: dict) -> tuple:
    """
    get_bin_from_repository_case
    param: case item in json repository
    return: bytes list, shape length
    """
    shape = case.get("shape")
    tiling = case.get("tiling")
    tmp_bin = get_bin_from_shape(shape)
    shape_len = len(tmp_bin)
    tmp_bin = tiling_2_bin(tmp_bin, shape, tiling)
    return tmp_bin, shape_len


def get_case_num(json_handle: TextIO) -> int:
    """
    get case num in json file
    """
    json_handle.seek(0)
    case_num = 0
    for idx, line in enumerate(json_handle):
        try:
            _ = json.loads(line)
        except ValueError:
            print("Please check json file. err_line_idx = {}, err_line = {}".format(idx, line), flush=True)
            raise
        finally:
            pass
        case_num += 1
    return case_num


def generate_tiling_repository(json_handle: TextIO, bin_handle: BinaryIO) -> None:
    """
    generate bin file
    input_json_path: json file handle
    bin_file_path: bin file handle
    """
    bin_handle.seek(0)
    bin_handle.truncate()
    case_num = get_case_num(json_handle)
    all_bin = []
    all_bin = head_2_bin(all_bin, case_num)
    generate_to_bin(all_bin, bin_handle)
    json_handle.seek(0)
    shape_dict = {}
    valid_line_no = []
    found_duplicate = False
    for idx, line in enumerate(json_handle):
        try:
            case = json.loads(line)
            all_bin = []
            all_bin, shape_len = get_bin_from_repository_case(case)
            shape_bin = str(all_bin[:shape_len])
            if shape_bin not in shape_dict:
                shape_dict[shape_bin] = idx
                valid_line_no.append(idx)
            else:
                found_duplicate = True
                warnings.warn("found duplicate tiling in repo: {}, line[{}, {}]".format(
                    json_handle.name, shape_dict[shape_bin] + 1, idx + 1))
            generate_to_bin(all_bin, bin_handle)
        except ValueError:
            print("Please check json file. total_lines = {}, err_line_idx = {}, err_line = {}".format(
                  case_num, idx, line), flush=True)
            raise
        finally:
            pass

    if found_duplicate:
        raise RuntimeError("found duplicate tiling in repo: {}".format(json_handle.name))


def transfer_json_to_bin_by_handle(json_handle: TextIO, bin_handle: BinaryIO) -> None:
    """
    transfer json to bin function interface
    input_json_path: json file handle
    bin_file_path: bin file handle
    """
    generate_tiling_repository(json_handle, bin_handle)


def transfer_json_to_bin(input_json_path: str, bin_file_path: str) -> None:
    """
    transfer json to bin function interface
    input_json_path: json file path
    bin_file_path: bin file path
    """
    if not os.path.isfile(input_json_path):
        with os.fdopen(os.open(input_json_path, FILE_FLAG, FILE_MODE_640), 'w'):
            pass
    if not os.path.isfile(bin_file_path):
        with os.fdopen(os.open(bin_file_path, FILE_FLAG, FILE_MODE_640), 'w'):
            pass
    with open(input_json_path, 'r') as json_handle, open(bin_file_path, 'ab') as bin_handle:
        generate_tiling_repository(json_handle, bin_handle)
