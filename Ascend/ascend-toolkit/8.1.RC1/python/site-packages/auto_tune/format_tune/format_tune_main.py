#!/usr/bin/env python3
# -*- coding:utf-8 -*-
"""
Copyright (C) 2023. Huawei Technologies Co., Ltd. All rights reserved.

Define the tik tune function
"""

import json
import os
import time
import math
from typing import List
from collections import namedtuple

from tbe.common.utils.create_kb_query_key import get_op_compile_unique_key
from auto_tune.common_module.common_util import DEFAULT_OM_RUN_THRESHOLD
from auto_tune.common_module.common_util import COST_MAX_VALUE
from tbe.common.repository_manager.interface import cann_kb_write
from tbe.common.repository_manager.interface import cann_kb_search
from auto_tune.auto_tune_log import LOG_INSTANCE
from auto_tune.auto_tune_main import repeat_tune_flag
from auto_tune.get_input_args import check_load_json
from auto_tune.common_module.common_util import get_time_str
from auto_tune.common_module.common_util import TuneOpParam
from auto_tune.common_module.common_util import TuneResReport
from auto_tune.file_manager_module.report_file_manager import TuneResultReport

ExecuteParams = namedtuple("ExecuteParams", ["pid", "cb_key", "cb_result", "cb_release", "timer_queue"])

DEFAULT_TIMEOUT_BUILD_EXECUTE = 3000
ADJUST_COEFFICIENT = 20
TIME_SLEEP_CALLBACK = 1
MIN_OPTIMIZATION_THRESHOLD = 0.05
SECOND_OPTIMIZATION_THRESHOLD = 0.1
SPLIT_CHAR = ";"
COLON_CHAR = ":"


class FormatTune:
    """
    class for format op tuning
    """
    def __init__(self, op_args_json: dict, tune_option: dict) -> None:
        super(FormatTune, self).__init__()
        self.tune_option = tune_option
        self.job_id = tune_option.get("job_id", "")
        self.build_op_name = ""
        self.op_type = op_args_json["op_type"]
        self.inputs = op_args_json["op_params"].get("input_desc", [])
        self.outputs = op_args_json["op_params"].get("output_desc", [])
        # attr_desc's dtype is List(dict)
        self.attrs = op_args_json["op_params"].get("attr_desc", [])
        self.kernel_name = op_args_json["op_params"].get("kernel_name", "")
        self.extra_params = op_args_json["op_params"].get("extra_param", {})
        # parse format space
        self.default_format = FormatTune._parse_default_format(self.inputs, self.outputs)
        self.format_space = self._parse_format_space(tune_option.get("format_option", ""))
        self.info_dict = ""
        self.repo_format = {}
        self.tune_mode = "Format"
        self.baseline_cost = COST_MAX_VALUE
        self.cb_struct_key = tune_option.get("cb_struct_key", None)
        self.global_mgr = tune_option["global_mgr"]
        self.tune_report_info_q = self.global_mgr.get("tune_report_info_q", None)
        self.tune_success = False
        self.update_flag = False
        self.exist_repository = False
        self.tune_result_report = None
        self.default_time_bound = DEFAULT_TIMEOUT_BUILD_EXECUTE
        self.build_run_time_bound = self.default_time_bound
        LOG_INSTANCE.info("FormatTune for [op_type=%s, kernel_name=%s] init succ.", self.op_type, self.kernel_name)
        LOG_INSTANCE.info("FormatTune: parse format space is: %s.", str(self.format_space))
        LOG_INSTANCE.debug("Inputs:%s.", str(self.inputs))
        LOG_INSTANCE.debug("Outputs:%s.", str(self.outputs))
        LOG_INSTANCE.debug("Attrs:%s.", str(self.attrs))

    @staticmethod
    def _format_str2dict(format_str: str) -> dict:
        """
        parse format space
        Parameters
        ----------
        format_option: format strategy of string
        Returns
        -------
        format_dict: format strategy of dict
        """
        format_dict = {}
        if not format_str:
            return format_dict
        tensor_dsc_list = format_str.split(SPLIT_CHAR)
        for tensor_dsc in tensor_dsc_list:
            tensor_name, tensor_format = tensor_dsc.split(COLON_CHAR)
            format_dict[tensor_name] = tensor_format
        return format_dict

    @staticmethod
    def _format_dict2str(format_dict: dict) -> str:
        format_str = ""
        for key, value in format_dict.items():
            format_str += str(key) + COLON_CHAR + str(value) + SPLIT_CHAR
        if format_str:
            format_str = format_str.strip(SPLIT_CHAR)
        return format_str

    @staticmethod
    def _check_format_options(tensor_dsc_list: list) -> bool:
        """
        check wether the format space is valid
        Parameters
        ----------
        tensor_dsc_list: all format strategys of a format tune
        Returns
        -------
        True: the format space of the format tune is effective
        """
        if not tensor_dsc_list:
            return True
        tensor_num = len(tensor_dsc_list[0])
        for tensor_dsc in tensor_dsc_list:
            if len(tensor_dsc) != tensor_num:
                return False
        return True

    @staticmethod
    def _parse_default_format(inputs: list, outputs: list) -> str:
        """
        parse default format from format
        Parameters
        ----------
        inputs: description of inputs tensors
        Returns
        -------
        default_format: parsed default format of each format space
        """
        default_format = []

        def parse_default_format(tensor_name: str, tensors: list) -> None:
            for index, tensor_desc in enumerate(tensors):
                if "format" in tensor_desc:
                    default_format.append("{}{}:{}".format(tensor_name, str(index), tensor_desc.get("format", "")))

        parse_default_format("input", inputs)
        parse_default_format("output", outputs)
        LOG_INSTANCE.info("Default_format is: %s.", default_format)
        return SPLIT_CHAR.join(default_format)

    @staticmethod
    def _parse_profiling_data(profiling_list: List, tune_param_list: List) -> dict:
        """
        parse profiling data
        Parameters
        ----------
        profiling_list: profiling list of strategys
        tune_param_list: strategy list
        Returns
        -------
        profiling_list: parsed profiling data of each strategy
        """
        LOG_INSTANCE.debug("Parse profiling data begin, the size of profiling_list is %s.", str(len(profiling_list)))
        success_kernel_cnt = 0
        total_succ_cost_time = 0
        strategy_to_cost = {}
        for index, res in enumerate(profiling_list):
            op_name = res.get("opName", "")
            op_cost_time = int(res.get("totalCostTime", "0")) / 1000.0
            tune_param = tune_param_list[index]
            LOG_INSTANCE.debug("Parse profiling data op_name=%s, format=%s, cost_time[us]=%s.",
                               op_name, tune_param, str(op_cost_time))

            if op_cost_time > 0:
                success_kernel_cnt = success_kernel_cnt + 1
                strategy_to_cost[tune_param] = op_cost_time
                total_succ_cost_time += op_cost_time

        if success_kernel_cnt <= 0:
            LOG_INSTANCE.error("The count of build and excute successful <= 0.")
            return {}

        success_rate = success_kernel_cnt / len(profiling_list)
        LOG_INSTANCE.info("Parse profiling data success_kernel_cnt=%s, success_rate=%s.", \
                          str(success_kernel_cnt), str(success_rate))
        return strategy_to_cost

    def do_tune(self) -> bool:
        """
        tune one format op
        """
        # 1. check op args
        if not self._check_op_param():
            return False

        # 2. query  repository
        self._get_format_strategy()
        self.exist_repository = True if self.repo_format else False

        tune_op_params = TuneOpParam(self.exist_repository, None, None, 0, False, self.tune_option)
        input_args = {"topi_args": {"real_op_type": self.op_type}}
        self.tune_result_report = TuneResultReport(input_args, tune_op_params)

        # 3. if strategy has existed in repo and repeat_tune is falseï¼Œstop tune
        if not self._check_tune_condition():
            LOG_INSTANCE.debug(
                "REPEAT_TUNE is false, and the case:%s [info_dict=%s] has existed in repository, it won't be tuned!",
                self.kernel_name, self.info_dict)
            self.tune_result_report.report_tune_res_and_mode_to_opat(True, self.tune_mode)
            return True

        # 4. get build_run base time bound
        base_cost_time = self._get_baseline_build_run_time()
        self.build_run_time_bound = base_cost_time * ADJUST_COEFFICIENT

        # 5. evaluate strategy performance and get the best strategy
        best_format_info = self._performance_evaluate()
        if not best_format_info:
            LOG_INSTANCE.info("Format tune can't get format better than default or repo_format.")
            return True

        # 6. save best strategy to repository
        write_ok, self.update_flag = self._write_repository(best_format_info)

        # 7. post process
        self._report_tune_result(self.baseline_cost, best_format_info)
        return write_ok

    def _report_tune_result(self, before_cost: float, best_impl_info: str) -> None:
        """
        report tune result after write repository
        """
        after_cost = before_cost
        if (best_impl_info.get("cost_time") and self.update_flag):
            after_cost = best_impl_info.get("cost_time")
        self.tune_success = bool(after_cost < COST_MAX_VALUE and before_cost < COST_MAX_VALUE)
        if not self.tune_success:
            LOG_INSTANCE.warning("current tiling cost time[%f] greater than COST_MAX_VALUE[%f]", \
                                 after_cost, COST_MAX_VALUE)
            return
        if self.tune_result_report is not None:
            tune_res_report = TuneResReport(before_cost, after_cost, self.update_flag, self.exist_repository)
            self.tune_result_report.gen_tune_result_status(tune_res_report, self.build_op_name)
            self.tune_result_report.report_tune_res_and_mode_to_opat(self.tune_success, self.tune_mode)

    def _performance_evaluate(self) -> dict:
        """
        Evaluate the performance of format space
        Returns
        -------
        best_format_info: list
            the best format index in self.format_space
        """
        # buiiild and execute op to get profiling data
        profiling_list, _ = self._build_and_execute(self.format_space)
        if profiling_list:
            self.build_op_name = profiling_list[0].get("opName", "")

        # parse best strategy from profiling_list
        format_cost_list = FormatTune._parse_profiling_data(profiling_list, self.format_space)
        return self._get_best_format_info(format_cost_list)

    def _parse_format_space(self, format_option: str) -> list:
        """
        parse format space
        param:
        turn_format_req eg: "input0:NCHW,ND;input1:NCHW,NHWC;output0:NHWC,NZ"
        return:
        ["input0:NCHW;input1:NCHW;output0:NHWC", "input0:ND;input1:NHWC;output0:NZ"]
        """
        tensors_descs_list = format_option.split(SPLIT_CHAR)
        tensor_dsc_list = []
        for tensor_dscs in tensors_descs_list:
            tensor_name, tensor_space_str = tensor_dscs.split(COLON_CHAR)
            tensor_format_list = tensor_space_str.split(",")
            tensor_dsc = ["{}:{}".format(tensor_name, i) for i in tensor_format_list]
            tensor_dsc_list.append(tensor_dsc)

        # check whether num of format spaces is different for all tensors
        if not FormatTune._check_format_options(tensor_dsc_list):
            LOG_INSTANCE.error("Parse format space error: the num of format spaces is different for all tensors.")
            return []

        format_space_list = []
        space_num = len(tensor_dsc_list)
        while True:
            tensor_space_list = []
            for tensor_dsc in tensor_dsc_list:
                if not tensor_dsc:
                    tensor_dsc_list.remove(tensor_dsc)
                    break
                tensor_space_list.append(tensor_dsc.pop())
            if space_num != len(tensor_dsc_list):
                break
            else:
                format_space_list.append(SPLIT_CHAR.join(tensor_space_list))

        if self.default_format and self.default_format not in format_space_list:
            format_space_list.append(self.default_format)
        return format_space_list

    def _get_format_strategy(self) -> None:
        """
        query stretegy by op args from repository and update self.repo_format
        """
        LOG_INSTANCE.debug("Get format strategy: get_op_compile_unique_key begin.")
        try:
            info_dict_result = get_op_compile_unique_key(
                self.op_type, self.inputs, self.outputs, self.attrs, self.extra_params, False)
            if isinstance(info_dict_result, str):
                self.info_dict = info_dict_result
            elif isinstance(info_dict_result, list):
                self.info_dict = info_dict_result[0]
        except (RuntimeError, IndexError) as e:
            LOG_INSTANCE.error("Get format strategy: get_op_compile_unique_key raise exception: %s.", e)
            raise ValueError("Get format strategy: get_op_compile_unique_key failed! {}".format(e))
        finally:
            LOG_INSTANCE.info("Get format strategy: info_dict=%s.", self.info_dict)

        if not self.info_dict:
            msg = "Get format strategy: get info_dict failed, info_dict is empty!"
            LOG_INSTANCE.error(msg)
            raise ValueError(msg)
        self.info_dict = self.info_dict.replace('\'', '\"')
        strategy = cann_kb_search(self.info_dict, search_config={"op_type": "format_type", "full_info": True}, \
                                  option={})
        self.repo_format = {} if not strategy else strategy[0].get("knowledge", {})

        LOG_INSTANCE.info("Get format strategy: repo strategy=%s.", str(self.repo_format))

    def _build_and_execute(self, format_list: list, is_base: bool = False) -> tuple:
        """
        Build and excute the om to get profiling data of each strategy
        Parameters
        ----------
        kernel_list: strategy list with cb_struct_key
        Returns
        -------
        profiling_list: the profiling data of each strategy
        """
        cb_task_queue = self.global_mgr["tune_task_d"]
        cb_result = self.global_mgr["tune_result_d"]
        cb_release = self.global_mgr["release_tune_q"]
        timer_queue = self.global_mgr["timer_q"]

        cb_dict = {}
        pid = os.getpid()
        time_stamp = str(time.time()).replace(".", "_")[-9:]
        cb_key = "FORMAT_%s_%s" % (pid, time_stamp)
        cb_dict[cb_key] = {
                           "cb_struct_key": self.cb_struct_key,
                           "strategy_list": format_list,
                           "need_integrate": False,
                           "tune_mode": "FORMAT",
                           "costtime_baseline": DEFAULT_OM_RUN_THRESHOLD
        }
        LOG_INSTANCE.debug("Build and execute begin, timeout: %d[s].", self.build_run_time_bound)
        LOG_INSTANCE.debug("Build and execute info: %s.", str(cb_dict))
        timer_queue.put(("start", pid, cb_key))
        cb_task_queue.put(cb_dict)

        # query callback result
        execute_params = ExecuteParams(pid, cb_key, cb_result, cb_release, timer_queue)
        strategy_num = len(format_list)
        return self._get_execute_res(execute_params, strategy_num, is_base)

    def _get_execute_res(self, execute_params: ExecuteParams, strategy_num: int, is_base: bool = False) -> tuple:
        """
        get execute res list
        """
        profiling_list = []
        build_begin = time.time()
        build_run_time = 0
        while True:
            build_run_time = time.time() - build_begin
            if execute_params.cb_key in execute_params.cb_result:
                profiling_list = execute_params.cb_result.get(execute_params.cb_key, [])
                execute_params.cb_release.put(execute_params.cb_key)
                break
            if not is_base:
                time_bound = max(self.default_time_bound, strategy_num * self.build_run_time_bound)
                if build_run_time > time_bound:
                    LOG_INSTANCE.error("Format_tune build_and_execute has been waiting longer than %d!", time_bound)
                    break
            time.sleep(TIME_SLEEP_CALLBACK)
        execute_params.timer_queue.put(("stop", execute_params.pid, execute_params.cb_key))
        LOG_INSTANCE.info("Build and execute end, the size of profiling_list: %d, interval: %s[s].",
                          len(profiling_list), str(build_run_time))
        return profiling_list, build_run_time

    def _get_best_format_info(self, format_cost_dict: dict) -> dict:
        """
        get format info of the best performance from format_cost_list
        param:
        format_cost_list
        return:
        best_format_info with "format_info", "cost_time"
        """
        if not format_cost_dict:
            return {}
        default_cost = format_cost_dict.get(self.default_format, COST_MAX_VALUE)
        self.baseline_cost = default_cost
        if self.exist_repository:
            self.baseline_cost = format_cost_dict.get(self._format_dict2str(self.repo_format), default_cost)
        best_format_info = {}
        format_cost_dict.pop(self.default_format)
        cur_best_cost = default_cost
        for format_info, cost_time in format_cost_dict.items():
            if cost_time < cur_best_cost and cost_time < self.baseline_cost * (1 - SECOND_OPTIMIZATION_THRESHOLD):
                cur_best_cost = cost_time
                best_format_info["format_info"] = format_info
                best_format_info["cost_time"] = cost_time
        LOG_INSTANCE.debug("Get best_format_info: %s.", str(best_format_info))
        if best_format_info:
            best_format_info["format_info"] = self._format_str2dict(best_format_info.get("format_info", ""))
        return best_format_info

    def _write_repository(self, best_format_info: str) -> tuple:
        """
        save the best format strategy into repositity
        """
        strategy_info_msg = "Kernel_name:%s, info_dict:%s, best_format_info:%s" % (
            self.kernel_name, self.info_dict, best_format_info)
        LOG_INSTANCE.info("Begin to save_strategy, %s", strategy_info_msg)

        knowledge = best_format_info.get("format_info", {})
        write_config = {}
        write_config["op_type"] = "format_type"
        write_config["cost_time"] = best_format_info.get("cost_time", COST_MAX_VALUE)
        if cann_kb_write(
            self.info_dict, knowledge, write_config, flush=True, option={}) != 0:
            LOG_INSTANCE.error("Save strategy: cann_kb_add failed! %s.", strategy_info_msg)
            return False, False

        LOG_INSTANCE.info("Save strategy succ, %s.", strategy_info_msg)
        return True, True

    def _check_op_param(self) -> bool:
        """
        check whether current op is supported by AOE
        """
        if not self.format_space:
            LOG_INSTANCE.info("Format space is empty.")
            return False
        if not (self.inputs and self.outputs and self.kernel_name):
            err_msg = "Format tune op param is illegal, inputs/outputs/kernel_name not support None, \
            inputs:%s, outputs:%s, kernel_name:%s." % (str(self.inputs), str(self.outputs), str(self.kernel_name))
            LOG_INSTANCE.error(err_msg)
            return False
        return True

    def _check_tune_condition(self) -> bool:
        # if enable repeat_tune or strategy not in repository, do tune
        if repeat_tune_flag(self.kernel_name) or not self.repo_format:
            return True
        return False

    def _get_baseline_build_run_time(self) -> int:
        _, cost_time = self._build_and_execute(["{}"], True)
        return math.ceil(cost_time)


def format_tune_main(op_args: str, option: dict) -> bool:
    """
    The main function for format tune
    Parameters
    ----------
    op_desc: string
        the description of op
    option: dict
        the tune params
    Returns
    -------
    True: tune succeed, False: tune failed.
    """
    # transform op args to json format
    op_args_json = check_load_json(op_args)
    # init FormatTune
    format_tune_manager = FormatTune(op_args_json, option)
    # do tune
    try:
        res = format_tune_manager.do_tune()
    except (ValueError, TimeoutError) as e:
        LOG_INSTANCE.error("Format tune failed! op_type: %s, kernel_name:%s, raise exception:%s.",
                           format_tune_manager.op_type, format_tune_manager.kernel_name, str(e))
        res = False
    finally:
        pass
    if res:
        LOG_INSTANCE.info("Format tune succ! op_type: %s, kernel_name:%s.",
                          format_tune_manager.op_type, format_tune_manager.kernel_name)
    return res
