#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2022. Huawei Technologies Co., Ltd. All rights reserved.

Define the main config for tuning
"""
import copy
from dataclasses import dataclass

from auto_tune.config_module.config_v100 import TILING_STRUCTURE_V100
from auto_tune.config_module.config_v300 import TILING_STRUCTURE_V300
from auto_tune.config_module.config_v300 import OP_SURPPORT_V300
from auto_tune.config_module.config_v300 import TILING_STRUCTURE_TYPE_V300
from auto_tune.config_module.config_v300 import SPLIT_MAP_V300


# default common_args for auto_tune_compile
COMMON_ARGS = {
    'old_repository_filename': None, # old repository filename
    'tuning_algorithm': 'ga',
    'training_data_flag': False, # true: save train data for generating cost model
    "ga_end_opf_switch": False, # the swith to control the end of ga tune
    "same_elite_cycle_thr": 0.03, # the threshold to judge if cycle is the same elite for ga tuner
    "max_same_elite_cycle": 3 # the max cycle for same elite
}

# repository type
REPO_TYPE_GT = 0 # repo type: get tiling type
REPO_TYPE_RM = 1 # repo type: repository manager type

# .OM/.O run type
RUN_TYPE_KERNEL_PERF = 0
RUN_TYPE_TELNET = 1
RUN_TYPE_QTEST = 2

# op params config
OP_PARAMS_IN_CONFIG = {
    "a_shape": ["a_shape", "A_shape", "fm_shape"],
    "b_shape": ["b_shape", "B_shape", "filter_shape"],
    "c_shape": ["c_shape", "C_shape", "result_shape"],
    "a_dtype": ["a_dtype", "A_dtype", "fm_dtype"],
    "b_dtype": ["b_dtype", "B_dtype", "filter_dtype"],
    "c_dtype": ["c_dtype", "C_dtype", "result_dtype"],
}

# ga_args for V100
GA_ARGS_V1 = {
    'pop_size': 50, 'trial_num': 500, 'crossover_rate_pc1': 0.6, 'crossover_rate_pc2': 0.9, 'probs_formula_type': 1,
    'mutation_rate_pm1': 0.01, 'mutation_rate_pm2': 0.1, 'elite_num': 2, "early_stop_flag": True
}

# ga_args for V300
GA_ARGS_V2 = {
    'pop_size': 50, 'trial_num': 500, 'crossover_rate_pc1': 0.6, 'crossover_rate_pc2': 0.9, 'probs_formula_type': 1,
    'mutation_rate_pm1': 0.01, 'mutation_rate_pm2': 0.1, 'elite_num': 2, "early_stop_flag": False
}

# ga_args for Ascend310B
GA_ARGS_V3 = {
    'pop_size': 50, 'trial_num': 500, 'crossover_rate_pc1': 0.6, 'crossover_rate_pc2': 0.9, 'probs_formula_type': 2,
    'mutation_rate_pm1': 0.01, 'mutation_rate_pm2': 0.1, 'elite_num': 2, "early_stop_flag": True
}

# ga_args_high_perf for V100
GA_ARGS_HIGH_PERF_V1 = {
    'pop_size': 100, 'trial_num': 1000, 'crossover_rate_pc1': 0.6, 'crossover_rate_pc2': 0.9, 'probs_formula_type': 1,
    'mutation_rate_pm1': 0.01, 'mutation_rate_pm2': 0.1, 'elite_num': 2, "early_stop_flag": False
}

# ga_args_high_perf for V300
GA_ARGS_HIGH_PERF_V2 = {
    'pop_size': 150, 'trial_num': 1500, 'crossover_rate_pc1': 0.6, 'crossover_rate_pc2': 0.9, 'probs_formula_type': 1,
    'mutation_rate_pm1': 0.01, 'mutation_rate_pm2': 0.1, 'elite_num': 2, "early_stop_flag": False
}

# default ga_args_high_perf
GA_ARGS_HIGH_PERF_DEFAULT = {
    "ga_args": GA_ARGS_HIGH_PERF_V2
}

SUPPORT_SOC_CONFIG_HIGH_PERF  = {
    "Ascend310P": {"ga_args": GA_ARGS_HIGH_PERF_V1},
    "Ascend910": {"ga_args": GA_ARGS_HIGH_PERF_V2}
}

# Total SOC CONFIG
DEFAULT_CONFIG = {
    "repo_type": REPO_TYPE_GT,
    "tiling_structure": TILING_STRUCTURE_V100,
    "ga_args": GA_ARGS_V1,
    "common_args": COMMON_ARGS,
    "need_integrate": False,  # the product versions which need integrate
    "run_type": RUN_TYPE_KERNEL_PERF # run type
}
SUPPORT_SOC_CONFIG = {
    "Ascend310": {},
    "Ascend610": {"need_integrate": True},
    "BS9SX1A": {"need_integrate": True},
    "Ascend910": {},
    "Ascend310P": {},
    "Ascend610Lite": {"tiling_structure": TILING_STRUCTURE_V300, "repo_type": REPO_TYPE_RM,
        "ga_args": GA_ARGS_V3},
    "Hi3796CV300ES": {"need_integrate": True, "run_type": RUN_TYPE_TELNET},
    "Hi3796CV300CS": {"need_integrate": True, "run_type": RUN_TYPE_TELNET},
    "SD3403": {"need_integrate": True, "run_type": RUN_TYPE_TELNET},
    "Ascend910B": {"tiling_structure": TILING_STRUCTURE_V300, "repo_type": REPO_TYPE_RM,
        "ga_args": GA_ARGS_V2, "run_type": RUN_TYPE_QTEST},
    "Ascend910_93": {"tiling_structure": TILING_STRUCTURE_V300, "repo_type": REPO_TYPE_RM,
        "ga_args": GA_ARGS_V2, "run_type": RUN_TYPE_QTEST},
    "Ascend310B": {"tiling_structure": TILING_STRUCTURE_V300, "repo_type": REPO_TYPE_RM,
        "ga_args": GA_ARGS_V3, "run_type": RUN_TYPE_QTEST, "need_integrate": True},
    "AS31XM1": {"tiling_structure": TILING_STRUCTURE_V300, "repo_type": REPO_TYPE_RM,
        "ga_args": GA_ARGS_V3, "run_type": RUN_TYPE_QTEST, "need_integrate": True},
    "BS9SX2A": {"tiling_structure": TILING_STRUCTURE_V300, "repo_type": REPO_TYPE_RM,
        "ga_args": GA_ARGS_V3},
    "MC61AM21A": {"tiling_structure": TILING_STRUCTURE_V300, "repo_type": REPO_TYPE_RM,
        "ga_args": GA_ARGS_V3},
}


@dataclass
class FeatureConfig:
    """
    define the FeatureConfig class to manager the basic config for different soc version or different tunner alg.
    """
    soc_version: str
    full_soc_version: str
    high_perf: bool
    l1_size: int
    info_dict: dict

    def __post_init__(self) -> None:
        """
        post_init: create atters like XXX_location
        """
        if self.soc_version not in SUPPORT_SOC_CONFIG:
            raise ValueError("The soc_version %s doesn't support auto tuning." % self.soc_version)
        for idx, item in enumerate(self.config_keys):
            setattr(self, item + "_location", idx)

    @property
    def op_type(self) -> str:
        """
        get the op type
        """
        return self.info_dict.get("op_type")

    @property
    def repo_type(self) -> int:
        """
        get the repo type
        """
        if "repo_type" not in SUPPORT_SOC_CONFIG.get(self.soc_version):
            return DEFAULT_CONFIG.get("repo_type")
        if not self.is_v300_support_op: # not in v300 white list
            return DEFAULT_CONFIG.get("repo_type")
        return SUPPORT_SOC_CONFIG.get(self.soc_version).get("repo_type")

    @property
    def tiling_structure(self) -> dict:
        """
        get the tiling structure
        """
        if "tiling_structure" not in SUPPORT_SOC_CONFIG.get(self.soc_version):
            return DEFAULT_CONFIG.get("tiling_structure")
        if not self.is_v300_support_op: # not in v300 white list
            return DEFAULT_CONFIG.get("tiling_structure")
        return SUPPORT_SOC_CONFIG.get(self.soc_version).get("tiling_structure")

    @property
    def ga_args(self) -> dict:
        """
        get ga args for Tuner
        """
        if self.high_perf:
            return SUPPORT_SOC_CONFIG_HIGH_PERF.get(self.soc_version, {}).get("ga_args",
                    GA_ARGS_HIGH_PERF_DEFAULT.get("ga_args"))

        if "ga_args" not in SUPPORT_SOC_CONFIG.get(self.soc_version):
            return DEFAULT_CONFIG.get("ga_args")
        if not self.is_v300_support_op: # not in v300 white list
            return DEFAULT_CONFIG.get("ga_args")
        return SUPPORT_SOC_CONFIG.get(self.soc_version).get("ga_args")

    @property
    def common_args(self) -> dict:
        """
        get common args for Tuner
        """
        if "common_args" not in SUPPORT_SOC_CONFIG.get(self.soc_version):
            return copy.deepcopy(DEFAULT_CONFIG.get("common_args"))
        return copy.deepcopy(SUPPORT_SOC_CONFIG.get(self.soc_version).get("common_args"))

    @property
    def need_integrate(self) -> bool:
        """
        judge is need integrate
        """
        if "need_integrate" not in SUPPORT_SOC_CONFIG.get(self.soc_version):
            return DEFAULT_CONFIG.get("need_integrate")
        return SUPPORT_SOC_CONFIG.get(self.soc_version).get("need_integrate")

    @property
    def run_type(self) -> int:
        """
        get the run type
        """
        if "run_type" not in SUPPORT_SOC_CONFIG.get(self.soc_version):
            return DEFAULT_CONFIG.get("run_type")
        return SUPPORT_SOC_CONFIG.get(self.soc_version).get("run_type")

    @property
    def tiling_structure_type(self) -> int:
        """
        get the tiling structure type
        """
        return self.tiling_structure.get("tiling_structure_type")

    @property
    def config_keys(self) -> list:
        """
        get the config keys
        """
        return self.tiling_structure.get("config_keys")

    @property
    def full_load_pairs(self) -> list:
        """
        get the keys support full load
        """
        return self.tiling_structure.get("full_load_pairs")

    @property
    def bool_keys(self) -> list:
        """
        get the keys support replacing bool
        """
        return self.tiling_structure.get("bool_keys")

    @property
    def none_0_replace(self) -> list:
        """
        get the keys support replacing none to 0 or 0 to none
        """
        return self.tiling_structure.get("none_0_replace")

    @property
    def none_keys(self) -> list:
        """
        get the keys support replacing none to 0 or 0 to none
        """
        return self.tiling_structure.get("none_keys", [])

    @property
    def cross_point_keys(self) -> list:
        """
        get cross point keys
        """
        return self.tiling_structure.get("cross_point_keys")

    @property
    def half_index(self) -> int:
        """
        get half index for tuner
        """
        return self.tiling_structure.get("half_index")

    @property
    def unmutable_point_keys(self) -> list:
        """
        get unmutable point keys
        """
        return self.tiling_structure.get("unmutable_point_keys")

    @property
    def cross_point_locations(self) -> list:
        """
        get cross point locations
        """
        cross_point_locations = []
        for cross_point in self.cross_point_keys:
            cross_point_locations.append(self.config_keys.index(cross_point))
        return cross_point_locations

    @property
    def unmutable_point_locations(self) -> list:
        """
        get unmutable point locations
        """
        unmutable_point_locations = []
        for unmutable_point in self.unmutable_point_keys:
            unmutable_point_locations.append(self.config_keys.index(unmutable_point))
        return unmutable_point_locations

    @property
    def tiling_dict_structure(self) -> dict:
        """
        get tiling dict structure
        """
        return self.tiling_structure.get("tiling_dict_structure")

    @property
    def is_type_v300(self) -> bool:
        """
        judge if type of tiling_structure is v300
        """
        if self.tiling_structure_type == TILING_STRUCTURE_TYPE_V300:
            return True
        return False

    @property
    def split_map(self) -> dict:
        """
        split map
        """
        if self.is_type_v300:
            return SPLIT_MAP_V300
        return {}

    @property
    def is_v300_support_op(self) -> bool:
        """
        judge if op in v300 support list
        """
        return self.op_type in OP_SURPPORT_V300
