#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2022. Huawei Technologies Co., Ltd. All rights reserved.

Define TaskConfig Class
"""
import os
import fcntl
import csv
import copy
from collections import OrderedDict
from typing import List
from typing import Any
import numpy as np

from te.platform import CUBE_MKN
from tbe.common.tiling.tiling_api import tiling_analyzer
from tbe.common.tiling.tiling_api import get_tiling_type
from tbe.common.tiling.tiling_api import set_tiling_type
from tbe.common.tiling.tiling_api import get_tiling

from auto_tune.common_module.common_util import is_zero_tiling
from auto_tune.common_module.common_util import TuneOpParam
from auto_tune.common_module.common_util import MAX_UINT64
from auto_tune.common_module.common_util import MAX_UINT32
from auto_tune.common_module.common_util import MKN
from auto_tune.common_module.common_util import CA0
from auto_tune.common_module.common_util import SPARSITY_FLAG
from auto_tune.common_module.common_util import SPECIAL_MODE
from auto_tune.op_adapter.op_factory import FactoryOperatorAdapter
from auto_tune.auto_tune_log import LOG_INSTANCE
from auto_tune.util_atc import create_dir
from auto_tune.util_atc import FILE_FLAG
from auto_tune.util_atc import FILE_MODE_640
from auto_tune.config_module.config import FeatureConfig
from auto_tune.config_module.config import OP_PARAMS_IN_CONFIG


class TaskConfig:
    """
    Base class for tuner task

    Parameters
    ----------
    param: shape info of input.
    """
    def __init__(self,
                 param: dict,
                 feature_config: FeatureConfig,
                 op_tune_flag: str,
                 tune_op_params: TuneOpParam) -> None:
        # 1. save param self.param should be self.shape_args
        self.param = param.get('shape_args')
        self.cfg = feature_config
        self.common_args = feature_config.common_args
        self.half_index = self.cfg.half_index
        self.is_sparse = self.param.get(SPECIAL_MODE) is not None and \
            self.param.get(SPECIAL_MODE).get(SPARSITY_FLAG, False) or self.param.get(SPARSITY_FLAG, False)
        # 2. update common args: _singleton__input_params will be changed by self.shape_args while obtain_tiling,
        # so should do it before changing self.shape_args
        self.update_common_args(op_tune_flag, tune_op_params)
        # 3. compute_feasibility:
        self.feasibility, self.config_space = self.compute_feasibility()
        self.dims = [len(x) for x in self.config_space.values()]
        self.display_space_dim_info(self.config_space)
        LOG_INSTANCE.debug("config_space: %s", self.config_space)
        LOG_INSTANCE.info("length of feasibility: %s", len(self.feasibility))

    @staticmethod
    def display_space_dim_info(config_space: dict) -> None:
        for key, val in config_space.items():
            if len(val) > 100:
                LOG_INSTANCE.warning("the length the %s dim of the config_space is: %s", key, len(val))
            LOG_INSTANCE.debug("the %s dim of the config_space is: %s", key, str(val))

    # define the map function
    @staticmethod
    def map_special_value(input_element: Any) -> int:
        """
        get input
        """
        if input_element == []:
            return MAX_UINT32
        if input_element is None or not input_element:
            return 0
        if input_element is True:
            return 1
        return input_element

    @staticmethod
    def replace_dict_value(config: List, ori_value: int, replace_value: int) -> None:
        """
        basic method to replace dict value
        """
        if ori_value in config:
            config[config.index(ori_value)] = replace_value

    @staticmethod
    def check_dim(shape: List[int], dim: int) -> dict:
        """
        check the tiling_dict params' dimension
        Parameters
        ----------
        param: shape:the shape to be checked, dim: supposed dimension
        """
        new_shape = [1] * dim
        if shape is None:
            new_shape[0] = None
        elif shape == []:
            new_shape[0] = []
        elif len(shape) < dim:
            for each_index, each_shape in enumerate(shape):
                new_shape[each_index] = each_shape
        else:
            new_shape = shape
        return new_shape

    @staticmethod
    def change_special_str_to_num(slice_str: str, change_map: dict):
        """
        change special str to num
        """
        for s_num, s_str in change_map.items():
            if slice_str == s_str:
                return s_num
        return 0

    def compute_feasibility(self) -> tuple:
        """
        Calculate feasibility of all Tiling
        Parameters
        ----------
        param: the param of shape

        Returns
        -------
        config_space: the config space of every feature, dict
        dims: the length of config space of every feature
        feasibility: the feasibility of all Tiling, list
        """
        # encode the param
        op_type = self.param.get('op_type')

        # get the config space of every feature of tiling and tiling space
        tuning_flag = 0 if self.common_args.get("training_data_flag", False) else 1
        space = tiling_analyzer(op_type, tuning_flag, self.param)
        return self.decode_space(space)

    def update_common_args(self, op_tune_flag: str, tune_op_params: TuneOpParam) -> object:
        """
        get common_args from option
        """
        self.common_args["op_tune_flag"] = op_tune_flag
        self.get_tuner_seed()
        self.get_tiling_by_type("cost_model_tiling")
        self.get_tiling_by_type("dsl_cache_tiling")
        self.common_args["exist_repository_flag"] = tune_op_params.already_in_repo
        self.common_args["time_stamp"] = tune_op_params.time_stamp
        self.common_args["pass_param_num"] = tune_op_params.pass_param_num
        self.common_args["overhead_opt_tune"] = tune_op_params.overhead_opt_tune
        if tune_op_params.option:
            self.common_args["cb_struct_key"] = tune_op_params.option.get("cb_struct_key", None)
            self.common_args["cb_task"] = tune_op_params.option.get("global_mgr").get("tune_task_d")
            self.common_args["cb_res"] = tune_op_params.option.get("global_mgr").get("tune_result_d")
            self.common_args["cb_release"] = tune_op_params.option.get("global_mgr").get("release_tune_q")
            self.common_args["timer"] = tune_op_params.option.get("global_mgr").get("timer_q")
            self.common_args["tune_progress"] = tune_op_params.option.get("global_mgr").get("tune_progress_q")
            self.common_args["is_dynamic_mode"] = tune_op_params.option.get("is_dynamic", False)
            self.common_args["cb_datacmp_task"] = tune_op_params.option.get("global_mgr").get("datacmp_task_q")
            self.common_args["cb_datacmp_res"] = tune_op_params.option.get("global_mgr").get("datacmp_res_d")
            LOG_INSTANCE.info("ga tune[%s] with [%s]",
                self.param.get("kernel_name"), tune_op_params.option.get("cb_struct_key", None))

    def get_tuner_seed(self) -> None:
        """
        get tunner seed to update auto tiling info for common_args
        """
        auto_tiling_list = []
        auto_tiling_dict = []
        # get tiling from tiling_query under auto_tiling
        tiling_type = get_tiling_type()
        set_tiling_type("auto_tiling")
        auto_tiling = get_tiling(self.param)
        set_tiling_type(tiling_type)

        auto_tiling_flag = not is_zero_tiling(auto_tiling)
        if auto_tiling_flag:
            auto_tiling_dict.append(auto_tiling)
            auto_tiling_list.append(self.convert_tiling(auto_tiling))

        self.common_args["auto_tiling_list"] = auto_tiling_list
        self.common_args["auto_tiling_dict"] = auto_tiling_dict

    def get_tiling_by_type(self, tiling_type: str) -> None:
        """
        get cost model tiling, when tune finished, compare performance
        Parameters:
        ----------
        """
        tmp_tiling_list = []
        tmp_tiling_dict = []
        # get tiling from tiling_query under tiling type
        old_tiling_type = get_tiling_type()
        set_tiling_type(tiling_type)
        tmp_tiling = get_tiling(self.param)
        set_tiling_type(old_tiling_type)
        if tiling_type == "dsl_cache_tiling":
            self.common_args[tiling_type] = tmp_tiling
            LOG_INSTANCE.info("common_args[%s] is [%s]", tiling_type, self.common_args.get(tiling_type))
            return

        if isinstance(tmp_tiling, list):
            for model_tiling in tmp_tiling:
                if not is_zero_tiling(model_tiling):
                    tmp_tiling_dict.append(model_tiling)
                    tmp_tiling_list.append(
                        [int(i) if i is not None and not isinstance(i, list) else i
                        for i in self.convert_tiling(model_tiling)])
        elif isinstance(tmp_tiling, dict):
            if not is_zero_tiling(tmp_tiling):
                tmp_tiling_dict.append(tmp_tiling)
                tmp_tiling_list.append(
                    [int(i) if i is not None and not isinstance(i, list) else i
                    for i in self.convert_tiling(tmp_tiling)])

        self.common_args[tiling_type + "_list"] = tmp_tiling_list
        self.common_args[tiling_type + "_dict"] = tmp_tiling_dict
        LOG_INSTANCE.info("common_args[%s] is [%s]", tiling_type, self.common_args.get(tiling_type + "_dict"))

    def decode_space(self, space_encode: List[int]) -> tuple:
        """
        Decode the information of space from the list of uint64 digit

        Parameters
        ----------
        space_encode: list
        info of encoded config_space and tiling space
        The first half of these uint64 digits contains tiling space,
        The second half of these uint64 digits contains config_space.

        Returns
        -------
        tiling_space: The decoded tiling, list
        config_space: The decoded config_space, dict
        """
        # According to the order of space encoding, the first half of the space_encode stores
        # tiling space, and the second half stores the configuration information.
        # The first dimension information of the tiling field is the length of tiling space.
        # Initialize configuration space and tiling space
        tiling_space = []
        config_option = []

        # get the tiling space and config space
        i = 0
        while i < len(space_encode):
            # the first eletment is the length of tiling space
            length = int(space_encode[i] & MAX_UINT64)
            if i == 0:
                if length % 2 != 0:
                    raise ValueError("the length of set for tiling must be even number.")
                # The combination of two numbers is decoded into a Tiling
                for j in range(0, length, 2):
                    tiling_index_0 = int(space_encode[i + j + 1] & MAX_UINT64)
                    tiling_index_1 = int(space_encode[i + j + 2] & MAX_UINT64)
                    tiling_space.append((tiling_index_0, tiling_index_1))
            # the second half of space encoding stores the configuration information
            else:
                option = []
                for j in range(length):
                    value = int(space_encode[i + j + 1] & MAX_UINT64)
                    option.append(value)
                config_option.append(option)
            # update the iterative variable
            i = i + length + 1

        # remove duplication
        len_tiling_space = len(tiling_space)
        tiling_space = list(set(tiling_space))
        if len(tiling_space) != len_tiling_space:
            raise ValueError(
                "tiling config_space get fail, tiling must be unique, please check tiling_analyzer of operator.")
        if not tiling_space:
            return tiling_space, OrderedDict()
        # get the config_space
        config_space = self.process_config_space(config_option)
        return tiling_space, config_space

    def config_space_value_replace(self, config: object, key: str) -> object:
        """
        modify values in config_space
        """
        new_value = config
        if key in self.cfg.none_0_replace:
            self.replace_dict_value(new_value, 0, None)
        if key in self.cfg.full_load_pairs:
            self.replace_dict_value(new_value, self.cfg.full_load_pairs[key], [])
        if key in self.cfg.bool_keys:
            self.replace_dict_value(new_value, None, False)
            self.replace_dict_value(new_value, 0, False)
            self.replace_dict_value(new_value, 1, True)
        if key in self.cfg.none_keys:
            self.replace_dict_value(new_value, 0, None)
        return new_value

    def process_config_space(self, config_option: list) -> dict:
        """
        Decode the information of space from the list of uint64 digit

        Parameters
        ----------
        config_option: list
        info of encoded config_space
        The uint64 digits contains config_space.

        Returns
        -------
        config_space: dict of config_space
        """
        config_keys = self.cfg.config_keys
        config_space = OrderedDict()
        # Transform config space into ordered dictionary of config space
        if len(config_keys) != len(config_option):
            raise ValueError("config_space get failed, length of key and value are not equal")
        for i in np.arange(len(config_keys)):
            # some tiling feature support special value None
            config_space[config_keys[i]] = self.config_space_value_replace(config_option[i], config_keys[i])

        return config_space

    def entity2point(self, entity: list) -> tuple:
        """
        Transform entity of tiling into index

        Parameters
        ----------
        entity: the entity of tiling
        Returns
        -------
        p: number
        the index of tiling
        """
        # convert knob form (vector) to entity form (integer list)
        knob1 = []
        for j, k in enumerate(entity[:self.half_index]):
            for dim in range(self.dims[j]):
                if k == list(self.config_space.values())[j][dim]:
                    knob1.append(dim)

        # convert knob form (vector) to point form (single integer)
        point1 = 0
        for j, k in enumerate(knob1):
            point1 += int(np.prod(self.dims[:j])) * k

        # convert knob form (vector) to entity form (integer list)
        knob2 = []
        for j, k in enumerate(entity[self.half_index:]):
            for dim in range(self.dims[j + self.half_index]):
                if k == list(self.config_space.values())[j + self.half_index][dim]:
                    knob2.append(dim)

        # convert knob form (vector) to point form (single integer)
        point2 = 0
        for j, k in enumerate(knob2):
            point2 += int(np.prod(self.dims[self.half_index:j + self.half_index])) * k

        return (point1, point2)

    def point2entity(self, point: tuple) -> list:
        """
        Transform the index of tiling into entity

        Parameters
        ----------
        point: the index of tiling

        Returns
        -------
        entity: list
        the entity of tiling
        """
        point1 = point[0]
        point2 = point[1]
        # convert point form (single integer) to knob form (vector)
        entity = []
        knob1 = []
        for dim in self.dims[:self.half_index]:
            knob1.append(point1 % dim)
            point1 //= dim

        # convert knob form (vector) to entity form (integer list)
        for j, k in enumerate(knob1):
            elite1 = list(self.config_space.values())[j][k]
            entity.append(elite1)

        # convert point form (single integer) to knob form (vector)
        knob2 = []
        for dim in self.dims[self.half_index:]:
            knob2.append(point2 % dim)
            point2 //= dim

        # convert knob form (vector) to entity form (integer list)
        for j, k in enumerate(knob2):
            elite2 = list(self.config_space.values())[j + self.half_index][k]
            entity.append(elite2)

        return entity

    def save_history_data(self, tiling_history: list) -> None:
        """
        save the train data for generating cost model when training_data_flag is true
        """
        if self.common_args.get("training_data_flag", True):
            train_data_save_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'traindata')
            create_dir(train_data_save_path)
            csv_name = ''.join((self.param.get("kernel_name"), '_', self.param.get('op_type'), '.csv'))
            csv_save_path = os.path.join(train_data_save_path, csv_name)
            with os.fdopen(os.open(csv_save_path, FILE_FLAG, FILE_MODE_640), 'a+') as f_handle:
                fcntl.flock(f_handle.fileno(), fcntl.LOCK_EX)
                handle = csv.writer(f_handle)
                handle.writerows(tiling_history)
                fcntl.flock(f_handle.fileno(), fcntl.LOCK_UN)

    def get_opshape_in_param(self) -> tuple:
        """
        get op shape in param

        Returns
        -------
        a_shape, b_shape, c_shape: list
        the shape of op
        """
        a_shape = []
        b_shape = []
        c_shape = []

        for ashape in OP_PARAMS_IN_CONFIG["a_shape"]:
            a_shape = self.param.get(ashape)
            if a_shape:
                break

        for bshape in OP_PARAMS_IN_CONFIG["b_shape"]:
            b_shape = self.param.get(bshape)
            if b_shape:
                break

        for cshape in OP_PARAMS_IN_CONFIG["c_shape"]:
            c_shape = self.param.get(cshape)
            if c_shape:
                break
        return a_shape, b_shape, c_shape

    def record_history_data(self, genes: list, result: list) -> list:
        """
        Record the train data for generating cost model

        Parameters
        ----------
        genes: record the tiling info
        result: record the label and feature

        Returns
        -------
        data_base: the performance data base of tiling
        """
        # check the length of genes and results
        if len(genes) != len(result):
            raise ValueError("the length of x_tiling and y_cost isn't equal")
        feature_data = copy.deepcopy(genes)
        label_data = copy.deepcopy(result)
        # prepare the record data for feature
        op_class_obj = FactoryOperatorAdapter(self.param.get('op_type'))

        bias_flag = 1 if self.param.get("bias_flag") else 0

        # record the history of train tiling
        x_tiling = []
        y_cost = [i.cost for i in label_data]  # record y_cost
        for tiling in feature_data:
            for j, element in enumerate(tiling):
                tiling[j] = self.map_special_value(element)
            a_shape, b_shape, c_shape = self.get_opshape_in_param()
            tiling.extend(a_shape[:4])
            tiling.extend(b_shape[:4])

            if self.cfg.is_type_v300:
                c_shape = tiling.extend(c_shape[2:4])
            else:
                m_block, n_block, k_block = op_class_obj.calc_matric_feature(self)
                tiling.append(m_block)
                tiling.append(n_block)
                tiling.append(k_block)
                # rate_data indicates the expansion rate of the data
                tiling.append(op_class_obj.get_r(m_block, k_block, self) * 10000)

            tiling.append(bias_flag)
            tiling.append(op_class_obj.op_tag_encode)
            x_tiling.append(tiling)  # record x_tiling

        data = []
        for k, x_data in enumerate(x_tiling):
            write_line = []
            write_line.append(y_cost[k])
            write_line.extend(x_data)
            data.append(write_line)

        return data

    def get_b_dtype(self) -> int:
        """
        get b_dtype
        """
        b_type = None
        b_dtype = OP_PARAMS_IN_CONFIG["b_dtype"]
        for b_dtype in OP_PARAMS_IN_CONFIG["b_dtype"]:
            b_type = self.param.get(b_dtype)
            if b_type:
                break
        return b_type

    def tiling_dict_value_replace(self, tiling_dict: dict) -> None:
        """
        modify value in tiling_dict
        """
        for key, tiling_item in tiling_dict.items():
            tiling_dict_key = self.cfg.tiling_dict_structure[key]
            if not isinstance(tiling_dict_key, list):
                continue
            special_flag = tiling_dict_key[0] in self.cfg.none_0_replace and tiling_item[0] is None or \
                tiling_dict_key[0] in self.cfg.full_load_pairs and tiling_item[0] == []
            if special_flag:
                tiling_dict[key] = tiling_item[0]
        if "INPUT_L1_BT_param" in tiling_dict.keys():
            tiling_dict["INPUT_L1_BT_param"] = self.cfg.split_map.get(tiling_dict["INPUT_L1_BT_param"])
        if "INPUT_L1_BT_param" in tiling_dict.keys():
            tiling_dict["INPUT_L1_FB_param"] = self.cfg.split_map.get(tiling_dict["INPUT_L1_FB_param"])
        if "INPUT_L1_BT_param" in tiling_dict.keys():
            tiling_dict["INPUT_L1_eltwise_param"] = self.cfg.split_map.get(tiling_dict["INPUT_L1_eltwise_param"])

    def transform_struct_list(self, struct_value: list, tiling: list) -> list:
        """
        get a dimension list value in struct dict by tiling list
        """
        b_dtype = self.get_b_dtype()
        config = CUBE_MKN[b_dtype]
        mkn = config['mac'][0]
        ca0 = config['mac'][1]
        struct_list = []
        for _, item in enumerate(struct_value):
            if item == CA0:
                single_value = ca0
            elif item == MKN:
                single_value = mkn
            else:
                single_value = tiling[getattr(self.cfg, item + "_location")]
            struct_list.append(single_value)
        return struct_list

    def tiling_transform(self, tiling: list) -> dict:
        """
        transform the format of tiling
        tiling: tiling generated by optimization algorithm
        return: transformed tiling
        """
        tiling_dict_new = {}
        # Fill the dictionary of Tiling
        for struct_key, struct_value in self.cfg.tiling_dict_structure.items():
            value_obj = None
            if isinstance(struct_value, list):
                value_obj = self.transform_struct_list(struct_value, tiling)
            elif isinstance(struct_value, str):
                value_obj = tiling[getattr(self.cfg, struct_value + "_location")]
            elif isinstance(struct_value, dict):
                value_obj = {}
                for item_k, item_v in struct_value.items():
                    value_obj[item_k] = tiling[getattr(self.cfg, item_v + "_location")]
            tiling_dict_new[struct_key] = value_obj

        self.tiling_dict_value_replace(tiling_dict_new)
        return tiling_dict_new

    def convert_tiling(self, tiling_dict_in: dict) -> list:
        """
        transfer the tiling dict to list
        :param tiling_dict: tiling from already_in_repository
        :return:
        """
        tiling_dict = copy.deepcopy(tiling_dict_in)
        self.tiling_dim_adjustment(tiling_dict, self.cfg.tiling_dict_structure)
        tiling_list_new = [0] * len(self.cfg.config_keys)

        loc_dict = self.find_replace_loc_for_dic(self.cfg.config_keys, tiling_dict, self.cfg.tiling_dict_structure)

        for loc, replace_val in loc_dict.items():
            if loc < len(tiling_list_new):
                tiling_list_new[loc] = replace_val

        return tiling_list_new

    def find_replace_loc_for_dic(self, config_keys: List, tiling_dict: dict, tiling_dict_structure: dict) -> dict:
        """
        replace location value for tiling_dict
        """
        loc_dict = {}
        for tiling_dict_key, item_val in tiling_dict.items():
            item_struct = tiling_dict_structure.get(tiling_dict_key)
            if isinstance(item_struct, dict) and isinstance(item_val, dict):
                loc_dict.update(self.find_replace_loc_for_dic(config_keys, item_val, item_struct))
            elif isinstance(item_struct, List) and isinstance(item_val, List):
                for idx, item_key in enumerate(item_struct):
                    self.update_loc_list(config_keys, item_key, loc_dict, item_val[idx])
            elif isinstance(item_struct, str):
                self.update_loc_list(config_keys, item_struct, loc_dict, item_val)
        return loc_dict

    def update_loc_list(self, config_keys: List, key: str, loc_dict: dict, replace_val: int) -> None:
        """
        replace loc_dict value
        """
        if key in config_keys:
            loc = getattr(self.cfg, key + "_location")
            loc_dict[loc] = replace_val

    def tiling_dim_adjustment(self, tiling_dict: dict, tiling_dict_structure: dict) -> None:
        """
        normalize tiling dict
        """
        tiling_dict['AL1_shape'] = self.check_dim(
            tiling_dict.get('AL1_shape'), len(tiling_dict_structure.get('AL1_shape')))
        tiling_dict['BL1_shape'] = self.check_dim(
            tiling_dict.get('BL1_shape'), len(tiling_dict_structure.get('BL1_shape')))
        tiling_dict['AUB_shape'] = self.check_dim(
            tiling_dict.get('AUB_shape'), len(tiling_dict_structure.get('AUB_shape')))
        tiling_dict['BUB_shape'] = self.check_dim(
            tiling_dict.get('BUB_shape'), len(tiling_dict_structure.get('BUB_shape')))
        if tiling_dict.get("CUB_matrix"):
            tiling_dict["CUB_matrix"] = self.check_dim(
            tiling_dict.get("CUB_matrix"), len(tiling_dict_structure.get("CUB_matrix")))
        if tiling_dict.get("L0C_OUTPUT_matrix"):
            tiling_dict["L0C_OUTPUT_matrix"] = self.check_dim(
            tiling_dict.get("L0C_OUTPUT_matrix"), len(tiling_dict_structure.get("L0C_OUTPUT_matrix")))
        tiling_dict['AL0_matrix'] = self.check_dim(
            tiling_dict.get('AL0_matrix'), len(tiling_dict_structure.get('AL0_matrix')))
        tiling_dict['BL0_matrix'] = self.check_dim(
            tiling_dict.get('BL0_matrix'), len(tiling_dict_structure.get('BL0_matrix')))
        tiling_dict['CL0_matrix'] = self.check_dim(
            tiling_dict.get('CL0_matrix'), len(tiling_dict_structure.get('CL0_matrix')))

        # 以下逻辑跟算子解空间的返回值相关，以后慢慢要求算子多平台统一
        # 有些算子以AUB_shape的不同维度代表不同含义，才有以下特殊处理
        if tiling_dict.get("AUB_shape")[0] is None or tiling_dict.get("AUB_shape")[1] == 0:
            tiling_dict.get("AUB_shape")[1] = None
        tiling_dict.get("AUB_shape")[2] = None
        tiling_dict.get("AUB_shape")[3] = None
        if tiling_dict.get("BUB_shape")[0] is None:
            tiling_dict["BUB_shape"] = [None] * len(tiling_dict.get("BUB_shape"))

        if tiling_dict.get("BL0_matrix")[0] == []:
            tiling_dict.get("BL0_matrix")[1] = tiling_dict.get('CL0_matrix')[0]
        if self.cfg.is_type_v300:
            tiling_dict["INPUT_L1_BT_param"] = self.change_special_str_to_num(
                tiling_dict["INPUT_L1_BT_param"], self.cfg.split_map)
            tiling_dict["INPUT_L1_FB_param"] = self.change_special_str_to_num(
                tiling_dict["INPUT_L1_FB_param"], self.cfg.split_map)
            tiling_dict["INPUT_L1_eltwise_param"] = self.change_special_str_to_num(
                tiling_dict["INPUT_L1_eltwise_param"], self.cfg.split_map)