#!/usr/bin/env python3
# -*- coding:utf-8 -*-
"""
Copyright (C) 2021. Huawei Technologies Co., Ltd. All rights reserved.

Define the tik tune function
"""

import json
import os
import time
import math
from typing import List

from tbe.common.utils.create_kb_query_key import get_op_compile_unique_key
from tbe.common.repository_manager.interface import cann_kb_write
from tbe.common.repository_manager.interface import cann_kb_search
from auto_tune.auto_tune_log import LOG_INSTANCE
from auto_tune.auto_tune_main import repeat_tune_flag
from auto_tune.common_module.common_util import COST_MAX_VALUE
from auto_tune.common_module.common_util import get_time_str
from auto_tune.common_module.common_util import TuneOpParam
from auto_tune.common_module.common_util import TuneResReport
from auto_tune.file_manager_module.report_file_manager import TuneResultReport
from auto_tune.get_input_args import check_load_json

SUCCESS_RATE_CONTROL = 0
DEFAULT_TIMEOUT_BUILD_EXECUTE = 200
HIGH_PERF_TIMEOUT_BUILD_EXECUTE = 600
ADJUST_COEFFICIENT = 20
TIME_SLEEP_CALLBACK = 1
MIN_OPTIMIZATION_THRESHOLD = 0.05
DEFAULT_OM_RUN_THRESHOLD = 18446744073709551615


class ImplTune:
    """
    class for impl op tuning
    """
    def __init__(self, op_args_json: dict, tune_option: dict) -> None:
        super(ImplTune, self).__init__()
        self.op_args_str = json.dumps(op_args_json)
        self.tune_option = tune_option
        self.op_type = op_args_json["op_type"]
        self.build_op_name = ""
        self.inputs = op_args_json["op_params"]["input_desc"]
        self.outputs = op_args_json["op_params"]["output_desc"]
        # attr_desc's dtype is List(dict)
        self.attrs = op_args_json["op_params"].get("attr_desc", [])
        self.kernel_name = op_args_json["op_params"]["kernel_name"]
        self.extra_params = op_args_json["op_params"].get("extra_param", {})
        self.info_dict = ""
        self.repo_tiling = {}
        self.tune_mode = "Impl"
        self.res_data = {}
        self.repo_cost_time = DEFAULT_OM_RUN_THRESHOLD
        self.cb_struct_key = tune_option.get("cb_struct_key", None)
        self.dynamic_and_impl = tune_option.get("dynamic_and_impl", None)
        self.global_mgr = tune_option["global_mgr"]
        self.tune_report_info_q = self.global_mgr.get("tune_report_info_q", None)
        self.job_id = tune_option.get("job_id")
        self.exist_repository = False
        self.update_flag = False
        self.tune_success = False
        self.bank_status = {}
        self.tune_result_report = None
        self.default_time_bound = HIGH_PERF_TIMEOUT_BUILD_EXECUTE if tune_option.get(
            "high_perf", False) else DEFAULT_TIMEOUT_BUILD_EXECUTE
        self.build_run_time_bound = self.default_time_bound
        LOG_INSTANCE.info("ImplTune for [op_type=%s, kernel_name=%s] init succ.", self.op_type, self.kernel_name)
        LOG_INSTANCE.debug("inputs:%s", str(self.inputs))
        LOG_INSTANCE.debug("outputs:%s", str(self.outputs))
        LOG_INSTANCE.debug("attrs:%s", str(self.attrs))

    @staticmethod
    def _parse_profiling_data(profiling_list: List, tune_param_list: List) -> dict:
        """
        parse profiling data

        Parameters
        ----------
        profiling_list: profiling list of tilings
        tune_param_list: tiling list

        Returns
        -------
        profiling_list: parsed profiling data of each tiling
        """
        LOG_INSTANCE.info(
            "_parse_profiling_data begin, profiling_list.size=%s", str(len(profiling_list)))
        if not profiling_list:
            LOG_INSTANCE.error("Empty profiling result list.")
            return {}
        success_kernel_cnt = 0
        total_succ_cost_time = 0
        tiling_to_cost = {}
        for idx, res in enumerate(profiling_list):
            op_name = res.get("opName")
            op_cost_time = int(res.get("aiCoreCostTime").get(op_name, 0))
            if not op_cost_time:
                op_cost_time = int(res.get("opCostTime").get(op_name, 0))
                LOG_INSTANCE.debug("_parse_profiling_data, get opCostTime, not aiCoreCostTime")
            op_cost_time = op_cost_time / 1000
            tune_param = tune_param_list[idx]
            LOG_INSTANCE.debug("_parse_profiling_data op_name=%s, tiling=%s, cost_time[us]=%s",
                               op_name, str(tune_param), str(op_cost_time))

            if op_cost_time > 0:
                success_kernel_cnt = success_kernel_cnt + 1
                tiling_to_cost[tune_param] = op_cost_time
                total_succ_cost_time = total_succ_cost_time + op_cost_time

        success_rate = success_kernel_cnt / len(profiling_list)
        if success_rate <= SUCCESS_RATE_CONTROL:
            LOG_INSTANCE.error("build_and_excute success_rate[%s] is lower than [%s]." %
                               (str(success_rate), str(SUCCESS_RATE_CONTROL)))
            return {}

        LOG_INSTANCE.info(
            "_parse_profiling_data success_kernel_cnt=%s, success_rate=%s",
            str(success_kernel_cnt), str(success_rate))
        return tiling_to_cost

    def do_tune(self) -> bool:
        """
        tune one impl op
        """
        # 1. check op args
        if not self._check_op_param():
            return False

        # 2. query  repository
        self._get_tiling()
        self.exist_repository = True if self.repo_tiling else False

        tune_op_params = TuneOpParam(self.exist_repository, None, None, 0, False, self.tune_option)
        input_args = {"topi_args": {"real_op_type": self.op_type}}
        self.tune_result_report = TuneResultReport(input_args, tune_op_params)

        # 3. if tiling has existed in repo and version is same, and repeat_tune is falseï¼Œstop tune
        if not self._check_tune_condition():
            LOG_INSTANCE.warning(
                "REPEAT_TUNE is false, and the case:%s [info_dict=%s] has existed in repository, it won't be tuned!",
                self.kernel_name, self.info_dict)
            self.tune_result_report.report_tune_res_and_mode_to_opat(True, self.tune_mode)
            return True

        # 4. get tune space from dynamic_and_impl
        tune_param_list = []
        impl_space = self.dynamic_and_impl.split(",")
        for impl in impl_space:
            tune_param_list.append("False") if impl == "True" else tune_param_list.append(impl)

        # 5. evaluate baseline performance
        before_cost, base_cost_time = self._get_default_cost()
        self.build_run_time_bound = base_cost_time * ADJUST_COEFFICIENT

        # 6. evaluate tiling performance and get the best tiling
        best_impl_info = self._performance_evaluate(tune_param_list)
        # 7. save best tiling to repository
        write_ok, self.update_flag = self._write_repository(best_impl_info)
        # 8. post process
        self._report_tune_result(before_cost, best_impl_info)
        return write_ok

    def _report_tune_result(self, before_cost: float, best_impl_info: str) -> None:
        """
        report tune result after write repository
        """
        after_cost = before_cost
        if (best_impl_info.get("cost_time") and self.update_flag):
            after_cost = best_impl_info.get("cost_time")
        self.tune_success = bool(after_cost < COST_MAX_VALUE and before_cost < COST_MAX_VALUE)
        if not self.tune_success:
            LOG_INSTANCE.warning("current tiling cost time[%s] greater than COST_MAX_VALUE[%s]", \
                                 after_cost, COST_MAX_VALUE)
            return
        if self.tune_result_report is not None:
            tune_res_report = TuneResReport(before_cost, after_cost, self.update_flag, self.exist_repository)
            self.tune_result_report.gen_tune_result_status(tune_res_report, self.build_op_name)
            self.tune_result_report.report_tune_res_and_mode_to_opat(self.tune_success, self.tune_mode)

    def _get_tiling(self):
        """
        query tiling by op args

        Returns
        -------
        tiling: str
            the tiling from repository. If not in repository, return empty string
        """
        LOG_INSTANCE.debug("get_tiling: get_op_compile_unique_key begin")
        try:
            info_dict_result = get_op_compile_unique_key(
                self.op_type, self.inputs, self.outputs, self.attrs, self.extra_params, False)
            if isinstance(info_dict_result, str):
                self.info_dict = info_dict_result
            elif isinstance(info_dict_result, list):
                self.info_dict = info_dict_result[0]
        except (RuntimeError, IndexError) as e:
            LOG_INSTANCE.error("get_tiling: get_op_compile_unique_key raise exception: %s", e)
            raise ValueError("get_tiling: get_op_compile_unique_key failed!")
        finally:
            LOG_INSTANCE.info("get_tiling: info_dict=%s", self.info_dict)

        if not self.info_dict:
            msg = "get_tiling: get info_dict failed, info_dict is empty!"
            LOG_INSTANCE.error(msg)
            raise ValueError(msg)
        self.info_dict = self.info_dict.replace('\'', '\"')
        tiling = cann_kb_search(self.info_dict, search_config={"op_type": "impl_type", "full_info": True}, option={})
        self.repo_tiling = {} if not tiling else tiling[0].get("knowledge", {})
        if not isinstance(self.repo_tiling, dict):
            msg = "get_tiling: cann_kb_search failed, repo_tiling: {} is not dict.".format(str(self.repo_tiling))
            LOG_INSTANCE.error(msg)
            raise ValueError(msg)
        self.repo_cost_time = DEFAULT_OM_RUN_THRESHOLD if not tiling \
            else tiling[0].get("cost_time", DEFAULT_OM_RUN_THRESHOLD)

        LOG_INSTANCE.info("get_tiling: repo tiling=%s", str(self.repo_tiling))

    def _get_default_cost(self) -> tuple:
        """
        get default cost without tiling
        support op: matmul
        """
        default_result, cost_time = self._build_and_execute("{}", True)
        cost_dict = ImplTune._parse_profiling_data(default_result, [""])
        if not cost_dict:
            LOG_INSTANCE.warning("Get default cost failed, use default COST_MAX_VALUE!")
            return COST_MAX_VALUE, self.default_time_bound
        return min(cost_dict.values()), math.ceil(cost_time)

    def _build_and_execute(self, op_impl: str, is_base: bool = False) -> tuple:
        """
        Build and excute the om to get profiling data of each tiling

        Parameters
        ----------
        kernel_list: tiling list with cb_struct_key

        Returns
        -------
        profiling_list: the profiling data of each tiling
        """
        cb_task_queue = self.global_mgr["tune_task_d"]
        cb_result = self.global_mgr["tune_result_d"]
        cb_release = self.global_mgr["release_tune_q"]
        timer_queue = self.global_mgr["timer_q"]

        strategy_list = [op_impl]
        cb_dict = {}
        pid = os.getpid()
        time_stamp = str(time.time()).replace(".", "_")[-9:]
        cb_key = "IMPL_%s_%s" % (pid, time_stamp)
        cb_dict[cb_key] = {
            "cb_struct_key": self.cb_struct_key,
            "strategy_list": strategy_list,
            "need_integrate": False,
            "tune_mode": "IMPL",
            "costtime_baseline": DEFAULT_OM_RUN_THRESHOLD
        }
        LOG_INSTANCE.info("_build_and_execute begin, timeout: %d[s]", self.build_run_time_bound)
        timer_queue.put(("start", pid, cb_key))
        cb_task_queue.put(cb_dict)

        # query callback result
        build_begin = time.time()
        profiling_list = []
        build_run_time = 0
        strategy_num = len(strategy_list)
        while True:
            build_run_time = time.time() - build_begin
            if cb_key in cb_result:
                profiling_list = cb_result.get(cb_key)
                cb_release.put(cb_key)
                break
            if not is_base:
                time_bound = max(strategy_num * self.build_run_time_bound, self.default_time_bound)
                if build_run_time > time_bound:
                    LOG_INSTANCE.error("Impl_tune build_and_execute has been waiting longer than %d!", time_bound)
                    break
            time.sleep(TIME_SLEEP_CALLBACK)
        timer_queue.put(("stop", pid, cb_key))
        LOG_INSTANCE.info("_build_and_execute end, profiling_list.size: %d, interval: %s[s]",
                          len(profiling_list), str(build_run_time))
        return profiling_list, build_run_time

    def _performance_evaluate(self, tune_param_list: List[dict]) -> dict:
        """
        Evaluate the performance of tune_param_list

        Parameters
        ----------
        tune_param_list: str
            the tiling space from impl op

        Returns
        -------
        best_impl_info: list
            the best impl info
        """
        # build and execute op to get profiling data
        profiling_list = []

        #add impl build_and_execute task
        for impl in tune_param_list:
            profiling_impl, _ = self._build_and_execute(impl)
            if not profiling_impl:
                LOG_INSTANCE.error("performance_evaluate failed, because failed to build_and_execute.")
                return {}
            profiling_list.extend(profiling_impl)

        # parse best tiling from profiling_list
        best_impl_info = {}
        cost_dict = ImplTune._parse_profiling_data(profiling_list, tune_param_list)
        best_impl = min(cost_dict, key=cost_dict.get)
        min_cost = min(cost_dict.values())
        best_impl_info["impl_info"] = best_impl
        best_impl_info["cost_time"] = min_cost
        if profiling_list:
            self.build_op_name = profiling_list[0].get("opName", "")
        LOG_INSTANCE.debug(
                "performance_evaluate: get best_impl_info succ, best_impl_info:%s",
                str(best_impl_info))
        return best_impl_info

    def _cann_kb_add_save_tiling(self, best_impl_info: dict, tiling_info_msg: str) -> bool:
        knowledge = {}
        impl_info = best_impl_info.get("impl_info")
        if impl_info == "False":
            knowledge["dynamic_compile_static"] = "false"
        else:
            knowledge["dynamic_compile_static"] = "true"
            knowledge["op_impl_switch"] = impl_info

        write_config = {}
        write_config["op_type"] = "impl_type"
        write_config["cost_time"] = best_impl_info.get("cost_time")
        if cann_kb_write(
            self.info_dict, knowledge, write_config, flush=True, option={}) == 0:
            LOG_INSTANCE.debug("save_tiling: cann_kb_add succ, %s", tiling_info_msg)
        else:
            LOG_INSTANCE.error("save_tiling: cann_kb_add failed! %s", tiling_info_msg)
            return False

        LOG_INSTANCE.info("save_tiling succ, %s", tiling_info_msg)
        return True

    def _write_repository(self, best_impl_info: str) -> tuple:
        """
        write repository
        params: best_impl_info
        return:
        1. is process ok
        2. is repository update
        """
        if not best_impl_info:
            LOG_INSTANCE.error(
                "write repository failed, because best_impl_info is empty! op_args:%s, info_dict:%s",
                self.op_args_str, self.info_dict)
            return False, False

        tiling_info_msg = "kernel_name:%s, info_dict:%s, best_impl_info:%s" % (
            self.kernel_name, self.info_dict, best_impl_info)

        LOG_INSTANCE.info("begin to save_tiling, %s", tiling_info_msg)

        # compare with repository tiling
        if self.repo_tiling:
            current_cost_time = best_impl_info.get("cost_time")
            repo_cost_time = self.repo_cost_time * (1 - MIN_OPTIMIZATION_THRESHOLD)
            if current_cost_time > repo_cost_time:
                LOG_INSTANCE.info(
                    "save_tiling: no need to save because current tiling cost time[%s] greater than repo_tiling[%s]",
                    str(current_cost_time), str(repo_cost_time))
                return True, False
        if self._cann_kb_add_save_tiling(best_impl_info, tiling_info_msg):
            return True, True
        return False, False

    def _check_op_param(self) -> bool:
        """
        check whether current op is supported by AOE
        """
        if not (self.inputs and self.outputs and self.kernel_name):
            err_msg = "impl tune op param is illegal, inputs/outputs/kernel_name not support None, \
            inputs:%s, outputs:%s, kernel_name:%s" % (str(self.inputs), str(self.outputs), str(self.kernel_name))
            LOG_INSTANCE.error(err_msg)
            return False
        return True

    def _check_tune_condition(self) -> bool:
        # if enable repeat_tune or tiling not in repository, do tune
        if repeat_tune_flag(self.kernel_name) or not self.repo_tiling:
            return True
        else:
            return False


def impl_tune_main(op_args: str, option: dict) -> bool:
    """
    The main function for impl tune

    Parameters
    ----------
    op_desc: string
        the operator params
    option: dict
        the tune params
    Returns
    -------
    Ture: tune succeed, False: tune failed.
    """
    # transform op args to json format
    op_args_json = check_load_json(op_args)
    # init ImplTune
    impl_tune_manager = ImplTune(op_args_json, option)
    # do tune
    try:
        res = impl_tune_manager.do_tune()
    except (ValueError, TimeoutError) as e:
        LOG_INSTANCE.error("impl_tune failed! op_type: %s, kernel_name:%s, raise exception:%s",
                           impl_tune_manager.op_type, impl_tune_manager.kernel_name, str(e))
        res = False
    finally:
        pass
    if res:
        LOG_INSTANCE.info("impl_tune succ! op_type: %s, kernel_name:%s.",
            impl_tune_manager.op_type, impl_tune_manager.kernel_name)
    return res
