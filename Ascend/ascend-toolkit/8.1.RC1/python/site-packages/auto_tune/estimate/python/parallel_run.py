#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright 2020 Huawei Technologies Co., Ltd

parallel run on device
"""
import os
import re
import fcntl
import json
import shutil
import platform
from collections import namedtuple
from typing import List

from auto_tune.auto_tune_log import LOG_INSTANCE
from auto_tune.common_module.common_util import MeasureResult
from auto_tune.common_module.common_util import get_soc_info
from auto_tune.estimate.python import tnc
from auto_tune.estimate.python.util import get_kernel_meta_dir
from auto_tune.estimate.python.util import run_cmd_comm
from auto_tune.estimate.python.util import check_device_id
from auto_tune.estimate.python.util import ABNORMAL_RESULT_STATUS
from auto_tune.estimate.python.compress_weights import compress_weights_conv2d
from auto_tune.util_atc import FILE_FLAG
from auto_tune.util_atc import FILE_MODE_640
from auto_tune.util_atc import create_dir
from auto_tune.util_atc import remove_files
from auto_tune.util_atc import get_dict_from_json_file

ESTIMATE_CONFIG_PATH = os.path.dirname(os.path.realpath(__file__))
SUCCESS_RATE_CONTROL = 0.66
ONE_MINUTE = 60
EXTRA_TIME_RESERVED = 17
LD_LIBRARY_PATH_ERR = 127
TIME_NUM = 15

SUPPORT_PRODUCT = (
    "Ascend910", "Ascend910A", "Ascend910B", "Ascend910ProA",
    "Ascend910ProB", "Ascend910PremiumA", "Ascend310",
    "Ascend310B1", "Ascend310B2", "Ascend310B3", "Ascend310B4",
    "AS31XM1X",
    "Ascend910B1", "Ascend910B2", "Ascend910B2C", "Ascend910B3", "Ascend910B4", "Ascend910B4-1",
    "Ascend910_9391", "Ascend910_9381", "Ascend910_9392", "Ascend910_9382", "Ascend910_9372", "Ascend910_9362",
    "Ascend610", "Ascend610Lite", "BS9SX1AA", "BS9SX1AB", "BS9SX1AC", "Ascend310P3", "Ascend310P1",
    "BS9SX2AA", "BS9SX2AB", "MC61AM21AA", "MC61AM21AB", "Ascend310P5", "Ascend310P7"
)
HI_PRODUCT = ("Hi3796CV300ES", "Hi3796CV300CS", "SD3403")

RetStatus = namedtuple("RetStatus", ["ret", "ret_info"])


def get_res_from_split_line(result: str) -> tuple:
    """
    get kernel_name, res_status, result_time from result line
    """
    kernel_name, res_status, result_time = str(), int(), int()
    for res_split in result.split(","):
        if "kernelName" in res_split:
            kernel_name = res_split.split(":")[-1]
        if "ResultStatus" in res_split:
            res_status = int(res_split.split(":")[-1])
        if "TotalCycle" in res_split:
            result_time = int(res_split.split(":")[-1])

    return kernel_name, res_status, result_time


def run_kernel_get_result(op_info_dict: dict, ret_info: str) -> None:
    '''
    run_kernel_get_result
    @param op_info_list list contain dict with kernel info
    @param ret_info from run on device
    '''
    re_rule = re.compile("kernelName:[0-9a-zA-Z_]+, ResultStatus:[0-9]+, TotalCycle:[0-9]+")
    res_list = re_rule.findall(ret_info, re.I)
    for result in res_list:
        kernel_name, res_status, result_time = get_res_from_split_line(result)
        for t_op in op_info_dict.get("op_info_list"):
            if t_op.get("kernel_name") in kernel_name:
                t_op["result_status"] = res_status
                t_op["kernel_result"] = result_time


def parse_soc_version(ret_info: str) -> str:
    '''
    parse_soc_version
    @param ret_info from run on device
    @return real soc_version str
    '''
    if "kernel_perf_comm LD_LIBRARY_PATH error" in ret_info:
        return ""
    re_rule = re.compile("real_soc_version:[0-9a-zA-Z]+")
    res_list = re_rule.findall(ret_info, re.I)
    if not res_list:
        return ""
    real_soc_version = res_list[0].split(":")[-1]
    return real_soc_version


def get_real_input(topi_args: dict, op_info_dict: dict, json_params: dict) -> tuple:
    """
    get_real_input
    @param topi_args: topi_args
    @param json_params: kernel generated json_params
    """
    real_file_list_str = str()
    file_list = []
    ret = True

    if get_soc_info().full_soc_version in HI_PRODUCT:
        file_path = os.path.realpath(os.path.join(op_info_dict.get("es_conf").get("host_share_dir"), "tss"))
        remote_path = os.path.realpath(os.path.join(op_info_dict.get("es_conf").get("nfs_share_dir"), "tss"))
    elif get_soc_info().full_soc_version in SUPPORT_PRODUCT:
        file_path = get_kernel_meta_dir()
        remote_path = file_path
    else:
        return False, "", file_list

    if topi_args.get('compress_flag', False) and len(topi_args.get('real_data', [])) == 1:
        real_weight = topi_args.get('real_data')[0].get('data')
        ret, zip_file_name, info_file_name = \
            compress_weights_conv2d(topi_args, real_weight, json_params, file_path)
        zip_file = os.path.join(remote_path, zip_file_name)
        info_file = os.path.join(remote_path, info_file_name)
        real_file_list_str = " 1 %s 2 %s " % (zip_file, info_file)
        if os.path.isfile(os.path.join(file_path, zip_file_name)):
            file_list.append(os.path.join(file_path, zip_file_name))
        if os.path.isfile(os.path.join(file_path, info_file_name)):
            file_list.append(os.path.join(file_path, info_file_name))

    return ret, real_file_list_str, file_list


def run_telnet_on_es(str_cmd: str, es_info: dict, timeout_s: int) -> str:
    '''
    send cmd to es with telnet
    '''
    es_tnc = tnc.TelnetClient(es_info.get('es_ip'), es_info.get('es_port'),
                              es_info.get('es_user'), es_info.get('es_password'))
    ret = es_tnc.execute(str_cmd, 'kernel_perf_comm_finished', timeout=timeout_s)
    return ret


def run_on_es(cmd_param: str, op_info_dict: dict) -> tuple:
    '''
    Combined shell script and run it
    '''
    device_share_dir = op_info_dict.get("es_conf").get("nfs_share_dir")

    kernel_perf_comm_path = os.path.realpath(os.path.join(device_share_dir, "tss", "bin", "kernel_perf_comm"))

    timeout_s = max(int(ONE_MINUTE * len(op_info_dict.get("op_info_list"))), ONE_MINUTE * TIME_NUM)
    out_put_log_path = os.path.realpath(
        os.path.join(op_info_dict.get("es_conf").get('nfs_share_dir'), "tss", "output.log"))
    content = "export LD_LIBRARY_PATH=%s:$LD_LIBRARY_PATH \n timeout %s %s %s > %s 2>&1\n" \
              "if [ $? -eq %s ];then\necho \"kernel_perf_comm LD_LIBRARY_PATH error\" > %s 2>&1\nfi\n" \
              "echo \"kernel_perf_comm_finished\"\n" % ( \
              op_info_dict.get("es_conf").get("es_ld_path"), \
              str(timeout_s - EXTRA_TIME_RESERVED), \
              kernel_perf_comm_path, \
              cmd_param, \
              out_put_log_path, \
              str(LD_LIBRARY_PATH_ERR), \
              out_put_log_path)

    cmd_file = os.path.realpath(os.path.join(op_info_dict.get("es_conf").get('host_share_dir'), "tss", "cmd.sh"))
    output_log = os.path.realpath(os.path.join(op_info_dict.get("es_conf").get('host_share_dir'), "tss", "output.log"))
    if os.path.isfile(cmd_file):
        os.remove(cmd_file)
    if os.path.isfile(output_log):
        os.remove(output_log)

    with os.fdopen(os.open(cmd_file, FILE_FLAG, FILE_MODE_640), "w+") as f_handle:
        f_handle.write(content)

    sh_cmd = "sh %s" % (
        os.path.realpath(os.path.join(op_info_dict.get("es_conf").get('nfs_share_dir'), "tss", "cmd.sh")))

    ret_content = run_telnet_on_es(sh_cmd, op_info_dict.get("es_conf"), timeout_s)
    output_str = str()

    if os.path.isfile(cmd_file):
        os.remove(cmd_file)

    if os.path.isfile(output_log):
        with open(output_log, "r") as file_handle:
            output_str = file_handle.read()
        os.remove(output_log)
    else:
        return False, "LHISI No file generated!"

    if not ret_content:
        return False, "run_on_es output: %s" % output_str

    run_kernel_get_result(op_info_dict, output_str)
    return True, "kernel_perf_comm output:%s" % output_str


def get_kernel_perf_path() -> str:
    """
    get kernel_perf path
    """
    sys_platform = platform.system()
    path_list = []
    if sys_platform == "Windows":
        path_list = os.environ['PATH'].split(";")
    elif sys_platform == "Linux":
        path_list = os.environ['PATH'].split(":")
    else:
        raise OSError("not support OS!")

    kernel_perf_comm_path = None
    for path_info in path_list:
        kernel_perf_comm_path = os.path.realpath(os.path.join(path_info, "kernel_perf_comm"))
        if os.path.isfile(kernel_perf_comm_path):
            break
        kernel_perf_comm_path = None

    return kernel_perf_comm_path


def run_kernel_host(cmd_param: str, op_info_dict: dict) -> tuple:
    """
    run kernel on host
    """
    kernel_perf_comm_path = get_kernel_perf_path()
    if not kernel_perf_comm_path:
        return False, "There is no kernel_perf_comm in PATH!"

    cmd_param = "%s %s" % (kernel_perf_comm_path, cmd_param)

    timeout_s = int(60 * len(op_info_dict.get("op_info_list")))
    ret, output_bytes = run_cmd_comm(cmd_param, timeout=timeout_s)

    if not ret:
        return ret, output_bytes

    run_kernel_get_result(op_info_dict, output_bytes)
    return True, "kernel_perf_comm output:%s" % output_bytes


def get_device_list(device_cnt: int) -> tuple:
    '''
    get_device_list
    @param device_cnt: device_cnt
    '''
    device_id_env = os.environ.get("ASCEND_DEVICE_ID", None)
    if not device_id_env:
        device_id_env = os.environ.get("DEVICE_ID", None)
    if device_id_env and not check_device_id(device_id_env):
        return False, []

    ret_value = True
    device_list = []
    if device_id_env:
        try:
            device_id_env = int(device_id_env)
            device_list = [device_id_env]
        except (TypeError, ValueError):
            ret_value = False
        finally:
            pass
    else:
        for device_id in range(int(device_cnt)):
            device_list.append(device_id)
    return ret_value, device_list


def lock_device(device_list: List[int]) -> List[str]:
    '''
    lock_device
    @param device_list: device_list
    '''
    lock_list = []
    for device_id in device_list:
        home_path = os.environ.get("ASCEND_WORK_PATH", "")
        if not home_path:
            home_path = os.environ.get("HOME", "/")
        else:
            home_path = os.path.join(home_path, "aoe_data")
        lock_folder_path = os.path.realpath(os.path.join(home_path, ".lock"))
        create_dir(lock_folder_path)
        file_path = os.path.join(lock_folder_path, "tune_%s.lock" % device_id)
        es_file = os.fdopen(os.open(file_path, FILE_FLAG, FILE_MODE_640), "w")
        fcntl.flock(es_file.fileno(), fcntl.LOCK_EX)
        lock_list.append(es_file)
    return lock_list


def unlock_device(lock_list: List[str]) -> None:
    '''
    unlock_device
    @param lock_list: lock_list
    '''
    for device_lock in lock_list:
        fcntl.flock(device_lock.fileno(), fcntl.LOCK_UN)
        device_lock.close()


def run_check_soc_version() -> bool:
    '''
    run_check_soc_version: make a fake parameter cmd_param to run on device
    @param None
    @return Bool
    '''
    op_info_dict = {}
    config_file = os.path.join(ESTIMATE_CONFIG_PATH, "config.json")
    with open(config_file, "r") as file_handle:
        op_info_dict = get_dict_from_json_file(file_handle)

    full_soc_version = get_soc_info().full_soc_version
    device_cnt = op_info_dict.get("device_cnt")
    ret, device_list = get_device_list(device_cnt)
    if not ret or not device_list:
        LOG_INSTANCE.error("check_soc_version failed! Can not get device id list.")
        return False
    device_list_str = " ".join(list(map(str, device_list)))
    cmd_param = "%s %s %s %s %s" % (full_soc_version, "2", "5", str(device_cnt), device_list_str)
    op_info_dict["op_info_list"] = [{"kernel_name": "kernel_name"}, {"kernel_name": "kernel_name"}]

    lock_list = lock_device(device_list)
    if full_soc_version in SUPPORT_PRODUCT:
        ret, ret_info = run_kernel_host(cmd_param, op_info_dict)
    elif full_soc_version in HI_PRODUCT:
        if not op_info_dict.get("es_conf"):
            LOG_INSTANCE.error("Check_soc_version failed! There is no es_conf in config.json.")
            return False
        ret, ret_info = run_on_es(cmd_param, op_info_dict)
    else:
        ret = False
    unlock_device(lock_list)

    if not ret:
        LOG_INSTANCE.error("Check soc_version failed, because failed to run cmd on device.")
        return False
    real_soc_version = parse_soc_version(ret_info)
    if not real_soc_version:
        LOG_INSTANCE.error("Check soc_version failed, please check the es_ld_path in config.json as user guide.")
        return False
    if full_soc_version != real_soc_version:
        LOG_INSTANCE.error("Check soc_version failed, because input_soc_version is %s, real_soc_version is %s.",
            full_soc_version, real_soc_version)
        return False
    return True


def get_cmd_params(topi_args: dict, op_info_dict: List[dict], cmd_param: str) -> tuple:
    """
    get cmd params and files_to_remove list
    """
    cmd_suffix = str()
    file_to_remove = []
    work_path = get_kernel_meta_dir()
    for op_info in op_info_dict["op_info_list"]:
        kernel_dict = {}

        kernel_bin_path = os.path.join(work_path, "%s.o" % op_info.get('kernel_name'))
        kernel_json_path = os.path.join(work_path, "%s.json" % op_info.get('kernel_name'))
        fusion_op_path = os.path.join(
            os.environ.get("TUNE_DUMP_PATH", "tune_dump"), "fusion_op_%s.json" % op_info.get('kernel_name'))
        file_to_remove.append(kernel_bin_path)
        file_to_remove.append(kernel_json_path)

        with open(kernel_json_path, "r") as f_handle:
            kernel_dict = json.load(f_handle)
        kernel_name = kernel_dict.get("kernelName", 1)
        ret, real_file_list_str, real_file_list = get_real_input(topi_args, op_info_dict, kernel_dict)
        file_to_remove = file_to_remove + real_file_list

        if os.path.isfile(fusion_op_path):
            file_to_remove.append(fusion_op_path)

        if get_soc_info().full_soc_version in HI_PRODUCT:
            kernel_folder = \
                os.path.realpath(os.path.join(op_info_dict.get("es_conf").get("host_share_dir"), "tss"))
            shutil.copy(kernel_bin_path, kernel_folder)
            kernel_bin_path = os.path.realpath(os.path.join( \
                op_info_dict.get("es_conf").get("nfs_share_dir"), "tss", "%s.o" % str(op_info.get("kernel_name"))))
            kernel_bin_path_host = os.path.join(kernel_folder, "%s.o" % str(op_info.get("kernel_name")))
            file_to_remove.append(kernel_bin_path_host)

        cmd_param = "%s%s %s %s %s %s " % \
                    (cmd_param,
                     str(len(op_info.get('input_size_list'))),
                     str(len(op_info.get('output_size_list'))),
                     str(len(real_file_list)),
                     str(op_info.get('input_memory')),
                     str(op_info.get('output_memory')))
        cmd_suffix = "%s %s %s %s %s " % (cmd_suffix, \
                     kernel_bin_path, \
                     kernel_name, \
                     str(kernel_dict.get("blockDim", 1)), \
                     str(op_info.get('l1_addr_input_flag')))
        l1_addr_offset = op_info.get("l1_addr_offset", 0)
        cmd_suffix = "%s %s %s %s %s %s %s" % (cmd_suffix,
                     " ".join((str(x) for x in op_info.get('input_size_list'))),
                     " ".join((str(x) for x in op_info.get('output_size_list'))),
                     real_file_list_str,
                     " ".join((str(x) for x in op_info.get('input_l1_addr_list'))),
                     " ".join((str(x) for x in op_info.get('output_l1_addr_list'))),
                     "".join(str(l1_addr_offset)))
    cmd_param = "%s %s" % (cmd_param, cmd_suffix)
    return ret, cmd_param, file_to_remove


def get_parallel_run_res(op_info_dict: List[dict]) -> tuple:
    """
    get kernel run results
    """
    success_kernel_cnt = 0
    results_list = []
    inputs_list = []
    for op_info in op_info_dict.get("op_info_list"):
        kernel_result = op_info.get("kernel_result", 0)
        result_status = op_info.get("result_status", ABNORMAL_RESULT_STATUS)
        if kernel_result > 0 and result_status == 0:
            success_kernel_cnt = success_kernel_cnt + 1
            res = MeasureResult(point=op_info.get("tiling_point", None), cost=kernel_result)
            results_list.append(res)
            inputs_list.append(op_info.get("tiling_entity", None))
        else:
            LOG_INSTANCE.warning("[%s] kernel_result[%s], result_status[%s]" % (str(op_info.get('kernel_name')),
                str(kernel_result), str(result_status)))
            LOG_INSTANCE.warning("[%s]tiling_entity:%s" % (str(op_info.get('kernel_name')),
                    str(op_info.get('tiling_entity'))))
            LOG_INSTANCE.warning("[%s]tiling_point:%s" % (str(op_info.get('kernel_name')),
                    str(op_info.get('tiling_point'))))
            LOG_INSTANCE.warning("[%s]tiling_dict:%s" % (str(op_info.get('kernel_name')),
                    str(op_info.get('tiling_dict'))))

    return success_kernel_cnt, results_list, inputs_list


def parallel_run(topi_args: dict, op_info_dict: List[dict]) -> tuple:
    '''
    parallel run on device
    @param topi_args: topi_args
    @param op_info_list: list contain dict with kernel info
    '''
    ret, device_list = get_device_list(op_info_dict.get("device_cnt"))
    if not ret or not device_list:
        return RetStatus(False, "run kernel failed! Can not get device id list"), [], []
    soc_version = get_soc_info().full_soc_version
    cmd_param = "%s %s %s %s " % (soc_version, str(len(op_info_dict.get("op_info_list"))),
                                  str(op_info_dict.get('repeat_count')), str(len(device_list)))

    for device_id in device_list:
        cmd_param = "%s%s " % (cmd_param, device_id)

    ret, ret_info = True, "not support estimate_mode"
    ret, cmd_param, file_to_remove = get_cmd_params(topi_args, op_info_dict, cmd_param)

    lock_list = lock_device(device_list)
    if soc_version in SUPPORT_PRODUCT and ret:
        ret, ret_info = run_kernel_host(cmd_param, op_info_dict)
    elif soc_version in HI_PRODUCT and ret:
        ret, ret_info = run_on_es(cmd_param, op_info_dict)
    unlock_device(lock_list)

    remove_files(file_to_remove)

    success_kernel_cnt, results_list, inputs_list = get_parallel_run_res(op_info_dict)
    if not op_info_dict.get("op_info_list"):
        return RetStatus(False, "run kernel failed! Op info list is empty"), [], []
    success_rate = success_kernel_cnt / len(op_info_dict.get("op_info_list"))
    if success_rate < SUCCESS_RATE_CONTROL:
        LOG_INSTANCE.error("Total .o in device is: %d, success kernel is: %d, success rate is: %.2f." \
                           "Success rate is less than threshold", len(op_info_dict.get("op_info_list")),
                           success_kernel_cnt, success_rate)
        return RetStatus(False, "Failed run kernel too many!\n%s" % ret_info), [], []

    return RetStatus(True, "Parallel Run Success"), results_list, inputs_list
