#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright 2021 Huawei Technologies Co., Ltd

run Qtest sim for Ascend910B
"""
import sys
import os
import shutil
import math
import json
import glob
import importlib
from collections import namedtuple

from auto_tune.common_module.common_util import get_soc_info

from auto_tune.common_module.common_util import MeasureResult
from auto_tune.auto_tune_log import LOG_INSTANCE
from auto_tune.estimate.python.parallel_run import SUCCESS_RATE_CONTROL
from auto_tune.estimate.python.parallel_run import RetStatus
from auto_tune.estimate.python.util import get_kernel_meta_dir
from auto_tune.estimate.python.util import ABNORMAL_RESULT_STATUS
from auto_tune.estimate.python.util import ABNORMAL_KERNEL_RES
from auto_tune.util_atc import FILE_FLAG
from auto_tune.util_atc import FILE_MODE_640

L2_ADDR_TYPE = ["L2", "l2"]
DDR_ADDR_TYPE = ["DDR", "ddr"]

Costparams = namedtuple("Costparams", ["blockdim", "l2_or_ddr_in", "chipname", "qtest_show_log", "all_blk",
                        "dump_html"], defaults=["l2", "cloud_v220", False, False, False])

Qtestparams = namedtuple("Qtestparams", ["qtest_default_path", "dst_path", "function_name"])

Kernelpaths = namedtuple("Kernelpaths", ["kernel_bin_path", "kernel_path", "json_path", "cce_path"],
                         defaults=[None, None, None, None])

CHIPNAME_DICT = {"Ascend310B1": "core_v300",
                 "Ascend310B2": "core_v300",
                 "Ascend310B3": "core_v300",
                 "Ascend310B4": "core_v300",
                 "AS31XM1X": "core_v300",
                 "Ascend910B1": "cloud_v220",
                 "Ascend910B2": "cloud_v220",
                 "Ascend910B2C": "cloud_v220",
                 "Ascend910B3": "cloud_v220",
                 "Ascend910B4": "cloud_v220",
                 "Ascend910B4-1": "cloud_v220",
                 "Ascend910_9391": "cloud_v220",
                 "Ascend910_9381": "cloud_v220",
                 "Ascend910_9392": "cloud_v220",
                 "Ascend910_9382": "cloud_v220",
                 "Ascend910_9372": "cloud_v220",
                 "Ascend910_9362": "cloud_v220"
                 }

def remove_qtest_files(qtest_path: str, op_info: dict, kernel_paths: Kernelpaths) -> None:
    """
    remove extra files
    """
    file_to_remove = glob.glob(os.path.join(qtest_path, op_info.get('kernel_name') + '*'))
    file_to_remove.append(kernel_paths.kernel_bin_path)
    file_to_remove.append(kernel_paths.cce_path)
    file_to_remove.append(kernel_paths.json_path)
    for files in file_to_remove:
        if os.path.isfile(files):
            os.remove(files)


def get_func_line(cce_file: str) -> str:
    """
    get function lines
    """
    # read function time in cce
    find_function = 'extern'
    function_line = str()
    with open(cce_file, 'r', encoding='utf8') as fp:
        for lines in fp.readlines():
            if lines.find(find_function) != -1:
                function_line = lines
                break
    return function_line


def get_qtest_result(blockdim: int, qtest_params: Qtestparams, cost_params: Costparams) -> tuple:
    """
    get qtest_results
    """
    sys.path.append(qtest_params.qtest_default_path)
    run_qtest_obj = importlib.import_module("run_qtest")

    # specify custom input source
    if cost_params.l2_or_ddr_in in L2_ADDR_TYPE:
        custom_inputs = run_qtest_obj.QTest.get_custom_input(
            cost_params.chipname, run_qtest_obj.QTest.CUSTOM_INPUT.L2, 10)
    elif cost_params.l2_or_ddr_in in DDR_ADDR_TYPE:
        custom_inputs = run_qtest_obj.QTest.get_custom_input(
            cost_params.chipname, run_qtest_obj.QTest.CUSTOM_INPUT.DDR, 10)
    else:
        LOG_INSTANCE.error("Please check custom input source.")

    qtest_result = {}
    for k in range(0, blockdim):
        run_qtest_obj.QTest.set_qtest_path(qtest_params.qtest_default_path)
        testbench_path, _ = qtest_params.qtest_default_path.split('/qtest/')
        model_path = os.path.join(testbench_path, 'lib/')
        run_qtest_obj.QTest.set_model_path(model_path)
        qtest = run_qtest_obj.QTest(qtest_params.dst_path, qtest_params.function_name, custom_inputs)
        qtest.set_chip(cost_params.chipname)
        qtest.set_block_idx(k)
        qtest.set_block_num(blockdim)
        qtest.set_thread_id(0)
        qtest.set_thread_dim(1)

        pt = run_qtest_obj.QTest.Pipe_t
        tmp_res = qtest.run_test(
                print_test=True, filter={pt.MTE1, pt.MTE2, pt.MTE3, pt.VEC, pt.CUBE})


    qtest_result['cost'] = tmp_res[0]
    qtest_result['cube_cycle'] = tmp_res[1][pt.CUBE]
    qtest_result['mte1_cycle'] = tmp_res[1][pt.MTE1]
    qtest_result['mte2_cycle'] = tmp_res[1][pt.MTE2]
    qtest_result['mte3_cycle'] = tmp_res[1][pt.MTE3]
    qtest_result['mte2_bytes'] = tmp_res[2][pt.MTE2]

    return qtest_result


def get_kernel_result(op_info: dict, blk_dim: int, qtest_ret: dict) -> None:
    """
    get kernel result
    """
    op_info['kernel_result'] = qtest_ret.get("cost", 0)
    env_blockdim = int(os.environ.get('TVM_TARGET_AIC_BLOCKDIM', 1))
    if blk_dim > env_blockdim:
        mul_cost = qtest_ret.get("cost", 0) * math.ceil(blk_dim / env_blockdim)
        op_info['kernel_result'] = mul_cost


def replace_format(lines: list) -> list:
    """
    modify format
    """
    new_lines = []
    for line in lines:
        line = line.replace("F322F16", "F322BF16")
        new_lines.append(line)
    return new_lines


def qtest_cost(cce_kernel_path: str, qtest_default_path: str, cost_params: Costparams) -> dict:
    """
    get qtest cost time
    """
    # split the path and name
    cce_kernel_name = cce_kernel_path.split(os.sep)[-1]
    dst_path = qtest_default_path + cce_kernel_name
    function_line = get_func_line(cce_kernel_path)
    function_name = function_line.split('void')[-1]
    if function_name.find('(') != -1:
        function_name = function_name.split('(')[0]
    else:
        function_name = function_name.strip()

    # copy file from kernel meta to qtest/
    shutil.copy(cce_kernel_path, dst_path)

    # reformat cce header in order to support qtest estimation
    lines = []
    with open(dst_path, 'r') as fp:
        lines = fp.readlines()

    lines = replace_format(lines)
    s = ''.join(lines)
    with os.fdopen(os.open(dst_path, FILE_FLAG, FILE_MODE_640), 'w') as fp:
        fp.write(s)

    # specify blockdim
    if cost_params.all_blk:
        blockdim = int(blockdim)
    else:
        # only run the first block
        blockdim = 1

    qtest_params = Qtestparams(qtest_default_path, dst_path, function_name)
    return get_qtest_result(blockdim, qtest_params, cost_params)


def update_qtest_res(qtest_results_list: list, qtest_inputs_list: list, op_info: dict, success_kernel_cnt: int) -> int:
    """
    update qtest results
    """
    kernel_result = op_info.get("kernel_result", ABNORMAL_KERNEL_RES)
    result_status = op_info.get("result_status", ABNORMAL_RESULT_STATUS)
    if kernel_result > ABNORMAL_KERNEL_RES and result_status == 0:
        success_kernel_cnt = success_kernel_cnt + 1
        res = MeasureResult(point=op_info.get("tiling_point", None), cost=kernel_result)
        qtest_results_list.append(res)
        qtest_inputs_list.append(op_info.get("tiling_entity", None))

    return success_kernel_cnt


def qtest_run(topi_args: dict, op_info_dict: dict) -> tuple:
    """
    run qtest for Ascend910B and Ascend310B
    """
    if not op_info_dict.get("op_info_list") or not topi_args:
        return RetStatus(False, "run kernel failed!\nop info list is empty"), [], []

    success_kernel_cnt = 0
    qtest_results_list = []
    qtest_inputs_list = []
    for op_info in op_info_dict.get("op_info_list"):
        kernel_paths = Kernelpaths()
        kernel_paths = kernel_paths._replace(
            kernel_bin_path=os.path.join(get_kernel_meta_dir(), "%s.o" % op_info.get('kernel_name')))
        kernel_paths = kernel_paths._replace(kernel_path=kernel_paths.kernel_bin_path.split('.')[0])
        kernel_paths = kernel_paths._replace(cce_path="%s.cce" % kernel_paths.kernel_path,
                                             json_path="%s.json" % kernel_paths.kernel_path)
        with open(kernel_paths.json_path, "r") as f_handle:
            kernel_dict = json.load(f_handle)

        dvc_test_platform_path = os.path.join(os.environ.get("HOME", "/"), 'repos/dvcTestPlatform/')
        dvc_test_platform_path = os.path.realpath(os.environ.get("DVCTESTPLATFORM", dvc_test_platform_path))
        qtest_path = os.path.join(dvc_test_platform_path, 'testbench/qtest/')
        cost_params = Costparams(kernel_dict.get("blockDim", 1), 'l2',
                                 CHIPNAME_DICT.get(get_soc_info().full_soc_version), False, False, False)

        get_kernel_result(op_info, kernel_dict.get("blockDim", 1),
            qtest_cost(kernel_paths.cce_path, qtest_path, cost_params))
        op_info['result_status'] = 0

        # remove files
        remove_qtest_files(qtest_path, op_info, kernel_paths)

        tmp_success_kernel_cnt = update_qtest_res(
            qtest_results_list, qtest_inputs_list, op_info, success_kernel_cnt)
        success_kernel_cnt = tmp_success_kernel_cnt

    success_rate = success_kernel_cnt / len(op_info_dict.get("op_info_list"))

    if success_rate < SUCCESS_RATE_CONTROL:
        LOG_INSTANCE.error("total .o in device is: %d, success kernel is: %d, "
                           "success rate is: %.2f,Success rate is less than "
                           "threshold", len(op_info_dict.get("op_info_list")), success_kernel_cnt, success_rate)
        return RetStatus(False, "Failed run kernel too many!\n"), [], []

    return RetStatus(True, "Parallel Run Success"), qtest_results_list, qtest_inputs_list
