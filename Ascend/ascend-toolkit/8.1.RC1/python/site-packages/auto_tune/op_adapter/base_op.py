#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

Define the base class for op
"""
import os

from auto_tune.util_atc import RepoNameParams

# op and repository name
OP_DICT = {
    "conv2d_backprop_filter": "conv2d_bp_filter",
    "conv2d_backprop_input": "conv2d_bp_input",
    "conv2d": "conv2d_forward",
    "depthwise_conv2d_forward": "depthwise_conv2d",
    "depthwise_bp_filter": "depthwise_bp_filter",
    "depthwise_bp_input": "depthwise_bp_input",
    "convolution_3d": "conv3d_forward",
    "matmul": "matmul",
    "conv3d_backprop_input": "conv3d_bp_input",
    "conv3d_backprop_filter": "conv3d_bp_filter"
}

# TYPE DICT FOR CASENAME
TYPE_DICT = {"float16": "fp16", "float32": "fp32", "uint8": "u8", "int8": "i8", "int32": "i32"}
# Upper repository in custom and build-in
SOC_VERSION_UPPER = ("Hi3796CV300CS", "Hi3796CV300ES", "SD3403",
                     "Ascend310P1", "Ascend310P2", "Ascend310P3", "Ascend310P4", "Ascend310P5", "Ascend310P7",
                     "Ascend310B1", "Ascend310B2", "Ascend310B3", "Ascend310B4",
                     "AS31XM1X",
                     "Ascend910B1", "Ascend910B2", "Ascend910B2C", "Ascend910B3", "Ascend910B4", "Ascend910B4-1",
                     "Ascend910_9391", "Ascend910_9381", "Ascend910_9392", "Ascend910_9382", "Ascend910_9372",
                     "Ascend910_9362",)
NEW_SOC_VERSION = (
    "Ascend610", "Ascend610Lite", "BS9SX1AA", "BS9SX1AB", "BS9SX1AC",
    "BS9SX2AA", "BS9SX2AB", "MC61AM21AA", "MC61AM21AB"
)
ASCEND910_LIST = ("Ascend910A", "Ascend910B", "Ascend910PremiumA", "Ascend910ProA", "Ascend910ProB")
ASCEND910_CORE_NUM_LIST = [2, 4, 8, 16]
ASCEND310P3_CORE_NUM_LIST = [1, 2, 4]
ASCEND310P1_CORE_NUM_LIST = [1, 2, 4, 8]
ASCEND310P5_CORE_NUM_LIST = [1, 2, 4]
ASCEND310P7_CORE_NUM_LIST = [1, 2, 4]
# const 1024
CONST_1024 = 1024
#tbe compile para
PASS_PARAM_NUM = 0
#overhead opt flag
OVERHEAD_OPT_TUNE = False


class BaseOpType:
    '''
    base op_type class,
    Subclasses should implement the parent class
    if your soc_version is old, don't changed the repository name.
    if you add a new soc_version, please use new_repository_name.
    '''

    def __init__(self, op_type: str) -> None:
        '''
        init class
        :param op_type:op_type
        '''
        self.op_type = op_type
        self.pass_param_num = PASS_PARAM_NUM
        self.overhead_opt_tune = OVERHEAD_OPT_TUNE

    @staticmethod
    def calc_matric_feature(task: object) -> None:
        '''
        calc the M,N,K
        :param task: task
        :return: M,N,K
        '''
        raise NotImplementedError()

    @staticmethod
    def get_r(m_axis: int, k_axis: int, task: object) -> int:
        '''
        calc the R
        :param m_axis: M
        :param k_axis: K
        :param task:task
        :return: R
        '''
        if "a_shape" in task.param:
            a_shape = task.param.get("a_shape")
        else:
            a_shape = task.param.get("A_shape")
        r_axis = (m_axis * k_axis / (a_shape[1] * a_shape[4] * a_shape[2] * a_shape[3]))
        return r_axis

    @staticmethod
    def parse_case_for_atc(op_info_dict: dict) -> None:
        """
        transform data method for atc
        :param op_info_dict: dict
        :return:
        """
        raise NotImplementedError()

    @staticmethod
    def get_case_name_suffix(op_info_dict: dict) -> None:
        """
        get case_name
        :param op_info_dict:op_info
        :return: case_name
        """
        raise NotImplementedError()

    def check_new_file_name(self, soc_version: str, aicore_num: int) -> bool:
        '''
        check use new bank file name or not
        :param soc_version, aicore_num
        :return: bool
        '''
        if self.op_type in ["conv2d"]:
            return True
        if soc_version in NEW_SOC_VERSION:
            return True
        if soc_version in ASCEND910_LIST and aicore_num in ASCEND910_CORE_NUM_LIST:
            return True
        if soc_version == "Ascend310P3" and aicore_num in ASCEND310P3_CORE_NUM_LIST:
            return True
        if soc_version == "Ascend310P1" and aicore_num in ASCEND310P1_CORE_NUM_LIST:
            return True
        if soc_version == "Ascend310P5" and aicore_num in ASCEND310P5_CORE_NUM_LIST:
            return True
        if soc_version == "Ascend310P7" and aicore_num in ASCEND310P7_CORE_NUM_LIST:
            return True
        return False

    def record_till_file_name(self, repo_name_params: RepoNameParams) -> str:
        '''
        Modify to file_path of the best record till file name
        :param file:file_path
        :return: modied file_path
        '''
        file_path = ''
        if self.check_new_file_name(repo_name_params.soc_version, repo_name_params.aicore_num):
            file_path = self.new_repository_name(repo_name_params)
        else:
            if repo_name_params.l1_fusion in (False, "false"):
                file_path = self.old_repository_name(repo_name_params.soc_version, repo_name_params.src_file)
            else:
                if self.op_type == "depthwise_conv2d_forward":
                    file_path = self.new_repository_name_depthwise(repo_name_params)
                else:
                    file_path = self.new_repository_name(repo_name_params)
        return file_path

    def old_repository_name(self, soc_version: str, src_file: str) -> str:
        '''
        old repository name
        for example:repository_Hi3796CV300ES_conv2d_forward.json
        params: soc_version:platform, src_file:src_file
        return modied file_path
        '''
        file_list = src_file.split('.')
        if soc_version in SOC_VERSION_UPPER:
            lower_soc_version = soc_version
        else:
            lower_soc_version = soc_version[:1].lower() + soc_version[1:]
        file_path = ""
        if file_list[-1] == "json":
            dir_name = os.path.dirname(src_file)
            file_name = 'repository_{}_{}.{}'.format(lower_soc_version, OP_DICT.get(self.op_type, None), file_list[-1])
            file_path = os.path.join(dir_name, file_name)
        elif file_list[-1] == "csv" or file_list[-1] == "bin":
            file_path = '{}_{}_{}.{}'.format('.'.join(file_list[0:-1]), lower_soc_version,
                                             OP_DICT.get(self.op_type, None), file_list[-1])
        else:
            raise TypeError("Result file type should be json, csv or bin.")
        return file_path

    def new_repository_name(self, repo_name_params: RepoNameParams) -> str:
        '''
        new repository name
        for example:AIC_2_L1_SIZE_1024_L2_FUSION_repository_Ascend310_conv2d_forward.json
        params:
        aicore_num:int
        l1_size:int
        l2_fusion:boolean
        soc_version:platform
        src_file:src_file
        return modified file_path
        '''
        file_list = repo_name_params.src_file.split('.')
        l2_fusion_str = "_L2_FUSION" if repo_name_params.l2_fusion else ""
        base_prefix = 'AIC_{}_L1_SIZE_{}{}'.format(str(repo_name_params.aicore_num),
            str(int(repo_name_params.l1_size / CONST_1024)), l2_fusion_str)
        base_postfix = '{}_{}.{}'.format(repo_name_params.soc_version, OP_DICT.get(self.op_type), file_list[-1])
        file_name = ''
        if file_list[-1] == "json" or file_list[-1] == "bin":
            file_name = '{}_repository_{}'.format(base_prefix, base_postfix)
        elif file_list[-1] == "csv":
            file_name = '{}_cost_model_{}'.format(base_prefix, base_postfix)
        else:
            raise TypeError("Result file type should be json, csv or bin.")
        return os.path.join(os.path.dirname(repo_name_params.src_file), file_name)

    def new_repository_name_depthwise(self, repo_name_params: RepoNameParams) -> str:
        '''
        new repository name
        for example:AIC_2_L1_SIZE_1024_L2_FUSION_repository_Ascend310_conv2d_forward.json
        params: repo_name_params
        return modified file_path
        '''
        file_list = repo_name_params.src_file.split('.')
        l2_fusion_str = "_L2_FUSION" if repo_name_params.l2_fusion else ""
        file_path = ""
        index = repo_name_params.src_file.rfind('/')
        if file_list[-1] == "json":
            file_path = ''.join(repo_name_params.src_file[0:index + 1]) + 'AIC_' + \
                        str(repo_name_params.aicore_num) + '_L1_SIZE_' + \
                        str(int(repo_name_params.l1_size / CONST_1024)) + l2_fusion_str + \
                        '_repository_' + repo_name_params.soc_version + '_' + OP_DICT.get(self.op_type, None) + \
                        '_forward' + '.' + file_list[-1]
        elif file_list[-1] == "csv":
            file_path = ''.join(repo_name_params.src_file[0:index + 1]) + 'AIC_' + \
                        str(repo_name_params.aicore_num) + '_L1_SIZE_' + \
                        str(int(repo_name_params.l1_size / CONST_1024)) + l2_fusion_str + \
                        '_cost_model_' + repo_name_params.soc_version + '_' + OP_DICT.get(self.op_type, None) + \
                        '_forward' + '.' + file_list[-1]
        elif file_list[-1] == "bin":
            file_path = ''.join(repo_name_params.src_file[0:index + 1]) + 'AIC_' + \
                        str(repo_name_params.aicore_num) + '_L1_SIZE_' + \
                        str(int(repo_name_params.l1_size / CONST_1024)) + l2_fusion_str + \
                        '_repository_' + \
                        repo_name_params.soc_version + '_' + OP_DICT.get(self.op_type, None) + \
                        '_forward' + '.' + file_list[-1]
        else:
            raise TypeError("Result file type should be json, csv or bin.")
        return file_path


