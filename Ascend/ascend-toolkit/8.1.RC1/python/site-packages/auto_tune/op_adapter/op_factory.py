#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

Define the class for factory of op
"""
from auto_tune.auto_tune_log import LOG_INSTANCE
from auto_tune.op_adapter.conv2d_adapter import OpConv2d
from auto_tune.op_adapter.conv2d_backprop_input import OpConv2dBackpropInput
from auto_tune.op_adapter.conv2d_backprop_filter import OpConv2dBackpropFilter
from auto_tune.op_adapter.depthwise_conv2d_native import OpDepthwiseConv2dForward
from auto_tune.op_adapter.depthwise_conv2d_backprop_input import OpDepthwiseBpInput
from auto_tune.op_adapter.depthwise_conv2d_backprop_filter import OpDepthwiseBpFilter
from auto_tune.op_adapter.matmul import OpMatmul
from auto_tune.op_adapter.convolution_3d import OpConvolution3d
from auto_tune.op_adapter.conv3d_backprop_input import OpConv3dBackpropInput
from auto_tune.op_adapter.conv3d_backprop_filter import OpConv3dBackpropFilter
from auto_tune.util_atc import RepoNameParams

# OUTPUT TENSOR DICT
OUTPUT_TENSOR_DICT = {1: "single_out", 2: "double_out", 3: "three_out"}


class FactoryOperatorAdapter():
    """
    The factory of op_type:conv, conv_fast,
    conv2d_back_filter, conv2d_back_input, matmul
    """

    def __init__(self, op_type: str) -> None:
        '''
        factory class
        :param op_type: type of operator
        '''
        op_class_str = "op_%s" % op_type.lower()
        op_class_str = adapte_op_type(op_class_str)
        if op_class_str == "OpConv3d":
            op_class_str = "OpConvolution3d"

        try:
            self.op_class_obj = globals()[op_class_str](op_type)
        except KeyError:
            err_msg = 'op_type should be conv2d, conv2d_backprop_input ' \
                      'or conv2d_backprop_filter, or matmul, or conv3d' \
                      'or conv3d_backprop_input, or conv3d_backprop_filter' \
                      'The class %s not implement.' % (op_class_str)
            LOG_INSTANCE.error(err_msg)
            raise ValueError(
                'op_type should be conv2d, conv2d_backprop_input, conv2d_backprop_filter, convolution_3d'
                'conv3d_backprop_input, conv3d_backprop_filter or matmul.')
        finally:
            pass

        self.op_tag_encode = self.op_class_obj.op_tag_encode
        self.pass_param_num = self.op_class_obj.pass_param_num
        self.overhead_opt_tune = self.op_class_obj.overhead_opt_tune

    def calc_matric_feature(self, task: object) -> tuple:
        '''
        calc the M,N,K
        :param task: task
        :return: M,N,K
        '''
        return self.op_class_obj.calc_matric_feature(task)

    def record_till_file_name(self, repo_name_params: RepoNameParams) -> str:
        '''
        Modify to file_path of the best record till file name
        :param file:file_path
        :return: modied file_path
        '''
        return self.op_class_obj.record_till_file_name(repo_name_params)

    def get_r(self, m_axis: int, k_axis: int, task: object) -> int:
        '''
        calc the R
        :param M: M
        :param K: K
        :param task:task
        :return: R
        '''
        return self.op_class_obj.get_r(m_axis, k_axis, task)

    def parse_case_for_atc(self, op_info_dict: dict) -> dict:
        """
        Transform the data into the corresponding
        input required by get_shape_args
        :param op_info_dict:
        :return:
        """
        return self.op_class_obj.parse_case_for_atc(op_info_dict)

    def get_case_name_for_atc(self, op_info_dict: dict) -> str:
        """
        get case_name
        :param op_info_dict:op_info
        :return: case_name
        """
        return contact_fusion_name(op_info_dict) + self.op_class_obj.get_case_name_suffix(op_info_dict)


def adapte_op_type(op_type_name: str) -> str:
    '''
    adapte_op_type
    '''
    split_name_list = [s.capitalize() for s in op_type_name.split('_')]
    capitalized_op_name = "".join(split_name_list)

    return capitalized_op_name


def contact_fusion_name(op_info_dict: dict) -> str:
    """
    contact fusion name
    Parameters
    ----------
    param: fu_op_name

    """
    fu_op_name = op_info_dict.get("fu_op_name")
    out_tensor_num = len(op_info_dict.get("output_shape", []))
    fu_op_name_suffix = "_".join(fu_op_name)
    if out_tensor_num in OUTPUT_TENSOR_DICT and op_info_dict.get("fu_op_num") > 1:
        fu_op_name_suffix = "{}_{}_".format(fu_op_name_suffix, OUTPUT_TENSOR_DICT.get(out_tensor_num))
    else:
        fu_op_name_suffix = "{}_".format(fu_op_name_suffix)
    return fu_op_name_suffix
