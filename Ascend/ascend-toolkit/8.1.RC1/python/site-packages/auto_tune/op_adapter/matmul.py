#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

Define the class for Conv2dBackpropInput
"""
from auto_tune.op_adapter.base_op import BaseOpType
from auto_tune.op_adapter.base_op import TYPE_DICT

PADL_VALUE = 40
PADR_VALUE = 40
FUSED_VALUE_2 = 2
FUSED_VALUE_4 = 4


class OpMatmul(BaseOpType):
    '''
    op matmul implement base_op_type
    '''

    def __init__(self, op_type: str) -> None:
        super(OpMatmul, self).__init__(op_type)
        self.op_tag_encode = 7

    @staticmethod
    def get_case_name_suffix(op_info_dict: dict) -> str:
        """
        get case name suffix
        :param task: op_info_dict
        :return: case_name_suffix
        """
        input_params = op_info_dict.get("input_params").get('matmul')
        input_x1 = input_params.get("input_x1")
        x1_dtype = input_params.get("x1_dtype")
        input_x2 = input_params.get("input_x2")
        x2_dtype = input_params.get("x2_dtype")
        output_y = input_params.get("output_y")
        c_dtype = input_params.get("c_dtype")

        case_name_suffix = str(input_x1[0]) + '_' + \
                           str(input_x1[1]) + '_' + \
                           str(input_x2[0]) + '_' + \
                           str(input_x2[1]) + '_' + \
                           str(output_y[0]) + '_' + \
                           str(output_y[1]) + '_' + \
                           str(TYPE_DICT[x1_dtype]) + '_' + \
                           str(TYPE_DICT[x2_dtype]) + '_' + \
                           str(TYPE_DICT[c_dtype])
        return case_name_suffix

    @staticmethod
    def parse_case_for_atc(op_info_dict: dict) -> dict:
        """
        parse the input case by res_tencor

        Parameters
        ----------
        op_info_dict: dict

        """
        matmul_input = {}
        res_dict = {}

        fused_num = 0
        padl = 0
        padr = 0

        x1_dtype = op_info_dict.get("input_dtype_list")[0]
        x2_dtype = op_info_dict.get("input_dtype_list")[1]
        c_dtype = op_info_dict.get("input_dtype_list")[2]

        x1_format = op_info_dict.get("cube_ori_format_list")[0]
        x2_format = op_info_dict.get("cube_ori_format_list")[1]
        bias_format = op_info_dict.get("cube_ori_format_list")[2]

        if c_dtype == "float32":
            if x1_dtype == "int8":
                padl = PADL_VALUE
                padr = PADR_VALUE
            fused_num = 1
        elif c_dtype == "int32":
            fused_num = FUSED_VALUE_2
        else:
            fused_num = FUSED_VALUE_4

        # get shape
        matmul_input['input_x1'] = op_info_dict.get("input_ori_shape_list")[0]
        matmul_input['input_x2'] = op_info_dict.get("input_ori_shape_list")[1]
        matmul_input['ori_shape'] = op_info_dict.get("input_ori_shape_list")[2]
        matmul_input['output_y'] = op_info_dict.get("input_ori_shape_list")[2]

        matmul_input['x1_dtype'] = x1_dtype
        matmul_input['x2_dtype'] = x2_dtype
        matmul_input['x1_format'] = x1_format
        matmul_input['x2_format'] = x2_format
        matmul_input['fused_num'] = fused_num
        matmul_input['kernel_name'] = op_info_dict.get("fusion_op_name")
        matmul_input['padl'] = padl
        matmul_input['padr'] = padr
        matmul_input['c_dtype'] = c_dtype
        matmul_input['batch'] = 1
        matmul_input['strides'] = [1, 1]
        matmul_input['bias_format'] = bias_format

        res_dict['matmul'] = matmul_input
        return res_dict

    @staticmethod
    def calc_matric_feature(task: object) -> tuple:
        '''
        calc the M,N,K of op matmul
        :param task: task
        :return: M,N,K
        '''
        # According the difference of pad, kh, kw of dE/dX,
        # M is also computed differently
        # if pad is 0, kh, kw are 1, the M is computed by the method
        k_h = task.param.get("B_shape")[2]
        k_w = task.param.get("B_shape")[3]
        param_check = (task.param.get("padu") or task.param.get("padd") or
                       task.param.get("padl") or task.param.get("padr"))
        if not param_check and (k_h == 1) and (k_w == 1):
            m_axis = task.param.get("A_shape")[2] * task.param.get("A_shape")[3] * task.param.get("A_shape")[0]
        else:
            m_axis = task.param.get("A_shape")[2] * \
                task.param.get("strideH_expand") * \
                task.param.get("A_shape")[3] * \
                task.param.get("strideW_expand") * task.param.get("A_shape")[0]
        n_axis = task.param.get("B_shape")[1] * task.param.get("B_shape")[4]
        k_axis = k_h * k_w * task.param.get("A_shape")[1] *  task.param.get("A_shape")[4]
        return m_axis, n_axis, k_axis
