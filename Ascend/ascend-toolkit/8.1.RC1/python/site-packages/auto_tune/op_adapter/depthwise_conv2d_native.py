#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

depthwise_conv2d_native.py
"""

import math
from typing import List

from auto_tune.op_adapter.base_op import BaseOpType
from auto_tune.op_adapter.base_op import TYPE_DICT


def transform_by_format(dilations: List[int], strides: List[int], format_x: str) -> tuple:
    """
    transform by format:nchw,nhwc
    :param dilations: dilations
    :param strides: strides
    :param format_x: format_x
    :return: dlt_h, dlt_w, strideh, stridew
    """
    if format_x == "NHWC":
        strideh = strides[1]
        stridew = strides[2]
        dlt_h = dilations[1]
        dlt_w = dilations[2]
    elif format_x == "NCHW":
        strideh = strides[2]
        stridew = strides[3]
        dlt_h = dilations[2]
        dlt_w = dilations[3]
    else:
        raise RuntimeError("data_format should be NHWC or NCHW")
    return [dlt_h, dlt_w, strideh, stridew]


class OpDepthwiseConv2dForward(BaseOpType):
    '''
    depthwise_conv2d_native implement the base_op_type
    '''

    def __init__(self, op_type: str) -> None:
        '''
        init method
        :param op_type:op_type 'depthwise_conv2d_native'
        '''
        super(OpDepthwiseConv2dForward, self).__init__(op_type)
        self.op_tag_encode = 3

    @staticmethod
    def calc_matric_feature(task: object) -> tuple:
        """
        calculate the matric
        :param task: task
        :return: M,N,K
        """
        task.param["A_shape"] = [int(i) for i in task.param.get("A_shape")]
        task.param["B_shape"] = [int(i) for i in task.param.get("B_shape")]
        h_o = int(math.floor((task.param.get("A_shape")[2] + task.param.get("padu") +
                             task.param.get("padd") - task.param.get("B_shape")[2]) /
                             task.param.get("strideH")) + 1)
        w_o = int(math.floor((task.param.get("A_shape")[3] + task.param.get("padl") +
                             task.param.get("padr") - task.param.get("B_shape")[3]) /
                             task.param.get("strideW")) + 1)
        m_axis = h_o * w_o
        n_axis = task.param.get("B_shape")[0]
        k_axis = task.param.get("A_shape")[1] * task.param.get("A_shape")[4] * \
            task.param.get("B_shape")[2] * task.param.get("B_shape")[3]

        return m_axis, n_axis, k_axis

    @staticmethod
    def get_filter_shape_format(shape_filter: List[int], filter_format: str) -> tuple:
        """
        get filter ori_shape and ori_format
        """
        ori_shape = []
        ori_format = "invalid"
        if filter_format == "NCHW":
            ori_shape = shape_filter
            ori_format = "NCHW"
        elif filter_format == "HWCN":
            ori_shape = [shape_filter[3], shape_filter[2], shape_filter[0], shape_filter[1]]
            ori_format = "NCHW"
        elif filter_format == "NHWC":
            ori_shape = [shape_filter[0], shape_filter[3], shape_filter[1], shape_filter[2]]
            ori_format = "NCHW"
        else:
            raise RuntimeError("only supported tensorflow format")
        return ori_shape, ori_format

    @staticmethod
    def get_case_name_suffix(op_info_dict: dict) -> str:
        """
        get case name suffix
        :param task: op_info_dict
        :return: case_name_suffix
        """
        # get the shape info from op_info_dict
        input_params = op_info_dict.get("input_params").get("depthwise_conv2d_forward")
        shape_x = input_params.get('x').get("ori_shape")
        in_dtype = input_params.get('x').get("dtype")
        shape_w = input_params.get('filter').get("ori_shape")
        w_dtype = input_params.get('filter').get("dtype")
        dlt_h, dlt_w, strideh, stridew = transform_by_format(
                input_params.get("dilations"), input_params.get("strides"), input_params.get("data_format"))
        pads = input_params.get('pads')
        if input_params.get("bias") is None:
            bias_flag = False
        else:
            bias_flag = True

        case_name_suffix = str(shape_x[0]) + '_' + str(shape_x[1]) + '_' + \
            str(shape_x[2]) + '_' + str(shape_x[3]) + '_' + \
            str(shape_w[0]) + '_' + str(shape_w[1]) + '_' + str(shape_w[2]) + '_' + str(shape_w[3]) + '_' + \
            str(TYPE_DICT[in_dtype]) + '_' + str(TYPE_DICT[w_dtype]) + '_' + \
            str(pads[0]) + '_' + str(pads[1]) + '_' + str(pads[2]) + '_' + str(pads[3]) + '_' + \
            str(strideh) + '_' + str(stridew) + '_' + str(dlt_h) + '_' + str(dlt_w) + '_' + str(bias_flag)
        return case_name_suffix

    def parse_case_for_atc(self, op_info_dict: dict) -> dict:
        """
        parse the input case by op_info_dict

        Parameters
        ----------
        op_info_dict: dict

        """
        depthwise_conv2d = {}
        res_dict = {}

        x_format = op_info_dict.get("cube_ori_format_list")[0]
        filter_format = op_info_dict.get("cube_ori_format_list")[1]
        shape_x = op_info_dict.get("cube_ori_shape_list")[0]
        shape_filter = op_info_dict.get("cube_ori_shape_list")[1]

        depthwise_conv2d['x'] = {}
        if x_format == "NCHW":
            depthwise_conv2d.get('x')['ori_shape'] = shape_x
            depthwise_conv2d.get('x')['ori_format'] = "NCHW"
        elif x_format == "NHWC":
            depthwise_conv2d.get('x')['ori_shape'] = [shape_x[0], shape_x[3], shape_x[1], shape_x[2]]
            depthwise_conv2d.get('x')['ori_format'] = "NCHW"
        else:
            raise RuntimeError("only supported NCHW/NHWC")

        depthwise_conv2d.get('x')['dtype'] = op_info_dict.get("cube_dtype_list")[0]

        depthwise_conv2d['filter'] = {}
        filter_ori_shape, filter_ori_format = self.get_filter_shape_format(shape_filter, filter_format)
        depthwise_conv2d.get('filter')['ori_shape'] = filter_ori_shape
        depthwise_conv2d.get('filter')['ori_format'] = filter_ori_format
        depthwise_conv2d.get('filter')['dtype'] = op_info_dict.get("cube_dtype_list")[1]

        for _ in range(len(op_info_dict.get("cube_ori_shape_list")), 4):
            op_info_dict.get("cube_ori_shape_list").append(None)
        if op_info_dict.get("cube_ori_shape_list")[2] is not None:
            depthwise_conv2d['bias'] = {}
            depthwise_conv2d.get('bias')["shape"] = op_info_dict.get("cube_ori_shape_list")[2]
            depthwise_conv2d.get('bias')["dtype"] = op_info_dict.get("cube_dtype_list")[2]
        else:
            depthwise_conv2d['bias'] = None

        if op_info_dict.get("cube_ori_shape_list")[3] is not None:
            depthwise_conv2d['offset_w'] = {}
            depthwise_conv2d.get('offset_w')["shape"] = op_info_dict.get("cube_ori_shape_list")[3]
            depthwise_conv2d.get('offset_w')["dtype"] = op_info_dict.get("cube_dtype_list")[3]
        else:
            depthwise_conv2d['offset_w'] = None

        depthwise_conv2d['strides'] = op_info_dict.get("all_agrs")[0]
        depthwise_conv2d['dilations'] = op_info_dict.get("all_agrs")[1]
        depthwise_conv2d['pads'] = op_info_dict.get("all_agrs")[2]
        depthwise_conv2d['data_format'] = op_info_dict.get("all_agrs")[3]
        depthwise_conv2d['offset_x'] = op_info_dict.get("all_agrs")[4] if len(op_info_dict.get("all_agrs")) > 4 else 0
        depthwise_conv2d['kernel_name'] = op_info_dict.get("fusion_op_name")
        res_dict['depthwise_conv2d_forward'] = depthwise_conv2d

        return res_dict