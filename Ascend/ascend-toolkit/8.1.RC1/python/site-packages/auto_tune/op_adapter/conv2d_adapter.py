#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

conv2d_adpter.py
"""

from collections import namedtuple
import math
from typing import List

from auto_tune.op_adapter.base_op import BaseOpType
from auto_tune.op_adapter.base_op import TYPE_DICT

Formatparams = namedtuple("Formatparams", ["dilations", "inputs", "shape_w", "shape_x", "strides", "weights"])
#tbe compile para
PASS_PARAM_NUM = 16


def transform_by_format(format_params: Formatparams) -> tuple:
    """
    transform by format:nchw,nhwc
    :param dilations: dilations
    :param inputs: input
    :param shape_w: shape_w
    :param shape_x: shape_x
    :param strides: strides
    :param weights: weights
    :return: dlt_h, dlt_w, shape_filter, shape_fm, strideh, stridew
    """
    dlt_h, dlt_w, format_w, shape_fm, strideh, stridew = ori_transform_by_format(format_params.dilations,
            format_params.inputs, format_params.shape_x, format_params.strides, format_params.weights)
    if format_w == "NCHW":
        shape_filter = format_params.shape_w
    elif format_w == "NHWC":
        shape_filter = [format_params.shape_w[0], format_params.shape_w[3],
                        format_params.shape_w[1], format_params.shape_w[2]]
    elif format_w == "HWCN":
        shape_filter = [format_params.shape_w[3], format_params.shape_w[2],
                        format_params.shape_w[0], format_params.shape_w[1]]
    else:
        raise RuntimeError("weights ori_format should be NCHW, NHWC or HWCN.")
    return [dlt_h, dlt_w, shape_filter, shape_fm, strideh, stridew]


def ori_transform_by_format(dilations: List[int], inputs: dict, shape_x: List[int],
                            strides: List[int], weights: dict) -> tuple:
    """
    input ori_shape transform by format:nchw,nhwc
    :param dilations: dilations
    :param inputs: inputs
    :param shape_x: shape_x
    :param strides: strides
    :param weights: weights
    :return: dlt_h, dlt_w, format_w, shape_fm, strideh, stridew
    """
    format_x = inputs.get("ori_format")
    if format_x == "NCHW":
        shape_fm = shape_x
        strideh = strides[2]
        stridew = strides[3]
        dlt_h = dilations[2]
        dlt_w = dilations[3]
    elif format_x == "NHWC":
        shape_fm = [shape_x[0], shape_x[3], shape_x[1], shape_x[2]]
        strideh = strides[1]
        stridew = strides[2]
        dlt_h = dilations[1]
        dlt_w = dilations[2]
    else:
        raise RuntimeError("inputs ori_format should be NCHW or NHWC.")
    format_w = weights.get("ori_format")
    return [dlt_h, dlt_w, format_w, shape_fm, strideh, stridew]


class OpConv2d(BaseOpType):
    '''
    conv2d implement the BaseOpType

    '''

    def __init__(self, op_type: str) -> None:
        '''
        init method
        :param op_type:op_type 'conv2d'
        '''
        super(OpConv2d, self).__init__(op_type)
        self.op_tag_encode = 0
        self.pass_param_num = PASS_PARAM_NUM

    @staticmethod
    def parse_case_for_atc(op_info_dict: dict) -> dict:
        """
        parse the input case by op_info_dict

        Parameters
        ----------
        op_info_dict: dict

        """
        conv2d = {}

        conv2d["conv2d"] = {}
        conv2d.get("conv2d")["inputs"] = {}
        conv2d.get("conv2d").get("inputs")["ori_shape"] = op_info_dict.get("cube_ori_shape_list")[0]
        conv2d.get("conv2d").get("inputs")["dtype"] = op_info_dict.get("cube_dtype_list")[0]
        conv2d.get("conv2d").get("inputs")["ori_format"] = op_info_dict.get("cube_ori_format_list")[0]
        conv2d.get("conv2d")["weights"] = {}
        conv2d.get("conv2d").get("weights")["ori_shape"] = op_info_dict.get("cube_ori_shape_list")[1]
        conv2d.get("conv2d").get("weights")["dtype"] = op_info_dict.get("cube_dtype_list")[1]
        conv2d.get("conv2d").get("weights")["ori_format"] = op_info_dict.get("cube_ori_format_list")[1]
        conv2d.get("conv2d")["bias"] = {}
        conv2d.get("conv2d")["offset_w"] = {}
        if op_info_dict.get("cube_ori_shape_list")[2] is not None:
            conv2d.get("conv2d").get("bias")["ori_shape"] = op_info_dict.get("cube_ori_shape_list")[2]
            conv2d.get("conv2d").get("bias")["dtype"] = op_info_dict.get("cube_dtype_list")[2]
            conv2d.get("conv2d").get("bias")["ori_format"] = op_info_dict.get("cube_ori_format_list")[2]
        else:
            conv2d.get("conv2d")["bias"] = None
        if len(op_info_dict.get("cube_ori_shape_list")) < 4:
            op_info_dict.get("cube_ori_shape_list").append(None)
        if op_info_dict.get("cube_ori_shape_list")[3] is not None:
            conv2d.get("conv2d").get("offset_w")["ori_shape"] = op_info_dict.get("cube_ori_shape_list")[3]
            conv2d.get("conv2d").get("offset_w")["dtype"] = op_info_dict.get("cube_dtype_list")[3]
            conv2d.get("conv2d").get("offset_w")["ori_format"] = op_info_dict.get("cube_ori_format_list")[3]
        else:
            conv2d.get("conv2d")["offset_w"] = None
        if len(op_info_dict.get("all_agrs")[1]) < 4:
            strideh, stridew = op_info_dict.get("all_agrs")[1]
            conv2d.get("conv2d")["strides"] = [1, 1, strideh, stridew]
            conv2d.get("conv2d")["pads"] = op_info_dict.get("all_agrs")[4]
            conv2d.get("conv2d")["dilations"] = op_info_dict.get("all_agrs")[7]
            conv2d.get("conv2d")["offset_a"] = op_info_dict["all_agrs"][2]
        else:
            conv2d.get("conv2d")["strides"] = op_info_dict.get("all_agrs")[0]
            conv2d.get("conv2d")["pads"] = op_info_dict.get("all_agrs")[1]
            conv2d.get("conv2d")["dilations"] = op_info_dict.get("all_agrs")[2]
            conv2d.get("conv2d")["offset_a"] = op_info_dict.get("all_agrs")[3]
        conv2d.get("conv2d")["kernel_name"] = op_info_dict.get("fusion_op_name")
        return conv2d

    @staticmethod
    def get_case_name_suffix(op_info_dict: dict) -> str:
        """
        get case name suffix
        :param task: op_info_dict
        :return: case_name_suffix
        """
        inputs = op_info_dict.get("input_params").get("conv2d").get("inputs")
        shape_x = inputs.get("ori_shape")
        weights = op_info_dict.get("input_params").get("conv2d").get("weights")
        shape_w = weights.get("ori_shape")
        dilations = op_info_dict.get("input_params").get("conv2d").get("dilations")
        strides = op_info_dict.get("input_params").get("conv2d").get("strides")
        format_params = Formatparams(dilations, inputs, shape_w, shape_x, strides, weights)
        dlt_h, dlt_w, shape_filter, shape_fm, strideh, stridew = transform_by_format(format_params)
        in_dtype = inputs.get("dtype")
        w_dtype = weights.get("dtype")
        pads = op_info_dict.get("input_params").get("conv2d").get("pads")
        if op_info_dict.get("input_params").get("conv2d").get("bias") is None:
            bias_flag = False
        else:
            bias_flag = True

        case_name_suffix = '{}_{}_{}_{}_{}_{}_{}_{}_{}_{}_{}_{}_{}_{}_{}_{}_{}_{}_{}'.format(
                            str(shape_fm[0]), str(shape_fm[1]), str(shape_fm[2]), str(shape_fm[3]),
                            str(shape_filter[0]), str(shape_filter[1]), str(shape_filter[2]), str(shape_filter[3]),
                            str(TYPE_DICT[in_dtype]), str(TYPE_DICT[w_dtype]),
                            str(pads[0]), str(pads[1]), str(pads[2]), str(pads[3]),
                            str(strideh), str(stridew),
                            str(dlt_h), str(dlt_w),
                            str(bias_flag))

        return case_name_suffix

    @staticmethod
    def calc_matric_feature(task: object) -> tuple:
        """
        calculate the matric
        :param task: task
        :return: M,N,K
        """
        if "a_shape" in task.param:
            h_o = int(math.floor((task.param.get("a_shape")[2] + task.param.get("pad")[0] + \
                task.param.get("pad")[1] - task.param.get("b_shape")[2]) / task.param.get("stride")[0]) + 1)
            w_o = int(math.floor((task.param.get("a_shape")[3] + task.param.get("pad")[2] + \
                task.param.get("pad")[3] - task.param.get("b_shape")[3]) / task.param.get("stride")[1]) + 1)
            m_dim = h_o * w_o
            n_dim = task.param.get("b_shape")[0]
            k_dim = task.param.get("a_shape")[1] * task.param.get("a_shape")[4] * \
                task.param.get("b_shape")[2] * task.param.get("b_shape")[3]
        else:
            h_o = int(math.floor((task.param.get("A_shape")[2] + task.param.get("padu") + \
                task.param.get("padd") - task.param.get("B_shape")[2]) / task.param.get("strideH")) + 1)
            w_o = int(math.floor((task.param.get("A_shape")[3] + task.param.get("padl") + \
                task.param.get("padr") - task.param.get("B_shape")[3]) / task.param.get("strideW")) + 1)
            m_dim = h_o * w_o
            n_dim = task.param.get("B_shape")[0]
            k_dim = task.param.get("A_shape")[1] * task.param.get("A_shape")[4] * \
                task.param.get("B_shape")[2] * task.param.get("B_shape")[3]
        return m_dim, n_dim, k_dim
