#!/usr/bin/env python3
# -*- coding:utf-8 -*-
"""
Copyright (C) 2021. Huawei Technologies Co., Ltd. All rights reserved.

Define the tik tune function
"""
import json
from typing import List

from tbe.common.register import get_tune_param_check_supported
from tbe.common.register import get_tune_space
from auto_tune.auto_tune_log import LOG_INSTANCE

TIK_VERSION_KEY = "version"
TIK_TUNE_TIMEOUT_KEY = "tune_timeout"
TUNE_PARAM_KEY = "tune_param"
TUNE_PARAM_NAME_KEY = "param"
TUNE_PARAM_VALUE_KEY = "value"
TUNE_PARAM_TYPE_KEY = "type"
TUNE_SUB_PARAM_KEY = "sub_param"
SUB_PARAM_LIST_KEY = "param_list"
TUNE_ADDITIONAL_PARAM_KEY = "additional_param"

MAX_TOTAL_TUNE_PARAM_SIZE = 65537
MAX_BUILD_TUNE_PARAM_SIZE = 500


def _get_value_list(param_dict: dict) -> list:
    if param_dict[TUNE_PARAM_TYPE_KEY] not in ("list", "range"):
        err_msg = "parse_tune_param error, param:%s type:%s is not list or range." % (
            param_dict[TUNE_PARAM_NAME_KEY], param_dict[TUNE_PARAM_TYPE_KEY])
        LOG_INSTANCE.error(err_msg)
        raise ValueError(err_msg)

    values = param_dict[TUNE_PARAM_VALUE_KEY]
    if param_dict[TUNE_PARAM_TYPE_KEY] == "range":
        if len(values) != 2:
            err_msg = "parse_tune_param error, param:%s type is range, but value is %s." % (
                param_dict["param"], str(values))
            LOG_INSTANCE.error(err_msg)
            raise ValueError(err_msg)
        values = list(range(values[0], values[1] + 1))
    return values


def _parse_sub_param(sub_param: dict, sub_tune_space_list: List[dict]) -> None:
    if SUB_PARAM_LIST_KEY not in sub_param:
        return
    param_to_values = {}
    for param in sub_param[SUB_PARAM_LIST_KEY]:
        param_to_values.update({param[TUNE_PARAM_NAME_KEY]: _get_value_list(param)})

    # generate tune space by combinate param_to_values
    for key, values in param_to_values.items():
        tmp_tune_space_list = []
        for sub_tune_param in sub_tune_space_list:
            for value in values:
                tmp_tune_param = {}
                tmp_tune_param.update(sub_tune_param)
                tmp_tune_param.update({key: value})
                tmp_tune_space_list.append(tmp_tune_param)
        sub_tune_space_list.clear()
        sub_tune_space_list.extend(tmp_tune_space_list)


def _parse_tune_param(tune_param: dict) -> List[dict]:
    """
    parse tune param
    """
    LOG_INSTANCE.debug("_parse_tune_param begin, tune_param:%s", str(tune_param))
    top_param_name = tune_param[TUNE_PARAM_NAME_KEY]
    tune_space_list = []
    if TUNE_PARAM_VALUE_KEY in tune_param:
        value_list = _get_value_list(tune_param)
        for value in value_list:
            tune_space_list.append({top_param_name: value})
    else:
        sub_params = tune_param[TUNE_SUB_PARAM_KEY]
        # parse sub_param
        for sub_param in sub_params:
            values_first = sub_param[TUNE_PARAM_VALUE_KEY]
            sub_tune_space_list = []
            sub_tune_space_list.append({top_param_name: values_first})
            _parse_sub_param(sub_param, sub_tune_space_list)
            tune_space_list.extend(sub_tune_space_list)

    LOG_INSTANCE.debug("_parse_tune_param succ, tune_space_list.size:%s", str(len(tune_space_list)))
    return tune_space_list


def _parse_tune_spaces(tune_space_dict: dict, func_for_validator_tune_space: object,
                       op_compute_params: tuple) -> List[str]:
    """
    parse tune space from tik op

    Parameters
    ----------
    tune_space_dict: tune space from tik op
    func_for_validator_tune_space: func to validate tune param
    op_compute_paramsï¼š op params

    Returns
    -------
    tune_space_list: tune tiling
    """
    # parse "tune_param"
    tune_param_list = []
    for tune_param in tune_space_dict[TUNE_PARAM_KEY]:
        tune_param_list.extend(_parse_tune_param(tune_param))

    tune_param_size = len(tune_param_list)
    if tune_param_size > MAX_TOTAL_TUNE_PARAM_SIZE:
        LOG_INSTANCE.error("_parse_tune_spaces, total tune_param's size from op:%d greater than %d, not supported!",
                           tune_param_size, MAX_TOTAL_TUNE_PARAM_SIZE)
        return []
    LOG_INSTANCE.info("_parse_tune_spaces, before validate, total tune_param_list.size:%d", tune_param_size)

    supported_tune_space_list = []
    has_additional_param = TUNE_ADDITIONAL_PARAM_KEY in tune_space_dict
    for tune_param in tune_param_list:
        tune_space = {TUNE_PARAM_KEY: tune_param, TIK_VERSION_KEY: tune_space_dict[TIK_VERSION_KEY]}
        if has_additional_param:
            tune_space[TUNE_ADDITIONAL_PARAM_KEY] = tune_space_dict[TUNE_ADDITIONAL_PARAM_KEY]
         # check whether tune_param is supported by op
        tune_param_str = json.dumps(tune_space)
        is_support = func_for_validator_tune_space(*op_compute_params, tune_param_str)
        LOG_INSTANCE.debug(
            "get_tune_param_check_supported, tune_param_str:%s, is_support:%s", tune_param_str, str(is_support))
        if is_support:
            supported_tune_space_list.append(tune_space)

    supported_tune_space_size = len(supported_tune_space_list)
    if supported_tune_space_size > MAX_BUILD_TUNE_PARAM_SIZE:
        LOG_INSTANCE.error("_parse_tune_spaces, supported_tune_space's size from op:%d greater than %d, not supported!",
                           supported_tune_space_size, MAX_BUILD_TUNE_PARAM_SIZE)
        return []

    LOG_INSTANCE.info("_parse_tune_spaces succ. supported tune_space_list.size:%d, tune_space_list:%s",
                      supported_tune_space_size, str(supported_tune_space_list))
    return supported_tune_space_list


def load_json(json_str: str) -> dict:
    """
    check load json success or not
    :param json_str: json path
    :return: json data
    """
    json_data = {}
    try:
        json_data = json.loads(json_str)
    except (ValueError, TypeError):
        LOG_INSTANCE.error("load json from str failed, json_str: %s", json_str)
    finally:
        pass
    return json_data


def _get_op_compute_params(op_params: dict) -> tuple:
    inputs = op_params["inputs"]
    outputs = op_params["outputs"]
    attrs = op_params["attrs"]
    kernel_name = op_params["kernel_name"]
    if attrs:
        attr_value = (attr.get("value") for attr in attrs)
        op_compute_params = (*inputs, *outputs, *attr_value, kernel_name)
    else:
        op_compute_params = (*inputs, *outputs, kernel_name)
    return op_compute_params


def _check_tune_space_dict(tune_space_dict: dict) -> bool:
    if not tune_space_dict:
        LOG_INSTANCE.error("get tik tune space failed, tune_space_dict from op is empty!")
        return False
    if not (TIK_VERSION_KEY in tune_space_dict and TUNE_PARAM_KEY in tune_space_dict):
        LOG_INSTANCE.error("get tik tune space failed, because the necessary param [%s] or [%s] not in tune params!",
                           TIK_VERSION_KEY, TUNE_PARAM_KEY)
        return False
    return True


def get_tik_tune_space(op_params: dict) -> dict:
    """
    query tik op tiling space by op args

    Parameters
    ----------
    op_params:  tik op params

    Returns
    -------
    complete_tune_param_list: tune tiling list
    """
    LOG_INSTANCE.info("get_tik_tune_space begin, kernel_name:%s", op_params["kernel_name"])
    op_type = op_params["op_type"]
    # 1. get op registed func for tune space
    func_for_get_tune_space = get_tune_space(op_type)
    func_for_validator_tune_space = get_tune_param_check_supported(op_type)
    if not func_for_get_tune_space or not func_for_validator_tune_space:
        LOG_INSTANCE.error(
            "get_tik_tune_space failed, op: %s not regist get_tune_space or get_tune_param_check_supported!", op_type)
        return {}

    # 2. get and check tune space from op
    op_compute_params = _get_op_compute_params(op_params)
    tune_space_str = func_for_get_tune_space(*op_compute_params)
    LOG_INSTANCE.debug("get_tik_tune_space from op succ, optype:%s, tune_space_str=%s", op_type, tune_space_str)

    tune_space_dict = load_json(tune_space_str)
    if not _check_tune_space_dict(tune_space_dict):
        return {}

    complete_tune_space = {}
    # 3. if only to get version, not need to parse sub_tune_param
    if op_params.get("only_get_op_version", False):
        complete_tune_space[TIK_VERSION_KEY] = tune_space_dict.get(TIK_VERSION_KEY)
        LOG_INSTANCE.info("get_tik_tune_space only get version succ, kernel_name:%s", op_params["kernel_name"])
        return complete_tune_space

    # 4. parse tune space
    tune_param_list = _parse_tune_spaces(tune_space_dict, func_for_validator_tune_space, op_compute_params)
    if not tune_param_list:
        LOG_INSTANCE.error("get_tik_tune_space failed, after parse tune_param_list is empty!")
        return {}
    complete_tune_space[TUNE_PARAM_KEY] = tune_param_list

    # 5. parse tune_timeout for build and exec setted by op
    if TIK_TUNE_TIMEOUT_KEY in tune_space_dict:
        complete_tune_space[TIK_TUNE_TIMEOUT_KEY] = tune_space_dict.get(TIK_TUNE_TIMEOUT_KEY)

    LOG_INSTANCE.info("get_tik_tune_space succ, kernel_name:%s", op_params["kernel_name"])
    return complete_tune_space
