#!/usr/bin/env python3
# -*- coding:utf-8 -*-
"""
Copyright (C) 2021. Huawei Technologies Co., Ltd. All rights reserved.

Define the tik tune function
"""

import json
import os
import time
from typing import List

from tbe.common.utils.create_kb_query_key import get_op_compile_unique_key
from tbe.common.repository_manager.interface import cann_kb_write
from tbe.common.repository_manager.interface import cann_kb_search
from auto_tune.auto_tune_log import LOG_INSTANCE
from auto_tune.auto_tune_main import repeat_tune_flag
from auto_tune.get_input_args import check_load_json
from tik_tune.tik_tune_space_parser import TIK_TUNE_TIMEOUT_KEY
from tik_tune.tik_tune_space_parser import TUNE_PARAM_KEY
from tik_tune.tik_tune_space_parser import TIK_VERSION_KEY

TIK_TUNE_SUPPORT_OP_TYPE = ()
SUCCESS_RATE_CONTROL = 0
TIK_TUNE_SPACE_TIMEOUT = 120
DEFAULT_TIMEOUT_BUILD_EXECUTE = 120
MAX_TIMEOUT_BUILD_EXECUTE = 300
TIME_SLEEP_CALLBACK = 1
MIN_OPTIMIZATION_THRESHOLD = 0.05
DEFAULT_OM_RUN_THRESHOLD = 18446744073709551615


class TikTune:
    """
    class for tik op tuning
    """
    def __init__(self, op_args_json: dict, tune_option: dict) -> None:
        super(TikTune, self).__init__()
        self.op_args_str = json.dumps(op_args_json)
        self.op_type = op_args_json["op_type"]
        self.inputs = op_args_json["op_params"]["input_desc"]
        self.outputs = op_args_json["op_params"]["output_desc"]
        # attr_desc's dtype is List(dict)
        self.attrs = op_args_json["op_params"].get("attr_desc", [])
        self.kernel_name = op_args_json["op_params"]["kernel_name"]
        self.extra_params = op_args_json["op_params"].get("extra_param", {})
        self.tiling_key = ""
        self.repo_tiling = {}
        self.cb_struct_key = tune_option.get("cb_struct_key", None)
        self.global_mgr = tune_option["global_mgr"]
        self.timeout_for_build = DEFAULT_TIMEOUT_BUILD_EXECUTE
        LOG_INSTANCE.info("TikTune for [op_type=%s, kernel_name=%s] init succ.", self.op_type, self.kernel_name)
        LOG_INSTANCE.debug("inputs:%s", str(self.inputs))
        LOG_INSTANCE.debug("outputs:%s", str(self.outputs))
        LOG_INSTANCE.debug("attrs:%s", str(self.attrs))

    @staticmethod
    def _parse_profiling_data(profiling_list: List, tune_param_list: List) -> dict:
        """
        parse profiling data

        Parameters
        ----------
        profiling_list: profiling list of tilings
        tune_param_list: tiling list with cb_struct_key

        Returns
        -------
        profiling_list: parsed profiling data of each tiling
        """
        LOG_INSTANCE.info(
            "_parse_profiling_data begin, profiling_list.size=%s", str(len(profiling_list)))
        success_kernel_cnt = 0
        total_succ_cost_time = 0
        tiling_to_cost = {}
        for idx, res in enumerate(profiling_list):
            op_name = res.get("opName")
            op_cost_time = int(res.get("aiCoreCostTime").get(op_name, 0))
            if not op_cost_time:
                op_cost_time = int(res.get("opCostTime").get(op_name, 0))
                LOG_INSTANCE.debug("_parse_profiling_data, get opCostTime, not aiCoreCostTime")
            op_cost_time = op_cost_time / 1000
            tune_param = tune_param_list[idx]
            LOG_INSTANCE.debug("_parse_profiling_data op_name=%s, tiling=%s, cost_time[us]=%s",
                               op_name, str(tune_param), str(op_cost_time))

            if op_cost_time > 0:
                success_kernel_cnt = success_kernel_cnt + 1
                tiling_to_cost[json.dumps(tune_param)] = op_cost_time
                total_succ_cost_time = total_succ_cost_time + op_cost_time

        success_rate = success_kernel_cnt / len(profiling_list)
        if success_rate <= SUCCESS_RATE_CONTROL:
            LOG_INSTANCE.error("build_and_excute success_rate[%s] is lower than [%s]." %
                               (str(success_rate), str(SUCCESS_RATE_CONTROL)))
            return {}

        LOG_INSTANCE.info(
            "_parse_profiling_data success_kernel_cnt=%s, success_rate=%s",
            str(success_kernel_cnt), str(success_rate))
        return tiling_to_cost

    def do_tune(self) -> bool:
        """
        tune one tik op
        """
        # 1. check op args
        if not self._check_op_param():
            return False

        # 2. query tiling from repository
        self._get_tiling()

        # 3. if tiling has existed in repo and version is same, and repeat_tune is falseï¼Œstop tune
        if not self._check_tune_condition():
            LOG_INSTANCE.warning(
                "REPEAT_TUNE is false, and the case:%s [tiling_key=%s] has existed in repository, it won't be tuned!",
                self.kernel_name, self.tiling_key)
            return True

        # 4. get tune space from tik op
        tune_param_list = self._get_tik_tune_param()

        # 5. evaluate tiling performance and get the best tiling
        best_tiling_info = self._performance_evaluate(tune_param_list)

        # 6. save best tiling to repository
        return self._save_tiling(best_tiling_info)

    def _get_tiling(self):
        """
        query tiling by op args

        Returns
        -------
        tiling: str
            the tiling from repository. If not in repository, return empty string
        """
        LOG_INSTANCE.debug("get_tiling: get_op_compile_unique_key begin")
        try:
            tiling_key_result = get_op_compile_unique_key(
                self.op_type, self.inputs, self.outputs, self.attrs, self.extra_params)
            if isinstance(tiling_key_result, str):
                self.tiling_key = tiling_key_result
            elif isinstance(tiling_key_result, list):
                self.tiling_key = tiling_key_result[0]
        except (RuntimeError, IndexError) as e:
            LOG_INSTANCE.error("get_tiling: get_op_compile_unique_key raise exception: %s", e)
            raise ValueError("get_tiling: get_op_compile_unique_key failed!")
        finally:
            LOG_INSTANCE.info("get_tiling: tiling_key=%s", self.tiling_key)

        if not self.tiling_key:
            msg = "get_tiling: get tiling_key failed, tiling_key is empty!"
            LOG_INSTANCE.error(msg)
            raise ValueError(msg)

        tiling = cann_kb_search(self.tiling_key, search_config={"op_type": "tik_vector"}, option={})
        self.repo_tiling = {} if not tiling else tiling[0].get("knowledge", {})
        if not isinstance(self.repo_tiling, dict):
            msg = "get_tiling: cann_kb_search failed, repo_tiling: {} is not dict.".format(str(self.repo_tiling))
            LOG_INSTANCE.error(msg)
            raise ValueError(msg)

        LOG_INSTANCE.info("get_tiling: repo tiling=%s", str(self.repo_tiling))

    def _parse_tune_timeout_from_op(self, tune_space: dict) -> None:
        """
        parse tik tune timeout from op, if greater than MAX_TIMEOUT, will be replaced with MAX_TIMEOUT.
        """
        if TIK_TUNE_TIMEOUT_KEY in tune_space:
            tune_timeout_from_op = tune_space.get(TIK_TUNE_TIMEOUT_KEY)
            if tune_timeout_from_op > MAX_TIMEOUT_BUILD_EXECUTE:
                warn_msg = "_get_tik_tune_param, tune_timeout[%d] s from op is greater than MAX_TIMEOUT[%d] s, \
                    will not be used, replaced with MAX_TIMEOUT" % (tune_timeout_from_op, MAX_TIMEOUT_BUILD_EXECUTE)
                LOG_INSTANCE.warning(warn_msg)
                self.timeout_for_build = MAX_TIMEOUT_BUILD_EXECUTE
            else:
                self.timeout_for_build = tune_timeout_from_op
            LOG_INSTANCE.info("_get_tik_tune_param, timeout_for_build change to %d s, kernel_name=%s",
                              self.timeout_for_build, self.kernel_name)

    def _get_tik_op_version(self) -> str:
        """
        query current version of op

        Returns
        -------
        op_version: current version of op
        """
        LOG_INSTANCE.info("_get_tik_op_version begin, kernel_name=%s", self.kernel_name)
        tune_space = self._get_tik_tune_space(only_get_op_version=True)
        return tune_space.get(TIK_VERSION_KEY, "")

    def _get_tik_tune_param(self) -> List[dict]:
        """
        query tik op tiling params by op args

        Returns
        -------
        tik_tune_param_list: the tiling param list from tik op
        """
        LOG_INSTANCE.info("_get_tik_tune_param begin, kernel_name=%s", self.kernel_name)
        tune_space = self._get_tik_tune_space(only_get_op_version=False)
        self._parse_tune_timeout_from_op(tune_space)
        tik_tune_param_list = tune_space.get(TUNE_PARAM_KEY, [])
        if not tik_tune_param_list:
            err_msg = "the case [%s] stop to tune, because tune_param from op is empty!" % (self.kernel_name)
            LOG_INSTANCE.warning(err_msg)
            raise ValueError(err_msg)
        LOG_INSTANCE.info("_get_tik_tune_param succ, kernel_name=%s, tik_tune_space.size:%d",
                            self.kernel_name, len(tik_tune_param_list))
        return tik_tune_param_list

    def _get_tik_tune_space(self, only_get_op_version: bool = False) -> dict:
        """
        query tik op tiling space by op args

        Returns
        -------
        tik_tune_space: the tiling space from tik op
        """
        LOG_INSTANCE.info("get_tik_tune_space begin, only_get_op_version:%s, kernel_name=%s",
                          str(only_get_op_version), self.kernel_name)
        time_stamp = str(time.time()).replace(".", "_")[-9:]
        op_param_key = "TIK_compile_%s_%s" % (os.getpid(), time_stamp)
        op_param_dict = {}
        op_param_dict[op_param_key] = {
            "op_type": self.op_type,
            "inputs": self.inputs,
            "outputs": self.outputs,
            "attrs": self.attrs,
            "extra_params": self.extra_params,
            "kernel_name": self.kernel_name,
            "only_get_op_version": only_get_op_version
        }
        tune_space_task_q = self.global_mgr["tik_tune_space_task_q"]
        tune_space_task_q.put(op_param_dict)

        tune_space_result_d = self.global_mgr["tik_tune_space_result_d"]
        tune_space_task_begin = time.time()
        while True:
            if op_param_key in tune_space_result_d:
                tune_space = tune_space_result_d.get(op_param_key)
                LOG_INSTANCE.info("get_tik_tune_space end, kernel_name=%s, only_get_op_version:%s",
                                  self.kernel_name, str(only_get_op_version))
                self.global_mgr["release_tik_tune_space_q"].put(op_param_key)
                return tune_space

            if time.time() - tune_space_task_begin > TIK_TUNE_SPACE_TIMEOUT:
                err_msg = "get_tik_tune_space timeout:%d s!" % (TIK_TUNE_SPACE_TIMEOUT)
                LOG_INSTANCE.error(err_msg)
                raise TimeoutError(err_msg)

    def _build_and_execute(self, tune_param_list: List[dict]) -> List[str]:
        """
        Build and excute the om to get profiling data of each tiling

        Parameters
        ----------
        kernel_list: tiling list with cb_struct_key

        Returns
        -------
        profiling_list: the profiling data of each tiling
        """
        cb_task_queue = self.global_mgr["tune_task_d"]
        cb_result = self.global_mgr["tune_result_d"]
        cb_release = self.global_mgr["release_tune_q"]
        timer_queue = self.global_mgr["timer_q"]

        strategy_list = []
        for tune_param in tune_param_list:
            strategy_list.append(json.dumps(tune_param))

        if not strategy_list:
            LOG_INSTANCE.error("_build_and_execute failed, because strategy is empty!")
            return []

        cb_dict = {}
        pid = os.getpid()
        time_stamp = str(time.time()).replace(".", "_")[-9:]
        cb_key = "TIK_%s_%s" % (pid, time_stamp)
        cb_dict[cb_key] = {"cb_struct_key": self.cb_struct_key,
                           "strategy_list": strategy_list,
                           "need_integrate": False,
                           "tune_mode": "TIK",
                           "costtime_baseline": DEFAULT_OM_RUN_THRESHOLD
                           }
        LOG_INSTANCE.info("_build_and_execute begin, timeout: %d[s], tune_param_list.size: %d",
                          self.timeout_for_build, len(tune_param_list))
        timer_queue.put(("start", pid, cb_key))
        cb_task_queue.put(cb_dict)

        # query callback result
        build_begin = time.time()
        profiling_list = []
        while True:
            if cb_key in cb_result:
                profiling_list = cb_result.get(cb_key)
                cb_release.put(cb_key)
                break
            if time.time() - build_begin > self.timeout_for_build:
                LOG_INSTANCE.error("_build_and_execute failed, wait more than time_out:%d[s].", self.timeout_for_build)
                break
            time.sleep(TIME_SLEEP_CALLBACK)
        timer_queue.put(("stop", pid, cb_key))
        LOG_INSTANCE.info("_build_and_execute end, profiling_list.size: %d, interval: %s[s]",
                          len(profiling_list), str(time.time() - build_begin))
        return profiling_list

    def _performance_evaluate(self, tune_param_list: List[dict]) -> dict:
        """
        Evaluate the performance of tune_param_list

        Parameters
        ----------
        tune_param_list: list
            the tiling space from tik op

        Returns
        -------
        best_tiling_info: list
            the best tiling, such as {"tune_param":{xxx}, "perf_info":{"cost_time":xxx}, "additionnal_param":{xxx}}
        """
        # build and execute op to get profiling data
        profiling_list = self._build_and_execute(tune_param_list)
        if not profiling_list:
            LOG_INSTANCE.error("performance_evaluate failed, because failed to build_and_execute.")
            return {}

        # parse best tiling from profiling_list
        best_tiling_info = {}
        tiling_to_cost = TikTune._parse_profiling_data(profiling_list, tune_param_list)
        if tiling_to_cost:
            # tiling_to_cost:: key:tune_param, value:cost_time
            min_cost_tiling_key = min(tiling_to_cost.keys(), key=lambda k: tiling_to_cost[k])
            best_tiling_info = json.loads(min_cost_tiling_key)
            best_tiling_info["perf_info"] = {"cost_time": tiling_to_cost[min_cost_tiling_key]}
            LOG_INSTANCE.debug(
                "performance_evaluate: get best_tiling_info succ, best_tiling_info:%s",
                str(best_tiling_info))
        return best_tiling_info

    def _cann_kb_add_save_tiling(self, best_tiling_info: dict, tiling_info_msg: str) -> bool:
        if cann_kb_write(
            self.tiling_key, best_tiling_info, write_config={"op_type": "tik_vector"}, flush=True, option={}) == 0:
            LOG_INSTANCE.debug("save_tiling: cann_kb_add succ, %s", tiling_info_msg)
        else:
            LOG_INSTANCE.error("save_tiling: cann_kb_add failed! %s", tiling_info_msg)
            return False

        LOG_INSTANCE.info("save_tiling succ, %s", tiling_info_msg)
        return True

    def _save_tiling(self, best_tiling_info: dict) -> bool:
        if not best_tiling_info:
            LOG_INSTANCE.error(
                "save best tiling failed, because best_tiling_info is empty! op_args:%s, tiling_key:%s",
                self.op_args_str, self.tiling_key)
            return False

        tiling_info_msg = "kernel_name:%s, tiling_key:%s, best_tiling_info:%s" % (
            self.kernel_name, self.tiling_key, json.dumps(best_tiling_info))

        LOG_INSTANCE.info("begin to save_tiling, %s", tiling_info_msg)

        # compare with repository tiling
        if self.repo_tiling and best_tiling_info.get(TIK_VERSION_KEY) == self.repo_tiling.get(TIK_VERSION_KEY, "None"):
            current_cost_time = best_tiling_info.get("perf_info").get("cost_time")
            repo_cost_time = self.repo_tiling.get("perf_info").get("cost_time") * (1 - MIN_OPTIMIZATION_THRESHOLD)
            if current_cost_time > repo_cost_time:
                LOG_INSTANCE.info(
                    "save_tiling: no need to save because current tiling cost time[%s] greater than repo_tiling[%s]",
                    str(current_cost_time), str(repo_cost_time))
                return True

        return self._cann_kb_add_save_tiling(best_tiling_info, tiling_info_msg)

    def _check_op_param(self) -> bool:
        """
        check whether current op is supported by AOE
        """
        if self.op_type not in TIK_TUNE_SUPPORT_OP_TYPE:
            err_msg = "tik tune only support %s, the op %s not support." % (
                str(TIK_TUNE_SUPPORT_OP_TYPE), self.op_type)
            LOG_INSTANCE.error(err_msg)
            return False

        if not (self.inputs and self.outputs and self.kernel_name):
            err_msg = "tik tune op param is illegal, inputs/outputs/kernel_name not support None, \
            inputs:%s, outputs:%s, kernel_name:%s" % (str(self.inputs), str(self.outputs), str(self.kernel_name))
            LOG_INSTANCE.error(err_msg)
            return False
        return True

    def _check_tune_condition(self) -> bool:
        # get repeat tune flag
        repeat_tune = repeat_tune_flag(self.kernel_name)
        # if enable repeat_tune or tiling not in repository, do tune
        if repeat_tune or not self.repo_tiling:
            return True
        # current version of op
        op_version = self._get_tik_op_version()
        LOG_INSTANCE.info("_check_tune_condition, op_version:%s, repo_tiling_version:%s",
                          op_version, self.repo_tiling.get(TIK_VERSION_KEY, "None"))
        # if current version of op is diffrent from repo_tiling, do tune
        return self.repo_tiling.get(TIK_VERSION_KEY, "None") != op_version


def tik_tune_main(op_args: str, option: dict) -> bool:
    """
    The main function for tik tune

    Parameters
    ----------
    op_desc: string
        the operator params
    option: dict
        the tune params
    Returns
    -------
    Ture: tune succeed, False: tune failed.
    """
    # transform op args to json format
    op_args_json = check_load_json(op_args)
    # init TikTune
    tik_tune_manager = TikTune(op_args_json, option)
    # do tune
    try:
        res = tik_tune_manager.do_tune()
    except (ValueError, TimeoutError):
        res = False
    finally:
        pass
    if res:
        LOG_INSTANCE.info("tik_tune succ! op_type: %s, kernel_name:%s.",
                          tik_tune_manager.op_type, tik_tune_manager.kernel_name)
    else:
        LOG_INSTANCE.error("tik_tune failed! op_type: %s, kernel_name:%s.",
                           tik_tune_manager.op_type, tik_tune_manager.kernel_name)
    return res
