#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

RL-TUNE
"""
import datetime
from pathlib import Path
import json
import os
import pickle
import sys
from io import StringIO
from contextlib import redirect_stdout
from contextlib import redirect_stderr

from tbe.tvm._ffi.base import TVMError
from tbe.tvm.error_mgr.tbe_python_error_mgr import TBEPythonError
from tbe.common.rl_bank import bank_manager
from te_fusion import fusion_util

from schedule_search import config
from schedule_search import log
from schedule_search import tune_util
from schedule_search import util
from schedule_search import soc_cfg
from schedule_search.atc_rl_manager import msoptune_rl_adapter
from schedule_search.ts_env.estimator.evb import evb_host


TUNE_OPTION_DICT = {}


def get_tune_result_key(ori_op_name, kernel_name):
    """

    :param ori_op_name:
    :param kernel_name:
    :return:
    """
    if not ori_op_name.endswith(kernel_name):
        return "_".join([ori_op_name, kernel_name])

    return ori_op_name


def get_op_sch_list(sch_file_list: list, tune_info: dict) -> list:
    """
    获取算子default schedule列表
    """
    sch_list = []
    for sch_file in sch_file_list:
        try:
            with redirect_stderr(StringIO()), redirect_stdout(StringIO()), open(sch_file, "rb") as file_handler:
                sch = pickle.load(file_handler)
            sch_list.append(sch)
        except (ValueError, IOError, OSError, TVMError, TBEPythonError) as exception:
            log.warn("RL exception occur: can not pickle load %s: %s.", sch_file, repr(exception))
        finally:
            pass

    if sch_list:
        return sch_list

    opp_path = tune_info.get("opp_path", "")
    op_name = tune_info["op_name"]
    kernel_name = tune_info["kernel_name"]
    inputs = tune_info.get("op_args", [])
    soc_cfg.proc_env_info(tune_info["soc_info"])
    if "__" in op_name:
        # 融合算子
        op_func = fusion_util.fusion_op
        op_args = [tune_info.get("op_json", "")]
    else:
        # 单算子
        if os.path.exists(opp_path) and opp_path not in sys.path:
            sys.path.append(opp_path)
        op_impl_module = __import__('impl.' + op_name, fromlist=['1'])
        op_func = getattr(op_impl_module, op_name)
        op_args = list(inputs)

    bank_manager.set_current_op_name(kernel_name)
    try:
        op_func(*op_args)
    except (AttributeError, OSError, ValueError, RuntimeError, TypeError, TVMError, TBEPythonError) as exception:
        log.warn("RL exception occur: op %s can not base build: %s.", op_name, repr(exception))

    sch_list = bank_manager.get_op_res(kernel_name)
    return sch_list


def create_tune_workspace_and_show_file(pid_ts: str, workspace_dir: str) -> (bool, str, str):
    """
    create tune_workspace and tune_show dir
    """
    tune_show_dir = os.path.join(os.getcwd(), "tune_show_%s" % pid_ts)
    tune_workspace = os.path.join(workspace_dir, "tune_workspace_" + pid_ts)
    util.create_dir(tune_workspace)
    util.create_dir(tune_show_dir)
    # 如果创建失败，就不要调优了
    if not os.path.isdir(tune_show_dir) or not os.path.isdir(tune_workspace):
        log.warn("RL tune info: can not create tune show dir, rl tune exit.")
        return False, tune_show_dir, tune_workspace
    return True, tune_show_dir, tune_workspace


def get_res_list(tune_info: dict, curr_dir: str) -> (list, str):
    """
    get res_list
    """
    if isinstance(tune_info.get("sch"), list):
        sch_file_list = [os.path.join(curr_dir, x) for x in tune_info.get("sch")]
        op_outputs_list = tune_info.get("op_outputs")
    else:
        sch_file_list = [os.path.join(curr_dir, tune_info.get("sch"))]
        op_outputs_list = [tune_info.get("op_outputs")]
    ignore_reason = ''
    res_list = []
    sch_list = get_op_sch_list(sch_file_list, tune_info)
    if not sch_list:
        ignore_reason = 'sch_list null'
        sch_list = []
    for i, sch in enumerate(sch_list):
        ret = tune_util.tune_comm_check(sch, tune_info.get("op_type"))
        if not ret:
            ignore_reason = 'comm_check fail'
            break
        if hasattr(sch, 'cce_special') and "op_outputs" in sch.cce_special:
            op_outputs = sch.cce_special["op_outputs"]
        else:
            op_outputs = op_outputs_list[i]
        curr_res = tune_util.get_res_by_output_name(sch, op_outputs)
        res_list.append(curr_res)
    return res_list, ignore_reason


def set_tune_result_key(op_config : dict,
                        op_name_list : list,
                        op_config_list : list,
                        ori_op_name : str) -> None:
    """
    set tune result key
    """
    op_config["tune_result_key"] = get_tune_result_key(ori_op_name, op_config.get("kernel_name"))
    first_index = op_name_list.index(ori_op_name)
    op_config_list[first_index]["tune_result_key"] = \
        get_tune_result_key(op_config_list[first_index]["ori_op_name"],
                            op_config_list[first_index]["kernel_name"])


def get_res_list_and_op_config(tune_json_list: list) -> (list, list):
    """
    get res_list and op_config_list for tune_task
    """
    all_res_list = []
    op_config_list = []
    op_name_list = []
    for tune_json in tune_json_list:
        with open(tune_json, "r") as file_handler:
            tune_info = json.load(file_handler)

        base_kernel = os.path.join(os.path.dirname(tune_json), tune_info.get("base_kernel"))
        res_list, ignore_reason = get_res_list(tune_info, os.path.dirname(tune_json))
        if not res_list or ignore_reason:
            continue

        # 如果命中了bank，却没有打开REPEAT_TUNE，则不重复tune了
        repeat_tune, hit_bank, _ = tune_util.check_repeat_tune(res_list, tune_info.get("kernel_name"))
        if not repeat_tune:
            ignore_reason = 'hit bank'

        all_res_list.append(res_list)
        op_config = {
            "op_name": tune_info.get("op_name"),
            "base_kernel": base_kernel,
            "kernel_name": tune_info.get("kernel_name"),
            "inputs": tune_info.get("op_args", []),
            "tensor_list": tune_info.get("tensor_list", []),
            "opp_path": tune_info.get("opp_path", ""),
            "op_json": tune_info.get("op_json", ""),
            "op_model_name": tune_info.get("op_model_name", ""),
            "ignore_reason": ignore_reason,
            "hit_bank": hit_bank,
            "build_config": soc_cfg.proc_env_info(tune_info.get("soc_info")),
            "golden_input": tune_info.get("golden_input", []),
            "golden_output": tune_info.get("golden_output", []),
            "soc_version": tune_info.get("soc_info", ["Ascend310"])[0]
        }
        ori_op_name = tune_info.get('ori_op_name') if tune_info.get('ori_op_name') \
                      else tune_util.get_ori_op_name(op_config.get('op_model_name'),
                                                     op_config.get('kernel_name'), op_config.get('op_json'))
        op_config['ori_op_name'] = ori_op_name
        # 已经出现过的op, tune result key 加上kernel name， 保证唯一性
        if ori_op_name in op_name_list:
            set_tune_result_key(op_config, op_name_list, op_config_list, ori_op_name)
        op_name_list.append(ori_op_name)

        if 'tik_tensor' in tune_info:
            op_config['tik_tensor'] = tune_info.get('tik_tensor')
        if not os.path.exists(base_kernel):
            op_config['no_base_tune'] = True
        op_config_list.append(op_config)
    return all_res_list, op_config_list


def tune_independently(dump_dir,  # pylint: disable=R0914,R0912,R0915
                       tune_option,
                       pid_ts):
    """
    独立rl tune处理函数
    :param dump_dir:放置rl tune任务信息的dump文件目录
    :param tune_option:rl tune选项字典
    :param pid_ts:pid及时间戳
    :return:bool
    """
    tune_json_list = []
    for path in Path(dump_dir).rglob('*.tune_info.json'):
        tune_json_list.append(str(path))
    if not tune_json_list:
        log.warn("RL tune info: tune_info.json not found in dump dir: %s, rl tune exit.", dump_dir)
        return False

    ret, tune_show_dir, tune_workspace = create_tune_workspace_and_show_file(pid_ts, config.WORKSPACE)
    if not ret:
        log.warn("RL tune info: can not create tune workspace, rl tune exit.")
        return False

    # 在tune_show_dir中添加in_use的FLag
    util.write_to_file(os.path.join(tune_show_dir, 'RL_in_use.flag'),
                       "pid=%s, ts=%s" % (os.getpid(), datetime.datetime.now()))

    all_res_list, op_config_list = get_res_list_and_op_config(tune_json_list)
    if not all_res_list:
        log.warn("RL tune info: can not get output tensors, rl tune exit.")
        tune_util.tune_workspace_clean(tune_workspace, tune_show_dir, tune_option)
        return False

    if "timeout" not in tune_option:
        tune_timeout = tune_util.get_timeout() * len(all_res_list)
        if not tune_timeout:
            tune_util.tune_workspace_clean(tune_workspace, tune_show_dir, tune_option)
            return False
        tune_option["timeout"] = tune_timeout

    for op_config in op_config_list:
        # 不进行调优时，不需要这个flag
        if op_config['ori_op_name'] and not op_config['ignore_reason']:
            util.write_to_file(os.path.join(tune_show_dir, '%s.flag' % op_config['kernel_name']),
                               op_config['ori_op_name'])

    tune_option["tune_workspace"] = tune_workspace
    tune_option["tune_show_dir"] = tune_show_dir
    tss_workspace = os.path.basename(tune_workspace)
    tune_option = util.init_option(tune_option)
    for evb_info in tune_option['evbs']:
        evb_info["tss_workspace"] = tss_workspace
        evb_host.update_evb_info(evb_info)
    TUNE_OPTION_DICT["evbs"] = tune_option.get("evbs", [])
    ret, _ = msoptune_rl_adapter.msoptune(all_res_list, tune_option, op_config_list=op_config_list)
    tune_util.tune_workspace_clean(tune_workspace, tune_show_dir, tune_option)
    return ret


def main():
    """
    rl tune作为独立工具的主入口
    """
    if len(sys.argv) < 2:
        log.err("RL tune info: params error! pelese input 1 param at least: dump_dir.")
        sys.exit(-1)

    log.info("RL tune info: rl tune begin.")
    tune_option = {"rl_tune": True, "auto_schedule_golden": True}
    for i in range(2, len(sys.argv)):
        if "--golden_input" in sys.argv[i]:
            sys_str = sys.argv[i].split("--golden_input=")[1]
            tune_option["golden_input"] = sys_str.strip().split(",")
        elif "--golden_output" in sys.argv[i]:
            sys_str = sys.argv[i].split("--golden_output=")[1]
            tune_option["golden_output"] = sys_str.strip().split(",")
        elif "--" in sys.argv[i]:
            key, value = sys.argv[i].strip().replace("--", "").split("=")
            tune_option[key] = value

    pid_ts = tune_option.get('pid_ts')
    if not pid_ts:
        pid_str = os.getpid()
        time_str = datetime.datetime.now().strftime('%Y%m%d_%H%M%S%f')[:-3]
        pid_ts = "{}_pid{}".format(time_str, pid_str)

    try:
        ret = tune_independently(sys.argv[1], tune_option, pid_ts)
    except KeyboardInterrupt:
        ret = False
        tune_show_dir = os.path.join(os.getcwd(), "tune_show_%s" % pid_ts)
        tune_workspace = os.path.join(config.WORKSPACE,
                                      "tune_workspace_" + pid_ts)
        tune_util.tune_workspace_clean(tune_workspace, tune_show_dir,
                                       TUNE_OPTION_DICT)
    if not ret:
        log.warn("RL tune info: rl tune ret is not meet expectation.")
        return -1

    log.info("RL tune info: rl tune end.")
    return 0


if __name__ == '__main__':
    sys.exit(main())
