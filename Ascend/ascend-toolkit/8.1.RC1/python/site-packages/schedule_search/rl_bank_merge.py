#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

RL-TUNE
"""
import os
import sys
import json
import datetime

from schedule_search import log
from schedule_search.util import create_dir
from schedule_search.util import OPEN_FILE_MODES_640
from schedule_search.util import WRITE_FILE_FLAGS
from tbe.common.rl_bank.rl_bank import get_default_rl_path
from tbe.common.rl_bank.rl_bank import update_bank_dict
from tbe.common.rl_bank.rl_bank import trans_bank_dict
from tbe.common.rl_bank.rl_bank import read_custom_bank
from tbe.common.rl_bank.rl_bank import get_bank_value
from tbe.common.rl_bank.rl_bank import RL_BANK_TICK_INDEX

OPP_PATH = "ASCEND_OPP_PATH"
ASCEND_NORMAL_LEN = 9


def filter_bank(custom_bank: dict, built_in_bank: dict) -> dict:
    """
    filter_bank, keep cheque in custom_bank which is better than built_in_bank
    :param custom_bank:
    :param built_in_bank:
    :return: new_custom_bank
    """
    new_custom_bank = {}
    for key in custom_bank:
        tick = get_bank_value(key, custom_bank)[RL_BANK_TICK_INDEX]
        if key in built_in_bank and built_in_bank[key][1] <= tick:
            continue
        new_custom_bank[key] = custom_bank[key]

    return new_custom_bank


def write_to_new_custom_bank(dst_path: str, soc_version: str, bank_name: str, new_custom_bank: dict) -> None:
    """
    write_to_new_custom_bank
    :param dst_path:
    :param soc_version:
    :param bank_name:
    :param new_custom_bank:
    :return:
    """
    time_stamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S_%f')
    custom_bank_file = '{}_{}.json'.format(bank_name, time_stamp)
    custom_bank_dir = os.path.join(dst_path, soc_version, "vector")
    create_dir(custom_bank_dir)
    custom_bank_path = os.path.join(custom_bank_dir, custom_bank_file)
    custom_bank = trans_bank_dict(new_custom_bank, "to")
    with os.fdopen(os.open(custom_bank_path, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), 'w') as bank_fh:
        json.dump(custom_bank, bank_fh, sort_keys=True, indent=4)


def get_bank_names(bank_path: str) -> list:
    """
    get bank name
    :param bank_path:
    :return: bank_names
    """
    if not os.path.isdir(bank_path):
        return []

    bank_names = []
    for bank_file_name in os.listdir(bank_path):
        bank_file = os.path.join(bank_path, bank_file_name)
        if not os.path.isfile(bank_file) or not bank_file_name.endswith('.json'):
            log.warn("Invalid bank file:%s", bank_file)
            continue

        bank_file_name_splits = bank_file_name.split(".json")[0].split("_")
        bank_name = "_".join(bank_file_name_splits[:4])
        if bank_name not in bank_names:
            bank_names.append(bank_name)

    if not bank_names:
        log.warn("There is no rl json file in src_path:%s", bank_path)

    return bank_names


def classify_src_path(src_path: str) -> dict:
    """
    classify src path
    :param src_path:
    :return: dict_src
    """
    default_custom_bank_path = get_default_rl_path(custom=True)
    src_path_list = src_path.split(":")
    # key: (soc_version, bank_name), value: [src_path0, src_path1]
    dict_src = {}
    for each_src_path in src_path_list:
        each_src_path = os.path.realpath(each_src_path)
        if each_src_path == default_custom_bank_path:
            log.warn("Input src path can not be default custom bank path:%s", default_custom_bank_path)
            continue

        for soc_version in os.listdir(each_src_path):
            custom_bank_dir = os.path.join(each_src_path, soc_version, 'vector')
            bank_names = get_bank_names(custom_bank_dir)
            for bank_name in bank_names:
                dict_src.setdefault((soc_version, bank_name), [])
                dict_src[(soc_version, bank_name)].append(custom_bank_dir)

    return dict_src


def read_built_in_bank(built_in_bank_file: str) -> dict:
    """
    read built in bank
    :param built_in_bank_file: built-in bank file name
    :return: built_in_bank
    """
    built_in_bank = {}
    if os.path.isfile(built_in_bank_file):
        try:
            with open(built_in_bank_file) as fh_bank:
                tmp_bank = json.load(fh_bank)
            built_in_bank = trans_bank_dict(tmp_bank, "from")
        except (OSError, AttributeError, ValueError) as exception:
            log.err("Read built-in bank file failed, bank_file: %s, err_msg: %s", built_in_bank_file, repr(exception))
        finally:
            pass
    return built_in_bank


def rl_merge_offline(src_path: str, dst_path: str) -> bool:
    """
    rl_merge_offline
    :param src_path:
    :param dst_path:
    :return:
    """

    opp_path = os.getenv(OPP_PATH, "/usr/local/Ascend/opp")

    dict_src = classify_src_path(src_path)
    for key in dict_src:
        soc_version, bank_name = key
        custom_bank = {}
        for custom_bank_dir in dict_src[(soc_version, bank_name)]:
            cur_custom_bank, _ = read_custom_bank(custom_bank_dir, bank_name)
            update_bank_dict(custom_bank, cur_custom_bank)

        # 读取对应的built-in bank
        built_in_soc = soc_version
        if len(soc_version) > ASCEND_NORMAL_LEN and soc_version.startswith("A"):
            built_in_soc = soc_version[0:ASCEND_NORMAL_LEN]
        built_in_bank_file = os.path.join(opp_path, "built-in/data/rl", built_in_soc, "%s.json" % bank_name)
        if not os.path.exists(built_in_bank_file):
            built_in_bank_file = os.path.join(opp_path, "data/rl", built_in_soc, "built-in", "%s.json" % bank_name)
        built_in_bank = read_built_in_bank(built_in_bank_file)

        # custom bank的bank，如果对应built-in中更优, 则根据built-in更新
        custom_bank = filter_bank(custom_bank, built_in_bank)
        if custom_bank:
            write_to_new_custom_bank(dst_path, soc_version, bank_name, custom_bank)

    return True


def main():
    """
    RL知识库合并入口
    :return:
    """
    return rl_merge_offline(sys.argv[1], sys.argv[2])


if __name__ == '__main__':
    sys.exit(main())
