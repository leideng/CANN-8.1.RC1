#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from collections import defaultdict


GEMM_OP_ID_LIST = ["gemm-like", "gemm_deep_fuse"]
CONV_OP_ID_LIST = ["conv-like", "conv_deep_fuse"]
MAD_OP_ID_LIST = GEMM_OP_ID_LIST + CONV_OP_ID_LIST
MAD_OP_ID_MAP = {"gemm-like": "gemm_deep_fuse",
                 "conv-like": "conv_deep_fuse"}
MAD_TAG_LIST = ['matmul', "conv_mad"]


def get_depends(sch): # pylint: disable=R0912
    """
    :param sch:
    :return:
    """
    tensors = {}
    for i, stage in enumerate(sch.stages):
        for idx in range(stage.op.num_outputs):
            tensors[stage.op.output(idx)] = i
    dict_inputs = defaultdict(list)
    dict_outputs = defaultdict(list)
    for i, stage in enumerate(sch.stages):
        for input_tensor in stage.op.input_tensors:
            input_index = tensors.get(input_tensor, 0)
            try:
                dict_inputs[i].append(input_index)
                dict_outputs[input_index].append(i)
            except ValueError:
                continue
            finally:
                pass

    return dict_inputs, dict_outputs


def get_sub_tree(stage_index, next_dict, sub_tree_indices):
    """
    :param stage_index:
    :param next_dict:
    :param sub_tree_indices:
    """
    for fwd_index in next_dict[stage_index]:
        if fwd_index not in sub_tree_indices:
            sub_tree_indices.append(fwd_index)
            get_sub_tree(fwd_index, next_dict, sub_tree_indices)


def c_op_identify(sch):
    """
    返回该Schedule是否是一个C OP，返回值如下：
    'no': 不是C OP
    'gemm-like': 像Gemm这样的C OP，这样的OP后面一半的轴不能切，都是规格轴
    'argmax_last-like': 像argmax_last这样的C OP，这样的OP最后一根轴不能切，
    按规格轴处理
    """
    special_id_dict = {}
    for i, stage in enumerate(sch.stages):
        if stage.op.tag == 'argmax_last':
            return 'argmax_last-like'
        if stage.op.tag == 'matmul':
            special_id_dict.setdefault('gemm-like', []).append(i)
        elif stage.op.tag in ['conv_mad', "convolution_im2col_row_major"]:
            special_id_dict.setdefault('conv-like', []).append(i)

    op_id = 'no'
    for id_item in MAD_OP_ID_MAP:
        if id_item not in special_id_dict:
            continue
        op_id = id_item

    if op_id == 'no':
        return op_id

    if op_id not in special_id_dict:
        return op_id

    if len(special_id_dict.get(op_id)) == 1:
        return op_id

    last_mad_stage = special_id_dict.get(op_id)[-1]
    dict_fanin, _ = get_depends(sch)
    subtree = []
    get_sub_tree(last_mad_stage, dict_fanin, subtree)
    for mad_index in special_id_dict.get(op_id):
        if mad_index in subtree:
            return MAD_OP_ID_MAP.get(op_id)

    return op_id


def update_stage_tag_type(op_schedule_info):
    """
    更新stage_info的tag和type
    :param op_schedule_info:
    """
    stages_info = op_schedule_info.stages_info
    fanin_dict = op_schedule_info.real_fanin_dict
    for i, stage_info in enumerate(stages_info):
        stages_type = stage_info.get("type", [])
        stage_scope = stage_info.get("scope")
        if stage_info["tag"] == "conv_l1fuse_reshape" and \
                "CacheWrite" in stages_type:
            stage_index = fanin_dict[i][0]
            stages_info[stage_index].setdefault('type', [])
            if 'l1fuse_leaf' not in stages_info[stage_index]['type']:
                stages_info[stage_index]['type'].append('l1fuse_leaf')
                stages_info[stage_index]['tag'] = "mem_copy"
        elif 'l1fuse_leaf' in stages_type and stage_scope != "local.L1":
            # 原始stage后面会做inline，因此这里去掉l1fuse_leaf
            stages_info[i]['type'].remove('l1fuse_leaf')
        elif 'leaf' in stages_type:
            stages_info[i]['tag'] = "mem_copy"


def is_cut_l1_k(t2c_params, stage_index):
    '''
    看临近的mad stage，看是否切了大K
    '''
    # 没找到mad就当没切处理
    cut_k = False
    stages = t2c_params.schedule.stages
    mad_stage_indexs = t2c_params.cube_info_dict.get("mad_stage", [])
    for mad_stage_index in mad_stage_indexs:
        if mad_stage_index in t2c_params.fanout_sub_tree[stage_index]:
            k_factor = t2c_params.cleaned_actions[mad_stage_index][0]
            stage = stages[mad_stage_index]
            if k_factor != stage.op.reduce_axis[0].dom.extent.value:
                return True
            return False
    return cut_k
