#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
add cheque to specify bank
"""
import json
import os
import pickle
from typing import Union
from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.platform import SHORT_SOC_VERSION
from tbe.common.platform import FULL_SOC_VERSION
from tbe.common.rl_bank.rl_bank import BUILT_IN_DATA_RL
from tbe.common.rl_bank.rl_bank import add_case
from tbe.common.rl_bank.cheque import gen_cheque
from tbe.common.rl_bank.rl_bank import get_default_rl_path
from tbe.common.rl_bank.rl_bank import get_custom_rl_path
from tbe.common.rl_bank.rl_bank import write_bank
from tbe.common.rl_bank.withdraw import withdraw
from tbe.common.utils import log
from tbe.common.rl_bank.rl_bank import satisfy_bank


def get_output_tensors(output_tensors: list, output_names: Union[list, object], load_obj: object) -> None:
    """
    get real output tensors
    :param output_tensors:
    :param output_names: output names in a list or generator
    :param load_obj: pickle load object
    :return:
    """
    for output_name in output_names:
        for i in range(len(load_obj.stages)):
            stage = load_obj.stages[i]
            # support for tuple_reduce_sum
            if output_name.startswith("%s_v" % (stage.op.name)):
                out_idx = int(output_name.split('_v')[-1])
                output_tensors.append(stage.op.output(out_idx))
            elif output_name == stage.op.name:
                out_idx = 0
                output_tensors.append(stage.op.output(out_idx))


def diff_code(output_tensors: list, cheque_list: list, real_schedule_code: list) -> None:
    """
    Helper function. Returns a string containing the unified diff of two list
    :param output_tensors: output_tensors to generate expected shcedule code
    :param cheque_list: cheque_list to generate expected schedule code
    :param real_schedule_code: actual
    :return:
    """
    #  gen_sch_by_cheque
    _, draw_code_lines = withdraw(output_tensors, cheque_list)
    print("=" * 80)
    print("\n".join(draw_code_lines))
    print("=" * 80)
    import difflib
    diff = difflib.unified_diff(draw_code_lines, real_schedule_code)
    diff_output = '\n'.join(diff)
    if diff_output:
        print(diff_output)


def get_outputs(code_line_list: list) -> (list, list):
    """
    get_outputs
    :param code_line_list: shcedule_code_list
    :return: output_tensors, real_schedule_code
    """
    output_tensors = []
    output_names = []
    schedule_code = False
    real_schedule_code = []
    for code_line in code_line_list:
        if not code_line.strip():
            continue
        if "#op_outputs:" in code_line:
            output_names = (output.strip() for output in code_line.split("#op_outputs:")[1].split(","))
        elif "pickle.loads(" in code_line:
            tensor_pickle_byte = code_line.split("pickle.loads(b'")[-1][:-2].encode(
                'ISO-8859-1').decode('unicode-escape').encode('ISO-8859-1')
            load_obj = pickle.loads(tensor_pickle_byte)
            get_output_tensors(output_tensors, output_names, load_obj)
        elif "create_schedule" in code_line:
            schedule_code = True
        elif "config = dict()" in code_line or "return sch" in code_line:
            schedule_code = False
        else:
            if schedule_code and not code_line.startswith("    #"):
                real_schedule_code.append(code_line.strip())
    return output_tensors, real_schedule_code


def get_schedule_code(sch_py_path: str) -> list:
    """
    parse schedule py
    :param sch_py_path: best schedule py file path
    :return: schedule_codes_list
    """
    # "add cheque sch_py_path:" is smoke condition
    log.info("add cheque sch_py_path:%s", sch_py_path)
    with open(sch_py_path, 'r') as file_handler:
        file_content = file_handler.read()
    code_lines = file_content.split("\n")
    schedule_codes_list = []
    for i, code_line in enumerate(code_lines):
        if code_line.startswith("def dsl_func_"):
            start = i
        elif code_line == "    return sch":
            end = i
            schedule_codes_list.append(code_lines[start: end + 1])
    if not schedule_codes_list:
        schedule_codes_list = [code_lines]
    return schedule_codes_list


def get_cheque_from_sch(sch_py_path: str, kernel_name: str) -> list:
    """
    get cheque which format is same as rl bank
    :param sch_py_path: best sch py file path
    :param kernel_name: op kernel name
    :return: cheque
    """
    stop_sign, output_tensors_list, cheque_list = get_output_and_cheque_list(sch_py_path, kernel_name)
    if stop_sign or not output_tensors_list or not cheque_list or len(output_tensors_list) != len(cheque_list):
        log.warn("op %s can't get output and cheque_list.", kernel_name)
        return []

    cheque = []
    if isinstance(output_tensors_list, list) and isinstance(output_tensors_list[0], list):
        for i, _ in enumerate(output_tensors_list):
            cheque.extend(cheque_list[i])
    else:
        cheque = cheque_list
    log.info("get cheque from sch end, kernel_name: %s, cheque: %s.", kernel_name, cheque)
    return cheque


def get_output_and_cheque_list(sch_py_path: str, kernel_name: str) -> (bool, list, list):
    """
    get output_tensors_list and cheque_list from schedule_codes_list
    :param sch_py_path: best sch py file path
    :param kernel_name: op kernel name
    :return: T/F, output_tensors_list, cheque_list
    """
    stop_sign = False
    if not sch_py_path:
        log.warn("op %s has no searched schedule stratagy.", kernel_name)
        return True, [], []

    schedule_codes_list = get_schedule_code(sch_py_path)
    output_tensors_list = []
    cheque_list = []
    for schedule_codes in schedule_codes_list:
        # get output_tensors
        output_tensors, real_schedule_code = get_outputs(schedule_codes)
        if not output_tensors:
            raise RuntimeError("get output_tensors from schedule py file fail.")
        # gen cheque
        cheque = gen_cheque(schedule_codes, kernel_name=kernel_name)
        if not cheque:
            log.debug("op %s genearte cheque invalid", kernel_name)
            return True, output_tensors_list, cheque_list
        cheque_list.append(cheque)
        output_tensors_list.append(output_tensors)
        # show code diff if enable DIFF_CODE
        if os.getenv("DIFF_CODE", "False").lower() == "true":
            diff_code(output_tensors, cheque, real_schedule_code)

    return stop_sign, output_tensors_list, cheque_list


def _get_bank_json_path(bank_file: str, bank_type: str) -> str:
    """
    get_bank_json_path by soc_version
    :param bank_file: bank file name
    :param bank_type: bank type, e.g. custom
    :return: bank_json_path
    """
    soc_version = get_soc_spec(SHORT_SOC_VERSION)
    if bank_type == 'custom':
        _, bank_dir = get_custom_rl_path()
        # if assign TUNE_BANK_PATH, custom bank path is TUNE_BANK_PATH/soc_version/vector
        bank_type = "vector"
        soc_version = get_soc_spec(FULL_SOC_VERSION)
        bank_json_path = os.path.join(bank_dir, soc_version, bank_type, "%s.json" % bank_file)
    else:
        bank_dir = get_default_rl_path()
        bank_json_path = os.path.join(bank_dir, soc_version, "%s.json" % bank_file) if \
            BUILT_IN_DATA_RL in bank_dir else os.path.join(bank_dir, soc_version, bank_type, "%s.json" % bank_file)

    return bank_json_path


def add_cheque_to_bank_by_sch(sch_py_path: str,
                       bank_type: str,
                       bank_file: str,
                       op_info_str: str = "") -> bool:
    """
    add_cheque_to_bank_by_sch
    :param sch_py_path: best schedule py file path
    :param bank_type: bank type, e.g. custom
    :param bank_file: bank file path
    :param kernel_name: kernel name
    :param op_info_str: kernel_name@op_type@shape
    :return: T/F
    """
    if not os.path.exists(sch_py_path):
        raise RuntimeError("%s not exists" % sch_py_path)

    if bank_type not in ["custom", "built-in"]:
        raise RuntimeError("bank_type must be custom or built-in,while is %s" % bank_type)

    # maybe start with best_
    parse_base_name = os.path.basename(sch_py_path).strip('best_').split('_')
    best_tick = int(parse_base_name[0])
    base_tick = int(parse_base_name[1])
    if not satisfy_bank(base_tick, best_tick, 'in'):
        raise RuntimeError("base_tick: %s best_tick: %s, satisfy_bank check fail!" % base_tick, best_tick)

    kernel_name = op_info_str.split("@")[0]
    stop_sign, output_tensors_list, cheque_list = get_output_and_cheque_list(sch_py_path, kernel_name)
    if stop_sign:
        log.warn("op_info: %s can't get cheque_list", op_info_str)
        return False

    bank_json_path = _get_bank_json_path(bank_file, bank_type)
    if add_case(output_tensors_list, cheque_list, best_tick, bank_json_path, op_info_str):
        return True
    return False


def add_cheque_to_bank(best_cheque_info: dict,
                       bank_type: str,
                       bank_file: str,
                       op_info_str: str = "") -> bool:
    """
    add_cheque_to_bank
    :param best_cheque_info: a dict, including "base_tick" "best_tick" "bank_key" "cheque"
    :param bank_type: bank type, e.g. custom
    :param bank_file: bank file path
    :param kernel_name: kernel name
    :param op_info_str: kernel_name@op_type@shape
    :return: T/F
    """
    if bank_type not in ["custom", "built-in"]:
        raise ValueError(
            "add_cheque_to_bank failed, bank_type must be custom or built-in, while is %s." % bank_type)

    best_tick = best_cheque_info.get("best_tick")
    base_tick = best_cheque_info.get("base_tick")
    if not satisfy_bank(base_tick, best_tick, 'in'):
        raise RuntimeError("base_tick: %s best_tick: %s, satisfy_bank check fail!" % base_tick, best_tick)

    # read bank file and update current cheque
    base_key_actions_dict = {}
    bank_json_path = _get_bank_json_path(bank_file, bank_type)
    if os.path.exists(bank_json_path):
        with open(bank_json_path) as json_file:
            base_key_actions_dict = json.load(json_file)

    bank_key = best_cheque_info.get("bank_key")
    cheque_list = best_cheque_info.get("cheque")
    if isinstance(bank_key, list):
        if not (len(bank_key) == len(cheque_list)):
            log.debug("The length of bank key and the length of cheque list do not match.")
            return False
        for idx, key in enumerate(bank_key):
            base_key_actions_dict.update({key: json.dumps((cheque_list[idx], best_tick, op_info_str))})
    else:
        base_key_actions_dict.update({bank_key: json.dumps((cheque_list, best_tick, op_info_str))})

    write_bank(bank_json_path, base_key_actions_dict)
    log.debug("add cheque to the bank end, bank file path: %s, op info str: %s.", bank_json_path, op_info_str)
    return True


def try_add_cheque(sch_py_path: str,
                   bank_type: str,
                   bank_file: str,
                   op_info_str: str = "",
                   best_cheque_info: dict = None) -> (bool, str):
    """
    try_add_cheque
    :param sch_py_path: best schedule py file path
    :param bank_type: bank type, custom or built-in
    :param bank_file: bank file path
    :param op_info_str: kernel_name@op_type@shape
    :param best_cheque_info: a dict, including "base_tick" "best_tick" "bank_key" "cheque"
    :return:
    """
    try:
        if best_cheque_info:
            ret = add_cheque_to_bank(best_cheque_info, bank_type, bank_file, op_info_str)
        else:
            ret = add_cheque_to_bank_by_sch(sch_py_path, bank_type, bank_file, op_info_str)
        return ret, ""
    except Exception as excp:  # pylint: disable=broad-except
        log.error("try add cheque failed, best_cheque_info: %s, bank_type: %s, bank_file: %s, op_info_str: %s",
                  best_cheque_info, bank_type, bank_file, op_info_str)
        return False, "sch_py_path:%s add cheque to %s bank fail:%s" % (sch_py_path, bank_type, str(excp))
    finally:
        pass
