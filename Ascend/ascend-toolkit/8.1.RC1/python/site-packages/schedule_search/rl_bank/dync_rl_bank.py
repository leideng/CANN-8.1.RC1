#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
dync rl bank
"""
import copy
import hashlib
from typing import NoReturn
from typing import List
from typing import Dict

import numpy
from tbe import tvm
from tbe.dsl.base import operation
from tbe.common.utils import log
from tbe.common.rl_bank import search_bank
from tbe.common.rl_bank.withdraw import gen_sch_by_cheque
from tbe.common.rl_bank.dync_rl_merge_range_rule import RANGE_CMP_SYMBOL_LIST
from tbe.common.rl_bank.dync_rl_merge_range_rule import get_merge_expr_rules

RL_BASE_KERNEL_KEY = 0xff00000000000000
BLOCK_SPLIT_INFO_NOT_USE_INDEX = []
UB_SPLIT_INFO_NOT_USE_INDEX = [0, 3]


class DyncRLBank:
    """
    dynamic rl bank, to gerenate schedule_list
    """
    def __init__(self,
                 output_tensors: List,
                 op_info: Dict = None,
                 sync_tensor: list = None) -> NoReturn:
        self._output_tensors = output_tensors
        self._op_info = op_info
        self._sync_tensor = sync_tensor

        self._op_pattern = None

        self._create_sch_ctx_nums = 0
        self._withdraw_succ_cheque_id = []
        self._compute_attrs = []
        self._tune_info_lists = []
        self._cheque_lists = []
        self._sch_infos = {}
        self._rl_schedules = []

        self._rl_compute_pattern = None

        self._rl_bank_info_for_cpt = {}


    @staticmethod
    def _vars_name_to_int(vars_: List) -> List:
        """
        vars name to int
        1xxxx：Indicates the shape variable corresponding to different dynamic_axis inputs.
                different input: last 4-5 loc, different axis: 2-3 loc
                for example: 10101: first input, first dynamic axis
        2xxxx：Factor variable corresponding to block split
        3xxxx：Factor variable corresponding to ub split
        :param vars_:
        :return: new_var_names
        """
        new_var_names = []
        for var in vars_:
            if isinstance(var, str):
                var_name = var
            else:
                var_name = var.get_name()

            names = list(filter(None, var_name.split('_')))

            if names[0] == 'dim':
                new_var_names.append(10000 + int(names[1]) * 100 + int(names[2]))
            elif names[0] == 'block':
                new_var_names.append(20000 + int(names[2]))
            elif names[0] == 'ub':
                new_var_names.append(30000 + int(names[2]))
        return new_var_names

    @staticmethod
    def _package_range_info(range_str: str, dynamic_axis_name: List) -> List:
        """
        parse range_str to generate range_info for runtime
        range_info:
        [ dync_axis_inds: [[], [], []...] : dynamic axis index for variable operation
          mod_vals:        []              : right value of the modulo operation
          cmp_symbols:     []              : comparison symbol
          right_vals:      []              : right value of range expression
        ]
        And, length of dync_axis_inds/mod_vals/cmp_symbols/right_vals is all equal
        :param range_str:
        :return:
        """
        def merge_similar_range_expr(variant_range_info: List) -> List:
            """
            merge range expr by rules:
            1. Combine <= and >= of the same variable into <=&&>=.
               If the left and right values are the same, combine them into ==.
            2. Multiple x==1&&y==1 are combined into x*y==1
            in which, variant_range_info is a variant range_info
            variant_range_info:
            [[dync_axis_ind, mod_val, cmp_symbol, right_value], ...]
            :param variant_range_info:
            :return:
            """
            merged_range_info = copy.deepcopy(variant_range_info)
            merge_expr_rule_funcs = get_merge_expr_rules()
            for rule_func in merge_expr_rule_funcs:
                merged_range_info = rule_func(merged_range_info)
            return merged_range_info

        def convert_variant_to_normal_expr(variant_range_info: List) -> List:
            """
            Converts a deformed range expression to its final form
            :param variant_range_info:
            :return:
            """
            dync_axis_inds = []
            mod_vals = []
            cmp_symbols = []
            right_vals = []
            for v_info in variant_range_info:
                dync_axis_inds.append(v_info[0])
                mod_vals.append(v_info[1])
                cmp_symbols.append(v_info[2])
                right_vals.append(v_info[3])

            return [dync_axis_inds, mod_vals, cmp_symbols, right_vals]

        variant_range_info = []
        for expr_str in range_str.split("&&"):
            for symbol in RANGE_CMP_SYMBOL_LIST:
                if symbol in expr_str:
                    cmp_symbol = RANGE_CMP_SYMBOL_LIST.index(symbol)
                    parts_by_symbol = expr_str.split(symbol)
                    right_val = [int(parts_by_symbol[1])] * 2
                    mod_str = parts_by_symbol[0]
                    if "%" in parts_by_symbol[0]:
                        parts_by_mod = parts_by_symbol[0].split("%")
                        if int(parts_by_mod[1]) & (int(parts_by_mod[1]) - 1):
                            raise RuntimeError("The right operand of the modulo must be an integer power of 2.")
                        else:
                            mod_val = int(parts_by_mod[1])
                        mod_str = parts_by_mod[0]
                    else:
                        mod_val = -1
                    parts_by_multi = mod_str.split("*")
                    dync_axis_ind = sorted(dynamic_axis_name.index(name) for name in parts_by_multi)
                    variant_range_info.append([dync_axis_ind, mod_val, cmp_symbol, right_val])
                    break
        try:
            new_range_info = merge_similar_range_expr(variant_range_info)
        except Exception as e:
            log.warn("can not merge similar range_expr, exception is : %s, skip this operation!", e)
            new_range_info = variant_range_info
        finally:
            pass

        return convert_variant_to_normal_expr(new_range_info)

    @staticmethod
    def _package_tiling_meta_info(bank_tiling_meta_info: List) -> List:
        """
        Re-package the pattern based on the bank_info format.
        :param bank_tiling_meta_info:
        :return:
        """
        def gen_new_split_info(del_index_list, old_split_info):
            new_split_info = []
            for ind, ele in enumerate(old_split_info):
                if ind not in del_index_list:
                    new_split_info.append(ele)
            return new_split_info

        tiling_meta_info = []
        # append block_split_info
        block_split_info = gen_new_split_info(BLOCK_SPLIT_INFO_NOT_USE_INDEX, bank_tiling_meta_info[0])
        tiling_meta_info.append(block_split_info)

        # append every ub_split_info
        for split_info in bank_tiling_meta_info[1]:
            ub_split_info = gen_new_split_info(UB_SPLIT_INFO_NOT_USE_INDEX, split_info)
            tiling_meta_info.append(ub_split_info)

        # append workspace_size_list info
        if len(bank_tiling_meta_info) > 2:
            tiling_meta_info.append(bank_tiling_meta_info[2])
        else:
            tiling_meta_info.append([])

        return tiling_meta_info

    def query_dync_rl_bank(self) -> [bool, List]:
        """
        query from dynamic rl bank json
        :return: exec_ret, rl_schedules
        """
        # debug info
        op_info_dfs_tensor_list = []
        if self._op_info is not None:
            op_info_dfs_tensor_list = self._op_info.get("dfs_tensor_list", "")
        context_ori, op_infos = search_bank.get_op_context_infos()
        op_name = op_infos.get("op_name", "")
        kernel_name = op_infos.get("kernel_name", "")
        log.debug("Auto search bank info: query dynamic rl bank begin, op_name: %s, kernel_name: %s,"
                  "out_tensors: %s, op_info_dfs_tensor_list: %s.",
                  op_name, kernel_name, self._output_tensors, op_info_dfs_tensor_list)

        # Obtain tune_info in the knowledge base based on the output tensor.
        repository_infos = search_bank.get_cheque(self._output_tensors, op_info=self._op_info,
                                                  op_infos=op_infos, context=context_ori)
        if not repository_infos:
            log.info('Unfortunately, the hit end with unsuccessful, and the repository was null!')
            return False, []

        # Parse tune_info and group tune_info by queue.
        self._parse_tune_infos(repository_infos)

        # get pattern in the compute context.
        self._get_pattern_by_compute_context()

        # Withdraw schs for different check_lists.
        withdraw_ret = False
        if self._cheque_lists:
            withdraw_ret, self._rl_schedules = self._withdraw_dync_rl_schs_by_cheque_lists()
        if not withdraw_ret:
            log.info('Unfortunately, all cheque withdraw end with unsuccessful!')
            return False, []

        try:
            # package the runtime rl bank info base to generate bank_info for different compute.
            bank_info_ret = self._gen_dync_rl_bank_info()
        except Exception as e:
            log.warn("can not generate dynamic rl bank info, exception is : %s", e)
            bank_info_ret = False
        finally:
            pass

        if not bank_info_ret:
            log.info('Unfortunately, hit succeed, '
                     'but can not generate rl bank info, please check it.')
            # Clear the context created by the rl and disable the rl optimization result.
            for _ in range(self._create_sch_ctx_nums):
                operation.get_context().get_current_compute().get_schedules().pop()
            return False, []

        # add build arg
        operation.add_build_arg("double_buffer_non_reuse", True)

        log.info('Congratulations, hit dynamic rl bank!')

        return True, self._rl_schedules

    def _parse_tune_infos(self, repository_infos: List) -> NoReturn:
        """
        parse tune info from repository bank
        :param repository_infos:
        :return:
        """
        if len(repository_infos) < 3:
            raise RuntimeError("Auto search bank info error: the length of repository's value is not correct, "
                               "please check rl_bank.")

        self._compute_attrs = repository_infos[0]
        self._cheque_lists = repository_infos[1]
        self._tune_info_lists = repository_infos[2]

    def _get_pattern_by_compute_context(self) -> NoReturn:
        """
        get pattern
        :return:
        """
        curr_compute_context = operation.get_context().get_current_compute()
        self._op_pattern = curr_compute_context.get_pattern()

    def _withdraw_dync_rl_schs_by_cheque_lists(self) -> [bool, List]:
        """
        withdraw dynamic rl schs by cheque_lists
        :return:
        """
        rl_schedules = []
        withdraw_ret = False
        for i, cheque_list in enumerate(self._cheque_lists):
            # create schedule context
            with operation.schedule() as rl_sch_context:
                self._create_sch_ctx_nums += 1
                rl_sch_context.add("sch_pattern", "rl_sch")

                # Convert each cheque_list to sch.
                ret, rl_sch = gen_sch_by_cheque(self._output_tensors, cheque_list, self._sync_tensor)
                if ret and isinstance(rl_sch, tvm.Schedule):
                    tiling_key = self._gen_dync_rl_tiling_key(i)
                    rl_sch.tiling_key = tiling_key

                    rl_sch_context.add("tiling_key", tiling_key)
                    rl_sch_context.add("cheque_id", i)

                    search_bank.add_sch_additional_entry(rl_sch, "original_outs",
                                                         rl_sch.cce_special["orign_out_tensor"])
                    search_bank.add_sch_additional_entry(rl_sch, "real_outs", rl_sch.cce_special["real_out_tensor"])
                    search_bank.add_sch_additional_entry(rl_sch, "context", rl_sch_context)

                    withdraw_ret = True
                    rl_schedules.append(rl_sch)
                    self._withdraw_succ_cheque_id.append(i)

            if not ret:
                log.info('current cheque %s withdraw end with unsuccessful!', i)
                # pop schedule context while withdraw runtimeError
                operation.get_context().get_current_compute().get_schedules().pop()

        return withdraw_ret, rl_schedules

    def _gen_md5_kernel_key(self, cheque_id: int) -> str:
        """
        generate kernel_key by md5
        :return:
        """
        # kernel_key：rl_bank_key+cheque_id+random_num
        rl_bank_key = search_bank.get_rl_bank_key(self._output_tensors, self._op_info)
        random_num = int(numpy.random.randint(0, 100000000, 1))
        kernel_key_str = "{}+{}+{}".format(rl_bank_key, cheque_id, random_num)

        key_md5 = hashlib.md5()
        key_md5.update(kernel_key_str.encode())
        key_md5_digest = key_md5.hexdigest()[-8:]

        return key_md5_digest

    def _gen_dync_rl_tiling_key(self, cheque_id: int) -> int:
        """
        generate dynamic rl tiling_key
        :return:
        """
        # generate md5 kernel_key
        key_md5_digest = self._gen_md5_kernel_key(cheque_id)

        # if kernel_key is unique, add it to operatorContext.
        # And not, re-generate
        used_rl_kernel_key = copy.deepcopy(operation.get_context().get('_rl_kernel_key'))
        if used_rl_kernel_key is not None:
            while key_md5_digest in used_rl_kernel_key:
                log.info("kernel_key conflicts, regenerate!")
                key_md5_digest = self._gen_md5_kernel_key(cheque_id)
            operation.get_context().get('_rl_kernel_key').append(key_md5_digest)
        else:
            operation.get_context().add('_rl_kernel_key', [key_md5_digest])

        # generate hexadecimal tiling_key
        tiling_key = int(key_md5_digest, 16) | RL_BASE_KERNEL_KEY

        return tiling_key

    def _get_pattern_from_compute_attrs(self):
        """
        generate compute_pattern by compute_attrs
        :return:
        """
        compute_pattern = self._compute_attrs[0]
        pattern_str = []

        # get inputs shape list
        inputs_shape_list = compute_pattern[0]
        all_shape_str = []
        for shape in inputs_shape_list:
            all_shape_str.extend([str(e) for e in shape])
        pattern_str.append("_".join(all_shape_str))

        # get attr
        attr_list = compute_pattern[1]
        if len(attr_list) > 0:
            pattern_str.append('&')
            attr_str_list = [str(e) for e in attr_list]
            pattern_str.append("_".join(attr_str_list))

        self._rl_compute_pattern = "".join(pattern_str)

    def _gen_dync_rl_bank_info(self) -> bool:
        """
        generate dynamic rl_bank_info for current compute
        :return:
        """
        dynamic_axis_name = self._compute_attrs[2]
        op_vars_int = self._vars_name_to_int(dynamic_axis_name)

        curr_compute_context = operation.get_context().get_current_compute()
        for sch_context in curr_compute_context.get_schedules():
            sch_vars = sch_context.get_vars()

            sch_vars_int = self._vars_name_to_int(sch_vars)
            self._sch_infos.setdefault(sch_context.get("cheque_id"),
                                       [sch_context.get("tiling_key"), op_vars_int + sch_vars_int])

        # package rl_bank_info
        bank_info_list_for_cpt = []
        for tune_info in self._tune_info_lists:
            if len(tune_info) != 3:
                raise RuntimeError("Auto search bank info error: the length of tune_info is not correct, "
                                   "please check rl_bank's tune_info.")

            cheque_id = tune_info[0]
            if cheque_id not in self._withdraw_succ_cheque_id:
                continue

            range_info = self._package_range_info(tune_info[1], dynamic_axis_name)

            bank_tiling_meta_info = tune_info[2]
            tiling_meta_info = self._package_tiling_meta_info(bank_tiling_meta_info)
            bank_info = [range_info, dynamic_axis_name, tiling_meta_info] + self._sch_infos.get(cheque_id)
            if not bank_info:
                log.info("bank_info is null!")
                return False
            bank_info_list_for_cpt.append(bank_info)

        self._get_pattern_from_compute_attrs()
        self._rl_bank_info_for_cpt.setdefault(self._rl_compute_pattern, bank_info_list_for_cpt)

        curr_compute_context.add("_bank_info", self._rl_bank_info_for_cpt)
        return True
