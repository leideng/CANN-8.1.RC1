#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
generate the cheque from best result python file by rl search
"""
import os
import time
import json
import pickle
from collections import namedtuple
from dataclasses import make_dataclass
from ast import literal_eval as make_tuple
from typing import Union
from typing import NoReturn

import tbe
from tbe import tvm
from tbe.dsl.instrinsic import cce_emitinsn_params
from tbe.common.rl_bank.bank_cfg import INTRIN_MAP
from tbe.common.rl_bank.bank_cfg import SCOPE_DICT
from tbe.common.rl_bank.bank_cfg import PRIMITIVE_DICT
from tbe.common.rl_bank.bank_cfg import ScheduleTarget
from tbe.common.rl_bank.bank_cfg import Axis
from tbe.common.rl_bank.bank_cfg import TBE_COMPILE_PARA_DICT
from tbe.common.utils import log


SplitParam = make_dataclass("SplitParam", ["sch", "sch_targets", "cheque_list", "code_line", "split_stage_name",
                        "split_stage_obj", "split_stage_idx", "split_axis", "split_axis_name", "factor"])

GenChequeParam = namedtuple("GenChequeParam", ["sch", "sch_targets", "cheque_list", "code_line"])


def get_param_in_brackets(expression: str) -> str:
    """
    get value in brackets: []
    """
    return expression.split("[")[1].split("]")[0]


def get_axis_in_brackets(expression: str) -> str:
    """
    get axis in brackets: []
    """
    return expression.split("axis[")[1].split("]")[0]


def delete_brackets(expression: str) -> str:
    """
    delete brackets: []
    """
    return expression.replace("[", "").replace("]", "")


def get_stage_by_name(stage_name, sch_targets):
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    stage_name = stage_name.strip()
    for stage_idx, sch_target in enumerate(sch_targets):
        if (isinstance(sch_target.name, str)
                and stage_name == sch_target.name) or (isinstance(sch_target.name, list)
                                                       and stage_name in sch_target.name):
            return stage_idx, sch_target.obj.op.output(0)
    raise RuntimeError("no stage named by ", stage_name)


def get_axis_by_name(axis_name, axes):
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    if isinstance(axis_name, list):
        axis_name = axis_name[0]

    axis_name = axis_name.strip()
    for axis_idx, axis in enumerate(axes):
        if (isinstance(axis.name, str) and axis_name == axis.name) or (isinstance(axis.name, list)
                                                                       and axis_name in axis.name):
            return axis_idx, axis.obj
    raise RuntimeError("no axis named by ", axis_name)


def get_primitive_id(primitive_name):
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    primitive_name = primitive_name.strip()
    for primitive_id in sorted(PRIMITIVE_DICT):
        if PRIMITIVE_DICT[primitive_id] == primitive_name:
            return primitive_id
    raise RuntimeError("no primitive_name named by ", primitive_name)


def get_scope_id(scope):
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    scope = scope.strip()
    for scope_id in sorted(SCOPE_DICT):
        if SCOPE_DICT[scope_id] == scope:
            return scope_id
    raise RuntimeError("no scope named by ", scope)


def get_insn_id(insn_name):
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    insn_name = insn_name.strip()
    for insn_id in sorted(INTRIN_MAP):
        if INTRIN_MAP[insn_id] == insn_name:
            return insn_id
    raise RuntimeError("no insn named by ", insn_name)


def get_axis(sch, sch_targets, cheque_list, specify_axis_name_dict, split_stage_name):
    '''
    get_axis
    :param sch:
    :param sch_targets:
    :param cheque_list:
    :param specify_axis_name_dict:
    :param split_stage_name:
    :param split_stage_idx:
    :param split_stage_obj:
    :return:
    '''
    split_stage_idx, split_stage_obj = get_stage_by_name(split_stage_name, sch_targets)
    # get axis when have not got
    axis_num = len(split_stage_obj.op.axis)
    for i in range(axis_num):
        axis_name = '%s_axis_%d' % (split_stage_name, i)
        axis_obj = sch[split_stage_obj].op.axis[i]
        curr_axis = Axis(axis_name, axis_obj)
        curr_axis.update_name("sch[%s].op.axis[%s]" % (split_stage_name, i))
        if axis_name in specify_axis_name_dict:
            curr_axis.update_name(specify_axis_name_dict[axis_name])
        sch_targets[split_stage_idx].axes.append(curr_axis)

    cheque = [split_stage_idx, get_primitive_id("get_axis"), axis_num]
    cheque_list.append(cheque)

    # get reduce axis
    reduce_axis_num = len(sch[split_stage_obj].op.reduce_axis)
    if reduce_axis_num:
        for i in range(reduce_axis_num):
            axis_name = '%s_reduce_axis_%d' % (split_stage_name, i)
            axis_obj = sch[split_stage_obj].op.reduce_axis[i]
            curr_axis = Axis(axis_name, axis_obj)
            curr_axis.update_name("sch[%s].op.reduce_axis[%s]" % (split_stage_name, i))
            if axis_name in specify_axis_name_dict:
                curr_axis.update_name(specify_axis_name_dict[axis_name])
            sch_targets[split_stage_idx].axes.append(curr_axis)
        cheque = [split_stage_idx, get_primitive_id("get_reduce_axis"), reduce_axis_num]
        cheque_list.append(cheque)


def update_after_reduce_split(split_param: SplitParam) -> None:
    """
    update_after_split
    :param sch_targets:
    :param split_stage_idx:
    :param split_axis_name:
    :param sch:
    :param split_stage_obj:
    :param factor:
    :param code_line:
    :param cheque_list:
    :return:
    """
    sch_targets = split_param.sch_targets
    split_stage_idx = split_param.split_stage_idx
    factor = split_param.factor
    # get axis by name
    split_axis_idx, axis_obj = get_axis_by_name(split_param.split_axis_name, sch_targets[split_stage_idx].axes)
    # do split
    split_outer, split_inner = split_param.sch[split_param.split_stage_obj].split(axis_obj, factor=factor)
    # delete axis when axis is splited
    sch_targets[split_stage_idx].axes.pop(split_axis_idx)
    # get axis name after split from code line
    split_name = split_param.code_line.split("=")[0].strip()
    split_outer_name, split_inner_name = split_name.split(",")
    # inset inner then insert outer
    sch_targets[split_stage_idx].axes.insert(split_axis_idx, Axis(split_inner_name, split_inner))
    sch_targets[split_stage_idx].axes.insert(split_axis_idx, Axis(split_outer_name, split_outer))
    # add cheque
    cheque = [split_stage_idx, get_primitive_id("split"), split_axis_idx, factor]
    split_param.cheque_list.append(cheque)


def proc_cache_read(gen_cheque_param: namedtuple) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if ".cache_read(" in code_line:
        out_stage_name = code_line.split("=")[0].strip()
        cache_read_param = code_line.split("cache_read(")[1].split(",")
        scope = cache_read_param[1].replace("'", "").strip()
        read_stage_idx, read_stage_obj = get_stage_by_name(cache_read_param[0], gen_cheque_param.sch_targets)
        consumer_list = get_param_in_brackets(code_line).split(",")
        consumer_stage_idx_list = []
        consumer_stage_obj_list = []
        for consumer in consumer_list:
            consumer = consumer.strip()
            consumer_stage_idx, consumer_stage_obj = get_stage_by_name(consumer, gen_cheque_param.sch_targets)
            consumer_stage_idx_list.append(consumer_stage_idx)
            consumer_stage_obj_list.append(consumer_stage_obj)

        readed_tensor = gen_cheque_param.sch.cache_read(read_stage_obj, scope, consumer_stage_obj_list)
        # Tensor shoule insert after orignal tensor  when cache_read
        gen_cheque_param.sch_targets.insert(read_stage_idx + 1, ScheduleTarget(out_stage_name, readed_tensor, []))
        cheque = [
            read_stage_idx,
            get_primitive_id("cache_read"),
            get_scope_id(scope), consumer_stage_idx_list
        ]
        gen_cheque_param.cheque_list.append(cheque)


def proc_cache_write(sch, sch_targets, cheque_list, code_line):  # pylint: disable=too-many-locals
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    if ".cache_write(" in code_line:
        written_name = code_line.split("=")[0].strip()

        if ',' not in written_name:
            # one tensor do cache_write
            write_stage_name, scope = code_line.split("cache_write(")[1].replace(")",
                                                                                 "").split(",")
            scope = scope.replace("'", "").strip()
            write_stage_idx, write_stage_obj = get_stage_by_name(write_stage_name, sch_targets)
            written_tensor = sch.cache_write(write_stage_obj, scope)
            # Tensor shoule insert before orignal tensor  when cache_write
            sch_targets.insert(write_stage_idx, ScheduleTarget(written_name, written_tensor, []))

            cheque = [write_stage_idx, get_primitive_id("cache_write"), get_scope_id(scope)]
            cheque_list.append(cheque)
        else:
            # more than one tensor do cache_write
            write_tensor_names, scope = code_line.split("cache_write(")[1].replace(")", "")\
                .split("],")
            write_tensor_names = write_tensor_names.lstrip('[').rstrip(']').split(', ')
            write_stage_name = write_tensor_names[0].split('_v')[0].strip()
            scope = scope.replace("'", "").strip()
            write_stage_idx, write_stage_obj = get_stage_by_name(write_stage_name, sch_targets)
            write_tensor_objs = []
            for idx in range(len(write_tensor_names)):
                write_tensor_objs.append(write_stage_obj.op.output(idx))
            written_tensors = sch.cache_write(write_tensor_objs, scope)

            written_name = '%s_l' % write_stage_name
            sch_targets.insert(write_stage_idx, ScheduleTarget(written_name, written_tensors[0],
                                                               []))

            cheque = [[write_stage_idx, len(write_tensor_names)],
                      get_primitive_id("cache_write"),
                      get_scope_id(scope)]
            cheque_list.append(cheque)


def proc_set_buffer_size(gen_cheque_param: namedtuple) -> None:
    '''

    :param sch:
    :param sch_targets:
    :param cheque_list:
    :param code_line:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if ".set_buffer_size(" in code_line:
        stage_name = get_param_in_brackets(code_line.split(".set_buffer_size")[0])
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
        input_l1_size_str = code_line.split(".set_buffer_size(")[1].rstrip(')\n')
        if '.' in input_l1_size_str:
            input_l1_size = float(input_l1_size_str)
        else:
            input_l1_size = int(input_l1_size_str)

        cheque = [stage_idx, get_primitive_id("set_buffer_size"), input_l1_size]
        gen_cheque_param.cheque_list.append(cheque)

        gen_cheque_param.sch[stage_obj].set_buffer_size(input_l1_size)


def proc_preload(gen_cheque_param: namedtuple) -> None:
    '''
    proc_preload
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    if ".preload(" in gen_cheque_param.code_line:
        stage_name = get_param_in_brackets(gen_cheque_param.code_line)
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
        gen_cheque_param.sch[stage_obj].preload()

        cheque = [stage_idx, get_primitive_id("preload")]
        gen_cheque_param.cheque_list.append(cheque)


def proc_double_buffer(gen_cheque_param: namedtuple) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    if ".double_buffer(" in gen_cheque_param.code_line:
        stage_name = get_param_in_brackets(gen_cheque_param.code_line)
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
        gen_cheque_param.sch[stage_obj].double_buffer()

        cheque = [stage_idx, get_primitive_id("double_buffer")]
        gen_cheque_param.cheque_list.append(cheque)


def proc_compute_inline(gen_cheque_param: namedtuple) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    if ".compute_inline(" in gen_cheque_param.code_line:
        stage_name = get_param_in_brackets(gen_cheque_param.code_line)
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
        gen_cheque_param.sch[stage_obj].compute_inline()

        cheque = [stage_idx, get_primitive_id("compute_inline")]
        gen_cheque_param.cheque_list.append(cheque)


def _get_split_param(gen_cheque_param: namedtuple, split_axis_type: str) -> None:
    sch, sch_targets, cheque_list, code_line = tuple(gen_cheque_param)
    split_stage_name = code_line.split("].split")[0].split("[")[1]
    split_stage_idx, split_stage_obj = get_stage_by_name(split_stage_name, sch_targets)
    factor = int(code_line.split("factor=")[1].split(")")[0])

    split_axis = code_line.split(".split(")[1].split(",")[0]
    if "[" in split_axis and "]" in split_axis:
        split_axis = int(get_axis_in_brackets(split_axis))

    if isinstance(split_axis, int):
        split_axis_name = '%s_%s_%d' % (split_stage_name, split_axis_type, split_axis)
    else:
        split_axis_name = split_axis

    split_param = SplitParam(sch, sch_targets, cheque_list, code_line,
                             split_stage_name, split_stage_obj, split_stage_idx, split_axis, split_axis_name, factor)
    return split_param


def _proc_reduce_split_int(split_param: SplitParam, stage_get_axis_dict: dict, specify_axis_name_dict: dict) -> None:
    split_stage_name = split_param.split_stage_name
    # get axis
    if not stage_get_axis_dict.get(split_stage_name, False):
        get_axis(split_param.sch, split_param.sch_targets,
                 split_param.cheque_list, specify_axis_name_dict, split_stage_name)
        stage_get_axis_dict[split_stage_name] = True

    update_after_reduce_split(split_param)


def _proc_reduce_split_rfactor(split_param: SplitParam, stage_get_axis_dict: dict,
                               specify_axis_name_dict: dict) -> None:
    split_stage_name = split_param.split_stage_name
    sch_targets = split_param.sch_targets
    # split_axis is specify_axis_name: ub_split_reduce_axis
    if not stage_get_axis_dict.get(split_stage_name, False):
        # get comm axis and get reduce axis
        get_axis(split_param.sch, sch_targets, split_param.cheque_list, specify_axis_name_dict, split_stage_name)
        stage_get_axis_dict[split_stage_name] = True

    # get real split axis obj
    ori_stage_name = split_stage_name.rstrip('_rfactor')
    ori_stage_idx, _ = get_stage_by_name(ori_stage_name, sch_targets)
    _, ori_axis_obj = get_axis_by_name(split_param.split_axis_name, sch_targets[ori_stage_idx].axes)
    for axis in sch_targets[split_param.split_stage_idx].axes:
        if axis.obj == ori_axis_obj:
            split_param.split_axis_name = axis.name
            break
    update_after_reduce_split(split_param)


def proc_reduce_split(gen_cheque_param: namedtuple, stage_get_axis_dict: dict, specify_axis_name_dict: dict) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if ".split(" in code_line and "factor" in code_line and "reduce_axis" in code_line:
        split_param = _get_split_param(gen_cheque_param, "reduce_axis")
        split_axis = split_param.split_axis
        # might be int or specify_axis_name: ub_split_reduce_axis
        if isinstance(split_axis, int):
            _proc_reduce_split_int(split_param, stage_get_axis_dict, specify_axis_name_dict)
        elif split_param.split_stage_name.endswith('_rfactor') and split_axis in specify_axis_name_dict.values():
            _proc_reduce_split_rfactor(split_param, stage_get_axis_dict, specify_axis_name_dict)
        # reduce axis split twice
        else:
            update_after_reduce_split(split_param)


def _update_after_split(split_param: SplitParam, is_split_axit_int: bool) -> None:
    # get axis index in current axes by axis_name
    split_stage_in_targets_sch = split_param.sch_targets[split_param.split_stage_idx]
    split_axis_idx, axis_obj = get_axis_by_name(split_param.split_axis_name, split_stage_in_targets_sch.axes)
    stage_for_split = split_param.sch[split_param.split_stage_obj]
    if is_split_axit_int:
        axis_obj = stage_for_split.op.axis[split_param.split_axis]
    split_outer, split_inner = stage_for_split.split(axis_obj, factor=split_param.factor)
    # delete split axis
    split_stage_in_targets_sch.axes.pop(split_axis_idx)
    # inserrt inner then outer
    split_name = split_param.code_line.split("=")[0].strip()
    split_outer_name, split_inner_name = split_name.split(",")
    split_stage_in_targets_sch.axes.insert(split_axis_idx, Axis(split_inner_name, split_inner))
    split_stage_in_targets_sch.axes.insert(split_axis_idx, Axis(split_outer_name, split_outer))
    cheque = [split_param.split_stage_idx, get_primitive_id("split"), split_axis_idx, split_param.factor]
    split_param.cheque_list.append(cheque)


def _pro_split_axis_int(split_param: SplitParam, stage_get_axis_dict: dict, specify_axis_name_dict: dict) -> None:
    split_stage_name = split_param.split_stage_name
    # get axis
    if not stage_get_axis_dict.get(split_stage_name, False):
        get_axis(split_param.sch, split_param.sch_targets,
                 split_param.cheque_list, specify_axis_name_dict, split_stage_name)
        stage_get_axis_dict[split_stage_name] = True
    _update_after_split(split_param, True)


def _pro_split_axis_string(split_param: SplitParam, stage_get_axis_dict: dict, specify_axis_name_dict: dict) -> None:
    split_stage_name = split_param.split_stage_name
    split_stage_in_targets_sch = split_param.sch_targets[split_param.split_stage_idx]
    # split_axis is specify_axis_name: ub_split_axis. eg: sch[reduce_39_rfactor].split(ub_split_axis, factor)
    if split_stage_name.endswith('_rfactor') and split_param.split_axis_name in specify_axis_name_dict.values():
        # get split axis name of curr stage
        if not stage_get_axis_dict.get(split_stage_name, False):
            # get comm axis and get reduce axis
            get_axis(split_param.sch, split_param.sch_targets,
                     split_param.cheque_list, specify_axis_name_dict, split_stage_name)
            stage_get_axis_dict[split_stage_name] = True

        # get real split axis obj
        ori_stage_name = split_stage_name.rstrip('_rfactor')
        ori_stage_idx, _ = get_stage_by_name(ori_stage_name, split_param.sch_targets)
        _, ori_axis_obj = get_axis_by_name(split_param.split_axis_name, split_param.sch_targets[ori_stage_idx].axes)
        for axis in split_stage_in_targets_sch.axes:
            if axis.obj == ori_axis_obj:
                split_param.split_axis_name = axis.name
                break
    _update_after_split(split_param, False)


def proc_split(gen_cheque_param: namedtuple, stage_get_axis_dict: dict, specify_axis_name_dict: dict) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if ".split(" in code_line and "factor" in code_line and "reduce_axis" not in code_line:
        split_param = _get_split_param(gen_cheque_param, "axis")
        if isinstance(split_param.split_axis, int):
            _pro_split_axis_int(split_param, stage_get_axis_dict, specify_axis_name_dict)
        # if string mean axis has been split, get axis obj by axis name
        else:
            _pro_split_axis_string(split_param, stage_get_axis_dict, specify_axis_name_dict)


def _is_trs_reorder(stage_name: str, reorder_axis_name_list: Union[list, tuple], last_code_line: str,
                    stage_obj: object) -> bool:
    """
    flag_0..op.axis in every axis_name
    flag_1.last_proc is cache_read or cache_write
    flag_2.reorder_axes len = op.axes
    :return: flag
    """
    trs_reorder_flag_0 = True
    check_str = stage_name + '.op.axis'
    for axis_name in reorder_axis_name_list:
        if check_str not in axis_name:
            trs_reorder_flag_0 = False
            break
    trs_reorder_flag_1 = 'cache_read' in last_code_line or 'cache_write' in last_code_line
    trs_reorder_flag_2 = len(stage_obj.op.axis) == len(reorder_axis_name_list)

    return trs_reorder_flag_0 and trs_reorder_flag_1 and trs_reorder_flag_2


def _trs_reorder_proc(reorder_param: GenChequeParam, stage_name: str,
                      reorder_axis_name_list: Union[list, tuple], last_code_line: str) -> bool:
    """
    trs reorder proc
    :param stage_obj:
    :param stage_name:
    :param sch:
    :param reorder_axis_name_list:
    :param stage_idx:
    :param cheque_list:
    :return:
    """
    stage_idx, stage_obj = get_stage_by_name(stage_name, reorder_param.sch_targets)
    trs_reorder_ret = False
    if _is_trs_reorder(stage_name, reorder_axis_name_list, last_code_line, stage_obj):
        reorder_axes = []
        for i in range(len(stage_obj.op.axis)):
            axis_name = '%s.op.axis[%d]' % (stage_name, i)
            axis_obj = reorder_param.sch[stage_obj].op.axis[i]
            reorder_axes.append(Axis(axis_name, axis_obj))

        reorder_axis_idx_list = []
        reorder_axis_obj_list = []
        for axis_name in reorder_axis_name_list:
            axis_idx, axis_obj = get_axis_by_name(axis_name, reorder_axes)
            reorder_axis_idx_list.append(axis_idx)
            reorder_axis_obj_list.append(axis_obj)

        cheque = [stage_idx, get_primitive_id("reorder"), reorder_axis_idx_list]
        reorder_param.cheque_list.append(cheque)
        reorder_param.sch[stage_obj].reorder(*(reorder_axis_obj_list))
        trs_reorder_ret = True

    return trs_reorder_ret


def _do_reorder(do_reorder_param: GenChequeParam, stage_idx: int,
                reorder_axis_name_list: Union[list, tuple], stage_obj: object) -> NoReturn:
    """
    do reorder
    :param do_reorder_param:
    :param stage_idx:
    :param reorder_axis_name_list:
    :param stage_obj:
    :return:
    """
    left_axis_idx_list = list(range(len(do_reorder_param.sch_targets[stage_idx].axes)))
    reorder_axis_idx_list = []
    reorder_axis_obj_list = []
    for axis_name in reorder_axis_name_list:
        axis_idx, axis_obj = get_axis_by_name(axis_name,
                                              do_reorder_param.sch_targets[stage_idx].axes)
        left_axis_idx_list.remove(axis_idx)
        reorder_axis_idx_list.append(axis_idx)
        reorder_axis_obj_list.append(axis_obj)

    do_reorder_param.cheque_list.append([stage_idx, get_primitive_id("reorder"), reorder_axis_idx_list])

    do_reorder_param.sch[stage_obj].reorder(*(reorder_axis_obj_list))
    # sort axis by reorder
    do_reorder_param.sch_targets[stage_idx].axes = [
        do_reorder_param.sch_targets[stage_idx].axes[i]
        for i in reorder_axis_idx_list + left_axis_idx_list
    ]


def proc_reorder(sch: object, sch_targets: list, cheque_list: list,
                 code_line: str, last_code_line: str) -> NoReturn:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    if ".reorder(" in code_line:
        stage_name = code_line.split("[")[1].split("]")[0]
        stage_idx, stage_obj = get_stage_by_name(stage_name, sch_targets)
        reorder_axis_name_param = code_line.split("reorder(")[1].split(")")[0]
        reorder_axis_name_list = [x.strip() for x in reorder_axis_name_param.split(",") if x.strip()]

        reorder_param = GenChequeParam(sch, sch_targets, cheque_list, code_line)
        # 对输入和输出做的reorder时，不需要将axis信息放到cheque
        if _trs_reorder_proc(reorder_param, stage_name,
                             reorder_axis_name_list, last_code_line):
            return

        # axes is empty if have not get axis
        if not sch_targets[stage_idx].axes:
            # comm axis
            axis_num = len(stage_obj.op.axis)
            cheque_list.append([stage_idx, get_primitive_id("get_axis"), axis_num])

            for i in range(axis_num):
                sch_targets[stage_idx].axes.append(Axis('%s_axis_%d' % (stage_name, i), sch[stage_obj].op.axis[i]))
            # reduce axis
            reduce_axis_num = len(stage_obj.op.reduce_axis)
            cheque_list.append([stage_idx, get_primitive_id("get_reduce_axis"), reduce_axis_num])

            for i in range(reduce_axis_num):
                sch_targets[stage_idx].axes.append(
                    Axis('%s_reduce_axis_%d' % (stage_name, i),
                         sch[stage_obj].op.reduce_axis[i]))

        do_reorder_param = GenChequeParam(sch, sch_targets, cheque_list, code_line)
        _do_reorder(do_reorder_param, stage_idx, reorder_axis_name_list, stage_obj)


def _set_run_once_axes(run_once_axes_idx_list: list, run_once_axes_obj_list: list, code_line: str,
                       at_stage_axis: object) -> None:
    run_once_axes_param = get_param_in_brackets(code_line.split(",", 2)[-1].replace(" ", ""))
    run_once_axes_name = run_once_axes_param.split(",")
    for axis_name in run_once_axes_name:
        axis_idx, axis_obj = get_axis_by_name(axis_name, at_stage_axis)
        run_once_axes_idx_list.append(axis_idx)
        run_once_axes_obj_list.append(axis_obj)


def proc_allocate_at(gen_cheque_param: namedtuple) -> None:
    """
    proc_allocate_at
    :param sch:
    :param sch_targets:
    :param cheque_list:
    :param code_line:
    :return:
    """
    code_line = gen_cheque_param.code_line
    if ".allocate_at(" in code_line:
        stage_name = get_param_in_brackets(code_line.split("allocate_at")[0])
        at_stage_name = get_param_in_brackets(code_line.split("allocate_at")[1])
        at_axis_name = code_line.split(",")[1].split(")")[0]

        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
        at_stage_idx, at_stage_obj = get_stage_by_name(at_stage_name, gen_cheque_param.sch_targets)
        at_axis_idx, at_axis_obj = get_axis_by_name(at_axis_name, gen_cheque_param.sch_targets[at_stage_idx].axes)
        run_once_axes_idx_list = []
        run_once_axes_obj_list = []
        if code_line.count(",") > 1:
            _set_run_once_axes(run_once_axes_idx_list, run_once_axes_obj_list,
                               code_line, gen_cheque_param.sch_targets[at_stage_idx].axes)

        cheque = [
            stage_idx,
            get_primitive_id("allocate_at"), at_stage_idx, at_axis_idx, run_once_axes_idx_list
        ]
        gen_cheque_param.cheque_list.append(cheque)

        gen_cheque_param.sch[stage_obj].allocate_at(
            gen_cheque_param.sch[at_stage_obj], at_axis_obj, run_once_axes_obj_list)


def proc_mem_unique(gen_cheque_param: namedtuple) -> None:
    """
    proc_mem_unique
    :param sch:
    :param sch_targets:
    :param cheque_list:
    :param code_line:
    :return:
    """
    if ".mem_unique(" in gen_cheque_param.code_line:
        stage_name = get_param_in_brackets(gen_cheque_param.code_line)
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
        gen_cheque_param.sch[stage_obj].mem_unique()

        cheque = [stage_idx, get_primitive_id("mem_unique")]
        gen_cheque_param.cheque_list.append(cheque)


def proc_nparts(sch, sch_targets, cheque_list, code_line, specify_axis_name_dict):  # pylint: disable=too-many-locals
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    if ".split(" in code_line and "nparts" in code_line:
        split_stage_name = code_line.split("].split")[0].split("[")[1]
        split_stage_idx, split_stage_obj = get_stage_by_name(split_stage_name, sch_targets)
        nparts = int(code_line.split("nparts=")[1].split(")")[0])
        split_axis_name = code_line.split(".split(")[1].split(",")[0]
        # get aixs if this stage has no axes
        if not sch_targets[split_stage_idx].axes:
            get_axis(sch, sch_targets, cheque_list, specify_axis_name_dict, split_stage_name)

        axis_idx, axis_obj = get_axis_by_name(split_axis_name, sch_targets[split_stage_idx].axes)
        cheque = [split_stage_idx, get_primitive_id("split_nparts"), axis_idx, nparts]
        cheque_list.append(cheque)

        split_outer, split_inner = sch[split_stage_obj].split(axis_obj, nparts=nparts)
        # delete split axis
        sch_targets[split_stage_idx].axes.pop(axis_idx)
        split_outer_name, split_inner_name = code_line.split("=")[0].strip().split(",")
        # insert inner then outer
        sch_targets[split_stage_idx].axes.insert(axis_idx, Axis(split_inner_name, split_inner))
        sch_targets[split_stage_idx].axes.insert(axis_idx, Axis(split_outer_name, split_outer))


def proc_compute_at(gen_cheque_param: namedtuple) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if ".compute_at(" in code_line:
        sch_targets = gen_cheque_param.sch_targets
        sch = gen_cheque_param.sch
        stage_name = get_param_in_brackets(code_line.split("compute_at")[0])
        at_stage_name = get_param_in_brackets(code_line.split("compute_at")[1])
        at_axis_name = code_line.split(",")[1].split(")")[0]

        stage_idx, stage_obj = get_stage_by_name(stage_name, sch_targets)
        at_stage_idx, at_stage_obj = get_stage_by_name(at_stage_name, sch_targets)
        at_axis_idx, at_axis_obj = get_axis_by_name(at_axis_name, sch_targets[at_stage_idx].axes)

        cheque = [stage_idx, get_primitive_id("compute_at"), at_stage_idx, at_axis_idx]
        gen_cheque_param.cheque_list.append(cheque)

        sch[stage_obj].compute_at(sch[at_stage_obj], at_axis_obj)


def _get_local_axis_name(specify_axis_name_dict: dict, fuse_axis_name: str) -> str:
    res = fuse_axis_name
    for local_axis_name, special_axis_name in specify_axis_name_dict.items():
        if fuse_axis_name == special_axis_name:
            res = local_axis_name
            break
    return res


def _get_fuse_axis(sch_targets: list, specify_axis_name_dict: dict, code_line: str, stgae_idx: int) -> list:
    ori_fuse_axis_name = code_line.split("fuse(")[1].split(")")[0]
    ori_fuse_axis_name_list = ori_fuse_axis_name.split(",")
    fuse_axis_name_list = (x.strip() for x in ori_fuse_axis_name_list if x.strip())
    fuse_axis_idx_list = []
    fuse_axis_obj_list = []
    for fuse_axis_name in fuse_axis_name_list:
        axis_name = fuse_axis_name
        if fuse_axis_name in specify_axis_name_dict.values():
            axis_name = _get_local_axis_name(specify_axis_name_dict, fuse_axis_name)
        axis_idx, axis_obj = get_axis_by_name(axis_name, sch_targets[stgae_idx].axes)
        fuse_axis_idx_list.append(axis_idx)
        fuse_axis_obj_list.append(axis_obj)
    return fuse_axis_idx_list, fuse_axis_obj_list


def proc_fuse(gen_cheque_param: namedtuple, specify_axis_name_dict: dict) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if ".fuse(" in code_line:
        sch_targets = gen_cheque_param.sch_targets
        sch = gen_cheque_param.sch
        fused_axis_name = code_line.split("=")[0].strip()
        stage_name = get_param_in_brackets(code_line)
        stgae_idx, stage_obj = get_stage_by_name(stage_name, sch_targets)

        fuse_axis_idx_list, fuse_axis_obj_list = _get_fuse_axis(
            sch_targets, specify_axis_name_dict, code_line, stgae_idx)
        fused_axis_obj = sch[stage_obj].fuse(*(fuse_axis_obj_list))
        fuse_axis_start = min(fuse_axis_idx_list)
        # delete fuse axis
        for _ in fuse_axis_idx_list:
            sch_targets[stgae_idx].axes.pop(fuse_axis_start)
        # insert outer
        sch_targets[stgae_idx].axes.insert(fuse_axis_start, Axis(fused_axis_name, fused_axis_obj))

        cheque = [stgae_idx, get_primitive_id("fuse"), fuse_axis_idx_list]
        gen_cheque_param.cheque_list.append(cheque)


def proc_rfactor(gen_cheque_param: namedtuple) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if ".rfactor(" in code_line:
        sch_targets = gen_cheque_param.sch_targets
        tensor_names = code_line.split("=")[0]
        out_tensor_name = tensor_names.split(',')[0].strip()
        stage_name = code_line.split("rfactor(")[1].split(",")[0]
        rfactor_axis_name = code_line.split("rfactor(")[1].split(",")[1]
        factor_axis = int(code_line.split("factor_axis=")[1].replace(")", "").strip())
        stage_idx, stage_obj = get_stage_by_name(stage_name, sch_targets)
        axis_idx, axis_obj = get_axis_by_name(rfactor_axis_name, sch_targets[stage_idx].axes)
        out_tensor_obj = gen_cheque_param.sch.rfactor(stage_obj, axis_obj, factor_axis=factor_axis)

        cheque = [stage_idx, get_primitive_id("rfactor"), axis_idx, factor_axis]
        gen_cheque_param.cheque_list.append(cheque)

        if not isinstance(out_tensor_obj, tvm.Tensor):
            out_tensor_obj = out_tensor_obj[0]
        sch_targets.insert(stage_idx, ScheduleTarget(out_tensor_name, out_tensor_obj.op.output(0), []))


def proc_set_scope(gen_cheque_param: namedtuple) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if ".set_scope(" in code_line:
        stage_name = get_param_in_brackets(code_line.split(".set_scope")[0])
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
        scope = code_line.split("'")[1]

        cheque = [stage_idx, get_primitive_id("set_scope"), get_scope_id(scope)]
        gen_cheque_param.cheque_list.append(cheque)

        gen_cheque_param.sch[stage_obj].set_scope(scope)


def proc_bind(gen_cheque_param: namedtuple) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if '.bind(' in code_line and 'sub_block' not in code_line:
        sch_targets = gen_cheque_param.sch_targets
        stage_name = get_param_in_brackets(code_line.split(".bind(")[0])
        stage_idx, stage_obj = get_stage_by_name(stage_name, sch_targets)

        cheque = [stage_idx, get_primitive_id("bind")]
        gen_cheque_param.cheque_list.append(cheque)

        block = tvm.te.thread_axis('blockIdx.x')
        gen_cheque_param.sch[stage_obj].bind(sch_targets[stage_idx].axes[0].obj, block)


def proc_sub_bind(gen_cheque_param: namedtuple):  # pylint: disable=too-many-locals
    '''
    proc_sub_bind
    :param gen_cheque_param: namedtuple("args", "sch", "sch_targets", "primitive", "stage_index", "mode")
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if '.bind(' in code_line and 'sub_block' in code_line:
        stage_name = code_line.split(".bind(")[0].split("[")[1].split("]")[0]
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)

        sub_axis_name = code_line.split(".bind(")[1].split(",")[0]
        sub_axis_idx, sub_axis_obj = get_axis_by_name(sub_axis_name, gen_cheque_param.sch_targets[stage_idx].axes)

        cheque = [stage_idx, get_primitive_id("sub_bind"), sub_axis_idx]
        gen_cheque_param.cheque_list.append(cheque)

        sub_block = tvm.te.thread_axis('subBlockIdx.x')
        gen_cheque_param.sch[stage_obj].bind(sub_axis_obj, sub_block)


def proc_block_sync(block_sync_type: str, gen_cheque_param: namedtuple) -> None:
    '''
    proc_block_sync
    :param block_sync_type:
    :param sch:
    :param sch_targets:
    :param cheque_list:
    :param code_line:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    prime_key = '.%s(' % block_sync_type
    if prime_key in code_line:
        stage_name = get_param_in_brackets(code_line.split(prime_key)[0])
        stage_idx, _ = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)

        block_sync_params = code_line.split(prime_key)[1].split(")")[0]
        axis_name, _, bottom_expr = block_sync_params.strip().split(",")
        axis_idx, _ = get_axis_by_name(axis_name, gen_cheque_param.sch_targets[stage_idx].axes)
        sync_stage_idx = -1

        # get bottom
        bottom = False
        if bottom_expr.split("=")[-1].strip() == "True":
            bottom = True

        cheque = [stage_idx, get_primitive_id(block_sync_type), axis_idx, sync_stage_idx, int(bottom)]
        gen_cheque_param.cheque_list.append(cheque)


def proc_pragma(gen_cheque_param: namedtuple) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if '.pragma(' in code_line:
        sch = gen_cheque_param.sch
        stage_name = get_param_in_brackets(code_line.split(".pragma(")[0])
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
        pragma_axis = code_line.split(".pragma(")[1].split(",")[0]
        if "[" in pragma_axis and "]" in pragma_axis:
            pragma_axis = int(pragma_axis.split("axis[")[1].split("]")[0])
        pragma_name = code_line.split("'")[1]
        pragma_offset_tmp = code_line.split(",")[2]
        pragma_offset = int(pragma_offset_tmp.split(")")[0].strip())

        # int，get axis by index
        if isinstance(pragma_axis, int):
            cheque = [
                stage_idx,
                get_primitive_id("pragma"), [pragma_axis, -1],
                get_insn_id(pragma_name), pragma_offset
            ]
            sch[stage_obj].pragma(sch[stage_obj].op.axis[pragma_axis], pragma_name, pragma_offset)
        # str，axis name，get axis obj by name
        else:
            insn_axis_idx, insn_axis_obj = get_axis_by_name(pragma_axis, gen_cheque_param.sch_targets[stage_idx].axes)
            cheque = [
                stage_idx,
                get_primitive_id("pragma"), [-1, insn_axis_idx],
                get_insn_id(pragma_name), pragma_offset
            ]
            sch[stage_obj].pragma(insn_axis_obj, pragma_name, pragma_offset)

        gen_cheque_param.cheque_list.append(cheque)


def proc_bind_buffer(gen_cheque_param: namedtuple) -> None:
    '''

    :param sch:
    :param sch_targets:
    :param cheque_list:
    :param code_line:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if '.bind_buffer(' in code_line:
        sch = gen_cheque_param.sch
        stage_name = get_param_in_brackets(code_line.split(".bind_buffer(")[0])
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
        axis_idx = int(get_axis_in_brackets(code_line.split(".bind_buffer(")[1].split(",")[0]))
        stride = int(code_line.split(",")[1].strip())
        offset_tmp = code_line.split(",")[2]
        offset = int(offset_tmp.split(")")[0].strip())

        sch[stage_obj].bind_buffer(sch[stage_obj].op.axis[axis_idx], stride, offset)
        bind_buffer_cheque = [stage_idx,
                              get_primitive_id("bind_buffer"),
                              axis_idx,
                              stride,
                              offset]
        gen_cheque_param.cheque_list.append(bind_buffer_cheque)


def _get_mad_dict_in_emit_insn(cheque: list, last_code_line: str, sch_targets: list, stage_idx: int) -> dict:
    cheque.append([])
    mad_pattern = last_code_line.split('mad_pattern":')[1].strip()
    mad_pattern_value = int(mad_pattern.split(",")[0].strip("}"))
    cheque[-1].append(mad_pattern_value)
    # set default init_bias_value to 0 means that init_bias not in mad_dict
    init_bias_value = 0
    if "init_bias" in last_code_line:
        init_bias = last_code_line.split('init_bias":')[1].strip()
        init_bias_value = int(init_bias.split(",")[0].strip("}"))
    cheque[-1].append(init_bias_value)

    k_outer_axis_name = get_param_in_brackets(last_code_line).split(",")
    k_outer_axis_obj = []
    for axis_name in k_outer_axis_name:
        axis_idx, axis_obj = get_axis_by_name(axis_name, sch_targets[stage_idx].axes)
        cheque[-1].append(axis_idx)
        k_outer_axis_obj.append(axis_obj)

    mad_dict = {
        "mad_pattern": int(mad_pattern_value),
        "k_outer": k_outer_axis_obj,
    }
    if init_bias_value:
        mad_dict["init_bias"] = init_bias_value
    return mad_dict


def _proc_emit_insn_str(gen_cheque_param: namedtuple, code_line: str, last_code_line: str,
                        stage_name: str, insn_axis: object) -> None:
    stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
    insn_axis_idx, insn_axis_obj = get_axis_by_name(insn_axis, gen_cheque_param.sch_targets[stage_idx].axes)
    insn_name = gen_cheque_param.code_line.split("'")[1]
    cheque = [
        stage_idx,
        get_primitive_id("emit_insn"), [-1, insn_axis_idx],
        get_insn_id(insn_name)
    ]
    if insn_name == "mad" and 'mad_dict' in last_code_line:
        mad_dict = _get_mad_dict_in_emit_insn(cheque, last_code_line, gen_cheque_param.sch_targets, stage_idx)
        gen_cheque_param.sch[stage_obj].emit_insn(insn_axis_obj, insn_name, mad_dict)
    elif insn_name == "dma_copy" and 'no_overlap' in code_line:
        no_overlap_value = int(
            code_line.split("no_overlap':")[1].split(",")[0].strip("})"))
        cheque.append([no_overlap_value])
        dma_dict = {
            "no_overlap": int(no_overlap_value),
        }
        gen_cheque_param.sch[stage_obj].emit_insn(insn_axis_obj, insn_name, dma_dict)
    else:
        gen_cheque_param.sch[stage_obj].emit_insn(insn_axis_obj, insn_name)
    return cheque


def proc_emit_insn(gen_cheque_param: namedtuple, last_code_line: str) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if '.emit_insn(' not in code_line:
        return
    sch = gen_cheque_param.sch
    stage_name = get_param_in_brackets(code_line.split(".emit_insn(")[0])
    stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
    insn_axis = code_line.split(".emit_insn(")[1].split(",")[0]
    if "[" in insn_axis and "]" in insn_axis:
        insn_axis = int(get_axis_in_brackets(insn_axis))
    insn_name = code_line.split("'")[1]

    # int，get axis by index
    if isinstance(insn_axis, int):
        cheque = [
            stage_idx,
            get_primitive_id("emit_insn"), [insn_axis, -1],
            get_insn_id(insn_name)
        ]
        if insn_name == "vector_transpose" and 'src_in_dst_order' in code_line:
            code_str = last_code_line.split("[")[1]
            src_in_dst_order_str_list = code_str.split("]")[0].split(",")
            src_in_dst_order_list = [int(i) for i in src_in_dst_order_str_list]
            cheque.append([src_in_dst_order_list])
            src_in_dst_order = tvm.call_cce_pure_intrin('handle', 'tir.tvm_tuple', *src_in_dst_order_list)
            trs_attrs = {"src_in_dst_order": src_in_dst_order}
            sch[stage_obj].emit_insn(sch[stage_obj].op.axis[insn_axis], insn_name, trs_attrs)
        else:
            sch[stage_obj].emit_insn(sch[stage_obj].op.axis[insn_axis], insn_name)
    # str，axis name，get axis obj by name
    else:
        cheque = _proc_emit_insn_str(gen_cheque_param, code_line, last_code_line, stage_name, insn_axis)

    gen_cheque_param.cheque_list.append(cheque)


def proc_buffer_align(gen_cheque_param: namedtuple) -> None:
    """
    proc_buffer_align
    :param sch:
    :param sch_targets:
    :param cheque_list:
    :param code_line:
    :return:
    """
    code_line = gen_cheque_param.code_line
    if ".buffer_align(" in code_line:
        stage_name = get_param_in_brackets(code_line)
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)

        buffer_align_args = code_line.split("buffer_align")[1]
        buffer_align_args_obj = make_tuple(buffer_align_args)
        args_list = []
        for arg_item in buffer_align_args_obj:
            args_list.append(list(arg_item))

        gen_cheque_param.sch[stage_obj].buffer_align(*buffer_align_args_obj)
        cheque = [stage_idx, get_primitive_id("buffer_align"), args_list]
        gen_cheque_param.cheque_list.append(cheque)


def proc_insert_param(cheque_list, code_line):  # pylint: disable=too-many-locals
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    if "insert_param('broadcast_axis_offset'" in code_line:
        broadcast_axis_offset = int(code_line.split(",")[1].split(")")[0].strip())

        cce_emitinsn_params.cceEmitParamsIns.del_param('broadcast_axis_offset')
        cce_emitinsn_params.cceEmitParamsIns.insert_param('broadcast_axis_offset',
                                                          broadcast_axis_offset)

        cheque = [-1, get_primitive_id("broadcast_axis_offset"), broadcast_axis_offset]
        cheque_list.append(cheque)


def proc_reused_by(sch, sch_targets, cheque_list, code_line):
    """
    proc_reused_by
    :param sch:
    :param sch_targets:
    :param cheque_list:
    :param code_line:
    :return:
    """
    if '.reused_by(' in code_line:
        # get stage_name
        stage_name = get_param_in_brackets(code_line.split(".reused_by(")[0])
        stage_idx, stage_obj = get_stage_by_name(stage_name, sch_targets)
        # get reused_data
        reused_by_params = code_line.split(".reused_by(")[1].split(")")[0].strip().split(",")
        reuse_data = False
        if "reuse_data=" in reused_by_params[-1]:
            if reused_by_params[-1].split("reuse_data=")[-1] == "True":
                reuse_data = True
            # gen cheque
            cheque = [stage_idx, get_primitive_id("reused_by"), -1, int(reuse_data)]
            cheque_list.append(cheque)
            # do action
            sch[stage_obj].reused_by(reuse_data=reuse_data)
        else:
            # get reused_stage_name
            reused_stage_name = reused_by_params[0]
            reused_stage_idx, reused_stage_obj = get_stage_by_name(reused_stage_name, sch_targets)
            # gen cheque
            cheque = [stage_idx, get_primitive_id("reused_by"), reused_stage_idx, int(reuse_data)]
            cheque_list.append(cheque)
            # do action
            sch[stage_obj].reused_by(reused_stage_obj)


def proc_storage_align(gen_cheque_param: namedtuple) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if '.storage_align(' in code_line:
        sch = gen_cheque_param.sch
        stage_name = get_param_in_brackets(code_line.split(".storage_align(")[0])
        stage_idx, stage_obj = get_stage_by_name(stage_name, gen_cheque_param.sch_targets)
        axis_idx = int(get_axis_in_brackets(code_line.split(".storage_align(")[1].split(",")[0]))
        block_num = int(code_line.split(",")[1].strip())

        cheque = [stage_idx, get_primitive_id("storage_align"), axis_idx, block_num]
        gen_cheque_param.cheque_list.append(cheque)

        sch[stage_obj].storage_align(sch[stage_obj].op.axis[axis_idx], block_num, 0)


def proc_tbe_compile_para(gen_cheque_param: namedtuple) -> None:
    """
    proc_tbe_compile_para
    :param sch:
    :param sch_targets:
    :param cheque_list:
    :param code_line:
    :return:
    """
    if '.tbe_compile_para' not in gen_cheque_param.code_line:
        return

    tbe_para_str = gen_cheque_param.code_line.split("=")[1]
    tbe_para = make_tuple(tbe_para_str.strip())
    gen_cheque_param.sch.tbe_compile_para = tbe_para
    gen_cheque_param.cheque_list.append(get_cheque_tbe_compile_para(tbe_para))


def _get_tensor_name_list(sch_targets: list, tensor_name_list: list, tensor_idx_list: list,
                          tensor_obj_list: list) -> list:
    tensor_nums = 0
    other_tensor_list = []
    stage_name = ''
    for idx, tensor_name in enumerate(tensor_name_list):
        if '_v%s' % idx in tensor_name:
            tensor_nums += 1
            stage_name = tensor_name.split('_v%s' % idx)[0] + tensor_name.split('_v%s' % idx)[1]
        else:
            other_tensor_list.append(tensor_name)
    if tensor_nums > 0:
        stage_idx, stage_obj = get_stage_by_name(stage_name, sch_targets)
        tensor_idx_list.append([stage_idx, tensor_nums])
        for idx in range(tensor_nums):
            tensor_obj_list.append(stage_obj.op.output(idx))
    return other_tensor_list


def _do_proc_cce_special(gen_cheque_param: namedtuple, cce_special_cheque: list) -> None:
    code_line = gen_cheque_param.code_line
    cce_special_key = code_line.split("\"")[1]
    tensor_names = delete_brackets(code_line.split("=")[1].strip()).split(",")
    tensor_name_list = (x.strip() for x in tensor_names if x.strip())
    tensor_obj_list = []
    tensor_idx_list = []
    # tuple_reduce generate cce_special cheque
    spec_scene = False
    for cheque in gen_cheque_param.cheque_list:
        if cheque[1] == 1 and isinstance(cheque[0], list):
            spec_scene = True
            break

    if spec_scene:
        tensor_name_list = _get_tensor_name_list(
            gen_cheque_param.sch_targets, tensor_name_list, tensor_idx_list, tensor_obj_list)

    for tensor_name in tensor_name_list:
        stage_idx, stage_obj = get_stage_by_name(tensor_name, gen_cheque_param.sch_targets)
        tensor_obj_list.extend([stage_obj.op.output(0)])
        tensor_idx_list.append(stage_idx)
    gen_cheque_param.sch.cce_special[cce_special_key] = tensor_obj_list
    cce_special_cheque.append(tensor_idx_list)


def proc_cce_special(gen_cheque_param: namedtuple, cce_special_cheque: list) -> None:
    '''
    get_stage_by_name
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    code_line = gen_cheque_param.code_line
    if ".cce_special" in code_line:
        sch = gen_cheque_param.sch
        if sch.cce_special is None:
            sch.cce_special = {}
            cce_special_cheque.extend([-1, get_primitive_id("cce_special")])
        else:
            _do_proc_cce_special(gen_cheque_param, cce_special_cheque)

        if len(cce_special_cheque) == 5:
            gen_cheque_param.cheque_list.append(cce_special_cheque)


def _get_tensor_obj_list(cheque_list: list, tensor_name_list: list, sch_targets: list) -> list:
    # tuple_reduce generate special config
    spec_scene = False
    for cheque in cheque_list:
        if cheque[1] == 1 and isinstance(cheque[0], list):
            spec_scene = True
            break
    if not spec_scene:
        return []

    tensor_obj_list = []
    tensor_nums = 0
    stage_name = ''
    for tensor_name in tensor_name_list:
        if '_v' not in tensor_name:
            _, stage_obj = get_stage_by_name(tensor_name, sch_targets)
            tensor_obj_list.append(stage_obj.op.output(0))
        elif '_v' in tensor_name and '_l' in tensor_name:
            tensor_nums += 1
            stage_name = '%s_l' % (tensor_name.split('_v')[0])
        elif '_v' in tensor_name and '_l' not in tensor_name:
            tensor_nums += 1
            stage_name = tensor_name.split('_v')[0]
    if tensor_nums > 0:
        _, stage_obj = get_stage_by_name(stage_name, sch_targets)
        for idx in range(tensor_nums):
            tensor_obj_list.append(stage_obj.op.output(idx))
    return tensor_obj_list


def proc_build(sch: object, sch_targets: list, cheque_list: list, code_line: str, kernel_name: str = "") -> None:
    '''
    proc_build
    :param stage_name:
    :param sch_targets:
    :return:
    '''
    if 'config["tensor_list"]' in code_line:
        tensor_name_list = delete_brackets(code_line.split("=")[1]).split(",")
        tensor_name_list = (x.strip() for x in tensor_name_list if x.strip())
        tensor_obj_list = _get_tensor_obj_list(cheque_list, tensor_name_list, sch_targets)

        # try to build ensure proc right
        config = {}
        config["print_ir"] = False
        config["need_build"] = True
        current_time = str(int(time.time() * 1000))
        if not kernel_name:
            kernel_name = "%s_%s" % ("default", str(os.getpid()) + "_" + current_time)
        config["name"] = kernel_name
        config["tensor_list"] = tensor_obj_list
        config["bool_storage_as_1bit"] = False
        tbe.dsl.build(sch, config)


def proc_axis_name(code_line, specify_axis_name_dict):
    '''
    proc_axis_name
    :param code_line:
    :param specify_axis_name_dict:
    :return:
    '''
    if "=" in code_line and ',' not in code_line and 'axis' in code_line and 'op' in code_line:
        specify_axis_name = code_line.split("=")[0].strip()
        stage_name = get_param_in_brackets(code_line.split(".op")[0]).strip()
        axis_type = "axis"
        if "reduce_axis" in code_line:
            axis_type = "reduce_axis"
        axis_idx = int(code_line.split("[")[-1].split("]")[0])
        local_axis_name = '%s_%s_%d' % (stage_name, axis_type, axis_idx)
        if local_axis_name != specify_axis_name:
            specify_axis_name_dict[local_axis_name] = specify_axis_name


def get_cheque_tbe_compile_para(tbe_compile_para):
    """
    :param tbe_compile_para:
    :return:
    """
    def _bool2num(bool_value):
        if bool_value:
            return 1
        return 0
    tbe_para_cheque = [-1, get_primitive_id("tbe_compile_para")]
    tbe_para_dict = {v: k for (k, v) in TBE_COMPILE_PARA_DICT.items()}
    for key, value in tbe_compile_para.items():
        cheque_key = tbe_para_dict.get(key)
        if cheque_key is not None:
            tbe_para_cheque.append([cheque_key, _bool2num(value)])
    return tbe_para_cheque


def _get_sch(code_line: str) -> object:
    tensor = code_line.split("pickle.loads(b'")[-1][:-2]
    tensor_pickle_byte = tensor.encode('ISO-8859-1').decode('unicode-escape').encode('ISO-8859-1')
    sch = pickle.loads(tensor_pickle_byte)
    sch.cce_special = None
    return sch


def gen_cheque_by_code(code_line_list: list, kernel_name: str) -> list:
    '''
    gen_cheque_by_code
    :param code_line_list:
    :return:
    '''
    # get cheque_list by code of python file
    cheque_list = []
    cce_special_cheque = []
    sch = []
    sch_targets = []
    stage_get_axis_dict = {}
    specify_axis_name_dict = {}
    last_code_line = None
    for code_line in code_line_list:
        if "pickle.loads(" in code_line:
            sch = _get_sch(code_line)
            for stage in sch.stages:
                sch_targets.append(ScheduleTarget(stage.op.name, stage.op.output(0), []))
            continue
        if "    #" in code_line:
            continue

        gen_cheque_param = GenChequeParam(sch, sch_targets, cheque_list, code_line)
        proc_cache_read(gen_cheque_param)
        proc_cache_write(sch, sch_targets, cheque_list, code_line)
        proc_set_buffer_size(gen_cheque_param)
        proc_preload(gen_cheque_param)
        proc_double_buffer(gen_cheque_param)
        proc_compute_inline(gen_cheque_param)
        proc_axis_name(code_line, specify_axis_name_dict)
        proc_reduce_split(gen_cheque_param, stage_get_axis_dict, specify_axis_name_dict)
        proc_split(gen_cheque_param, stage_get_axis_dict, specify_axis_name_dict)
        proc_reorder(sch, sch_targets, cheque_list, code_line, last_code_line)
        proc_allocate_at(gen_cheque_param)
        proc_mem_unique(gen_cheque_param)
        proc_nparts(sch, sch_targets, cheque_list, code_line, specify_axis_name_dict)
        proc_compute_at(gen_cheque_param)
        proc_fuse(gen_cheque_param, specify_axis_name_dict)
        proc_rfactor(gen_cheque_param)
        proc_set_scope(gen_cheque_param)
        proc_bind(gen_cheque_param)
        proc_sub_bind(gen_cheque_param)
        proc_pragma(gen_cheque_param)
        proc_bind_buffer(gen_cheque_param)
        proc_block_sync("wait_block_sync", gen_cheque_param)
        proc_block_sync("set_block_sync", gen_cheque_param)
        proc_emit_insn(gen_cheque_param, last_code_line)
        proc_buffer_align(gen_cheque_param)
        proc_insert_param(cheque_list, code_line)
        proc_reused_by(sch, sch_targets, cheque_list, code_line)
        proc_storage_align(gen_cheque_param)
        proc_tbe_compile_para(gen_cheque_param)
        proc_cce_special(gen_cheque_param, cce_special_cheque)
        proc_build(sch, sch_targets, code_line, kernel_name)
        last_code_line = code_line
    return cheque_list


def gen_cheque_by_comments(code_line_list):
    '''
    gen_cheque_by_comments
    :param code_line_list:
    :return:
    '''
    # get cheque_list by comments of python file
    for code_line in code_line_list:
        if "# cheque_list: " in code_line:
            cheque_list_str = code_line.split("# cheque_list: ")[1].strip()
            comment_cheque = json.loads(cheque_list_str)
            return comment_cheque


def is_cheques_equal(cheque_list, new_cheque_list):
    '''
    is_cheques_equal
    :param cheque_list:
    :param new_cheque_list:
    :return:
    '''
    if cheque_list is None or new_cheque_list is None:
        return False
    for cheque in cheque_list:
        if cheque not in new_cheque_list:
            log.warn("sub cheque %s not in comment, its primitive is %s", cheque,
                      PRIMITIVE_DICT[cheque[1]])
            return False
    if len(cheque_list) == len(new_cheque_list):
        return True


def gen_cheque(code_line_list, kernel_name=""):
    '''
    gen_cheque
    :param py_path:
    :param kernel_name:
    :return:
    '''
    # new_cheque_list by py should equal to cheque_list by code
    cheque_list = gen_cheque_by_code(code_line_list, kernel_name)
    log.debug("cheque_list from code: %s", cheque_list)
    if os.getenv("DOUBLE_CHECK", "TRUE").lower() == "true":
        comments_cheque_list = gen_cheque_by_comments(code_line_list)
        log.debug("cheque_list from comments:%s", comments_cheque_list)
        ret = is_cheques_equal(cheque_list, comments_cheque_list)
        if ret:
            return cheque_list
        else:
            log.warn("cheque_list from code and comments is different!")
            return []
    return cheque_list
