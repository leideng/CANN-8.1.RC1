#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
rl bank manager
"""
from tbe.tvm import create_schedule
from tbe.common.buildcfg import get_current_build_config
from tbe.dsl.base import operation


class BankManager():
    """
    BankManager
    """
    def __init__(self):
        """init"""
        self.kernel_name = "default"
        self._current_op_name = ""
        self.no_hit_dict = {}
        self.res_map = {}
        self.tik_tensor_dict = {}
        self.cheque_list = []
        self.res_index = 0
        self.tik_build_config = {}

    def clear(self):
        """
        clear
        """
        self.__init__()

    def set_kernel_name(self, kernel_name: str) -> None:
        """
        set kernel_name
        :param kernel_name:
        :return:
        """
        self.kernel_name = kernel_name

    def update_bank_hit_info(self, no_hit: bool) -> None:
        """
        update no hit dict
        :param no_hit:
        :return:
        """
        self.no_hit_dict[self.kernel_name] = no_hit

    def get_bank_hit_info(self) -> bool:
        """
        get no hit dict
        :return: no_hit
        """
        return self.no_hit_dict.get(self.kernel_name, False)

    def set_current_op_name(self, op_name: str) -> None:
        """
        Set current op_name
        Parameters
        ----------
        op_name : string
        update current op_name to save op_params.
        """
        self._current_op_name = op_name

    def set_op_res(self, res: object) -> object:
        """
        set op output res
        Parameters
        ----------
        res : op output
        """
        sch = None
        if not get_current_build_config("enable_op_prebuild"):
            res_op = []
            op_outputs = []
            if isinstance(res, (list, tuple)):
                for single_res in res:
                    res_op.append(single_res.op)
                    op_outputs.append(single_res.op.name)
            else:
                res_op.append(res.op)
                op_outputs.append(res.op.name)
            sch = create_schedule(res_op)

            # is_fractal_format on behalf of 5hd
            is_fractal_format = None
            context = operation.get_context()
            if context and context.get_current_compute():
                is_fractal_format = context.get_current_compute().get("_is_fractal_format")

            sch.cce_special = {"op_outputs": op_outputs, "is_fractal_format": is_fractal_format}
            self.res_map.setdefault(self._current_op_name, []).append(sch)
        return sch

    def set_tensor_list(self, tensor_list: list) -> None:
        """
        save tensor_list
        Parameters
        ----------
        tensor_list : input tensors
        """
        if get_current_build_config("enable_op_prebuild"):
            return
        if self._current_op_name not in self.res_map:
            return

        sch = self.res_map[self._current_op_name][-1]
        if "tensor_list" in sch.cce_special:
            return

        sch.cce_special["tensor_list"] = tensor_list

    def set_tik_tensor(self, input_tensor: object, output: object) -> None:
        """
        Save tik op input&output tensor
        Parameters
        ----------
        input_tensor : tik input tensor
        output : tik output tensor
        """
        self.tik_tensor_dict[self._current_op_name] = [input_tensor, output]

    def set_cheque_list(self, cheque_list: list) -> None:
        """
        Save RL cheque_list
        Parameters
        ----------
        cheque_list : RL cheque_list
        """
        self.cheque_list.append(cheque_list)

    def clear_res_index(self) -> None:
        """
        clear RL res_index
        Parameters
        ----------
        """
        self.res_index = 0

    def clear_cheque_list(self) -> None:
        """
        clear RL cheque_list
        Parameters
        ----------
        """
        self.cheque_list = []

    def get_op_res(self, key: str) -> list:
        """
        Get op's output tensors
        Parameters
        ----------
        key : key to get build type

        Returns : op's output tensors
        """
        return self.res_map.get(key, None)

    def get_tik_tensor(self, key: str) -> list:
        """
        Get tik op input&output tensor
        Parameters
        ----------
        key : op name

        Returns : tik tensors
        """
        return self.tik_tensor_dict.get(key, None)

    def get_cheque_list(self, res_index: int = None) -> list:
        """
        Get RL cheque_list
        """
        if res_index is None:
            return self.cheque_list
        if res_index >= len(self.cheque_list):
            return None
        return self.cheque_list[res_index]

    def get_res_index(self) -> int:
        """
        Get RL res_index
        """
        curr_res_index = self.res_index
        self.res_index += 1
        return curr_res_index

    def collect_op_res(self: 'BankManager', kernel_name: str) -> dict:
        """
        collect op compile result for rl tune,
        this result is pickle friendly
        """
        sch_list = self.res_map.get(kernel_name)
        # custom attrs of schedule are discard by tvm when pickle, so we save it manually here
        cce_special_list = (getattr(x, "cce_special", None) for x in sch_list)
        sch_res = list(zip(sch_list, cce_special_list))
        tik_tensor = self.tik_tensor_dict.get(kernel_name)
        res = {"kernel_name": kernel_name, "sch": sch_res, "tik_tensor": tik_tensor}
        return res

    def restore_op_res(self: 'BankManager', op_res: dict) -> None:
        """
        restore op compile result for rl tune, the result is from 'collect_op_res'
        """
        kernel_name = op_res["kernel_name"]
        sch_list = []
        for elem in op_res["sch"]:
            sch = elem[0]
            if elem[1]:
                sch.cce_special = elem[1]
            sch_list.append(sch)
        self.res_map.setdefault(kernel_name, []).extend(sch_list)
        if op_res["tik_tensor"]:
            self.tik_tensor_dict[kernel_name] = op_res["tik_tensor"]


# Singleton for rl bank
BANK_MGR = BankManager()


def set_kernel_name(kernel_name: str) -> None:
    """
    set kernel_name
    :param kernel_name:
    :return:
    """
    BANK_MGR.set_kernel_name(kernel_name)


def update_bank_hit_info(no_hit: bool) -> None:
    """
    update no hit dict
    :param no_hit:
    :return:
    """
    BANK_MGR.update_bank_hit_info(no_hit)


def get_bank_hit_info() -> bool:
    """
    get no hit info
    :return: no_hit
    """
    return BANK_MGR.get_bank_hit_info()


def init_bank_hit_info(kernel_name: str) -> None:
    """
    init no hit dict
    :return: kernel_name
    """
    BANK_MGR.set_kernel_name(kernel_name)
    BANK_MGR.update_bank_hit_info(False)


def set_current_op_name(op_name: str) -> None:
    """
    Set current op_name, external interface for C call python

    Parameters
    ----------
    op_name : update current op_name to save op_params.
    """
    BANK_MGR.set_current_op_name(op_name)


def set_op_res(res_val: object) -> object:
    """
    Get current op_name's build type

    Parameters
    ----------
    res_val : op output tensors
    """
    sch = BANK_MGR.set_op_res(res_val)
    return sch


def set_tensor_list(tensor_list: list) -> None:
    """
    save tensor_list

    Parameters
    ----------
    tensor_list : input tensors
    """
    BANK_MGR.set_tensor_list(tensor_list)


def set_tik_tensor(input_tensor: object, output: object) -> None:
    """
    save tik_tensor

    Parameters
    ----------
    input_tensor : tik input tensor
    output : tik output tensor
    """
    BANK_MGR.set_tik_tensor(input_tensor, output)


def set_cheque_list(cheque_list: list) -> None:
    """
    Save RL cheque_list

    Parameters
    ----------
    cheque_list : RL cheque_list
    """
    BANK_MGR.set_cheque_list(cheque_list)


def clear_cheque_list() -> None:
    """
    clear RL cheque_list

    Parameters
    ----------
    """
    BANK_MGR.clear_cheque_list()


def clear_res_index() -> None:
    """
    clear RL res_index

    Parameters
    ----------
    """
    BANK_MGR.clear_res_index()


def get_op_res(key: str) -> list:
    """
    Get current op's output tensors

    Parameters
    ----------
    key : op name

    Returns : current op's output tensors.
    """
    return BANK_MGR.get_op_res(key)


def get_tik_tensor(key: str) -> list:
    """
    Get tik op input&output tensor

    Parameters
    ----------
    key : op name

    Returns : current op's output tensors.
    """
    return BANK_MGR.get_tik_tensor(key)


def get_cheque_list(res_index: int = None) -> list:
    """
    Get RL cheque_list
    """
    return BANK_MGR.get_cheque_list(res_index)


def get_res_index() -> int:
    """
    Get RL res_index
    """
    return BANK_MGR.get_res_index()


def get_tik_build_config() -> dict:
    """
    get tbe build config for tik dsl op in RL, after the config
    is fetched, it will be reset to empty
    """
    res = BANK_MGR.tik_build_config
    BANK_MGR.tik_build_config = {}
    return res


def set_tik_build_config(tik_build_config: dict) -> dict:
    """
    set tbe build config for tik dsl op in RL
    """
    BANK_MGR.tik_build_config = tik_build_config


def collect_op_res(kernel_name: str) -> dict:
    """
    collect op compile result for rl tune,
    this result is pickle friendly
    """
    return BANK_MGR.collect_op_res(kernel_name)


def restore_op_res(op_res: dict) -> None:
    """
    restore op compile result for rl tune, the result is from 'collect_op_res'
    """
    return BANK_MGR.restore_op_res(op_res)
