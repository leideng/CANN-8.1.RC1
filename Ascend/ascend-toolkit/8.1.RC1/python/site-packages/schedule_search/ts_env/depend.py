#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import numpy as np

from schedule_search.ts_env import tensor_cfg


def get_deps_flags(deps_vector):
    """

    :param deps_vector:
    :return:
    """
    # deps_vector是一个个8位的数，本函数是要把它们全拆成一个一个的0/1
    # 比如对于Stage25来说，它依赖24和23，被26所依赖，
    # 则其deps_vector：[0，0，0，0，0，0，0，0，0，0，0，0，5，128，0，0]
    # 转换后成为一个128的List，
    # 其中23，24，26个元素为1，其余为0，所以事实上是要倒过来的
    deps_flags = []
    # 倒序遍历每个deps_u8
    for deps_u8 in reversed(deps_vector):
        # deps_u8应该是0~255
        if not 0 <= deps_u8 < 256:
            raise AssertionError()
        # 把u8按从低到高位依次解析出Flag，添加到deps_flags中
        for i in range(8):
            u8_bit_i = (deps_u8 >> i) % 2
            deps_flags.append(u8_bit_i)
    return deps_flags


def get_fanin_stage_indices(stage_index, features):
    """

    :param stage_index:
    :param features:
    :return:
    """
    # 获取最近的依赖
    deps_vector = np.uint32(
        features[stage_index][tensor_cfg.FeatureTensorCfg.
                              deps_s:tensor_cfg.FeatureTensorCfg.deps_e + 1])
    deps_flags = get_deps_flags(deps_vector)
    return [
        i
        for i, dep_flag in enumerate(deps_flags[:stage_index])
        if dep_flag == 1
    ]


def get_fanout_stage_indices(stage_index, features):
    """

    :param stage_index:
    :param features:
    :return:
    """
    deps_vector = np.uint32(
        features[stage_index][tensor_cfg.FeatureTensorCfg.
                              deps_s:tensor_cfg.FeatureTensorCfg.deps_e + 1])
    deps_flags = get_deps_flags(deps_vector)
    return [
        i
        for i, dep_flag in enumerate(deps_flags)
        if dep_flag == 1 and i > stage_index
    ]


def get_fanin_sub_tree_indices(features):
    """
    获取某个节点对应的输入子树
    :param features:
    :return:
    """
    # 获取所有的deps，包括直接依赖和间接依赖
    subtree_indices = {}
    deps_s = tensor_cfg.FeatureTensorCfg.deps_s
    deps_e = tensor_cfg.FeatureTensorCfg.deps_e + 1
    for stage_index, feature_vec in enumerate(features):
        subtree_indices[stage_index] = []
        deps_vector = np.uint32(feature_vec[deps_s:deps_e])
        deps_flags = get_deps_flags(deps_vector)
        direct_deps = [
            i
            for i, dep_flag in enumerate(deps_flags[:stage_index])
            if dep_flag == 1
        ]
        subtree_indices.get(stage_index).extend(direct_deps)
        for direct_dep in direct_deps:
            subtree_indices.get(stage_index).extend(subtree_indices.get(direct_dep))
    return subtree_indices


def get_fanout_sub_tree_indices(features):
    """
    获取某个节点对应的输出子树
    :param features:
    :return:
    """
    # 获取所有的deps，包括直接依赖和间接依赖
    subtree_indices = {}
    deps_s = tensor_cfg.FeatureTensorCfg.deps_s
    deps_e = tensor_cfg.FeatureTensorCfg.deps_e + 1
    stage_num = len(features)
    for stage_index in range(stage_num - 1, -1, -1):
        feature_vec = features[stage_index]
        subtree_indices[stage_index] = []
        deps_vector = np.uint32(feature_vec[deps_s:deps_e])
        deps_flags = get_deps_flags(deps_vector)
        direct_deps = [
            i
            for i, dep_flag in enumerate(deps_flags[stage_index + 1:], stage_index + 1)
            if dep_flag == 1
        ]
        subtree_indices.get(stage_index).extend(direct_deps)
        for direct_dep in direct_deps:
            subtree_indices.get(stage_index).extend(subtree_indices.get(direct_dep))
    return subtree_indices


def get_real_fanin_fanout_stages(stage_index,
                                 features,
                                 inlined_stages,
                                 direction='fanin'):
    """
    获取stage的直接依赖，如果直接依赖为inline, 则往上推一个
    """
    if direction == 'fanin':
        func = get_fanin_stage_indices
    else:
        func = get_fanout_stage_indices
    fan_stages = func(stage_index, features)
    tmp_child_stages = fan_stages.copy()
    read_child_stages = []
    while True:
        cur_child_stages = []
        for child_stage in tmp_child_stages:
            if child_stage not in inlined_stages:
                # child stage与stage at的target相同，则是依赖的stage
                read_child_stages.append(child_stage)
            else:
                # child stage与stage at的target不同，
                # 而且child stage不是当前stage的at target，需要继续向下找
                cur_child_stages.extend(func(child_stage, features))

        if not cur_child_stages:
            break
        tmp_child_stages = cur_child_stages

    return fan_stages, read_child_stages


def get_fanouts_from_sch(sch, stage):
    """

    :param sch:
    :param stage:
    :return:
    """
    stages = list(sch.stages)
    stage_tensors = []
    for idx in range(stage.op.num_outputs):
        stage_tensors.append(stage.op.output(idx))

    stage_index = stages.index(stage)
    fanouts = []
    for i, each_stage in enumerate(stages):
        if i <= stage_index:
            continue
        for input_tensor in each_stage.op.input_tensors:
            try:
                if input_tensor in stage_tensors and i not in fanouts:
                    fanouts.append(i)
                    break
            except ValueError:
                continue

    return fanouts
