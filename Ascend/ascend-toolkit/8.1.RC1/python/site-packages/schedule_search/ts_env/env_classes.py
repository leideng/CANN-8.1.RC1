#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import json
import os
from collections import namedtuple

import fcntl

from schedule_search import log
from schedule_search import util


class OomError:
    """
    OomError
    """
    L1_BUFF = "l1_oom"
    UB_BUFF = "ub_oom"
    L0AB = "l0ab_oom"
    L0C = "l0c_oom"
    SEGMENT = "segment_oom"
    OVERFLOW = "overflow_oom"
    ALL = [L1_BUFF, UB_BUFF, L0AB, L0C, SEGMENT, OVERFLOW]

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.UB_BUFF

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.ALL


class TensorInfo:
    """
    TensorInfo
    """

    def __init__(self, name, shape, dtype):
        self.name = name
        self.shape = shape
        self.dtype = dtype

    def __repr__(self):
        print_str = "TensorInfo, name: %s, shape: %s, dtype: %s" % (
            self.name, self.shape, self.dtype)
        return print_str

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.name

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.shape


class KernelRunArgsInfo:
    """
    KernelRunArgsInfo
    """

    def __init__(self,  # pylint: disable=R0913
                 op_name,
                 output_cnt,
                 kernel_bin_path,
                 unique_id,
                 gen_golden=0):
        self.kernel_bin_path = kernel_bin_path
        self.unique_id = unique_id
        self.gen_golden = gen_golden

        self.inplace_list = [-1] * output_cnt
        op_name_list = op_name.split("__")
        if set(op_name_list) & set(["bn_training_update"]):
            # 最后两个输入和第2, 3个输出inplace
            self.inplace_list[1] = 5
            self.inplace_list[2] = 6

        if kernel_bin_path == "invalid_kernel_bin_path":
            self.block_dim = 1
            self.kernel_name = unique_id
            self.workspace_sizes = []
        else:
            kernel_json_path = kernel_bin_path.replace(".o", ".json")
            if not os.path.exists(kernel_bin_path) or not os.path.exists(kernel_json_path):
                log.warn("%s or %s does not exists." % (kernel_bin_path, kernel_json_path))
                self.block_dim = 1
                self.kernel_name = unique_id
                self.workspace_sizes = []
                return
            # 从json文件读取block_dim、workspace_sizes
            with open(kernel_json_path, 'r') as file_handler:
                kernel_dict = json.load(file_handler)
                self.block_dim = kernel_dict.get("blockDim", 1)
                self.kernel_name = kernel_dict.get("binFileName", "unknown")
                self.workspace_sizes = kernel_dict.get("workspace", {}).get('size', [])

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.gen_golden

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.kernel_name


class LocalLock:
    """
    LocalLock
    """
    def __init__(self, lock_file):
        if not os.path.exists(lock_file):
            log.dbg("lock_file: %s not exist!", lock_file)
            util.write_to_file(lock_file)
        self.lock_fd = os.open(lock_file, os.O_CREAT, 0o640)

    def lock(self):
        """
        lock
        """
        fcntl.flock(self.lock_fd, fcntl.LOCK_EX)

    def unlock(self):
        """
        unlock
        """
        os.close(self.lock_fd)


SchInfo = namedtuple(
        'SchInfo',
        ['sch', 'code', 'cleaned_actions', 'retry_t2c_rules', 'cheque_list'])

KernelInfo = namedtuple('KernelInfo', [
        'error_code', 'kernel_run_obj', 'sch_info'])
