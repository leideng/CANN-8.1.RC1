#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from typing import NoReturn

from tbe import tvm

from schedule_search import log
from schedule_search.ts_env import env_util
from schedule_search.ts_env.tensor_to_code.t2c_util import T2cParams
from schedule_search.ts_env.tensor_to_code.trs_comm import calc_trs_reorder_action
from schedule_search.ts_env.tensor_to_code.trs_comm import calc_trs_split_axis
from schedule_search.ts_env.cheque_generator import get_storage_align_cheque
from schedule_search.ts_env.env_consts import MODE_RUNTIME


def last_axis_has_cross(ori_permute: list, high_ub_split_axis: int, low_ub_split_axis: int) -> bool:
    """
    last axis has cross or not
    :param ori_permute:
    :param high_ub_split_axis:
    :param low_ub_split_axis:
    :return:
    """
    ori_perm = []
    for index in ori_permute:
        ori_perm.append(int(index))
    permute = sorted(range(len(ori_perm)), key=ori_perm.__getitem__)

    dim_len = len(ori_permute)
    is_last_transpose = ori_permute[dim_len - 1] != dim_len - 1
    src_in_ub_by_out = permute[ori_permute[low_ub_split_axis]:]
    base_order = list(range(len(permute)))
    consequent_dst = base_order[high_ub_split_axis:]
    last_has_cross = is_last_transpose and any(i in consequent_dst for i in src_in_ub_by_out)

    return last_has_cross


def calc_storage_align(ori_permute: list,
                       high_ub_split_axis: int, low_ub_split_axis: int,
                       reorder_in_index: int, reorder_out_index: int) -> [list, bool]:
    """
    calculate storage_align axis index
    :param ori_permute:
    :param permute:
    :param high_ub_split_axis:
    :param low_ub_split_axis:
    :param reorder_in_index:
    :param reorder_out_index:
    :return:
    """
    ori_perm = []
    for ind in ori_permute:
        ori_perm.append(int(ind))
    permute = sorted(range(len(ori_perm)), key=ori_perm.__getitem__)

    # split out: all axes after out_split_axis, include itself
    # split input axis in input_tensor
    # split out axes in input_tensor
    out_in_input_split = []
    for axis in ori_perm[high_ub_split_axis:]:
        if axis < ori_perm[low_ub_split_axis]:
            out_in_input_split.append(axis)
    # find align axis in input_order_tensor index
    input_align_axis = -1
    for index, value in enumerate(reorder_in_index):
        if value in out_in_input_split:
            input_align_axis = index

    out_in_output_split = []
    for axis in permute[ori_perm[low_ub_split_axis]:]:
        if axis < high_ub_split_axis:
            out_in_output_split.append(axis)
    output_align_axis = -1
    for index, value in enumerate(reorder_out_index):
        if value in out_in_output_split:
            output_align_axis = index

    return [input_align_axis, output_align_axis]


def align_a_trs_stage(stage_name: str, align_axis_index: int,
                      t2c_params: T2cParams, stage_index: int, last_has_cross: bool) -> list:
    """
    align transpose stage
    :param stage:
    :param stage_name:
    :param align_axis_index:
    :param t2c_params:
    :return:
    """
    stage = t2c_params.schedule.stages[stage_index]
    # 不需要考虑dtype变化，每个tensor只看自己的输出dtype来计算block_num
    vector_block_num = env_util.get_block_num(stage.op.output(0).dtype)
    if align_axis_index < 0:
        return []

    # b32和b64的last_tranpose场景，输出tensor的对齐条件需要变为原来的16倍
    ori_permute = t2c_params.stages_info[-1]["trs_params"]["ori_permute"]
    dim_len = len(ori_permute)
    is_last_trs = int(ori_permute[dim_len - 1]) != dim_len - 1
    # b16_factor
    if stage.op.tag == "transpose" and not last_has_cross \
            and is_last_trs and vector_block_num < 16:
        vector_block_num *= 16

    code_line = 'sch[%s].storage_align(sch[%s].op.axis[%s], %s, 0)' % \
                (stage_name, stage_name, align_axis_index, vector_block_num)
    if t2c_params.mode == MODE_RUNTIME:
        stage.storage_align(stage.op.axis[align_axis_index], vector_block_num,
                            0)

    # 生成storage_align操作对应的cheque
    get_storage_align_cheque(t2c_params, stage_index, align_axis_index,
                             vector_block_num)
    return [code_line]


def do_trs_align(t2c_params: T2cParams, do_align_dict: dict, last_has_cross: bool) -> NoReturn:
    """
    do align for trs
    :param t2c_params:
    :param do_align_dict:
    :return:
    """
    # do_align
    t2c_params.code_lines.extend(['\n', '# storage_align code for trs'])
    code_lines = []
    for stage_index, axis_index in do_align_dict.items():
        stage_name = t2c_params.stages_info[stage_index]["name"]
        sub_code = align_a_trs_stage(stage_name, axis_index,
                                     t2c_params, stage_index, last_has_cross)
        code_lines.extend(sub_code)

    t2c_params.code_lines.extend(code_lines)


def proc(t2c_params: T2cParams) -> bool:
    """
    transpose storage align
    :param t2c_params:
    :return:
    """
    align_stage_list = []

    for stage_index, stage in enumerate(t2c_params.schedule.stages):
        if isinstance(stage.op, tvm.PlaceholderOp):
            continue

        if stage_index in t2c_params.inlined_stages:
            continue

        if '.local.UB' in stage.op.name:
            align_stage_list.append((stage_index, stage))

    # only do align for input and output in UB
    if len(align_stage_list) != 2:
        log.warn('align stages num should be equal to 2 for transpose.')

    # calc ori_permute and chosen_axes
    ori_permute = t2c_params.stages_info[-1]["trs_params"]["ori_permute"]
    chosen_axes = t2c_params.stages_info[-1]["trs_params"]["chosen_axes"]
    # calc split axis
    low_ub_split_axis, high_ub_split_axis = calc_trs_split_axis(t2c_params, chosen_axes)
    # calc reorder index
    reorder_in_index, reorder_out_index = calc_trs_reorder_action(t2c_params)
    # calc storage_align axis index
    align_axes = calc_storage_align(
        ori_permute, high_ub_split_axis, low_ub_split_axis,
        reorder_in_index, reorder_out_index)
    # calc last axis has cross or not
    last_has_cross = last_axis_has_cross(ori_permute, high_ub_split_axis, low_ub_split_axis)

    # do_storage_align
    do_align_dict = {}
    for index, (stage_index, _) in enumerate(align_stage_list):
        # -1时不进行storage_align，与手写模板保持一致
        if align_axes[index] == -1:
            continue
        do_align_dict[stage_index] = align_axes[index]

    do_trs_align(t2c_params, do_align_dict, last_has_cross)

    # 记录选轴和对齐轴信息到py文件中
    t2c_params.code_lines.extend(['# chosen_axes: %s' % chosen_axes])
    t2c_params.code_lines.extend(['# updated_axes: %s' % [low_ub_split_axis, high_ub_split_axis]])
    t2c_params.code_lines.extend(['# align_axes: %s' % align_axes])

    return True
