#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from collections import namedtuple

from schedule_search import soc_cfg
from schedule_search.ts_env import env_util
from schedule_search.ts_env.tensor_cfg import AxisInfo

REDUCE_INFO_KEYS = ('reduce_tensors',
                    'shape_before_reduce',
                    'reduce_axis_indexs')
SPLIT_INFO_KEYS = ('factor',
                   'axis_index',
                   'axis_name',
                   'axis_obj',
                   'outer_axis_name',
                   'outer_axis_obj',
                   'inner_axis_name',
                   'inner_axis_obj')
ReduceInfo = namedtuple('ReduceInfo', REDUCE_INFO_KEYS)
SplitInfo = namedtuple('SplitInfo', SPLIT_INFO_KEYS)



def find_split_axis(shape,  # pylint: disable=R0912
                    begin_axis, end_axis, bound_size):
    """
    切出bound_size能装下的最大切分，用于多核切分
    """
    #
    axis_num = len(shape)
    if begin_axis >= axis_num \
            or begin_axis < 0 \
            or end_axis >= axis_num \
            or end_axis < 0:
        return 0, 1
    if begin_axis < end_axis:
        step = 1
    else:
        step = -1
    split_axis_index = end_axis
    temp_size = 1
    need_split = False
    for i in range(begin_axis, end_axis + step, step):
        temp_size = temp_size * shape[i]
        if temp_size >= bound_size:
            split_axis_index = i
            temp_size = temp_size / shape[i]
            need_split = True
            break
    split_size = 1
    # split the split axis
    if need_split:
        for i in range(1, shape[split_axis_index] + 1, 1):
            if (temp_size * i) == bound_size:
                split_size = i
                break
            if (temp_size * i) > bound_size:
                split_size = i - 1
                break
    else:
        # 说明最后一根轴要整吃
        split_size = shape[end_axis]
    return split_axis_index, split_size


def _default_atomic_write_axis(t2c_params,
                               atomic_write_satge_index,
                               atomic_write_satge_name,
                               shape_before_reduce,
                               reduce_axis_indexs):
    """

    :param t2c_params:
    :param atomic_write_satge_index:
    :return:
    """
    # 默认at到唯一的reduce轴
    compute_at_axis_info = None
    for axis in t2c_params.axis_info_list[atomic_write_satge_index]:
        if axis.type == "reduce_axis":
            compute_at_axis_info = axis
            break
    # 默认emit_insn到0轴
    emit_insn_axis_index = 0
    emit_insn_axis_name \
        = '%s_axis_%d' % (atomic_write_satge_name, emit_insn_axis_index)
    code_line = '%s = sch[%s].op.axis[%d]' % (
        emit_insn_axis_name, atomic_write_satge_name, emit_insn_axis_index)
    if code_line not in t2c_params.code_lines:
        t2c_params.code_lines.append(code_line)
    emit_insn_axis_obj = t2c_params.schedule.stages[
        atomic_write_satge_index].op.axis[emit_insn_axis_index]
    emit_insn_axis_info = AxisInfo(emit_insn_axis_name,
                                   emit_insn_axis_obj.dom.extent.value, 'axis',
                                   emit_insn_axis_index, 'all',
                                   emit_insn_axis_obj)

    # 1、reduce all/last直接at到唯一的reduce轴，emit_insn到0轴
    if len(shape_before_reduce) == len(reduce_axis_indexs) or \
            len(shape_before_reduce) in reduce_axis_indexs:
        return True, compute_at_axis_info, emit_insn_axis_info

    return False, compute_at_axis_info, emit_insn_axis_info


def _at_norm_axis_check(t2c_params, shape_before_reduce, reduce_axis_indexs):
    """

    :param t2c_params:
    :param shape_before_reduce:
    :param reduce_axis_indexs:
    :return:
    """
    # 2、reduce nist查看是否需要at/emit_insn到普通轴
    none_redcuce_shape = []
    for axis_index, axis_len in enumerate(shape_before_reduce):
        if axis_index not in reduce_axis_indexs:
            none_redcuce_shape.append(axis_len)
    bound_size = soc_cfg.get_ub_size() // 2
    last_none_reduce_axis_s, last_none_reduce_axis_e \
        = env_util.find_last_none_reduce_axis(shape_before_reduce,
                                              reduce_axis_indexs)
    last_none_reduce_size = 1
    for index in range(last_none_reduce_axis_s, last_none_reduce_axis_e + 1):
        last_none_reduce_size *= shape_before_reduce[index]
    block_size = env_util.get_block_num(
        t2c_params.op_schedule_info.reduce_atomic_dict['reduce_dtype'])
    is_axis_32b_align = last_none_reduce_size % block_size == 0
    if not is_axis_32b_align:
        bound_size = last_none_reduce_size
    # 逆序调用这个函数，获取split_factor
    split_axis_index, split_factor = find_split_axis(
        none_redcuce_shape,
        len(none_redcuce_shape) - 1, 0, bound_size)
    return split_axis_index, split_factor, none_redcuce_shape


def _get_at_axis_info(t2c_params,
                      split_axis_index,
                      none_redcuce_shape,
                      split_factor,
                      atomic_write_satge_index):
    """

    :param t2c_params:
    :param split_axis_index:
    :param none_redcuce_shape:
    :param split_factor:
    :param atomic_write_satge_index:
    :return:
    """
    compute_at_axis_index = split_axis_index
    atomic_write_satge_name \
        = t2c_params.stages_info[atomic_write_satge_index]['name']
    # 轴整吃，compute_at往前挪一根轴
    if split_factor == none_redcuce_shape[split_axis_index]:
        compute_at_axis_index -= 1
    if compute_at_axis_index != -1:
        compute_at_axis_name = '%s_axis_%d' % (atomic_write_satge_name,
                                               compute_at_axis_index)
        code_line = '%s = sch[%s].op.axis[%d]' % (compute_at_axis_name,
                                                  atomic_write_satge_name,
                                                  compute_at_axis_index)
        if code_line not in t2c_params.code_lines:
            t2c_params.code_lines.append(code_line)
        compute_at_axis_obj = t2c_params.schedule.stages[
            atomic_write_satge_index].op.axis[compute_at_axis_index]
        compute_at_axis_info = AxisInfo(compute_at_axis_name,
                                        compute_at_axis_obj.dom.extent.value,
                                        'axis', compute_at_axis_index, 'all',
                                        compute_at_axis_obj)
        return compute_at_axis_info
    return None


def _get_emit_axis_info(t2c_params,
                        split_axis_index,
                        none_redcuce_shape,
                        split_factor,
                        atomic_write_satge_index):
    """

    :param t2c_params:
    :param split_axis_index:
    :param none_redcuce_shape:
    :param split_factor:
    :param atomic_write_satge_index:
    :return:
    """
    atomic_write_satge_name \
        = t2c_params.stages_info[atomic_write_satge_index]['name']
    emit_insn_axis_index = split_axis_index
    # 轴不整吃，emit_insn往后挪一根轴
    if split_factor != none_redcuce_shape[split_axis_index]:
        emit_insn_axis_index += 1
    if emit_insn_axis_index < len(none_redcuce_shape):
        emit_insn_axis_name = '%s_axis_%d' % (atomic_write_satge_name,
                                              emit_insn_axis_index)
        code_line = '%s = sch[%s].op.axis[%d]' % (
            emit_insn_axis_name, atomic_write_satge_name, emit_insn_axis_index)
        if code_line not in t2c_params.code_lines:
            t2c_params.code_lines.append(code_line)
        emit_insn_axis_obj = t2c_params.schedule.stages[
            atomic_write_satge_index].op.axis[emit_insn_axis_index]
        emit_insn_axis_info = AxisInfo(emit_insn_axis_name,
                                       emit_insn_axis_obj.dom.extent.value,
                                       'axis', emit_insn_axis_index, 'all',
                                       emit_insn_axis_obj)
        return emit_insn_axis_info
    return None


def get_reduce_atomic_write_axis(t2c_params,   # pylint: disable=R0914,R0912
                                 atomic_write_satge_index):
    """

    :param t2c_params:
    :param atomic_write_satge_index:
    :return:
    """
    # 获取at和emit_insn的轴
    if t2c_params.op_schedule_info.tiling_case == 0:
        return None, None

    atomic_write_satge_name \
        = t2c_params.stages_info[atomic_write_satge_index]['name']
    shape_before_reduce = t2c_params.op_schedule_info.reduce_atomic_dict.get(
        'shape_before_reduce', [])
    reduce_axis_indexs = t2c_params.op_schedule_info.reduce_atomic_dict.get(
        'reduce_axis_indexs', [])

    # 默认reduce all/last直接at到唯一的reduce轴，emit_insn到0轴
    ret, compute_at_axis_info, emit_insn_axis_info = \
        _default_atomic_write_axis(t2c_params,
                                   atomic_write_satge_index,
                                   atomic_write_satge_name,
                                   shape_before_reduce,
                                   reduce_axis_indexs)
    if ret:
        return compute_at_axis_info, emit_insn_axis_info

    # reduce nist查看是否需要at/emit_insn到普通轴
    split_axis_index, split_factor, none_redcuce_shape = _at_norm_axis_check(
        t2c_params, shape_before_reduce, reduce_axis_indexs)

    # compute_at
    ret = _get_at_axis_info(t2c_params,
                            split_axis_index,
                            none_redcuce_shape,
                            split_factor,
                            atomic_write_satge_index)
    if ret:
        compute_at_axis_info = ret

    # emit_insn
    ret = _get_emit_axis_info(t2c_params,
                              split_axis_index,
                              none_redcuce_shape,
                              split_factor,
                              atomic_write_satge_index)
    if ret:
        emit_insn_axis_info = ret

    return compute_at_axis_info, emit_insn_axis_info


def gen_reduce_info(reduce_info=None, **kwargs):
    '''
    记录reduce_axis信息的类
    '''
    values = []
    for key in REDUCE_INFO_KEYS:
        value = kwargs.get(key)
        if value is None:
            value = getattr(reduce_info, key, None)
        values.append(value)

    return ReduceInfo(*values)


def gen_split_info(split_info=None, **kwargs):
    '''
    记录split信息的类
    '''
    values = []
    for key in SPLIT_INFO_KEYS:
        value = kwargs.get(key)
        if value is None:
            value = getattr(split_info, key, None)
        values.append(value)

    return SplitInfo(*values)
