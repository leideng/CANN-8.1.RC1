#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from tbe import tvm

from schedule_search import log
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_cfg import AxisInfo
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.tensor_to_code import t2c_util
from schedule_search.ts_env.cheque_generator import get_axis_cheque
from schedule_search.ts_env.cheque_generator import get_split_cheque
from schedule_search.timer import timer

HOWO_1_AXIS_NAME = "HoWo1"
HOWO_1_AXIS_TAG = "HoWo/C0"


class SubAxisInfo:  # pylint: disable=R0913
    """
    SubAxisInfo
    """
    def __init__(
            self,
            axis_tag,
            axis_len,
            origin_axis,
            outer_axis,
            inner_axis):
        self.axis_tag = axis_tag  # axis的标记，如N, C, H, W
        self.axis_len = axis_len  # 轴长度
        self.origin_axis = origin_axis  # 原始轴axis的名字
        self.outer_axis = outer_axis  # 切分后的外轴名字
        self.inner_axis = inner_axis  # 切分后的内轴名字

    def __str__(self):
        print_str = "axis_tag: %s, axis_len: %s, origin_axis: %s, " \
                    "outer_axis: %s, inner_axis: %s" \
                    "" % (self.axis_tag, self.axis_len,
                          self.origin_axis, self.outer_axis,
                          self.inner_axis)
        return print_str

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.axis_tag

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.axis_len


@timer()
def get_fused_axis_info(  # pylint: disable=R0913,R0914,R0912
        stage,
        axis_type,
        attr_dict,
        axis_info_dict,
        intrin,
        stage_name):
    """ 识别融合的轴中各子轴的信息SubAxisInfo"""
    axis_tag_list = attr_dict[axis_type]
    c0_value = 16
    split_info_list = []
    # 遍历所有轴
    for i, axis_tag in enumerate(axis_tag_list):
        sub_split_infos = []
        axis_name = '%s_%s_%d' % (stage_name, axis_type, i)
        if isinstance(axis_tag, tvm.runtime.container.String):
            axis_tag_value = str(axis_tag)
        else:
            axis_tag_value = axis_tag.value
        sub_axis_list = axis_tag_value.replace(' ', '').split("*")
        origin_axis = "sch[%s].op.%s[%s]" % (stage_name, axis_type, i)
        if len(sub_axis_list) == 1:
            if axis_type == "axis":
                axis_len = stage.op.axis[i].dom.extent.value
            else:
                axis_len = stage.op.reduce_axis[i].dom.extent.value
            sub_split_infos.append(
                SubAxisInfo(axis_tag_value, axis_len, origin_axis, axis_name, None))
            split_info_list.append(sub_split_infos)
            continue

        # 遍历每个轴的各子轴
        for j, sub_axis in enumerate(sub_axis_list):
            sub_axis_len = t2c_util.get_sub_axis_len(sub_axis, axis_info_dict)
            if j == len(sub_axis_list) - 1:
                sub_split_infos.append(
                    SubAxisInfo(sub_axis, sub_axis_len, origin_axis, None, None))
                break

            # 当前不允许切Wo, HoWo认为是最后一个sub axis, 针对mad stage的特殊处理
            if origin_axis == "%s_HoWo" % axis_name:
                axis_len = sub_axis_len * axis_info_dict[sub_axis_list[j + 1]].value
                if intrin == "mad" and i == len(axis_tag_list) - 1:
                    outer_axis = "%s_%s" % (axis_name, HOWO_1_AXIS_NAME)
                    inner_axis = "%s_C0" % axis_name
                    sub_split_infos.append(
                        SubAxisInfo(HOWO_1_AXIS_TAG, (axis_len + 15) // 16,
                                    origin_axis, outer_axis, inner_axis))
                    sub_split_infos.append(
                        SubAxisInfo("C0", c0_value, origin_axis, None, None))
                else:
                    sub_split_infos.append(
                        SubAxisInfo("HoWo", axis_len, origin_axis, None, None))
                break

            out_axis = "%s_%s" % (axis_name, sub_axis)
            inner_axis = "%s_%s" % (axis_name, "".join(sub_axis_list[j + 1:]))
            sub_split_infos.append(
                SubAxisInfo(sub_axis, sub_axis_len, origin_axis, out_axis, inner_axis))
            origin_axis = inner_axis
        split_info_list.append(sub_split_infos)
    return split_info_list


class SplitAxisInfo:
    """
    SplitAxisInfo
    """
    def __init__(self, axis_index, ajusted_factor, sub_axis_split, sub_factor):
        self.axis_index = axis_index  # 需要切分的轴在axis_infos的位置
        self.factor = ajusted_factor  # 调整后的factor
        self.sub_axis_split = sub_axis_split  # 融合轴中切分的子轴tag
        self.sub_factor = sub_factor  # 切分子轴对应的factor

    def __str__(self):
        print_str = "axis_index: %s, factor: %s, sub_axis_split: %s, " \
                    "sub_factor: %s" % (self.axis_index, self.factor,
                                        self.sub_axis_split, self.sub_factor)
        return print_str

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.axis_index

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.factor


@timer()
def get_split_axis_info(factor,  # pylint: disable=R0912
                        axis_infos, split_infos, min_axis_index=-1):
    """

    :param factor:
    :param axis_infos:
    :param split_infos:
    :param min_axis_index:
    :return:
    """
    factor_reserve = factor
    sub_factor = 0
    ajusted_factor = 1
    sub_axis_split = split_infos[0].axis_tag
    min_limit = False
    for i in range(len(split_infos)):
        curr_index = len(split_infos) - 1 - i
        if HOWO_1_AXIS_TAG == split_infos[curr_index].axis_tag:
            # TBE指令映射限制，不能切Wo，故K轴只能切h
            sub_axis_split = "Ho"
            sub_factor = factor_reserve
            ajusted_factor *= sub_factor
            break
        if factor_reserve < split_infos[curr_index].axis_len:
            sub_factor = factor_reserve
            ajusted_factor *= sub_factor
            sub_axis_split = split_infos[curr_index].axis_tag
            break
        # 达到了约束的最低index，则不再往前找子轴，直接切分该轴，切分因子定为子轴轴长
        if min_axis_index == curr_index:
            # 子轴轴长
            sub_factor = split_infos[curr_index].axis_len
            ajusted_factor *= sub_factor
            sub_axis_split = split_infos[curr_index].axis_tag
            min_limit = True
            break
        sub_factor = factor_reserve
        factor_reserve = factor_reserve // split_infos[curr_index].axis_len
        ajusted_factor *= split_infos[curr_index].axis_len

    split_axis_index = 0
    # 从后往前倒推找切分轴
    factor_reserve = ajusted_factor
    for i in range(len(axis_infos)):
        curr_index = len(axis_infos) - 1 - i
        if axis_infos[curr_index].name.endswith(HOWO_1_AXIS_NAME) or (
                factor_reserve < axis_infos[curr_index].len
        ) or (min_limit and factor_reserve == axis_infos[curr_index].len):
            split_axis_index = curr_index
            break

        factor_reserve = factor_reserve // axis_infos[curr_index].len
        # HoWo/C0, C0, 如果切HoWo/C0，则切分因子不需要乘以C0的长度
        if split_axis_index < curr_index:
            ajusted_factor = ajusted_factor // axis_infos[curr_index].len

    return SplitAxisInfo(split_axis_index, ajusted_factor, sub_axis_split,
                         sub_factor)


@timer()
def split_fuse_axis(  # pylint: disable=R0913,R0914
        t2c_params,
        stage,
        axis_index,
        split_infos,
        axis_type,
        intrin,
        factor,
        stage_name,
        stage_index):
    """

    :param t2c_params:
    :param stage:
    :param axis_index:
    :param split_infos:
    :param axis_type:
    :param intrin:
    :param factor:
    :param stage_name:
    :return:
    """
    def is_c_axis(axis_tag):
        """

        :param axis_tag:
        :return:
        """
        if axis_tag in ["C0", "Ci0", "Co0"]:
            return True
        return False

    def _get_split_info(factor_reserve):
        axis_tag_merged = []
        axis_len_merged = 1
        split_axis_index = -1
        hw_flag = False
        # 从后往前倒推找切分轴
        for i in range(len(split_infos)):
            curr_index = len(split_infos) - 1 - i
            axis_tag_merged.append(split_infos[curr_index].axis_tag.replace("/C0", "1"))
            axis_len_merged *= split_infos[curr_index].axis_len
            # 针对mad stage的特殊处理
            if intrin == "mad" and axis_type == "reduce_axis" and \
                    split_infos[curr_index].axis_tag == HOWO_1_AXIS_TAG:
                split_axis_index = curr_index
                hw_flag = True
                break
            if factor_reserve < split_infos[curr_index].axis_len:
                split_axis_index = curr_index
                break
            factor_reserve = factor_reserve // split_infos[curr_index].axis_len
        axis_tag_merged.reverse()
        return hw_flag, split_axis_index, axis_tag_merged, axis_len_merged

    code_lines = []
    stage_axis_info = []
    c0_value = 16
    # 切分第一刀和第二刀必须在同一根子轴上，如ci1 * kd轴不允许出现第一刀切ci1，
    # 第二刀切kd
    hw_flag, split_axis_index, axis_tag_merged, axis_len_merged = _get_split_info(factor)
    log.dbg("split_axis_index of sch[%s].%s[%s] is: %s, factor: %s!",
            stage_name, axis_type, axis_index, split_axis_index, factor)
    # split_axis_index之前的轴需要先split开
    inner_axis = "sch[%s].op.%s[%s]" % (stage_name, axis_type, axis_index)
    axis_name = '%s_%s_%d' % (stage_name, axis_type, axis_index)
    # 实际切分轴之前的轴需要split，之后的轴则不需要split
    for i in range(split_axis_index):
        code_lines.append('%s, _ = sch[%s].split(%s, nparts=%d)' %
                          (split_infos[i].outer_axis, stage_name,
                           split_infos[i].origin_axis, split_infos[i].axis_len))
        axis_attr = "c" if is_c_axis(split_infos[i].axis_tag) else "sub_axis"
        stage_axis_info.append(
            AxisInfo(split_infos[i].outer_axis,
                     split_infos[i].axis_len,
                     axis_type,
                     axis_index,
                     axis_attr,
                     sub_axis_split=split_infos[i].axis_tag,
                     sub_axis_factor=1))
        inner_axis = split_infos[i].inner_axis

        # split_nparts操作对应的cheque
        get_split_cheque(t2c_params, stage_index, 2 * i, split_infos[i].axis_len, 'nparts')

    if hw_flag:
        outer_axis = axis_name + "_%s" % "".join(axis_tag_merged[:-1])
        c0_axis = axis_name + "_k0"
        code_lines.append('%s, %s = sch[%s].split(%s, factor=%d)' %
                          (outer_axis, c0_axis, stage_name, inner_axis, c0_value))
        stage_axis_info.append(
            AxisInfo(outer_axis, axis_len_merged // c0_value, axis_type,
                     axis_index, 'all'))
        stage_axis_info.append(
            AxisInfo(c0_axis, c0_value, axis_type, axis_index, 'c'))

        # split_factor操作对应的cheque
        get_split_cheque(t2c_params, stage_index, split_axis_index * 2 - 1, c0_value)
    else:
        axis_attr = "c" if is_c_axis("".join(axis_tag_merged)) else "all"
        # 不需要切原始轴的场景
        if not stage_axis_info:
            code_lines.append('%s = sch[%s].op.%s[%d]' %
                              (axis_name, stage_name, axis_type, axis_index))
            axis_obj = stage.op.axis[axis_index] if axis_type == "axis" else stage.op.reduce_axis[axis_index]
            stage_axis_info.append(
                AxisInfo(axis_name, axis_len_merged, axis_type, axis_index, axis_attr, axis_obj))
        else:
            stage_axis_info.append(
                AxisInfo(inner_axis, axis_len_merged, axis_type, axis_index, axis_attr))
    return code_lines, stage_axis_info, split_axis_index


@timer()
def split_fused_stage(t2c_params,  # pylint: disable=R0915,R0914,R0912
                      stage_index, mad_info):
    """ 先对融合轴进行拆分，再对各轴再进行split操作 """

    def _split_proc(axis_infos,  # pylint: disable=R0912
                    axis_type, factor1_split_info,
                    factor2_split_info, axis_index):
        # 对融合轴各子轴的切分
        log.dbg("factor1_split_info: %s, factor2_split_info: %s",
                factor1_split_info, factor2_split_info)
        for i, axis_info in enumerate(axis_infos):
            if axis_info.attr == "c":
                stage_axis_info.append(axis_info)
                continue
            axis_name = axis_info.name
            # 切第一刀
            if factor1_split_info and i == factor1_split_info.axis_index:
                final_code_lines.append(
                    '%s_o, %s_i = sch[%s].split(%s, factor=%d)' %
                    (axis_name, axis_name, stage_name, axis_name,
                     factor1_split_info.factor))
                axis_obj_o, axis_obj_i = None, None
                if mode == MODE_RUNTIME:
                    log.dbg('stage %s axis %s factor: %d', stage,
                            axis_info.body, factor1_split_info.factor)
                    axis_obj_o, axis_obj_i = stage.split(
                        axis_info.body, factor=factor1_split_info.factor)
                stage_axis_info.append(
                    AxisInfo(axis_name + '_o',
                             factor1_split_info.factor,
                             axis_type,
                             axis_index,
                             'o',
                             axis_body=axis_obj_o,
                             sub_axis_split=factor1_split_info.sub_axis_split,
                             sub_axis_factor=factor1_split_info.sub_factor))
                # split_factor操作对应的cheque
                get_split_cheque(t2c_params, stage_index,
                                 len(stage_axis_info) - 1,
                                 factor1_split_info.factor)

                if factor2_split_info and i == factor2_split_info.axis_index:
                    # 对i轴再切第二刀
                    final_code_lines.append(
                        '%s_io, %s_ii = sch[%s].split(%s_i, factor=%d)' %
                        (axis_name, axis_name, stage_name, axis_name,
                         factor2_split_info.factor))
                    axis_obj_io, axis_obj_ii = None, None
                    if mode == MODE_RUNTIME:
                        log.dbg('stage %s axis %s factor: %d', stage,
                                axis_obj_i, factor2_split_info.factor)
                        axis_obj_io, axis_obj_ii = stage.split(
                            axis_obj_i, factor=factor2_split_info.factor)
                    stage_axis_info.append(
                        AxisInfo(
                            axis_name + '_io',
                            factor2_split_info.factor,
                            axis_type,
                            axis_index,
                            'io',
                            axis_body=axis_obj_io,
                            sub_axis_split=factor2_split_info.sub_axis_split,
                            sub_axis_factor=factor2_split_info.sub_factor))
                    stage_axis_info.append(
                        AxisInfo(axis_name + '_ii', factor2_split_info.factor,
                                 axis_type, axis_index, 'ii', axis_obj_ii))
                    # split_factor操作对应的cheque
                    get_split_cheque(t2c_params, stage_index,
                                     len(stage_axis_info) - 2,
                                     factor2_split_info.factor)
                else:
                    stage_axis_info.append(
                        AxisInfo(axis_name + '_i', factor1_split_info.factor,
                                 axis_type, axis_index, 'i', axis_obj_i))
            else:
                stage_axis_info.append(axis_info)

    def _get_stage_axis_mapping(attr_dict, last_stage):
        # 查询当前stage与最后一个stage的轴对应关系
        last_stage_attr_dict = {}
        for attr_name, attr_value in last_stage.op.attrs.items():
            last_stage_attr_dict[attr_name] = attr_value
        axis_index_map = []
        for mad_axis_tag in attr_dict["axis"]:
            matched = False
            for i, last_axis_tag in enumerate(last_stage_attr_dict.get("axis")):
                if mad_axis_tag.value == last_axis_tag.value:
                    axis_index_map.append(i)
                    matched = True
                    break
            if not matched:
                axis_index_map.append(None)
        return axis_index_map

    def _split_axis_comm(  # pylint: disable=R0913
            axis_type,
            axis_index,
            split_infos,
            real_axis_index,
            factor_1,
            factor_2):
        code_lines, axis_infos, split_axis_index = split_fuse_axis(
            t2c_params, stage, axis_index, split_infos, axis_type, intrin,
            factor_2, stage_name, stage_index)
        final_code_lines.extend(code_lines)
        if real_axis_index is None:
            stage_axis_info.append(axis_infos[axis_index])
            return True
        factor1_split_info = get_split_axis_info(factor_1, axis_infos,
                                                 split_infos, split_axis_index)
        factor2_split_info = None
        if factor_2 > 0:
            factor2_split_info = get_split_axis_info(factor_2, axis_infos,
                                                     split_infos)
        _split_proc(axis_infos, axis_type, factor1_split_info,
                    factor2_split_info, axis_index)
        return True

    def _split_axis(axis_type,  # pylint: disable=R0912
                    mad_info, split_vector, axis_index_map=None):
        split_info_list = get_fused_axis_info(stage, axis_type, attr_dict,
                                              axis_info_dict, intrin,
                                              stage_name)
        for axis_index, split_infos in enumerate(split_info_list):
            real_axis_index = axis_index if axis_index_map is None else axis_index_map[axis_index]
            if real_axis_index is None:
                # 没有匹配关系的就不切分，将factor置为轴长
                factor_1 = factor_2 = stage.op.axis[
                    axis_index].dom.extent.value
            else:
                factor_1, factor_2 = split_vector[real_axis_index], \
                                     split_vector[real_axis_index
                                                  + t2c_util.max_axis()]

            if not mad_info:
                _split_axis_comm(axis_type, axis_index, split_infos,
                                 real_axis_index, factor_1, factor_2)
            elif mad_info["cut_K"]:
                # 如果切了大K，走MNKk模板，对mad stage切两刀，
                # 最后一个stage切一刀(L1 buffer)
                if intrin == "mad":
                    _split_axis_comm(axis_type, axis_index, split_infos,
                                     real_axis_index, factor_1, factor_2)
                else:
                    _split_axis_comm(axis_type, axis_index, split_infos,
                                     real_axis_index, factor_1, 0)
            else:
                # 如果没有切大K，走MNmnk模板，对最后一个stage切两刀，
                # mad stage切一刀(L0 buffer)
                if intrin == "mad":
                    _split_axis_comm(axis_type, axis_index, split_infos,
                                     real_axis_index, factor_2, 0)
                else:
                    _split_axis_comm(axis_type, axis_index, split_infos,
                                     real_axis_index, factor_1, factor_2)

    final_code_lines = []
    stage_axis_info = []

    stage = t2c_params.schedule.stages[stage_index]
    stage_info = t2c_params.op_schedule_info.stages_info[stage_index]
    stage_name = stage_info['name']
    mode = t2c_params.mode
    intrin = t2c_params.op_schedule_info.op_intrin_key_index[
        t2c_params.features[stage_index][FeatureTensorCfg.compute_s]].intrin
    split_vector = t2c_params.cleaned_actions[stage_index][
                   ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    attr_dict = {}
    for attr_name, attr_value in stage.op.attrs.items():
        attr_dict[attr_name] = attr_value
    axis_info_dict = t2c_params.op_schedule_info.op_attr_dict.get(
        'axis_info', {})

    # split的stage的所有普通轴和reduce轴生成对应的cheque
    log.dbg("stage: %s, stage.op.name: %s, stage_name: %s", stage,
            stage.op.name, stage_name)
    get_axis_cheque(t2c_params, stage_index)

    if stage.op.reduce_axis:
        if intrin == "mad":
            # mad stage对应的普通轴
            axis_index_map = _get_stage_axis_mapping(attr_dict,
                                                     mad_info["at_stage"])
            _split_axis("axis", mad_info, mad_info["split_vector"],
                        axis_index_map)
        else:
            for axis_index, axis_obj in enumerate(stage.op.axis):
                axis_name = '%s_axis_%d' % (stage_name, axis_index)
                final_code_lines.append('%s = sch[%s].op.axis[%d]' %
                                        (axis_name, stage_name, axis_index))
                stage_axis_info.append(
                    AxisInfo(axis_name, 0, 'axis', axis_index, 'all',
                             axis_obj))
        # reduce轴
        _split_axis("reduce_axis", mad_info, split_vector)
    else:
        # 普通轴
        _split_axis("axis", mad_info, split_vector)

    return final_code_lines, stage_axis_info
