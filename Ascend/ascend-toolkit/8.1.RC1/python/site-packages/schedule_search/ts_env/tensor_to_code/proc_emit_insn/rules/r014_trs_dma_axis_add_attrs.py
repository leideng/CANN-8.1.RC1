#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from typing import NoReturn

from tbe import tvm
from tbe.tvm import Stage

from schedule_search import log
from schedule_search.op_cfg import TIK_TO_DSL_OP_LIST
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.cheque_generator import get_emit_insn_cheque
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_to_code.t2c_util import T2cParams
from schedule_search.ts_env.tensor_to_code.trs_comm import calc_trs_reorder_action
from schedule_search.ts_env.tensor_to_code.trs_comm import calc_trs_split_axis


def get_dma_axis(stage: Stage, curr_axis_info_list: list,
                 stage_name: str, proc_sch: bool = True) -> (int, str, object):
    """
    pre build时获取pragma轴编号
    :param stage:
    :param curr_axis_info_list:
    :param proc_sch:
    :param stage_name:
    :return:
    """
    emit_insn_axis_obj = None
    axis_name = ""

    # 非叶子stage、叶子分叉stage、中间输出stage
    if curr_axis_info_list is None:
        axis_num = 0
        if proc_sch:
            emit_insn_axis_obj = stage.op.axis[axis_num]
        return \
            axis_num, "sch[%s].op.axis[%s]" % (stage_name, axis_num), \
            emit_insn_axis_obj

    # 叶子stage、叶子分叉stage、中间输出stage
    for i, axis_info in enumerate(curr_axis_info_list):
        axis_name = axis_info.name
        for axis_ends in ["_ii", "_i"]:
            proc_sch_flag = axis_name.endswith(axis_ends) and proc_sch
            if proc_sch_flag:
                emit_insn_axis_obj = curr_axis_info_list[i].body
                return i, axis_name, emit_insn_axis_obj

    log.warn(
        "Pragma axis not found for stage_name:%s,  "
        "curr_axis_info_list:%s !", stage_name, curr_axis_info_list)

    return 0, axis_name, emit_insn_axis_obj


def get_src_and_dst_order(permute: list, ori_permute: list,
                          reorder_in_index: list, reorder_out_index: list) -> (list, list):
    """
    get src_order and dst_order
    :param permute:
    :param ori_permute:
    :param reorder_in_index:
    :param reorder_out_index:
    :return:
    """
    base_order = list(range(len(permute)))
    src_order = [base_order[i] for i in reorder_in_index]
    dst_order = [ori_permute[i] for i in reorder_out_index]

    return src_order, dst_order


def get_ub_src_and_dst_order(t2c_params: T2cParams, permute: list, ori_permute: list,
                             low_ub_split_axis: int, high_ub_split_axis: int) -> (list, list):
    """
    get ub_src_order and ub_dst_order
    :param t2c_params:
    :param permute:
    :param ori_permute:
    :param chosen_axes:
    :return:
    """
    # calc reorder_index
    reorder_in_index, reorder_out_index = calc_trs_reorder_action(t2c_params)

    src_order, dst_order = get_src_and_dst_order(
        permute, ori_permute, reorder_in_index, reorder_out_index)

    continus_src = src_order[ori_permute[low_ub_split_axis]:]
    continus_dst = dst_order[high_ub_split_axis:]
    ub_src_order = [o for o in src_order if o in continus_dst and o not in continus_src]
    ub_src_order.extend(continus_src)
    ub_dst_order = [o for o in dst_order if o in continus_src and o not in continus_dst]
    ub_dst_order.extend(continus_dst)

    return ub_src_order, ub_dst_order


def calc_src_in_dst_order_attr(t2c_params: T2cParams, stages_info: list, chosen_axes: list) -> (dict, list):
    """
    calculate src_in_dst_order_attr
    :param t2c_params:
    :param stages_info:
    :param chosen_axes:
    :return:
    """
    # calc split axis
    low_ub_split_axis, high_ub_split_axis = calc_trs_split_axis(t2c_params, chosen_axes)

    # calc ori_permute and permute
    ori_permute = stages_info[-1]["trs_params"]["ori_permute"]
    ori_perm = []
    for ind in ori_permute:
        ori_perm.append(int(ind))
    permute = sorted(range(len(ori_perm)), key=ori_perm.__getitem__)

    # get ub_src_order and ub_dst_order
    ub_src_order, ub_dst_order = get_ub_src_and_dst_order(
        t2c_params, permute, ori_permute, low_ub_split_axis, high_ub_split_axis)

    src_in_dst_order_list = [ub_src_order.index(o) for o in ub_dst_order]
    src_in_dst_order = tvm.call_cce_pure_intrin('handle', 'tir.tvm_tuple', *src_in_dst_order_list)
    attrs = {"src_in_dst_order": src_in_dst_order}

    t2c_params.code_lines.append(
        "src_in_dst_order = tvm.call_cce_pure_intrin('handle', 'tir.tvm_tuple', {})".format(*src_in_dst_order_list))

    return attrs, src_in_dst_order_list


def do_trs_emit_insn(t2c_params: T2cParams, stages_info: list, stage_index: int,
                     intrin: str, chosen_axes: list) -> NoReturn:
    """
    do transpose emit insn
    :param t2c_params:
    :param stages_info:
    :param stage_index:
    :param intrin:
    :param chosen_axes:
    :return:
    """
    stage = t2c_params.stage
    stage_name = t2c_params.stage_name
    proc_sch = bool(t2c_params.mode == MODE_RUNTIME)

    axis_num, dma_axis, dma_axis_obj = \
        get_dma_axis(stage, t2c_params.axis_info_list[stage_index],
                     stage_name, proc_sch=proc_sch)

    attrs = None
    attrs_str = None
    extra_info = None
    # 输出的dma-tensor需要设置no_overlap为2的attrs
    if intrin == 'dma_copy' and 'leaf' in stages_info[stage_index].get("type", []):
        attrs = {"no_overlap": 2}
        attrs_str = str(attrs)
        extra_info = attrs
    # vector_transpose的tensor需要设置attrs
    elif intrin == 'vector_transpose' and stages_info[stage_index].get("tag") == "transpose":
        attrs, src_in_dst_order_list = calc_src_in_dst_order_attr(t2c_params, stages_info, chosen_axes)
        attrs_str = "{\'src_in_dst_order\': src_in_dst_order}"
        extra_info = {"src_in_dst_order": src_in_dst_order_list}

    if proc_sch:
        stage.emit_insn(dma_axis_obj, intrin, attrs=attrs)
    t2c_params.code_lines.append("sch[%s].emit_insn(%s, '%s', attrs=%s)" %
                                 (stage_name, dma_axis, intrin, attrs_str))
    # 生成emit_insn的cheque
    if attrs is not None:
        get_emit_insn_cheque(t2c_params, stage_index, intrin,
                             (dma_axis, axis_num), extra_info=extra_info)
    else:
        get_emit_insn_cheque(t2c_params, stage_index, intrin,
                             (dma_axis, axis_num))


def proc(t2c_params: T2cParams) -> bool:
    """

    :param t2c_params:
    :return:
    """
    stages_info = t2c_params.stages_info

    # calc chosen_axes
    chosen_axes = []
    all_stages = t2c_params.schedule.stages
    for index, _ in enumerate(all_stages):
        if "chosen_axes" in stages_info[index].keys():
            chosen_axes = stages_info[index]['chosen_axes']
            break

    # manual_debug choose_axes
    debug_params = t2c_params.op_schedule_info.option.get("trs_debug", [False, {}])
    if debug_params[0]:
        chosen_axes = debug_params[1]["chosen_axes"]

    # recorde chosen axes info
    if "trs_params" not in stages_info[-1].keys():
        stages_info[-1].setdefault('trs_params', {})
    chosen_axes_info = {"chosen_axes": chosen_axes}
    stages_info[-1]["trs_params"].update(chosen_axes_info)

    features = t2c_params.features
    stage_index = t2c_params.stage_index

    intrin = t2c_params.op_schedule_info.op_intrin_key_index[
        features[stage_index][FeatureTensorCfg.compute_s]].intrin

    if t2c_params.op_schedule_info.option.get('op_type') in TIK_TO_DSL_OP_LIST.keys():
        if intrin.find("##") != -1:
            intrins = intrin.split('##')
            emit_insn_action_index = t2c_params.cleaned_actions[stage_index][
                ActionTensorCfg.emit_insn_s]
            intrin = str(intrins[emit_insn_action_index])

        do_trs_emit_insn(t2c_params, stages_info, stage_index, intrin, chosen_axes)

        t2c_params.proc_flag_dict[stage_index] = True
        return True

    return True
