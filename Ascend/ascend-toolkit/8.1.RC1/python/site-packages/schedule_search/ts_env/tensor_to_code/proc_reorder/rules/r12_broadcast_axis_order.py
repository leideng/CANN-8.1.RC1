#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_to_code import t2c_util


def update_leveled_axis(stage_index, axis_index_list, t2c_params):
    '''
    按index的顺序重排leveled_axis
    :param axis_index_list:
    :return:
    '''
    axis_num = t2c_util.max_axis()
    layer_num = (ActionTensorCfg.reorder_e + 1 -
                 ActionTensorCfg.reorder_s) // axis_num
    leveled_axis = t2c_params.leveled_axis_for_reorder[stage_index]

    # 逐层重排
    for layer_index in range(layer_num):
        new_layer_leveled_axis = []
        for axis_index in axis_index_list:
            for axis_info in leveled_axis[layer_index]:
                if axis_info.index == axis_index:
                    new_layer_leveled_axis.append(axis_info)
        t2c_params.leveled_axis_for_reorder[stage_index][layer_index] = \
            new_layer_leveled_axis

        # leveled_axis已经按顺序排好了，不需要cleaned_actionsre记录order顺序
        reorder_s = ActionTensorCfg.reorder_s + layer_index * axis_num
        reorder_e = reorder_s + axis_num
        t2c_params.cleaned_actions[stage_index][reorder_s: reorder_e] = \
            list(range(axis_num))


def _no_need_reorder(t2c_params, stage_index):
    """

    :param t2c_params:
    :param stage_index:
    :return:
    """
    stage_info = t2c_params.op_schedule_info.stages_info[stage_index]
    # 没有切不处理
    index = t2c_util.AXIS_LEVEL_O_INDEX
    if not t2c_params.leveled_axis_for_reorder[stage_index][index]:
        return True

    # 如果是reduce stage, 暂时不处理，continue
    if 'reduce' in stage_info.get('type', []):
        return True

    if t2c_util.gn_training_update_nchw(t2c_params.op_schedule_info):
        return True

    return False


def _default_order(broadcast_groups, broadcast_axis_list):
    """

    :param broadcast_groups:
    :param broadcast_axis_list:
    :return:
    """
    for bc_group in broadcast_groups:
        for bc_axis in bc_group:
            if bc_axis not in broadcast_axis_list:
                broadcast_axis_list.append(bc_axis)


def proc(t2c_params):  # pylint: disable=R0914, R0915, R0912
    """
    规则内容：
    1、非broadcast轴放在broadcast轴前面
    2、如果有broadcast groups，需要按采样的结果排序broadcast axis
    """
    schedule = t2c_params.schedule
    stages_info = t2c_params.op_schedule_info.stages_info
    broadcast_info_dict \
        = t2c_params.op_schedule_info.broadcast_dict.get('info')
    max_axis_num = t2c_util.max_axis()
    actions = t2c_params.actions

    # 没有broadcast的算子，不处理
    if not broadcast_info_dict:
        return

    broadcast_groups_dict = {}
    for stage_index, stages_info in enumerate(stages_info):
        if _no_need_reorder(t2c_params, stage_index):
            continue

        # 获取stage的fanin中所有broadcast stage的broadcast axis
        broadcast_groups = stages_info.get('broadcast_groups', [])
        # 如果有broadcast groups，需要按采样的结果排序broadcast axis
        broadcast_axis_reorder = stages_info.get(
            'broadcast_axis_reorder')
        broadcast_axis_list = []
        # 如果有采样，根据采样reorder broadcast axis
        if broadcast_axis_reorder:
            broadcast_axis_list = broadcast_axis_reorder
            # 记录一下相关信息，好写到py中，有一些信息用于分析定位
            broadcast_groups_reorder = stages_info.get(
                'broadcast_groups_reorder')
            choose_axis = stages_info.get('choose_axis')
            action = actions[stage_index][:max_axis_num]
            sample_action = stages_info.get('sample_action')
            broadcast_groups_dict[stage_index] = {
                'broadcast_groups': broadcast_groups,
                'broadcast_groups_reorder': broadcast_groups_reorder,
                'broadcast_axis_reorder': broadcast_axis_list,
                'choose_axis': choose_axis,
                'action': list(action),
                'sample_action': sample_action,
                'name': stages_info.get('name')
            }
        # 没有采样，按照默认顺序排列
        else:
            _default_order(broadcast_groups, broadcast_axis_list)

        new_reorder_list = []

        axis_num = len(schedule.stages[stage_index].op.axis)

        # 非broadcast轴reorder在前
        for axis in range(axis_num):
            if axis not in broadcast_axis_list:
                new_reorder_list.append(axis)

        # broadcast轴reorder在后
        for axis in broadcast_axis_list:
            new_reorder_list.append(axis)

        # 大于axis num 补齐
        for axis in range(axis_num, max_axis_num):
            new_reorder_list.append(axis)

        if len(new_reorder_list) != max_axis_num:
            log.info("reorder list len invalid:%s", len(new_reorder_list))
            continue

        # 按指定的顺序重排leveled_axis
        update_leveled_axis(stage_index, new_reorder_list, t2c_params)

        t2c_params.reorder_axis_map.setdefault(stage_index, {})
        for index, axis in enumerate(new_reorder_list):
            t2c_params.reorder_axis_map[stage_index][index] = axis

        last_cut_index = -1
        for each_cut_index in range(t2c_params.cut_axis_index[stage_index] +
                                    1):
            new_index = new_reorder_list.index(each_cut_index)
            if new_index > last_cut_index:
                last_cut_index = new_index
        t2c_params.last_cut_axis_index[stage_index] = last_cut_index

    # 记录到py中，debug_manual可以获取
    if broadcast_groups_dict:
        t2c_params.op_schedule_info.broadcast_groups_dict = \
            broadcast_groups_dict
        t2c_params.code_lines.append('# broadcast_groups: %s' %
                                     broadcast_groups_dict)
