#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import copy
from io import StringIO
from contextlib import redirect_stdout
from contextlib import redirect_stderr
import numpy as np

from schedule_search import log
from schedule_search.ts_env import env_util
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.estimator.estimate import get_all_tensors
from schedule_search.ts_env.estimator.estimate import \
    get_tensors_by_tensors_str
from schedule_search.ts_env.estimator.kernel_runner import store_tmp_proc
from schedule_search.ts_env.cheque_generator import get_storage_align_cheque
from tbe import tvm
from tbe.tvm import tir as ir_pass
from tbe.common.buildcfg import build_config


def get_stage_expr_type(expr_info):  # pylint: disable=R0911,R0912
    """
    不管stage本身是什么类型的计算，只看表达式等号左右两边tensor包含的pragma下轴的信息：
    所有tensor都包含所有轴是elewise；
    等号左边缺少轴是reduce；等号右边缺少轴是broadcast。
    缺少的轴里包含最后一根轴就是last，否则是nist
    """
    # 拿到pragma下的所有轴的名字
    emit_insn_axis_list = expr_info["emit_insn_axis_list"]
    intrin = expr_info["intrin"]
    if intrin == "dma_copy":
        return "dma_copy"
    if intrin == "phony_insn":
        return "phony_insn"
    # 表达式两边都没有的轴，过滤掉
    all_expr_axis = []
    for tensor in expr_info["dst"] + expr_info["src"]:
        all_expr_axis.extend(tensor["axis_var_list"])
    emit_insn_axis_list = [
        axis
        for axis in emit_insn_axis_list
        if axis in all_expr_axis
    ]

    # 先检查dst tensor 即表达式等号左边
    for dst_tensor in expr_info["dst"]:
        # 出现在右边而不在左边的消失轴
        axis_miss_in_dst = [
            axis_var
            for axis_var in emit_insn_axis_list
            if axis_var not in dst_tensor["axis_var_list"]
        ]
        if axis_miss_in_dst:
            for axis_var in axis_miss_in_dst:
                for src_tensor in expr_info["src"]:
                    # 如果某个消失轴是某个src的最后一根轴，则是reduce_last
                    if src_tensor["axis_var_list"] \
                            and axis_var == src_tensor["axis_var_list"][-1]:
                        return "reduce_last"
            # 判断完所有消失轴都不是src的最后一根，那就是reduce_nist
            return "reduce_nist"

    # 再检查src tensor 即表达式等号右边
    for src_tensor in expr_info["src"]:
        # 出现在左边而不在右边的消失轴
        axis_miss_in_src = [
            axis_var
            for axis_var in emit_insn_axis_list
            if axis_var not in src_tensor["axis_var_list"]
        ]
        if axis_miss_in_src:
            for axis_var in axis_miss_in_src:
                for dst_tensor in expr_info["dst"]:
                    # 如果某个消失轴是某个dst的最后一根轴，则是broadcast_last
                    if dst_tensor["axis_var_list"] \
                            and axis_var == dst_tensor["axis_var_list"][-1]:
                        return "broadcast_last"
            # 判断完所有消失轴都不是dst的最后一根，那就是broadcast_nist
            return "broadcast_nist"

    return "elementwise"


def get_common_axis_list(expr_info, axis_var_list):  # pylint: disable=R0912
    """

    :param expr_info:
    :param axis_var_list:
    :return:
    """
    common_axis_list = []
    total_axis_list = []
    # 以包含轴最多的axis_var_list为基准
    for expr_buffer_dict in expr_info["dst"] + expr_info["src"]:
        if len(total_axis_list) < len(expr_buffer_dict["axis_var_list"]):
            total_axis_list = expr_buffer_dict["axis_var_list"]
    # 从后往前找到第一个非公有轴就退出
    for i in range(len(total_axis_list) - 1, -1, -1):
        if total_axis_list[i] in axis_var_list:
            common_axis_list.insert(0, total_axis_list[i])
        else:
            break

    return common_axis_list


def get_upper_align_axis(  # pylint: disable=R0912,R0914,R0915
        expr_info,
        expr_buffer_dict,
        expr_type,
        reduce_flag=True):
    """

    :param expr_info:
    :param expr_buffer_dict:
    :param expr_type:
    :param reduce_flag:
    :return:
    """
    stride_dict = expr_buffer_dict["stride_dict"]
    shape = expr_info["shape"]
    emit_insn_axis_list = expr_info["emit_insn_axis_list"]
    # 没有抓取到shape的即那种一次只处理一个数据的emit insn
    if not shape:
        return emit_insn_axis_list[-1]
    prev_info = []
    axis_var_list = expr_buffer_dict["axis_var_list"]
    comm_axis_var_list = get_common_axis_list(expr_info, axis_var_list)
    log.dbg("comm_axis_var_list:%s", comm_axis_var_list)
    if comm_axis_var_list:
        upper_axis = comm_axis_var_list[-1]
    else:
        upper_axis = emit_insn_axis_list[-1]
    for i in range(len(comm_axis_var_list) - 1, -1, -1):
        emit_insn_axis = comm_axis_var_list[i]
        if emit_insn_axis not in emit_insn_axis_list:
            if prev_info and expr_type == "elementwise" \
                    and emit_insn_axis.split(".")[0] \
                    == prev_info[2].split(".")[0]:
                log.dbg("expr: %s, upper_axis: %s", expr_info, prev_info[2])
                return prev_info[2]
            continue
        shape_value = shape[emit_insn_axis_list.index(emit_insn_axis)]
        # 第一次，即最低维度
        if not prev_info:
            prev_info = [shape_value, 1, emit_insn_axis]
            continue
        stride_value = stride_dict.get(emit_insn_axis, None)
        # 出现stride不符合预期，那么就是不连续，此处直接取上一个轴
        if stride_value is None or stride_value != prev_info[0] * prev_info[1]:
            upper_axis = prev_info[2]
            break

        # reduce为True只关注与最后一根reduce轴连续的reduce轴，否则只关注非reduce轴
        if reduce_flag:
            if not emit_insn_axis.startswith("k"):
                upper_axis = prev_info[2]
                break
        else:
            if emit_insn_axis.startswith("k"):
                upper_axis = prev_info[2]
                break

        prev_info = [shape_value, stride_value, emit_insn_axis]
        upper_axis = prev_info[2]

    # 如果连续轴的前一根轴长是1则仍是连续的，可以继续往前挪
    if upper_axis in emit_insn_axis_list:
        upper_axis_index = emit_insn_axis_list.index(upper_axis)
        for i in range(upper_axis_index, -1, -1):
            if shape[i - 1] != 1:
                break
            upper_axis = emit_insn_axis_list[i - 1]
            log.dbg("update upper_axis to %s", upper_axis)

    # 可能存在一些被化简掉的轴，轴长为1
    ori_emit_insn_axis = expr_info["ori_emit_insn_axis"]
    if comm_axis_var_list \
            and upper_axis == comm_axis_var_list[0] \
            and not (upper_axis.startswith("k")
                     or ori_emit_insn_axis.startswith("k")):
        if upper_axis != ori_emit_insn_axis and expr_info["buffer"]:
            ori_index = int(ori_emit_insn_axis.split(".")[0][-1])
            upper_index = int(upper_axis.split(".")[0][-1])
            need_move = True
            align_block = env_util.get_block_num(expr_info["buffer"][1])
            buffer_extent = expr_info["buffer"][0]
            for i in range(ori_index, upper_index, 1):
                # 预期应该是tvm.expr.IntImm类的常数，但有时是个tvm.expr.Sub等
                if not getattr(buffer_extent[i], "value", None):
                    continue
                if buffer_extent[i].value != 1 \
                        and buffer_extent[i].value % align_block != 0:
                    need_move = False
                    break
            if need_move:
                upper_axis = ori_emit_insn_axis

    log.dbg("tensor_name: %s, upper_axis: %s, comm axis: %s",
            expr_buffer_dict["stage_name"], upper_axis, comm_axis_var_list)
    return upper_axis


def gen_global_axis_name(axis, stage_name, stage_index):
    """

    :param axis:
    :param stage_name:
    :param stage_index:
    :return:
    """
    return "{}@{}@{}".format(axis, stage_name, stage_index)


def parse_global_axis_name(global_axis):
    """

    :param global_axis:
    :return: axis, stage_name, stage_index
    """
    if global_axis is None:
        return None, None, None
    return global_axis.split("@")


def get_local_axis(axis_info, axis):
    """

    :param axis_info:
    :param axis:
    :return:
    """
    if axis not in axis_info["global"]:
        return None

    axis_index = axis_info["global"].index(axis)
    local_axis_name = axis_info["local"][axis_index]
    return local_axis_name


def get_global_axis(axis, src_stage_index, axis_life_dict):
    """

    :param axis:
    :param src_stage_index:
    :param axis_life_dict:
    :return:
    """
    # 该函数返回global的axis名字
    axis = axis.replace(".inner", "").replace(".outer",
                                              "").replace(".init", "")

    # local --> global
    src_axis_info = axis_life_dict[src_stage_index]
    if axis not in src_axis_info["local"]:
        log.warn("local axis %s not in tensor %s, src axis_info: %s!", axis,
                 src_stage_index, src_axis_info)
        return None
    axis_index = src_axis_info["local"].index(axis)
    global_axis_name = src_axis_info["global"][axis_index]
    return global_axis_name


def get_dst_axis_name(  # pylint: disable=R0913,R0912
        src_stage_index,
        src_tensor_name,
        axis,
        dst_stage_index,
        axis_map_by_stage_index,
        alias_dict,
        stage_obj):
    """

    :param src_stage_index:
    :param src_tensor_name:
    :param axis:
    :param dst_stage_index:
    :param axis_map_by_stage_index:
    :param alias_dict:
    :param stage_obj:
    :return:
    """
    # 该函数返回global的axis名字
    axis = axis.replace(".inner", "").replace(".outer",
                                              "").replace(".init", "")
    # 如果dst是src，则直接返回自己
    if src_stage_index == dst_stage_index:
        return axis

    # local --> global
    # 以k开头的reduce轴没有记录在local中，则直接拼接处global轴名
    if is_reduce_axis(stage_obj, axis):
        global_axis_name = gen_global_axis_name(axis, src_tensor_name,
                                                src_stage_index)
    # src是broadcast stage的broadcast轴就是别人的global
    elif is_broadcast_axis(stage_obj, axis):
        global_axis_name = gen_global_axis_name(axis, src_tensor_name,
                                                src_stage_index)
    else:
        global_axis_name = get_global_axis(axis, src_stage_index,
                                           axis_map_by_stage_index)
        if not global_axis_name:
            return None

    # global --> local
    dst_axis_info_list = axis_map_by_stage_index[dst_stage_index]
    dst_axis_name = get_local_axis(dst_axis_info_list, global_axis_name)
    if not dst_axis_name:
        # 再尝试从alias_dict拿一下
        if global_axis_name in alias_dict:
            log.dbg("global_axis_name modify from %s to %s", global_axis_name,
                    alias_dict[global_axis_name])
            for tmp_global_axis in alias_dict[global_axis_name]:
                dst_axis_name = get_local_axis(dst_axis_info_list,
                                               tmp_global_axis)
                if dst_axis_name:
                    break
        if not dst_axis_name:
            log.dbg(
                "src:%s axis:%s, global axis %s not in stage_idx %s "
                "tensor %s, dst axis_info: %s,src tensor: %s, axis: "
                "%s!\nalias_dict:%s", src_tensor_name, axis, global_axis_name,
                dst_stage_index,
                axis_map_by_stage_index[dst_stage_index]["stage_name"],
                dst_axis_info_list, src_stage_index, axis, alias_dict)
            return None

    return dst_axis_name


def axis_index_in_stage(stage, axis_name):  # pylint: disable=R0912
    """

    :param stage:
    :param axis_name:
    :return:
    """
    axis_var_list = []
    if axis_name.startswith("k"):
        for axis_obj in stage.op.reduce_axis:
            axis_var_list.append(str(axis_obj.var.name))
    else:
        for axis_obj in stage.op.axis:
            axis_var_list.append(str(axis_obj.var.name))

    axis_index = 0
    for i, axis_var in enumerate(axis_var_list):
        if axis_name.split(".")[0] == axis_var.split(".")[0]:
            log.dbg("index of %s in %s is: %s!", axis_name, stage.op.name, i)
            axis_index = i
            break
    return axis_index


def align_a_stage(stage, stage_name, align_axis_index, t2c_params,
                  stage_index):
    """

    :param stage:
    :param stage_name:
    :param align_axis_index:
    :param t2c_params:
    :param stage_index:
    :return:
    """
    # 不需要考虑dtype变化，每个tensor只看自己的输出dtype来计算block_num
    vector_block_num = env_util.get_block_num(stage.op.output(0).dtype)
    if align_axis_index < 0:
        return []

    code_line = 'sch[%s].storage_align(sch[%s].op.axis[%s], %s, 0)' % \
                (stage_name, stage_name, align_axis_index, vector_block_num)
    if t2c_params.mode == MODE_RUNTIME:
        stage.storage_align(stage.op.axis[align_axis_index], vector_block_num,
                            0)

    # 生成storage_align操作对应的cheque
    get_storage_align_cheque(t2c_params, stage_index, align_axis_index,
                             vector_block_num)
    return [code_line]


def is_reduce_axis(stage, axis_name):  # pylint: disable=R0912
    """

    :param stage:
    :param axis_name:
    :return:
    """
    if axis_name.startswith("k"):
        return True

    # 有reduce axis说明是reduce stage keepdims时 reduce轴的名字也是i开头
    if not stage.op.reduce_axis:
        return False

    if not hasattr(stage.op.body[0].source[0], "indices"):
        return False

    input_dims = len(stage.op.input_tensors[0].shape)
    output_dims = len(stage.op.output(0).shape)
    keepdims = (input_dims == output_dims)
    if keepdims:
        axis_idx = axis_index_in_stage(stage, axis_name)
        reduce_axis = stage.op.body[0].source[0].indices[axis_idx]
        if isinstance(reduce_axis, tvm.expr.BinaryOpExpr):
            reduce_axis = reduce_axis.a
        if reduce_axis.name.startswith("k"):
            log.dbg("stage:%s axis %s is reduce axis", stage.op.name,
                    axis_name)
            return True

    return False


def is_broadcast_axis(stage, axis_name):
    """

    :param stage:
    :param axis_name:
    :return:
    """
    broadcast_axis_list = env_util.get_stage_broadcast_axis(stage)

    log.dbg("stage:%s axis_name:%s broadcast_axis_list:%s", stage.op.name,
            axis_name, broadcast_axis_list)
    if not broadcast_axis_list:
        return False

    if axis_index_in_stage(stage, axis_name) in broadcast_axis_list:
        return True
    return False


def get_storage_align_info(sch, binds): # pylint: disable=R0915,no-member,R0912
    """
    get_storage_align_info
    :param sch:
    :param binds:
    :return:
    """

    def storage_align_preorder_func(stmt):  # pylint: disable=R0915,R0912
        """
        storage_align_preorder_func
        :param stmt:
        :return:
        """

        def get_expr_info(stmt,  # pylint: disable=R0912
                          axis_var_list, stride_dict, axis_list):
            """
            get_expr_info
            :param stmt:
            :param axis_var_list:
            :param stride_dict:
            :param axis_list:
            """
            if isinstance(stmt, tvm.tir.Add):
                get_expr_info(stmt.a, axis_var_list, stride_dict, axis_list)
                get_expr_info(stmt.b, axis_var_list, stride_dict, axis_list)
            elif isinstance(stmt, tvm.tir.Mul):
                get_expr_info(stmt.a, axis_var_list, stride_dict, axis_list)
                if isinstance(stmt.b, tvm.tir.IntImm):
                    if isinstance(stmt.a, tvm.Var):
                        stride_dict[stmt.a.name] = stmt.b.value
                else:
                    get_expr_info(stmt.b, axis_var_list, stride_dict,
                                  axis_list)
            elif isinstance(stmt, tvm.Var):
                axis_var_list.append(stmt.name)

        def update_expr_info_dict(expr_index, stage_name, expr_buffer_list,
                                  axis_list):
            """

            :param expr_index:
            :param stage_name:
            :param expr_buffer_list:
            :param axis_list:
            """
            axis_var_list = []
            stride_dict = {}
            get_expr_info(expr_index, axis_var_list, stride_dict, axis_list)
            if axis_var_list:
                if axis_var_list[-1] not in stride_dict:
                    stride_dict[axis_var_list[-1]] = 1
            else:
                # emit insn只处理单个元素的场景
                axis_var_list = [axis_list[0]]
                stride_dict[axis_list[0]] = 1
            axis_var_dict = {
                "stage_name": str(stage_name),
                "axis_var_list": axis_var_list,
                "stride_dict": stride_dict
            }
            expr_buffer_list.append(axis_var_dict)

        def stmt_for_proc(curr_stmt):
            """

            :param curr_stmt:
            """
            shape_list = []
            axis_list = []
            while isinstance(curr_stmt, tvm.tir.stmt.For):
                shape_list.append(curr_stmt.extent.value)
                axis_list.append(curr_stmt.loop_var.name)
                curr_stmt = curr_stmt.body
                # for循环中间可能穿插reduce_init，需要跳过
                if isinstance(curr_stmt, tvm.stmt.Block):
                    curr_stmt = curr_stmt.rest

            if isinstance(curr_stmt, tvm.tir.stmt.Store):
                stmt_store_proc(curr_stmt, shape_list, axis_list)

        def stmt_store_proc(curr_stmt,  # pylint: disable=R0912
                            shape_list, axis_list):
            """

            :param curr_stmt:
            :param shape_list:
            :param axis_list:
            """
            stage_name = curr_stmt.buffer_var.name

            expr_info = {
                "dst": [],
                "src": [],
                "shape": shape_list,
                "emit_insn_axis_list": axis_list,
                "intrin": stmt_intrin.value,
                "expr": str(curr_stmt),
                "ori_emit_insn_axis": str(ori_emit_insn_axis),
                "buffer": buffer_dict.get(stage_name, [[]])[-1]
            }
            expr_info_dict.setdefault(str(stage_name), []).append(expr_info)
            # 表达式左边dst的解析
            update_expr_info_dict(curr_stmt.index, stage_name,
                                  expr_info["dst"], axis_list)
            # 表达式右边src的解析
            src_expr = curr_stmt.value
            if isinstance(src_expr, tvm.tir.Load):
                update_expr_info_dict(src_expr.index, src_expr.buffer_var.name,
                                      expr_info["src"], axis_list)
            elif isinstance(src_expr, tvm.tir.IntImm):
                pass
            elif isinstance(src_expr, tvm.tir.Select):
                # 简化处理，默认和dst保持一致
                update_expr_info_dict(curr_stmt.index, stage_name,
                                      expr_info["src"], axis_list)
            elif isinstance(src_expr, tvm.expr.Call):
                for call_arg in src_expr.args:
                    if isinstance(call_arg, tvm.tir.Load):
                        update_expr_info_dict(call_arg.index,
                                              call_arg.buffer_var.name,
                                              expr_info["src"], axis_list)
                    else:
                        log.dbg("====[storage_align_info]====unsupport "
                                "call_arg type: %s, call_arg: %s, dir: %s" %
                                (type(call_arg), call_arg, dir(call_arg)))
            elif hasattr(src_expr, 'a') and hasattr(src_expr, 'b'):
                for sub_src_expr in [src_expr.a, src_expr.b]:
                    if isinstance(sub_src_expr, tvm.tir.Load):
                        update_expr_info_dict(sub_src_expr.index,
                                              sub_src_expr.buffer_var.name,
                                              expr_info["src"], axis_list)
                    else:
                        log.dbg("====[storage_align_info]====unsupport "
                                "a/b type: %s, a/b: %s, src_expr: %s" %
                                (type(sub_src_expr), sub_src_expr, src_expr))
            elif hasattr(src_expr, 'value'):
                if isinstance(src_expr.value, tvm.tir.Load):
                    update_expr_info_dict(src_expr.value.index,
                                          src_expr.value.buffer_var.name,
                                          expr_info["src"], axis_list)
                else:
                    log.dbg("====[storage_align_info]====unsupport "
                            "value type: %s, stmt: %s" %
                            (type(src_expr.value), curr_stmt))
            else:
                log.dbg("====[storage_align_info]====unsupport "
                        "expr type: %s, src_expr: %s, dir: %s" %
                        (type(src_expr), curr_stmt, dir(src_expr)))

        if isinstance(stmt, tvm.tir.stmt.Allocate):
            buffer_dict.setdefault(stmt.buffer_var.name, []).append(
                (stmt.extents, stmt.dtype))
        elif stmt.attr_key == 'pragma_emit_insn':
            if stmt.value in ["vector_reduce_init", "reg_mov"]:
                return
            stmt_intrin = stmt.value
            ori_emit_insn_axis = stmt.node.var.name
            curr_stmt = stmt.body
            if isinstance(curr_stmt, tvm.tir.stmt.For):
                stmt_for_proc(curr_stmt)
            elif isinstance(curr_stmt, tvm.tir.stmt.Store):
                shape_list = [1]
                axis_list = []
                # 不紧贴for循环的emit insn只处理单个元素
                if isinstance(stmt.node, tvm.tir.IterVar):
                    axis_list = [stmt.node.var.name]
                stmt_store_proc(curr_stmt, shape_list, axis_list)
            else:
                return

    # tvm底层可能会有一些奇怪的打印，我们在此统一封装下，让它不要吱声
    f_out = StringIO()
    f_err = StringIO()
    with redirect_stderr(f_err), redirect_stdout(f_out):
        mod = tvm.driver.build_module.schedule_to_module(sch, binds)
        mod = tvm.tir.transform.InjectPrefetch()(mod)
        # Phase 1
        mod = ir_pass.transform.StorageFlatten(64)(mod)

        mod = ir_pass.transform.CanonicalSimplify()(mod)
        mod = ir_pass.transform.ReuseBuf()(mod)
        mod = ir_pass.transform.ReuseCoAxisBuffer()(mod)
        mod = ir_pass.transform.FullySplitLoopPartition()(mod)
        mod = ir_pass.transform.SinglePointManager()(mod)
        mod = ir_pass.transform.UnrollLoop()(mod)
        mod = ir_pass.transform.RemoveNoOp()(mod)
        mod = ir_pass.transform.CanonicalSimplify()(mod)
        mod = ir_pass.transform.FissionLoop()(mod)
        mod = ir_pass.transform.SparseAccessTransform()(mod)
        # Pass: Pragma Propagation. Propagate pragma to the top of block below.
        mod = ir_pass.transform.PragmaPropagation()(mod)
        # Pass: Branch Motion. Raise `IfThenElse` to the top of `Pragma`.
        mod = ir_pass.transform.BranchMotion()(mod)
        stmt = mod["main"].body

        expr_info_dict = {}
        buffer_dict = {}
        ir_pass.stmt_functor.ir_transform(stmt, storage_align_preorder_func, None, ['tir.AttrStmt', 'tir.Allocate'])
    log.dbg("expr_info_dict: %s" % expr_info_dict)
    return expr_info_dict


def get_sch_and_binds(t2c_params):  # pylint: disable=R0914
    """

    :param t2c_params:
    :return:
    """
    op_schedule_info = t2c_params.op_schedule_info
    align_sch_obj = copy.deepcopy(op_schedule_info.schedule_obj)
    special_tensor_dict = copy.deepcopy(op_schedule_info.special_tensor_dict)
    code_lines = copy.deepcopy(t2c_params.code_lines)
    # 遗留到storage_align做的emit_insn，这里要做一下
    emit_insn_code_dict = op_schedule_info.emit_insn_code_dict
    log.dbg("emit_insn_code_dict: %s", emit_insn_code_dict)
    for stage_index, emit_insn_dict in emit_insn_code_dict.items():
        emit_insn_axis_obj = None
        # 需要挪轴的stage是不会做split的，因此可以直接到stage.op.axis中去查找
        for axis_obj in align_sch_obj.stages[stage_index].op.axis:
            if axis_obj.var.name == emit_insn_dict['axis_obj'].var.name:
                emit_insn_axis_obj = axis_obj
                break
        intrinsic_func_name = emit_insn_dict['intrin']
        align_sch_obj.stages[stage_index].emit_insn(emit_insn_axis_obj,
                                                    intrinsic_func_name)
        tsrz_line = emit_insn_dict["code"]
        code_lines.append(tsrz_line)

    features = t2c_params.op_schedule_info.feature_tensor
    sample_actions = t2c_params.actions
    code_lines.append('\n')
    code_lines.append(
        '# feature(without action): %s' %
        str(features.tolist() if isinstance(features, np.ndarray) else features)
    )
    code_lines.append(
        '# sampled actions: %s' %
        str(sample_actions.tolist() if isinstance(sample_actions, np.ndarray) else sample_actions)
    )
    cleaned_actions = t2c_params.cleaned_actions
    code_lines.append(
        '# cleaned actions: %s' %
        str(cleaned_actions.tolist() if isinstance(cleaned_actions, np.ndarray) else cleaned_actions)
    )

    # 统一加上四个字符的缩进
    for i, _ in enumerate(code_lines):
        code_lines[i] = '    %s' % code_lines[i]
    schedule_code = "\n".join(code_lines)
    # 获取binds
    all_tensors, all_tensor_names = get_all_tensors(align_sch_obj,
                                                    special_tensor_dict)
    binds = get_tensors_by_tensors_str(op_schedule_info.tensor_list_str,
                                       all_tensors, all_tensor_names)

    return align_sch_obj, binds, schedule_code


def get_expr_info_dict(t2c_params):
    """
    获取expr_info_dict
    数据结构定义：
    expr_buffer_dict = {
        "stage_name": buffer_var,
        "axis_var_list": [],    # 下标涉及的轴
        "stride_dict": {},      # 实际为下标轴对应的系数
    }
    expr_info = {
        "dst": [expr_buffer_dict],
        "src": [expr_buffer_dict],
        "shape": [],
        "emit_insn_axis_list": [],
    }
    expr_info_dict[stage_name] = [expr_info],
    # 一个stage可能有多个for循环和表达式
    """

    # 1、获取schedule对象、binds列表
    sch, binds, schedule_code = get_sch_and_binds(t2c_params)
    log.dbg("tensor_list: %s, binds: %s",
            t2c_params.op_schedule_info.tensor_list_str, binds)

    # 2、获取storage_align_info
    with build_config(bool_storage_as_1bit=False):
        try:
            expr_info_dict = get_storage_align_info(sch, binds)
        except Exception:  # pylint: disable=broad-except
            # 保存算子到文件，打印py路径和异常信息，用于问题定位
            op_schedule_info = t2c_params.op_schedule_info
            error_dir = "align_exception"
            kernel_name, _ = env_util.gen_kernel_name(op_schedule_info.op_name)
            py_file = store_tmp_proc(op_schedule_info, schedule_code,
                                     error_dir, kernel_name, True)
            log.info("storage_align exception: %s", py_file)
            return {}

    return expr_info_dict
