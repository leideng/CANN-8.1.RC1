#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import math
from schedule_search import log
from schedule_search import comm
from schedule_search import soc_cfg
from schedule_search import op_cfg
from schedule_search.ts_env import env_util
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_cfg import AxisInfo
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.tensor_to_code import t2c_util
from schedule_search.ts_env.tensor_to_code.t2c_util import BROADCAST_AT_POSTFIX
from schedule_search.ts_env.tensor_to_code.t2c_util import COMMON_AT_POSTFIX
from schedule_search.ts_env.tensor_to_code.t2c_util import MULTICORE_POSTFIX
from schedule_search.ts_env.cheque_generator import get_split_cheque
from schedule_search.ts_env.cheque_generator import get_axis_cheque
from schedule_search.ts_env.cheque_generator import get_axis_index
from schedule_search.timer import timer


@timer()
def split_axis_once_proc(split_axis_proc_info_dict,  # pylint: disable=R0913
                         axis_name, axis_len,
                         stage_axis_info, t2c_params, stage_index):
    """
    :param split_axis_proc_info_dict:
    :param axis_name:
    :param axis_len:
    :param stage_axis_info:
    :param t2c_params:
    :return:
    """
    split_axis_proc_info_dict["code_lines"].append(
        '%s_o, %s_i = sch[%s].split(sch[%s].op.%saxis[%d],'
        ' factor=%d)' %
        (axis_name, axis_name, split_axis_proc_info_dict["stage_name"],
         split_axis_proc_info_dict["stage_name"],
         split_axis_proc_info_dict["prefix"],
         split_axis_proc_info_dict["axis_idx"],
         split_axis_proc_info_dict["factor_1"]))
    axis_obj_o, axis_obj_n1o, axis_obj_i = None, None, None
    if split_axis_proc_info_dict["mode"] == MODE_RUNTIME:
        log.dbg('stage %s axis %s factor: %d',
                split_axis_proc_info_dict["stage"],
                split_axis_proc_info_dict["axis"],
                split_axis_proc_info_dict["factor_1"])
        axis_obj_o, axis_obj_i = split_axis_proc_info_dict["stage"].split(
            split_axis_proc_info_dict["axis"],
            factor=split_axis_proc_info_dict["factor_1"])
    # TODO可能会存在尾块的情况，当前没有考虑尾块
    axis_o_len = math.floor(
        (axis_len + split_axis_proc_info_dict["factor_1"] - 1) /
        split_axis_proc_info_dict["factor_1"])
    stage_axis_info.append(
        AxisInfo(axis_name + '_o', axis_o_len,
                 split_axis_proc_info_dict["prefix"] + 'axis',
                 split_axis_proc_info_dict["axis_idx"], 'o', axis_obj_o))

    # 生成split操作对应的cheque。并删除切分轴，增加切分后新生成的轴
    # 切分的原始轴axis
    ori_order_axis = t2c_util.get_ori_order(stage_axis_info)
    splited_axis_index = get_axis_index(ori_order_axis, axis_name + '_o')
    get_split_cheque(t2c_params, stage_index, splited_axis_index,
                     split_axis_proc_info_dict["factor_1"])

    # 只有切分轴的切分因子有可能不被factor整除，不能整除时再对i切出n1_o=1
    c_op = t2c_params.op_schedule_info.c_op
    if split_axis_proc_info_dict["is_last_stage"] and \
        axis_len % split_axis_proc_info_dict["factor_1"] > 0 and \
        c_op not in comm.MAD_OP_ID_LIST:
        split_axis_proc_info_dict["code_lines"].append(
            '%s%s, %s_i = sch[%s].split(%s_i, factor=%d)' %
            (axis_name, COMMON_AT_POSTFIX, axis_name,
             split_axis_proc_info_dict["stage_name"], axis_name,
             split_axis_proc_info_dict["factor_1"]))
        if split_axis_proc_info_dict["mode"] == MODE_RUNTIME:
            axis_obj_n1o, axis_obj_i = split_axis_proc_info_dict[
                "stage"].split(axis_obj_i,
                               factor=split_axis_proc_info_dict["factor_1"])
        stage_axis_info.append(
            AxisInfo(axis_name + COMMON_AT_POSTFIX, 1,
                     split_axis_proc_info_dict["prefix"] + 'axis',
                     split_axis_proc_info_dict["axis_idx"], 'o', axis_obj_n1o))
        # 切分的axis_i，生成cheque
        get_split_cheque(t2c_params, stage_index, splited_axis_index + 1,
                         split_axis_proc_info_dict["factor_1"])
    return axis_obj_i


@timer()
def split_axis_twice_proc(t2c_params,  # pylint: disable=R0913,R0914
                          split_axis_proc_info_dict,
                          nparts32_factor, stage_axis_info, axis_name,
                          stage_index):
    """
    split_axis_twice_proc
    :param t2c_params:
    :param split_axis_proc_info_dict:
    :param nparts32_factor:
    :param stage_axis_info:
    :param axis_name:
    :return:
    """
    split_axis_proc_info_dict["code_lines"].append(
        '%s%s, %s_to = sch[%s].split(sch[%s].op.axis[%d],'
        ' factor=%d)' %
        (axis_name, MULTICORE_POSTFIX, axis_name,
         split_axis_proc_info_dict["stage_name"],
         split_axis_proc_info_dict["stage_name"],
         split_axis_proc_info_dict["axis_idx"], nparts32_factor))
    split_axis_proc_info_dict["code_lines"].append(
        '%s%s, %s_so = sch[%s].split(%s_to, factor=%d)' %
        (axis_name, BROADCAST_AT_POSTFIX, axis_name,
         split_axis_proc_info_dict["stage_name"], axis_name, nparts32_factor))

    if split_axis_proc_info_dict["factor_1"] > nparts32_factor:
        split_axis_proc_info_dict["factor_1"] = nparts32_factor
        axis_idx = split_axis_proc_info_dict["axis_idx"]
        t2c_params.cleaned_actions[t2c_params.stage_index][
            ActionTensorCfg.split_factor_s + axis_idx] = nparts32_factor

    split_axis_proc_info_dict["code_lines"].append(
        '%s%s, %s_i = sch[%s].split(%s_so, factor=%d)' %
        (axis_name, COMMON_AT_POSTFIX, axis_name,
         split_axis_proc_info_dict["stage_name"], axis_name,
         split_axis_proc_info_dict["factor_1"]))
    axis_obj_oo, axis_obj_n1o, axis_obj_o, axis_obj_i \
        = None, None, None, None
    if split_axis_proc_info_dict["mode"] == MODE_RUNTIME:
        axis_obj_oo, axis_obj_to = split_axis_proc_info_dict["stage"].split(
            split_axis_proc_info_dict["axis"], factor=nparts32_factor)
        axis_obj_n1o, axis_obj_so = split_axis_proc_info_dict["stage"].split(
            axis_obj_to, factor=nparts32_factor)
        axis_obj_o, axis_obj_i = split_axis_proc_info_dict["stage"].split(
            axis_obj_so, factor=split_axis_proc_info_dict["factor_1"])
    multicore_len = math.ceil(split_axis_proc_info_dict[
        "axis"].dom.extent.value / nparts32_factor)
    stage_axis_info.append(
        AxisInfo(axis_name + MULTICORE_POSTFIX, multicore_len, 'axis',
                 split_axis_proc_info_dict["axis_idx"], 'o', axis_obj_oo))
    stage_axis_info.append(
        AxisInfo(axis_name + BROADCAST_AT_POSTFIX, 1, 'axis',
                 split_axis_proc_info_dict["axis_idx"], 'o', axis_obj_n1o))
    axis_o_len = math.ceil(nparts32_factor /
                           split_axis_proc_info_dict["factor_1"])
    stage_axis_info.append(
        AxisInfo(axis_name + COMMON_AT_POSTFIX, axis_o_len, 'axis',
                 split_axis_proc_info_dict["axis_idx"], 'o', axis_obj_o))

    # 生成split操作对应的cheque。
    ori_order_axis = t2c_util.get_ori_order(stage_axis_info)
    splited_axis_index = get_axis_index(ori_order_axis,
                                        axis_name + MULTICORE_POSTFIX)
    get_split_cheque(t2c_params, stage_index, splited_axis_index,
                     nparts32_factor)
    get_split_cheque(t2c_params, stage_index, splited_axis_index + 1,
                     nparts32_factor)
    get_split_cheque(t2c_params, stage_index, splited_axis_index + 2,
                     split_axis_proc_info_dict["factor_1"])
    return axis_obj_i


@timer()
def split_axis_factor2_proc(split_axis_proc_info_dict,  # pylint: disable=R0913
                            axis_name, axis_obj_i,
                            stage_axis_info, t2c_params, stage_index):
    """

    :param split_axis_proc_info_dict:
    :param axis_name:
    :param axis_obj_i:
    :param stage_axis_info:
    :param t2c_params:
    :return:
    """
    if split_axis_proc_info_dict["factor_2"] > 0:
        factor_2 = split_axis_proc_info_dict["factor_2"]

        def get_update_stage_name(op_type):
            return op_cfg.CUBE_VECTOR_COMMON_SCHEDULE_STAGE.get(op_type, "")

        def get_factor2(split_axis_proc_info_dict, stage_name, split_axis_name):
            factor_2 = split_axis_proc_info_dict["factor_2"]
            if split_axis_proc_info_dict["stage_name"] != stage_name:
                return factor_2

            # f2 great than f1, can't exist
            # f2 less than f1, wait expend
            # just process f2 equals f1
            if split_axis_proc_info_dict["factor_1"] != split_axis_proc_info_dict["factor_2"]:
                return factor_2

            sub_block_factor = op_cfg.get_sub_block_factor()
            cuttable = split_axis_proc_info_dict["factor_2"] > sub_block_factor
            if cuttable:
                return split_axis_proc_info_dict["factor_2"] // sub_block_factor

            return factor_2

        op_name = t2c_params.op_name
        if op_cfg.is_support_split(op_name):
            split_stage_name = get_update_stage_name(op_name)
            factor_2 = get_factor2(split_axis_proc_info_dict, split_stage_name, axis_name)

        # 对i轴再切第二刀
        split_axis_proc_info_dict["code_lines"].append(
            '%s_io, %s_ii = sch[%s].split(%s_i, factor=%d)' %
            (axis_name, axis_name, split_axis_proc_info_dict["stage_name"],
             axis_name, factor_2))
        axis_obj_io, axis_obj_ii = None, None
        if split_axis_proc_info_dict["mode"] == MODE_RUNTIME:
            log.dbg('stage %s axis %s factor: %d',
                    split_axis_proc_info_dict["stage"], axis_obj_i,
                    split_axis_proc_info_dict["factor_2"])
            axis_obj_io, axis_obj_ii = split_axis_proc_info_dict[
                "stage"].split(axis_obj_i,
                               factor=factor_2)
        # TODO可能会存在尾块的情况，当前没有考虑尾块
        stage_axis_info.append(
            AxisInfo(
                axis_name + '_io', split_axis_proc_info_dict["factor_1"] //
                factor_2,
                split_axis_proc_info_dict["prefix"] + 'axis',
                split_axis_proc_info_dict["axis_idx"], 'io', axis_obj_io))
        stage_axis_info.append(
            AxisInfo(axis_name + '_ii', factor_2,
                     split_axis_proc_info_dict["prefix"] + 'axis',
                     split_axis_proc_info_dict["axis_idx"], 'ii', axis_obj_ii))

        # 对i轴切分的第二刀操作生成对应的cheque
        ori_order_axis = t2c_util.get_ori_order(stage_axis_info)
        splited_axis_index = get_axis_index(ori_order_axis, axis_name + '_io')
        get_split_cheque(t2c_params, stage_index, splited_axis_index,
                         factor_2)

    else:
        stage_axis_info.append(
            AxisInfo(axis_name + '_i', split_axis_proc_info_dict["factor_1"],
                     split_axis_proc_info_dict["prefix"] + 'axis',
                     split_axis_proc_info_dict["axis_idx"], 'i', axis_obj_i))


@timer()
def split_axis_proc(t2c_params, split_axis_proc_info_list, stage_index,
                    o_tail=''):
    """

    :param t2c_params:
    :param split_axis_proc_info_list:
    :param o_tail:
    :return:
    """
    split_axis_proc_info_dict = {
        "axis": split_axis_proc_info_list[0],
        "factor_1": split_axis_proc_info_list[1],
        "factor_2": split_axis_proc_info_list[2],
        "code_lines": split_axis_proc_info_list[3],
        "stage": split_axis_proc_info_list[4],
        "stage_name": split_axis_proc_info_list[5],
        "prefix": split_axis_proc_info_list[7],
        "axis_idx": split_axis_proc_info_list[8],
        "mode": split_axis_proc_info_list[9],
        "is_last_stage": split_axis_proc_info_list[10],
        "before_len": split_axis_proc_info_list[11],
    }

    stage_axis_info = split_axis_proc_info_list[6]
    axis_len = split_axis_proc_info_dict.get("axis").dom.extent.value
    axis_name = '%s_%saxis_%d' % (split_axis_proc_info_dict.get("stage_name"),
                                  split_axis_proc_info_dict.get("prefix"),
                                  split_axis_proc_info_dict.get("axis_idx"))
    # Factor为0的，不执行split操作
    # 最后一个Stage，且不能整除的，也先不直接切分，而是放到Bind中统一处理
    if split_axis_proc_info_dict.get("factor_1") == 0:
        split_axis_proc_info_dict.get("code_lines").append(
            '%s = sch[%s].op.%saxis[%d]' %
            (axis_name + o_tail, split_axis_proc_info_dict.get("stage_name"),
             split_axis_proc_info_dict.get("prefix"),
             split_axis_proc_info_dict.get("axis_idx")))
        stage_axis_info.append(
            AxisInfo(axis_name + o_tail, axis_len,
                     split_axis_proc_info_dict.get("prefix") + 'axis',
                     split_axis_proc_info_dict.get("axis_idx"),
                     o_tail[1:] if o_tail != '' else 'c',
                     split_axis_proc_info_dict.get("axis")))
        return

    # d，核数
    core_num = soc_cfg.get_core_num()
    # 最后一个Stage，非整除，前面的Fuse起来比核数少，要切的轴又比较大，要切2次
    need_split_twice = True
    need_split_twice &= split_axis_proc_info_dict.get("is_last_stage")
    need_split_twice &= axis_len % split_axis_proc_info_dict.get("factor_1") > 0
    need_split_twice &= split_axis_proc_info_dict.get("before_len") < core_num
    need_split_twice &= split_axis_proc_info_dict.get("factor_2") == 0

    if need_split_twice \
            and t2c_params.op_schedule_info.c_op not in comm.MAD_OP_ID_LIST \
            and t2c_params.op_schedule_info.option.get('op_type') not in op_cfg.TIK_TO_DSL_OP_LIST.keys() \
            and axis_len > split_axis_proc_info_dict.get("factor_1") * core_num \
            / split_axis_proc_info_dict.get("before_len"):
        nparts32_factor = math.ceil(
            axis_len * split_axis_proc_info_dict.get("before_len") / 32)
        block_dim = env_util.get_block_num(
            split_axis_proc_info_dict.get("stage").op.output(0).dtype)
        nparts32_factor = int(nparts32_factor / block_dim) * block_dim
        if not nparts32_factor:
            nparts32_factor = min(block_dim, axis_len)
        axis_obj_i = split_axis_twice_proc(t2c_params,
                                           split_axis_proc_info_dict,
                                           nparts32_factor, stage_axis_info,
                                           axis_name, stage_index)
    else:
        axis_obj_i = split_axis_once_proc(split_axis_proc_info_dict, axis_name,
                                          axis_len, stage_axis_info,
                                          t2c_params, stage_index)
    split_axis_factor2_proc(split_axis_proc_info_dict, axis_name, axis_obj_i,
                            stage_axis_info, t2c_params, stage_index)
    return


@timer()
def split_one_before_cut_start(t2c_params):
    """
    第一根切分轴之前的axis是否按factor=1进行切分
    :param t2c_params:
    :return:
    """
    if t2c_util.gn_training_update_nchw(t2c_params.op_schedule_info):
        return False

    return True


@timer()
def get_o_tail(cut_start,   # pylint: disable=R0913
               cut_axis_index, factor_1, axis_index,
               stage_axis_obj, t2c_params):
    """
    get_o_tail
    :param cut_start:
    :param cut_axis_index:
    :param factor_1:
    :param axis_index:
    :param stage_axis_obj:
    :return:
    """
    o_tail = ''
    if cut_start is False and factor_1 == 1 and axis_index != len(
            stage_axis_obj) - 1:
        factor_1 = 0
        # 如果stage的axis order没有变化，切分轴之前的轴不切分
        if split_one_before_cut_start(t2c_params):
            factor_1 = 1
        o_tail = '_o'
        cut_axis_index = axis_index + 1
    # 已经切过了，且轴长等于Factor，则不要切
    elif cut_start and stage_axis_obj[axis_index].dom.extent.value == factor_1:
        o_tail = '_o'
    else:
        cut_start = True
    return o_tail, factor_1, cut_axis_index, cut_start


def get_rnn_split_factor(split_vector, axis_index, stage, at_stage):
    '''
    rnn类算子获取mad对应的切分因子
    '''
    if len(stage.op.axis) == len(at_stage.op.axis):
        factor_1 = split_vector[axis_index]
        factor_2 = split_vector[axis_index + t2c_util.max_axis()]
        return factor_1, factor_2

    if axis_index == 0:
        factor_1 = split_vector[axis_index]
        factor_2 = split_vector[axis_index + t2c_util.max_axis()]
    elif axis_index == 1:
        factor_1 = factor_2 = 0
    else:
        factor_1 = split_vector[axis_index - 1]
        factor_2 = split_vector[axis_index - 1 + t2c_util.max_axis()]
    return factor_1, factor_2


def get_split_factor(t2c_params, axis_index, split_axis_info_dict,
                     stage_index):
    """
    get_split_factor
    :param t2c_params:
    :param axis_index:
    :param split_axis_info_dict:
    :return:
    """
    split_vector = split_axis_info_dict["split_vector"]
    if t2c_params.op_schedule_info.op_name in op_cfg.RNN_OP_LIST and \
            split_axis_info_dict["intrin"] == "mad" and \
            not split_axis_info_dict["prefix"]:
        stage = t2c_params.schedule.stages[stage_index]
        at_index = t2c_params.op_schedule_info.at_dict[stage_index]
        at_stage = t2c_params.schedule.stages[at_index]
        return get_rnn_split_factor(split_vector, axis_index, stage, at_stage)

    factor_1 = split_vector[axis_index]
    factor_2 = split_vector[axis_index + t2c_util.max_axis()]
    return factor_1, factor_2


@timer()
def split_axis(t2c_params, split_axis_info_dict, stage_index):
    """
    split_axis
    :param t2c_params:
    :param split_axis_info_dict
    :param stage_index
    :return:
    """
    # 实际切分axis
    cut_start = False
    cut_axis_index = 0
    before_len = 1
    for axis_index, axis in enumerate(split_axis_info_dict["stage_axis_obj"]):
        factor_1, factor_2 = get_split_factor(t2c_params, axis_index,
                                              split_axis_info_dict,
                                              stage_index)
        if not split_axis_info_dict["mad_info"]:
            # factor1在碰到第一个非1的factor之前，切分factor=1
            o_tail, factor_1, cut_axis_index, cut_start = get_o_tail(
                cut_start, cut_axis_index, factor_1, axis_index,
                split_axis_info_dict["stage_axis_obj"], t2c_params)

            if t2c_params.op_schedule_info.option.get('op_type') in op_cfg.TIK_TO_DSL_OP_LIST.keys():
                if axis.dom.extent.value != factor_1:
                    t2c_params.last_cut_axis_index[stage_index] = axis_index
                    if factor_1 != 1 and t2c_params.first_cut_part_factor_axis_index.get(stage_index) is None:
                        t2c_params.first_cut_part_factor_axis_index[stage_index] = axis_index

            split_axis_proc_info_list = [
                axis, factor_1, factor_2, split_axis_info_dict["code_lines"],
                split_axis_info_dict["stage"],
                split_axis_info_dict["stage_name"],
                split_axis_info_dict["stage_axis_info"],
                split_axis_info_dict["prefix"], axis_index,
                split_axis_info_dict["mode"],
                split_axis_info_dict["is_last_stage"], before_len
            ]
            split_axis_proc(t2c_params,
                            split_axis_proc_info_list,
                            stage_index,
                            o_tail=o_tail)
        elif split_axis_info_dict["mad_info"]["cut_K"]:
            # 如果切了大K，走MNKk模板，对mad stage切两刀，
            # 最后一个stage切一刀(L1 buffer)
            real_factor_2 = factor_2 if split_axis_info_dict["intrin"] == "mad" else 0
            split_axis_proc_info_list = [
                axis, factor_1, real_factor_2,
                split_axis_info_dict["code_lines"],
                split_axis_info_dict["stage"],
                split_axis_info_dict["stage_name"],
                split_axis_info_dict["stage_axis_info"],
                split_axis_info_dict["prefix"], axis_index,
                split_axis_info_dict["mode"],
                split_axis_info_dict["is_last_stage"], before_len
            ]
            split_axis_proc(t2c_params, split_axis_proc_info_list, stage_index)
        else:
            # 如果没有切大K，走MNmnk模板，对最后一个stage切两刀，
            # mad stage切一刀(L0 buffer)
            if split_axis_info_dict["intrin"] == "mad":
                factor_1 = factor_2
                factor_2 = 0
            split_axis_proc_info_list = [
                axis, factor_1, factor_2,
                split_axis_info_dict["code_lines"],
                split_axis_info_dict["stage"],
                split_axis_info_dict["stage_name"],
                split_axis_info_dict["stage_axis_info"],
                split_axis_info_dict["prefix"], axis_index,
                split_axis_info_dict["mode"],
                split_axis_info_dict["is_last_stage"], before_len
            ]
            split_axis_proc(t2c_params, split_axis_proc_info_list, stage_index)
        before_len *= axis.dom.extent.value
    return cut_axis_index


@timer()
def get_o_axis(t2c_params, stage_index, stage_axis_info):
    '''
    :param t2c_params:
    :param stage_index:
    :param stage_axis_info:
    :return:
    '''
    reorder_list = t2c_params.actions[stage_index][
        ActionTensorCfg.reorder_s:ActionTensorCfg.reorder_s + \
                                   t2c_util.max_axis()]
    o_axis_info_list = []
    for axis_index in reorder_list:
        for axis_info in stage_axis_info[:]:
            if axis_info.index == axis_index and axis_info.attr == 'o':
                o_axis_info_list.append(axis_info)
                stage_axis_info.remove(axis_info)
    return o_axis_info_list


@timer()
def split_for_gemm_bind(t2c_params,  # pylint: disable=R0914
                        stage_index, stage_axis_info, code_lines):
    '''
    :param t2c_params:
    :param stage_index:
    :param stage_axis_info:
    :param code_lines:
    :return:
    '''
    stage_name = t2c_params.stages_info[stage_index].get('name')
    has_batch, _ = t2c_util.gemm_identify(t2c_params.op_schedule_info)
    bind_len = t2c_params.schedule.stages[stage_index].op.axis[0].dom.extent.value if has_batch else 1
    core_num = soc_cfg.get_core_num()
    if bind_len >= core_num:
        return code_lines, stage_axis_info

    n_axis_index, _ = t2c_util.get_nm_axis_index(t2c_params.op_schedule_info)
    c_op = t2c_params.op_schedule_info.c_op

    ori_axis_infos = stage_axis_info[:]
    o_axis_info_list = get_o_axis(t2c_params, stage_index, stage_axis_info)
    for axis_info in o_axis_info_list[:]:
        if bind_len >= core_num:
            break
        axis_index = get_axis_index(ori_axis_infos, axis_info.name)
        # 深度融合时，不允许Co轴切多核
        if axis_info.index == n_axis_index and \
                c_op in comm.MAD_OP_ID_MAP.values():
            nparts = 1
        else:
            nparts = min((core_num + bind_len - 1) // bind_len, axis_info.len)
        bind_len *= nparts
        code_lines.append(
            '%s_oo, %s = sch[%s].split(%s, nparts=%d)' % (
                axis_info.name, axis_info.name, stage_name,
                axis_info.name, nparts))
        axis_obj_o, axis_obj_i = None, None
        if t2c_params.mode == MODE_RUNTIME:
            axis_obj_o, axis_obj_i = t2c_params.schedule.stages[
                stage_index].split(axis_info.body, nparts=nparts)
        stage_axis_info.append(
            AxisInfo('%s_oo' % axis_info.name, nparts,
                     'axis', axis_info.index, 'oo', axis_obj_o))
        stage_axis_info.append(
            AxisInfo(axis_info.name, axis_info.len // nparts, 'axis',
                     axis_info.index, 'o', axis_obj_i))
        # ori_axis_infos应添加o轴切分后的oo轴
        ori_axis_infos.insert(
            axis_index,
            AxisInfo('%s_oo' % axis_info.name, nparts,
                     'axis', axis_info.index, 'oo', axis_obj_o))
        o_axis_info_list.remove(axis_info)
        # 生成split_nparts对应的cheque
        get_split_cheque(t2c_params, stage_index, axis_index,
                         nparts, "nparts")

    stage_axis_info.extend(o_axis_info_list)
    return code_lines, stage_axis_info


def split_group_axis(t2c_params, stage_index, stage_axis_info, code_lines):
    '''
    卷积算子需要从Co轴切分出group轴
    :param t2c_params:
    :param stage_index:
    :param stage_axis_info:
    :param code_lines:
    :return:
    '''
    if t2c_params.op_schedule_info.c_op not in comm.CONV_OP_ID_LIST:
        return code_lines, stage_axis_info

    stage_name = t2c_params.stages_info[stage_index].get('name')
    n_index, _ = t2c_util.get_nm_axis_index(t2c_params.op_schedule_info)
    axis_info = None
    axis_index = None
    for i, curr_axis_info in enumerate(stage_axis_info):
        if curr_axis_info.index == n_index and curr_axis_info.attr == "o":
            axis_info = curr_axis_info
            axis_index = i
            break

    nparts = 1
    code_lines.append(
        '%s_group, %s = sch[%s].split(%s, nparts=%d)' %
        (axis_info.name, axis_info.name, stage_name, axis_info.name, nparts))
    axis_obj_o, axis_obj_i = None, None
    if t2c_params.mode == MODE_RUNTIME:
        axis_obj_o, axis_obj_i = t2c_params.schedule.stages[stage_index].split(
            axis_info.body, nparts=nparts)
    stage_axis_info.insert(
        axis_index,
        AxisInfo('%s' % axis_info.name, axis_info.len // nparts, 'axis',
                 axis_info.index, 'o', axis_obj_i))
    stage_axis_info.insert(
        axis_index,
        AxisInfo('%s_group' % axis_info.name, nparts, 'axis', axis_info.index,
                 'oo', axis_obj_o))
    stage_axis_info.remove(axis_info)
    # 生成split_nparts对应的cheque
    get_split_cheque(t2c_params, stage_index, axis_index, nparts, "nparts")

    return code_lines, stage_axis_info


@timer()
def split_a_stage(t2c_params, stage_index, mad_info):  # pylint: disable=R0912
    """
    split_a_stage
    :param t2c_params:
    :param stage_index:
    :param mad_info:
    :return:
    """
    code_lines = []
    stage_axis_info = []

    stage = t2c_params.schedule.stages[stage_index]
    stage_info = t2c_params.op_schedule_info.stages_info[stage_index]

    split_info_dict = {
        "stage_name":
            stage_info['name'],
        "is_reduce_stage": (not str(stage.op).startswith("placeholder")
                            and len(stage.op.reduce_axis) > 0) \
                           and stage_info.get('split_axis_type', None) !=
                           'axis',
        "intrin":
            t2c_params.op_schedule_info.op_intrin_key_index[
                t2c_params.features[
                    stage_index][FeatureTensorCfg.compute_s]].intrin,
        "is_last_stage": (stage_index == len(t2c_params.schedule.stages) - 1),
        "split_vector":
            t2c_params.cleaned_actions[stage_index]
            [ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
    }

    # manual_debug split_factor
    debug_params = t2c_params.op_schedule_info.option.get("trs_debug", [False, {}])
    if debug_params[0]:
        split_info_dict["split_vector"] = debug_params[1]["split_vector"]

    # record split info
    if "trs_params" not in stage_info.keys():
        stage_info.setdefault('trs_params', {})
    split_factor_dict = {"split_factor_info": split_info_dict.get("split_vector")}
    stage_info["trs_params"].update(split_factor_dict)

    # 记录split信息到py文件中
    split_vector_info = '# split factor info: %s' % split_info_dict.get("split_vector")
    code_lines.append(split_vector_info)

    if split_info_dict.get("is_reduce_stage"):
        # 生成普通轴和reduce轴对应的cheque
        get_axis_cheque(t2c_params, stage_index)

        if split_info_dict.get("intrin") == "mad":
            # mad对应的stage也需要切分axis轴，切axis轴以最后一个stage为准
            split_axis_info_dict = {
                "stage_axis_info": stage_axis_info,
                "code_lines": code_lines,
                "stage_axis_obj": stage.op.axis,
                "split_vector": mad_info[stage_index]["split_vector"],
                "stage_name": split_info_dict.get("stage_name"),
                "prefix": "",
                "stage": stage,
                "mode": t2c_params.mode,
                "mad_info": mad_info,
                "intrin": split_info_dict.get("intrin"),
                "is_last_stage": split_info_dict.get("is_last_stage"),
            }

            split_axis(t2c_params, split_axis_info_dict, stage_index)
        else:
            # 先把非Reduce轴拿出来，放在最后，不切
            for axis_index, axis in enumerate(stage.op.axis):
                axis_name = '%s_axis_%d' % (split_info_dict.get("stage_name"),
                                            axis_index)
                code_lines.append(
                    '%s = sch[%s].op.axis[%d]' %
                    (axis_name, split_info_dict.get("stage_name"), axis_index))
                stage_axis_info.append(
                    AxisInfo(axis_name,
                             stage.op.axis[axis_index].dom.extent.value,
                             'axis', axis_index, 'all', axis))
        split_info_dict["stage_axis_obj"] = stage.op.reduce_axis
        split_info_dict["prefix"] = 'reduce_'
    else:
        # 如果有reduce轴，记录下来
        for axis_index, axis in enumerate(stage.op.reduce_axis):
            axis_name = '%s_reduce_axis_%d' % (split_info_dict.get("stage_name"),
                                               axis_index)
            code_lines.append(
                '%s = sch[%s].op.reduce_axis[%d]' %
                (axis_name, split_info_dict.get("stage_name"), axis_index))
            stage_axis_info.append(
                AxisInfo(axis_name,
                         stage.op.reduce_axis[axis_index].dom.extent.value,
                         'reduce_axis', axis_index, 'all', axis))
        # 生成普通轴对应的cheque，如果有reduce轴，也生成cheque
        get_axis_cheque(t2c_params, stage_index)

        split_info_dict["stage_axis_obj"] = stage.op.axis
        split_info_dict["prefix"] = ''

    # 切分
    split_axis_info_dict = {
        "stage_axis_info": stage_axis_info,
        "code_lines": code_lines,
        "stage_axis_obj": split_info_dict.get("stage_axis_obj"),
        "split_vector": split_info_dict.get("split_vector"),
        "stage_name": split_info_dict.get("stage_name"),
        "prefix": split_info_dict.get("prefix"),
        "stage": stage,
        "mode": t2c_params.mode,
        "mad_info": mad_info,
        "intrin": split_info_dict.get("intrin"),
        "is_last_stage": split_info_dict.get("is_last_stage"),
    }

    cut_axis_index = split_axis(t2c_params, split_axis_info_dict, stage_index)

    # gemm的MN都切一下多核的oo
    if t2c_params.op_schedule_info.c_op in comm.MAD_OP_ID_LIST \
            and split_info_dict.get("is_last_stage"):
        code_lines, stage_axis_info = split_for_gemm_bind(t2c_params,
                                                          stage_index,
                                                          stage_axis_info,
                                                          code_lines)

    return code_lines, stage_axis_info, cut_axis_index
