#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search import util
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.tensor_to_code import t2c_util
from schedule_search.ts_env.tensor_to_code.proc_cache_rw.rules \
    .lv0_write_ub2out import is_broadcast_not_last_tensor
from schedule_search.ts_env.tensor_to_code.proc_emit_insn.rules.comm import \
    get_emit_insn_axis
from schedule_search.ts_env.cheque_generator import get_emit_insn_cheque
from schedule_search.ts_env.cheque_generator import get_reuseby_cheque
from schedule_search.ts_env.cheque_generator import get_double_buffer_cheque

# 对于特殊的非last的broadcast场景，
# 并且指令映射属于以下映射special_broadcast_insn_map之一的
# (目前包括"vector_mul"、"vector_div"、"vector_add"、"vector_sub")，优化指令映射。
SPECIAL_INTRIN_MAP = {
    "vector_mul": "vector_mul_with_broadcast",
    "vector_div": "vector_div_with_broadcast",
    "vector_add": "vector_add_with_broadcast",
    "vector_sub": "vector_sub_with_broadcast"
}


# 判断是否只存在broadcast非last的tensor
def get_broadcast_not_last_tensor(stage):
    """

    :param stage:
    :return:
    """
    broadcast_not_last_tensor = []
    for in_tensor in stage.op.input_tensors:
        # 如果输入的数据里面有broadcast last，则直接返回false，
        # 不属于特殊场景,特殊场景中broadcast只能是非last的
        if in_tensor.op.tag == "broadcast_for_tensor":
            if [x.value for x in in_tensor.op.input_tensors[0].shape] \
                    == [x.value for x in in_tensor.shape]:
                return broadcast_not_last_tensor
        if is_broadcast_not_last_tensor(in_tensor):
            broadcast_not_last_tensor.append(in_tensor)

    return broadcast_not_last_tensor


def _special_check(origin_insn_shape,  # pylint: disable=R0912,R0911
                   broadcast_insn_shape, broadcast_tensor, max_broadcast_axis):
    """

    :param origin_insn_shape:
    :param broadcast_insn_shape:
    :param broadcast_tensor:
    :param max_broadcast_axis:
    :return:
    """
    original_tensor = broadcast_tensor.op.input_tensors[0]
    original_shape = [x.value for x in original_tensor.shape]
    broadcast_shape = [x.value for x in broadcast_tensor.shape]
    # 如果不涉及broadcast，则不做特殊指令替换
    if origin_insn_shape == broadcast_insn_shape:
        return False
    dtype = broadcast_tensor.dtype.lower()
    size = util.get_dtype_size(dtype)
    for i in range(max_broadcast_axis + 1, len(original_shape), 1):
        size = size * original_shape[i]
    if not size % 32 == 0:
        return False

    if dtype != "float32":
        return False

    if len(original_shape) != 5:
        return False
    if original_shape[-1] != 16:
        return False
    if broadcast_shape[2] == 1 or broadcast_shape[3] == 1:
        return False
    return True


# 特殊的broadcast 非last的场景，例如[1,x,1,1,16]-->[2,x,32,8,16]
# broadcast的最后一根轴后面数据要32b align
def is_special_bc(broadcast_not_last_tensor,  # pylint: disable=R0911,R0912
                  ub_split_axis, ub_split_factor):
    """

    :param broadcast_not_last_tensor:
    :param ub_split_axis:
    :param ub_split_factor:
    :return:
    """

    def get_axis_tail_extent(shape_value, factor):
        """

        :param shape_value:
        :param factor:
        :return:
        """
        if shape_value % factor == 0:
            tail_extent = factor
        else:
            tail_extent = shape_value % factor
        return tail_extent

    for broadcast_tensor in broadcast_not_last_tensor:
        original_tensor = broadcast_tensor.op.input_tensors[0]
        original_shape = [x.value for x in original_tensor.shape]
        broadcast_shape = [x.value for x in broadcast_tensor.shape]
        # 找到broadcast非last的最大一根轴,并判断该轴后面的轴长乘积是否32 byte align
        max_broadcast_axis = 0
        origin_insn_shape = []
        broadcast_insn_shape = []
        for i in range(len(original_shape) - 1, -1, -1):
            # 计算IR中实际做指令映射的shape
            if i == ub_split_axis:
                origin_insn_shape.append(
                    get_axis_tail_extent(original_shape[i], ub_split_factor))
                broadcast_insn_shape.append(
                    get_axis_tail_extent(broadcast_shape[i], ub_split_factor))
            elif i > ub_split_axis:
                origin_insn_shape.append(original_shape[i])
                broadcast_insn_shape.append(broadcast_shape[i])
            if original_shape[i] == 1 \
                    and original_shape[i] != broadcast_shape[i]:
                max_broadcast_axis = i
                break
        log.dbg("ori insn shape: %s, broadcast insn shape: %s",
                origin_insn_shape, broadcast_insn_shape)

        if not _special_check(origin_insn_shape, broadcast_insn_shape,
                              broadcast_tensor, max_broadcast_axis):
            return False
    return True


def get_split_info(t2c_params, stage_index):  # pylint: disable=R0914
    """

    :param t2c_params:
    :param stage_index:
    :return:
    """
    split_axis = 0
    split_factor = 1

    try:
        stages = t2c_params.schedule.stages
        stages_info = t2c_params.op_schedule_info.stages_info
        reduce_axis_dict = t2c_params.op_schedule_info.reduce_axis_dict
        features = t2c_params.features
        cleaned_actions = t2c_params.cleaned_actions
        stage_factors, _ = t2c_util.get_factors(
            stages, stages_info, features, cleaned_actions, reduce_axis_dict,
            t2c_params.op_schedule_info.real_fanout_dict)
        factors = stage_factors[stage_index][0]
        log.dbg("factors: %s", factors)
        stage_axis = stages[stage_index].op.axis
        for i in range(len(stage_axis) - 1, -1, -1):
            axis_len = stage_axis[i].dom.extent.value
            factor = factors[i]
            if factor < axis_len or i == 0:
                split_axis = i
                split_factor = factor
                break
    except Exception as exception:  # pylint: disable=broad-except
        log.dbg('get_factors failed. %s', str(exception))

    return split_axis, split_factor


def get_final_intrin(intrin, t2c_params, stage_index, stage):
    """

    :param intrin:
    :param t2c_params:
    :param stage_index:
    :param stage:
    :return:
    """
    if intrin not in SPECIAL_INTRIN_MAP:
        return intrin

    # 特殊场景优化vector部分指令映射，包括"vector_mul"、"vector_div"、
    # "vector_add"、"vector_sub"
    broadcast_not_last_tensor = get_broadcast_not_last_tensor(stage)
    if not broadcast_not_last_tensor:
        return intrin

    # 找到ub tiling的切分轴，用于特殊场景([1,x,1,1,16])的判断
    ub_split_axis, ub_split_factor = get_split_info(t2c_params, stage_index)
    log.dbg("ub_split_axis of %s is: %s, factor is: %s", stage.op.name,
            ub_split_axis, ub_split_factor)

    if is_special_bc(broadcast_not_last_tensor, ub_split_axis,
                     ub_split_factor):
        intrin = SPECIAL_INTRIN_MAP.get(intrin)
    return intrin


def _get_emit_insn_axis(t2c_params, intrin):
    stage = t2c_params.stage
    stage_index = t2c_params.stage_index
    stage_name = t2c_params.stage_name
    axis_info_list = t2c_params.axis_info_list

    if intrin == "vector_muls" and len(stage.op.input_tensors) == 2:
        # vmuls指令为vector 乘以 scale，如果出现两个tensor，则需要特殊处理
        if axis_info_list[stage_index] is None:
            axis_num = len(stage.op.axis) - 1
            emit_insn_axis = "sch[%s].op.axis[%s]" % (stage_name, axis_num)
            emit_insn_axis_obj = stage.op.axis[axis_num]
            return axis_num, emit_insn_axis, emit_insn_axis_obj

    axis_num, emit_insn_axis, emit_insn_axis_obj = get_emit_insn_axis(
        stage,
        stage_index,
        axis_info_list,
        t2c_params.stages_info[stage_index],
        op_name=t2c_params.op_schedule_info.op_name)
    if intrin == 'vector_reduce_sum_last_axis_opt':
        ori_axis_info_list = t2c_params.ori_axis_info_list
        curr_axis_info_list = axis_info_list[stage_index] + ori_axis_info_list[
            stage_index]

        for i, axis_info in enumerate(curr_axis_info_list):
            axis_name = axis_info.name
            if axis_name.endswith("_i"):
                axis_num = i
                emit_insn_axis = axis_name
                emit_insn_axis_obj = axis_info.body
                break
        log.dbg('emit_insn_axis: %s, emit_insn_axis_obj: %s', emit_insn_axis,
                emit_insn_axis_obj)

    return axis_num, emit_insn_axis, emit_insn_axis_obj


def proc(t2c_params):  # pylint: disable=R0914,R0912
    """
    proc
    :param t2c_params:
    :return:
    """
    features = t2c_params.features
    mode = t2c_params.mode
    stage_index = t2c_params.stage_index
    stage_name = t2c_params.stage_name
    stage = t2c_params.stage

    proc_sch = bool(mode == MODE_RUNTIME)

    # 前面规则处理过的stage直接跳过
    if t2c_params.proc_flag_dict.get(stage_index, False):
        return True

    intrinsic_func_name = t2c_params.op_schedule_info.op_intrin_key_index[
        features[stage_index][FeatureTensorCfg.compute_s]].intrin
    intrinsic_func_name = get_final_intrin(intrinsic_func_name, t2c_params,
                                           stage_index, stage)

    insn_axis_idx, emit_insn_axis, emit_insn_axis_obj = _get_emit_insn_axis(
        t2c_params, intrinsic_func_name)

    tsrz_line = "sch[%s].emit_insn(%s, '%s')" % (stage_name, emit_insn_axis,
                                                 intrinsic_func_name)
    t2c_params.code_lines.append(tsrz_line)

    if proc_sch:
        stage.emit_insn(emit_insn_axis_obj, intrinsic_func_name)

    # 生成emit_insn对应的cheque
    get_emit_insn_cheque(t2c_params, stage_index, intrinsic_func_name,
                         (emit_insn_axis, insn_axis_idx))

    if intrinsic_func_name == "vector_axpy":
        fanin_list = t2c_params.op_schedule_info.fanin_dict[stage_index]
        for fanin_index in fanin_list:
            reuse_input = stage.op.input_tensors[1]
            if reuse_input.op.name == t2c_params.schedule.stages[
                    fanin_index].op.name:
                reused_code_line = "sch[%s].reused_by(%s)" % (
                    t2c_params.stages_info[fanin_index]["name"], stage_name)
                t2c_params.code_lines.append(reused_code_line)
                get_reuseby_cheque(t2c_params, fanin_index, stage_index)
                t2c_params.code_lines.append('sch[%s].double_buffer()' %
                                             stage_name)
                # 生成double_buffer对应的cheque
                get_double_buffer_cheque(t2c_params, stage_index)
                if proc_sch:
                    t2c_params.schedule.stages[fanin_index].reused_by(
                        stage.op.output(0))
                    stage.double_buffer()
                break

    t2c_params.proc_flag_dict[stage_index] = True
    return True
