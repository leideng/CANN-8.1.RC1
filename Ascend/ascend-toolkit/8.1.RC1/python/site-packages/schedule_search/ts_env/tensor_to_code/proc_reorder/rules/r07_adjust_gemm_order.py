#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search import comm
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.tensor_to_code import t2c_util
from schedule_search import op_cfg


def k_reorder(stage_index, t2c_params):
    '''
    k固定在mn后面
    '''
    leveled_axis = t2c_params.leveled_axis_for_reorder[stage_index]

    # K轴默认放在MN的后面，涉及O轴和IO轴
    for level in [t2c_util.AXIS_LEVEL_O_INDEX,
                  t2c_util.AXIS_LEVEL_IO_INDEX]:
        for axis_info in leveled_axis[level]:
            if axis_info.type == "reduce_axis":
                leveled_axis[level].remove(axis_info)
                leveled_axis[level].append(axis_info)
            break


def mn_reorder(stage_index, t2c_params):
    '''
    mad的mn轴和最后一个stage的mn轴的reorder顺序必须保持一致
    '''
    leveled_axis = t2c_params.leveled_axis_for_reorder[stage_index]
    axis_num = t2c_util.max_axis()
    reorder_len = ActionTensorCfg.reorder_e + 1 - ActionTensorCfg.reorder_s
    layer_num = reorder_len // axis_num
    for layer_index in range(layer_num):
        order_s = ActionTensorCfg.reorder_s + layer_index * axis_num
        order_e = order_s + axis_num
        reorder_list = t2c_params.actions[-1][order_s:order_e]
        if not leveled_axis[layer_index]:
            return
        # k在最后
        k_index = len(leveled_axis[layer_index]) - 1
        new_reorder_list = []
        for reorder_index in reorder_list:
            if reorder_index != k_index:
                new_reorder_list.append(reorder_index)
        new_reorder_list.append(k_index)
        t2c_params.cleaned_actions[stage_index][order_s:order_e] \
            = new_reorder_list


def mnk_reorder(stage_index, t2c_params):
    '''
    mn的顺序基于采样，k固定在mn后面
    '''
    k_reorder(stage_index, t2c_params)
    mn_reorder(stage_index, t2c_params)


def mad_reorder(stage_index, t2c_params):  # pylint: disable=R0912
    '''
    mad
    '''
    leveled_axis = t2c_params.leveled_axis_for_reorder[stage_index]

    # 将k0放置在c的最后一个
    for axis_info in leveled_axis[t2c_util.AXIS_LEVEL_C_INDEX]:
        if axis_info.name.endswith("_k0"):
            leveled_axis[t2c_util.AXIS_LEVEL_C_INDEX].remove(axis_info)
            leveled_axis[t2c_util.AXIS_LEVEL_C_INDEX].append(axis_info)

    # 将ki_inner放置在c的倒数第二个
    for axis_info in leveled_axis[t2c_util.AXIS_LEVEL_I_II_NORMAL_INDEX]:
        if axis_info.type == "reduce_axis":
            leveled_axis[t2c_util.AXIS_LEVEL_I_II_NORMAL_INDEX].remove(
                axis_info)
            leveled_axis[t2c_util.AXIS_LEVEL_C_INDEX].insert(-1, axis_info)
            break

    # 将iio轴放在ii轴的最前面，当前iio轴仅用于mad某些场景下，
    # 保证参与mad的B矩阵N为1
    for axis_info in leveled_axis[t2c_util.AXIS_LEVEL_IIO_INDEX]:
        leveled_axis[t2c_util.AXIS_LEVEL_I_II_NORMAL_INDEX].insert(
            0, axis_info)

    # RNN类算子mad对应的stage有多个n，将其第一个n轴不做切分，放在ii轴前面
    if t2c_params.op_schedule_info.op_name in op_cfg.RNN_OP_LIST:
        for axis_info in leveled_axis[t2c_util.AXIS_LEVEL_C_INDEX]:
            if axis_info.index == 1 and axis_info.type == "axis":
                leveled_axis[t2c_util.AXIS_LEVEL_C_INDEX].remove(axis_info)
                leveled_axis[t2c_util.AXIS_LEVEL_I_II_NORMAL_INDEX].insert(
                    0, axis_info)
    # mnk的顺序
    mnk_reorder(stage_index, t2c_params)


def gm_reorder(stage_index, t2c_params):  # pylint: disable=R0912
    '''
    gm
    '''
    leveled_axis = t2c_params.leveled_axis_for_reorder[stage_index]

    # 逐层重排
    has_batch, _ = t2c_util.gemm_identify(t2c_params.op_schedule_info)
    axis_num = t2c_util.max_axis()
    layer_num = (ActionTensorCfg.reorder_e + 1 -
                 ActionTensorCfg.reorder_s) // axis_num
    for layer_index in range(layer_num):
        new_layer_leveled_axis = []
        order_s = ActionTensorCfg.reorder_s + layer_index * axis_num
        order_e = order_s + axis_num
        reorder_list = t2c_params.actions[stage_index][order_s:order_e]
        for axis_index in reorder_list:
            if has_batch:
                axis_index += 1
            for axis_info in leveled_axis[layer_index]:
                if axis_info.index == axis_index:
                    new_layer_leveled_axis.append(axis_info)
        t2c_params.leveled_axis_for_reorder[stage_index][layer_index] = \
            new_layer_leveled_axis
        t2c_params.cleaned_actions[stage_index][order_s:order_e] = list(
            range(axis_num))


def proc(t2c_params):
    """
    规则内容：mad的reorder
    """
    # 输入
    c_op = t2c_params.op_schedule_info.c_op
    if c_op not in comm.MAD_OP_ID_LIST:
        return

    features = t2c_params.features
    stage_num = len(features)
    last_stage_index = stage_num - 1

    for stage_index in range(stage_num):
        intrin = t2c_params.op_schedule_info.op_intrin_key_index[
            features[stage_index][FeatureTensorCfg.compute_s]].intrin
        # mad stage
        if 'mad' in intrin:
            mad_reorder(stage_index, t2c_params)
        # gm stage,一个axis，split可能会切出多个o，但是采样的是axis index，处理一下
        elif stage_index == last_stage_index:
            gm_reorder(stage_index, t2c_params)

    log.dbg('gemm reorder done')
