#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from functools import reduce as functools_reduce

from schedule_search import log
from schedule_search.controller.mcts_search.features import UB_BUFFER_SIZE
from schedule_search.ts_env import env_util
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.timer import timer
from tbe import tvm


def must_split_axis(t2c_params):
    """
    :param t2c_params:
    :return:
    """
    if t2c_params.op_schedule_info.op_name in ['diag_part_d'] and \
            len(t2c_params.op_schedule_info.output_info_list[0].shape) == 1:
        return True

    return False


def split_none_reduce(t2c_params, shape_before_reduce, reduce_axis_indexs, reduce_size, reduce_stage_index):

    # reduce stage没有切就算了
    split_vector_s = ActionTensorCfg.split_factor_s
    split_vector_e = ActionTensorCfg.split_factor_e + 1
    reduce_stage_action = t2c_params.cleaned_actions[reduce_stage_index]
    reduce_split_vector = reduce_stage_action[split_vector_s:split_vector_e]
    reduce_stage = t2c_params.schedule.stages[reduce_stage_index]
    if sum(reduce_split_vector) == 0:
        return

    must_flag = must_split_axis(t2c_params)

    t2c_params.op_schedule_info.stages_info[reduce_stage_index][
        'split_axis_type'] = 'axis'
    log.dbg("reduce stage %s need split axis", reduce_stage)

    # 计算可以切分的普通轴范围
    # 切普通轴，reorder要把reduce轴放在最后，
    # 因此，需要保证切下的普通轴尾块和reduce轴乘积小于ub。
    # 由于reduce stage会compute at到最后的非reduce stage，继承普通轴的切分，
    # 因此，reduce stage切普通轴时，只能切最后一个stage切分轴之后的普通轴
    # 1、先获取最终的切分轴和切分因子
    last_stage_action = t2c_params.cleaned_actions[-1]
    last_split_vector = last_stage_action[split_vector_s:split_vector_e]
    axis_len_list = [
        axis.dom.extent.value
        for axis in t2c_params.schedule.stages[-1].op.axis
    ]
    axis_num = len(axis_len_list)
    last_split_axis = axis_num - 1
    last_split_factor = 1
    for axis_index in range(axis_num):
        if last_split_vector[axis_index] != 1:
            last_split_axis = axis_index
            last_split_factor = last_split_vector[axis_index]
            break
    is_keepdims = len(shape_before_reduce) == axis_num
    last_split_axis = env_util.find_none_reduce_axis_index(
        last_split_axis,
        shape_before_reduce,
        reduce_axis_indexs,
        is_keepdims=is_keepdims)
    log.dbg(
        "last_split_vector: %s, last_split_axis: %s, last_split_factor: %s",
        last_split_vector, last_split_axis, last_split_factor)

    # 2、获取reduce stage可切的普通轴的最小axis和该axis的最大切分因子
    min_split_axis = last_split_axis
    total_size = reduce_size
    for axis_index in range(axis_num - 1, last_split_axis - 1, -1):
        axis_len = axis_len_list[axis_index]
        if axis_index == last_split_axis:
            axis_len = last_split_factor
        total_size *= axis_len
        if total_size > UB_BUFFER_SIZE:
            min_split_axis = axis_index
            break
    min_split_axis_len = axis_len_list[min_split_axis] if min_split_axis != last_split_axis else last_split_factor
    total_size /= min_split_axis_len

    max_split_factor = 1
    for factor in range(min_split_axis_len, 0, -1):
        if total_size * factor < UB_BUFFER_SIZE:
            max_split_factor = factor
            break
    # 放宽一点，这里正好临界，可能有最优值
    if max_split_factor + 2 < min_split_axis_len:
        max_split_factor += 2
    log.dbg("min_split_axis: %s, max_split_factor: %s", min_split_axis,
            max_split_factor)

    # 3、获取reduce stage采样的reduce轴的切分
    reduce_axis_len_list = [
        axis_len
        for axis_index, axis_len in enumerate(shape_before_reduce)
        if axis_index in reduce_axis_indexs
    ]
    reduce_axis_num = len(reduce_axis_len_list)
    reduce_split_axis = reduce_axis_num - 1
    reduce_split_factor = 1
    for axis_index in range(reduce_axis_num):
        if reduce_split_vector[axis_index] != 1:
            reduce_split_axis = axis_index
            reduce_split_factor = reduce_split_vector[axis_index]
            break
    log.dbg(
        "reduce_axis_len_list: %s, reduce_split_vector: %s, "
        "reduce_split_axis: %s, reduce_split_factor: %s", reduce_axis_len_list,
        reduce_split_vector, reduce_split_axis, reduce_split_factor)

    # 4、由于采样到的是reduce轴的切分，需要将采样结果按比例映射成普通轴的切分，
    # 按数据块占总切分范围的比例映射
    # reduce的数据块大小
    reduce_slice_len = reduce_split_factor
    if reduce_axis_len_list[reduce_split_axis + 1:]:
        reduce_slice_len *= functools_reduce(
            lambda x, y: x * y, reduce_axis_len_list[reduce_split_axis + 1:])
    # reduce轴的切分比例
    ratio = reduce_slice_len / reduce_size
    # reduce stage普通轴可切分的大小
    total_size = max_split_factor
    if axis_len_list[min_split_axis + 1:]:
        total_size *= functools_reduce(lambda x, y: x * y,
                                       axis_len_list[min_split_axis + 1:])
    # 普通轴切分后，块的大小
    slice_len = int(ratio * total_size) + 1
    log.dbg("slice_len: %s", slice_len)

    # 5、由切分后数据块的大小，反推切分轴和切分因子
    split_axis = axis_num - 1
    split_factor = 1
    size = total_size
    for axis_index in range(min_split_axis, axis_num):
        axis_len = axis_len_list[axis_index]
        if axis_index == min_split_axis:
            axis_len = max_split_factor
        size /= axis_len
        for factor in range(axis_len, 0, -1):
            if size * factor <= slice_len:
                size *= factor
                split_factor = factor
                break
        if size < slice_len:
            split_axis = axis_index
            break
    log.dbg("split_axis: %s, split_factor: %s", split_axis, split_factor)

    # 6、之前判断总的reduce是否超ub不是很严谨，全部处理，极端情况可能全部oom
    # 这里做一下特殊处理
    reduce_outer_len = 1 \
        if reduce_axis_len_list[reduce_split_axis] == reduce_split_factor \
        else reduce_axis_len_list[reduce_split_axis] - reduce_split_factor
    if reduce_axis_len_list[:reduce_split_axis]:
        reduce_outer_len *= functools_reduce(
            lambda x, y: x * y, reduce_axis_len_list[:reduce_split_axis])
    if reduce_outer_len > reduce_slice_len and not must_flag:
        log.dbg("reduce_slice_len: %s, reduce_outer_len: %s, "
                "no need clean", reduce_slice_len, reduce_outer_len)
        return

    # 7、获取split_vector
    split_vector = [0] * (ActionTensorCfg.split_factor_e + 1 -
                          ActionTensorCfg.split_factor_s)
    for axis_index, axis_len in enumerate(axis_len_list):
        if axis_index < split_axis:
            split_vector[axis_index] = 1
        elif axis_index == split_axis:
            split_vector[axis_index] = split_factor
        else:
            split_vector[axis_index] = axis_len
    log.dbg("split_vector: %s", split_vector)

    log.dbg(
        "reduce_axis_len_list: %s, reduce_split_axis: %s, "
        "reduce_split_factor: %s, ratio: %s, "
        "last_split_axis: %s, last_split_factor: %s, total_size: %s, "
        "slice_len: %s, "
        "min_split_axis: %s, max_split_factor: %s, split_axis: %s, "
        "split_factor: %s, split_vector: %s", reduce_axis_len_list,
        reduce_split_axis, reduce_split_factor, ratio, last_split_axis,
        last_split_factor, total_size, slice_len, min_split_axis,
        max_split_factor, split_axis, split_factor, split_vector)

    t2c_params.cleaned_actions[reduce_stage_index][
    split_vector_s:split_vector_e] = split_vector
    log.dbg("cleaned_action: %s",
            t2c_params.cleaned_actions[reduce_stage_index])


@timer('r10')
def proc(t2c_params): # pylint: disable=R0912,R0914,R0915,R0911
    """
    规则内容：若reduce_axis能整吃，就不切reduce_axis，切axis，将reduce_axis整吃
             由于是不通用的特殊处理，只对少量算子进行这种特殊处理
    """
    # 单输出
    if len(t2c_params.op_schedule_info.output_info_list) > 1:
        return

    # 只有一个reduce，没有broadcast
    reduce_cnt = 0
    reduce_tensor = None
    tensors = []
    for idx in range(t2c_params.schedule.outputs[0].num_outputs):
        tensors.append(t2c_params.schedule.outputs[0].output(idx))
    all_tensors = tensors[:]
    while tensors:
        new_tensors = []
        for tensor in tensors:
            if tensor.op.tag.find('reduce') >= 0:
                reduce_cnt += 1
                reduce_tensor = tensor
            if tensor.op.tag.find('broadcast') >= 0:
                return
            if not isinstance(tensor.op, tvm.PlaceholderOp):
                new_tensors.extend(tensor.op.input_tensors)
        tensors = list(set(new_tensors) - set(all_tensors))
        all_tensors.extend(tensors)
    if reduce_cnt != 1:
        return

    reduce_stage_index \
        = list(t2c_params.op_schedule_info.reduce_axis_dict.keys())[0]

    # reduce_last
    reduce_type = t2c_params.op_schedule_info.reduce_axis_dict[
        reduce_stage_index].get('type', None)
    if reduce_type != 'last':
        return

    # reduce_sum
    if reduce_tensor.op.tag.find('reduce_sum') == -1:
        return

    # reduce_all不行
    reduce_stage = t2c_params.schedule.stages[reduce_stage_index]
    shape_before_reduce = [
        i.value
        for i in reduce_stage.op.input_tensors[0].shape
    ]
    reduce_axis_indexs = t2c_params.op_schedule_info.reduce_axis_dict[
        reduce_stage_index].get('axis', [])
    if not reduce_axis_indexs \
            or len(reduce_axis_indexs) == len(shape_before_reduce):
        return

    # reduce轴总大小小于ub
    reduce_size = 1
    none_reduce_size = 1
    for axis_index, axis_len in enumerate(shape_before_reduce):
        if axis_index in reduce_axis_indexs:
            reduce_size *= axis_len
        else:
            none_reduce_size *= axis_len
    if reduce_size > UB_BUFFER_SIZE:
        return

    # reduce轴的大小比普通轴大很多

    split_none_reduce(t2c_params, shape_before_reduce, reduce_axis_indexs, reduce_size, reduce_stage_index)
    return
