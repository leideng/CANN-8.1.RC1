#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.tensor_to_code import t2c_util
from schedule_search.timer import timer


def _no_need_proc(stages_info, stage, stage_index, processed_stage_indices):
    """

    :param stages_info:
    :param stage:
    :param stage_index:
    :param processed_stage_indices:
    :return:
    """
    if str(stage.op).startswith("placeholder"):
        return True

    # 已经处理过的就不处理了
    if stage_index in processed_stage_indices:
        log.dbg('stage %d processed. ', stage_index)
        return True

    stage_info = stages_info[stage_index]

    if 'reduce' not in stage_info.get('type', []):
        log.dbg('stage %d is not reduce. ', stage_index)
        return True
    return False


def _get_split_reduce(t2c_params, stage_index, consecutive_reduce_list):
    """

    :param t2c_params:
    :param stage_index:
    :param consecutive_reduce_list:
    :return:
    """
    features = t2c_params.features
    ever_is_last = 0
    ever_axis = 0
    ever_factor_ratio = 0
    need_split_reduce = stage_index
    # 暂时不考虑一个Stage切多根轴的，所以只看第一个ReduceAxis
    for iter_index in consecutive_reduce_list:
        curr_axis = features[iter_index][
            FeatureTensorCfg.reduce_axis_s]
        factor = t2c_params.cleaned_actions[iter_index][
            ActionTensorCfg.split_factor_s]
        curr_factor_ratio = float(factor) / curr_axis
        compute_tag = t2c_params.op_schedule_info.op_intrin_key_index[
            features[iter_index][FeatureTensorCfg.compute_s]].op_tag
        curr_is_last = 1 if compute_tag.endswith(t2c_util.REDUCE_LAST_KEYWORD) else 0
        log.dbg(
            "stage_index: %s, curr_is_last: %d, ever_is_last: %d, "
            "curr_axis: %d, ever_axis: %d, "
            "curr_factor_ratio: %f, ever_factor_ratio: %f.",
            iter_index, curr_is_last, ever_is_last, curr_axis,
            ever_axis, curr_factor_ratio, ever_factor_ratio)
        if curr_is_last < ever_is_last:
            continue
        if curr_is_last == ever_is_last and curr_axis < ever_axis:
            continue
        if curr_is_last == ever_is_last \
                and curr_axis == ever_axis \
                and curr_factor_ratio <= ever_factor_ratio:
            continue
        ever_is_last = curr_is_last
        ever_factor_ratio = curr_factor_ratio
        ever_axis = curr_axis
        need_split_reduce = iter_index
    return need_split_reduce


@timer('r11')
def proc(t2c_params):  # pylint: disable=R0912,R0914,R0915
    """
    规则内容：如果有好几个连续的Reduce，就判断一下其中Factor/Axis最大的一个切，
    其余的不切
    # 具体切哪个Stage按如下三个判据：
    # 1，ReduceLast的永远比ReduceNlst优先
    # 2，1相同的前提下，轴长更长的优先
    # 3，1&2都相同的前提下，Factor/轴长更大的优先
    """
    # 输入
    sch = t2c_params.schedule
    stages_info = t2c_params.stages_info
    stages = list(sch.stages)
    tiling_case = t2c_params.op_schedule_info.tiling_case

    # WILLDO: reduce atomic暂时不处理
    if tiling_case > 0:
        return True

    # 每个叶子stage、叶子分叉stage
    processed_stage_indices = []
    for stage_index, stage in enumerate(stages):
        if _no_need_proc(stages_info,
                         stage, stage_index, processed_stage_indices):
            continue

        # 如果是Reduce，那就向下判断，有依赖且连续的Stage是不是Reduce
        consecutive_reduce_list = [stage_index]
        my_fanouts = t2c_params.op_schedule_info.real_fanin_dict[stage_index]
        # 分叉节点有两种情况：
        # 1 既是reduce又是workspace， workspace的fanout必然是1
        # 2 非workspace，后续多个如果都是reduce节点，
        # 非workspace不可能at到两个reduce节点，因此两个reduce不会split
        while len(my_fanouts) == 1:
            fanout = my_fanouts[0]
            is_reduce = 'reduce' in stages_info[fanout].get('type', [])
            if is_reduce:
                consecutive_reduce_list.append(fanout)
                my_fanouts = t2c_params.op_schedule_info.real_fanin_dict[
                    fanout]
            else:
                break

        log.dbg('consecutive_reduce_list: %s.', consecutive_reduce_list)

        # 记录一下，这一下子就全处理了，后面不用再次处理
        processed_stage_indices = consecutive_reduce_list[:]

        # 如果有好几个连续的Reduce，就判断一下其中Factor/Axis最大的一个切，其余的不切
        # 具体切哪个Stage按如下三个判据：
        # 1，ReduceLast的永远比ReduceNlst优先
        # 2，1相同的前提下，轴长更长的优先
        # 3，1&2都相同的前提下，Factor/轴长更大的优先
        if len(consecutive_reduce_list) > 1:
            need_split_reduce = _get_split_reduce(
                t2c_params, stage_index, consecutive_reduce_list)

            log.dbg('need_split_reduce: %d.', need_split_reduce)

            # 不需要切的Stage把Factor全置成0
            for iter_index in consecutive_reduce_list:
                if iter_index != need_split_reduce:
                    log.dbg('iter_index %d need clean.', iter_index)
                    split_s = ActionTensorCfg.split_factor_s
                    split_e = ActionTensorCfg.split_factor_e
                    t2c_params.cleaned_actions[iter_index][
                        split_s:split_e + 1] = [0] * (split_e + 1 - split_s)
                    t2c_params.cleaned_actions[iter_index][split_s] = 1
