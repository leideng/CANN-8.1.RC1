#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import json

from schedule_search import log
from schedule_search import comm as global_comm
from schedule_search import op_cfg
from schedule_search.timer import timer
from schedule_search.ts_env import env_util
from schedule_search.ts_env.tensor_to_code.proc_storage_align.rules import comm
from schedule_search.ts_env.tensor_to_code.proc_storage_align.rules \
    .align_for_reduce_atomic import proc as atomic_proc
from schedule_search.ts_env.tensor_to_code.proc_storage_align.rules \
    .align_for_transpose import proc as align_for_transpose_proc
from schedule_search.ts_env.tensor_to_code.proc_storage_align.rules \
    .align_for_strided_slice_d import proc as strided_slice_d_proc
from schedule_search.ts_env.cheque_generator import get_stage_index
from schedule_search.ts_env.cheque_generator import get_axis_index
from schedule_search.ts_env.cheque_generator import get_emit_insn_cheque
from tbe import tvm


def get_fanin_fanout_stages(stage_index, fanout_dict, fanin_dict, stages):
    """

    :param stage_index:
    :param fanout_dict:
    :param fanin_dict:
    :param stages:
    :return:
    """
    fanout_stage_index_list = fanout_dict[stage_index]
    fanout_stage_name_list = [
        stages[i].op.name
        for i in fanout_stage_index_list
    ]
    fanin_stage_index_list = fanin_dict[stage_index]
    fanin_stage_name_list = [stages[i].op.name for i in fanin_stage_index_list]

    fanout_list = [fanout_stage_name_list, fanout_stage_index_list]
    fanin_list = [fanin_stage_name_list, fanin_stage_index_list]
    return fanout_list, fanin_list


def update_broadcast_axis_map(stage_obj_i, stage_index_i, axis_map_i, tmp_axis_map_i):
    broadcast_axis_list_i = env_util.get_stage_broadcast_axis(stage_obj_i)
    log.dbg("%s %s %s", stage_obj_i.op.name, stage_obj_i.op.tag,
            broadcast_axis_list_i)
    if not broadcast_axis_list_i:
        if not stage_obj_i.op.input_tensors:
            src_axis_list = axis_map_i[stage_index_i]["global"]
        else:
            # [886] broadcast-> [1123, 886]这种场景
            src_axis_list = []
            output_shape = stage_obj_i.op.output(0).shape
            input_shape = [
                x.value
                for x in stage_obj_i.op.input_tensors[0].shape
            ]
            for i, output_shape_value in enumerate(output_shape):
                if output_shape_value.value not in input_shape:
                    continue
                src_axis_list.append(
                    axis_map_i[stage_index_i]["global"][i])
    else:
        src_axis_list = []
        for i, stage_axis in enumerate(list(stage_obj_i.op.axis)):
            axis_name = stage_axis.var.name
            # broadcast轴打上broadcast stage的名字，方便区分
            if i in broadcast_axis_list_i:
                axis_name = comm.gen_global_axis_name(
                    axis_name, stage_obj_i.op.name, stage_index_i)
            else:
                axis_name = tmp_axis_map_i.get(
                    axis_name,
                    comm.gen_global_axis_name(axis_name,
                                              stage_obj_i.op.name,
                                              stage_index_i))
            src_axis_list.append(axis_name)

    return src_axis_list

def get_axis_map(t2c_params):  # pylint: disable=R0914,R0915
    """

    :param t2c_params:
    :return:
    """
    def update_axis_map(  # pylint: disable=R0912,R0914,R0915
            stage_obj,
            visited_stages,
            axis_map,
            stage_index):
        """

        :param stage_obj:
        :param visited_stages:
        :param axis_map:
        :param stage_index:
        :return:
        """
        if stage_obj in visited_stages:
            return
        if isinstance(stage_obj.op, tvm.PlaceholderOp):
            return
        stage_name = stages_info[stage_index]["name"]
        tmp_axis_map = {}
        if stage_index in axis_map:
            # 这里建立reduce stage之前的stage的轴映射关系，如
            # ['k1', 'i0', 'i1', 'i2']和['i0', 'i1', 'i2', 'i3']的对应关系
            for i, stage_axis in enumerate(stage_obj.op.axis):
                tmp_axis_map[stage_axis.var.name] \
                    = axis_map[stage_index]["global"][i]
        else:
            local_axis_list = [
                stage_axis.var.name
                for stage_axis in stage_obj.op.axis
            ]
            global_axis_list = []
            for stage_axis in stage_obj.op.axis:
                global_axis_list.append(
                    comm.gen_global_axis_name(stage_axis.var.name,
                                              stage_obj.op.name, stage_index))

            fanout_list, fanin_list = get_fanin_fanout_stages(
                stage_index, fanout_dict, fanin_dict, stages)
            axis_map[stage_index] = {
                "local": local_axis_list,
                "global": global_axis_list,
                "stage_index": stage_index,
                "stage_name": stage_name,
                "fanouts": fanout_list,
                "fanins": fanin_list
            }

        op_body = stage_obj.op.body[0]
        if isinstance(op_body, tvm.tir.Reduce) and hasattr(
                op_body.source[0], "indices"):
            src_axis_list = []
            for i, stage_axis in enumerate(op_body.source[0].indices):
                if isinstance(stage_axis, tvm.tir.expr.BinaryOpExpr):
                    axis_name = stage_axis.a.name
                else:
                    axis_name = stage_axis.name
                # reduce轴打上reduce stage的名字，方便区分
                if axis_name.startswith("k"):
                    axis_name = comm.gen_global_axis_name(
                        axis_name, stage_obj.op.name, stage_index)
                axis_name = tmp_axis_map.get(axis_name, axis_name)
                src_axis_list.append(axis_name)
        elif "broadcast" in stage_obj.op.tag:
            src_axis_list = update_broadcast_axis_map(stage_obj, stage_index, axis_map, tmp_axis_map)
        else:
            src_axis_list = axis_map[stage_index]["global"]

        input_stage_index_list = fanin_dict[stage_index]
        for input_stage_index in input_stage_index_list:
            input_stage = stages[input_stage_index]
            if isinstance(input_stage.op, tvm.PlaceholderOp):
                curr_axis_list = []
            else:
                curr_axis_list = [
                    stage_axis.var.name
                    for stage_axis in input_stage.op.axis
                ]
                # [886] broadcast-> [1123, 886]，且broadcast被inline掉的场景
                if len(src_axis_list) != len(curr_axis_list):
                    new_src_axis_list = []
                    output_shape = stage_obj.op.output(0).shape
                    input_shape = [
                        x.value
                        for x in input_stage.op.output(0).shape
                    ]
                    for i, output_shape_value in enumerate(output_shape):
                        if output_shape_value.value not in input_shape:
                            continue
                        new_src_axis_list.append(src_axis_list[i])
                    src_axis_list = new_src_axis_list

            fanout_list, fanin_list = get_fanin_fanout_stages(
                input_stage_index, fanout_dict, fanin_dict, stages)
            axis_map[input_stage_index] = {
                "local": curr_axis_list,
                "global": src_axis_list,
                "stage_index": input_stage_index,
                "stage_name": stages_info[input_stage_index]["name"],
                "fanouts": fanout_list,
                "fanins": fanin_list
            }

    def visit_stage_proc(output_stages, visited_stages,
                         axis_map_by_stage_index):
        """

        :param output_stages:
        :param visited_stages:
        :param axis_map_by_stage_index:
        """
        new_stages = []
        for stage, stage_index in output_stages:
            update_axis_map(stage, visited_stages, axis_map_by_stage_index,
                            stage_index)
            input_stage_index_list = fanin_dict[stage_index]
            for input_stage_index in input_stage_index_list:
                if stages[input_stage_index] in visited_stages:
                    continue
                update_axis_map(stages[input_stage_index], visited_stages,
                                axis_map_by_stage_index, input_stage_index)
                visited_stages.append(stages[input_stage_index])
                new_stages.append(
                    (stages[input_stage_index], input_stage_index))

        if new_stages:
            visit_stage_proc(new_stages, visited_stages,
                             axis_map_by_stage_index)

    def get_alias_dict(tuple_reduce_dict):  # pylint: disable=R0912
        """

        :return:
        """
        alias_dict = {}
        # 从上往下，发现fanout有多个就记录下轴的对应关系
        for stage_index, stage_info in enumerate(stages_info):
            fanout_stage_index_list = fanout_dict[stage_index]
            if len(fanout_stage_index_list) == 1 or stage_index not in \
                    axis_map_by_stage_index:
                continue
            curr_global_list = axis_map_by_stage_index.get(stage_index)["global"]
            # 针对tuple_reduce的处理，建立a与a.v0和a.v1的align关系
            for curr_global in curr_global_list:
                axis, stage_name, stage_index = comm.parse_global_axis_name(
                    curr_global)
                for tuple_stage_name in tuple_reduce_dict.get(stage_name, []):
                    tuple_global_axis = comm.gen_global_axis_name(
                        axis, tuple_stage_name, stage_index)
                    alias_dict.setdefault(curr_global,
                                          []).append(tuple_global_axis)
                    alias_dict.setdefault(tuple_global_axis,
                                          []).append(curr_global)

            for fanout_stage_index in fanout_stage_index_list:
                if fanout_stage_index not in axis_map_by_stage_index:
                    continue
                fanout_global_list \
                    = axis_map_by_stage_index[fanout_stage_index]["global"]
                if len(fanout_global_list) != len(curr_global_list):
                    log.warn("stage: %s and fanout: %s shape not equal!",
                             stage_info["name"], fanout_stage_index)
                    continue
                for i, fanout_global_axis in enumerate(fanout_global_list):
                    if fanout_global_axis == curr_global_list[i]:
                        continue
                    alias_dict.setdefault(curr_global_list[i],
                                          []).append(fanout_global_axis)
                    alias_dict.setdefault(fanout_global_axis,
                                          []).append(curr_global_list[i])
        log.dbg("alias_dict: %s", alias_dict)
        return alias_dict

    stages_info = t2c_params.stages_info
    sch_obj = t2c_params.schedule
    stages = sch_obj.stages
    output_stage = []
    fanin_dict = t2c_params.op_schedule_info.real_fanin_dict
    fanout_dict = t2c_params.op_schedule_info.real_fanout_dict
    tuple_reduce_dict = {}
    for stage_index, stage_info in enumerate(stages_info):
        stage_type = stages_info[stage_index].get('type', [])
        log.dbg("%s %s", stages[stage_index].op.name,
                stage_info.get("type", []))
        if {'leaf', 'origin_leaf_out'}.intersection(set(stage_type)) \
                and "virtual_leaf_out" not in stage_type:
            output_stage.append((stages[stage_index], stage_index))
        for idx in range(stages[stage_index].op.num_outputs):
            tuple_reduce_dict.setdefault(
                stages[stage_index].op.name,
                []).append(stages[stage_index].op.output(idx).name)

    visited_stages = []
    axis_map_by_stage_index = {}
    axis_map_by_op_name = {}
    visit_stage_proc(output_stage, visited_stages, axis_map_by_stage_index)
    # 最后再来一遍对齐global的处理
    alias_dict = get_alias_dict(tuple_reduce_dict)
    for stage_index, axis_map_info in axis_map_by_stage_index.items():
        axis_map_by_op_name.setdefault(stages[stage_index].op.name,
                                       []).append(axis_map_info)
    log.dbg("axis_map: %s", json.dumps(axis_map_by_op_name, indent=4))
    return axis_map_by_op_name, axis_map_by_stage_index, alias_dict


def update_final_align_dict(final_align_dict, stage_index, stage_name,
                            final_align_axis, stage_obj):
    """

    :param final_align_dict:
    :param stage_index:
    :param stage_name:
    :param final_align_axis:
    :param stage_obj:
    """
    if comm.is_reduce_axis(stage_obj, final_align_axis):
        axis_type = "reduce"
    elif comm.is_broadcast_axis(stage_obj, final_align_axis):
        axis_type = "broadcast"
    else:
        axis_type = "comm"

    init_dict = {
        "comm": "",
        "broadcast": "",
        "reduce": "",
        "stage_name": stage_name
    }
    if stage_index not in final_align_dict:
        final_align_dict.setdefault(stage_index, init_dict)[axis_type] \
            = final_align_axis
    # "i2.c" > "i1.c" True
    elif final_align_dict[stage_index].get(axis_type, "") and \
            final_align_dict[stage_index][axis_type] > final_align_axis:
        pass
    else:
        final_align_dict[stage_index][axis_type] = final_align_axis

    log.dbg("stage:%s %s need_align_axis:%s final_align_axis:%s", stage_index,
            stage_name, final_align_axis,
            final_align_dict[stage_index][axis_type])


def get_stage_index_by_expr(stage_dict, expr_info, t2c_params):
    """

    :param stage_dict:
    :param expr_info:
    :param t2c_params:
    :return:
    """
    dst_stage_name = expr_info["dst"][0]["stage_name"]
    stage_index_list = stage_dict.get(dst_stage_name, [])
    if not stage_index_list:
        log.warn("expr: %s not found in stage!", expr_info["expr"])
        return None

    stages = t2c_params.schedule.stages
    fanin_dict = t2c_params.op_schedule_info.real_fanin_dict
    fanout_dict = t2c_params.op_schedule_info.real_fanout_dict
    if len(stage_index_list) == 1 or not expr_info["src"]:
        stage_index = stage_index_list[0]
        _, fanin_list = get_fanin_fanout_stages(stage_index, fanout_dict,
                                                fanin_dict, stages)
        return [(stage_index, fanin_list)]

    # 对于stage.op.name重复的stage，则需要根据表达式去判断了，只看fanin
    matched_stage_index_list = []
    for stage_index in stage_index_list:
        _, fanin_list = get_fanin_fanout_stages(stage_index, fanout_dict,
                                                fanin_dict, stages)
        name_fanins, _ = fanin_list
        src_stage_list = [
            src_expr["stage_name"]
            for src_expr in expr_info["src"]
        ]
        if len(set(src_stage_list).intersection(
                set(name_fanins))) == len(name_fanins):
            matched_stage_index_list.append((stage_index, fanin_list))
    if not matched_stage_index_list:
        log.warn("no matched stage_index of %s!", dst_stage_name)
        return None
    if len(matched_stage_index_list) > 1:
        log.dbg("matched stage_index of %s: %s more than 1!", dst_stage_name,
                matched_stage_index_list)

    return matched_stage_index_list


def emit_insn_proc(  # pylint: disable=R0914,R0912
        t2c_params,
        stage_index,
        stage,
        expr_stage_dict,
        align_axis_index=None):
    """

    :param t2c_params:
    :param stage_index:
    :param stage:
    :param expr_stage_dict:
    :param align_axis_index:
    :return:
    """
    emit_insn_code_dict = t2c_params.op_schedule_info.emit_insn_code_dict
    if stage_index not in emit_insn_code_dict:
        return

    intrinsic_func_name = emit_insn_code_dict[stage_index]["intrin"]
    stage_name = emit_insn_code_dict[stage_index]["stage_name"]
    if align_axis_index is None:
        tsrz_line = emit_insn_code_dict[stage_index]["code"]
        emit_insn_axis_obj = emit_insn_code_dict[stage_index]["axis_obj"]
        align_axis_index = emit_insn_code_dict[stage_index]["axis_index"]
    else:
        # 有些情况做了storage align和不做没有区别，不影响数据连续性
        if stage_index in expr_stage_dict and align_axis_index > 0:
            stride_dict = expr_stage_dict[stage_index]["dst"][0]['stride_dict']
            vector_block_num = env_util.get_block_num(stage.op.output(0).dtype)
            align_axis_var = str(stage.op.axis[align_axis_index - 1].var.name)
            if align_axis_var in stride_dict:
                stride = stride_dict[align_axis_var]
                if stride % vector_block_num == 0:
                    align_axis_index = 0
                    log.dbg(
                        "stride_dict: %s, align_axis_var: %s no "
                        "need move axis", stride_dict, align_axis_var)
        emit_insn_axis = "sch[%s].op.axis[%s]" % (stage_name, align_axis_index)
        tsrz_line = "sch[%s].emit_insn(%s, '%s')" % (
            stage_name, emit_insn_axis, intrinsic_func_name)
        emit_insn_axis_obj = stage.op.axis[align_axis_index]
    # 生成emit_insn对应的cheque
    if 'emit_insn' in tsrz_line:
        _, after_emit_insn = tsrz_line.split(".emit_insn(", 1)
        emit_insn_axis = after_emit_insn.split(",")[0]
        insn_name = tsrz_line.split("'")[1]
        get_emit_insn_cheque(t2c_params, stage_index, insn_name,
                             (emit_insn_axis, align_axis_index))
        stage.emit_insn(emit_insn_axis_obj, intrinsic_func_name)
    t2c_params.code_lines.append(tsrz_line)

    return


def final_align_check(  # pylint: disable=R0912
        expr_dict_list,
        final_align_dict,
        all_stages,
        same_name_stage_index_list,
        op_name):
    """

    :param expr_dict_list:
    :param final_align_dict:
    :param all_stages:
    :param same_name_stage_index_list:
    :param op_name:
    :return:
    """
    def update_final_update_dict(  # pylint: disable=R0912
            fanin_list,
            stage_name,
            curr_axis):
        """

        :param fanin_list:
        :param stage_name:
        :param curr_axis:
        :return:
        """
        for fanin_index in fanin_list[1]:
            stage = all_stages[fanin_index]
            if stage.op.name != stage_name:
                continue
            upper_axis = final_align_dict.get(fanin_index, "")
            if curr_axis.split(".")[0] <= upper_axis.split(".")[0]:
                return
            axis_index = int(curr_axis.split(".")[0][-1])
            if axis_index + 1 >= len(stage.op.axis):
                return
            final_align_dict[fanin_index] = str(stage.op.axis[axis_index +
                                                              1].var.name)
            final_update_dict[fanin_index] = axis_index
            for same_name_stages in same_name_stage_index_list:
                if fanin_index in same_name_stages:
                    for same_name_stage_index in same_name_stages:
                        final_update_dict[same_name_stage_index] = axis_index
            return

    def dma_align_proc(expr_dict):
        """

        :param expr_dict:
        :return:
        """
        if op_name not in ["cosine_embedding_loss"]:
            return
        if expr_dict["expr_type"] == "dma_copy":
            dst_axis_list = expr_dict["expr_info"]["dst"][0]["axis_var_list"]
            if len(dst_axis_list) != 1:
                return
            src_axis_list = expr_dict["expr_info"]["src"][0]["axis_var_list"]
            if len(src_axis_list) > 1 and dst_axis_list[0] in src_axis_list:
                stage_index = expr_dict["stage_index"]
                upper_axis = final_align_dict.get(stage_index, "")
                axis_index = int(upper_axis.split(".")[0][-1])
                if axis_index + 1 >= len(all_stages[stage_index].op.axis):
                    return
                log.dbg("expr: %s need dma align proc",
                        expr_dict["expr_info"]["expr"])
                final_update_dict[stage_index] = axis_index
        return

    final_update_dict = {}
    for expr_dict in expr_dict_list:
        expr_info = expr_dict["expr_info"]
        fanin_list = expr_dict["fanin_list"]
        dma_align_proc(expr_dict)
        if expr_info["shape"] != [1]:
            continue
        for expr_buffer_dict in expr_info["src"]:
            stage_name = expr_buffer_dict["stage_name"]
            if not stage_name.endswith(".local.UB"):
                continue
            axis_var_list = expr_buffer_dict["axis_var_list"]
            if not axis_var_list:
                continue
            if axis_var_list[-1] not in expr_buffer_dict["stride_dict"]:
                continue
            if expr_buffer_dict["stride_dict"][axis_var_list[-1]] != 1:
                continue
            curr_axis = axis_var_list[-1]
            update_final_update_dict(fanin_list, stage_name, curr_axis)
    return final_update_dict


def pre_do_align(t2c_params, need_align_stages, final_align_dict,
                 expr_stage_dict, final_update_dict):
    """

    :param t2c_params:
    :param need_align_stages:
    :param final_align_dict:
    :param expr_stage_dict:
    :param final_update_dict:
    :return:
    """
    do_align_dict = {}
    for stage_index, _ in need_align_stages.items():
        stage_obj = t2c_params.schedule.stages[stage_index]
        if stage_index not in final_align_dict:
            emit_insn_proc(t2c_params, stage_index, stage_obj, expr_stage_dict)
            continue
        # 对某根轴对齐，是通过对它前一根轴做stora_align实现
        # 生成代码字符串
        final_align_axis = final_align_dict[stage_index]
        # 没有对齐要求，不做align
        if not final_align_axis:
            emit_insn_proc(t2c_params, stage_index, stage_obj, expr_stage_dict)
            continue
        # reduce轴是给别人对齐global用的，自己不需要对齐
        if comm.is_reduce_axis(stage_obj, final_align_axis):
            align_axis_index = -1
            emit_insn_proc(t2c_params, stage_index, stage_obj, expr_stage_dict)
        else:
            align_axis_index = comm.axis_index_in_stage(
                stage_obj, final_align_dict[stage_index])
            emit_insn_proc(t2c_params, stage_index, stage_obj, expr_stage_dict,
                           align_axis_index)
            align_axis_index -= 1
        do_align_dict[stage_index] = align_axis_index

    for stage_index in final_update_dict:
        do_align_dict[stage_index] = final_update_dict[stage_index]

    return do_align_dict


def do_align(t2c_params, do_align_dict):
    """

    :param t2c_params:
    :param do_align_dict:
    :return:
    """
    # do_align
    t2c_params.code_lines.extend(['\n', '# storage_align code'])
    code_lines = []
    for stage_index, axis_index in do_align_dict.items():
        stage = t2c_params.schedule.stages[stage_index]
        stage_name = t2c_params.stages_info[stage_index]["name"]
        sub_code = comm.align_a_stage(stage, stage_name, axis_index,
                                      t2c_params, stage_index)
        code_lines.extend(sub_code)

    t2c_params.code_lines.extend(code_lines)


@timer('storage_align')
def proc(t2c_params, rules):  # pylint: disable=R0912,R0914,R0915
    """
    主要输入是schedule对象、Mode、rules和inlined_stages
    主要输出是storage_align代码或操作
    """
    # gemm带有两根16规格轴，不做storage_align
    if t2c_params.op_schedule_info.c_op in global_comm.MAD_OP_ID_LIST:
        return True

    tiling_case = t2c_params.op_schedule_info.tiling_case
    # atomic还走老流程
    atomic_ret_flag = tiling_case > 0 and \
                      t2c_params.op_schedule_info.op_name not in \
                      ["cosine_embedding_loss", "gn_training_reduce"]
    if atomic_ret_flag:
        atomic_proc(t2c_params)
        return True

    transpose_ret_flag = t2c_params.op_schedule_info.option.get('op_type') in op_cfg.TIK_TO_DSL_OP_LIST.keys() and \
                         align_for_transpose_proc(t2c_params)
    if transpose_ret_flag:
        return True

    ret = strided_slice_d_proc(t2c_params)
    if ret:
        return True

    axis_life_dict, axis_map_by_stage_index, alias_dict \
        = get_axis_map(t2c_params)
    log.dbg("axis_life_dict=%s\naxis_map_by_stage_index=%s\nalias_dict=%s\n",
            axis_life_dict, axis_map_by_stage_index, alias_dict)
    # 根据sch对象通过pre_build，获取并解析stmt信息
    expr_info_dict = comm.get_expr_info_dict(t2c_params)
    all_stages = t2c_params.schedule.stages
    need_align_stages = {}
    stage_dict = {}
    align_tensor_list = []
    for stage_index, stage in enumerate(all_stages):
        for idx in range(stage.op.num_outputs):
            align_tensor_list.append(stage.op.output(idx).name)
            stage_dict.setdefault(stage.op.output(idx).name,
                                  []).append(stage_index)

        # Placeholder不需要做align
        if isinstance(stage.op, tvm.PlaceholderOp):
            continue
        # inline的stage不做storage_align
        if stage_index in t2c_params.inlined_stages:
            continue
        gm_type_set = {
            'origin_leaf_out', 'inter_out', 'workspace', 'virtual_leaf_out'
        }
        # 涉及ub to gm的不做storage align
        if gm_type_set.intersection(
                set(t2c_params.stages_info[stage_index].get('type', []))):
            continue
        need_align_stages[stage_index] = stage.op.name
    log.dbg("stage_dict: %s", stage_dict)

    update_align_dict = {}
    expr_stage_dict = {}
    same_name_stage_index_list = []
    total_exprs = []
    for tensor_name in sorted(expr_info_dict):
        for expr_info in expr_info_dict[tensor_name]:
            # WILLDO: broadcast_enhance加上storage_align会报错，
            # 暂时不进行storage_align
            if expr_info["intrin"].endswith("_broadcast_enhance"):
                code_lines = []
                for val in t2c_params.op_schedule_info.emit_insn_code_dict \
                        .values():
                    tsrz_line = val["code"]
                    code_lines.append(tsrz_line)
                    # 生成emit_insn对应的cheque
                    if 'emit_insn' in tsrz_line:
                        before_emit, after_emit = tsrz_line.split(
                            ".emit_insn(", 1)
                        stage_name = before_emit.split("[")[1].split("]")[0]
                        emit_insn_axis = after_emit.split(",")[0]
                        insn_name = tsrz_line.split("'")[1]
                        stage_index = get_stage_index(t2c_params.stages_info,
                                                      stage_name)
                        axis_index = get_axis_index(
                            t2c_params.axis_info_list[stage_index],
                            emit_insn_axis)
                        get_emit_insn_cheque(t2c_params, stage_index,
                                             insn_name,
                                             (emit_insn_axis, axis_index))

                t2c_params.code_lines.extend(code_lines)
                return True
            if not expr_info["emit_insn_axis_list"]:
                continue
            expr_type = comm.get_stage_expr_type(expr_info)
            expr_dst_stage_idx = get_stage_index_by_expr(
                stage_dict, expr_info, t2c_params)
            if not expr_dst_stage_idx:
                continue
            if len(expr_dst_stage_idx) > 1:
                same_name_stage_index_list.append(
                    [x[0] for x in expr_dst_stage_idx])
            stage_index, fanin_list = expr_dst_stage_idx[0]

            if stage_index is None:
                log.warn("stage_index of expr_info: %s query failed!",
                         expr_info)
                continue
            expr_stage_dict[stage_index] = expr_info
            log.dbg("stage_index: %s, stage:%s expr_type:%s expr_info:%s",
                    stage_index, tensor_name, expr_type, expr_info)
            if expr_info["ori_emit_insn_axis"].startswith("k"):
                align_axis = expr_info["emit_insn_axis_list"][0]
            else:
                align_axis = expr_info["ori_emit_insn_axis"]
            # 先更新emit_insn轴到update字典中
            update_align_dict.setdefault(stage_index, []).append({
                "tensor_name":
                tensor_name,
                "stage_index":
                stage_index,
                "axis_var":
                align_axis,
            })
            input_dict = {
                "expr_type": expr_type,
                "expr_info": expr_info,
                "align_stage_list": align_tensor_list,
                "stage_index": stage_index,
                "fanin_list": fanin_list,
            }
            for rule in rules:
                module = __import__(rule, fromlist=['1'])
                output_dict = {"update_align_dict": update_align_dict}
                module.proc(input_dict, output_dict)
            total_exprs.append(input_dict)

    log.dbg("update_align_dict:%s", update_align_dict)
    # 汇总所有tensor对自己的对齐要求，选择最内层轴
    pre_final_align_dict = {}
    for stage_index, stage_name in need_align_stages.items():
        if not update_align_dict.get(stage_index, []):
            continue
        # 如果别人对自己有对齐要求, 对齐要求是个list of dict
        for need_align_info in update_align_dict.get(stage_index):
            need_align_axis = need_align_info["axis_var"]
            src_stage_index = need_align_info["stage_index"]
            src_tensor_name = need_align_info["tensor_name"]
            # 对齐轴在自己stage的名字
            log.dbg("stage_name:%s need_align_info:%s", stage_name,
                    need_align_info)
            need_align_axis = comm.get_dst_axis_name(
                src_stage_index, src_tensor_name, need_align_axis, stage_index,
                axis_map_by_stage_index, alias_dict, all_stages[stage_index])
            # 如果是比最终对齐轴更靠内层，则更新
            if need_align_axis:
                update_final_align_dict(pre_final_align_dict, stage_index,
                                        stage_name, need_align_axis,
                                        all_stages[stage_index])

    log.dbg("pre_final_align_dict:%s", pre_final_align_dict)

    # 把所有对齐轴统一拉齐到global轴上，每一个global stage有一个对齐轴
    global_align_dict = {}
    for stage_index, stage_name in need_align_stages.items():
        if stage_index not in pre_final_align_dict:
            continue
        global_stage_axis = ""
        local_comm_axis = pre_final_align_dict[stage_index]["comm"]
        if local_comm_axis:
            global_stage_axis = comm.get_global_axis(local_comm_axis,
                                                     stage_index,
                                                     axis_map_by_stage_index)
            global_axis_name, _, global_index = global_stage_axis.split("@")
            global_align_dict.setdefault(int(global_index),
                                         []).append(global_axis_name)

        # 如果有reduce对齐轴，肯定是global
        local_reduce_axis = pre_final_align_dict[stage_index]["reduce"]
        if local_reduce_axis:
            global_align_dict.setdefault(stage_index,
                                         []).append(local_reduce_axis)
            global_stage_axis = comm.gen_global_axis_name(
                local_reduce_axis, stage_name, stage_index)

        # 如果有broadcast对齐轴，肯定是global
        local_broadcast_axis = pre_final_align_dict[stage_index]["broadcast"]
        if local_broadcast_axis:
            global_align_dict.setdefault(stage_index,
                                         []).append(local_broadcast_axis)
            global_stage_axis = comm.gen_global_axis_name(
                local_reduce_axis, stage_name, stage_index)

        if global_stage_axis in alias_dict:
            for alias_stage_axis in alias_dict[global_stage_axis]:
                stage_axis_name, _, stage_index = alias_stage_axis.split("@")
                global_align_dict.setdefault(int(stage_index),
                                             []).append(stage_axis_name)
    log.dbg("global_align_dict:%s", global_align_dict)

    # 选择每个global_stage的最内层轴作为global的对齐轴
    for stage_index in sorted(global_align_dict):
        global_align_dict[stage_index] = max(global_align_dict.get(stage_index))

    log.dbg("global_align_dict after max: %s", global_align_dict)

    # reduce对齐轴是给别人找global对齐轴
    # 自己只看普通轴，需要对应到自己stage轴的名字
    final_align_dict = {}
    for stage_index, stage_name in need_align_stages.items():
        if stage_index not in pre_final_align_dict:
            continue
        curr_align_axis = pre_final_align_dict[stage_index]["comm"]
        if stage_index in final_align_dict:
            if curr_align_axis > final_align_dict[stage_index]:
                final_align_dict[stage_index] = curr_align_axis
        else:
            final_align_dict[stage_index] = curr_align_axis
        axis_info = axis_map_by_stage_index.get(stage_index)
        for global_stage_index in sorted(global_align_dict):
            global_stage = all_stages[global_stage_index].op.name
            global_axis = comm.gen_global_axis_name(
                global_align_dict.get(global_stage_index), global_stage,
                global_stage_index)
            # broadcast轴只要求自己 不要求别人
            if "broadcast" in global_stage:
                continue
            if global_axis in axis_info["global"]:
                global_axis_index = axis_info["global"].index(global_axis)
                local_axis = axis_info["local"][global_axis_index]
                log.dbg(
                    "stage:%s curr_align_axis:%s local_axis:%s "
                    "from global_stage:%s axis:%s", stage_name,
                    curr_align_axis, local_axis, global_stage,
                    global_align_dict.get(global_stage_index))
                if local_axis > final_align_dict.get(stage_index):
                    final_align_dict[stage_index] = local_axis

        # stage_name 一样但stage_index不一样，这里简单处理，align到相同的轴上
        log.dbg("same_name_stage_index_list:%s", same_name_stage_index_list)
        for same_name_stages in same_name_stage_index_list:
            if stage_index in same_name_stages:
                for same_name_stage_index in same_name_stages:
                    final_align_dict[same_name_stage_index] \
                        = final_align_dict.get(stage_index)
                    log.dbg(
                        "stage_name:%s stage_index:%s same to %s align "
                        "to axis:%s", stage_name, same_name_stage_index,
                        stage_index, final_align_dict.get(stage_index))

        log.dbg("stage:%s final_align_axis:%s", stage_name,
                final_align_dict.get(stage_index))
    log.dbg("final_align_dict:%s", final_align_dict)
    final_update_dict = final_align_check(total_exprs, final_align_dict,
                                          all_stages,
                                          same_name_stage_index_list,
                                          t2c_params.op_schedule_info.op_name)
    log.dbg("final_update_dict:%s", final_update_dict)

    do_align_dict = pre_do_align(t2c_params, need_align_stages,
                                 final_align_dict, expr_stage_dict,
                                 final_update_dict)
    do_align(t2c_params, do_align_dict)
    log.dbg('proc storage_align ok')
    return True
