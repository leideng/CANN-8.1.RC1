#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search import comm
from schedule_search.ts_env.tensor_cfg import INVALID_AT_AXIS
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_to_code.proc_at.rules.comm import \
    refine_a_stage
from schedule_search import op_cfg
import schedule_search.ts_env.tensor_to_code.t2c_util as t2c_util
from schedule_search.ts_env.tensor_to_code.proc_at.rules.\
    r04_refine_at_structure import _split_once
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.tensor_cfg import AxisInfo
from schedule_search.ts_env.cheque_generator import get_split_cheque
from schedule_search.retry_proc import add_retry_option


def l0c2ub_split_retry_proc(t2c_params, stage_index, n_axis_index):
    '''
    l0c2ub切分因子retry
    '''
    ori_factor = t2c_params.cleaned_actions[stage_index][n_axis_index +
                                                         t2c_util.max_axis()]
    if ori_factor == 1:
        return 0
    l0c2ub_factor_name = "l0c2ub_factor_%s" % stage_index
    retry_options = [{l0c2ub_factor_name: False}]
    factor_option_list = []
    # 只取整除的factor
    for i in range(1, ori_factor, 1):
        if ori_factor % i == 0:
            factor_option_list.append(i)
    for factor in factor_option_list:
        retry_options.append({l0c2ub_factor_name: factor})
    add_retry_option(t2c_params.retry_t2c_rules,
                     "l0c2ub_split_%s" % stage_index, retry_options)
    l0c2ub_factor = t2c_params.op_schedule_info.option.get(
        l0c2ub_factor_name, 0)
    return l0c2ub_factor


def split_l0c_n_axis(t2c_params):    # pylint: disable=R0914
    '''
    针对l0c的n轴的切分
    '''
    if t2c_params.op_schedule_info.op_name in op_cfg.RNN_OP_LIST:
        return

    for stage_index, stage_info in enumerate(t2c_params.stages_info):
        stage_type = stage_info.get("type", [])
        if not {"leaf", "l1fuse_leaf"} & set(stage_type):
            continue
        stage_axis_infos = t2c_params.axis_info_list[stage_index]
        axis_index = None
        n_axis_index, _ = t2c_util.get_nm_axis_index(
            t2c_params.op_schedule_info)
        for i, curr_axis_info in enumerate(stage_axis_infos):
            # 找到最内侧的n轴
            if curr_axis_info.index == n_axis_index:
                axis_index = i

        axis_info = stage_axis_infos[axis_index]
        stage_name = stage_info['name']
        stage = t2c_params.schedule.stages[stage_index]
        axis_o = "%so" % axis_info.name
        axis_i = "%si" % axis_info.name
        factor = l0c2ub_split_retry_proc(t2c_params, stage_index, n_axis_index)
        if factor == 0:
            continue
        t2c_params.code_lines.append(
            '%s, %s = sch[%s].split(%s, factor=%d)' %
            (axis_o, axis_i, stage_name, axis_info.name, factor))
        axis_obj_o, axis_obj_i = None, None
        if t2c_params.mode == MODE_RUNTIME:
            axis_obj_o, axis_obj_i = stage.split(axis_info.body, factor)

        del stage_axis_infos[axis_index]
        stage_axis_infos.insert(
            axis_index,
            AxisInfo(axis_i, factor, 'axis', axis_info.index,
                     f"{axis_info.attr}i", axis_obj_i))
        stage_axis_infos.insert(
            axis_index,
            AxisInfo(axis_o, axis_info.len // factor, 'axis', axis_info.index,
                     "l0c_o", axis_obj_o))

        # 生成split_nparts对应的cheque
        get_split_cheque(t2c_params, stage_index, axis_index, factor)


def split_for_redundancy(t2c_params):
    """
    对最后一个stage的最内层oo轴再做一次npart切分，避免冗余搬移
    """
    stage_index = len(t2c_params.schedule.stages) - 1
    axis_index = None
    axis_info = None
    last_stage_axis_infos = t2c_params.axis_info_list[stage_index]
    has_batch, _ = t2c_util.gemm_identify(t2c_params.op_schedule_info)
    for i, curr_axis_info in enumerate(last_stage_axis_infos):
        # 找到最内侧的oo轴
        if (has_batch
                and curr_axis_info.index == 0) or curr_axis_info.attr == 'oo':
            axis_index = i
            axis_info = curr_axis_info

    if axis_info is None:
        return

    _split_once(t2c_params, stage_index, axis_index, axis_info.name,
                axis_info.len, t2c_util.COMMON_AT_POSTFIX,
                t2c_util.MULTICORE_POSTFIX, oo_type=True)


def proc(t2c_params):  # pylint: disable=R0912
    """
    规则内容：获取每个stage的at到的axis，存入at_targets
    """
    sch = t2c_params.schedule
    c_op = t2c_params.op_schedule_info.c_op
    if c_op not in comm.MAD_OP_ID_LIST:
        return False

    features = t2c_params.features
    axis_info_list = t2c_params.axis_info_list
    stages_info = t2c_params.op_schedule_info.stages_info
    stage_num = len(features)
    at_choices = []
    for _ in range(stage_num):
        at_choices.append([])

    split_l0c_n_axis(t2c_params)
    split_for_redundancy(t2c_params)
    # 从下往上推导at的关系
    at_targets = [None] * stage_num
    reversed_stages = list(sch.stages)
    reversed_stages.reverse()

    for reverse_index, _ in enumerate(reversed_stages):
        stage_index = stage_num - reverse_index - 1
        stages_type = stages_info[stage_index].get('type', [])
        if 'placeholder' in stages_type:
            continue

        # 该stage已经Inline掉了
        if stage_index in t2c_params.inlined_stages:
            continue

        if reverse_index == 0:
            # 所有_o, _io都是可at的目标
            at_choices[stage_index] = []
            at_choices[stage_index] += [
                axis
                for axis in axis_info_list[stage_index]
                if axis.attr in ["o", "io", "l0c_o"]
            ]
            t2c_params.cleaned_actions[stage_index][
                ActionTensorCfg.at_s] = INVALID_AT_AXIS
            at_targets[stage_index] = None
            continue

        refine_a_stage(stage_index, at_choices, at_targets, t2c_params)

    t2c_params.at_targets = at_targets
    log.dbg('gemm at done')
    return True
