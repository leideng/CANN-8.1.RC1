#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search import comm
from schedule_search.ts_env.tensor_cfg import INVALID_AT_AXIS
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_to_code import t2c_util
from schedule_search import op_cfg
from schedule_search.retry_proc import add_retry_option


def get_at_choices(  # pylint: disable=R0912
        stage_index, at_choices, child_stages, t2c_params):
    """
    取前面公共的目标
    """
    if len(child_stages) == 1:
        my_choices = at_choices[child_stages[0]][:]
        return my_choices

    # 从前向后，在第0个子节点中，且在其他子节点中的，就收之
    my_choices = []
    at_dict = t2c_params.op_schedule_info.at_dict
    at_target = at_dict[stage_index]
    child_index = child_stages[0]
    # 分叉节点取和自己at_target一样的节点
    if len(child_stages) > 1:
        for child_stage in child_stages:
            if at_target == at_dict[child_stage]:
                child_index = child_stage
                break
    for choice in at_choices[child_index]:
        all_child_have_curr_choice = True
        for child_stage in child_stages[1:]:
            if choice not in at_choices[child_stage]:
                all_child_have_curr_choice = False
                break
        if not all_child_have_curr_choice:
            break
        my_choices.append(choice)
    return my_choices


def no_cut_l1_k_clean(t2c_params, stage_index, my_at_choices, clean_at):
    '''
    没有切大K时，L1的stage需要at到普通o轴上
    '''
    stage = t2c_params.schedule.stages[stage_index]
    if ".local.L1" not in stage.op.name:
        return clean_at

    if comm.is_cut_l1_k(t2c_params, stage_index):
        return clean_at

    for i in range(len(my_at_choices) - 1, -1, -1):
        at_choice = my_at_choices[i]
        if at_choice and at_choice.type == "axis" and at_choice.attr in ["o"]:
            clean_at = i
            return clean_at

    return clean_at


def at_clean_rule_proc(stage_index,  # pylint: disable=R0912,R0914,R0915
                       my_at_choices, t2c_params):
    """
    从my_at_choices选择一个at
    """
    def _clean_l0_at(clean_at):
        '''
        L0不允许多搬数据，固定at到小k，即最内的reduce轴
        '''
        for idx in range(len(my_at_choices) - 1, -1, -1):
            if my_at_choices[idx].type == "reduce_axis":
                clean_at = idx
                break
        return clean_at

    def _clean_quant_params_at(clean_at):
        # conv中量化涉及的broadcast轴at到多核轴上
        fanins = t2c_params.op_schedule_info.fanin_dict[stage_index]
        stages_info = t2c_params.op_schedule_info.stages_info
        fanouts = t2c_params.op_schedule_info.fanout_dict[stage_index]
        if fanins and fanouts and "placeholder" in stages_info[
                fanins[0]].get("type", []) and t2c_params.schedule.stages[
                    fanouts[0]].op.tag in t2c_util.QUANT_CAST_TAGS:
            return 0
        return clean_at

    def _clean_l0c2ub_at(clean_at):
        if my_at_choices[clean_at] is None:
            return clean_at

        if my_at_choices[clean_at].attr != "l0c_o":
            return clean_at

        output_set = {"leaf", "inter_out", "l1fuse_leaf"}
        if stage_scope == "local.UB" or (output_set & stage_type):
            fanins = t2c_params.op_schedule_info.all_fanin_dict[
                stage_index]
            if not set(fanins) & set(mad_stage_indexs):
                clean_at -= 1
        else:
            clean_at -= 1
        return clean_at

    def get_at_retry_name(matrix_b):
        '''
        获取retry name
        '''
        retry_name = ""
        if t2c_params.op_schedule_info.op_name in op_cfg.RNN_OP_LIST:
            if matrix_b:
                bl1_index = bl1_indexs.index(stage_index)
                retry_name = "not_at_bl1_%s" % bl1_index
            else:
                if "l1fuse_leaf" in stage_type:
                    # WTODO: 这里只针对了rnnv3做了特殊处理，不具备通用性
                    retry_name = "not_at_al1_1"
                else:
                    al1_index = al1_indexs.index(stage_index)
                    retry_name = "not_at_al1_%s" % al1_index
        else:
            if matrix_b:
                retry_name = "not_at_bl1"
            else:
                retry_name = "not_at_al1"
        return retry_name

    def _l1_dma_clean(clean_at, matrix_b=False):  # pylint: disable=R0912,R0914
        # 有四种选择, 不at(即多核轴)、n_o、m_o、k_o
        at_axis_search = t2c_params.op_schedule_info.option.get(
            'at_axis_search')
        if not at_axis_search:
            retry_name = get_at_retry_name(matrix_b)
            retry_options = [{retry_name: False}, {retry_name: True}]
            add_retry_option(t2c_params.retry_t2c_rules, retry_name,
                             retry_options)
            if t2c_params.op_schedule_info.option.get(retry_name, False):
                return 0

        kl1_split = comm.is_cut_l1_k(t2c_params, stage_index)
        legal_axis_list = []
        legal_index_list = []
        for i, at_choice in enumerate(my_at_choices):
            if at_choice.type == "axis":
                if at_choice.attr == "o":
                    legal_axis_list.append(at_choice)
                    legal_index_list.append(i)
            elif at_choice.type == "reduce_axis":
                if kl1_split:
                    legal_axis_list.append(at_choice)
                    legal_index_list.append(i)
        if clean_at > len(legal_index_list) - 1:
            clean_at = len(legal_index_list) - 1

        if at_axis_search:
            return legal_index_list[clean_at]

        # 切了k轴就固定at到k轴
        if kl1_split:
            for legal_index in legal_index_list:
                curr_axis = my_at_choices[legal_index]
                if curr_axis.type == "reduce_axis" and curr_axis.attr == "o":
                    return legal_index
        n_index, m_index = t2c_util.get_nm_axis_index(
            t2c_params.op_schedule_info)
        if matrix_b:
            target_index = n_index
        else:
            target_index = m_index
        for legal_index in legal_index_list[1:]:
            if my_at_choices[legal_index].index == target_index:
                clean_at = legal_index
                return clean_at

        clean_at = legal_index_list[clean_at]
        return clean_at

    def _clean_gemm_at(clean_at):
        '''
        MAD对应的Stage，必须AT到最内侧的outer轴
        '''
        if c_op in comm.CONV_OP_ID_LIST:
            clean_at = len(my_at_choices) - 1
            clean_at = _clean_quant_params_at(clean_at)
        elif c_op in comm.MAD_OP_ID_LIST:
            clean_at = len(my_at_choices) - 1
            clean_at = _clean_l0c2ub_at(clean_at)
        return clean_at

    def _clean_set_fmatrix(clean_at, c_op):
        if c_op in comm.CONV_OP_ID_LIST:
            # al1以及l1fuse_leaf保持和set_fmatrix一致
            fanout_subtree_indices = t2c_params.fanout_sub_tree[stage_index]
            set_fmatrixs = t2c_params.cube_info_dict.get("set_fmatrix", [])
            for i in set_fmatrixs:
                if i not in fanout_subtree_indices:
                    continue
                clean_at = t2c_params.cleaned_actions[i][ActionTensorCfg.at_s]
                break
        else:
            clean_at = _l1_dma_clean(clean_at)
        return clean_at

    # 注意：这里的action_tensor中的at是指my_at_choices中的index
    clean_at = t2c_params.cleaned_actions[stage_index][ActionTensorCfg.at_s]
    stage_info = t2c_params.op_schedule_info.stages_info[stage_index]
    stage_name = stage_info.get('name')
    if clean_at >= len(my_at_choices):
        clean_at = len(my_at_choices) - 1
    c_op = t2c_params.op_schedule_info.c_op
    stage_tag = stage_info.get('tag')
    stage_scope = stage_info.get('scope')
    stage_type = set(stage_info.get('type', []))
    at_align = t2c_params.op_schedule_info.option.get("at_align", True)
    mad_stage_indexs = t2c_params.cube_info_dict.get("mad_stage", [])
    bl1_indexs = t2c_params.cube_info_dict.get("matrix_bl1", [])
    al1_indexs = t2c_params.cube_info_dict.get("matrix_al1", [])
    gemm_strict_mask = t2c_params.op_schedule_info.option.get(
        'gemm_strict_mask')

    if at_align:
        clean_at = len(my_at_choices) - 1
    elif stage_tag in ["im2col", "load2d", "l1_to_l0"]:
        log.dbg('[%s] %s %s', stage_index, stage_name, stage_tag)
        # L0不允许多搬数据，固定at到小k，即最内的reduce轴
        clean_at = _clean_l0_at(clean_at)
    elif stage_tag in ["set_fmatrix"]:
        clean_at = _l1_dma_clean(clean_at)
        log.dbg('[%s] %s clean_at: %s', stage_index, stage_name, clean_at)
    elif stage_index in bl1_indexs:
        log.dbg('[%s] %s %s', stage_index, stage_name, stage_tag)
        clean_at = _l1_dma_clean(clean_at, matrix_b=True)
    elif stage_index in al1_indexs or (
            "l1fuse_leaf" in stage_type and t2c_params.op_schedule_info.overflow_l1size_flag):
        log.dbg('[%s] %s %s', stage_index, stage_name, stage_tag)
        clean_at = _clean_set_fmatrix(clean_at, c_op)
    elif "l1fuse_leaf" in stage_type and not t2c_params.op_schedule_info.overflow_l1size_flag:
        log.dbg("no overflow l1, compute at 0")
        clean_at = 0
    elif stage_tag in ["out_to_l1"]:
        log.dbg('[%s] %s %s', stage_index, stage_name, stage_tag)
        if c_op in comm.MAD_OP_ID_LIST and gemm_strict_mask is True:
            for idx, at_choice in enumerate(my_at_choices):
                if at_choice and at_choice.type == "reduce_axis":
                    clean_at = idx
                    break
    else:
        log.dbg('[%s] %s %s', stage_index, stage_name, stage_tag)
        # mad及其之后的stage都默认at到o或io轴的最内层轴，
        # MNKk at到大N，MNmnk at到小n
        clean_at = _clean_gemm_at(clean_at)
        clean_at = no_cut_l1_k_clean(t2c_params, stage_index, my_at_choices,
                                     clean_at)
    return clean_at


def inherited(axis, at_choices, child_stages):
    '''
    :param axis:
    :param at_choices:
    :param child_stages:
    :return:
    '''
    # 现在全置成了True，和当前的代码是一致的，后面需要放开，届时可能代码的顺序也需要调整
    log.dbg('axis: %s, at_choices: %s, child_stages: %s', axis, at_choices,
            child_stages)
    return True


def refine_a_stage(stage_index,  # pylint: disable=R0913,R0912
                   at_choices, at_targets, t2c_params):
    """

    :param features:
    :param stage_index:
    :param at_choices:
    :param inlined_stages:
    :param t2c_params:
    :param at_targets:
    :param stage:
    :param axis_info_list:
    """
    axis_info_list = t2c_params.axis_info_list
    stage = t2c_params.schedule.stages[stage_index]
    inlined_stages = t2c_params.inlined_stages
    child_stages = t2c_params.op_schedule_info.real_fanout_dict[stage_index]
    cleaned_actions = t2c_params.cleaned_actions

    # 要找到当前Stage的所有子节点，看它们AT完之后，还有哪些目标可以AT
    my_at_choices = get_at_choices(stage_index, at_choices, child_stages,
                                   t2c_params)

    # inlined stage仅向下传递my_at_choices
    if stage_index in inlined_stages:
        cleaned_actions[stage_index][ActionTensorCfg.at_s] = INVALID_AT_AXIS
        at_targets[stage_index] = None
        at_choices[stage_index] = my_at_choices[:]
        log.dbg("inline stage [%d] at choices:%s",
                stage_index, at_choices[stage_index])
        return

    # 对at的Action作Clean
    clean_at = at_clean_rule_proc(stage_index, my_at_choices, t2c_params)
    t2c_params.cleaned_actions[stage_index][ActionTensorCfg.at_s] = clean_at

    # 设置自己的at target
    at_targets[stage_index] = my_at_choices[clean_at]

    # 设置自己at后，父节点可用的at choices
    at_choices[stage_index] = my_at_choices[:clean_at + 1]

    stage_type = t2c_params.stages_info[stage_index].get('type', [])
    # 如果自己是reduce stage，那还会暴露自己的at choices
    if not str(stage.op).startswith("placeholder") \
            and stage.op.reduce_axis \
            and axis_info_list[stage_index]:
        # 自己的Reduce axis肯定需要暴露
        for axis in axis_info_list[stage_index]:
            if axis.attr in ["o", "io"] and axis.type == "reduce_axis":
                at_choices[stage_index].append(axis)
        # 自己没有继承切分的轴也可以暴露
        for axis in stage.op.axis:
            # 如果这个轴没有继承，就可以暴露
            if not inherited(axis, at_choices, child_stages):
                at_choices[stage_index].append(axis)
    elif "l1fuse_leaf" in stage_type:
        # 理论上at之前的轴都可以暴露出来，这里简化处理，只暴露第一根轴
        at_choices[stage_index] = [at_choices[stage_index][0]]
        for axis in axis_info_list[stage_index]:
            if axis.attr in ["o", "io", "l0c_o"]:
                at_choices[stage_index].append(axis)
