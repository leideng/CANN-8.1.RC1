#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search.ts_env.tensor_to_code import t2c_util as util
from schedule_search.ts_env.tensor_to_code.proc_cache_rw.main import \
    gen_cache_rw_info
from schedule_search.ts_env.tensor_to_code.proc_cache_rw.main import \
    is_dma_intrin
from tbe.common.platform import platform_info
from tbe import tvm


def condition_check(input_dict):
    """

    :param input_dict:
    :param consumer_stages_info:
    :return:
    """
    tensor = input_dict["tensor"]
    op_type = type(tensor.op)
    tensor_name = tensor.op.name
    cache_level = input_dict["cache_level"]
    consumer_stages_info = input_dict["consumer_stages_info"]

    if cache_level != 0:
        log.dbg("Op name:%s, Cache Level:%s not 0, no need read OUT->L1!",
                tensor_name, cache_level)
        return False

    # 如果他的consumer是l1fuse_reshape, 且其本身不是dma或者中间输出，则cache_read到L1
    stage_tag = input_dict["stage_info"].get("tag")
    stage_type = input_dict["stage_info"].get("type", [])
    if consumer_stages_info[0].get('tag') == "conv_l1fuse_reshape" and \
            "inter_out" not in stage_type and not is_dma_intrin(stage_tag):
        log.dbg("Op name:%s, need read L1, type: %s!", tensor_name, stage_type)
        return True

    if op_type != tvm.PlaceholderOp:
        log.dbg("Op name:%s, Op type:%s not Placeholder, "
                "no need read OUT->L1!", tensor_name, op_type)
        return False

    # l1_fusion(input_l1_flag=1),输入tensor_a需要cache read到L1_Fusion
    if input_dict["input_l1_flag"] == 1 and \
            input_dict['tensor_a_name'] == tensor_name:
        log.dbg("l1_fusion(input_l1_flag=1), op_name: %s, from L1, "
                "need read L1->L1_Fusion!", tensor_name)
        return True

    # 需要搬进L1的tag做静态配置
    if consumer_stages_info[0].get('tag') not in util.NEED_READ_OUT_TO_L1_TAGS:
        log.dbg("op_name: %s, consumer_tag: %s, need read OUT->L1!",
                tensor_name, consumer_stages_info[0].get('tag'))
        return False

    return True


def proc(input_dict):
    """
    :param input_dict:
    :return:
    """
    if not condition_check(input_dict):
        return []

    return gen_cache_rw_info(input_dict["tensor"], input_dict["all_tensors"],
                             "CacheRead", platform_info.scope_cbuf,
                             input_dict['stage_info'])
