#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from functools import reduce as functools_reduce

from schedule_search import log
from schedule_search import comm
from schedule_search import util
from schedule_search.ts_env import env_util
from schedule_search.ts_env.tensor_cfg import AXIS_CNT
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_to_code import t2c_util
from schedule_search.timer import timer


def adjust_factor(stage, factors, stage_dtype):  # pylint: disable=R0914,R0912
    """

    :param stage:
    :param factors:
    :param stage_dtype:
    :return:
    """
    def _get_last_slice_size(axis_len_list, slice_size):
        split_axis_index = len(axis_len_list) - 1
        split_factor = 1
        for axis_len in axis_len_list[::-1]:
            if slice_size <= axis_len:
                split_factor = axis_len % slice_size
                if split_factor == 0:
                    split_factor = slice_size
                break
            split_axis_index -= 1
            slice_size = slice_size // axis_len
        last_slice_size = util.get_last_slice_len(
            axis_len_list[split_axis_index], split_factor,
            axis_len_list[split_axis_index + 1:])
        return last_slice_size, split_axis_index, split_factor

    # 1、获取切分轴和切分因子，这里会切两刀，获取最后一刀的
    axis_len_list = [int(axis.dom.extent.value) for axis in stage.op.axis]
    split_axis_index = len(axis_len_list) - 1
    split_factor = 1
    for axis_index in range(len(axis_len_list) - 1, -1, -1):
        axis_len = axis_len_list[axis_index]
        factor = factors[axis_index]
        if factor < axis_len or axis_index == 0:
            split_axis_index = axis_index
            split_factor = factor
            break
    log.dbg("split_axis_index: %s, split_factor: %s", split_axis_index,
            split_factor)

    # 2、获取数据块的大小
    slice_size = split_factor
    if split_axis_index < len(axis_len_list) - 1:
        slice_size *= functools_reduce(lambda x, y: x * y,
                                       axis_len_list[split_axis_index + 1:])

    # 3、调整数据块的大小，同时向下、向上调整，看尾块能否32b对齐
    block_size = env_util.get_block_num(stage_dtype)
    total_size = functools_reduce(lambda x, y: x * y, axis_len_list)
    add_slice_size = slice_size
    sub_slice_size = slice_size
    # 向下最多调整slice_size次，向上最多调整total_size - slice_size次
    for _ in range(max(slice_size + 1, total_size - slice_size + 1)):
        # 向下
        sub_slice_size -= 1
        if sub_slice_size > 0:
            sub_last_slice_size, sub_split_axis_index, sub_split_factor \
                = _get_last_slice_size(axis_len_list, sub_slice_size)
            if sub_last_slice_size % block_size == 0:
                log.dbg("sub_last_slice_size: %s", sub_last_slice_size)
                return True, sub_split_axis_index, sub_split_factor
        # 向上
        add_slice_size += 1
        if add_slice_size <= total_size:
            add_last_slice_size, add_split_axis_index, add_split_factor \
                = _get_last_slice_size(axis_len_list, add_slice_size)
            if add_last_slice_size % block_size == 0:
                log.dbg("add_last_slice_size: %s", add_last_slice_size)
                return True, add_split_axis_index, add_split_factor

    # 4、clean失败全部整吃
    return False, 0, axis_len_list[0]


def _get_axis_index(none_reduce_axis_indexs,
                    reduce_axis_indexs,
                    is_keepdims,
                    input_axis_index,
                    input_axis_type="axis"):
    """

    :param none_reduce_axis_indexs:
    :param reduce_axis_indexs:
    :param is_keepdims:
    :param input_axis_index:
    :param input_axis_type:
    :return:
    """
    # 获取在中间输出上的轴对应关系
    if input_axis_type == "reduce_axis":
        axis_index = reduce_axis_indexs[input_axis_index]
    else:
        if is_keepdims:
            axis_index = input_axis_index
        else:
            axis_index = none_reduce_axis_indexs[input_axis_index]
    log.dbg(
        "axis_index: %s, none_reduce_axis_indexs: %s, reduce_axis_indexs: "
        "%s, is_keepdims: %s, input_axis_index: %s, input_axis_type: %s",
        axis_index, none_reduce_axis_indexs, reduce_axis_indexs, is_keepdims,
        input_axis_index, input_axis_type)
    return axis_index


def proc_reduce(real_axis_index, split_axis_index, split_factor, axis):
    """
    proc_reduce
    :param real_axis_index:
    :param split_axis_index:
    :param split_factor:
    :param axis:
    :return:
    """
    if real_axis_index < split_axis_index:
        clean_factor = 1
    elif real_axis_index == split_axis_index:
        clean_factor = split_factor
    else:
        clean_factor = axis.dom.extent.value
    return clean_factor


def clean_proc(t2c_params,  # pylint: disable=R0912
               stage_index, split_axis_index, split_factor):
    """
    clean_proc
    :param t2c_params:
    :param stage_index:
    :param split_axis_index:
    :param split_factor:
    """
    log.dbg("split_axis_index: %s, split_factor: %s", split_axis_index,
            split_factor)
    reduce_stage_index = t2c_params.op_schedule_info.at_dict[stage_index]
    reduce_stage = t2c_params.schedule.stages[reduce_stage_index]
    reduce_at_stage_index = t2c_params.op_schedule_info.at_dict[
        reduce_stage_index]
    reduce_at_stage = t2c_params.schedule.stages[reduce_at_stage_index]
    log.dbg(
        "before clean: %s, %s", t2c_params.cleaned_actions[reduce_stage_index]
        [ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_s +
         AXIS_CNT], t2c_params.cleaned_actions[reduce_at_stage_index]
        [ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_s +
         AXIS_CNT])

    # 需要找到轴的对应关系
    reduce_axis_indexs = util.get_reduce_axis_index(reduce_stage.op)
    shape_before_reduce = env_util.tvm_shape_trans(
        reduce_stage.op.input_tensors[0].shape)
    is_keepdims = len(shape_before_reduce) == len(reduce_at_stage.op.axis)
    none_reduce_axis_indexs = list(
        set(range(len(shape_before_reduce))) - set(reduce_axis_indexs))
    none_reduce_axis_indexs.sort()

    if split_axis_index in reduce_axis_indexs:
        # comm aixs proc
        for axis_index, axis in enumerate(reduce_at_stage.op.axis):
            real_axis_index = _get_axis_index(none_reduce_axis_indexs,
                                              reduce_axis_indexs,
                                              is_keepdims,
                                              axis_index,
                                              input_axis_type="axis")
            if real_axis_index >= split_axis_index:
                t2c_params.cleaned_actions[reduce_at_stage_index][
                    ActionTensorCfg.split_factor_s +
                    axis_index] = axis.dom.extent.value
        # reduce axis proc
        for axis_index, axis in enumerate(reduce_stage.op.reduce_axis):
            real_axis_index = _get_axis_index(none_reduce_axis_indexs,
                                              reduce_axis_indexs,
                                              is_keepdims,
                                              axis_index,
                                              input_axis_type="reduce_axis")
            t2c_params.cleaned_actions[reduce_stage_index][
                ActionTensorCfg.split_factor_s + axis_index] = proc_reduce(
                    real_axis_index, split_axis_index, split_factor, axis)
    else:
        for axis_index, axis in enumerate(reduce_at_stage.op.axis):
            real_axis_index = _get_axis_index(none_reduce_axis_indexs,
                                              reduce_axis_indexs,
                                              is_keepdims,
                                              axis_index,
                                              input_axis_type="axis")
            if real_axis_index < split_axis_index:
                t2c_params.cleaned_actions[reduce_at_stage_index][
                    ActionTensorCfg.split_factor_s + axis_index] = 1
            elif real_axis_index == split_axis_index:
                t2c_params.cleaned_actions[reduce_at_stage_index][
                    ActionTensorCfg.split_factor_s + axis_index] = split_factor
            else:
                t2c_params.cleaned_actions[reduce_at_stage_index][
                    ActionTensorCfg.split_factor_s +
                    axis_index] = axis.dom.extent.value
        for axis_index, axis in enumerate(reduce_stage.op.reduce_axis):
            real_axis_index = _get_axis_index(none_reduce_axis_indexs,
                                              reduce_axis_indexs,
                                              is_keepdims,
                                              axis_index,
                                              input_axis_type="reduce_axis")
            if real_axis_index >= split_axis_index:
                t2c_params.cleaned_actions[reduce_stage_index][
                    ActionTensorCfg.split_factor_s +
                    axis_index] = axis.dom.extent.value


@timer('r12')
def proc(t2c_params):  # pylint: disable=R0914,R0912
    """
    规则内容：
    中间输出如果at到reduce stage，然后reduce stage又at到叶子输出，
    那中间输出相当于切了两刀，数据不连续，
    最后一块数据（factor能整除时为factor，否则为尾块）长度必须是32字节的整数倍
    """
    # 这里默认inter out -> inter out at的reduce stage ->reduce stage at的stage，
    # 中间没有其它的reduce、broadcast,
    # 如果有的话，这里的调整逻辑不能这样简单处理
    features = t2c_params.features
    stages = t2c_params.schedule.stages
    stages_info = t2c_params.stages_info
    cleaned_actions = t2c_params.cleaned_actions
    op_schedule_info = t2c_params.op_schedule_info
    reduce_axis_dict = t2c_params.op_schedule_info.reduce_axis_dict
    tiling_case = t2c_params.op_schedule_info.tiling_case

    if op_schedule_info.c_op in comm.MAD_OP_ID_LIST:
        return True

    # get_factors不支持atomic
    if tiling_case > 0:
        return True

    # 没有中间输出不处理
    inter_out_list = t2c_util.get_inter_out(stages_info)
    if len(inter_out_list) != 1:
        return True

    # 获取中间输出的切分
    stage_factors, _ = t2c_util.get_factors(
        stages, stages_info, features, cleaned_actions, reduce_axis_dict,
        t2c_params.op_schedule_info.real_fanout_dict)

    # 逐个处理
    # 多个中间输出不好调整，顾此失彼
    for stage_index in inter_out_list:
        # 中间输出没有at到reduce不处理
        reduce_stage_index = op_schedule_info.at_dict[stage_index]
        if 'reduce' not in stages_info[reduce_stage_index].get('type', []):
            continue

        # 尾块已经32b对齐不处理
        stage = stages[stage_index]
        factors = stage_factors[stage_index][0]
        log.dbg("factors: %s", factors)
        last_slice_size = t2c_util.get_last_slice_size(stage.op.axis, factors)
        stage_dtype = stage.op.input_tensors[0].dtype
        if last_slice_size % env_util.get_block_num(stage_dtype) == 0:
            continue
        log.dbg("inter_out [%s] %s need clean. factors: %s", stage_index,
                stage, factors)

        # 如果shape只有一维，且轴长为1，则不需要下面的clean
        stage_axis = stage.op.axis
        if len(stage_axis) == 1 and stage_axis[0].dom.extent.value == 1:
            continue

        # 进行clean
        ret, split_axis_index, split_factor = adjust_factor(
            stage, factors, stage_dtype)
        if not ret:
            log.dbg("clean [%s] %s failed.", stage_index, stage)
        log.dbg("split_axis_index: %s, split_factor: %s", split_axis_index,
                split_factor)

        # 将clean结果映射到reduce的stage和reduce at的stage
        clean_proc(t2c_params, stage_index, split_axis_index, split_factor)

    return True
