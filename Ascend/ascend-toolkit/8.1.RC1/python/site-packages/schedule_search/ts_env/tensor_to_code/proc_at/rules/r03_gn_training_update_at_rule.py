#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search.ts_env import env_util
from schedule_search.ts_env.cheque_generator import get_fuse_cheque
from schedule_search.ts_env.cheque_generator import get_split_cheque
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_cfg import AxisInfo
from schedule_search.ts_env.tensor_cfg import INVALID_AT_AXIS
from schedule_search.ts_env.tensor_to_code.t2c_util import factor_tail_check
from schedule_search.ts_env.tensor_to_code.t2c_util import \
    gn_training_update_nchw
from schedule_search.ts_env.tensor_to_code.t2c_util import MULTICORE_POSTFIX
from schedule_search.ts_env.tensor_to_code.t2c_util import COMMON_AT_POSTFIX


def _do_fuse(t2c_params, stage, stage_index, reordered_axis):
    """

    :param t2c_params:
    :param stage:
    :param stage_index:
    :param reordered_axis:
    :return:
    """

    def get_fuse_num():
        if not reordered_axis and t2c_params.cut_axis_index.get(
                stage_index) > 0:
            return 2

        if len(reordered_axis) > 1:
            return len(reordered_axis)

        return 1

    fuse_num = get_fuse_num()
    if fuse_num == 1:
        return

    stage_axis_info = t2c_params.axis_info_list[stage_index]
    axis_name = '%s_axis_fused_o' % stage.op.name
    fuse_code = ['%s = sch[%s].fuse(' % (axis_name, stage.op.name)]
    fuse_len = 1
    axis_obj_list = []
    index_list = []
    fuse_axis_name_list = []
    for i in range(fuse_num):
        fuse_code.append("%s, " % stage_axis_info[0].name)
        fuse_axis_name_list.append(stage_axis_info[0].name)
        fuse_len *= stage_axis_info[0].len
        axis_obj_list.append(stage_axis_info[0].body)
        index_list.append(i)
        del stage_axis_info[0]
    t2c_params.code_lines.append(''.join(fuse_code) + ")")
    fused_axis_obj = None
    if t2c_params.mode == MODE_RUNTIME:
        fused_axis_obj = stage.fuse(*axis_obj_list)
    stage_axis_info.insert(
        0,
        AxisInfo(axis_name, fuse_len, 'axis', index_list, 'o',
                 fused_axis_obj))

    # 实现fuse操作对应的cheque
    get_fuse_cheque(t2c_params, stage_index, index_list)


def _do_split(t2c_params, stage, stage_index, factor):

    if factor == 0:
        return

    axis_infos = t2c_params.axis_info_list[stage_index]
    axis_info = axis_infos[0]
    stage_name = t2c_params.stages_info[stage_index]['name']
    axis_type = 'o'
    axis_name = axis_info.name.split("_o")[0]
    axis_oo = axis_name + MULTICORE_POSTFIX
    axis_o = axis_name + COMMON_AT_POSTFIX
    axis_oo_len = axis_info.len // factor

    t2c_params.code_lines.append(
        '%s, %s = sch[%s].split(%s, factor=%d)' %
        (axis_oo, axis_o, stage_name, axis_info.name, factor))

    axis_obj_oo, axis_obj_o = None, None
    if t2c_params.mode == MODE_RUNTIME:
        axis_obj_oo, axis_obj_o = stage.split(axis_info.body, factor=factor)

    del axis_infos[0]
    axis_infos.insert(0,
                      AxisInfo(axis_o, factor, 'axis',
                               axis_info.index, axis_type, axis_obj_o))
    axis_infos.insert(0,
                      AxisInfo(axis_oo, axis_oo_len, 'axis',
                               axis_info.index, axis_type, axis_obj_oo))

    get_split_cheque(t2c_params, stage_index, 0, factor)


def _get_reordered_axis(t2c_params, stage_index):
    """

    :param t2c_params:
    :param stage_index:
    :return:
    """
    reorder_axis_map = t2c_params.reorder_axis_map.get(stage_index, {})
    reordered_axis = []
    if reorder_axis_map:
        for _, axis in reorder_axis_map.items():
            if axis == 0:
                break
            reordered_axis.append(axis)

    return reordered_axis


def multicore_fuse_split(t2c_params, stage_index):
    """

    :param t2c_params:
    :param stage_index:
    :return:
    """
    # 如果切分轴为0
    stage = t2c_params.schedule.stages[stage_index]
    stage_dtype = stage.op.output(0).dtype
    block_size = env_util.get_block_num(stage_dtype)

    reordered_axis = _get_reordered_axis(t2c_params, stage_index)
    # 如果切分轴大于0
    # 对前面两根轴进行fuse
    _do_fuse(t2c_params, stage, stage_index, reordered_axis)

    # 如果切分后的数据块小于32B
    if not reordered_axis \
            and not factor_tail_check(t2c_params, stage, stage_index):
        # 如果fuse后的轴长小于block size, 则返回
        # 最小数据块小于32B，则对fuse之后的轴以factor最小block size进行切分
        if t2c_params.axis_info_list[stage_index][0].len < block_size:
            return False

        _do_split(t2c_params, stage, stage_index, block_size)

    t2c_params.bind_axis[stage_index] = \
        t2c_params.axis_info_list[stage_index][0]

    return True


def _ensure_at_axis(t2c_params,  # pylint: disable=R0914,R0912
                    at_targets,
                    stage_num,
                    multicore_enable):
    """

    :param t2c_params:
    :param reversed_stages:
    :param at_dict:
    :param at_targets:
    :param special_stages:
    :return:
    """
    at_axis_infos = t2c_params.axis_info_list[stage_num - 1]

    broadcast_info = t2c_params.op_schedule_info.broadcast_dict['info']
    bc_stages = list(broadcast_info.keys())
    last_cut_axis = t2c_params.cut_axis_index[stage_num - 1]

    for stage_index in range(stage_num):
        # at target为 None, inline的stages
        stage = t2c_params.schedule.stages[stage_index]
        at_stage_index = t2c_params.op_schedule_info.at_dict.get(stage_index)
        if str(stage.op).startswith("placeholder") or at_stage_index is None:
            t2c_params.cleaned_actions[stage_index][ActionTensorCfg.at_s] = \
                INVALID_AT_AXIS
            at_targets[stage_index] = None
            continue

        # 如果没有使能多核，at最后一根切分轴
        if not multicore_enable:
            t2c_params.cleaned_actions[stage_index][ActionTensorCfg.at_s] = \
                last_cut_axis
            at_targets[stage_index] = at_axis_infos[last_cut_axis]
            continue

        bc_in_subtree = False
        for bc_stage in bc_stages:
            if stage_index in t2c_params.op_schedule_info.\
                    all_fanin_dict[bc_stage]:
                bc_in_subtree = True
                break

        # 如果stage后续有broadcast, at到多核bind轴
        if bc_in_subtree:
            t2c_params.cleaned_actions[stage_index][ActionTensorCfg.at_s] = 0
            at_targets[stage_index] = at_axis_infos[0]
        else:
            t2c_params.cleaned_actions[stage_index][ActionTensorCfg.at_s] = \
                last_cut_axis
            at_targets[stage_index] = at_axis_infos[last_cut_axis]


def proc(t2c_params):  # pylint: disable=R0912,R0914,R0915
    """
    规则内容：获取每个stage的at到的axis，存入at_targets
    """
    if not gn_training_update_nchw(t2c_params.op_schedule_info):
        return False
    # 输入
    stage_num = len(t2c_params.features)
    at_targets = [None] * stage_num
    # 对最后一个stage的axis进行fuse和split操作
    multi_core_enable = multicore_fuse_split(t2c_params, stage_num - 1)

    # 不能使能多核，则设置已经处理过多核
    if not multi_core_enable:
        t2c_params.proc_flag_dict[stage_num - 1] = True

    # at的axis如果有多个选择，记录at的偏移，用于保证前后依赖关系
    _ensure_at_axis(t2c_params, at_targets, stage_num, multi_core_enable)

    t2c_params.at_targets = at_targets
    return True
