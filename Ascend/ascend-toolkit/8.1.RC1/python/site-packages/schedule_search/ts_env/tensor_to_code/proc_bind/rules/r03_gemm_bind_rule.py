#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search.ts_env.tensor_cfg import AxisInfo
from schedule_search.ts_env.tensor_to_code.t2c_util import gemm_identify
from schedule_search.ts_env.tensor_to_code.t2c_util import COMMON_AT_POSTFIX
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.cheque_generator import get_bind_cheque
from schedule_search.ts_env.cheque_generator import get_fuse_cheque
from schedule_search.ts_env.cheque_generator import get_split_cheque
from schedule_search.ts_env.cheque_generator import get_sub_bind_cheque
from schedule_search.ts_env.tensor_to_code.proc_bind.rules.comm import \
    get_block_dim
from schedule_search import op_cfg
from schedule_search import comm
from tbe import tvm


def fuse_proc(bind_stage_index,  # pylint: disable=R0912,R0914
              bind_stage, t2c_params):
    '''
    用batch + oo轴fuse起来作为bind的轴
    '''
    def need_fuse(has_batch, axis_info):
        if axis_info.attr == 'oo':
            return True
        if has_batch and axis_info.index == 0 and not axis_info.name.endswith(
                COMMON_AT_POSTFIX):
            return True
        return False

    bind_stage_name = t2c_params.stages_info[bind_stage_index]['name']
    fuse_axis_name = '%s_axis_fused_o' % bind_stage_name
    fuse_code = '%s = sch[%s].fuse(' % (fuse_axis_name, bind_stage_name)
    has_batch, _ = gemm_identify(t2c_params.op_schedule_info)

    fuse_len = 1
    fuse_axis_obj_list = []
    fuse_index_list = []
    fuse_axis_name_list = []
    fuse_axis_indices = []

    new_bind_stage_axis_info = []
    for i, axis_info in enumerate(t2c_params.axis_info_list[bind_stage_index]):
        if need_fuse(has_batch, axis_info):
            fuse_code += "%s, " % axis_info.name
            fuse_len *= axis_info.len
            fuse_axis_obj_list.append(axis_info.body)
            fuse_index_list.append(axis_info.index)
            fuse_axis_name_list.append(axis_info.name)
            fuse_axis_indices.append(i)
            continue
        new_bind_stage_axis_info.append(axis_info)
    t2c_params.code_lines.append(fuse_code + ")")

    fused_axis_obj = None
    if t2c_params.mode == MODE_RUNTIME:
        fused_axis_obj = bind_stage.fuse(*fuse_axis_obj_list)
    new_bind_stage_axis_info.insert(
        0,
        AxisInfo(fuse_axis_name, fuse_len, 'axis',
                 fuse_index_list, 'o', fused_axis_obj))

    t2c_params.axis_info_list[bind_stage_index] = new_bind_stage_axis_info

    # 实现fuse操作对应的cheque
    get_fuse_cheque(t2c_params, bind_stage_index, fuse_axis_indices)


def split_proc(bind_stage_index, bind_stage, t2c_params):
    '''
    进行Nparts切分
    '''
    # 计算block_dim
    stage_axis_info = t2c_params.axis_info_list[bind_stage_index]
    split_axis_info = stage_axis_info[0]
    block_dim = get_block_dim(split_axis_info.len)
    if t2c_params.op_schedule_info.op_name in op_cfg.TIK_BIND_OP_LIST and \
            op_cfg.MULTI_SCH_BLOCKDIM:
        if block_dim < op_cfg.MULTI_SCH_BLOCKDIM[-1]:
            return False

        block_dim = min(op_cfg.MULTI_SCH_BLOCKDIM[-1], block_dim)

    # Nparts切分
    axis_name = split_axis_info.name
    bind_stage_name = t2c_params.stages_info[bind_stage_index]['name']
    t2c_params.code_lines.append(
        '%s_oo, %s_o = sch[%s].split(%s, nparts=%d)' %
        (axis_name, axis_name, bind_stage_name, axis_name, block_dim))
    axis_obj_o, axis_obj_i = None, None
    if t2c_params.mode == MODE_RUNTIME:
        axis_obj_o, axis_obj_i = bind_stage.split(split_axis_info.body,
                                                  nparts=block_dim)
    del stage_axis_info[0]
    stage_axis_info.insert(
        0,
        AxisInfo(axis_name + '_o', split_axis_info.len // block_dim, 'axis',
                 split_axis_info.index, 'o', axis_obj_i))
    stage_axis_info.insert(
        0,
        AxisInfo(axis_name + '_oo', block_dim, 'axis', split_axis_info.index,
                 'oo', axis_obj_o))

    # 实现split_nparts对应的cheque
    get_split_cheque(t2c_params, bind_stage_index, 0, block_dim, "nparts")
    if t2c_params.op_schedule_info.op_name in op_cfg.TIK_BIND_OP_LIST:
        op_cfg.MULTI_SCH_BLOCKDIM.append(block_dim)
    return True


def sub_bind_proc(bind_stage_index, bind_stage, t2c_params):
    # sub bind
    bind_stage_name = t2c_params.stages_info[bind_stage_index]['name']
    sub_axis_index = 0

    for index, axis in enumerate(t2c_params.axis_info_list[-1]):
        if "so" in axis.name:
            sub_axis_index = index
            break
    sub_bind_axis_info = t2c_params.axis_info_list[bind_stage_index][sub_axis_index]
    t2c_params.code_lines.append("sub_block = tvm.te.thread_axis('subBlockIdx.x')")
    t2c_params.code_lines.append("sch[%s].bind(%s, sub_block)" %
                                 (bind_stage_name, sub_bind_axis_info.name))
    if t2c_params.mode == MODE_RUNTIME:
        sub_block = tvm.te.thread_axis('subBlockIdx.x')
        bind_stage.bind(sub_bind_axis_info.body, sub_block)

    # 生成bind操作对应的cheque
    get_sub_bind_cheque(t2c_params, bind_stage_index, sub_axis_index)


def bind_proc(bind_stage_index, bind_stage, t2c_params):
    '''
    bind
    '''
    bind_stage_name = t2c_params.stages_info[bind_stage_index]['name']
    bind_axis_info = t2c_params.axis_info_list[bind_stage_index][0]
    t2c_params.code_lines.append("block = tvm.thread_axis('blockIdx.x')")
    t2c_params.code_lines.append("sch[%s].bind(%s, block)" %
                                 (bind_stage_name, bind_axis_info.name))
    t2c_params.bind_axis[bind_stage_index] = bind_axis_info
    if t2c_params.mode == MODE_RUNTIME:
        block = tvm.thread_axis('blockIdx.x')
        bind_stage.bind(bind_axis_info.body, block)

    # 生成bind操作对应的cheque
    get_bind_cheque(t2c_params, bind_stage_index)


def proc(t2c_params):
    '''
    gemm的多核规则
    '''
    c_op = t2c_params.op_schedule_info.c_op
    if c_op not in comm.MAD_OP_ID_LIST:
        return True

    # lx fusion不使能多核
    l1_fusion_dict = t2c_params.op_schedule_info.l1_fusion_dict
    if l1_fusion_dict["l1_fusion_type"] in [0, 1]:
        return True

    # 只能有一个stage绑定多核
    bind_stage, bind_stage_index = t2c_params.bind_stages[0]

    # 前面规则处理过的stage直接跳过
    if t2c_params.proc_flag_dict.get(bind_stage_index, False):
        return True

    fuse_proc(bind_stage_index, bind_stage, t2c_params)

    ret = split_proc(bind_stage_index, bind_stage, t2c_params)
    if not ret:
        t2c_params.proc_flag_dict[bind_stage_index] = True
        return True

    if op_cfg.is_support_split(t2c_params.op_name):
        sub_bind_proc(bind_stage_index, bind_stage, t2c_params)

    bind_proc(bind_stage_index, bind_stage, t2c_params)

    t2c_params.proc_flag_dict[bind_stage_index] = True
    return True
