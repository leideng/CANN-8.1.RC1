#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import math
from functools import reduce as functools_reduce

from schedule_search import log
from schedule_search import soc_cfg
from schedule_search import util
from schedule_search.controller.mcts_search.features import UB_BUFFER_SIZE
from schedule_search.ts_env import env_util
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.tensor_cfg import AxisInfo
from schedule_search.ts_env.tensor_to_code import t2c_util
from schedule_search.ts_env.tensor_to_code.proc_bind.rules import comm
from schedule_search.ts_env.cheque_generator import get_fuse_cheque
from schedule_search.ts_env.cheque_generator import get_split_cheque
from schedule_search.ts_env.cheque_generator import get_bind_cheque
from tbe import tvm


def bind_exact_div(cut_axis_index, # pylint: disable=R0913,R0914
                   stage_index,
                   stage_axis_info,
                   t2c_params,
                   mode,
                   stage):
    """
    整除情况下的Fuse和Nparts切分
    """
    stage_name = stage.op.name
    if cut_axis_index > 0:
        axis_name = '%s_axis_fused_o' % stage_name
        fuse_code = ['%s = sch[%s].fuse(' % (axis_name, stage_name)]
        fuse_len = 1
        axis_obj_list = []
        index_list = []
        fuse_axis_name_list = []
        for i in range(cut_axis_index + 1):
            fuse_code.append(f"{stage_axis_info[0].name}, ")
            fuse_axis_name_list.append(stage_axis_info[0].name)
            fuse_len *= stage_axis_info[0].len
            axis_obj_list.append(stage_axis_info[0].body)
            index_list.append(i)
            del stage_axis_info[0]
        t2c_params.code_lines.append(''.join(fuse_code) + ")")
        fused_axis_obj = None
        if mode == MODE_RUNTIME:
            fused_axis_obj = stage.fuse(*axis_obj_list)
        stage_axis_info.insert(
            0,
            AxisInfo(axis_name, fuse_len, 'axis', index_list, 'o',
                     fused_axis_obj))

        # 实现fuse操作对应的cheque
        get_fuse_cheque(t2c_params, stage_index, index_list)

    # 3，进行Nparts切分
    # a, 计算block_dim
    split_axis_info = stage_axis_info[0]
    block_dim = comm.get_block_dim(split_axis_info.len)
    # b, Nparts切分
    axis_name = split_axis_info.name
    t2c_params.code_lines.append(
        '%s_oo, %s = sch[%s].split(%s, nparts=%d)' %
        (axis_name, axis_name, stage_name, axis_name, block_dim))
    axis_obj_o, axis_obj_i = None, None
    if mode == MODE_RUNTIME:
        axis_obj_o, axis_obj_i = stage.split(split_axis_info.body,
                                             nparts=block_dim)
    del stage_axis_info[0]
    stage_axis_info.insert(
        0,
        AxisInfo(axis_name + '_o', split_axis_info.len // block_dim, 'axis',
                 split_axis_info.index, 'o', axis_obj_i))
    stage_axis_info.insert(
        0,
        AxisInfo(axis_name + '_oo', block_dim, 'axis', split_axis_info.index,
                 'oo', axis_obj_o))

    # 实现split_nparts对应的cheque
    get_split_cheque(t2c_params, stage_index, 0, block_dim, "nparts")
    return block_dim


def fuse_axis(  # pylint: disable=R0913,R0914
        t2c_params,
        stage_axis_info,
        stage,
        stage_name,
        cut_axis_index,
        mode,
        fuse_cut,
        stage_index):
    """

    :param t2c_params:
    :param stage_axis_info:
    :param stage:
    :param stage_name:
    :param cut_axis_index:
    :param mode:
    :param fuse_cut:
    :return:
    """
    axis_name = '%s_axis_fused_o' % stage_name
    fuse_code = ['%s = sch[%s].fuse(' % (axis_name, stage_name)]
    fuse_len = 1
    axis_obj_list = []
    index_list = []
    fuse_axis_name_list = []
    for i in range(cut_axis_index + 1):
        if i == cut_axis_index and not fuse_cut:
            break
        fuse_code.append("%s, " % stage_axis_info[0].name)
        fuse_axis_name_list.append(stage_axis_info[0].name)
        fuse_len *= stage_axis_info[0].len
        axis_obj_list.append(stage_axis_info[0].body)
        index_list.append(i)
        del stage_axis_info[0]
    t2c_params.code_lines.append(''.join(fuse_code) + ")")
    fused_axis_obj = None
    if mode == MODE_RUNTIME:
        fused_axis_obj = stage.fuse(*axis_obj_list)
    stage_axis_info.insert(
        0,
        AxisInfo(axis_name, fuse_len, 'axis', index_list, 'o', fused_axis_obj))

    # 实现fuse操作对应的cheque
    get_fuse_cheque(t2c_params, stage_index, index_list)
    return fuse_len


def split_for_bind(t2c_params, stage_axis_info, stage, stage_index, mode):
    """

    :param t2c_params:
    :param stage_axis_info:
    :param stage:
    :param stage_name:
    :param mode:
    :return:
    """
    stage_name = stage.op.name
    split_axis_info = stage_axis_info[0]
    block_dim = comm.get_block_dim(split_axis_info.len)
    # b, Nparts切分
    axis_name = split_axis_info.name
    t2c_params.code_lines.append('%s_oo, _ = sch[%s].split(%s, nparts=%d)' %
                                 (axis_name, stage_name, axis_name, block_dim))
    axis_obj_o, axis_obj_i = None, None
    if mode == MODE_RUNTIME:
        axis_obj_o, axis_obj_i = stage.split(split_axis_info.body,
                                             nparts=block_dim)
    del stage_axis_info[0]
    axis_o_len = math.ceil(split_axis_info.len / block_dim)
    stage_axis_info.insert(
        0,
        AxisInfo(axis_name + '_o', axis_o_len, 'axis', split_axis_info.index,
                 'o', axis_obj_i))
    stage_axis_info.insert(
        0,
        AxisInfo(axis_name + '_oo', block_dim, 'axis', split_axis_info.index,
                 'oo', axis_obj_o))

    # 实现split_nparts对应的cheque
    get_split_cheque(t2c_params, stage_index, 0, block_dim, "nparts")
    return block_dim


def bind_nonexact_div(cut_axis_index,  # pylint: disable=R0913,R0912
                      stage_index, stage_axis_info, t2c_params,
                      mode, stage, before_cut_fuse_len, core_num):
    """
    非整除情况下的Fuse和Nparts切分
    """
    stage_name = stage.op.name
    block_dim = None
    # 2.6，不整除地切分0号轴
    if cut_axis_index == 1:
        # 2.7，不整除地切分1号轴，前面的轴还很小
        if before_cut_fuse_len <= core_num:
            fuse_cut = True
            block_dim = fuse_axis(t2c_params, stage_axis_info, stage,
                                  stage_name, cut_axis_index, mode, fuse_cut,
                                  stage_index)
        # 2.8，不整除地切分1号轴，前面的轴很大
        else:
            block_dim = split_for_bind(t2c_params, stage_axis_info, stage,
                                       stage_index, mode)
    elif cut_axis_index > 1:
        # 2.9，不整除地切分2+号轴，前面的轴还很小
        if before_cut_fuse_len <= core_num:
            fuse_cut = True
            # Fuse起来，不用切Nparts
            block_dim = fuse_axis(t2c_params, stage_axis_info, stage,
                                  stage_name, cut_axis_index, mode, fuse_cut,
                                  stage_index)
        # 2.a，不整除地切分2+号轴，前面的轴很大
        else:
            fuse_cut = False
            fuse_axis(t2c_params, stage_axis_info, stage, stage_name,
                      cut_axis_index, mode, fuse_cut, stage_index)
            block_dim = split_for_bind(t2c_params, stage_axis_info, stage,
                                       stage_index, mode)
    return block_dim


def get_bind_info(t2c_params,  # pylint: disable=R0914,R0912
                  stage_index, stage, mode, stage_axis_info):
    """

    :param t2c_params:
    :param stage_index:
    :param stage:
    :param mode:
    :param stage_axis_info:
    :return:
    """
    # a，切分轴的序号
    ated_axis_index = t2c_params.ated_axis_index.get(stage_index, None)
    reorder_axis_map = t2c_params.reorder_axis_map.get(stage_index, {})

    # WILLDO: LAP待优化，t2c_params.cut_axis_index先更新，
    #  这里直接用原cut_axis_index之前的轴都是切分轴，reorder之后
    last_cut_axis_index = t2c_params.last_cut_axis_index.get(stage_index)
    if last_cut_axis_index is None:
        last_cut_axis_index = t2c_params.cut_axis_index[stage_index]

    # 如果ated_axis_index为空，或者at轴在cut轴之后（理论上不应该发生）
    if ated_axis_index is None or ated_axis_index > last_cut_axis_index:
        ated_axis_index = last_cut_axis_index

    # b，是否整除切分
    exact_div = True

    # 根据reorder_list获取原来的index
    if reorder_axis_map.get(ated_axis_index) is not None:
        ori_index = reorder_axis_map[ated_axis_index]
    else:
        ori_index = ated_axis_index

    axis_len = stage.op.axis[ori_index].dom.extent.value
    factor = t2c_params.cleaned_actions[stage_index][ori_index]
    if axis_len % factor != 0:
        exact_div = False

    # 1, 根据切分、尾块等信息判断能否使能多核，如果不能使能多核，则直接返回
    if not t2c_util.factor_tail_check(t2c_params, stage, stage_index):
        log.dbg('factor_tail_check failed. Can not enable multi core.')
        for axis_info in stage_axis_info:
            if axis_info.attr == 'o':
                break
            t2c_params.code_lines.append("%s_o = %s" %
                                         (axis_info.name, axis_info.name))
            axis_info.name = f"{axis_info.name}_o"
            axis_info.attr = 'o'
        return 1

    # c，切分轴前面的轴Fuse到一起的大小
    before_cut_fuse_len = 1
    for i in range(ated_axis_index + 1):
        before_cut_fuse_len *= stage_axis_info[i].len

    # 只有一份，不启用多核
    if before_cut_fuse_len == 1:
        log.dbg('before cut fuse len is 1. No need to enable multi core.')
        return 1

    # d，核数
    core_num = soc_cfg.get_core_num()
    # 切分轴大于0，大部分要Fuse，只有一个例外
    if exact_div:
        block_dim = bind_exact_div(ated_axis_index, stage_index,
                                   stage_axis_info, t2c_params, mode, stage)
    else:
        block_dim = bind_nonexact_div(ated_axis_index, stage_index,
                                      stage_axis_info, t2c_params, mode, stage,
                                      before_cut_fuse_len, core_num)
    return block_dim


def _get_split_axis(t2c_params, stage):
    """

    :param t2c_params:
    :param stage:
    :return:
    """
    shapes = t2c_params.op_schedule_info.concat_dict['shapes']
    stage_dtype = stage.op.output(0).dtype
    block_size = env_util.get_block_num(stage_dtype)
    # 计算满足UB大小的切分轴split_axis，用于判断是否使能多核
    ub_size_align = (UB_BUFFER_SIZE // block_size) * block_size
    ub_size_align = ub_size_align // util.get_dtype_size(stage_dtype)

    # shapes[-1]是算子最后输出的shape
    res_shape = shapes[-1]
    split_axis = len(res_shape)
    axis_size = 1
    for k in range(0, len(res_shape)):
        axis_size = functools_reduce(lambda i, j: i * j, res_shape[k:])
        if axis_size <= ub_size_align:
            split_axis = k - 1
            break
    if split_axis == len(res_shape) and axis_size > ub_size_align:
        split_axis = len(res_shape) - 1
    return split_axis, block_size, axis_size


def _default_get_bcf(shapes, concat_axis, block_size):
    """
    获取bind core flag
    :param shapes:
    :param concat_axis:
    :param block_size:
    :return:
    """
    def get_maxinum_common_divisor(left, right):
        """

        :param left:
        :param right:
        :return:
        """
        left, right = (left, right) if left >= right else (right, left)
        while right:
            left, right = right, left % right
        return left

    # 参考base的factor判断是否绑多核
    input_axis = [shapes[i][concat_axis] for i in range(len(shapes) - 1)]
    split_factor = input_axis[0]
    bind_core_flag = False

    if len(shapes) - 1 > 2:
        for i in input_axis[1:]:
            split_factor = get_maxinum_common_divisor(i, split_factor)

    if split_factor % block_size == 0:
        bind_core_flag = True
    return bind_core_flag


def concat_bind(t2c_params, stage):  # pylint: disable=R0914,R0912
    """

    :param t2c_params:
    :param stage:
    :return:
    """
    bind_core_flag = False
    concat_axis = t2c_params.op_schedule_info.concat_dict['concat_axis']
    shapes = t2c_params.op_schedule_info.concat_dict['shapes']
    axis_num = len(shapes[-1])
    # shapes[-1]是算子最后输出的shape
    res_shape = shapes[-1]
    split_axis, block_size, axis_size = _get_split_axis(t2c_params, stage)

    # 0,整个数据可以全部放进UB，这时不使能多核
    if split_axis < 0:
        bind_core_flag = False
    # 1,满足UB大小的切分轴>concat_axis:(切分轴后面的数据/输入shape个数)32B对齐则bind
    elif split_axis > concat_axis:
        if (axis_size / (len(shapes) - 1)) % block_size == 0 and axis_num > 0:
            bind_core_flag = True
    # 2,满足UB大小的切分轴=concat_axis:
    elif split_axis == concat_axis:
        # 若切分轴是最后一根轴，第一个输入shape的最后一根轴长32B对齐，则bind
        if split_axis == axis_num - 1:
            concat_size = shapes[0][-1]
        # 若切分轴非最后一根轴，切分轴后面的数据32B对齐，则bind
        else:
            concat_size = functools_reduce(lambda i, j: i * j,
                                           res_shape[split_axis + 1:])
        # 若切分轴非最后一根轴，切分轴后面的数据32B对齐，则bind
        if concat_size % block_size == 0:
            bind_core_flag = True
    # 3,满足UB大小的切分轴<concat_axis
    else:
        bind_core_flag = _default_get_bcf(shapes, concat_axis, block_size)
    return bind_core_flag


def proc(t2c_params):  # pylint: disable=R0912
    """

    :param t2c_params:
    :return:
    """
    # lx fusion不使能多核
    l1_fusion_dict = t2c_params.op_schedule_info.l1_fusion_dict
    if l1_fusion_dict["l1_fusion_type"] in [0, 1]:
        return True

    mode = t2c_params.mode
    # 1, 对第一根切分轴前面的轴进行fuse操作
    # 目前来看，一个算子有且只会有一个Bind的Stage，多了的话就会有问题，少了也不对
    stage, stage_index = t2c_params.bind_stages[0]
    stage_name = stage.op.name

    # 前面规则处理过的stage直接跳过
    if t2c_params.proc_flag_dict.get(stage_index, False):
        log.dbg('Stage processed.')
        return True

    # concat算子走这块逻辑，判断是否绑多核，若不绑多核，直接返回True；
    # 若绑多核，继续bind操作
    if t2c_params.op_schedule_info.concat_dict:
        if not concat_bind(t2c_params, stage):
            return True

    if stage_index in t2c_params.bind_axis:
        bind_axis_info = t2c_params.bind_axis[stage_index]
    else:
        stage_axis_info = t2c_params.axis_info_list[stage_index]
        block_dim = get_bind_info(t2c_params, stage_index, stage, mode,
                                  stage_axis_info)
        if block_dim == 1:
            log.dbg('block_dim: %s', block_dim)
            return True
        bind_axis_info = stage_axis_info[0]
        # 如果block_dim为None， 判断一下bind_aixs的len，如果大于65535，则不绑多核，直接返回
        if block_dim is None and bind_axis_info.len > 65535:
            t2c_params.proc_flag_dict[stage_index] = True
            return True
    # 4，进行Bind操作
    t2c_params.code_lines.append("block = tvm.te.thread_axis('blockIdx.x')")
    code_line = "sch[%s].bind(%s, block)" % (stage_name, bind_axis_info.name)
    t2c_params.code_lines.append(code_line)
    t2c_params.proc_flag_dict[stage_index] = True

    if mode == MODE_RUNTIME:
        block = tvm.te.thread_axis('blockIdx.x')
        stage.bind(bind_axis_info.body, block)

    # 生成bind操作对应的cheque
    get_bind_cheque(t2c_params, stage_index)

    return True
