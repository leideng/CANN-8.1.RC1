#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from collections import namedtuple
from schedule_search import log
from schedule_search import soc_cfg
from schedule_search import util
from schedule_search import op_cfg
from schedule_search import comm
from schedule_search.retry_proc import add_retry_option
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.cheque_generator import get_allocate_at_cheque
from schedule_search.ts_env.cheque_generator import get_mem_uniq_cheque

FactorInfo = namedtuple('FactorInfo', 'mn_axis m_l1_factor n_l1_factor')
MatrixInfo = namedtuple('MatrixInfo', 'a_size b_size k_shape')


def get_mn_factor(t2c_params, b_l1_index, m_index):  # pylint: disable=R0912
    '''

    :param t2c_params:
    :param b_l1_index:
    :param m_index:
    :return:
    '''
    b_at_index = t2c_params.op_schedule_info.at_dict[b_l1_index]
    at_axis_info_list = t2c_params.axis_info_list[b_at_index]
    b_at_axis = t2c_params.at_targets[b_l1_index]

    after_at = False
    mn_axis_list = []
    n_index = m_index - 1
    m_l1_factor = t2c_params.schedule.stages[b_l1_index].op.axis[
        -2].dom.extent.value
    n_l1_factor = t2c_params.schedule.stages[b_l1_index].op.axis[
        -1].dom.extent.value
    for at_axis_info in at_axis_info_list:
        if at_axis_info.type == "axis":
            if at_axis_info.index == m_index:
                mn_axis_list.append(at_axis_info)
                if after_at:
                    m_l1_factor *= at_axis_info.len
            elif at_axis_info.index == n_index:
                mn_axis_list.append(at_axis_info)
                if after_at:
                    n_l1_factor *= at_axis_info.len
        if at_axis_info.name == b_at_axis.name:
            after_at = True

    log.dbg("Mm_l1_factor: %s, n_l1_factor: %s", m_l1_factor, n_l1_factor)

    return FactorInfo(mn_axis_list, m_l1_factor, n_l1_factor)


def get_mnk_shape(t2c_params, a_l0_index, b_l0_index, dtype_size):
    """

    :param t2c_params:
    :param a_l0_index:
    :param b_l0_index:
    :param dtype_size:
    :return:
    """
    m_l0_index = len(t2c_params.schedule.stages[a_l0_index].op.axis) - 4
    k_l0_index = len(t2c_params.schedule.stages[b_l0_index].op.axis) - 4
    n_l0_index = len(t2c_params.schedule.stages[b_l0_index].op.axis) - 3
    m_shape = t2c_params.schedule.stages[a_l0_index].op.axis[
        m_l0_index].dom.extent.value * t2c_params.schedule.stages[
            a_l0_index].op.axis[-2].dom.extent.value
    k_shape = t2c_params.schedule.stages[b_l0_index].op.axis[
        k_l0_index].dom.extent.value * t2c_params.schedule.stages[
            b_l0_index].op.axis[-1].dom.extent.value
    n_shape = t2c_params.schedule.stages[b_l0_index].op.axis[
        n_l0_index].dom.extent.value * t2c_params.schedule.stages[
            a_l0_index].op.axis[-1].dom.extent.value
    log.dbg("m: %s, n: %s, k: %s", m_shape, n_shape, k_shape)

    a_size = m_shape * k_shape * dtype_size
    b_size = k_shape * n_shape * dtype_size

    return MatrixInfo(a_size, b_size, k_shape)


def mn_reuse_proc(a_split_size,  # pylint: disable=R0912
                  matrix_info, l1_size, t2c_params):
    """

    :param a_split_size:
    :param matrix_info:
    :param l1_size:
    :param op_schedule_info:
    :return:
    """
    a_reuse = False
    b_reuse = False
    if a_split_size + matrix_info.b_size <= l1_size:
        if not t2c_params.op_schedule_info.option.get("disable_allocate_a",
                                                      False):
            a_reuse = True
        if not t2c_params.op_schedule_info.option.get("disable_allocate_b",
                                                      False):
            b_reuse = True
        # 两种retry选择: 1, 只使能a; 2, ab都不使能; 默认都使能的也要加进去
        retry_options = [{
            "disable_allocate_a": False,
            "disable_allocate_b": False
        }, {
            "disable_allocate_a": True,
            "disable_allocate_b": True
        }, {
            "disable_allocate_a": False,
            "disable_allocate_b": True
        }]
        add_retry_option(t2c_params.retry_t2c_rules, "allocate_at",
                         retry_options)
    elif a_split_size <= l1_size:
        if not t2c_params.op_schedule_info.option.get("disable_allocate_a",
                                                      False):
            a_reuse = True
        # 一种retry选择: 1, 不使能a
        retry_options = [{
            "disable_allocate_a": False
        }, {
            "disable_allocate_a": True
        }]
        add_retry_option(t2c_params.retry_t2c_rules, "allocate_at",
                         retry_options)
    return a_reuse, b_reuse


def nm_reuse_proc(b_split_size,  # pylint: disable=R0912
                  matrix_info, l1_size, t2c_params):
    """

    :param b_split_size:
    :param matrix_info:
    :param l1_size:
    :param op_schedule_info:
    :return:
    """
    a_reuse = False
    b_reuse = False
    if b_split_size + matrix_info.a_size <= l1_size:
        if not t2c_params.op_schedule_info.option.get("disable_allocate_a",
                                                      False):
            a_reuse = True
        if not t2c_params.op_schedule_info.option.get("disable_allocate_b",
                                                      False):
            b_reuse = True
        # 两种retry选择: 1, 只使能b; 2, ab都不使能
        retry_options = [{
            "disable_allocate_a": False,
            "disable_allocate_b": False
        }, {
            "disable_allocate_a": True,
            "disable_allocate_b": True
        }, {
            "disable_allocate_a": True,
            "disable_allocate_b": False
        }]
        add_retry_option(t2c_params.retry_t2c_rules, "allocate_at",
                         retry_options)
    elif b_split_size <= l1_size:
        if not t2c_params.op_schedule_info.option.get("disable_allocate_b",
                                                      False):
            b_reuse = True
        # 一种retry选择: 1, 不使能b
        retry_options = [{
            "disable_allocate_b": False
        }, {
            "disable_allocate_b": True
        }]
        add_retry_option(t2c_params.retry_t2c_rules, "allocate_at",
                         retry_options)
    return a_reuse, b_reuse


def get_reuse_info(t2c_params, b_l1_index, a_l0_index, b_l0_index, m_index):
    '''

    :param t2c_params:
    :param b_l1_index:
    :param a_l0_index:
    :param b_l0_index:
    :param m_index:
    :return:
    '''
    a_reuse = False
    b_reuse = False

    factor_info = get_mn_factor(t2c_params, b_l1_index, m_index)
    if not factor_info.mn_axis:
        return a_reuse, b_reuse

    dtype_size = util.get_dtype_size(
        t2c_params.schedule.stages[b_l1_index].op.output(0).dtype)
    matrix_info = get_mnk_shape(t2c_params, a_l0_index, b_l0_index, dtype_size)
    l1_size = soc_cfg.get_l1_size()
    a_split_size = factor_info.m_l1_factor * matrix_info.k_shape * dtype_size
    b_split_size = factor_info.n_l1_factor * matrix_info.k_shape * dtype_size
    if factor_info.mn_axis[0].index == m_index:
        # MN
        a_reuse, b_reuse = mn_reuse_proc(a_split_size, matrix_info, l1_size,
                                         t2c_params)
    else:
        # NM
        a_reuse, b_reuse = nm_reuse_proc(b_split_size, matrix_info, l1_size,
                                         t2c_params)

    log.dbg("a_reuse: %s, b_reuse: %s, factor_info: %s", a_reuse, b_reuse,
            factor_info)
    log.dbg("a_split_size: %s, b_split_size: %s, matrix_info: %s, l1_size: %s",
            a_split_size, b_split_size, matrix_info, l1_size)

    return a_reuse, b_reuse


def get_reuse_axis(t2c_params,  # pylint: disable=R0912
                   a_l0_index, b_l0_index):
    """

    :param t2c_params:
    :param a_l0_index:
    :param b_l0_index:
    :return:
    """
    if a_l0_index is None or b_l0_index is None:
        return None, None

    # 左右矩阵维度不同时，MN值的计算会不一样，暂不支持
    if len(t2c_params.schedule.stages[a_l0_index].op.axis) != len(
            t2c_params.schedule.stages[b_l0_index].op.axis):
        return None, None

    b_l1_index = t2c_params.op_schedule_info.real_fanin_dict[b_l0_index][0]

    a_reuse_axis = None
    b_reuse_axis = None

    # 这里默认最后一个stage的shape为N, M, 16, 16，即0轴是M
    m_index = len(t2c_params.schedule.stages[-1].op.axis) - 3
    n_index = m_index - 1

    a_reuse, b_reuse = get_reuse_info(t2c_params, b_l1_index, a_l0_index,
                                      b_l0_index, m_index)
    last_stage_index = len(t2c_params.schedule.stages) - 1
    last_stage_name = t2c_params.stages_info[last_stage_index]["name"]
    axis_info_list = t2c_params.axis_info_list[last_stage_index]
    for axis_info in axis_info_list:
        if a_reuse and axis_info.name == "%s_axis_%s_o" % (last_stage_name,
                                                           n_index):
            a_reuse_axis = axis_info
        elif b_reuse and axis_info.name == "%s_axis_%s_o" % (last_stage_name,
                                                             m_index):
            b_reuse_axis = axis_info
    return a_reuse_axis, b_reuse_axis


def do_allocate_at(t2c_params, l0_index, reuse_axis):
    """

    :param t2c_params:
    :param l0_index:
    :param reuse_axis:
    :return:
    """
    if not reuse_axis:
        return True
    log.dbg("l0_index: %s need allocate_at!", l0_index)
    l1_index = t2c_params.op_schedule_info.real_fanin_dict[l0_index][0]
    last_stage_index = len(t2c_params.schedule.stages) - 1
    last_stage = t2c_params.schedule.stages[last_stage_index]
    if t2c_params.mode == MODE_RUNTIME:
        t2c_params.schedule.stages[l1_index].allocate_at(
            last_stage, reuse_axis.body, [reuse_axis.body])
        t2c_params.schedule.stages[l1_index].mem_unique()
    stage_name = t2c_params.stages_info[l1_index]["name"]
    target_stage_name = t2c_params.stages_info[last_stage_index]["name"]
    t2c_params.code_lines.append(
        "sch[%s].allocate_at(sch[%s], %s, [%s])" %
        (stage_name, target_stage_name, reuse_axis.name, reuse_axis.name))
    reuse_axis_idx = t2c_params.axis_info_list[last_stage_index].index(
        reuse_axis)
    get_allocate_at_cheque(t2c_params, l1_index, last_stage_index,
                           reuse_axis_idx)

    t2c_params.code_lines.append("sch[%s].mem_unique()" % stage_name)
    get_mem_uniq_cheque(t2c_params, l1_index)
    t2c_params.allocate_at_list.append(l1_index)
    return True


def proc(t2c_params):  # pylint: disable=R0914, R0912
    """

    :param t2c_params:
    :return:
    """
    if t2c_params.op_schedule_info.op_name in op_cfg.RNN_OP_LIST:
        return True

    l1_fusion_dict = t2c_params.op_schedule_info.l1_fusion_dict
    a_l0_index = t2c_params.cube_info_dict.get("matrix_al0", [])
    b_l0_index = t2c_params.cube_info_dict.get("matrix_bl0", [])

    for idx in zip(a_l0_index, b_l0_index):
        a_l0, b_l0 = idx
        # 没切大K就跳过
        if not comm.is_cut_l1_k(t2c_params, a_l0):
            continue
        a_reuse_axis, b_reuse_axis = get_reuse_axis(t2c_params, a_l0, b_l0)
        # 若l1_fusion(input_l1_flag=1)，则tensor_a_l1,tensor_b_l1不做allocate_at
        if l1_fusion_dict['in_addr_type'] != 1 and \
           l1_fusion_dict['input_l1_flag'] != 1:
            do_allocate_at(t2c_params, a_l0, a_reuse_axis)
        if l1_fusion_dict['input_l1_flag'] != 1:
            do_allocate_at(t2c_params, b_l0, b_reuse_axis)
    return True
