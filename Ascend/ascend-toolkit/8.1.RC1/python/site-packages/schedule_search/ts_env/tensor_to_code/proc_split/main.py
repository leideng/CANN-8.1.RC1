#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search import comm
from schedule_search.timer import timer
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.tensor_to_code.proc_split.split_a_stage \
    import split_a_stage
from schedule_search.ts_env.tensor_to_code.proc_split.split_fused_stage \
    import split_fused_stage
from schedule_search.ts_env.tensor_to_code.proc_split. \
    split_reduce_atomic_stage import split_reduce_atomic_stage
from schedule_search.ts_env.tensor_to_code import t2c_util


@timer()
def get_attr_dict(stage):
    """

    :param stage:
    :return:
    """
    attr_dict = {}
    for attr_name, attr_value in stage.op.attrs.items():
        attr_dict[attr_name] = attr_value
    return attr_dict


def get_conv_split_vector(t2c_params, stage, curr_mad_info):
    '''
    获取conv场景下mad stage对应的切分action
    '''
    # conv场景跳过group轴
    if t2c_params.op_schedule_info.c_op not in comm.CONV_OP_ID_LIST:
        return

    # 最后一个stage没有group轴，需要放到第一维
    if stage.op.axis[0].var.name == "group.c":
        curr_mad_info["split_vector"].pop()
        curr_mad_info["split_vector"].insert(0, 0)

    # 和最后一个stage数据类型不一致时，需要特殊处理
    last_stage_dtype = curr_mad_info["at_stage"].op.output(0).dtype
    curr_dtype = stage.op.output(0).dtype
    if curr_dtype == "int32" and last_stage_dtype in ["int8", "int16"]:
        n_axis_index, _ = t2c_util.get_nm_axis_index(
            t2c_params.op_schedule_info)
        if stage.op.axis[0].var.name == "group.c":
            n_axis_index += 1
        # 最后一个stage的Co1轴大小是mad stage的一半
        curr_mad_info["split_vector"][n_axis_index] *= 2
        curr_mad_info["split_vector"][n_axis_index + t2c_util.max_axis()] *= 2


@timer()
def update_mad_info(t2c_params, stage_index, split_vector, mad_info):
    """

    :param t2c_params:
    :param stage_index:
    :param split_vector:
    :param mad_info:
    """
    intrin = t2c_params.op_schedule_info.op_intrin_key_index[
        t2c_params.features[stage_index][FeatureTensorCfg.compute_s]].intrin
    if intrin == "mad":
        mad_info.setdefault(stage_index, {})
        # 从at_target里找factor
        stages_info = t2c_params.op_schedule_info.stages_info
        at_info = stages_info[stage_index]["at_info"]
        at_index = at_info.get_at_target()
        mad_info[stage_index]["split_vector"] = t2c_params.cleaned_actions[
            at_index][ActionTensorCfg.
                      split_factor_s:ActionTensorCfg.split_factor_e + 1]
        stage = t2c_params.schedule.stages[stage_index]
        mad_info[stage_index]["at_stage"] = t2c_params.schedule.stages[-1]
        get_conv_split_vector(t2c_params, stage, mad_info[stage_index])
        # 是否切了大K
        mad_info[stage_index]["cut_K"] = split_vector[
            0] != stage.op.reduce_axis[0].dom.extent.value
        # 深度融合场景下，cut K全局一致，因此这里记录一个全局的cut K
        mad_info["cut_K"] = mad_info[stage_index]["cut_K"]


@timer('split')
def proc(t2c_params, rules):  # pylint: disable=R0914,R0912
    """
    主要输入是schedule对象、Mode、rules和inlined_stages
    主要输出是Split代码或操作，以及Split操作后的轴信息
    """
    # 输入
    stages = t2c_params.schedule.stages
    tiling_case = t2c_params.op_schedule_info.tiling_case

    # 输出
    code_lines = ['\n', '# split code']
    axis_info_list = []

    # 调用各个Rule，对Action进行清洗
    for rule in rules:
        module = __import__(rule, fromlist=['1'])
        module.proc(t2c_params)

    mad_info = {}
    cut_axis_index = 0
    for stage_index, stage in enumerate(stages):
        attr_dict = get_attr_dict(stage)
        t2c_params.stage_index = stage_index
        split_vector = t2c_params.cleaned_actions[stage_index][
            ActionTensorCfg.split_factor_s:ActionTensorCfg.split_factor_e + 1]
        update_mad_info(t2c_params, stage_index, split_vector, mad_info)

        # 如果要bind到reduce轴，tiling方案特殊处理
        if tiling_case > 0 and stage_index == len(stages) - 1:
            sub_code, stage_axis_info, cut_axis_index = \
                split_reduce_atomic_stage(t2c_params, stage_index)
            # 待处理cheque
        # 全0不切
        elif sum(split_vector) == 0:
            sub_code, stage_axis_info = [], None
        # WILLDO: 暂时compute里带了axis或reduce_axis attr的才走切分fuse的逻辑，
        #  后续再考虑自动从compute里提取
        elif "axis" in attr_dict or "reduce_axis" in attr_dict:
            sub_code, stage_axis_info = split_fused_stage(
                t2c_params, stage_index, mad_info)
        # 通用逻辑
        else:
            sub_code, stage_axis_info, cut_axis_index = split_a_stage(
                t2c_params, stage_index, mad_info)

        code_lines.extend(sub_code)
        if isinstance(stage_axis_info, list) \
                and isinstance(stage_axis_info[0], list):
            axis_info_list.extend(stage_axis_info)
        else:
            axis_info_list.append(stage_axis_info)
        t2c_params.cut_axis_index[stage_index] = cut_axis_index

    t2c_params.code_lines.extend(code_lines)
    t2c_params.axis_info_list = axis_info_list
    t2c_params.op_schedule_info.axis_info_list = axis_info_list
    t2c_params.stage_index = 0
    log.dbg('proc split ok')
    return True
