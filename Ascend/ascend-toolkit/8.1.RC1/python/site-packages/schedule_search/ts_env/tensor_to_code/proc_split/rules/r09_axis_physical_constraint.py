#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.tensor_to_code import t2c_util
from schedule_search.timer import timer


def factor_div_equally(upper_limit,  # pylint: disable=R0912
                       axis_len, cleaned_action, axis_index):
    """

    :param upper_limit:
    :param axis_len:
    :param cleaned_action:
    :param axis_index:
    :return:
    """

    # factor实际只允许[1, upper_limit], 但采样为[1, axis_len]，
    # 这里将(upper_limit, axis_len]等分clean到[1, upper_limit]
    def avg_clean_factor(factor, upper_limit, axis_len):
        """

        :param factor:
        :param upper_limit:
        :param axis_len:
        :return:
        """
        if factor <= upper_limit:
            return factor
        uint_len = (axis_len - upper_limit) // upper_limit
        if uint_len == 0:
            return upper_limit
        new_factor = (factor - upper_limit + uint_len - 1) // uint_len
        return new_factor

    axis_num = t2c_util.max_axis()
    factor_list = []
    # 只有factor2大于上限的时候，才采用等分策略，否则直接clean成上限
    need_avg_clean = False
    if cleaned_action[axis_num + axis_index] > upper_limit:
        need_avg_clean = True
    for buffer_depth in [1, 0]:
        factor_index = buffer_depth * axis_num + axis_index
        factor = cleaned_action[factor_index]
        if factor > upper_limit:
            if need_avg_clean:
                factor_list.append(
                    avg_clean_factor(factor, upper_limit, axis_len))
            else:
                factor_list.append(upper_limit)
        else:
            factor_list.append(factor)
    factor_list.reverse()
    log.dbg("factor_list: %s", factor_list)
    return factor_list


def ajust_factor(factor, upper_limit, base_list, direct=None):  # pylint: disable=R0912
    """

    :param factor:
    :param upper_limit:
    :param base_list:
    :return:
    """
    def is_align(factor, base_list):
        """

        :param factor:
        :param base_list:
        :return:
        """
        align_ret = True
        for base in base_list:
            if factor % base != 0:
                align_ret = False
                break
        return align_ret

    def up_proc(add_factor):
        '''
        向上递增处理
        '''
        if add_factor <= upper_limit:
            if is_align(add_factor, base_list):
                log.dbg("add_factor: %s is ok!", add_factor)
                return True
        return False

    def lower_proc(sub_factor):
        '''
        向下递减处理
        '''
        if sub_factor > 0:
            if is_align(sub_factor, base_list):
                log.dbg("sub_factor: %s is ok!", sub_factor)
                return True
        return False

    if direct is None:
        direct = ["up", "down"]
    # 双向查找能整除base的切分因子
    add_factor = factor - 1
    sub_factor = factor + 1
    for _ in range(max(factor + 1, upper_limit - factor + 1)):
        if "up" in direct:
            add_factor += 1
            if up_proc(add_factor):
                return add_factor
        if "down" in direct:
            sub_factor -= 1
            if lower_proc(sub_factor):
                return sub_factor
    log.dbg("ajust_factor failed, factor: %s, upper_limit: %s!", factor,
            upper_limit)
    return upper_limit


def _proc_axes(t2c_params,  # pylint: disable=R0912,R0914
               stage_index, axis_type, attr_dict):
    """

    :param t2c_params:
    :param stage_index:
    :param axis_type:
    :param attr_dict:
    :return:
    """
    stage = t2c_params.schedule.stages[stage_index]
    axis_num = t2c_util.max_axis()
    axis_info_dict = t2c_params.op_schedule_info.op_attr_dict.get('axis_info', {})
    if axis_type not in attr_dict:
        return
    axis_tag_list = attr_dict[axis_type]
    for i, axis_tag in enumerate(axis_tag_list):
        axis_tag_str = axis_tag.value.replace(' ', '')
        if axis_type == "axis":
            axis_len = stage.op.axis[i].dom.extent.value
        else:
            axis_len = stage.op.reduce_axis[i].dom.extent.value
        # 包含C0轴，必须是16的倍数
        if axis_tag_str in ["C0", "Ci0", "Co0"] \
                or "*C0" in axis_tag_str \
                or "*Ci0" in axis_tag_str \
                or "*Co0" in axis_tag_str:
            for buffer_depth in [0, 1]:
                factor_index = buffer_depth * axis_num + i
                factor = t2c_params.cleaned_actions[stage_index][
                    factor_index]
                t2c_params.cleaned_actions[stage_index][factor_index] \
                    = ajust_factor(factor, axis_len, [16])
        # HoWo，不允许切Wo，先只考虑切Ho
        elif axis_tag_str.endswith("Ho*Wo"):
            wo_value = t2c_util.get_sub_axis_len("Wo", axis_info_dict)
            ho_value = t2c_util.get_sub_axis_len("Ho", axis_info_dict)
            factor_list = factor_div_equally(
                (ho_value * wo_value + 15) // 16 * 16, axis_len,
                t2c_params.cleaned_actions[stage_index], i)
            # L1的切分Wo不允许切，Ho * Wo必须凑成16的倍数
            t2c_params.cleaned_actions[stage_index][i] = ajust_factor(
                factor_list[0], (ho_value * wo_value + 15) // 16 * 16, [wo_value, 16])
            # L0的切分clean成16的倍数
            new_factor = ajust_factor(
                factor_list[1], t2c_params.cleaned_actions[stage_index][i], [16])
            t2c_params.cleaned_actions[stage_index][axis_num + i] = new_factor
            log.dbg("HW origin factor: %s, cleaned factor: %s, %s",
                    factor_list, t2c_params.cleaned_actions[stage_index][i],
                    t2c_params.cleaned_actions[stage_index][axis_num + i])
        elif axis_tag_str.endswith("Kh*Kw"):
            kd_value = t2c_util.get_sub_axis_len("Kd", axis_info_dict)
            kh_value = t2c_util.get_sub_axis_len("Kh", axis_info_dict)
            kw_value = t2c_util.get_sub_axis_len("Kw", axis_info_dict)
            for buffer_depth in [0, 1]:
                factor_index = buffer_depth * axis_num + i
                factor = t2c_params.cleaned_actions[stage_index][factor_index]
                t2c_params.cleaned_actions[stage_index][factor_index] \
                    = ajust_factor(factor, axis_len, [kd_value * kh_value * kw_value])


@timer('r09')
def proc(t2c_params):  # pylint: disable=R0912
    """
    规则内容：各轴物理含义的约束
    """
    # 输入
    sch = t2c_params.schedule
    clean_actions = t2c_params.cleaned_actions
    axis_num = t2c_util.max_axis()
    cut_k = False
    for stage_index, stage in enumerate(sch.stages):
        if str(stage.op).startswith("placeholder"):
            continue
        if not stage.op.reduce_axis and stage_index != len(clean_actions) - 1:
            continue

        attr_dict = {}
        for attr_name, attr_value in stage.op.attrs.items():
            attr_dict[attr_name] = attr_value

        for axis_type in ["reduce_axis", "axis"]:
            _proc_axes(t2c_params, stage_index, axis_type, attr_dict)

        # 大K必切的情况下，小m和小n不切
        tag = t2c_params.features[stage_index][FeatureTensorCfg.compute_s]
        intrin = t2c_params.op_schedule_info.op_intrin_key_index[tag].intrin
        if intrin == 'mad':
            k_factor = t2c_params.cleaned_actions[stage_index][0]
            cut_k = k_factor != stage.op.reduce_axis[0].dom.extent.value

        # 考虑到oom，直接让L1的切分因子== L0的切分因子
        if cut_k and stage_index == len(clean_actions) - 1:
            t2c_params.cleaned_actions[stage_index][0] \
                = t2c_params.cleaned_actions[stage_index][axis_num]
            t2c_params.cleaned_actions[stage_index][1] \
                = t2c_params.cleaned_actions[stage_index][axis_num + 1]
