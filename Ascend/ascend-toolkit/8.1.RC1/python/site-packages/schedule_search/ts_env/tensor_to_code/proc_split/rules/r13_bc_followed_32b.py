#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search.ts_env import env_util
from schedule_search.ts_env.tensor_to_code import t2c_util
from schedule_search import log
from schedule_search.timer import timer


def get_right_factor(sample_factor,
                     get_right_factor_info_list
                     ):  # pylint: disable=R0912
    """
    get_right_factor
    :param get_right_factor_info_list:
    :param sample_factor:
    :return:
    """
    axis_len, block_dim, axis_len_after_cut_axis, \
    tail_align, factor_align = get_right_factor_info_list

    # 整吃的时候不用整除block_dim
    def _check_factor(curr_factor):  # pylint: disable=R0912
        """
        _check_factor
        :param curr_factor:
        :return:
        """
        tail_align_ok = False
        factor_align_ok = False

        if curr_factor % block_dim == 0:
            factor_align_ok = True

        reminder = axis_len % curr_factor
        # 整除时，只需要满足最小数据块是32B对齐
        if reminder == 0 \
                and curr_factor * axis_len_after_cut_axis % block_dim == 0:
            tail_align_ok = True
            factor_align_ok = True
        elif reminder != 0 \
                and reminder * axis_len_after_cut_axis % block_dim == 0:
            tail_align_ok = True

        if tail_align and not tail_align_ok:
            return False

        if factor_align and not factor_align_ok:
            return False

        return True

    if _check_factor(sample_factor):
        return sample_factor

    while True:
        # 向上向下调整factor，直到factor能整除block_dim
        add_factor = sample_factor
        sub_factor = sample_factor
        for _ in range(max(sample_factor + 1, axis_len - sample_factor + 1)):
            # 向上找一次
            if add_factor < axis_len:
                add_factor += 1
                if _check_factor(add_factor):
                    return add_factor

            if sub_factor > 1:
                sub_factor -= 1
                if _check_factor(add_factor):
                    return sub_factor

            if add_factor == axis_len and sub_factor == 1:
                return add_factor


def get_factor_tail_align(split_axis_index,  # pylint: disable=R0912
                          broadcast_axis, rnb):
    """
    get_factor_tail_align
    :param split_axis_index:
    :param broadcast_axis:
    :param rnb:
    :return:
    """
    first_no_bc_cut_axis = split_axis_index
    factor_align = False
    tail_align = False
    if split_axis_index in broadcast_axis:
        # reduce+broadcast场景，切分因子也要32B对齐，此处规则还不精确
        if rnb:
            factor_align = True
        tmp_cut_axis = None
        for i in range(split_axis_index):
            if i not in broadcast_axis:
                tmp_cut_axis = i
                break
        if tmp_cut_axis is not None:
            first_no_bc_cut_axis = tmp_cut_axis
        else:
            first_no_bc_cut_axis = None

    # 如果第一根非broadcast切分轴之前有broadcast轴，需要clean
    if first_no_bc_cut_axis is not None:
        for i in range(first_no_bc_cut_axis):
            if i in broadcast_axis:
                tail_align = True
                break
    return factor_align, tail_align


def clean_proc(t2c_params, stage_index, broadcast_axis, rnb):
    """
    clean_proc
    :param t2c_params:
    :param stage_index:
    :param broadcast_axis:
    :param rnb:
    :return:
    """
    # 拿到切分轴
    split_axis_index = t2c_util.get_split_axis(t2c_params, stage_index)
    factor_align, tail_align = get_factor_tail_align(split_axis_index,
                                                     broadcast_axis, rnb)
    if not tail_align and not factor_align:
        return

    sample_factor = t2c_params.cleaned_actions[stage_index][split_axis_index]
    shape = t2c_params.schedule.stages[stage_index].op.output(0).shape
    len_after_split_axis = 1
    for i in range(split_axis_index + 1, len(shape)):
        len_after_split_axis *= int(shape[i])

    stage_obj = t2c_params.schedule.stages[stage_index]
    block_dim = env_util.get_block_num(stage_obj.op.output(0).dtype)
    cleaned_factor = get_right_factor(sample_factor, [
        stage_obj.op.axis[split_axis_index].dom.extent.value, block_dim,
        len_after_split_axis, tail_align, factor_align
    ])
    log.dbg("%s axis[%s] clean to %s!", stage_obj, split_axis_index,
            cleaned_factor)
    t2c_params.cleaned_actions[stage_index][split_axis_index] = cleaned_factor


@timer('r13')
def proc(t2c_params):  # pylint: disable=R0912
    """
    规则内容：如果只有一根轴进行reduce后又broadcast回来，at的stage切分因子需要32b对齐
    """

    if not t2c_params.op_schedule_info.broadcast_dict.get('info'):
        return

    # reduce atomic不处理
    if t2c_params.op_schedule_info.tiling_case > 0:
        return

    last_stage = len(t2c_params.stages_info) - 1

    # 找到第一个切分的普通轴，如果前面有broadcast axis
    # 1， 如果能整除，切分的最小块要32B对齐
    # 2，如果不能整除，尾块要32B对齐
    all_fanins = t2c_params.op_schedule_info.all_fanin_dict[last_stage]
    broadcast_axis = []
    # 获取所有的broadcast axis
    rnb = False
    for broadcast_index in t2c_params.op_schedule_info.broadcast_dict['info']:
        if broadcast_index in all_fanins:
            broadcast_axis.extend(
                t2c_params.op_schedule_info.broadcast_dict['info']
                [broadcast_index]['axis'])
            if t2c_params.op_schedule_info.broadcast_dict['info'][
                    broadcast_index].get('reduce', []):
                rnb = True

    broadcast_axis.sort()
    sch = t2c_params.schedule
    stages_info = t2c_params.stages_info
    stages = list(sch.stages)

    for stage_index in range(len(stages)):
        stage_info = stages_info[stage_index]
        if "workspace" not in stage_info.get('type', []):
            continue
        clean_proc(t2c_params, stage_index, broadcast_axis, rnb)

    clean_proc(t2c_params, last_stage, broadcast_axis, rnb)
