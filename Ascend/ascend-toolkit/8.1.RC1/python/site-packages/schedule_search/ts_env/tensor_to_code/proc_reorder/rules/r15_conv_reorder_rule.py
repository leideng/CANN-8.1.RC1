#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search import comm
import schedule_search.ts_env.tensor_to_code.t2c_util as t2c_util
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg


def last_stage_reorder(stage_axis_list, t2c_params, stage_index):
    '''
    最后一个stage的reorder规则
    '''
    # Conv默认都有batch，最后一个stage默认取第一根轴
    batch_axis_info = stage_axis_list[0]

    # 将其放在最前面，如果已经在leveled_axis中，先将其删除
    stage_leveled_axis = t2c_params.leveled_axis_for_reorder[stage_index]
    for leveled_axis in stage_leveled_axis:
        if batch_axis_info in leveled_axis:
            leveled_axis.remove(batch_axis_info)

    t2c_params.leveled_axis_for_reorder[stage_index][
        t2c_util.AXIS_LEVEL_OO_INDEX].insert(0, batch_axis_info)


def reform_stage_reorder(stage_axis_list, t2c_params, stage_index):
    '''
    reform_by_vector stage的reorder规则
    '''
    last_inner_axis_info = stage_axis_list[-1]

    # 将其放在最前面，如果已经在leveled_axis中，先将其删除
    stage_leveled_axis = t2c_params.leveled_axis_for_reorder[stage_index]
    for leveled_axis in stage_leveled_axis:
        if last_inner_axis_info in leveled_axis:
            leveled_axis.remove(last_inner_axis_info)

    t2c_params.leveled_axis_for_reorder[stage_index][
        t2c_util.AXIS_LEVEL_C_INDEX].append(last_inner_axis_info)


def mad_stage_reorder(stage_axis_list, t2c_params, stage_index):
    '''
    mad对应stage的reorder规则
    '''
    # 根据轴名字找到batch轴group轴，有规则cover是不会切分的
    batch_axis_info = None
    group_axis_info = None
    for axis_info in stage_axis_list:
        if axis_info.type != "axis":
            continue
        axis_name = t2c_params.schedule.stages[stage_index].op.axis[
            axis_info.index].var.name
        if axis_name == "group.c":
            group_axis_info = axis_info
        elif axis_name == "batch.c":
            batch_axis_info = axis_info
    log.dbg('batch_axis_info: %s, group_axis_info: %s', batch_axis_info,
            group_axis_info)

    # 将其放在最前面，如果已经在leveled_axis中，先将其删除
    stage_leveled_axis = t2c_params.leveled_axis_for_reorder[stage_index]
    for leveled_axis in stage_leveled_axis:
        if batch_axis_info in leveled_axis:
            leveled_axis.remove(batch_axis_info)
        if group_axis_info in leveled_axis:
            leveled_axis.remove(group_axis_info)

    t2c_params.leveled_axis_for_reorder[stage_index][
        t2c_util.AXIS_LEVEL_I_II_NORMAL_INDEX].insert(0, batch_axis_info)
    if group_axis_info:
        t2c_params.leveled_axis_for_reorder[stage_index][
            t2c_util.AXIS_LEVEL_OO_INDEX].insert(0, group_axis_info)


def proc(t2c_params):
    '''
    规则内容：conv的group轴不参与reorder，放在最外面；
             mad stage的batch轴放在内层轴的第一个，最后一个stage则不做reorder
    '''
    if t2c_params.op_schedule_info.c_op not in comm.CONV_OP_ID_LIST:
        return

    stages_info = t2c_params.op_schedule_info.stages_info
    for stage_index, stage_axis_list in enumerate(t2c_params.axis_info_list):
        stage_info = stages_info[stage_index]
        stage_type = stage_info.get('type', [])
        if 'placeholder' in stage_type or stage_axis_list is None:
            continue

        intrin = t2c_params.op_schedule_info.op_intrin_key_index[
            t2c_params.features[stage_index][
                FeatureTensorCfg.compute_s]].intrin
        if intrin == 'mad':
            mad_stage_reorder(stage_axis_list, t2c_params, stage_index)
        elif stage_info["tag"] in t2c_util.QUANT_SERIES_TAGS:
            reform_stage_reorder(stage_axis_list, t2c_params, stage_index)
        elif "l1fuse_leaf" in stage_type:
            # l1fuse_leaf L1层的reorder以最后一个stage为准
            last_stage_reorder(stage_axis_list, t2c_params, stage_index)
        elif stage_index == len(t2c_params.axis_info_list) - 1:
            last_stage_reorder(stage_axis_list, t2c_params, stage_index)
