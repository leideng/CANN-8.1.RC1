#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search import comm
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.tensor_to_code import t2c_util as util
from schedule_search.ts_env.cheque_generator import get_emit_insn_cheque


def get_emit_insn_axis( # pylint: disable=R0912,R0913,R0914
        stage,
        stage_index,
        axis_info_list,
        compute,
        reduce_axis_dict,
        stage_name):
    """

    :param stage:
    :param stage_index:
    :param axis_info_list:
    :param compute:
    :param reduce_axis_dict:
    :param stage_name:
    :return:
    """
    emit_insn_axis = None
    emit_insn_axis_obj = None
    axis_num = 0
    curr_axis_info_list = axis_info_list[stage_index]

    # 说明没有轴操作，需要查看他at target的轴信息
    if curr_axis_info_list is None:
        emit_insn_axis = "sch[%s].op.axis[0]" % stage_name
        emit_insn_axis_obj = stage.op.axis[0]
        return axis_num, emit_insn_axis, emit_insn_axis_obj

    # 本身有轴操作，且还at到别的stage，这种认为是reduce轴切分，
    # 需要结合at target的axis轴切分
    if stage.op.reduce_axis:
        if compute.endswith(util.REDUCE_LAST_KEYWORD):
            # 多根reduce轴
            reduce_axis_list = reduce_axis_dict[stage_index]["axis"]
            if len(reduce_axis_list) > 1:
                # 如果连续取第一个，不连续取最后一个
                ret = util.is_reduce_axis_continuous(
                    stage.op.input_tensors[0].shape, reduce_axis_list)
                if ret is True:
                    reduce_axis_num = len(stage.op.reduce_axis)
                else:
                    reduce_axis_num = 1
            else:
                # 受IR限制，取reduce轴做emit_insn
                reduce_axis_num = 1
            emit_insn_axis = curr_axis_info_list[-reduce_axis_num].name
            emit_insn_axis_obj = curr_axis_info_list[-reduce_axis_num].body
        elif compute.endswith(util.REDUCE_NIST_KEYWORD):
            # 取第一个_0结尾的axis
            for i, axis_info in enumerate(curr_axis_info_list):
                axis_name = axis_info.name
                if axis_name.endswith("_0"):
                    emit_insn_axis = axis_name
                    emit_insn_axis_obj = axis_info.body
                    axis_num = i
                    break
        else:
            # 取第一个不是_o结尾的axis
            for i, axis_info in enumerate(curr_axis_info_list):
                axis_name = axis_info.name
                if not axis_name.endswith("_o"):
                    emit_insn_axis = axis_name
                    emit_insn_axis_obj = axis_info.body
                    axis_num = i
                    break

    log.dbg(' stage_name: %s, emit_insn_axis: %s', stage_name, emit_insn_axis)
    return axis_num, emit_insn_axis, emit_insn_axis_obj


def proc(t2c_params):  # pylint: disable=R0914,R0912
    """

    :param t2c_params:
    :return:
    """
    features = t2c_params.features
    stage_index = t2c_params.stage_index
    stage_name = t2c_params.stage_name
    stage = t2c_params.stage
    axis_info_list = t2c_params.axis_info_list
    mode = t2c_params.mode
    proc_sch = bool(mode == MODE_RUNTIME)
    tiling_case = t2c_params.op_schedule_info.tiling_case

    # 前面规则处理过的stage直接跳过
    if t2c_params.proc_flag_dict.get(stage_index, False):
        return True

    intrinsic_func_name = t2c_params.op_schedule_info.op_intrin_key_index[
        features[stage_index][FeatureTensorCfg.compute_s]].intrin
    if not util.need_move_emit_insn_axis(intrinsic_func_name):
        return True

    reduce_axis_dict = t2c_params.op_schedule_info.reduce_axis_dict
    compute = t2c_params.op_schedule_info.op_intrin_key_index[
        features[stage_index][FeatureTensorCfg.compute_s]].op_tag
    axis_num, emit_insn_axis, emit_insn_axis_obj = get_emit_insn_axis(
        stage, stage_index, axis_info_list, compute, reduce_axis_dict,
        stage_name)

    # 挪轴放到storage align之后再决定，暂时先不添加到t2c_params.code_lines中，
    # 但是atomic除外
    tsrz_line = "sch[%s].emit_insn(%s, '%s')" % (stage_name, emit_insn_axis,
                                                 intrinsic_func_name)
    if tiling_case > 0 or t2c_params.op_schedule_info.c_op in \
            comm.MAD_OP_ID_LIST:
        if proc_sch:
            stage.emit_insn(emit_insn_axis_obj, intrinsic_func_name)
        t2c_params.code_lines.append(tsrz_line)

        # 生成emit_insn对应的cheque
        get_emit_insn_cheque(t2c_params, stage_index, intrinsic_func_name,
                             (emit_insn_axis, axis_num))
    else:
        emit_insn_dict = {
            "stage_name": stage_name,
            "axis": emit_insn_axis,
            "axis_index": axis_num,
            "axis_obj": emit_insn_axis_obj,
            "intrin": intrinsic_func_name,
            "code": tsrz_line,
        }
        t2c_params.op_schedule_info.emit_insn_code_dict[stage_index] \
            = emit_insn_dict
    t2c_params.proc_flag_dict[stage_index] = True
    return True
