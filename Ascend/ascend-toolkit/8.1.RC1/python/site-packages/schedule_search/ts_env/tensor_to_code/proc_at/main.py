#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import json
import copy
from schedule_search import log
from schedule_search.timer import timer
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.cheque_generator import get_stage_index
from schedule_search.ts_env.cheque_generator import get_at_cheque
from schedule_search.ts_env.cheque_generator import get_split_cheque
from schedule_search.ts_env import depend
from schedule_search import op_cfg
from schedule_search.ts_env.tensor_cfg import AxisInfo
from schedule_search.ts_env.tensor_cfg import SplitInfo
from tbe import tvm


def split_axis_for_sub_bind(t2c_params, code_lines):

    op_name = t2c_params.op_name
    sch = t2c_params.schedule
    stages_info = t2c_params.stages_info
    at_targets = t2c_params.at_targets
    at_axis_infos = t2c_params.axis_info_list[-1]

    split_stage_axis, split_stage_axis_index, split_stage_name = \
        get_split_stage_info(sch.stages, at_axis_infos, op_name, at_targets)

    if split_stage_axis_index == -1:
        return False, SplitInfo(None, split_stage_name, split_stage_axis_index)

    # sub_block split codeline + schedule
    update_h_stage_name = stages_info[-1]['name']
    sub_block_factor = op_cfg.get_sub_block_factor()
    code_lines.append(
        '%s_so, %s_si = sch[%s].split(%s, nparts=%d)' %
        (split_stage_axis.name, split_stage_axis.name, update_h_stage_name, split_stage_axis.name, sub_block_factor))
    axis_obj_o, axis_obj_i = None, None
    if t2c_params.mode == MODE_RUNTIME:
        axis_obj_o, axis_obj_i = t2c_params.schedule.stages[-1].split(
            split_stage_axis.body, nparts=sub_block_factor)

    # update axis info
    del at_axis_infos[split_stage_axis_index]

    at_axis_infos.insert(
        split_stage_axis_index,
        AxisInfo('%s_si' % split_stage_axis.name, split_stage_axis.len // sub_block_factor, 'axis',
                 split_stage_axis.index, 'i', axis_obj_i))
    at_axis_infos.insert(
        split_stage_axis_index,
        AxisInfo('%s_so' % split_stage_axis.name, sub_block_factor, 'axis',
                 split_stage_axis.index, 'o', axis_obj_o))

    # gen split cheque
    at_index = len(t2c_params.schedule.stages) - 1

    get_split_cheque(t2c_params, at_index, split_stage_axis_index, sub_block_factor, "nparts")
    return True, SplitInfo(split_stage_axis, split_stage_name, split_stage_axis_index)


def runtime_proc(t2c_params, stage_index, stage, target_stage, target_axis):
    """

    :param t2c_params:
    :param stage_index:
    :param stage:
    :param target_stage:
    :param target_axis:
    """
    at_target_obj = None
    # 获取实际的at_target对象
    for tmp_stage_index, tmp_stage in enumerate(t2c_params.schedule.stages):
        tmp_stage_name = t2c_params.stages_info[tmp_stage_index]['name']
        if tmp_stage_name == target_stage:
            at_target_obj = tmp_stage
            t2c_params.op_schedule_info.at_dict[stage_index] = tmp_stage_index
            break
    log.dbg("stage_name: %s, stage: %s, target_stage: %s, at_target_obj: %s, "
            "target_axis: %s", t2c_params.stages_info[stage_index]['name'],
            stage, target_stage, at_target_obj, target_axis)
    stage.compute_at(at_target_obj, target_axis.body)


def get_split_tensor_name(outs, split_tag):
    """
    获取分离前所有节点并输出
    """
    operation_list = copy.deepcopy(outs)
    split_tensor_name = set()

    while operation_list:
        tmp_operation_list = []
        for current_tensor in operation_list:
            current_op = current_tensor.op
            current_name = current_op.name

            if current_name in split_tensor_name:
                log.dbg("tensor:%s has been visited", current_tensor.op.name)
                continue
            split_tensor_name.add(current_name)
            # placeholder not split
            if isinstance(current_op, tvm.PlaceholderOp):
                continue
            for i in range(len(current_op.input_tensors)):
                input_tensor = current_op.input_tensors[i]
                # only visit not reached split_tag node
                if split_tag not in input_tensor.op.tag:
                    tmp_operation_list.append(input_tensor)
        operation_list = list(set(tmp_operation_list))
    return split_tensor_name


def is_need_update(target_axis, split_axis):
    return target_axis.name == split_axis.name


def get_stage_type(stage, visited_name_tensor, split_stage_name):
    if is_stage_vector(stage, visited_name_tensor):
        return op_cfg.SplitStageType.VECTOR
    if is_stage_cube(stage, split_stage_name):
        return op_cfg.SplitStageType.SPLIT
    return op_cfg.SplitStageType.DEFAULT


def is_stage_vector(stage, visited_name_tensor):
    return stage.op.name in visited_name_tensor


def is_stage_cube(stage, split_stage_name):
    return stage.op.name == split_stage_name


def update_target_axis(split_stage_axis_index, at_axis_infos, stage_type):
    # orignal
    # o io ii
    #   ↑
    #   c && v at
    #
    # update: cut c at axis
    # o io_so io_si ii
    # ↑       ↑
    # c at    v at
    offset = op_cfg.SPLIT_AT_AXIS_OFFSET.get(stage_type, 0)
    return at_axis_infos[split_stage_axis_index + offset]


def cube_vector_split_stage_name(stage_key):
    return op_cfg.CUBE_VECTOR_SPLIT_STAGE.get(stage_key, "")


def get_split_stage_index_by_name(stages, split_stage_name):
    for stage_index, stage in enumerate(stages):
        if split_stage_name in stage.op.name:
            return stage_index
    return -1


def get_split_axis_info(at_axis_infos, at_targets, split_stage_index):
    for i, axis in enumerate(at_axis_infos):
        if axis.name == at_targets[split_stage_index].name:
            return i, axis
    return -1, None


def get_split_stage_info(stages, at_axis_infos, op_name, at_targets):
    split_stage_name = cube_vector_split_stage_name(op_name)
    split_stage_index = get_split_stage_index_by_name(stages, split_stage_name)
    if split_stage_index == -1:
        return None, -1, split_stage_name
    split_stage_axis_index, split_stage_axis = get_split_axis_info(at_axis_infos, at_targets, split_stage_index)

    return split_stage_axis, split_stage_axis_index, split_stage_name


def stage_at_axis_proc(t2c_params, code_lines):
    sch = t2c_params.schedule
    mode = t2c_params.mode
    stages_info = t2c_params.stages_info
    l1_fusion_dict = t2c_params.op_schedule_info.l1_fusion_dict
    at_targets = t2c_params.at_targets
    at_dict = copy.deepcopy(t2c_params.op_schedule_info.at_dict)

    op_name = t2c_params.op_name

    at_axis_infos = t2c_params.axis_info_list[-1]

    if op_cfg.is_support_split(op_name):
        stage_tag = op_cfg.CUBE_STAGE_TAG.get(op_name, "reserved")
        visited_name_tensor = get_split_tensor_name([sch.stages[-1]], stage_tag)

        enable_split, split_info = \
            split_axis_for_sub_bind(t2c_params, code_lines)

    def is_l1_fusion(l1_fusion_dict, stage):
        return (l1_fusion_dict['input_l1_flag'] == 1 and
            (stage.op.name.endswith('.local.L1_Fusion') or
             stage.op.name == 'tensor_a_l1.local.L1')) or \
                str(stage.op).startswith("placeholder")

    for stage_index, stage in enumerate(sch.stages):
        # l1_fusion_dict(['input_l1_flag']=1),tensor_a.local.L1_Fusion和
        # tensor_a_l1.local.L1不做compute_at
        if is_l1_fusion(l1_fusion_dict, stage):
            continue
        stage_name = stages_info[stage_index]['name']
        target_axis = at_targets[stage_index]
        if target_axis is not None:
            if op_cfg.is_support_split(op_name) and enable_split and \
                    is_need_update(target_axis, split_info.split_stage_axis):
                stage_type = get_stage_type(stage, visited_name_tensor, split_info.split_stage_name)
                target_axis = update_target_axis(split_info.split_stage_axis_index, at_axis_infos, stage_type)

            target_stage = target_axis.name.split('_reduce')[0].split(
                '_axis')[0]
            code_line = 'sch[%s].compute_at(sch[%s], %s)' % (
                stage_name, target_stage, target_axis.name)
            log.dbg("code_line: %s", code_line)
            code_lines.append(code_line)
            if mode == MODE_RUNTIME:
                runtime_proc(t2c_params, stage_index, stage, target_stage,
                             target_axis)

            # 生成compute_at对应的cheque
            target_stage_index = get_stage_index(stages_info, target_stage)

            # at target 所在轴在其所有轴中的位置
            target_axis_index = 0
            for i, axis_info in enumerate(
                    t2c_params.axis_info_list[target_stage_index]):
                if axis_info.name == target_axis.name:
                    target_axis_index = i
                    break
            get_at_cheque(t2c_params, stage_index, target_stage_index,
                          target_axis_index)

    for at_axis, ated in t2c_params.op_schedule_info.at_dict.items():
        if at_axis and ated:
            code_lines.append("#%s at %s" %
                              (t2c_params.stages_info[at_axis]['name'],
                               t2c_params.stages_info[ated]['name']))
    log.dbg("proc at done, code_lines: %s", "\n".join(code_lines))
    t2c_params.code_lines.extend(code_lines)
    t2c_params.op_schedule_info.at_dict = at_dict


@timer('compute_at')
def proc(t2c_params, rules):  # pylint: disable=R0914,R0912
    """

    :param t2c_params:
    :param rules:
    :return:
    """
    sch = t2c_params.schedule
    mode = t2c_params.mode
    code_lines = []
    stages_info = t2c_params.stages_info
    l1_fusion_dict = t2c_params.op_schedule_info.l1_fusion_dict
    t2c_params.fanout_sub_tree = depend.get_fanout_sub_tree_indices(
        t2c_params.features)
    t2c_params.code_lines.extend(['\n', '# compute_at code'])
    at_dict = copy.deepcopy(t2c_params.op_schedule_info.at_dict)

    # dump compute at的信息，用于debug manual build from action
    ori_at_dict_str = '# compute_at_dict:' + json.dumps(
        t2c_params.op_schedule_info.ori_at_dict)
    code_lines.extend(['\n', ori_at_dict_str])

    # 调用各个Rule，获取at_targets
    for rule in rules:
        module = __import__(rule, fromlist=['1'])
        ret = module.proc(t2c_params)
        # 有规则获取到at_targets即可
        if ret:
            break

    stage_at_axis_proc(t2c_params, code_lines)

    return True
