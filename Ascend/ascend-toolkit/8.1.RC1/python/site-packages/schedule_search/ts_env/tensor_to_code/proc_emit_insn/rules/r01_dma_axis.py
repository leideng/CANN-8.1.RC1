#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search import comm
from schedule_search.op_cfg import TIK_TO_DSL_OP_LIST
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.tensor_to_code import atomic_comm
from schedule_search.ts_env.cheque_generator import get_emit_insn_cheque
from schedule_search.ts_env.cheque_generator import get_pragma_cheque
from schedule_search.ts_env.cheque_generator import get_bind_buffer_cheque
from schedule_search.ts_env.cheque_generator import get_reuseby_cheque
from schedule_search.ts_env.tensor_to_code.proc_reuse.rules.\
    comm import get_reuse_index


def get_layer_num(stage, op_layer_num):
    """

    :param stage:
    :param op_layer_num:
    :return:
    """
    stage_name = stage.op.name
    if stage_name.endswith(".local.L0A") \
            or stage_name.endswith(".local.L0B") \
            or stage_name.endswith(".local.L0C"):
        return 1
    if stage_name.endswith(".local.L1"):
        return 0

    if op_layer_num == 1:
        return 0

    return 1


def get_no_split_dma_axis(stage):
    '''
    对不切分的stage，根据tag选择相应的轴
    '''
    if stage.op.tag in [
            "dequant_vector", "requant_vector", "dequant_s16_vector",
            "data_transfer"
    ]:
        return 2
    return 0


def get_dma_axis(  # pylint: disable=R0912
        stage,
        curr_axis_info_list,
        stage_name):
    """
    pre build时获取pragma轴编号
    :param stage:
    :param curr_axis_info_list:
    :param stage_name:
    :return:
    """
    emit_insn_axis_obj = None

    # 非叶子stage、叶子分叉stage、中间输出stage
    if curr_axis_info_list is None or stage.op.tag in ["data_transfer"]:
        axis_num = 0
        insn_axis_index = get_no_split_dma_axis(stage)
        emit_insn_axis_obj = stage.op.axis[insn_axis_index]
        emit_insn_axis = "sch[%s].op.axis[%s]" % (stage_name, insn_axis_index)
        return axis_num, emit_insn_axis, emit_insn_axis_obj

    # 叶子stage、叶子分叉stage、中间输出stage
    for i, axis_info in enumerate(curr_axis_info_list):
        axis_name = axis_info.name
        for axis_ends in ["_ii", "_i"]:
            if axis_name.endswith(axis_ends):
                emit_insn_axis_obj = curr_axis_info_list[i].body
                return i, axis_name, emit_insn_axis_obj

    log.warn(
        "Pragma axis not found for stage_name:%s,  "
        "curr_axis_info_list:%s !", stage_name, curr_axis_info_list)

    return 0, None, None


def reuse_pragma_proc(t2c_params,  # pylint: disable=R0912
                      reuse_stage_index, dma_axis_obj, axis_num, dma_axis):
    """
    老的pragma的方式reuse原语
    :param t2c_params:
    :param reuse_stage_index:
    :param dma_axis_obj:
    :param axis_num:
    :param dma_axis:
    :return:
    """
    proc_sch = bool(t2c_params.mode == MODE_RUNTIME)
    stages_info = t2c_params.stages_info
    reuse_stage = t2c_params.schedule.stages[reuse_stage_index]
    reuse_stage_name = stages_info[reuse_stage_index]['name']
    reuse_dma_axis_num, reuse_dma_axis, reuse_dma_axis_obj = get_dma_axis(
        reuse_stage,
        t2c_params.axis_info_list[reuse_stage_index],
        reuse_stage_name)

    reuse_index = get_reuse_index(t2c_params, reuse_stage_index)
    if proc_sch:
        if reuse_stage_name not in t2c_params.reused_input_list:
            reuse_stage.pragma(reuse_dma_axis_obj, 'reuse_input', reuse_index)
        t2c_params.stage.pragma(dma_axis_obj, 'replace_output', reuse_index)
        t2c_params.stage.emit_insn(dma_axis_obj, "phony_insn")

    if reuse_stage_name not in t2c_params.reused_input_list:
        t2c_params.code_lines.append(
            "sch[%s].pragma(%s, '%s', %s)" %
            (reuse_stage_name, reuse_dma_axis, "reuse_input", reuse_index))
        # 生成pragma对应的cheque
        get_pragma_cheque(t2c_params, reuse_stage_index, "reuse_input",
                          (reuse_dma_axis, reuse_dma_axis_num), reuse_index)
        t2c_params.reused_input_list.append(reuse_stage_name)
    t2c_params.code_lines.append(
        "sch[%s].pragma(%s, '%s', %s)" %
        (t2c_params.stage_name, dma_axis, "replace_output", reuse_index))
    # 生成pragma对应的cheque
    get_pragma_cheque(t2c_params, t2c_params.stage_index, "replace_output",
                      (dma_axis, axis_num), reuse_index)


def need_reused_by(reuse_src_index, reuse_dst_index, t2c_params):
    """

    :param reuse_src_index:
    :param reuse_dst_index:
    :param t2c_params:
    :return:
    """
    reuse_src_stage = t2c_params.schedule.stages[reuse_src_index]
    if reuse_src_stage.op.tag == "out_to_ub":
        return True

    if reuse_src_stage.op.tag == "elewise_single_cast":
        fanout_list = t2c_params.op_schedule_info.real_fanout_dict[
            reuse_dst_index]
        fanout_stage = t2c_params.schedule.stages[fanout_list[0]]
        if fanout_stage.op.tag != "elewise_single_cast":
            return False
        if reuse_src_stage.op.input_tensors[0].dtype == fanout_stage.op.output(
                0).dtype and fanout_stage.op.input_tensors[
                    0].dtype == reuse_src_stage.op.output(0).dtype:
            return True

    return False


def reused_by_proc(t2c_params,  # pylint: disable=R0914,R0912
                   reuse_stage_index):
    """
    reused_by原语
    :param t2c_params:
    :param reuse_stage_index:
    :return:
    """
    # 获取重用的stage
    reuse_src_index = reuse_dst_index = reuse_stage_index
    reused_by_info = None
    for _ in range(1, len(t2c_params.schedule.stages), 1):
        fanout_list = t2c_params.op_schedule_info.real_fanout_dict[
            reuse_src_index]
        fanin_list = t2c_params.op_schedule_info.real_fanin_dict[
            reuse_dst_index]
        if not fanout_list or not fanin_list:
            break
        reuse_src_index = fanout_list[0]
        reuse_src_stage = t2c_params.schedule.stages[reuse_src_index]
        reuse_src_stage_name = t2c_params.stages_info[reuse_src_index]['name']
        reuse_dst_index = fanin_list[0]
        reuse_dst_stage = t2c_params.schedule.stages[reuse_dst_index]
        reuse_dst_stage_name = t2c_params.stages_info[reuse_dst_index]['name']
        if not need_reused_by(reuse_src_index, reuse_dst_index, t2c_params):
            break

        log.dbg("src: %s, dst: %s", reuse_src_stage_name, reuse_dst_stage_name)
        stage_name = t2c_params.stages_info[reuse_src_index]["name"]
        axis_num, dma_axis, dma_axis_obj = get_dma_axis(
            reuse_src_stage, t2c_params.axis_info_list[reuse_src_index],
            stage_name)
        if t2c_params.mode == MODE_RUNTIME:
            reuse_src_stage.emit_insn(dma_axis_obj, "phony_insn")
        # reused_by的源stage映射为空指令
        t2c_params.code_lines.append("sch[%s].emit_insn(%s, 'phony_insn')" %
                                     (reuse_src_stage_name, dma_axis))
        # 生成emit_insn对应的cheque
        get_emit_insn_cheque(t2c_params, reuse_src_index, 'phony_insn',
                             (dma_axis, axis_num))
        t2c_params.proc_flag_dict[reuse_src_index] = True
        reused_by_info = (reuse_src_index, reuse_dst_index)

    if reused_by_info:
        reuse_src_index, reuse_dst_index = reused_by_info
        reuse_src_stage = t2c_params.schedule.stages[reuse_src_index]
        reuse_src_stage_name = t2c_params.stages_info[reuse_src_index]['name']
        reuse_dst_stage = t2c_params.schedule.stages[reuse_dst_index]
        reuse_dst_stage_name = t2c_params.stages_info[reuse_dst_index]['name']
        if t2c_params.mode == MODE_RUNTIME:
            reuse_src_stage.reused_by(reuse_dst_stage.op.output(0))
            reuse_dst_stage.reused_by(reuse_data=True)
        t2c_params.code_lines.append(
            "sch[%s].reused_by(%s)" %
            (reuse_dst_stage_name, reuse_src_stage_name))
        t2c_params.code_lines.append("sch[%s].reused_by(reuse_data=True)" %
                                     (reuse_src_stage_name))
        # 生成reused_by对应的cheque
        get_reuseby_cheque(t2c_params,
                           reuse_dst_index,
                           dst_stage_index=reuse_src_index)
        get_reuseby_cheque(t2c_params, reuse_src_index, reuse_data=True)


def get_reuse_info(fanin_stage_indices, virtual_leaf_out, stages_info):
    '''
    判断当前节点是否需要reuse，并返回需要reuse的stage index
    '''
    reuse = False
    reuse_stage_index = None
    # 虚节点不需要reuse
    if virtual_leaf_out:
        return reuse, reuse_stage_index
    for fanin_stage_index in fanin_stage_indices:
        try:
            fanin_stage_types = stages_info[fanin_stage_index].get('type', [])
            # 需要输出的非叶子stage
            if 'inter_out' in fanin_stage_types:
                reuse = True
                reuse_stage_index = fanin_stage_index
                break
        # 是PlaceHolder,是否需要启用Reuse？
        except ValueError:
            continue
        finally:
            pass
    return reuse, reuse_stage_index


def determine_no_need_dma_copy(t2c_params):
    stages_info = t2c_params.stages_info
    features = t2c_params.features
    stage_index = t2c_params.stage_index
    intrin = t2c_params.op_schedule_info.op_intrin_key_index[
        features[stage_index][FeatureTensorCfg.compute_s]].intrin

    # RL_transpose
    if t2c_params.op_schedule_info.option.get('op_type') in TIK_TO_DSL_OP_LIST.keys():
        return True

    if intrin != 'dma_copy':
        return True

    if stages_info[stage_index].get('tag') == 'mad_add_bias':
        return True

    return False


def proc(t2c_params):  # pylint: disable=R0912,R0914,R0915
    """

    :param t2c_params:
    :return:
    """
    mode = t2c_params.mode
    stage_index = t2c_params.stage_index
    sch = t2c_params.schedule
    stage = t2c_params.stage
    stage_name = t2c_params.stage_name
    stages_info = t2c_params.stages_info
    l1_fusion_dict = t2c_params.op_schedule_info.l1_fusion_dict
    stages = list(sch.stages)
    c_op = t2c_params.op_schedule_info.c_op

    proc_sch = bool(mode == MODE_RUNTIME)

    if determine_no_need_dma_copy(t2c_params):
        return True

    # Stage的名字
    stage_info = stages_info[stage_index]
    reduce_atomic = 'reduce_atomic' in stage_info.get('type', [])
    virtual_leaf_out = 'virtual_leaf_out' in stage_info.get('type', [])
    if "reduce_atomic_write" in stage_info.get('type', []):
        _, emit_insn_axis_info = atomic_comm.get_reduce_atomic_write_axis(
            t2c_params, stage_index)
        axis_num = emit_insn_axis_info.index
        dma_axis = emit_insn_axis_info.name
        dma_axis_obj = emit_insn_axis_info.body
    else:
        axis_num, dma_axis, dma_axis_obj = get_dma_axis(
            stage,
            t2c_params.axis_info_list[stage_index],
            stage_name)

    # 需要输出的非叶子stage，要重用cache
    fanin_stage_indices = t2c_params.op_schedule_info.real_fanin_dict[
        stage_index]
    reuse, reuse_stage_index = get_reuse_info(fanin_stage_indices,
                                              virtual_leaf_out, stages_info)
    if reuse:
        if t2c_params.schedule.stages[reuse_stage_index].op.tag == "ub_to_out":
            reused_by_proc(t2c_params, reuse_stage_index)
        else:
            reuse_pragma_proc(t2c_params, reuse_stage_index, dma_axis_obj,
                              axis_num, dma_axis)
            # 复用的cache read映射为空指令
            t2c_params.code_lines.append(
                "sch[%s].emit_insn(%s, 'phony_insn')" % (stage_name, dma_axis))
            # 生成emit_insn对应的cheque
            get_emit_insn_cheque(t2c_params, stage_index, 'phony_insn',
                                 (dma_axis, axis_num))
    elif reduce_atomic or virtual_leaf_out or (
            l1_fusion_dict['input_l1_flag'] == 1
            and stage_name == 'tensor_a_l1_l'):
        log.dbg("l1_fusion(input_l1_flag=1), emit_insn instrin: phony_insn")
        # reduce_atomic、virtual_leaf_out、l1_fusion(input_l1_flag=1)映射空指令
        if proc_sch:
            stage.emit_insn(dma_axis_obj, 'phony_insn')
        t2c_params.code_lines.append("sch[%s].emit_insn(%s, 'phony_insn')" %
                                     (stage_name, dma_axis))

        # 生成emit_insn的cheque
        get_emit_insn_cheque(t2c_params, stage_index, 'phony_insn',
                             (dma_axis, axis_num))
    else:
        # eltwise的l1 fusion，若eltwise+write_select融合
        # 最后输出tensor在emit insn前做bind buffer，只支持5HD，绑在C1轴上
        if l1_fusion_dict['l1_fusion_type'] == 0 \
                and stage_name.find("write_select") >= 0 \
                and l1_fusion_dict['eltwise_res_name'] == stage_name \
                and len(stage.op.output(0).shape) == 5:
            hwc0 = stage.op.attrs["HWC0"].value
            bind_axis_num = 1
            if proc_sch:
                stage.bind_buffer(stage.op.axis[1], hwc0, 0)
            t2c_params.code_lines.append(
                "sch[%s].bind_buffer(sch[%s].op.axis[%s], %s, 0)" %
                (stage_name, stage_name, bind_axis_num, hwc0))
            # 生成bind_buffer的cheque
            get_bind_buffer_cheque(t2c_params, stage_index, bind_axis_num,
                                   hwc0, 0)
        if proc_sch:
            stage.emit_insn(dma_axis_obj, "dma_copy")
        log.dbg("pragma axis for %s: %s, axis_num:%s", stage.op.name, dma_axis,
                axis_num)

        t2c_params.code_lines.append("sch[%s].emit_insn(%s, 'dma_copy')" %
                                     (stage_name, dma_axis))

        # 生成emit_insn的cheque
        get_emit_insn_cheque(t2c_params, stage_index, 'dma_copy',
                             (dma_axis, axis_num))

    pragma_insn_flag = c_op in comm.MAD_OP_ID_LIST and stage_index == len(stages) - 1
    if pragma_insn_flag:
        # pragma json_info_cache_read_mode
        pragma_type = 'json_info_cache_read_mode'
        pragma_value = 0
        t2c_params.code_lines.append(
            "sch[%s].pragma(%s, '%s', %s)" %
            (stage_name, dma_axis, pragma_type, pragma_value))
        if proc_sch:
            stage.pragma(dma_axis_obj, pragma_type, pragma_value)
        get_pragma_cheque(t2c_params, stage_index, pragma_type,
                          (dma_axis, axis_num), pragma_value)

    t2c_params.proc_flag_dict[stage_index] = True
    return True
