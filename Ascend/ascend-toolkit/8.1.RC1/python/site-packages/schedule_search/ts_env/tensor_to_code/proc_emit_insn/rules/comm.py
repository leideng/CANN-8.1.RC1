#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log


def cosine_embedding_loss_insn(stage_name, stage_axis_info_list):
    '''
    针对cosine_embedding_loss的emit insn规则
    '''
    # 取第一个不是_o结尾的axis
    axis_index = -1
    for i, axis_info in enumerate(stage_axis_info_list):
        axis_name = axis_info.name
        if axis_name.endswith("_io") or axis_name.endswith("_o"):
            next_axis = stage_axis_info_list[i + 1]
            if next_axis.name.endswith("_io") or next_axis.name.endswith("_o"):
                continue
            axis_index = i
            break
    axis_num = axis_index + 1
    emit_insn_axis = stage_axis_info_list[axis_num].name
    emit_insn_axis_obj = stage_axis_info_list[axis_num].body
    log.dbg(' stage_name: %s, emit_insn_axis: %s', stage_name, emit_insn_axis)
    return axis_num, emit_insn_axis, emit_insn_axis_obj


def get_no_split_insn_axis(stage_tag):
    '''
    对不切分的stage，根据tag选择相应的轴
    '''
    if stage_tag in ["set_fmatrix", "im2col"]:
        return 1
    if stage_tag in ["requant_s16_data_transfer"]:
        return 2
    return 0


def get_emit_insn_axis(  # pylint: disable=R0912
        stage,
        stage_index,
        axis_info_list,
        stage_info,
        op_name=None):
    """

    :param stage:
    :param stage_index:
    :param axis_info_list:
    :param stage_name:
    :return:
    """
    emit_insn_axis = None
    emit_insn_axis_obj = None
    axis_num = 0
    curr_axis_info_list = axis_info_list[stage_index]
    stage_name = stage_info["name"]

    # 说明没有轴操作，需要查看他at target的轴信息
    if curr_axis_info_list is None or stage.op.tag in ["requant_s16_data_transfer"]:
        insn_axis_index = get_no_split_insn_axis(stage_info["tag"])
        emit_insn_axis = "sch[%s].op.axis[%s]" % (stage_name, insn_axis_index)
        emit_insn_axis_obj = stage.op.axis[insn_axis_index]
        return axis_num, emit_insn_axis, emit_insn_axis_obj

    # 先针对cosine_embedding_loss特殊处理，后续取代后面的逻辑
    if op_name in ["cosine_embedding_loss"]:
        return cosine_embedding_loss_insn(stage_name, curr_axis_info_list)

    # 取第一个不是_o结尾的axis
    for i, axis_info in enumerate(curr_axis_info_list):
        axis_name = axis_info.name
        if axis_name.endswith("_io") or axis_name.endswith("_o"):
            continue
        emit_insn_axis = axis_name
        emit_insn_axis_obj = axis_info.body
        axis_num = i
        break

    log.dbg(' stage_name: %s, emit_insn_axis: %s', stage_name, emit_insn_axis)
    return axis_num, emit_insn_axis, emit_insn_axis_obj


def get_buffer_info(buffer_shape, buffer_stride):  # pylint: disable=R0912
    """

    :param buffer_shape:
    :param buffer_stride:
    :return:
    """
    buffer_info_list = []
    shape_dim = len(buffer_shape)
    slice_list = []
    for shape_index in range(0, shape_dim):
        # 首尾特殊处理一下
        if shape_index == 0:
            slice_list = [int(buffer_shape[shape_index])]
        if shape_index == shape_dim - 1:
            buffer_info_list.append(slice_list)
            break

        curr_stride = int(buffer_stride[shape_index])
        expect_stride = int(buffer_shape[shape_index + 1])
        expect_stride *= int(buffer_stride[shape_index + 1])
        if curr_stride in [expect_stride]:
            # 当前维度和下一个维度连续，直接把下一个维度的shape加入slice_list
            slice_list.append(int(buffer_shape[shape_index + 1]))
        elif expect_stride in [0]:
            # broadcast时，可能勾取出的stride为0，这里规避下curr_stride为0时，
            # 认为是连续的
            slice_list.append(int(buffer_shape[shape_index + 1]))
        else:
            # 当前维度和下一个维度不是连续的，将当前slice_list保存至buffer_info_list，
            # 并重新初始化slice_list
            buffer_info_list.append(slice_list)
            slice_list = [int(buffer_shape[shape_index + 1])]
    log.dbg("buffer_shape: %s, buffer_stride: %s, buffer_info_list: %s",
            buffer_shape, buffer_stride, buffer_info_list)
    return buffer_info_list


def get_emit_insn_axis_move_step(buffer_shape, buffer_info_list):
    """

    :param buffer_shape:
    :param buffer_info_list:
    :return:
    """
    # 迭代1无脑挪轴处理（vector指令只处理连续数据），后续待扩展
    return len(buffer_shape) - len(buffer_info_list[-1])


def get_moved_axis(stage, axis_num, curr_axis_info_list, move_step,
                   stage_name):
    """

    :param stage:
    :param axis_num:
    :param curr_axis_info_list:
    :param move_step:
    :param stage_name:
    :return:
    """
    axis_num_updated = axis_num + move_step
    if curr_axis_info_list:
        # reduce nist，最后一根轴不切，切倒数第二根轴时会走到此处
        axis_info = curr_axis_info_list[axis_num_updated]
        emit_insn_axis = axis_info.name
        emit_insn_axis_obj = axis_info.body
        return emit_insn_axis, emit_insn_axis_obj

    emit_insn_axis = "sch[%s].op.axis[%d]" % (stage_name, axis_num_updated)
    emit_insn_axis_obj = stage.op.axis[axis_num_updated]
    return emit_insn_axis, emit_insn_axis_obj


def need_dichotomy_add(  # pylint: disable=R0912
        loop_size,
        last_axis_size,
        dtype):
    """

    :param loop_size:
    :param last_axis_size:
    :param dtype:
    :return:
    """
    if dtype == "float16":
        vector_inst_one_repeat_size = 128
        dtype_size = 2
    elif dtype == "float32":
        vector_inst_one_repeat_size = 64
        dtype_size = 4
    else:
        return False
    block_size = 32
    if last_axis_size > vector_inst_one_repeat_size:
        return False
    if vector_inst_one_repeat_size % last_axis_size != 0:
        return False
    if last_axis_size * dtype_size % block_size != 0:
        return False
    if loop_size is not None and loop_size // vector_inst_one_repeat_size < 2:
        return False
    log.dbg("need_dichotomy_add")
    return True
