#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import copy
from schedule_search import log
from schedule_search import soc_cfg
from schedule_search import op_cfg
from schedule_search.ts_env.env_consts import MODE_RUNTIME
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.ts_env.tensor_cfg import AxisInfo
from schedule_search.ts_env.tensor_cfg import INVALID_AT_AXIS
from schedule_search.ts_env.tensor_to_code.t2c_util import MULTICORE_POSTFIX
from schedule_search.ts_env.tensor_to_code.t2c_util import BROADCAST_AT_POSTFIX
from schedule_search.ts_env.tensor_to_code.t2c_util import COMMON_AT_POSTFIX
from schedule_search.ts_env.tensor_to_code.t2c_util import TMP_POSTFIX
from schedule_search.ts_env.cheque_generator import get_split_cheque


def get_depend_child_stages(t2c_params, stage_index):  # pylint: disable=R0912
    """

    :param t2c_params:
    :param stage_index:
    :return:
    """
    final_child_stages = []
    tmp_child_stages = t2c_params.op_schedule_info.real_fanout_dict[
        stage_index]

    # 找到不同分支上，依赖的子stage，每条分支：
    # 1，子stage是当前stage at的stage, 分支break
    # 2，子stage是inline的stage，继续往下查询
    # 3，子stage at的stage与当前stage at的stage相同
    at_stage_index = t2c_params.op_schedule_info.at_dict[stage_index]
    while True:
        cur_child_stages = []
        for child_stage in tmp_child_stages:
            child_at_stage = t2c_params.op_schedule_info.at_dict.get(
                child_stage)
            if child_at_stage == at_stage_index:
                # child stage与stage at的target相同，则是依赖的stage
                final_child_stages.append(child_stage)
            elif child_stage != at_stage_index:
                # child stage与stage at的target不同，而且child stage不是
                # 当前stage的at target，需要继续向下找
                cur_child_stages.extend(
                    t2c_params.op_schedule_info.real_fanout_dict[child_stage])

        if not cur_child_stages:
            break
        tmp_child_stages = copy.deepcopy(cur_child_stages)

    return final_child_stages


def get_my_at_target(my_at_choices, broadcast=False):  # pylint: disable=R0912
    """
    1, broadcast 优先保证多核，at到broadcast_o
    2, 其他情况，优先保证继承for循环，at到common_o
    """
    commont_at_axis = None
    broadcast_at_axis = None
    origin_at_axis = None
    # 可以at到broadcast_o
    for at_choice in my_at_choices:
        if at_choice.name.endswith(BROADCAST_AT_POSTFIX):
            broadcast_at_axis = at_choice
        elif at_choice.name.endswith(COMMON_AT_POSTFIX):
            commont_at_axis = at_choice
        elif not at_choice.name.endswith(MULTICORE_POSTFIX):
            origin_at_axis = at_choice

    # 如果是broadcast，优先at到broadcast
    if broadcast and broadcast_at_axis is not None:
        return broadcast_at_axis

    if commont_at_axis:
        return commont_at_axis

    if broadcast_at_axis:
        return broadcast_at_axis

    return origin_at_axis


def get_at_choices_from_axis_info(axis_infos):
    """

    :param axis_infos:
    :return:
    """
    at_axis_infos = [axis for axis in axis_infos if axis.name.endswith('o')]

    index_list = []
    for axis_info in at_axis_infos:
        if axis_info.index not in index_list:
            index_list.append(axis_info.index)

    at_choices = []
    for _ in range(len(index_list)):
        at_choices.append([])

    for axis_info in at_axis_infos:
        pos = index_list.index(axis_info.index)
        at_choices[pos].append(axis_info)

    return at_choices


def get_multicore_split_nparts(clean_at,  # pylint: disable=R0912
                               at_choices, at_axis_info,
                               split_twice):
    """

    :param clean_at:
    :param at_choices:
    :param at_axis_info:
    :param split_twice:
    :return:
    """
    if not split_twice:
        return at_axis_info.len

    product = 1
    # at轴之前
    for i in range(clean_at):
        for axis_info in at_choices[i]:
            product *= axis_info.len

    # 如果at轴之前的o轴乘积小于或等于核数的一半
    core_num = soc_cfg.get_core_num()
    nparts = 1
    if product <= core_num:
        nparts = core_num // product

    # 如果nparts大于当前at的axis的o轴的轴长，直接取o轴轴长
    if nparts > at_axis_info.len:
        nparts = at_axis_info.len

    return nparts


def _split_twice(t2c_params,  # pylint: disable=R0914
                 at_index, index, axis_name, nparts):
    """

    :param t2c_params:
    :param at_index:
    :param index:
    :param axis_name:
    :param nparts:
    :return:
    """
    at_axis_infos = t2c_params.axis_info_list[at_index]
    at_axis_info = at_axis_infos[index]
    stage_name = t2c_params.stages_info[at_index]['name']
    stage = t2c_params.schedule.stages[at_index]
    axis_type = 'o'
    # 第一刀， 切出axis_oo用于和前面的o轴fuse后绑定多核
    axis_multicore_o = axis_name + MULTICORE_POSTFIX
    axis_tmp_o = axis_name + TMP_POSTFIX
    t2c_params.code_lines.append('%s, %s = sch[%s].split(%s, nparts=%d)' %
                                 (axis_multicore_o, axis_tmp_o, stage_name,
                                  at_axis_info.name, nparts))

    axis_bc_at_o = axis_name + BROADCAST_AT_POSTFIX
    axis_common_at_o = axis_name + COMMON_AT_POSTFIX
    # 第二刀， 切出axis_n1_o用于at
    t2c_params.code_lines.append(
        '%s, %s = sch[%s].split(%s, nparts=%d)' %
        (axis_bc_at_o, axis_common_at_o, stage_name, axis_tmp_o, 1))

    axis_obj_oo, axis_obj_oi, axis_obj_n1_o, axis_obj_oi_o \
        = None, None, None, None
    if t2c_params.mode == MODE_RUNTIME:
        axis_obj_oo, axis_obj_oi = stage.split(at_axis_info.body,
                                               nparts=nparts)
        axis_obj_n1_o, axis_obj_oi_o = stage.split(axis_obj_oi, nparts=1)
    del at_axis_infos[index]
    at_axis_infos.insert(
        index,
        AxisInfo(axis_common_at_o, at_axis_info.len // nparts, 'axis',
                 at_axis_info.index, axis_type, axis_obj_oi_o))
    at_axis_infos.insert(
        index,
        AxisInfo(axis_bc_at_o, 1, 'axis', at_axis_info.index, axis_type,
                 axis_obj_n1_o))
    at_axis_infos.insert(
        index,
        AxisInfo(axis_multicore_o, nparts, 'axis', at_axis_info.index,
                 axis_type, axis_obj_oo))

    # 生成split_nparts对应的cheque
    get_split_cheque(t2c_params, at_index, index, nparts, "nparts")
    get_split_cheque(t2c_params, at_index, index + 1, 1, "nparts")


def _split_once(t2c_params,  # pylint: disable=R0913,R0914
                at_index, index, axis_name, nparts,
                inner_postfix, outer_postfix, oo_type=False):
    """

    :param t2c_params:
    :param at_index:
    :param index:
    :param axis_name:
    :param nparts:
    :param inner_postfix:
    :param outer_postfix:
    :return:
    """
    at_axis_infos = t2c_params.axis_info_list[at_index]
    at_axis_info = at_axis_infos[index]
    stage_name = t2c_params.stages_info[at_index]['name']
    stage = t2c_params.schedule.stages[at_index]
    axis_type = 'o'
    axis_oo = axis_name + outer_postfix
    axis_o = axis_name + inner_postfix
    t2c_params.code_lines.append(
        '%s, %s = sch[%s].split(%s, nparts=%d)' %
        (axis_oo, axis_o, stage_name, at_axis_info.name, nparts))
    axis_obj_oo, axis_obj_o = None, None
    if t2c_params.mode == MODE_RUNTIME:
        axis_obj_oo, axis_obj_o = stage.split(at_axis_info.body,
                                              nparts=nparts)

    del at_axis_infos[index]
    at_axis_infos.insert(
        index,
        AxisInfo(axis_o, at_axis_info.len // nparts, 'axis',
                 at_axis_info.index, axis_type, axis_obj_o))
    if oo_type:
        axis_type = "oo"
    at_axis_infos.insert(
        index,
        AxisInfo(axis_oo, nparts, 'axis', at_axis_info.index, axis_type,
                 axis_obj_oo))

    # 生成split_nparts对应的cheque
    get_split_cheque(t2c_params, at_index, index, nparts, "nparts")


def _get_ori_index(t2c_params, at_index, clean_at):
    """

    :param t2c_params:
    :param at_index:
    :param clean_at:
    :return:
    """
    if t2c_params.reorder_axis_map.get(at_index, {}).get(clean_at) \
            is not None:
        ori_index = t2c_params.reorder_axis_map[at_index][clean_at]
    else:
        ori_index = clean_at
    return ori_index


def do_extra_split(t2c_params,  # pylint: disable=R0912,R0914,R0915
                   at_index, clean_at):
    """

    :param t2c_params:
    :param at_index:
    :param clean_at:
    :return:
    """
    # 如果是reduce,且reduce at的stage的axis与reduce的stage不相同
    at_axis_infos = t2c_params.axis_info_list[at_index]

    inner_postfix = COMMON_AT_POSTFIX
    # -1表示在0轴之外再切一个npart=1的外轴
    split_twice = False
    if clean_at == -1:
        at_axis_info = at_axis_infos[0]
        nparts = 1
        outer_postfix = BROADCAST_AT_POSTFIX
        axis_name = at_axis_info.name
    elif at_index == len(t2c_params.schedule.stages) - 1:
        # 整除时需要再切，用于bind
        ori_index = _get_ori_index(t2c_params, at_index, clean_at)
        at_stage = t2c_params.schedule.stages[at_index]
        axis_len = at_stage.op.axis[ori_index].dom.extent.value
        factor = t2c_params.cleaned_actions[at_index][ori_index]
        if axis_len % factor != 0:
            return clean_at

        at_choices = get_at_choices_from_axis_info(at_axis_infos)
        my_at_choices = at_choices[clean_at]

        outer_postfix = MULTICORE_POSTFIX
        inner_postfix = COMMON_AT_POSTFIX
        at_axis_info = None
        for at_choice in my_at_choices:
            if at_choice.name.endswith(outer_postfix) \
               or at_choice.name.endswith(inner_postfix):
                return clean_at
            if at_choice.name.endswith('_o'):
                at_axis_info = at_choice

        # at轴是broadcast轴，需要对o轴切两次：
        # 1）最外层_multicore_o, 用于和前面的o轴fuse之后使能多核
        # 2）中间 broadcast_o, 用于broadcast的stage at
        # 3）内层 inherit_o, 用于broadcast无关的stage，尽可能的继成切分
        for bc_group in t2c_params.stages_info[at_index].\
                get('broadcast_groups', []):
            if t2c_params.reorder_axis_map.get(at_index, {}).\
               get(clean_at) in bc_group:
                split_twice = True
                break

        nparts = get_multicore_split_nparts(clean_at, at_choices, at_axis_info,
                                            split_twice)
        axis_name = at_axis_info.name
    else:
        return clean_at

    if axis_name.endswith("_o"):
        axis_name = axis_name[:-2]

    index = at_axis_infos.index(at_axis_info)

    if split_twice:
        _split_twice(t2c_params, at_index, index, axis_name, nparts)
    else:
        _split_once(t2c_params,
                    at_index, index, axis_name, nparts,
                    inner_postfix, outer_postfix)
    return clean_at


def need_avoid_redundancy(t2c_params, stage_index, at_stage, at_axis):
    """

    :param t2c_params:
    :param stage_index:
    :param at_stage:
    :param at_axis:
    :return:
    """
    # at的axis是reorder后, -1表示at到第一个轴的oo轴，其实第一根轴
    if at_axis == -1:
        at_axis = 0

    at_axis_index = t2c_params.reorder_axis_map.get(at_stage, {}).get(at_axis)
    if at_axis_index is None:
        return False

    # 获取当前stage后的broadcast stage
    if at_axis_index in t2c_params.stages_info[stage_index].\
            get('followed_bc_info', []):
        return True

    return False


def inherit_at(fanouts, at_targets):
    """

    :param fanouts:
    :param at_targets:
    :return:
    """
    for fanout in fanouts:
        if at_targets[fanout] is not None:
            return at_targets[fanout]

    return None


def is_special_stage(t2c_params, stage_index, at_index):
    """
    针对输出节点，且后面跟着切分轴长度不相等的虚节点做去冗余特殊处理
    """
    stage_type = t2c_params.stages_info[stage_index].get('type', [])
    fanout_index = t2c_params.op_schedule_info.real_fanout_dict[stage_index]
    fanout_type = t2c_params.stages_info[fanout_index[0]].get('type', [])
    if "origin_leaf_out" in stage_type and "virtual_leaf_out" in fanout_type:
        last_cut_axis = t2c_params.last_cut_axis_index.get(at_index)
        cut_axis = t2c_params.axis_info_list[at_index][last_cut_axis]
        stages = t2c_params.op_schedule_info.schedule_obj.stages
        if stages[stage_index].op.axis[
                cut_axis.index].dom.extent.value != stages[
                    fanout_index[0]].op.axis[cut_axis.index].dom.extent.value:
            return True

    return False


def get_at_axis(stage_index,  # pylint: disable=R0911,R0912,R0914
                t2c_params, at_targets):
    """
    获取stage at的axis index
    返回值：1，是否是特殊的stage, 特殊stage是指broadcast相关的stage，
    at轴选择时要考虑避免冗余
            2，at的axis index（reorder之后的index）
    """
    stages_info = t2c_params.stages_info
    at_dict = t2c_params.op_schedule_info.at_dict
    at_index = at_dict[stage_index]

    # 1.at到reduce stage, at到切分的reduce轴
    ori_cut_index = t2c_params.cut_axis_index[at_index]

    # axis 可能会进行多次切分，切完后at到哪个，根据是否避免冗余计算来决策
    if 'reduce' in stages_info[at_index].get('type', []):
        return False, ori_cut_index

    # axis 可能会进行多次切分, 切完后at到last_cut_axis
    if t2c_params.op_schedule_info.option.get('op_type') in op_cfg.TIK_TO_DSL_OP_LIST.keys() and \
            t2c_params.last_cut_axis_index.get(at_index):
        return False, t2c_params.last_cut_axis_index[at_index]

    # 2.算子没有broadcast, at到切分轴
    broadcast_info = t2c_params.op_schedule_info.broadcast_dict['info']
    if not broadcast_info:
        return False, ori_cut_index

    # 3. 算子有broadcast，通过采样或继承
    at_axis = t2c_params.cleaned_actions[stage_index][ActionTensorCfg.at_s]
    if at_axis == INVALID_AT_AXIS:
        at_info = inherit_at(
            t2c_params.op_schedule_info.real_fanout_dict[stage_index],
            at_targets)
        # 优先继承fanout的at
        if at_info is not None:
            return at_info
        # fanout没有则往后最后一根切分轴at
        last_cut_axis = t2c_params.last_cut_axis_index.get(at_index)
        if last_cut_axis is not None:
            if is_special_stage(t2c_params, stage_index, at_index):
                return True, last_cut_axis
            return False, last_cut_axis
        return False, ori_cut_index

    # 根据当前stage的broadcast info决定是否需要避免冗余计算
    avoid_redundancy = need_avoid_redundancy(t2c_params, stage_index, at_index,
                                             at_axis)
    return avoid_redundancy, at_axis


def clean_align_at(stage_index, clean_at, t2c_params):
    """
    stage at的轴不能超过fanouts at的轴
    """
    at_stage_index = t2c_params.op_schedule_info.at_dict[stage_index]
    my_at_choices = get_at_choices_from_axis_info(
        t2c_params.axis_info_list[at_stage_index])

    if clean_at >= len(my_at_choices):
        clean_at = len(my_at_choices) - 1

    # 获取stage at目标相同的后续stage
    if t2c_params.op_schedule_info.option.get("at_align", True):
        depend_stages = get_depend_child_stages(t2c_params, stage_index)
        for child_index in depend_stages:
            if clean_at > t2c_params.cleaned_actions[child_index][
                    ActionTensorCfg.at_s]:
                clean_at = t2c_params.cleaned_actions[child_index][
                    ActionTensorCfg.at_s]

    return clean_at


def _ensure_at(t2c_params, reversed_stages, at_dict, at_targets):
    """

    :param t2c_params:
    :param reversed_stages:
    :param at_dict:
    :param at_targets:
    :return:
    """
    special_stages = []
    last_stage = len(reversed_stages) - 1
    stage_num = len(reversed_stages)
    for reverse_index, stage in enumerate(reversed_stages):
        stage_index = stage_num - reverse_index - 1
        if str(stage.op).startswith("placeholder"):
            t2c_params.cleaned_actions[stage_index][ActionTensorCfg.at_s] = \
                INVALID_AT_AXIS
            continue

        # at target为 None, inline的stages
        at_stage_index = at_dict.get(stage_index)
        if at_stage_index is None:
            t2c_params.cleaned_actions[stage_index][ActionTensorCfg.at_s] = \
                INVALID_AT_AXIS
            continue

        # 根据依赖关系更新clean_at
        avoid_redundancy, at_axis = get_at_axis(stage_index, t2c_params,
                                                at_targets)
        log.dbg(
            'stage_index:%s, stage_name:%s, \
                avoid_redundancy:%s, at_axis:%s', stage_index, stage.op.name,
            avoid_redundancy, at_axis)

        # 特殊的stage，选择at轴时需要避免冗余计算
        if avoid_redundancy and at_stage_index == last_stage:
            special_stages.append(stage_index)

        # 根据依赖关系对at axis进行clean
        clean_at = clean_align_at(stage_index, at_axis, t2c_params)
        t2c_params.cleaned_actions[stage_index][
            ActionTensorCfg.at_s] = clean_at

        t2c_params.update_ated_axis_index(at_stage_index, clean_at)
        at_targets[stage_index] = (avoid_redundancy, clean_at)
    return special_stages


def _ensure_at_axis(t2c_params,  # pylint: disable=R0914,R0912
                    reversed_stages, at_dict, at_targets, special_stages):
    """

    :param t2c_params:
    :param reversed_stages:
    :param at_dict:
    :param at_targets:
    :param special_stages:
    :return:
    """
    stage_num = len(reversed_stages)
    axis_info_list = t2c_params.axis_info_list
    for reverse_index in range(stage_num):
        stage_index = stage_num - reverse_index - 1
        clean_at = t2c_params.cleaned_actions[stage_index][
            ActionTensorCfg.at_s]

        if clean_at == INVALID_AT_AXIS:
            at_targets[stage_index] = None
            continue

        at_stage_index = at_dict[stage_index]
        my_at_choices = get_at_choices_from_axis_info(
            axis_info_list[at_stage_index])
        at_choice_index = clean_at if clean_at != -1 else 0

        # 如果fanout at的axis index与当前stage相同，则at的轴必须在前面
        depended_stages = get_depend_child_stages(t2c_params, stage_index)
        if at_choice_index > len(my_at_choices) - 1:
            at_choice_index = len(my_at_choices) - 1

        max_offset = len(my_at_choices[at_choice_index]) - 1
        for depended_stage in depended_stages:
            depend_at_index = t2c_params.cleaned_actions[depended_stage][
                ActionTensorCfg.at_s]
            # at到-1，实际是第一根轴，index = 0
            if depend_at_index == -1:
                depend_at_index = 0

            if depend_at_index != at_choice_index:
                continue

            at_offset = my_at_choices[at_choice_index].index(
                at_targets[depended_stage])
            if at_offset < max_offset:
                max_offset = at_offset

        at_choices = my_at_choices[at_choice_index][:max_offset + 1]

        special = stage_index in special_stages
        at_targets[stage_index] = get_my_at_target(at_choices, special)


def proc(t2c_params):  # pylint: disable=R0912,R0914,R0915
    """
    规则内容：获取每个stage的at到的axis，存入at_targets
    """
    # 输入
    sch = t2c_params.schedule
    features = t2c_params.features
    at_dict = t2c_params.op_schedule_info.at_dict
    stage_num = len(features)
    at_choices = []
    for _ in range(stage_num):
        at_choices.append([])

    # 从下往上推导at的关系
    at_targets = [None] * stage_num
    reversed_stages = list(sch.stages)
    reversed_stages.reverse()

    # 第一次循环，确定at
    last_stage = len(reversed_stages) - 1
    special_stages = _ensure_at(
        t2c_params, reversed_stages, at_dict, at_targets)

    # 最后一个stage,需要进行额外的切分，用于多核; at到-1用于避免冗余计算
    for at_stage_index in t2c_params.ated_axis_index:
        at_axis_index = t2c_params.ated_axis_index[at_stage_index]
        if at_axis_index == -1 or at_stage_index == last_stage:
            do_extra_split(t2c_params, at_stage_index, at_axis_index)

    # at的axis如果有多个选择，记录at的偏移，用于保证前后依赖关系
    _ensure_at_axis(t2c_params, reversed_stages, at_dict, at_targets,
                    special_stages)

    t2c_params.at_targets = at_targets
    return True
