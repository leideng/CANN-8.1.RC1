#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search.ts_env.tensor_to_code.proc_storage_align.rules import comm


def proc(input_dict, output_dict):  # pylint: disable=R0912,R0914
    """
    规则内容：非reduce_last的align规则
        对包含pragma下所有轴的tensor有要求，对齐轴是数据连续的起始轴axis
        这根轴要在dst和src都连续
    """
    expr_type = input_dict["expr_type"]
    expr_info = input_dict["expr_info"]
    name_fanin_list, index_fanin_list = input_dict["fanin_list"]
    dst_stage_index = input_dict["stage_index"]
    update_align_dict = output_dict["update_align_dict"]

    if expr_type in ["elementwise", "broadcast_last", "broadcast_nist", "reduce_nist", "dma_copy"]:
        dst_tensor_name = expr_info["dst"][0]["stage_name"]

        # broadcast_last只对dst和包含最后一根轴的src有对齐要求
        if expr_type == "broadcast_last":
            need_align_tensor_list = expr_info["dst"]
            for src_tensor in expr_info["src"]:
                # broadcast last可能有两个src
                # 对没有last轴的tensor没有要求，有最后一根轴的tensor还是有要求的
                last_emit_axis = expr_info["emit_insn_axis_list"][-1]
                if last_emit_axis in src_tensor["axis_var_list"]:
                    need_align_tensor_list.append(src_tensor)
        elif expr_type in ["dma_copy", "phony_insn"]:
            need_align_tensor_list = []
            for tensor in expr_info["src"] + expr_info["dst"]:
                if ".local." in tensor["stage_name"]:
                    need_align_tensor_list.append(tensor)
        # 其他场景对dst和src都有要求
        else:
            need_align_tensor_list = expr_info["src"] + expr_info["dst"]

        # 拿到各个tensor数据连续的起始轴
        all_upper_align_axis_list = []
        for tensor in need_align_tensor_list:
            # 根据表达式信息的stride，并计算得到数据连续的起始轴axis（从后往前）
            upper_align_reduce_axis = comm.get_upper_align_axis(
                expr_info, tensor, expr_type, reduce_flag=False)
            all_upper_align_axis_list.append(upper_align_reduce_axis)

        if not all_upper_align_axis_list:
            return
        # 得到上述连续轴中最内层的作为对齐轴
        final_upper_align_axis = max(all_upper_align_axis_list)
        if not final_upper_align_axis:
            return
        # 对有对齐要求的tensor更新对齐轴
        for tensor in need_align_tensor_list:
            stage_name = tensor["stage_name"]
            if stage_name in name_fanin_list:
                stage_index = index_fanin_list[name_fanin_list.index(stage_name)]
            else:
                stage_index = dst_stage_index
            update_align_dict.setdefault(stage_index, []).append({
                "tensor_name": dst_tensor_name,
                "stage_index": dst_stage_index,
                "axis_var": final_upper_align_axis
            })

            log.dbg(
                "r01 stage:%s expr_type:%s need stage:%s align to %s, "
                "stage_index: %s", dst_tensor_name, expr_type, stage_name,
                final_upper_align_axis, stage_index)
