#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import base64
import datetime
import json
import os

from schedule_search import log
from schedule_search import soc_cfg
from schedule_search import util
from schedule_search.ts_env.estimator.evb import evb_host
from schedule_search.util import cp_src_to_dst
from schedule_search.util import run_cmd_comm

FILE_PATH = os.path.dirname(os.path.realpath(__file__))
LOCK_PATH = "~/.lock"


def gen_task_info(task_key,  # pylint: disable=R0913,R0914
                  op_schedule_info,
                  kernel_run_obj,
                  check_output,
                  debug=False,
                  print_output=True,
                  run_base=False):
    """

    :param task_key:
    :param op_schedule_info:
    :param kernel_run_obj:
    :param check_output:
    :param debug:
    :param print_output:
    :param run_base:
    :return:
    """
    # golden_bin
    # true表示用.o在aicore上生成golden_data，false表示用py脚本在cpu上生成
    # 把.o或者.py的读取内容并放到消息里
    with open(kernel_run_obj.kernel_bin_path, 'rb') as file_handler:
        kernel_bin_content = base64.encodebytes(file_handler.read()) \
            .decode('ascii')

    option = op_schedule_info.option

    # 参数预处理，将所有参数处理成一个字符串，可以用pickle之类的序列化工具
    # 注意：bool的值经过消息传递会变成字符串
    if not run_base:
        run_timeout = op_schedule_info.option.get("run_timeout", 20)
    else:
        run_timeout = op_schedule_info.option.get("base_run_timeout", 60)

    task_info = {
        'task_key':
        task_key,
        'op_name':
        op_schedule_info.op_name,
        'check_output_list':
        [str(check_output) for _ in op_schedule_info.output_info_list],
        'input_dtype_list':
        [input_info.dtype for input_info in op_schedule_info.input_info_list],
        'input_file_list':
        op_schedule_info.input_file_list,
        'input_size_list':
        op_schedule_info.input_size_list,
        'expect_output_file_list':
        op_schedule_info.expect_output_file_list,
        'output_size_list':
        op_schedule_info.output_size_list,
        'output_dtype_list': [
            output_info.dtype
            for output_info in op_schedule_info.output_info_list
        ],
        'kernel_name':
        kernel_run_obj.kernel_name,
        'block_dim':
        kernel_run_obj.block_dim,
        'kernel_bin_path':
        kernel_run_obj.kernel_bin_path,
        'kernel_bin_content':
        kernel_bin_content,
        'debug':
        "1" if str(debug).lower() == "true" else "0",
        'print_output':
        str(print_output),
        'cce_prof':
        'False',
        'repeat_count':
        option.get('repeat_count', 20),
        'default_input_file':
        op_schedule_info.input_file_list,
        'default_input_size':
        str(evb_host.DEFAULT_INPUT_SIZE),
        'shape_list_str':
        op_schedule_info.shape_list_str,
        'store_dir':
        op_schedule_info.store_dir,
        'error_tolerance':
        op_schedule_info.option.get("error_tolerance", 0.0),
        "accuracy_tolerance":
        op_schedule_info.option.get("accuracy_tolerance", 0.0),
        'gen_golden':
        kernel_run_obj.gen_golden,
        'lock_timeout':
        op_schedule_info.option.get("lock_timeout", 60),
        # base的超时时间稍微长一点，保证base可以跑出来
        'run_timeout':
        run_timeout,
        'soc_version':
        soc_cfg.get_soc_version(),
        "kernel_runner":
        option.get("kernel_runner", "kernel_replay_comm"),
        "evbs":
        option.get("evbs", None),
        "rl_mode":
        option.get("rl_mode", ""),
        "workspace_sizes":
        kernel_run_obj.workspace_sizes,
        'data_require':
        op_schedule_info.option.get('data_require', None),
        'prof_type':
        op_schedule_info.option.get('prof_type', "0"),
        'inplace_info_list':
        kernel_run_obj.inplace_list,
        'local_kernel_runner':
        option.get('local_kernel_runner', "0"),
    }

    if op_schedule_info.cmp_kernel is None:
        cmp_device = "1"
    else:
        cmp_device = op_schedule_info.option.get('cmp_device', "0")
        cmp_bin_path = op_schedule_info.cmp_kernel.kernel_bin_path
        cmp_bin_content = base64.encodebytes(b'').decode('ascii')
        try:
            with open(cmp_bin_path, 'rb') as file_handler:
                cmp_bin_content = base64.encodebytes(file_handler.read()) \
                    .decode('ascii')
        except Exception as exce:  # pylint: disable=broad-except
            log.warn('can not read kernel. %s', str(exce))
        task_info['cmp_kernel_name'] = op_schedule_info.cmp_kernel.kernel_name
        task_info['cmp_block_dim'] = op_schedule_info.cmp_kernel.block_dim
        task_info['cmp_bin_content'] = cmp_bin_content
        task_info['cmp_workspace_sizes'] = \
            op_schedule_info.cmp_kernel.workspace_sizes
    task_info['cmp_device'] = cmp_device

    return task_info


def copy_data_to_evb_host(evb_info, src_path, dst_path):
    """

    :param evb_info:
    :param src_path:
    :param dst_path:
    :return:
    """
    host_pw = evb_info.get('host_password', '')
    h_user = evb_info.get('host_user', '')
    h_ip = evb_info.get('host_ip', '')

    if h_ip == "localhost":
        ret = cp_src_to_dst(src_path, dst_path, overwriting=False)
        if not ret:
            log.warn('can not cp src to dst: %s %s', src_path, dst_path)
            return False
        return True

    # 已经存在目标数据则不需要再次拷贝
    ls_cmd = evb_host.get_exec_cmd('ls %s' % dst_path, h_ip, h_user, host_pw)
    ret, output = run_cmd_comm(ls_cmd, quiet=True)
    if ret:
        log.dbg('%s already exist, output is: %s', dst_path, output)
        return True

    dir_path = os.path.dirname(dst_path)
    mkdir_cmd = evb_host.get_exec_cmd('mkdir -p %s' % dir_path, h_ip, h_user,
                                      host_pw)
    scp_cmd = evb_host.scp_l_to_r_cmd(src_path, dst_path, h_ip, h_user,
                                      host_pw)
    exec_cmd = mkdir_cmd + ' && ' + scp_cmd
    ret, output = run_cmd_comm(exec_cmd)
    if not ret:
        log.warn('can not run exec_cmd: %s, output is: %s', exec_cmd, output)
        return False
    return True


def run_in_local_mode(task_info, evb_info):  # pylint: disable=R0914
    """

    :param task_info:
    :param evb_info:
    :return:
    """
    task_key = task_info['task_key']
    timeout = task_info["lock_timeout"] + task_info["run_timeout"]
    if not timeout:
        return False, 0, "timeout of get tick can not be 0!"

    param_str = json.dumps((evb_info, task_info), )
    # 1, 在EVB Host上创建tss目录
    # 2，把evb_host.py加上参数等信息后，SCP到EVB Host的tss目录里
    # 3，用SSH在EVB Host侧把evb_host.py调起来
    host_pw = evb_info.get('host_password', "")
    h_user = evb_info.get('host_user', "")
    h_ip = evb_info.get('host_ip', "")

    evb_host_content_py = os.path.join(FILE_PATH, 'evb_host.py')

    with open(evb_host_content_py, 'rb') as file_handler:
        evb_host_content = file_handler.read().decode('utf-8')

    evb_host_content = evb_host_content.replace('@param_str@', param_str)
    py_file_name = 'evb_host_%s.py' % task_key
    local_py_file = os.path.join(task_info['store_dir'], py_file_name)
    fd = os.open(local_py_file, os.O_RDWR | os.O_CREAT, 0o640)
    with os.fdopen(fd, 'wb') as file_handler:
        file_handler.write(evb_host_content.encode('utf-8'))

    remote_evb_host_py_dir = os.path.join(evb_info['EVB_HOST_BASE_DIR'],
                                          "evb_host_py")

    mkdir_cmd = evb_host.get_exec_cmd(
        "mkdir -m 750 -p %s %s" % (LOCK_PATH, remote_evb_host_py_dir), h_ip,
        h_user, host_pw)
    scp_cmd = evb_host.scp_l_to_r_cmd(local_py_file, remote_evb_host_py_dir,
                                      h_ip, h_user, host_pw)
    lock_file = os.path.join(
        LOCK_PATH, "tune_{}.lock".format(evb_info.get('device_idx', "0")))
    exec_cmd = evb_host.get_exec_cmd(
        'timeout %s flock -x -w %s %s python3 %s/%s' %
        (timeout, task_info["lock_timeout"], lock_file,
         remote_evb_host_py_dir, py_file_name), h_ip, h_user, host_pw)

    # 复合指令，timeout只对紧挨着的那一条指令生效
    host_cmd = mkdir_cmd
    if scp_cmd:
        host_cmd += ' && ' + scp_cmd
    host_cmd += ' && ' + exec_cmd
    ret, info = run_cmd_comm(host_cmd)

    log.dbg('out: %s.', info)
    ret = False
    tick = 0
    if '[ret]:' in info and '[tick]:' in info and '[ret_info]:' in info:
        ret = (
            info.split('[ret]:')[-1].split(',')[0].strip().lower() == 'true')
        tick = int(float(info.split('[tick]:')[-1].split(',')[0].strip()))
        info = info.split('[ret_info]:')[-1]
    else:
        if not info.replace(
                "Authorized users only. "
                "All activities may be monitored and reported.", "").strip():
            info += " get lock timeout after %ss" % (task_info["lock_timeout"])

    # 把local_py_file删除
    util.rm_proc(local_py_file)
    return ret, tick, info


def run(op_schedule_info,  # pylint: disable=R0913
        kernel_run_obj,
        check_output,
        evb_info,
        debug=False,
        print_output=True,
        run_base=False):
    """

    :param op_schedule_info:
    :param kernel_run_obj:
    :param check_output:
    :param evb_info:
    :param debug:
    :param print_output:
    :param run_base:
    :return:
    """
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S_%f')
    task_key = "%s_%s_%s" % (kernel_run_obj.kernel_name, timestamp,
                             os.getpid())

    task_info = gen_task_info(task_key, op_schedule_info, kernel_run_obj,
                              check_output, debug, print_output, run_base)

    ret, tick, info = run_in_local_mode(task_info, evb_info)
    return ret, tick, info
