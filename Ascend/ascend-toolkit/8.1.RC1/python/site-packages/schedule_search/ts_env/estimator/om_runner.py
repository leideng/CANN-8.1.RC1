#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import datetime
import os
import sys
import time
import re
from typing import Union

from schedule_search import log
from schedule_search import util
from schedule_search.config import BASE_RUN_TIMEOUT
from schedule_search.config import RUN_TIMEOUT
from schedule_search.ts_env.estimator.kernel_runner import ErrorCode
from schedule_search.ts_env.estimator.kernel_runner import store_tmp_proc
from tbe.common.rl_bank.add_cheque import get_outputs
from tbe.common.rl_bank.rl_bank import get_rl_bank_key

CB_TASK_QUEUE = None
CB_RES_DICT = None
CB_RELEASE_QUEUE = None
DEFAULT_OM_RUN_THRESHOLD = 18446744073709551615
BASE_RUN_TIME_FACTOR = 20


def get_tick_from_cb(callback_ret_dict):
    """
    get_tick_from_cb
    :param callback_ret_dict:
    :return:
    """
    tick = int(callback_ret_dict["aiCoreCostTime"].get(
        callback_ret_dict["opName"], 0))
    # 如果ai_core耗时为0，尝试拿一下op cost
    if not tick:
        tick = int(callback_ret_dict["opCostTime"].get(
            callback_ret_dict["opName"], 0))
    # callback是ns单位
    return int(tick / 1000)


def get_om_base_tick(op_schedule_info: object) -> tuple:
    """
    :param op_schedule_info:
    :return:
    """
    runner = OMRunner(op_schedule_info,
                      None,
                      run_base=True)
    _, base_tick, err_code = runner.run()
    return base_tick, err_code


def gen_bank_key_by_code(compute_code: list) -> str:
    """
    gen_bank_key by compute_code
    """
    output_tensors, _ = get_outputs(compute_code)
    if not output_tensors:
        log.warn("can not get outputs:%s", output_tensors)
        return ""
    bank_key = get_rl_bank_key(output_tensors)
    if not bank_key:
        log.warn("can not get bank key:%s", bank_key)
        return ""

    return bank_key


class OMRunner:
    """
    OMRunner
    """
    def __init__(self, op_schedule_info: Union[object, list], kernel_info: Union[object, list],
                 process_share_infos: object = None, run_base: bool = False,
                 datacmp_args_dict: dict = None):

        # if op_schedule_info is list, get bank_key_list and rnn_cheque_list
        self.rnn_bank_key_list = []
        self.rnn_cheque_list = []
        self.op_schedule_info = None
        self.kernel_info = None

        self.set_schedule_info(op_schedule_info, kernel_info)
        self.process_share_infos = process_share_infos
        self.compute_code = self.op_schedule_info.compute_code.split("\n")
        # is_store_cheque indicates that store cheque to GLOBAL_DICT or not
        self.is_store_cheque = self.op_schedule_info.option.get("is_store_cheque", False)
        self.save_best_flag = False
        # not_store_sch indicates that store py files or not
        if self.op_schedule_info.option.get("not_store_sch", False):
            self.store_tmp_sch = False
        else:
            self.store_tmp_sch = not run_base

        self.cb_struct_key = self.op_schedule_info.option["cb_struct_key"]
        self.cheque_list = []

        self.cb_task_queue = CB_TASK_QUEUE
        self.cb_res_dict = CB_RES_DICT
        self.cb_release_queue = CB_RELEASE_QUEUE
        self.run_base_flag = run_base
        self.need_datacmp = False
        self.re_run_base = False
        if datacmp_args_dict is not None:
            self.need_datacmp = datacmp_args_dict.get("need_datacmp", False)
            self.re_run_base = datacmp_args_dict.get("re_runbase", False)
        if self.process_share_infos is not None:
            self.cb_task_queue = process_share_infos.cb_task_queue
            self.cb_res_dict = process_share_infos.cb_res_dict
            self.cb_release_queue = process_share_infos.cb_release_queue
        self.run_task_queue = self.cb_task_queue
        self.run_res_dict = self.cb_res_dict
        if self.run_base_flag and self.re_run_base:
            self.run_task_queue = datacmp_args_dict.get("rerun_task_q", None)
            self.run_res_dict = datacmp_args_dict.get("rerun_res_d", None)
            self.cb_release_queue = datacmp_args_dict.get("rerun_release_q", None)
        if self.run_base_flag:
            self.run_time_baseline = DEFAULT_OM_RUN_THRESHOLD
            self.is_store_cheque = False
            self.cheque_str_list = [str(
                {"rl_cheque": {"fake_key": []},
                 "kernel_name": self.op_schedule_info.option.get("kernel_name", "")
                })]
            self.run_timeout = self.op_schedule_info.option.get("base_run_timeout", BASE_RUN_TIMEOUT)
        else:
            self.run_time_baseline = self.op_schedule_info.base_totaltime
            self.kernel_run_obj = self.kernel_info.kernel_run_obj
            self.block_dim = self.kernel_run_obj.block_dim if self.kernel_run_obj is not None else None
            self.schedule_code = self.kernel_info.sch_info.code
            self.cheque_list = self.kernel_info.sch_info.cheque_list
            bank_key = self.op_schedule_info.option.get('op_config', {}).get("bank_key", [])
            self.bank_key = bank_key if bank_key else self.gen_bank_key()
            if self.need_datacmp:
                self.run_task_queue = datacmp_args_dict.get("datacmp_task_q", None)
                self.run_res_dict = datacmp_args_dict.get("datacmp_res_d", None)
                self.cheque_str_list = []
                self.rnn_bank_key_list = self.split_bank_key()
                for cheque in self.cheque_list:
                    rl_cheque_dict = self.get_rl_cheque_dict(cheque)
                    tmp_cheque_str = str({"rl_cheque": rl_cheque_dict,
                                          "kernel_name": self.op_schedule_info.option.get("kernel_name", "")})
                    self.cheque_str_list.append(tmp_cheque_str)
                # retrieve run om timeout same as base run om timeout
                self.run_timeout = max(self.op_schedule_info.base_run_time * BASE_RUN_TIME_FACTOR,
                                       self.op_schedule_info.option.get("base_run_timeout", BASE_RUN_TIMEOUT))
            else:
                rl_cheque_dict = self.get_rl_cheque_dict(self.cheque_list)
                if len(self.rnn_bank_key_list) > 1:
                    self.cheque_list = self.rnn_cheque_list
                    self.bank_key = self.rnn_bank_key_list

                self.cheque_str_list = [str(
                    {"rl_cheque": rl_cheque_dict,
                    "kernel_name": self.op_schedule_info.option.get("kernel_name", "")
                    })]
                self.run_timeout = max(self.op_schedule_info.base_run_time * BASE_RUN_TIME_FACTOR,
                                       self.op_schedule_info.option.get("base_run_timeout", BASE_RUN_TIMEOUT))

    def run(self) -> (bool, Union[int, list], Union[str, list]):
        """
        run during tuning process without precision calibration
        :return:
        """
        task_id = '{}_pid{}_{}'.format(
            self.op_schedule_info.option["kernel_name"], os.getpid(),
            datetime.datetime.now().strftime('%Y%m%d_%H%M%S_%f'))
        main_pid = self.op_schedule_info.option['main_pid']
        if not util.pid_exists(main_pid):
            log.info("om runner info: main process %s ends, current process is %s.", main_pid, os.getpid())
            return False, 0, ErrorCode.RUN_CRASH

        # put run task to task_queue
        log.info("om runner info: put task %s (cb_struct_key: %s) to %s.",
                 task_id, self.cb_struct_key, self.run_task_queue)
        self.run_task_queue.put({
            task_id: {"cb_struct_key": self.cb_struct_key,
                      "strategy_list": self.cheque_str_list,
                      "need_integrate": False,
                      "tune_mode": "RL",
                      "costtime_baseline": self.run_time_baseline}
        })

        base_task_start_time = time.time()

        # get run result from res_queue
        callback_ret = []
        cb_begin = time.time()
        # 等到超时
        log.dbg("om runner info: %s wait run result with timeout %s.", task_id, self.run_timeout)
        while time.time() - cb_begin <= self.run_timeout:
            # 主进程不在不等了，break掉
            if not util.pid_exists(main_pid):
                log.warn("om runner info: main process %s is dead, stop current om runner subprocess %s.",
                         main_pid, os.getpid())
                return False, 0, ErrorCode.RUN_CRASH
            if self.run_res_dict.get(task_id, None) is not None:
                callback_ret = self.run_res_dict.get(task_id)
                if not self.need_datacmp:
                    self.cb_release_queue.put(task_id)
                log.dbg("om runner info: get %s callback_ret: %s.", task_id, callback_ret)
                break
            # 等0.5s再尝试去获取下结果
            time.sleep(0.5)

        base_task_end_time = time.time()
        if self.run_base_flag:
            self.op_schedule_info.base_run_time = base_task_end_time - base_task_start_time

        return self.get_ret_from_cb(callback_ret, task_id)

    def get_ret_from_cb(self, callback_ret: list, task_id: str) -> (bool, Union[int, list], Union[int, list]):
        """
        get tick and err_code for single callbackret_dict
        :param callback_ret:
        :param task_id:
        :return: ret, tick, err_code
        """
        if not callback_ret:
            log.warn("om runner info: callback task %s cannot get result, callback_ret is %s.", task_id, callback_ret)
            return False, 0, ErrorCode.RUN_CRASH

        callback_parsed_rets = []
        callback_ticks = []
        callback_errcodes = []
        for callback_ret_dict in callback_ret:
            if not bool(callback_ret_dict):
                log.warn("om runner info: callback task: %s cannot get single result.", task_id)

            if not callback_ret_dict.get("aiCoreCostTime", None) or not callback_ret_dict.get("opName", None):
                log.warn("om runner info: task: %s has no aiCoreCostTime or opName, callback_ret_dict: %s.",
                          task_id, callback_ret_dict)
                self.post_proc(0, ErrorCode.RUN_CRASH)
                callback_parsed_rets.append(False)
                callback_ticks.append(0)
                callback_errcodes.append(ErrorCode.RUN_CRASH)
                continue

            # parse for tick
            tick = get_tick_from_cb(callback_ret_dict)
            if self.run_base_flag:
                self.op_schedule_info.base_totaltime = int(callback_ret_dict.get("profE2ECostTime", 0))
            err_code = ErrorCode.RUN_CRASH
            if tick > 0:
                if str(callback_ret_dict.get("verify", False)).lower() == "true":
                    err_code = ErrorCode.RUN_SUCC
                else:
                    err_code = ErrorCode.RUN_FAIL
            self.post_proc(tick, err_code)
            callback_parsed_rets.append(True)
            callback_ticks.append(tick)
            callback_errcodes.append(err_code)
            log.dbg("om runner info: get single ret from cb end, res: %s, tick: %d, task_id: %s, cheque_list: %s.",
                    err_code, tick, task_id, self.cheque_list)

        if not self.need_datacmp:
            return callback_parsed_rets[0], callback_ticks[0], callback_errcodes[0]

        if sum(callback_parsed_rets) > 0:
            return True, callback_ticks, callback_errcodes
        return False, callback_ticks, callback_errcodes

    def post_proc(self, tick: int, err_code: str) -> None:
        """
        post_proc
        :param tick:
        :return:
        """
        if self.need_datacmp:
            return

        if self.is_store_cheque:
            self.update_best_cheque(tick, err_code)
            if self.save_best_flag:
                self.save_best_py(tick, err_code, os.getpid())

        if self.store_tmp_sch:
            store_path = store_tmp_proc(self.op_schedule_info,
                                        self.schedule_code,
                                        err_code,
                                        self.kernel_run_obj.kernel_name,
                                        self.store_tmp_sch,
                                        tick=tick if tick > 0 else None)
            log.dbg("om runner info: the sch store path: %s.", store_path)

    def update_best_cheque(self, current_tick: int, err_code: str) -> None:
        """
        compare and update best tick with current_tick
        :param current_tick:
        :param err_code:
        :return:
        """
        if self.process_share_infos is None:
            log.info("om runner info: process_share_infos is None, cannot update best_cheque.")
            return

        kernel_name = self.op_schedule_info.option.get("kernel_name")
        if err_code != ErrorCode.RUN_SUCC:
            log.info("om runner info: unable to update best_cheque, op: %s, tick: %s, err_code: %s.",
                      kernel_name, current_tick, err_code)
            return

        best_cheque_info = {
            "base_tick": self.op_schedule_info.base_tick,
            "best_tick": current_tick,
            "bank_key": self.bank_key,
            "block_dim": self.block_dim,
            "cheque": self.cheque_list
        }

        pid = os.getpid()
        if not self.process_share_infos.best_cheque_dict.get(pid, {}):
            self.process_share_infos.best_cheque_dict[pid] = [best_cheque_info]
        else:
            saved_cheque_list = self.process_share_infos.best_cheque_dict.get(pid)
            saved_cheque_list.extend([best_cheque_info])
            self.process_share_infos.best_cheque_dict[pid] = saved_cheque_list
        log.dbg("om runner info: update_best_cheque end, op: %s, pid: %s, tick: %s, err_code: %s.",
                kernel_name, pid, current_tick, err_code)

    def save_best_py(self, current_tick: int, err_code: str, pid: int) -> None:
        """
        save sch py if current tick is better than global best_tick
        :param current_tick:
        :param err_code:
        :param pid:
        :return:
        """
        global_best_tick = self.get_global_best()
        log.dbg("om runner info: current_tick: %s, global_best_tick: %s.", current_tick, global_best_tick)

        if current_tick <= global_best_tick:
            store_dir = os.path.join(self.op_schedule_info.store_dir, err_code)
            py_files = []
            if os.path.exists(store_dir):
                py_files = os.listdir(store_dir)

            # rm py from the same pid
            remove_tag = "_".join(self.kernel_run_obj.kernel_name.split("_")[:-1]) + "_"
            files_to_remove = (file for file in py_files if remove_tag in file)
            for file in files_to_remove:
                os.remove(os.path.join(store_dir, file))
                log.dbg("om runner info: remove sch path: %s.", os.path.join(store_dir, file))

            store_path = store_tmp_proc(self.op_schedule_info,
                                        self.schedule_code,
                                        err_code,
                                        self.kernel_run_obj.kernel_name,
                                        True,
                                        tick=current_tick if current_tick > 0 else None)
            log.dbg("om runner info: best sch path updated: %s.", store_path)

    def get_global_best(self) -> int:
        """
        get global best tick from best_cheque_dict
        """
        best_cheque_dict_values = self.process_share_infos.best_cheque_dict.values()
        total_saved_cheque_list = []
        for saved_cheque_list in best_cheque_dict_values:
            total_saved_cheque_list.extend(saved_cheque_list)
        global_best_tick = min(total_saved_cheque_list,
                               key=lambda item: item.get("best_tick", sys.maxsize)).get("best_tick", sys.maxsize)
        return global_best_tick

    def gen_bank_key(self) -> str:
        """
        gen_bank_key
        :return:
        """
        return gen_bank_key_by_code(self.compute_code)

    def split_bank_key(self) -> list:
        """
        split bank_key
        e.g. 1.str(key1key2) -> [key1,key2]
             2.str(key) -> [key]
        :return: bank_key_list
        """
        key = self.bank_key
        res_list = []
        split_pos = [pattern.start() for pattern in re.finditer("\]\[", key)]
        split_pos = [-1] + split_pos + [len(key)]
        for idx in range(len(split_pos) - 1):
            start_idx = split_pos[idx] + 1
            end_idx = split_pos[idx + 1] + 1
            res_list.append(key[start_idx:end_idx])
        return res_list

    def get_rl_cheque_dict(self, cheque: list) -> dict:
        """
        get_rl_cheque_dict
        :param cheque:
        :return: rl_dict
        """
        rl_cheque_dict = {}
        if self.need_datacmp:
            cheque_list = cheque
            single_cheque = cheque
        else:
            cheque_list = self.rnn_cheque_list
            single_cheque = self.cheque_list

        if len(self.rnn_bank_key_list) > 1:
            for idx, key in enumerate(self.rnn_bank_key_list):
                rl_cheque_dict[key] = cheque_list[idx]
        else:
            rl_cheque_dict = {self.bank_key: single_cheque}
        return rl_cheque_dict

    def set_schedule_info(self, op_schedule_info: Union[object, list], kernel_info: Union[object, list]) -> None:
        """
        set_schedule_info
        :param op_schedule_info:
        :param kernel_info:
        :return:
        """
        if isinstance(op_schedule_info, list):
            for idx, single_op_schedule_info in enumerate(op_schedule_info):
                tmp_bank_key = gen_bank_key_by_code(single_op_schedule_info.compute_code.split("\n"))
                tmp_cheque_list = kernel_info[idx].sch_info.cheque_list
                self.rnn_bank_key_list.append(tmp_bank_key)
                self.rnn_cheque_list.append(tmp_cheque_list)

            op_schedule_info = op_schedule_info[0]
            kernel_info = kernel_info[0]

        self.op_schedule_info = op_schedule_info
        self.kernel_info = kernel_info

