#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import os
import time

from schedule_search import log
from schedule_search import util
from schedule_search import soc_cfg
from schedule_search.ts_env.estimator.evb import evb_host

FILE_PATH = os.path.dirname(os.path.realpath(__file__))
# replay_dir下的replay_comm采用版本号机制维护，更新replay_dir的replay_comm时，
# 这里必须同步修改
REPLAY_COMM_VERSION = "v013"


def put_exe_to_host(local_file, host_file, h_usr, h_ip, h_pwd):
    """

    :param local_file:
    :param host_file:
    :param h_usr:
    :param h_ip:
    :param h_pwd:
    :return:
    """
    md5_cmd = evb_host.get_exec_cmd('md5sum %s' % host_file, h_ip, h_usr,
                                    h_pwd)
    dst_ret, dst_md5 = util.run_cmd_comm(md5_cmd, quiet=True)
    src_ret, src_md5 = util.run_cmd_comm('md5sum %s' % local_file)
    if dst_ret and src_ret:
        if dst_md5.split(" ")[0] == src_md5.split(" ")[0]:
            log.info('host_file: %s already exists!', host_file)
            return True

    mkdir_cmd = evb_host.get_exec_cmd(
        'mkdir -p %s' % os.path.dirname(host_file), h_ip, h_usr, h_pwd)
    scp_cmd = evb_host.scp_l_to_r_cmd(local_file, host_file, h_ip, h_usr,
                                      h_pwd)
    exec_cmd = mkdir_cmd + ' && ' + scp_cmd
    ret, output = util.run_cmd_comm(exec_cmd)
    if not ret:
        log.warn('can not scp from local to host. info: %s', output)
        return False

    return True


def init_evb(evb_info, option):  # pylint: disable=R0912
    """

    :param evb_info:
    :param option:
    :return:
    """
    h_pwd = evb_info.get('host_password', "")
    h_ip = evb_info.get('host_ip', "")
    h_usr = evb_info.get('host_user', "")
    default_workspace = os.path.join(FILE_PATH,
                                     '../../../../../../../../../')
    workspace = evb_info.get('workspace', default_workspace)
    h_os = evb_info.get('host_os', "")
    h_arch = evb_info.get('host_arch', "")
    tss_workspace = option.get("tss_workspace", "tss_workspace")
    evb_info["tss_workspace"] = tss_workspace
    evb_host.update_evb_info(evb_info)

    kernel_runner = evb_info.get("kernel_runner", 'kernel_replay_comm')
    local_rplc_file = os.path.join(FILE_PATH,
                                   '../../../../schedule_search/libs',
                                   'kernel_replay_comm')

    if option.get('init_evb', False) is False:
        return True

    # source code mode
    if not os.path.exists(local_rplc_file):
        if "kernel_runner" not in option:
            option["local_kernel_runner"] = "0"
            option["kernel_runner"] = 'kernel_replay_comm.%s' % \
                                      REPLAY_COMM_VERSION
        else:
            option["local_kernel_runner"] = "1"

        kernel_runner = evb_info.get("kernel_runner", option["kernel_runner"])
        local_rplc_file = os.path.join(workspace, 'replay_dir/evb_data', h_os,
                                       h_arch, kernel_runner)
        if not os.path.exists(local_rplc_file):
            raise RuntimeError("%s not exist! please repo sync and env init!" %
                               local_rplc_file)

    # 如果是本机模式的话无需用scp，直接本地拷贝即可
    if h_ip == "localhost":
        host_rplc_file = os.path.join(evb_info['EVB_HOST_BASE_DIR'],
                                      'kernel_replay_comm')
        exec_cmd = "mkdir -p %s && cp -rfp %s %s" % (
            os.path.dirname(host_rplc_file), local_rplc_file, host_rplc_file)
        ret, output = util.run_cmd_comm(exec_cmd)
        if not ret:
            log.warn('can not cp from local to host. info: %s', output)
            return False
    else:
        # 拷贝replay comm
        host_rplc_file = os.path.join(evb_info['EVB_HOST_BASE_DIR'],
                                      kernel_runner)
        ret = put_exe_to_host(local_rplc_file, host_rplc_file, h_usr, h_ip,
                              h_pwd)
        if not ret:
            log.warn('Can not put kernel_replay_comm to device.')
            return False
    log.info("init_evb: %s done!", h_ip)
    return True


def _check_mp():
    """
    :return:
    """
    # ===========================================
    # 有rank_size大于1说明是多P，暂时不支持
    # ===========================================
    rank_size = os.getenv("RANK_SIZE", "")
    if rank_size.isdigit():
        if int(rank_size) > 1:
            fail_reason = "RL is invalid when RANK_SIZE[%s] > 1." % rank_size
            log.warn(fail_reason)
            return False, fail_reason
    return True, ""


def _check_import(evb_info):
    """

    :param evb_info:
    :return:
    """
    # ===========================================
    # 检查evb host import base64
    # ===========================================

    host_ip = evb_info["host_ip"]
    host_user = evb_info["host_user"]
    host_password = evb_info.get("host_password", "")
    import_base64_cmd = "python3 -c 'import base64'"
    check_cmd = util.get_exec_cmd(import_base64_cmd, host_ip, host_user,
                                  host_password)
    ret, _ = util.run_cmd_comm(check_cmd)
    if not ret:
        fail_reason = "import base64 in python3 failed in %s!" % host_ip
        log.warn(fail_reason)
        return False, fail_reason
    return True, ""


def _check_time(evb_info):
    """

    :param evb_info:
    :return:
    """
    # ===========================================
    # 检查远端时间与本地时间相隔不超过1小时
    # ===========================================

    host_ip = evb_info["host_ip"]
    host_user = evb_info["host_user"]
    host_password = evb_info.get("host_password", "")
    local_time = int(time.time())
    date_cmd = 'date +%s'
    check_cmd = util.get_exec_cmd(date_cmd, host_ip, host_user, host_password)
    ret, output = util.run_cmd_comm(check_cmd)
    remote_time = output.strip()
    if not ret or not remote_time.isdigit() \
            or abs(local_time - int(remote_time)) > 3600:
        fail_reason = "The time delta of local between %s is beyond 1 hour!" \
                % host_ip
        log.warn(fail_reason)
        return False, fail_reason
    return True, ""


def _check_disk(evb_info):
    """

    :param evb_info:
    :return:
    """
    # ===========================================
    # 检查HwHiAiUser用户可用空间不低于20G
    # ===========================================
    host_ip = evb_info["host_ip"]
    host_user = evb_info["host_user"]
    host_password = evb_info.get("host_password", "")
    if host_ip == 'localhost':
        try:
            root_path = os.path.expanduser('~')
            avail_space_gb = util.get_disk_size(root_path)
        except (ValueError, TypeError, FileNotFoundError) as exception:
            fail_reason = "get avail space of ~ fail. %s" % (exception)
            log.warn(fail_reason)
            return False, fail_reason
    else:
        # -B 1G 是以1G为单位， 小于1G也是1
        check_cmd = util.get_exec_cmd('df -h -B 1G ~', host_ip, host_user,
                                      host_password)
        ret, output = util.run_cmd_comm(check_cmd)
        if ret:
            avail_space_gb = int(output.split('\n')[1].split()[3])
        else:
            fail_reason = "get avail space of ~ by cmd '%s' failed!" % (check_cmd)
            log.warn(fail_reason)
            return False, fail_reason
            # 当'~'目录的剩余空间小于20G，则不行
            # 但要留给用户一些余量，所以这里只要达到19就行
    if avail_space_gb <= 19:
        fail_reason = ("The avail space of ~ in %s is %sG, "
                       "it must be bigger than 20G!") % (host_ip,
                                                         avail_space_gb)
        log.warn(fail_reason)
        return False, fail_reason

    return True, ""


def _check_memory(evb_info, option):
    """

    :param evb_info:
    :param option:
    :return:
    """
    host_ip = evb_info["host_ip"]
    host_user = evb_info["host_user"]
    host_password = evb_info.get("host_password", "")
    # 检查Host可用内存
    check_cmd = util.get_exec_cmd("free -g", host_ip, host_user, host_password)
    ret, output = util.run_cmd_comm(check_cmd)
    if ret:
        curr_mem = int(output.split('\n')[1].split()[1]) \
                   * 1024 * 1024 * 1024
        option.setdefault("host_mem", curr_mem)
        # 取集群中的内存最小值
        option["host_mem"] = min(curr_mem, option["host_mem"])
        log.dbg("host_mem: %s", option["host_mem"])
    return True, ""


def _check_device_id(evb_info):
    """

    :param evb_info:
    :return:
    """
    host_ip = evb_info["host_ip"]
    host_user = evb_info["host_user"]
    host_password = evb_info.get("host_password", "")
    # 检查配置的device_idx是否合法
    check_cmd = util.get_exec_cmd(
        "lspci | grep 'Processing accelerators' | wc -l", host_ip, host_user,
        host_password)
    ret, output = util.run_cmd_comm(check_cmd)
    if ret:
        device_cnt_str = output.split("\n")[0]
        if device_cnt_str.isdigit() and device_cnt_str != "0":
            if os.getenv("ASCEND_DEVICE_ID", None) is None and os.getenv(
                    "DEVICE_ID", None) is not None:
                # 物理device id，可能超过device个数，不做校验
                pass
            elif int(max(evb_info["device_idx"])) >= int(device_cnt_str):
                fail_reason = ("host only have %s device, evb conf "
                               "'device_idx' item config fail!") % (
                                   device_cnt_str)
                log.warn(fail_reason)
                raise RuntimeError({"errCode": "ED0002",
                                    "value": max(evb_info["device_idx"]),
                                    "env": "ASCEND_DEVICE_ID",
                                    "max_val": device_cnt_str})
    return True, ""


def _check_soc_version(evb_info):
    """
    检查配置的soc_version和单板侧的soc_version是否匹配
    :param evb_info:
    :return:
    """
    if evb_info["host_ip"] != "localhost":
        return True, ""

    kernel_runner = os.path.join(FILE_PATH, '../../../../schedule_search/libs',
                                 'kernel_replay_comm')
    _, output = util.run_cmd_comm(kernel_runner)
    if "========Curr socVersion: " not in output:
        log.warn("can not get soc version of device, output: %s.", output)
        return True, ""
    dev_soc_version = output.split("========Curr socVersion: ")[1].split(
        "\n")[0]
    soc_version = soc_cfg.get_full_soc_version()
    if soc_version != dev_soc_version:
        fail_reason = ("soc_version: %s != dev_soc_version: %s!") % (
            soc_version, dev_soc_version)
        log.warn(fail_reason)
        raise RuntimeError({"errCode": "ED0001", "user_val": soc_version, "device_val": dev_soc_version})
    return True, ""


def env_check(option):  # pylint: disable=R0911,R0912,R0914
    """

    :param option:
    :return:
    """
    if option.get("no_check", False):
        return True, ""
    ret, output = _check_mp()
    if not ret:
        return False, output
    evb_host_done_list = []
    if option.get('evbs', []):
        for evb_info in option['evbs']:
            host_ip = evb_info["host_ip"]

            # 一个host检查一遍就好了
            if host_ip in evb_host_done_list:
                continue

            ret, output = _check_import(evb_info)
            if not ret:
                return False, output
            ret, output = _check_time(evb_info)
            if not ret:
                return False, output
            ret, output = _check_disk(evb_info)
            if not ret:
                return False, output
            ret, output = _check_memory(evb_info, option)
            if not ret:
                return False, output
            ret, output = _check_device_id(evb_info)
            if not ret:
                return False, output
            ret, output = _check_soc_version(evb_info)
            if not ret:
                return False, output
            # 检查通过的放到done_list里
            evb_host_done_list.append(host_ip)
    return True, ""
