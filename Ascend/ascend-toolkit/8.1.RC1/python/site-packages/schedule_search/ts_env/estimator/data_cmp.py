#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from tbe.tvm.topi import generic
from tbe.tvm.topi.cce import util

import tbe
from tbe.common.platform.platform_info import set_current_compile_soc_info
from tbe.common.buildcfg import build_config
from tbe import tvm


NoneType = type(None)
CAST_DTYPE_DICT = {
    "int16": "uint8",
    "uint16": "uint8",
    "int64": "int32",
    "uint64": "int32",
    "bfloat16": "float32",
    "float64": "float32"
}


@util.check_input_type(list, float, dict, str, bool, bool)
def data_cmp(  # pylint: disable=R0913,R0914
        data_cmp_datas,
        accuracy_tolerance,
        configs,
        kernel_name="data_cmp",
        need_build=False,
        need_print=False):
    """
    Element-wise max the input tensors

    Parameters
    ----------
    shape : shape of data

    dtype : the data type, assume src_dtype equals dst_dtype, only
    support float16, float32,int8,uint8,int32

    tensor_num : the number of input tensors, need in range [1,120]

    kernel_name : cce kernel name, default value is "cce_caffe2_max"

    need_buid : if need to build CCEC kernel, default value is False

    need_print : if need to print the ir, default value is False

    Returns
    -------
    None
    :param configs:
    :param kernel_name:
    :param need_print:
    :param data_cmp_datas:
    :param accuracy_tolerance:
    :param need_build:

    """
    soc_version = configs['soc_info']["soc_version"]
    core_type = configs['soc_info']["core_type"]
    core_num = configs['soc_info']["core_num"]
    set_current_compile_soc_info(soc_version, core_type, core_num)
    res_list = []
    input_list = []
    if not data_cmp_datas:
        raise RuntimeError("data_cmp must input at least one shape")

    # 遍历需要比对的算子
    for index, data_info in enumerate(data_cmp_datas):
        shape = data_info["shape"]
        in_dtype = data_info["dtype"]
        in_dtype = in_dtype.lower()

        # 实际输出和期望输出
        in_dtype = CAST_DTYPE_DICT.get(in_dtype, in_dtype)

        actual = tvm.te.placeholder(shape, name="actual_%s" % str(index), dtype=in_dtype)
        expect = tvm.te.placeholder(shape, name="expect_%s" % str(index), dtype=in_dtype)
        # 加到input_list中
        input_list.extend([actual, expect])

        # 相减再取绝对值，获得实际误差
        if in_dtype != "float32":
            actual = tbe.dsl.cast_to(actual, "float32")
            expect = tbe.dsl.cast_to(expect, "float32")
        error_val = tbe.dsl.vsub(actual, expect)
        abs_error_val = tbe.dsl.vabs(error_val)

        # 最大允许误差
        atol = tvm.const(accuracy_tolerance, dtype=in_dtype)
        rtol = tvm.const(accuracy_tolerance, dtype=in_dtype)

        # 取绝对值
        abs_expect = tbe.dsl.vabs(expect)
        error_limit_mul = tbe.dsl.vmuls(abs_expect, rtol)
        error_limit = tbe.dsl.vadds(error_limit_mul, atol)

        # 另一种算法，使用向上取整和min求解
        the_max = tbe.dsl.vmax(abs_error_val, error_limit)
        dec = tbe.dsl.vsub(the_max, error_limit)
        if soc_version == 'Ascend310':
            dec_fp = tbe.dsl.cast_to(dec, "float16")
        else:
            dec_fp = tbe.dsl.cast_to(dec, "float32")
        abs_dec = tbe.dsl.vabs(dec_fp)
        ceil_abs_dec = tbe.dsl.ceil(abs_dec)
        one_ceil_abs_dec = tbe.dsl.vmins(ceil_abs_dec, 1)
        cmp_fp32 = tbe.dsl.cast_to(one_ceil_abs_dec, "float32")

        # 统计有多少个元素error了
        res = tbe.dsl.reduce_sum(cmp_fp32, 0)
        res_list.append(res)

    with tvm.target.cce():  # pylint: disable=no-member
        sch = generic.auto_schedule(res_list)  # pylint: disable=no-member


    config = {
        "print_ir": need_print,
        "need_build": need_build,
        "name": kernel_name,
        "tensor_list": input_list + res_list,
        "bool_storage_as_1bit": False
    }

    build_cfg = configs['build_cfg']
    with build_config(**build_cfg):
        tbe.dsl.build(sch, config)
