#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import os

from schedule_search import log
from schedule_search import util
from schedule_search.ts_env.env_util import gen_schedule_py
from schedule_search.ts_env.estimator.evb.evb_client import run


class ErrorCode:
    """
    ErrorCode
    """
    BUILD_TIMEOUT = "build_timeout"
    LOWER_TIMEOUT = "lower_timeout"
    BUILD_OOM = "build_oom"
    BUILD_NOALIGN = "build_noalign"
    BUILD_FAIL = "build_fail"
    BUILD_SUCC_ = "build_succ"
    RUN_SUCC = 'run_succ'
    PROFILING_FAIL = "profiling_fail"
    AICORE_ERROR = "aicore_error"
    RUN_CRASH = 'run_crash'
    QUEUE_TIMEOUT = "queue_timeout"
    RUN_FAIL = 'run_fail'
    ENV_EXCEPTION = "env_exception"
    RUN_TIMEOUT = "run_timeout"
    RUN_EXCEPTION = "run_exception"
    LOCK_TIMEOUT = "lock_timeout"

    # RESULT_FAIL有优先级顺序
    EVB_RUN_ERROR_LIST_ = \
        [("AICORE ERROR occur, ", AICORE_ERROR),
         ('exec timeout', QUEUE_TIMEOUT),
         ('memcmp output fail', RUN_FAIL),
         ('host log not found!', ENV_EXCEPTION),
         (' Terminated', RUN_TIMEOUT),
         ('memcmp output succ', RUN_EXCEPTION),
         ('get lock timeout', LOCK_TIMEOUT)
         ]

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.BUILD_OOM

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.RUN_EXCEPTION


def store_tmp_proc(  # pylint: disable=R0913
        op_schedule_info,
        schedule_code,
        err_code,
        kernel_name,
        store_tmp_sch,
        tick=None):
    """

    :param op_schedule_info:
    :param schedule_code:
    :param err_code:
    :param kernel_name:
    :param store_tmp_sch:
    :param tick:
    :return:
    """
    if not store_tmp_sch:
        return None

    if not schedule_code:
        return None

    # 获取文件存储路径
    store_dir = os.path.join(op_schedule_info.store_dir, err_code)
    util.create_dir(store_dir)
    if not tick:
        dst_file_name = "%s.py" % kernel_name
    else:
        if op_schedule_info.base_tick is None:
            base_tick = 0
        else:
            base_tick = op_schedule_info.base_tick
        dst_file_name = "%d_%d_%s.py" % (tick, base_tick, kernel_name)
        if err_code != ErrorCode.RUN_SUCC:
            dst_file_name = "%s_%s" % (err_code, dst_file_name)
    dst_file = os.path.join(store_dir, dst_file_name)
    # 生成py
    gen_schedule_py(op_schedule_info, schedule_code, kernel_name, dst_file)
    return dst_file


class CAModelRunner:  # pylint: disable=R0913
    """
    CAModelRunner
    """
    def __init__(
            self,
            op_schedule_info,
            kernel_run_obj,
            debug=False,
            store_tmp_sch=False,
            print_output=False,
            check_output=None,
            run_base=False):
        self.op_schedule_info = op_schedule_info
        self.kernel_run_obj = kernel_run_obj
        self.debug = debug
        self.store_tmp_sch = store_tmp_sch
        self.print_output = print_output
        if check_output is None:
            self.check_output = op_schedule_info.check_output
        else:
            self.check_output = check_output
        self.run_base = run_base

    @staticmethod
    def run(evb_info):
        """

        :param evb_info:
        :return:
        """
        log.dbg("evb_info: %s", str(evb_info))
        return False, 0, ""

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.run_base

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.print_output


class EvbRunner:  # pylint: disable=R0902
    """
    EvbRunner
    """

    def __init__(  # pylint: disable=R0914,R0913
            self,
            op_schedule_info,
            kernel_run_obj,
            schedule_code=None,
            debug=False,
            store_tmp_sch=False,
            print_output=False,
            check_output=None,
            run_base=False):
        self.op_schedule_info = op_schedule_info
        self.kernel_run_obj = kernel_run_obj
        self.schedule_code = schedule_code
        self.debug = debug
        self.store_tmp_sch = store_tmp_sch
        self.print_output = print_output
        if check_output is None:
            self.check_output = op_schedule_info.check_output
        else:
            self.check_output = check_output
        self.run_base = run_base

    def run(self, evb_info):  # pylint: disable=R0912
        """

        :param evb_info:
        :return:
        """
        err_code = ""
        kernel_run_obj = self.kernel_run_obj

        kernel_bin_path = kernel_run_obj.kernel_bin_path
        if not os.path.exists(kernel_bin_path):
            log.warn("kernel_bin_path:%s not exists!", kernel_bin_path)
            return False, 0, err_code
        # 是使用cluster模式还是Local模式
        ret, tick, output = run(self.op_schedule_info,
                                kernel_run_obj,
                                self.check_output,
                                evb_info,
                                debug=self.debug,
                                print_output=self.print_output,
                                run_base=self.run_base)
        if not ret:
            log.warn("ret_info:%s, tick:%d, output:%s", ret, tick, output)

        if ret:
            if tick > 0:
                err_code = ErrorCode.RUN_SUCC
                store_tmp_proc(self.op_schedule_info,
                               self.schedule_code,
                               err_code,
                               kernel_run_obj.kernel_name,
                               self.store_tmp_sch,
                               tick=tick)
            else:
                ret = False
                err_code = ErrorCode.PROFILING_FAIL
                store_tmp_proc(self.op_schedule_info,
                               self.schedule_code,
                               err_code,
                               kernel_run_obj.kernel_name,
                               self.store_tmp_sch,
                               tick=tick)
        else:
            # 失败场景直接从EVB_RUN_ErrorCode_FAIL_LIST中获取, 是否在已知错误里，
            # 不在的话默认是default错误
            err_code = ErrorCode.RUN_CRASH
            for key_word, fail_type in ErrorCode.EVB_RUN_ERROR_LIST_:
                if key_word in output:
                    err_code = fail_type
                    break
            if err_code == ErrorCode.RUN_CRASH:
                log.warn(
                    "ret_info:%s, tick:%d, output:%s, host_ip:%s, device_ip:"
                    "%s device_idx:%s", ret, tick, output,
                    evb_info.get("host_ip", "localhost"),
                    evb_info.get("device_ip", ""),
                    evb_info.get("device_idx", "0"))

            store_tmp_proc(self.op_schedule_info, self.schedule_code, err_code,
                           kernel_run_obj.kernel_name, self.store_tmp_sch,
                           tick)
        return ret, tick, err_code

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.run_base

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.print_output
