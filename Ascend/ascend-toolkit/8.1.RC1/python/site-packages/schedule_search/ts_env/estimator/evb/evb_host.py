#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import base64
import datetime
import inspect
import json
import os
import subprocess
import sys
import math

import numpy as np

from schedule_search.util import create_dir
from schedule_search.util import OPEN_FILE_MODES_640
from schedule_search.util import WRITE_FILE_FLAGS

THIS_FILE_NAME = __file__
FILE_PATH = os.path.dirname(os.path.realpath(THIS_FILE_NAME))

# EVB Host侧的目录
EVB_HOST_BASE_DIR_NAME = "tss"
EVB_HOST_DATA_DIR_NAME = "data"

# debug模式下临时文件的名字
CURR_OUTPUT_NAME = '0.curr_output.bin'

# default_input数据的版本标识，用于更新default_input
DEFAULT_INPUT_DATA_VERSION = "v5"
# 设置最大的input_size
DEFAULT_INPUT_SIZE = 64 * 1024 * 1024

RUNTIME_LOG_NAME = 'runtime.host.runtime'
HWTS_LOG_NAME = "hwts.log.data.45.dev.profiler_default_tag"

OUTPUT_FORMAT_DATA = sys.path[0] + os.sep + "output_format_data_hwts.txt"
'''['mode', 'rpttype', 'bufsize', 'reserved', 'timestamp', 'eventname',
'tasktype', 'streamid', 'task_id', 'thread', 'device_id', 'kernelname',
'persistant_1bit', 'reserved_7bit']'''
RUNTIME_TASK_ID_INDEX = 8
RUNTIME_KERNEL_NAME_INDEX = 11
HWTS_TYPE_INDEX = 0
HWTS_TASK_ID_INDEX = 4
HWTS_CYCLE_CNT_INDEX = 5


class SocVersion:
    """
    SocVersion
    """
    ASCEND910 = "Ascend910"
    ASCEND610 = "Ascend610"
    ASCEND310 = "Ascend310"
    Ascend310P = "Ascend310P"
    Hi3796CV300ES = "Hi3796CV300ES"

    def useless_func1(self):
        """
        useless_func1
        :return:
        """
        return self.ASCEND610

    def useless_func2(self):
        """
        useless_func2
        :return:
        """
        return self.ASCEND910


class Log:
    """
    这个文件是需要单独运行的，所以不能依赖log，所以为了保持代码格式一致，
    在这里添加一个log
    """
    @staticmethod
    def log(level, line_no, funcname, log_msg, *log_paras):
        """

        :param level:
        :param line_no:
        :param funcname:
        :param log_msg:
        :param log_paras:
        """
        timestamps = datetime.datetime.now().strftime('%Y%m%d_%H%M%S.%f')
        log_str = '[%s][%s][line:%d][%s]' % (timestamps, level, line_no,
                                             funcname)
        try:
            if level == 'E':
                print(log_str + '\033[47;31;1m' + log_msg % log_paras +
                      '\033[0m')
            elif level == 'W':
                print(log_str + '\033[47;35;1m' + log_msg % log_paras +
                      '\033[0m')
            else:
                print(log_str + log_msg % log_paras)
        except Exception as exception:  # pylint: disable=broad-except
            print(str(exception))
        sys.stdout.flush()

    @staticmethod
    def info(log_msg, *log_paras):
        """

        :param log_msg:
        :param log_paras:
        """
        line_no = inspect.currentframe().f_back.f_lineno
        funcname = inspect.currentframe().f_back.f_code.co_name
        Log.log('I', line_no, funcname, log_msg, *log_paras)

    @staticmethod
    def err(log_msg, *log_paras):
        """

        :param log_msg:
        :param log_paras:
        """
        line_no = inspect.currentframe().f_back.f_lineno
        funcname = inspect.currentframe().f_back.f_code.co_name
        Log.log('E', line_no, funcname, log_msg, *log_paras)

    @staticmethod
    def dbg(log_msg, *log_paras):
        """

        :param log_msg:
        :param log_paras:
        """
        line_no = inspect.currentframe().f_back.f_lineno
        funcname = inspect.currentframe().f_back.f_code.co_name
        Log.log('D', line_no, funcname, log_msg, *log_paras)

    @staticmethod
    def warn(log_msg, *log_paras):
        """

        :param log_msg:
        :param log_paras:
        """
        line_no = inspect.currentframe().f_back.f_lineno
        funcname = inspect.currentframe().f_back.f_code.co_name
        Log.log('W', line_no, funcname, log_msg, *log_paras)


def is_python3(version_info):
    """

    :param version_info:
    :return:
    """
    return bool(version_info >= (3, 0))


def run_cmd_comm(cmd,
                 timeout=1800,
                 print_output=False,
                 shell=True,
                 quiet=False):
    """

    :param cmd:
    :param timeout:
    :param print_output:
    :param shell:
    :param quiet:
    :return:
    """
    def _get_print_log(ret_str):
        if "sshpass -p " in cmd:
            print_log = "run cmd: sshpass -p ... %s!" % ret_str
        else:
            print_log = "run cmd: %s %s!" % (cmd, ret_str)
        return print_log

    def _print_log_proc(ret, ret_str, output, print_output):
        if quiet:
            return
        print_log = ""
        if ret is False or print_output is True:
            print_log = _get_print_log(ret_str)
        if print_output:
            print_log += "output: " + output
        if print_log:
            if ret:
                Log.info("%s", print_log)
            else:
                Log.err("%s", print_log)

    if not shell:
        cmd = cmd.split(" ")
    if sys.version_info >= (3, 5):
        try:
            out_bytes = subprocess.check_output(cmd,
                                                stderr=subprocess.PIPE,
                                                shell=shell,
                                                timeout=timeout)
        except subprocess.CalledProcessError as proc_err:
            output_str = proc_err.output.decode('utf-8', errors="ignore") \
                         + proc_err.stderr.decode('utf-8', errors="ignore")
            _print_log_proc(False, "fail", output_str, print_output)
            return False, output_str
        except subprocess.TimeoutExpired:
            _print_log_proc(False, "timeout", "timeout:%d" % timeout,
                            print_output)
            return False, 'timeout'
    else:
        return False, 'unsupported python version'
    _print_log_proc(True, "succ", out_bytes.decode('utf-8', errors="ignore"),
                    print_output)
    return True, out_bytes.decode('utf-8', errors="ignore")


def scp_l_to_r_cmd(local_file,   # pylint: disable=R0913
                   remote_file, ip_addr, usr, pwd, clean=False):
    """从Local侧拷贝到Remote侧的命令组装"""
    if ip_addr == "localhost":
        # 源和目的是同一个文件的时候，使用空命令
        if os.path.isdir(remote_file):
            dst_dir = os.path.dirname(os.path.abspath(remote_file))
            if os.path.dirname(local_file) == dst_dir:
                return ":"
        else:
            if os.path.abspath(local_file) == os.path.abspath(remote_file):
                return ":"
        return "cp -rf %s %s" % (local_file, remote_file)
    option = '-o StrictHostKeyChecking=no'
    scp_cmd = "sshpass -p %s scp %s %s %s@%s:%s" % (pwd, option, local_file,
                                                    usr, ip_addr, remote_file)
    # 防止残留，拷贝完后删除本地文件
    if clean:
        scp_cmd += " && rm " + local_file
    return scp_cmd


def get_kernel_path(task_info, evb_info):
    """
    把BaseKerner的二进制文件存到Device上
    """
    # 建一个临时目录，把Kernel的码流从消息中读出来，写到这个目录下的文件中
    kernel_file_name = os.path.basename(task_info['kernel_bin_path'])

    # 本地目录是临时的，用完会删掉，我们用ts保证其唯一性，也方便定位和观察
    timestamps = datetime.datetime.now().strftime('%Y%m%d_%H%M%S_%f')
    local_bin_dir = os.path.join(evb_info['EVB_HOST_BASE_DIR'], 'kernel',
                                 task_info['op_name'],
                                 str(os.getpid()) + "@" + timestamps)
    create_dir(local_bin_dir)
    local_bin_file_path = os.path.join(local_bin_dir, kernel_file_name)
    with os.fdopen(os.open(local_bin_file_path, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), "wb") as file_h:
        file_h.write(base64.decodebytes(task_info["kernel_bin_content"].encode('ascii')))
    local_cmp_bin = None
    if "cmp_bin_content" in task_info:
        # 用来比对数据的算子Kernel在Host侧的路径
        local_cmp_bin = os.path.join(local_bin_dir,
                                     task_info['cmp_kernel_name'] + '.o')
        with os.fdopen(os.open(local_cmp_bin, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), "wb") as file_h:
            file_h.write(base64.decodebytes(task_info["cmp_bin_content"].encode('ascii')))
    return local_bin_file_path, local_cmp_bin


def gen_random_input_data(input_size,   # pylint: disable=R0912,no-member
                          input_dtype, data_require):
    """

    :param input_size:
    :param input_dtype:
    :param data_require:
    :return:
    """
    if input_dtype == "bool":
        bit_size = 8
    else:
        digit_list = list(filter(str.isdigit, input_dtype))
        bit_size = int("".join(digit_list))
    dtype_size = bit_size // 8
    # 加个Seed，这样每次走到这里，获取的输入都是一致的。Seed设置为8，象征幸运。
    # 注意，修改seed或者random函数代码时，务必要调整DEFAULT_INPUT_DATA_VERSION
    # 为了防止部分场景结果撞对，把输入数据的0都替换成其他值
    np.random.seed(8)
    if "float" in input_dtype:
        input_data = np.random.uniform(-1, 1, input_size // dtype_size) \
            .astype(input_dtype)
        input_data[np.where(input_data == 0.)] = 1e-3
    elif "uint" in input_dtype:
        input_data = np.random.randint(1, 10, input_size // dtype_size) \
            .astype(input_dtype)
    else:
        input_data = np.random.randint(-10, 10, input_size // dtype_size) \
            .astype(input_dtype)
        input_data[np.where(input_data == 0)] = 1

    if not data_require:
        pass
    elif data_require == "positive":
        # 有些算子的输入不能有负数，比如有sqrt操作的算子
        if "float" in input_dtype:
            input_data = np.fabs(input_data)
        else:
            input_data = np.abs(input_data)
    else:
        Log.err("not support data require: %s", data_require)

    return input_data


def get_exec_cmd(cmd, ip_addr, usr, pwd):
    """

    :param cmd:
    :param ip_addr:
    :param usr:
    :param pwd:
    :return:
    """
    if ip_addr == "localhost":
        return cmd
    return "sshpass -p %s ssh -o StrictHostKeyChecking=no %s@%s \"%s\"" % (
        pwd, usr, ip_addr, cmd)


def check_and_copy(evb_info, golden_data_list):
    """

    :param evb_info:
    :param golden_data_list:
    """
    ip_addr = evb_info["host_ip"]
    usr = evb_info["host_user"]
    pwd = evb_info["host_password"]
    dst_dir = os.path.dirname(golden_data_list[0])
    ls_cmd = get_exec_cmd("ls " + dst_dir, ip_addr, usr, pwd)
    _, output = run_cmd_comm(ls_cmd)

    need_copy_file = ""
    for golden_data in golden_data_list:
        if golden_data not in output:
            need_copy_file += "%s " % golden_data

    # 执行copy
    if need_copy_file:
        mkdir_cmd = get_exec_cmd("mkdir -p " + dst_dir, ip_addr, usr, pwd)
        copy_cmd = mkdir_cmd + " ; sshpass -p %s scp -o " \
                               "StrictHostKeyChecking=no %s %s@%s:%s" \
                   % (pwd, need_copy_file, usr, ip_addr, dst_dir)
        run_cmd_comm(copy_cmd)


def broadcast_golden(own_evb_info, evb_info_list, golden_data_list):
    """

    :param own_evb_info:
    :param evb_info_list:
    :param golden_data_list:
    """
    done_host_list = []
    for evb_info in evb_info_list:
        if evb_info.get("host_ip", "localhost") == "localhost":
            continue
        if evb_info["host_ip"] in done_host_list \
                or evb_info["host_ip"] == own_evb_info["host_ip"]:
            continue
        # 检查目标文件在不在，不在则拷贝
        check_and_copy(evb_info, golden_data_list)
        done_host_list.append(evb_info["host_ip"])


def get_kernel_runner(evb_info, task_info):
    """
    获取evb host侧kernel_replay_comm的路径
    :param evb_info:
    :param task_info:
    :return:
    """
    default_path = os.path.join(evb_info['EVB_HOST_BASE_DIR'],
                                task_info["kernel_runner"])
    if evb_info.get("host_ip", "localhost") == "localhost":
        return default_path

    if task_info["local_kernel_runner"] == "1":
        return default_path

    run_install_path = evb_info.get("RUN_INSTALL_PATH", "/usr/local/Ascend")
    kernel_runner_path = ("python/site-packages/schedule_search/"
                          "libs/kernel_replay_comm")

    atc_kernel_runner = "%s/atc/%s" % (run_install_path, kernel_runner_path)
    if os.path.exists(atc_kernel_runner):
        return atc_kernel_runner

    fwk_kernel_runner = "%s/fwkacllib/%s" % (run_install_path,
                                             kernel_runner_path)
    if os.path.exists(fwk_kernel_runner):
        return fwk_kernel_runner

    return default_path


def gen_kernel_run_cmd(  # pylint: disable=R0913
        evb_info,
        task_info,
        kernel_file,
        cmp_kernel_file,
        gen_golden,
        inputs_para,
        outputs_paras):
    """

    :param evb_info:
    :param task_info:
    :param kernel_file:
    :param cmp_kernel_file:
    :param gen_golden:
    :param inputs_para:
    :param outputs_paras:
    :return:
    """
    cmp_paras = ""
    if task_info["cmp_device"] == "0":
        cmp_workspace_paras = " ".join(
            [str(x) for x in task_info.get('cmp_workspace_sizes', [])])
        cmp_paras = "{} {} {}".format(cmp_kernel_file,
                                      task_info["cmp_block_dim"],
                                      cmp_workspace_paras)
    kernel_runner = get_kernel_runner(evb_info, task_info)
    cmd_str = ("timeout {run_timeout} {kernel_runner} "
               "{input_cnt} {output_cnt} {host_kernel_file} {kernel_name} "
               "{block_dim} {repeat_cnt} {gen_golden} {debug} "
               "{accuracy_tolerance} {error_tolerance} {device_idx} "
               "{prof_type} {workspace_num} {cmp_device} "
               "{cmp_workspace_num} {inputs_para} {outputs_paras} "
               "{workspace_paras} {cmp_paras}")

    cmd = cmd_str.format(
        kernel_runner=kernel_runner,
        input_cnt=len(task_info.get('default_input_file', [])),
        output_cnt=len(task_info['expect_output_file_list']),
        host_kernel_file=kernel_file,
        kernel_name=task_info['kernel_name'],
        block_dim=task_info['block_dim'],
        repeat_cnt=int(task_info.get('repeat_count', 20)),
        gen_golden=gen_golden,
        debug=task_info['debug'],
        accuracy_tolerance=task_info.get('accuracy_tolerance', 0.0),
        error_tolerance=task_info.get('error_tolerance', 0.0),
        cmp_device=task_info.get('cmp_device', "0"),
        device_idx=evb_info.get("device_idx", "0"),
        prof_type=task_info.get("prof_type", "0"),
        inputs_para=inputs_para,
        outputs_paras=outputs_paras,
        cmp_paras=cmp_paras,
        run_timeout=task_info.get('run_timeout', 20),
        workspace_num=len(task_info.get('workspace_sizes', [])),
        cmp_workspace_num=len(task_info.get('cmp_workspace_sizes', [])),
        workspace_paras=" ".join(
            [str(x) for x in task_info.get('workspace_sizes', [])]))
    return cmd


def get_tick_by_rts(  # pylint: disable=R0913,R0914,R0912
        evb_info,
        task_info,
        kernel_file,
        cmp_kernel_file,
        gen_golden,
        inputs_para,
        outputs_paras):
    """

    :param evb_info:
    :param task_info:
    :param kernel_file:
    :param cmp_kernel_file:
    :param gen_golden:
    :param inputs_para:
    :param outputs_paras:
    :return:
    """
    cmd = ""
    if task_info['debug'] != "1":
        cmd += "ASCEND_GLOBAL_LOG_LEVEL=4 "
    if task_info['soc_version'] != SocVersion.ASCEND910:
        if evb_info.get("host_ip", "localhost") != "localhost":
            ld_library_env = evb_info.get(
                "LD_LIBRARY_PATH",
                "/usr/local/Ascend/acllib/lib64/:/usr/local/Ascend/atc/lib64")
            cmd += "LD_LIBRARY_PATH=%s " % ld_library_env
    cmd += gen_kernel_run_cmd(evb_info, task_info, kernel_file,
                              cmp_kernel_file, gen_golden, inputs_para,
                              outputs_paras)
    # 执行host_profile_cmd
    Log.info("cmd:%s", cmd)
    ret, ret_info = run_cmd_comm(cmd)
    if ret_info == "":
        ret_info = "no print log, maybe kernel run timeout!"
    ret_info += "\n" + cmd
    pattern = '========[Replay Print]========average cost:'
    lines = ret_info.split("\n")
    tick = 0
    ret = False
    for line in lines:
        if pattern in line:
            Log.info('Found tick line: %s', line)
            tick_str = line.split(pattern)[-1].strip()
            try:
                tick = float(tick_str)
            except (TypeError, ValueError):
                Log.warn('Can not convert tick to float. %s', tick_str)
                tick = 0
        elif "========[Replay Print]========memcmp output fail!" in line:
            return False, tick, ret_info
        elif "========[Replay Print]========Kernel Run Success!!" in line:
            ret = True
    # 一定要Success打印出来才认为是succ的
    ret = (tick > 0) and ret
    return ret, tick, ret_info


def run_kernel_online(evb_info, task_info):  # pylint: disable=R0914,R0912
    """

    :param evb_info:
    :param task_info:
    :return:
    """
    Log.dbg("run_a_kernel start.")
    op_name = task_info['op_name']
    default_input_file_list = task_info.get('default_input_file', [])
    input_size_list = task_info['input_size_list']
    # 本地生成输入数据文件
    gen_golden = int(task_info.get('gen_golden', 0))

    # kernel二进制文件路径
    host_kernel_file, host_cmp_kernel_file = get_kernel_path(
        task_info, evb_info)

    # inputs_para结构如下
    # /home/HwHiAiUser/tss/data/default_input@v1@float16
    # @157e856acef316702b998c05dc883426.data 14155776 float16
    # /home/HwHiAiUser/tss/data/default_input@v1@float32
    # @28d3cdcf54c444d1701e7c2d33178957.data 4096 float32
    inputs_para = []
    for i, input_file in enumerate(default_input_file_list):
        inputs_para.append("%s " % os.path.join(evb_info['EVB_HOST_DATA_DIR'], os.path.basename(input_file)))
        inputs_para.append("%s " % input_size_list[i])
        inputs_para.append("%s " % task_info['input_dtype_list'][i])

    Log.dbg("input_cnt:%s inputs_para:%s ", len(default_input_file_list),
            ''.join(inputs_para))

    # 预期输出数据文件及其长度
    outputs_paras = []
    expect_output_path_list = []
    golden_dir = os.path.join(evb_info['EVB_HOST_DATA_DIR'], op_name)
    if not os.path.exists(golden_dir):
        run_cmd_comm("mkdir -p " + golden_dir)
    # 判断本地是否存在golden，如果存在，本机执行replay comm的时候，就不用置1了
    golden_exists = True
    for i, expect_output_file_path \
            in enumerate(task_info['expect_output_file_list']):
        expect_output_file_path = os.path.join(
            golden_dir, os.path.basename(expect_output_file_path))
        expect_output_path_list.append(expect_output_file_path)
        outputs_paras.append("%s " % expect_output_file_path)
        outputs_paras.append("%d " % task_info['output_size_list'][i])
        outputs_paras.append("%s " % task_info['output_dtype_list'][i])
        outputs_paras.append("%s " % task_info['check_output_list'][i])
        outputs_paras.append("%s " % task_info['inplace_info_list'][i])
        if not os.path.exists(expect_output_file_path):
            golden_exists = False
    local_gen_golden = gen_golden
    if str(gen_golden) == "1" and golden_exists:
        local_gen_golden = 0
    Log.dbg("output_cnt: %s, output_sizes: %s",
            len(task_info['expect_output_file_list']), ''.join(outputs_paras))

    if task_info['prof_type'] == '0':
        ret, tick, ret_info = get_tick_by_rts(evb_info, task_info,
                                              host_kernel_file,
                                              host_cmp_kernel_file,
                                              local_gen_golden, ''.join(inputs_para),
                                              ''.join(outputs_paras))
    else:
        return False, 0, "unsupport prof_type: " + task_info['prof_type']
    Log.info("Run kernel over.")

    debug_str = ""
    # 1时使能debug
    if task_info['debug'] == "1":
        debug_str = "save debug output_data to " + \
                    os.path.join(evb_info['EVB_HOST_HOME'], CURR_OUTPUT_NAME)
        Log.dbg(debug_str)
    else:
        # host上的kernel文件删除
        run_cmd_comm("rm -rf " + os.path.dirname(host_kernel_file))

    Log.dbg("Run kernel end.")

    # 如果需要生成golden数据，则广播到集群里的各个host上去
    if str(gen_golden) == "1":
        broadcast_golden(evb_info, task_info["evbs"], expect_output_path_list)

    return ret, tick, ret_info + "\n" + debug_str


def gen_input_data(task_info, evb_info):
    """

    :param task_info:
    :param evb_info:
    :return:
    """
    # 若input_data不存在，则重新生成
    input_file_list = task_info.get('default_input_file', [])
    input_dtype_list = task_info.get('input_dtype_list', [])
    data_require = task_info.get('data_require', None)
    # 命令中增加输入数据的参数
    for i, input_file in enumerate(input_file_list):
        input_data_path = os.path.join(evb_info['EVB_HOST_DATA_DIR'],
                                       os.path.basename(input_file))
        if not os.path.exists(input_data_path):
            input_data = gen_random_input_data(DEFAULT_INPUT_SIZE,
                                               input_dtype_list[i],
                                               data_require)
            create_dir(os.path.dirname(input_data_path))
            with os.fdopen(os.open(input_data_path, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), "wb") as file_h:
                file_h.write(input_data)
    return True


def run_task_on_evb(evb_info, task_info):
    """

    :param evb_info:
    :param task_info:
    :return:
    """
    Log.dbg("run_task_on_evb is called,task_info:%s" % task_info['op_name'])
    # 判断输入是否存在
    ret = gen_input_data(task_info, evb_info)
    if ret is False:
        Log.dbg("gen_input_data fail!")
        return ret, 0, "\ngen input_data failed."

    return run_kernel_online(evb_info, task_info)


def get_disk_size(dir_path: str) -> int:
    """

    Parameters
    ----------
    dir_path

    Returns
    -------
    available disk size GB

    """
    stinfo = os.statvfs(dir_path)
    avail_disk_size = math.ceil(stinfo.f_bavail * stinfo.f_bsize / 1024 / 1024 / 1024)
    Log.info('path: %s, available size: %sG.', dir_path, str(avail_disk_size))
    return avail_disk_size


def clean_evb_host_golden_data(evb_info):
    """

    :param evb_info:
    """
    try:
        avail_space_gb = get_disk_size(evb_info['EVB_HOST_HOME'])
        # 当'~'目录的剩余空间小于1G，就要删了
        if avail_space_gb <= 1:
            # 只删第一层的算子目录，不删default共用文件
            ret, output = run_cmd_comm(
                'find %s -maxdepth 1 -type d -exec rm -rf {} +' %
                os.path.join(evb_info['EVB_HOST_DATA_DIR'], '*'))
            Log.info('Clean space ret: %s, output: \n%s', ret, output)
    except (ValueError, TypeError, FileNotFoundError) as exception:
        Log.warn('Can not clean space. %s', exception)


def update_evb_info(evb_info):
    """

    :param evb_info:
    """
    evb_host_home = evb_info.get(
        "host_home",
        os.path.join("/home", evb_info.get("host_user", "HwHiAiUser")))
    evb_info['EVB_HOST_HOME'] = evb_host_home
    evb_info['EVB_HOST_BASE_DIR'] = os.path.join(evb_host_home,
                                                 EVB_HOST_BASE_DIR_NAME,
                                                 evb_info.get("tss_workspace",
                                                              "tss_workspace"))
    evb_info['EVB_HOST_DATA_DIR'] = os.path.join(evb_info['EVB_HOST_BASE_DIR'],
                                                 EVB_HOST_DATA_DIR_NAME)
    evb_info['EVB_HOST_APP_BASE_DIR'] = os.path.join(
        evb_info['EVB_HOST_BASE_DIR'], "app")
    evb_info['EVB_HOST_DDK_DIR'] = os.path.join(evb_info['EVB_HOST_BASE_DIR'],
                                                "ddk")
    evb_info['EVB_HOST_HIPROF_DIR'] = os.path.join(
        evb_info['EVB_HOST_BASE_DIR'], "tools")


def get_ts_by_file_name(file_name):
    """

    :param file_name:
    :return:
    """
    try:
        splits = file_name.split('.')[-2].split('_')
        ts_str = splits[-4] + '_' + splits[-3]
        curr_ts = datetime.datetime.strptime(ts_str, '%Y%m%d_%H%M%S')
        return curr_ts
    except IndexError:
        return None


def check_before_run(evb_info):
    """

    :param evb_info:
    :return:
    """
    #  如果存在停止标记不跑了
    host_base = evb_info['EVB_HOST_BASE_DIR']
    stop_flag = "STOP-" + str(evb_info.get("device_idx", "0"))
    if os.path.exists(os.path.join(host_base, "STOP")) \
            or os.path.exists(os.path.join(host_base, stop_flag)):
        Log.err('STOP file exists, device stop running, please try later!')
        return False

    return True


def get_param_str():
    """

    :return:
    """
    return r'''@param_str@'''


def main():  # pylint: disable=R0912
    """

    :return:
    """
    # 如果是Local连接方式的EVB，直接调用run_task_on_evb这个函数就好了，
    # 如果是Remote连接方式的EVB，则需要把这个文件从Remote端发到EVB的Host上，
    # 然后用SSH触发HOST侧执行这个文件
    param_str = get_param_str()
    try:
        evb_info, task_info = json.loads(param_str)
        update_evb_info(evb_info)
    except json.decoder.JSONDecodeError:
        Log.err('load params failed.')
        return

    if not check_before_run(evb_info):
        return

    ret, tick, info = run_task_on_evb(evb_info, task_info)
    Log.info('[ret]: %s, [tick]: %s, [ret_info]: %s', ret, tick, info)

    # 把超过24小时的evb_host脚本全删了，不然会越积越多，浪费空间
    # 当前时间从当前文件的名字中取，不然这个EVBHost可能时间不准
    curr_ts = get_ts_by_file_name(THIS_FILE_NAME)
    if curr_ts is not None:
        for fname in os.listdir(FILE_PATH):
            if fname.startswith('evb_host_') and fname.endswith('.py'):
                try:
                    splits = fname.split('.')[0].split('_')
                    ts_str = splits[-4] + '_' + splits[-3]
                    f_ts = datetime.datetime.strptime(ts_str, '%Y%m%d_%H%M%S')
                    life_long_seconds = (curr_ts - f_ts).total_seconds()
                    if life_long_seconds > 3600:
                        os.remove(os.path.join(FILE_PATH, fname))
                except IndexError:
                    Log.dbg('Got IndexError.')
                except OSError:
                    Log.dbg('Got OSError.')

    # 如果本地空间剩余不多了，就把Golden数据目录全删了
    clean_evb_host_golden_data(evb_info)
    return


if __name__ == '__main__':
    main()
