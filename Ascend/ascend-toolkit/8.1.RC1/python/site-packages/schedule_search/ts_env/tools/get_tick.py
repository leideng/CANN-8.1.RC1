#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import json
import logging
import os

from schedule_search import log
from schedule_search import soc_cfg
from schedule_search import util
from schedule_search.controller.search_comm import pre_processing_proc
from schedule_search.ts_env.env_classes import KernelRunArgsInfo
from schedule_search.ts_env.env_classes import TensorInfo
from schedule_search.ts_env.estimator.evb import evb_host
from schedule_search.ts_env.estimator.evb.evb_client import copy_data_to_evb_host
from schedule_search.ts_env.estimator.kernel_runner import EvbRunner
from schedule_search.ts_env.op_schedule_info import OpScheduleInfo
from schedule_search.ts_env.te_auto_schedule_env import get_op_schedule_info
from schedule_search.util import OPEN_FILE_MODES_640
from schedule_search.util import WRITE_FILE_FLAGS


def get_tick_no_res(op_func,  # pylint: disable=R0913,R0914,R0912
                    input_params,
                    kernel_name,
                    input_tensor_list,
                    output_tensor_list,
                    evb_conf=None,
                    quantized=False,
                    accuracy_tolerance=0.001,
                    error_tolerance=0.001,
                    repeat_count=20,
                    op_name="default",
                    debug=False):
    """
        1, op_func: 算子入口函数，如：
            import impl.split_d as split_d，其中op_func为split_d
        2, input_params: 算子入口函数对应的参数列表
        3, kernel_name
        4, input_tensor_list：算子输入Tensor列表，格式为：
            [{"shape": [], "dtype": xx, "data": /xx/xx},
            {"shape": [], "dtype": xx, "data": /xx/xx}]
        5, output_tensor_list：算子输出Tensor列表，格式为：
            [{"shape": [], "dtype": xx, "data": /xx/xx},
            {"shape": [], "dtype": xx, "data": /xx/xx}]
        6, evb_conf: evb配置文件，可选参数，如果直接在evb host侧运行，可不传
        7, quantized: 是否量化算子，如果是则使用比较正负1来计算误差
        8, accuracy_tolerance: 容忍精度误差；
        9, error_tolerance: 容忍错误率；
        10, repeat_count: 算子kernel上板执行次数
    """
    option = {}
    if evb_conf is not None:
        option["evb_conf"] = evb_conf
    # 初始化和检查流程
    ret, option_list = pre_processing_proc(None, option, [None])
    option = option_list[0]
    os.environ["GET_RES"] = ""
    # 使用cpu比对
    option["cmp_device"] = "1"
    option["accuracy_tolerance"] = accuracy_tolerance
    option["error_tolerance"] = error_tolerance
    option["repeat_count"] = repeat_count

    op_func(*input_params)
    kernel_bin_path = os.path.join(soc_cfg.kernel_meta_dir(),
                                   "%s.o" % kernel_name)
    kernel_run_obj = KernelRunArgsInfo(op_name, len(output_tensor_list),
                                       kernel_bin_path, None)

    input_info_list = []
    for i, input_tensor_dict in enumerate(input_tensor_list):
        tensor_info = TensorInfo("input_%s" % i, input_tensor_dict["shape"],
                                 input_tensor_dict["dtype"])
        log.dbg("input, name: %s, shape: %s, dtype: %s", tensor_info.name,
                tensor_info.shape, tensor_info.dtype)
        input_info_list.append(tensor_info)
        option.setdefault("golden_input", []).append(input_tensor_dict["data"])

    output_info_list = []
    for i, output_tensor_dict in enumerate(output_tensor_list):
        tensor_info = TensorInfo("output_%s" % i, output_tensor_dict["shape"],
                                 output_tensor_dict["dtype"])
        log.dbg("output, name: %s, shape: %s, dtype: %s", tensor_info.name,
                tensor_info.shape, tensor_info.dtype)
        output_info_list.append(tensor_info)
        if "data" in output_tensor_dict:
            option.setdefault("golden_output",
                              []).append(output_tensor_dict["data"])

    op_schedule_info = OpScheduleInfo(kernel_name, [], None, input_info_list,
                                      output_info_list, kernel_name, "", 2,
                                      option, {}, [], {}, 0)
    evb_info = util.get_evb_info(op_schedule_info.option)
    data_path = "%s/%s" % (evb_info['EVB_HOST_BASE_DIR'],
                           evb_host.EVB_HOST_DATA_DIR_NAME)
    for input_file in op_schedule_info.input_file_list:
        input_file_path = os.path.join(data_path, os.path.basename(input_file))
        ret = copy_data_to_evb_host(evb_info, input_file, input_file_path)
        if not ret:
            log.err("copy default schedule input: %s to evb host: %s failed!",
                    input_file, input_file_path)
            return False, 0

    check_output = 0
    if option.get("golden_output", []):
        check_output = 4 if quantized else 2
        output_data_path = os.path.join(data_path, op_schedule_info.op_name)
        # 拷贝到evb host侧
        for output_file in op_schedule_info.expect_output_file_list:
            output_file_path = os.path.join(output_data_path,
                                            os.path.basename(output_file))
            ret = copy_data_to_evb_host(evb_info, output_file,
                                        output_file_path)
            if not ret:
                log.err(
                    "copy default schedule output: %s to evb host: %s "
                    "failed!", output_file, output_file_path)
                return False, 0

    runner = EvbRunner(op_schedule_info,
                       kernel_run_obj,
                       debug=debug,
                       print_output=True,
                       check_output=check_output)
    ret, tick, err_code = runner.run(evb_info)
    log.info("=======input_params: %s, ret: %s, tick: %s, err_code: %s" %
             (input_params, ret, tick, err_code))
    return ret, tick


def get_tick_with_res(res,  # pylint: disable=R0913,R0914,R0912
                      option,
                      op_func,
                      input_params,
                      kernel_name,
                      update_base_tick=False,
                      accuracy_tolerance=None,
                      error_tolerance=None,
                      debug=False):
    """

    :param res:
    :param option:
    :param op_func:
    :param input_params:
    :param kernel_name:
    :param update_base_tick:
    :param accuracy_tolerance:
    :param error_tolerance:
    :return:
    """
    # 初始化和检查流程
    ret, option_list = pre_processing_proc(None, option, [res])
    option = option_list[0]
    os.environ["GET_RES"] = ""
    try:
        op_func(*input_params)
    except Exception as excp:  # pylint: disable=broad-except
        log.err("input_params: %s, auto_schedule build fail!, exp: %s",
                input_params, str(excp))
        # 若auto schedule失败，与cpu比对
        option["no_base_tune"] = True
    kernel_bin_path = os.path.join(soc_cfg.kernel_meta_dir(),
                                   "%s.o" % kernel_name)
    option['base_kernel'] = kernel_bin_path
    op_schedule_info = get_op_schedule_info(res, option)[0]
    if accuracy_tolerance is not None:
        op_schedule_info.option["accuracy_tolerance"] = accuracy_tolerance
    if error_tolerance is not None:
        op_schedule_info.option["error_tolerance"] = error_tolerance
    # 删掉原来的kernel目录
    kernel_json = kernel_bin_path.replace(".o", ".json")
    if os.path.exists(kernel_bin_path):
        os.remove(kernel_bin_path)
    if os.path.exists(kernel_json):
        os.remove(kernel_json)
    os.environ["GET_RES"] = ""
    try:
        op_func(*input_params)
    except Exception as excp:  # pylint: disable=broad-except
        log.err("input_params: %s, exception, exp: %s", input_params,
                str(excp))
        return False, 0, 0

    op_name = op_schedule_info.op_name
    output_cnt = len(op_schedule_info.output_info_list)
    kernel_run_obj = KernelRunArgsInfo(op_name, output_cnt, kernel_bin_path,
                                       None)
    runner = EvbRunner(op_schedule_info,
                       kernel_run_obj,
                       debug=debug,
                       print_output=True)
    evb_info = util.get_evb_info(op_schedule_info.option)
    ret, tick, err_code = runner.run(evb_info)
    log.info("input_params: %s, ret: %s, tick: %s, err_code: %s", input_params,
             ret, tick, err_code)
    if not update_base_tick:
        return ret, op_schedule_info.base_tick, tick
    # 刷到json里
    op_data_path = os.path.join(op_schedule_info.replay_dir, "data",
                                op_schedule_info.op_name)
    util.create_dir(op_data_path)
    base_tick_file = os.path.join(op_data_path, "base_tick.json")
    if os.path.exists(base_tick_file):
        with open(base_tick_file, 'r') as file_handler:
            base_tick_dict = json.load(file_handler)
    else:
        base_tick_dict = {}
    base_tick_dict[op_schedule_info.shape_list_str] = tick
    with os.fdopen(os.open(base_tick_file, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), "w") as file_handler:
        json.dump(base_tick_dict, file_handler)
    return ret, tick, tick
