#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import datetime
import json
import os
import time
from enum import Enum
from schedule_search import log
from schedule_search import tune_util
from schedule_search.controller.search_comm import get_best_sch_path
from schedule_search.ts_env.env_classes import LocalLock
from schedule_search.util import OPEN_FILE_MODES_640
from schedule_search.util import WRITE_FILE_FLAGS
from tbe.common.rl_bank.rl_bank import get_bank_name


class ArgIndex(Enum):
    """
    indices for input arguments
    """
    op_schedule_infos_list_idx = 0
    option_idx = 1
    ignore_ops_idx = 2
    op_tune_res_idx = 3
    total_length = 4


def update_tune_statics(op_schedule_info: object, tune_statics: dict) -> None:
    """
    update tune statics content
    :param op_schedule_info: op schedule info
    :param tune_statics: previous tune statics
    :return:
    """
    layer_name = op_schedule_info.tune_result_key
    # 上一次的数据可以全丢弃了，反正都是全量统计
    tune_statics[layer_name]['ticks_best'] = []

    sch_list = []
    store_dir = op_schedule_info.store_dir
    run_succ_path = os.path.join(store_dir, "run_succ")
    if os.path.exists(run_succ_path):
        sch_list = os.listdir(run_succ_path)

    # 把Py中的tick和ts信息解析出来，然后按时间顺序排序
    py_info = []
    for py_file in sch_list:
        timestamp = int(py_file.split(".py")[0].split('_')[-1])
        best_tick = int(py_file.split('_')[0])
        py_info.append((timestamp, best_tick))
    py_info.sort(key=lambda x: x[0])

    for timestamp, best_tick in py_info:
        ts_str = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(timestamp/1000))
        new_best = "[%s, %s]" % (best_tick, ts_str)
        tune_statics[layer_name]['ticks_best'].append(new_best)

    # 打印当前调优状态，不能光打调出更优的了，还要把没调的也打了，保证每次打的是全量的
    if tune_statics[layer_name]['ticks_best']:
        last_best_ticks = get_last_best_ticks(tune_statics, layer_name)
        best_tick = min(last_best_ticks)
    else:
        best_tick = op_schedule_info.base_tick
    log.dbg("layer_name: %s, current best_tick: %s." % (layer_name, best_tick))


def try_update_bank(op_schedule_info: object, best_sch_path: str, best_tick: int, base_tick: int) -> bool:
    """
    try to update into the bank
    :param op_schedule_info: op's schedule info
    :param best_sch_path: best schedule file's path
    :param best_tick: best tick
    :param base_tick: base tick
    :return:
    """
    # 尝试放到bank里
    time_stamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S_%f')
    op_mode = op_schedule_info.option.get('op_mode', '')
    bank_name = get_bank_name(op_mode)
    kernel_name = op_schedule_info.option.get('op_config', {}).get("kernel_name", "default")
    kernel_name = kernel_name.split("@")[0]
    op_type = op_schedule_info.op_name
    op_shape = op_schedule_info.shape_list_str
    op_info_str = "{}@{}@{}".format(kernel_name, op_type, op_shape)
    bank_info = tune_util.BankInfo('{}_{}'.format(bank_name, time_stamp), 'custom', op_mode)
    return tune_util.add_best_to_bank((best_tick, base_tick),
                                      os.path.join(op_schedule_info.store_dir, 'run_succ', best_sch_path),
                                      op_info_str,
                                      bank_info)


def update_layer_status_data(tune_statics: dict, layer_name:str) -> None:
    """
    update status data in tune statics corresponding to the layer name
    :param tune_statics: tune statics content
    :param layer_name: layer name
    :return:
    """
    layer_status_data = tune_statics[layer_name]["status_data"]
    if layer_status_data['bank_hit']:
        layer_status_data['bank_update'] = True
        layer_status_data['bank_reserved'] = False
    else:
        layer_status_data['bank_append'] = True


def get_last_best_ticks(tune_statics: dict, layer_name: str) -> list:
    """
    get previous best ticks from tune_statics
    :param tune_statics: tune statics content
    :param layer_name: layer name
    :return: last_best_ticks
    """
    ticks_best = tune_statics[layer_name]["ticks_best"]
    last_best_ticks = []
    for tick in ticks_best:
        tick_num = tick.split('[')[1].split(',')[0]
        last_best_ticks.append(int(tick_num))
    return last_best_ticks


def check_and_update_banks(op_schedule_info: object, tune_statics: dict, op_tune_res: dict) -> None:
    """
    check conditions and try to update banks
    :param op_schedule_info: op's schedule info
    :param tune_statics: tune statics content
    :param op_tune_res: op tune update bank statics
    :return:
    """
    best_sch_path = get_best_sch_path(op_schedule_info, op_schedule_info.store_dir)

    layer_name = op_schedule_info.tune_result_key
    if best_sch_path:
        best_py = os.path.basename(best_sch_path)
        best_tick, best_sch_path, base_tick = tune_util.parse_tune_res(best_py)

        # 获取历史最佳, tick的格式为（tick, timestamp）
        last_best_ticks = get_last_best_ticks(tune_statics, layer_name)
        tune_statics[layer_name]["result_data"]['before_tune'] = base_tick
        tune_statics[layer_name]["result_data"]['after_tune'] = min(base_tick, best_tick)
        if not last_best_ticks or best_tick < min(last_best_ticks):
            # 加入bank
            if try_update_bank(op_schedule_info, best_sch_path, best_tick, base_tick):
                kernel_name = op_schedule_info.option.get('op_config', {}).get("kernel_name", "default")
                op_tune_res[kernel_name.split("@")[0]] = True
                log.dbg("op %s op_tune_res during tune: %s", kernel_name, op_tune_res)
                update_layer_status_data(tune_statics, layer_name)


def read_tune_statics(tune_statics_file: str) -> dict:
    """
    read tune statics file
    :param tune_statics_file: file name
    :return: tune_statics
    """
    # 统计文件和tune_show目录在同一个目录下，后面和ga保持一致
    if os.path.isfile(tune_statics_file):
        local_lock = LocalLock(tune_statics_file)
        local_lock.lock()
        try:
            with open(tune_statics_file, "r") as file_handler:
                tune_statics = json.load(file_handler)
                tune_statics = tune_statics if isinstance(tune_statics, dict) else {}
        except (IOError, AttributeError, json.decoder.JSONDecodeError) as excp:
            log.warn("RL exception occur: %s does not exist or cannot load, raise exception: %s",
                     tune_statics_file, repr(excp))
            tune_statics = {}
        finally:
            local_lock.unlock()
    else:
        tune_statics = {}
    return tune_statics


def tune_statics_update(op_schedule_infos_list: list, tune_statics: dict, ignore_ops: list, op_tune_res: dict) -> None:
    """
    update tune statics content
    :param op_schedule_infos_list: list of op's schedule info
    :param tune_statics: tune statics content to update
    :param ignore_ops: ignore ops list
    :param op_tune_res: op update bank during tune statics
    :return:
    """
    rl_layers = set()
    for ignore_op in ignore_ops:
        layer_name = ignore_op['tune_result_key']
        hit_bank = ignore_op['hit_bank']
        default_status = {'bank_hit': hit_bank,
                          'bank_append': False,
                          'bank_reserved': hit_bank,
                          'bank_update': False}
        tune_statics.setdefault(layer_name, {})
        tune_statics[layer_name].setdefault("ticks_best", [])
        tune_statics[layer_name].setdefault("result_data", {})
        tune_statics[layer_name].setdefault("status_data", default_status)
        rl_layers.add(layer_name)

    for op_schedule_infos in op_schedule_infos_list:
        layer_name = op_schedule_infos[0].tune_result_key
        hit_bank = op_schedule_infos[0].option.get(
            'op_config', {}).get('hit_bank', False)
        default_status = {'bank_hit': hit_bank,
                          'bank_append': False,
                          'bank_reserved': hit_bank,
                          'bank_update': False}
        tune_statics.setdefault(layer_name, {})
        tune_statics[layer_name].setdefault("ticks_best", [])
        tune_statics[layer_name].setdefault("result_data", {})
        tune_statics[layer_name].setdefault("status_data", default_status)

        # 更新Bank
        check_and_update_banks(op_schedule_infos[0], tune_statics, op_tune_res)

        # 更新tune数据
        update_tune_statics(op_schedule_infos[0], tune_statics)
        rl_layers.add(layer_name)

    all_layers = set(tune_statics.keys())
    for layer_name in all_layers - rl_layers:
        tune_statics.pop(layer_name)


def write_tune_statics(tune_statics_file: str, tune_statics: dict) -> None:
    """
    write new tune statics content into file
    :param tune_statics_file: file name
    :param tune_statics: new tune statics
    :return:
    """
    if not os.path.exists(tune_statics_file):
        with os.fdopen(os.open(tune_statics_file, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), 'w') as file_handler:
            json.dump({}, file_handler, sort_keys=True, indent=4)

    local_lock = LocalLock(tune_statics_file)
    local_lock.lock()
    new_tune_statics = {}
    # 要写入的时候重新读一次，然后把本次的数据Update进去，不要误删GA的数据
    try:
        with open(tune_statics_file, "r") as file_handler:
            new_tune_statics = json.load(file_handler)
            if not isinstance(new_tune_statics, dict):
                new_tune_statics = {}
    except (IOError, AttributeError, json.decoder.JSONDecodeError) as excp:
        log.warn("RL exception occur: write tune_statics of %s, raise exception: %s", tune_statics_file, repr(excp))
    finally:
        pass

    new_tune_statics.update(tune_statics)
    with os.fdopen(os.open(tune_statics_file, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), 'w') as file_handler:
        json.dump(new_tune_statics, file_handler, sort_keys=True, indent=4)
    log.dbg("The tune_statics_file of %s is updated.", tune_statics_file)
    local_lock.unlock()


def proc(args: tuple, start_time:float) -> None:
    """
    main proc to do bank update and tune statics update
    :param args: (op_schedule_infos_list, option, ignore_ops, (op_tune_res))
    :param start_time: start time
    :return:
    """
    op_schedule_infos_list = args[ArgIndex.op_schedule_infos_list_idx.value]
    option = args[ArgIndex.option_idx.value]
    ignore_ops = args[ArgIndex.ignore_ops_idx.value]
    op_tune_res = {}
    if len(args) == ArgIndex.total_length.value:
        op_tune_res = args[ArgIndex.op_tune_res_idx.value]

    current_time = time.time()
    timeout = int(option.get('timeout', 60 * 60 * 24))
    remaining_time = timeout - (current_time - start_time)
    if remaining_time > 0:
        log.info("Tuning remaining time: %d seconds", int(remaining_time))

    tune_show = op_schedule_infos_list[0][0].option.get('tune_show_dir', option.get("WORKSPACE", ""))

    if tune_show:
        tune_statics_file_split = tune_show.rsplit("tune_show", 1)
        tune_statics_file = "tune_result".join(tune_statics_file_split) + ".json"
    else:
        tune_statics_file = 'tune_result.json'
    # 读取原始的tune_statics
    tune_statics = read_tune_statics(tune_statics_file)
    # 更新tune_statics，并打印
    tune_statics_update(op_schedule_infos_list, tune_statics, ignore_ops, op_tune_res)
    # 写入新的tune_statics
    write_tune_statics(tune_statics_file, tune_statics)
