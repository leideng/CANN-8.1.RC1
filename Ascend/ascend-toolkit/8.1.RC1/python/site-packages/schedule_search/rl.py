#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import datetime
import os
import sys
import time
import json
import traceback
import multiprocessing
from collections import namedtuple
from absl import flags

from tbe.common.rl_bank.add_cheque import get_cheque_from_sch
from tbe.common.rl_bank.rl_bank import get_bank_name
from tbe.common.rl_bank.rl_bank import satisfy_bank
from tbe.common.rl_bank.rl_op_filter import rl_op_filter
from schedule_search import log
from schedule_search import tune_util
from schedule_search.controller import search_comm
from schedule_search.controller.mcts_search.mcts_searcher import mcts_search
from schedule_search.rl_progress_report import report_rl_tune_progress
from schedule_search.rl_progress_report import report_rl_tune_result
from schedule_search.soc_cfg import set_soc_info
from schedule_search.ts_env.estimator.estimate import re_get_base_tick
from schedule_search.ts_env.estimator.kernel_runner import ErrorCode
from schedule_search.ts_env.te_auto_schedule_env import get_op_schedule_info
from schedule_search.soc_cfg import get_core_num
from schedule_search.util import WRITE_FILE_FLAGS
from schedule_search.util import OPEN_FILE_MODES_640

BASE_TICK_THRESHOLD = 20
SMOKE_SUCC_CONDITION = "RL schedule search finish succ"
QUERY_SLEEPTIME = 0.001
BASETICK_OPTYPE_LIST = ["clipbyvalue"]

FLAGS = flags.FLAGS
# flags都是通过option的方式暴露给用户，不让用户直接指定flags，
# 所以这里不接受外部的flag参数，只做初始化赋值
FLAGS([sys.argv])


class PostRunAsync(multiprocessing.Process):
    """
    post_process_and_update_bank_async
    """
    def __init__(self,
                 communicate_option: dict,
                 op_mode: str,
                 global_manager: object,
                 main_pid: int,
                 *args,
                 **kwds) -> None:
        super(PostRunAsync, self).__init__(*args, **kwds)
        self.communicate_option = communicate_option
        self.op_mode = op_mode
        self.main_pid = main_pid
        self.exit_event = global_manager.multi_mgr.Event()
        # list of tuples(op_schedule_info, option_info, top_cheque_infos, tune_res_flag)
        self.update_bank_list = global_manager.multi_mgr.list()
        # list of bools indicating bank_udpate result
        self.update_bank_res = global_manager.multi_mgr.list()

    @staticmethod
    def _deal_with_not_full_core_num(best_cheque_info: dict, option_info: dict) -> None:
        """
        if block_dim less core_num, need warning log and save op args
        :param best_cheque_info:
        :param option_info:
        :return:
        """
        kernel_name = option_info.get("op_config").get("kernel_name", "default")
        if best_cheque_info.get("block_dim") >= get_core_num():
            return
        log.warn("This strategy doesn't make use of all cores.")
        suboptimal_path = option_info.get("suboptimal_path")
        if suboptimal_path == '':
            return
        suboptimal_file_name = kernel_name + ".json"
        suboptimal_file_path = os.path.join(suboptimal_path, suboptimal_file_name)
        op_desc = option_info.get("op_config").get("op_desc")
        with os.fdopen(os.open(suboptimal_file_path, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), "w") as f_handle:
            json.dump(op_desc, f_handle, sort_keys=True, indent=4)

    def run(self) -> None:
        """
        post_process_and_update_bank
        """
        log.event("RL tune info: PostRunAsync start to post_process_and_update_bank.")
        while not self.exit_event.is_set():
            if not self.update_bank_list:
                continue

            op_schedule_info, option_info, top_cheque_infos, tune_res = self.update_bank_list.pop()
            kernel_name = option_info.get("kernel_name", "default")
            set_soc_info(option_info.get("soc_version"), option_info.get("core_type"),
                         option_info.get("core_num"), option_info.get("l1_fusion"))
            cb_struct_key = option_info.get("cb_struct_key")
            get_base_flag = True if op_schedule_info.option.get("op_type", "") in BASETICK_OPTYPE_LIST else False
            if not tune_res:
                # mcts search failed
                self.clean_legacy_task(cb_struct_key, kernel_name)
                self.report_tune_result(option_info, op_schedule_info, False, False)
                if get_base_flag:
                    re_get_tick, _ = re_get_base_tick(op_schedule_info, self.communicate_option)
                continue

            self.clean_legacy_task(cb_struct_key, kernel_name)
            best_cheque_info = search_comm.get_best_cheque_info(op_schedule_info, top_cheque_infos, kernel_name,
                                                                self.communicate_option, get_base_flag)
            if not best_cheque_info:
                log.info("RL tune info: op %s has no valid cheque_info.", kernel_name)
                self.report_tune_result(option_info, op_schedule_info, True, False)
                continue

            self._deal_with_not_full_core_num(best_cheque_info, option_info)

            bank_updated_flag = self.check_and_update_bank(best_cheque_info, op_schedule_info)
            self.report_tune_result(option_info, op_schedule_info, True, bank_updated_flag)
        log.event("RL tune info: PostRunAsync exit_event set, post_process_and_update_bank end.")

    def clean_legacy_task(self, cb_struct_key: str, kernel_name: str) -> None:
        """
        clean up tasks left over from the search process
        :param cb_struct_key:
        :param kernel_name:
        """
        # tell opat this op has been search, legacy task should be cleaned
        cb_key_task_clean_q = self.communicate_option.get("cb_key_task_clean_q", None)
        cb_key_task_clean_res_dict = self.communicate_option.get("cb_key_clean_res_d", None)
        if cb_key_task_clean_q is not None and cb_key_task_clean_res_dict is not None:
            log.dbg("RL tune info: task %s is put to cb_key_task_clean_q.", cb_struct_key)
            cb_key_task_clean_q.put(cb_struct_key)
            while cb_key_task_clean_res_dict.pop(cb_struct_key, None) is None:
                time.sleep(QUERY_SLEEPTIME)
            log.dbg("RL tune info: task %s is cleaned.", cb_struct_key)
        log.info("RL tune info: all legacy compile_and_run tasks are cleaned (cb_struct_key: %s) for op %s.",
                cb_struct_key, kernel_name)

    def report_tune_result(self,
                         option_info: dict,
                         op_schedule_info: object,
                         tune_res: bool,
                         bank_updated_flag: bool) -> None:
        """
        clean compile_and_run tasks and report rl tune result
        :param option_info:
        :param op_schedule_info:
        :param tune_res:
        :param bank_updated_flag:
        :return:
        """
        kernel_name = option_info.get("kernel_name", "default")
        self.update_bank_res.append(bank_updated_flag)
        log.info("RL tune info: op %s update_bank: %s", kernel_name, bank_updated_flag)

        tune_report_info_q = self.communicate_option.get("tune_report_info_q")
        job_id = option_info.get("job_id", "")
        report_rl_tune_result(op_schedule_info, tune_report_info_q, bank_updated_flag, tune_res, job_id)

        timer_queue = self.communicate_option.get("timer_q")
        cb_struct_key = option_info.get("cb_struct_key")
        timer_queue.put(("stop", self.main_pid, "tune_op_%s" % cb_struct_key))

    def check_and_update_bank(self, best_cheque_info: dict, op_schedule_info: object) -> bool:
        """
        check best_cheque_info and try to add to bank
        :param best_cheque_info: a dict, including "base_tick" "best_tick" "bank_key" "cheque"
        :param op_schedule_info: op schedule info class
        :return: T/F, bank_updated_flag
        """
        kernel_name = op_schedule_info.option.get('op_config', {}).get("kernel_name", "default")
        kernel_name = kernel_name.split("@")[0]

        best_tick = best_cheque_info.get("best_tick")
        base_tick = best_cheque_info.get("base_tick")
        best_sch_path = best_cheque_info.get("best_sch_path", "")
        log.event("RL tune info: op %s check_and_update_bank, best_tick: %s, base_tick: %s.",
                kernel_name, best_tick, base_tick)

        if not satisfy_bank(base_tick, best_tick, 'in'):
            log.info("RL tune info: op: %s not satisfy bank update conditions, check_and_update_bank end.", kernel_name)
            return False

        # save best cheque to rl bank
        bank_name = get_bank_name(self.op_mode)
        custom_bank_file = '{}_{}'.format(bank_name, datetime.datetime.now().strftime('%Y%m%d_%H%M%S_%f'))
        bank_info = tune_util.BankInfo(custom_bank_file, 'custom', self.op_mode)
        op_info_str = "{}@{}@{}".format(kernel_name, op_schedule_info.op_name, op_schedule_info.shape_list_str)
        if tune_util.add_best_to_bank((best_tick, base_tick), best_sch_path, op_info_str, bank_info, best_cheque_info):
            op_schedule_info.best_tick = best_tick
            return True
        return False

    def stop(self) -> None:
        """
        stop PostRunAsync
        """
        self.exit_event.set()
        self.join()


def tune_single_op(res: list,
                   option_info: dict,
                   tune_progress_q: object,
                   update_bank_async_process: object,
                   cb_struct_key: str) -> bool:
    """
    do tune for single op
    :param res
    :param option_info
    :param tune_progress_q
    :param update_bank_async_process
    :param cb_struct_key
    :return op_tuned_flag, bank_updated_flag
    """
    start_time = time.time()
    time_out = option_info.get("timeout")
    kernel_name = option_info.get("kernel_name", "default")

    set_soc_info(option_info.get("soc_version"), option_info.get("core_type"),
                 option_info.get("core_num"), option_info.get("l1_fusion"))
    single_op_schedule_infos = get_op_schedule_info(res, option_info)
    if not single_op_schedule_infos:
        return False
    # 各个Option可能是不同的，根据Option信息获取各个目录信息
    search_comm.get_dir_by_option(option_info, single_op_schedule_infos, FLAGS)

    base_tick = single_op_schedule_infos[0].base_tick
    # if op gets base failed, ignore it
    if single_op_schedule_infos[0].base_run_err_code != ErrorCode.RUN_SUCC or base_tick <= 0:
        log.warn("RL tune info: op %s auto schedule can not run , skip it.", kernel_name)
        report_rl_tune_progress(tune_progress_q, cb_struct_key, time_out, "skip")
        return False

    if not rl_op_filter.is_tune_all_op and base_tick <= BASE_TICK_THRESHOLD:
        log.event("RL tune info: op %s auto schedule is good enough, no need to tune.", kernel_name)
        report_rl_tune_progress(tune_progress_q, cb_struct_key, time_out, "skip")
        return False

    log.event("RL tune info: op %s begin to tune, op_type: %s, output_info_list: %s, base_tick: %d, core_type: %s, "
              "core_num: %s.", kernel_name, single_op_schedule_infos[0].op_name,
              single_op_schedule_infos[0].output_info_list, base_tick,
              option_info.get("core_type"), option_info.get("core_num"))
    report_rl_tune_progress(tune_progress_q, cb_struct_key, time_out, "start")

    # start mcts search
    try:
        mcts_search(single_op_schedule_infos, time_out)
    except Exception as exception:
        log.err("RL exception occur: op %s tune failed. error msg: %s, traceback info: %s.", kernel_name,
                repr(exception), traceback.format_exc())
        update_bank_async_process.update_bank_list.append((single_op_schedule_infos[0], option_info, None, False))
        return True
    finally:
        log.event("RL search info: mcts search end.")

    report_rl_tune_progress(tune_progress_q, cb_struct_key, time_out, "end")

    top_cheque_infos = search_comm.get_top_cheque_info(single_op_schedule_infos[0])
    update_bank_async_process.update_bank_list.append((single_op_schedule_infos[0], option_info,
                                                       top_cheque_infos, True))

    end_time = time.time()
    log.event("RL tune info: op %s search succ, duration: %d seconds.", kernel_name, end_time - start_time)
    return True


def tune(res_list: list, option: dict, communicate_option: dict, op_config_list: list,
         global_multiprocess_mgr: object) -> bool:
    """
    RL调优，先推理在搜索，取最优的结果
    :param res_list: 算子输出tensor列表
    :param option: 推理选项
    :param communicate_option
    :param op_config_list: 每个算子独有的一些配置
    :param global_multiprocess_mgr
    :return: T/F
    """
    timer_queue = communicate_option.get("timer_q")
    tune_progress_q = communicate_option.get("tune_progress_q")

    # prepare: check, initialization and pre processing
    FLAGS.workspace = option.get("WORKSPACE", None)
    ret, option_info_list = search_comm.pre_processing_proc(FLAGS, option, res_list, op_config_list)
    if not ret:
        log.err("RL schedule tune pre_processing failed.")
        return False
    log.info("RL tune info: pre_processing successfully.")

    FLAGS.load_file_rl = os.path.join(FLAGS.workspace, "work_dir/init")
    FLAGS.infer_dir_rl = os.path.join(FLAGS.workspace, "outputs")

    # start thread for postprocessing and bank updating
    update_bank_async_process = PostRunAsync(communicate_option, option.get("op_mode", ''),
                                             global_multiprocess_mgr, os.getpid())
    update_bank_async_process.start()

    # start search
    global_multiprocess_mgr.init_shared_dict()
    ops_tuned_num = 0
    log.event("RL tune info: there are %d ops try to tune.", len(res_list))
    for res, option_info in zip(res_list, option_info_list):
        cb_struct_key = option_info.get("cb_struct_key")
        timer_queue.put(("start", os.getpid(), "tune_op_%s" % cb_struct_key))
        global_multiprocess_mgr.clear_shared_dict()
        tuned_flag = tune_single_op(res, option_info, tune_progress_q, update_bank_async_process, cb_struct_key)
        ops_tuned_num += 1 if tuned_flag else 0
        if not tuned_flag:
            timer_queue.put(("stop", os.getpid(), "tune_op_%s" % cb_struct_key))

    update_bank_async_process.stop()
    log.event("RL tune info: %s, RL tune all ops end, %d ops has been tuned, %d ops update bank.",
              SMOKE_SUCC_CONDITION, ops_tuned_num, sum(update_bank_async_process.update_bank_res))
    return True
