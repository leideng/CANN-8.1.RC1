#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from math import factorial

from schedule_search import log
from schedule_search import comm
from schedule_search.op_cfg import TIK_TO_DSL_OP_LIST
from schedule_search.controller.mcts_search.procedure.action import \
    ActionType
from schedule_search.controller.mcts_search.procedure.action import \
    SearcherAction
from schedule_search.ts_env.te_auto_schedule_env import update_progress
from schedule_search.controller.search_comm import get_split_sub_tree_depth
from schedule_search.ts_env.tensor_to_code.t2c_util import stage_need_split
from schedule_search.ts_env.tensor_to_code.t2c_util import \
    gn_training_update_nchw
from tbe.common.platform.platform_info import scope_cbuf


def get_split_todo(progress, stage_index, cache_layer=None):
    '''
    确定当前stage需要切分，获取todo
    :param progress:
    :param stage_index:
    :param cache_layer:
    :return:
    '''
    if not isinstance(cache_layer, int):
        cache_layer = progress.op_layers - 1

    stage_type = progress.op_schedule_info.stages_info[stage_index].get('type')
    # 只有一根轴，或者是gemm（mn都要切，不需要选轴了），不需要先选轴，直接切最后一根轴，
    # 否则需要先选轴
    nonzero_axes = progress.get_nonzero_axes(stage_index)
    if len(nonzero_axes) == 1 or progress.c_op in comm.MAD_OP_ID_LIST:
        # l1fuse_leaf跳过M轴(第三根轴)的切分
        if "l1fuse_leaf" in stage_type and cache_layer == 0 and progress.op_schedule_info.overflow_l1size_flag:
            chosen_axis = len(nonzero_axes) - 2
        else:
            chosen_axis = len(nonzero_axes) - 1
        chosen_axis_len = nonzero_axes[chosen_axis]
        sub_tree_depth = get_split_sub_tree_depth(chosen_axis_len)
        next_todo = SearcherAction(stage_index=stage_index,
                                   action_type=ActionType.split,
                                   cache_layer=cache_layer,
                                   sub_action_index=sub_tree_depth - 1,
                                   axis_index=chosen_axis)

    elif progress.op_schedule_info.option.get('op_type') in TIK_TO_DSL_OP_LIST.keys():
        choose_axis_and_split_map = {
            "times":TIK_TO_DSL_OP_LIST.get(progress.op_schedule_info.option.get('op_type')).get("split_times", 1),
            "chosen_axes":[]
        }
        next_todo = SearcherAction(stage_index=stage_index,
                                   action_type=ActionType.choose_axis,
                                   choose_axis_and_split_map=choose_axis_and_split_map)

    else:
        next_todo = SearcherAction(stage_index=stage_index,
                                   action_type=ActionType.choose_axis)
    return next_todo


def get_first_todo(progress):
    """
    从最后一个stage开始，走出采样的第一步
    :param progress:
    :return:
    """
    op_type = progress.op_schedule_info.option.get('op_type')
    # transpose reorder: first trs_reorder for output
    if op_type in TIK_TO_DSL_OP_LIST.keys() and \
            "trs_reorder_times" in TIK_TO_DSL_OP_LIST.get(op_type).keys():
        last_stage_index = progress.stage_num - 1
        nonzero_axes = progress.get_nonzero_axes(last_stage_index)
        permutation_num = factorial(len(nonzero_axes))
        sub_tree_depth = get_split_sub_tree_depth(permutation_num)
        progress.todo = SearcherAction(stage_index=last_stage_index,
                                       action_type=ActionType.reorder,
                                       sub_action_index=sub_tree_depth - 1,
                                       reorder_times=TIK_TO_DSL_OP_LIST.get(op_type).get("trs_reorder_times"))
        return

    # 先做cache_rw/double_buffer/inline
    start_index = 10
    end_index = 30
    # 从最后一个stage开始
    update_progress(progress, start_index, end_index)

    last_stage_index = progress.stage_num - 1
    last_stage_info = progress.op_schedule_info.stages_info[last_stage_index]
    cache_layer = progress.op_layers - 1
    broadcast_groups = last_stage_info.get('broadcast_groups')

    # reduce atomic需要采样切reduce轴还是普通轴，reduce all/nist不需要采样
    if progress.op_schedule_info.tiling_case > 1:
        log.dbg("tiling_case: %s, need choose_axis_type",
                progress.op_schedule_info.tiling_case)
        progress.todo = SearcherAction(
            stage_index=last_stage_index,
            action_type=ActionType.choose_axis_type,
        )

    # 有broadcast_groups需要采样reorder
    elif broadcast_groups:
        log.dbg("[%s] broadcast_groups: %s, need reorder.", last_stage_index,
                broadcast_groups)
        permutation_num = factorial(len(broadcast_groups))
        sub_tree_depth = get_split_sub_tree_depth(permutation_num)
        progress.todo = SearcherAction(stage_index=last_stage_index,
                                       action_type=ActionType.reorder,
                                       sub_action_index=sub_tree_depth - 1,
                                       cache_layer=cache_layer)

    # gemm先采样reorder
    elif progress.c_op in comm.MAD_OP_ID_LIST:
        # mn or nm只有两种选择
        progress.todo = SearcherAction(
            stage_index=last_stage_index,
            action_type=ActionType.reorder,
            cache_layer=cache_layer)

    # 采样切分
    else:
        progress.todo = get_split_todo(progress, last_stage_index)

    log.dbg('first todo: %s', progress.todo)


def get_next_stage_todo(progress, stage_index):
    """
    前一个stage已经采样完成，下一个stage的第一步
    注意：这些if顺序不能随便调整
    :param progress:
    :param stage_index:
    :return:
    """
    stage_info = progress.op_schedule_info.stages_info[stage_index]
    stage_types = stage_info.get('type', [])
    broadcast_groups = stage_info.get('broadcast_groups')

    next_todo = None

    # 0 l1fuse_leaf需要先采样当前stage的reorder
    if "l1fuse_leaf" in stage_types:
        # mn or nm只有两种选择
        next_todo = SearcherAction(stage_index=stage_index,
                                   action_type=ActionType.reorder,
                                   cache_layer=progress.op_layers - 1)
        return next_todo

    # 1 reduce_atomic_rfactor、reduce_atomic_write直接返回
    if {'reduce_atomic_rfactor', 'reduce_atomic_write'} & set(stage_types):
        return next_todo

    # 2 如果有broadcast_groups，需要先采样reorder
    if broadcast_groups:
        log.dbg("broadcast_groups: %s, [%s] need reorder.", broadcast_groups,
                stage_index)
        permutation_num = factorial(len(broadcast_groups))
        sub_tree_depth = get_split_sub_tree_depth(permutation_num)
        next_todo = SearcherAction(stage_index=stage_index,
                                   action_type=ActionType.reorder,
                                   sub_action_index=sub_tree_depth - 1)
        return next_todo

    # 3 需要切分，进行切分采样
    if stage_need_split(stage_index, progress.op_schedule_info):
        next_todo = get_split_todo(progress, stage_index)
        return next_todo

    # 4 需要采样at axis
    if need_search_at_axis(stage_index, progress.op_schedule_info):
        next_todo = SearcherAction(stage_index=stage_index,
                                   action_type=ActionType.at_axis)
        return next_todo

    return next_todo


def get_next_todo(progress):
    """
    :param progress:
    :return:
    """
    next_todo = None

    # 依次看前面的stage是否需要采样，如果前面没有Stage需要采样了，会返回None
    for stage_index in range(progress.todo.stage_index - 1, -1, -1):
        next_todo = get_next_stage_todo(progress, stage_index)
        if isinstance(next_todo, SearcherAction):
            break
    return next_todo


def need_search_at_axis(stage_index, op_schedule_info):
    '''

    :param stage_index:
    :param op_schedule_info:
    :return:
    '''
    at_stage_index = op_schedule_info.at_dict[stage_index]
    if not isinstance(at_stage_index, int):
        return False

    stage_info = op_schedule_info.stages_info[stage_index]
    if stage_info.get('followed_bc_info'):
        return True

    if gn_training_update_nchw(op_schedule_info):
        return False

    at_axis_search = op_schedule_info.option.get('at_axis_search')
    scope = stage_info.get('scope')
    # 卷积需要采样at轴
    if op_schedule_info.c_op in comm.CONV_OP_ID_LIST and at_axis_search:
        if scope != scope_cbuf:
            return False
        if stage_info["tag"] == "set_fmatrix":
            return True
        fanouts = op_schedule_info.real_fanout_dict[stage_index]
        if fanouts and op_schedule_info.stages_info[fanouts[0]].get(
                'scope') == "local.L0B":
            return True

    gemm_strict_mask = op_schedule_info.option.get('gemm_strict_mask')
    if op_schedule_info.c_op in comm.MAD_OP_ID_LIST and \
            gemm_strict_mask is False and scope == scope_cbuf:
        return True

    return False


def is_mad_leaf(progress):
    '''
    判断是否是mad算子的叶子节点，包括最后一个stage和L1融合的stage
    '''
    if progress.todo.stage_index == progress.stage_num - 1:
        return True

    stage_type = progress.op_schedule_info.stages_info[
        progress.todo.stage_index].get('type')
    if "l1fuse_leaf" in stage_type:
        return True

    return False
