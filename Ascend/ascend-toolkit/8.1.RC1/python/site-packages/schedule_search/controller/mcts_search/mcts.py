#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import collections
import math
import time
import copy
from typing import Union
import numpy as np

from schedule_search import log
from schedule_search.controller.history import generate_md5
from schedule_search.controller.history import query_history_dict
from schedule_search.controller.history import update_history_dict
from schedule_search.controller.history import update_hit_num
from schedule_search.ts_env.te_auto_schedule_env import get_tick
from schedule_search.controller.mcts_search.features import SEARCH_N
import schedule_search.controller.mcts_search.preprocessing as pp

# Exploration constants balancing priors vs value net output
C_PUCT_INIT = 15
# Exploration constants balancing priors vs value net output
C_PUCT_INIT_MIN = 1.0
# How much to weight the priors vs dirichlet noise when mixing, [0, 1]
DIRICHLET_NOISE_WEIGHT = 0.4
# mcts backup lamda, [0, 1]
BP_LAMDA = 1.0


class DummyRoot:
    """
    Root节点需要一个占位节点.
    """
    def __init__(self):
        self.parent = None
        self.node_name = "0"
        self.child_n = collections.defaultdict(float)
        self.child_w = collections.defaultdict(float)

    def child_n(self):  # pylint: disable=method-hidden
        """

        :return:
        """
        return self.child_n

    def child_w(self):  # pylint: disable=method-hidden
        """

        :return:
        """
        return self.child_w


class BaseNode:
    """
    A node of a search tree.
    """
    def __init__(self, progress_chain, action=None, parent=None):
        if parent is None:
            parent = DummyRoot()
        self.node_name = "0" if parent is None or action is None else parent.node_name + "-" + str(action)
        self.action = action
        self.progress_chain = progress_chain
        self.legal_actions_idx = np.where(self.progress.all_legal_actions() == 1)[0]

    def __repr__(self):
        return "<BaseNode move:%s, action:%s, path:%s>" % (self.progress.todo, self.action, self.node_name)

    @property
    def progress(self):
        """
        current node's progress
        :return:
        """
        return self.progress_chain.p_list[self.progress_chain.index]

    def maybe_add_child(self, action_value) -> object:
        """
        create a tree node
        :param action_value:
        """
        new_progress = self.progress.apply_action_value(action_value)

        # TIK可能有多个progress, 一个采完了再采另一个
        new_progress_chain = copy.deepcopy(self.progress_chain)
        new_progress_chain.replace_p(new_progress)

        child_node = BaseNode(new_progress_chain, action=action_value, parent=self)
        return child_node

    def get_moves(self) -> list:
        """
        get moves
        :return:
        """
        moves = self.node_name.split("-")
        moves.pop(0)
        moves = [int(item) for item in moves]
        return moves

    def get_value(self, process_share_infos: object) -> None:
        """
        get tick for dfs
        :param process_share_infos:
        :return:
        """
        if not self.is_done():
            raise AssertionError("node[%s] is not done" % self.node_name)

        moves = self.get_moves()
        # State置为None，因为获取Tick和Value的话，是不需要States的
        if self.progress_chain.num > 1:
            action_tensors = []
            op_schedule_infos = []
            for progress in self.progress_chain.p_list:
                action_tensors.append(progress.action_tensor)
                op_schedule_infos.append(progress.op_schedule_info)
        else:
            if self.progress.op_schedule_info.tik_op:
                action_tensors = [self.progress.action_tensor]
                op_schedule_infos = [self.progress.op_schedule_info]
            else:
                action_tensors = self.progress.action_tensor
                op_schedule_infos = self.progress.op_schedule_info
        log.dbg("RL search info: action_tensors used to try_get_tick: %s, op_schedule_infos: %s, moves: %s.",
                action_tensors, op_schedule_infos, moves)

        # get tick and corresponding value to backup later
        tick = try_get_tick(action_tensors, moves, op_schedule_infos, process_share_infos)
        log.dbg("RL search info: leaf_node is %s, tick got from try_get_tick is %ss.", self, tick)

        return tick

    def is_done(self) -> bool:
        """
        check whether search is done
        """
        return self.progress.is_search_over()


class MCTSNode(BaseNode):  # pylint: disable=R0902,R0904
    """
    A node of a MCTS search tree.
    """
    def __init__(self, progress_chain, action=None, parent=None):
        super().__init__(progress_chain, action, parent)
        if parent is None:
            parent = DummyRoot()
        self.parent = parent
        self.is_expanded = False
        self.losses_applied = 0  # number of virtual losses on this node
        self.illegal_actions = 1 - self.progress.all_legal_actions()
        self.child_n = np.zeros([SEARCH_N], dtype=np.float32)
        self.child_w = np.zeros([SEARCH_N], dtype=np.float32)
        self.child_prior = np.zeros([SEARCH_N], dtype=np.float32)
        self.children = {}  # map of flattened moves to resulting MCTSNode
        # 记录访问过的叶子节点
        self.visited_leaves = np.array([0] * SEARCH_N, dtype=int)
        self.value = None

    def __repr__(self):
        return "<MCTSNode move:%s, n_value:%s, action:%s, path:%s>" % (
            self.progress.todo, self.n_value, self.action, self.node_name)

    @property
    def child_action_score(self):
        """
        current node's child_action_score
        :return:
        """
        child_action_score = self.child_q + self.child_u
        for index in range(SEARCH_N):
            if self.illegal_actions[index] == 1:
                child_action_score[index] = float("-inf")

        return child_action_score

    @property
    def child_q(self):
        """
        current node's child_q (exploitation)
        :return:
        """
        return self.child_w / (1 + self.child_n)

    @property
    def child_u(self):
        """
        current node's child_w (exploration)
        :return:
        """
        c_puct = C_PUCT_INIT
        # Valid时，c_puct直接使用最后Decay完的结果
        if self.progress.valid:
            c_puct = C_PUCT_INIT_MIN
        return c_puct * math.sqrt(max(1, self.n_value - 1)) * self.child_prior / (1 + self.child_n)

    @property
    def q_value(self):
        """
        current node's q_value (exploitation)
        :return:
        """
        return self.w_value / (1 + self.n_value)

    @property
    def n_value(self):
        """
        current node's n_value
        :return:
        """
        return self.parent.child_n[self.action]

    @n_value.setter
    def n_value(self, value):
        """
        set current node's n_value
        """
        self.parent.child_n[self.action] = value

    @property
    def w_value(self):
        """
        current node's w_value
        :return:
        """
        return self.parent.child_w[self.action]

    @w_value.setter
    def w_value(self, value):
        """
        set current node's w_value (from backup value)
        """
        self.parent.child_w[self.action] = value

    def select_leaf(self):
        """
        mcts selection process
        :return:
        """
        current = self
        while True:
            if not current.is_expanded:
                break
            # 如果当前节点已经是最终节点,则不需要进行子节点展开,返回当前节点
            if current.is_done():
                return current

            best_action = np.argmax(current.child_action_score)
            new_leaf = current.maybe_add_child(best_action)
            # 如果子节点全是叶子节点，则优先选择没选过的
            if new_leaf.is_done() and current.child_n[best_action] > 0:
                for action, illegal in enumerate(current.illegal_actions):
                    if illegal == 0 and current.child_n[action] == 0:
                        new_leaf = current.maybe_add_child(action)
                        break
            log.dbg("RL search info: best_action: %s, old_leaf: %s, new_leaf: %s, child_action_score: %s.",
                    best_action, current, new_leaf, current.child_action_score.tolist())
            current = new_leaf

        log.dbg("RL search info: origin_leaf is %s, select_leaf is %s.", self, current)
        return current

    def maybe_add_child(self, action_value):
        """
        如果子节点已经存在，则返回，否则创建一个返回.
        """
        if action_value in self.children:
            return self.children[action_value]

        new_progress = self.progress.apply_action_value(action_value)

        # TIK可能有多个progress, 一个采完了再采另一个
        new_progress_chain = copy.deepcopy(self.progress_chain)
        new_progress_chain.replace_p(new_progress)

        self.children[action_value] = MCTSNode(new_progress_chain, action=action_value, parent=self)
        return self.children[action_value]

    def add_virtual_loss(self, up_to):
        """
        添加虚拟Loss，保证在一次并行Readouts中，可以选到不同的点去计算
        """
        self.losses_applied += 1
        loss = -1
        self.w_value += loss
        if self.parent is None or self is up_to:
            return
        self.parent.add_virtual_loss(up_to)

    def revert_virtual_loss(self, up_to):
        """
        revert virtual loss
        :param up_to:
        :return:
        """
        self.losses_applied -= 1
        revert = 1
        self.w_value += revert
        if self.parent is None or self is up_to:
            return
        self.parent.revert_virtual_loss(up_to)

    def incorporate_results(self, probs, value, up_to):
        """
        backup value for non-leaf nodes
        :param probs:
        :param value:
        :param watch_info_backup:
        :param up_to:
        :return:
        """
        if probs.shape != (SEARCH_N, ):
            raise AssertionError("probs.shape != (SEARCH_N, )")
        if self.is_done():
            raise AssertionError("self.is_done()")
        if self.is_expanded:
            return
        self.is_expanded = True

        self.child_w = np.ones([SEARCH_N], dtype=np.float32) * value
        log.dbg("RL search info: node is %s, random_value to backup is %s.", self, value)
        self.backup_value(value, up_to=up_to)

    def backup_value(self, value, up_to):
        """
        mcts backpropogation process
        :param value:
        :param up_to:
        """
        self.n_value += 1
        if self.is_done():
            self.w_value = value * (self.n_value + 1)
        else:
            self.w_value += value

        if self.parent is None or self is up_to:
            return

        # 使用自己Q值
        value = (1 - BP_LAMDA) * self.q_value + BP_LAMDA * value

        self.parent.backup_value(value, up_to)

    def get_states(self, states):
        """
        get states
        :param states:
        :return:
        """
        if self.parent and not isinstance(self.parent, DummyRoot):
            states.insert(0, self.parent.progress.state)
            return self.parent.get_states(states)
        return states

    def get_pis(self, pis):
        """
        get pis
        :param pis:
        :return:
        """
        if self.parent and not isinstance(self.parent, DummyRoot):
            pis.insert(0, self.parent.children_as_pi())
            return self.parent.get_pis(pis)
        return pis

    def get_action_tensors(self, action_tensors):
        """
        get action tensors
        :param action_tensors:
        :return:
        """
        if self.parent and not isinstance(self.parent, DummyRoot):
            action_tensors.insert(0, self.parent.progress.action_tensor)
            return self.parent.get_action_tensors(action_tensors)
        return action_tensors

    def get_moves(self, moves):
        """
        get moves
        :param moves:
        :return:
        """
        if self.action is not None:
            moves.insert(0, self.action)
        if self.parent and not isinstance(self.parent, DummyRoot):
            return self.parent.get_moves(moves)
        return moves

    def get_value(self, process_share_infos: object) -> int:
        """
        get tick and transfer to value for backup
        :param process_share_infos:
        :return:
        """
        if not self.is_done():
            raise AssertionError("node[%s] is not done" % self.node_name)
        if self.value is not None:
            log.dbg("Node:%s value:%s just return!", self, self.value)
            return self.value
        moves = []
        moves = self.get_moves(moves)
        # State置为None，因为获取Tick和Value的话，是不需要States的
        if self.progress_chain.num > 1:
            action_tensors = []
            op_schedule_infos = []
            for progress in self.progress_chain.p_list:
                action_tensors.append(progress.action_tensor)
                op_schedule_infos.append(progress.op_schedule_info)
        else:
            if self.progress.op_schedule_info.tik_op:
                action_tensors = [self.progress.action_tensor]
                op_schedule_infos = [self.progress.op_schedule_info]
            else:
                action_tensors = self.progress.action_tensor
                op_schedule_infos = self.progress.op_schedule_info
        log.dbg("RL search info: action_tensors used to try_get_tick are %s, op_schedule_infos: %s, moves: %s.",
                action_tensors, op_schedule_infos, moves)

        # get tick and corresponding value to backup later
        tick = try_get_tick(action_tensors, moves, op_schedule_infos, process_share_infos)

        if isinstance(op_schedule_infos, list) and len(op_schedule_infos) >= 1:
            single_op_schedule_info = op_schedule_infos[0]
        else:
            single_op_schedule_info = op_schedule_infos

        value = pp.value_algo_reciprocal(tick, single_op_schedule_info.base_tick)
        self.value = value
        log.dbg("RL search info: leaf_node is %s, tick got from try_get_tick is %s, value to backup is %s.",
                self, tick, value)

        # 记录一下tick，后面不用再重复获取
        self.progress.tick = tick

        return self.value

    def inject_noise(self):  # pylint: disable=no-member
        """
        inject noise as child_prior for the new root
        :return:
        """
        legal_indices = []
        for index, value in enumerate(self.illegal_actions):
            if value == 0:
                legal_indices.append(index)

        epsilon = 1e-5
        legal_moves = (1 - self.illegal_actions) + epsilon
        np.random.seed(int(time.time() * (10**6)) % (2**32))
        noise = np.random.random([SEARCH_N]) * legal_moves
        noise = noise / noise.sum()
        self.child_prior = (self.child_prior * (1 - DIRICHLET_NOISE_WEIGHT) + noise * DIRICHLET_NOISE_WEIGHT)
        log.dbg("RL search info: current root is %s, inject noise is %s, child_prior is %s.",
                self, noise.tolist(), self.child_prior.tolist())

    def children_as_pi(self, squash=False):
        """
        pdf of child_n
        :param squash:
        :return:
        """
        probs = self.child_n
        if squash:
            probs = probs**.98
        sum_probs = np.sum(probs)
        if sum_probs == 0:
            return probs
        probs = probs / sum_probs
        return probs

    def all_visited(self, child_index):
        """
        check whether all legal child nodes are visited for the current node
        :param child_index:
        :return:
        """
        # 所有的合法子节点都已经递归访问完了
        # 这只是一个粗略判断，最多递归三层，如果三层之后还有子节点，就直接返回False了
        layer_nodes = [self.children[child_index]]
        while layer_nodes:
            node = layer_nodes.pop(0)
            if node.is_done():
                continue
            # 如果node的所有合法子节点都展开了
            for child, illegal in enumerate(node.illegal_actions):
                if not illegal:
                    if child not in node.children:
                        return False
                    if not node.children[child].is_done():
                        layer_nodes.append(node.children[child])
        return True

    def best_child(self):
        """
        choose best child node according to child_n
        :return:
        """
        # 把已经完全递归完毕的节点排除掉，它们已经没有任何潜力了
        for index, c_n in sorted(enumerate(self.child_n),
                                 key=lambda x: x[1],
                                 reverse=True):
            # 遇到从未访问过的节点了，说明其他节点全展开完了，那就没办法了
            if c_n < 1:
                return np.argmax(self.child_n)
            if not self.all_visited(index):
                return index
        # 上面没有一个符合的，那仍旧走到这里
        return np.argmax(self.child_n)


def try_get_tick(action_tensors: list,
                 moves: int,
                 op_schedule_infos: Union[list, object],
                 process_share_infos: object) -> int:
    """
    try to get tick, either from action_history_dict or call get_tick
    :param action_tensors: action tensors
    :param op_schedule_infos: op infos
    :param moves: picked action
    :param process_share_infos
    :return: tick
    """
    if isinstance(op_schedule_infos, list) and len(op_schedule_infos) >= 1:
        single_op_schedule_info = op_schedule_infos[0]
    else:
        single_op_schedule_info = op_schedule_infos
    op_md5 = single_op_schedule_info.op_md5

    action_md5 = generate_md5(single_op_schedule_info.option, action_tensors)
    log.dbg("op_md5: %s, action_md5: %s try to query and update action_history_dict.", op_md5, action_md5)

    hit_res, tick, _ = query_history_dict(op_md5, action_md5, process_share_infos.action_history_dict)
    if not hit_res:
        _, new_tick, _, new_hit_res = get_tick(action_tensors, op_schedule_infos,
                                               process_share_infos=process_share_infos, moves=moves)
        tick, _ = update_history_dict(op_md5, action_md5, new_tick, new_hit_res,
                                      process_share_infos.action_history_dict)

    # update hit_num
    update_hit_num(op_md5, action_md5, process_share_infos.action_history_dict)

    return tick
