#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from functools import reduce as functools_reduce

from schedule_search import util
from schedule_search.controller.mcts_search.features import SEARCH_N
from schedule_search.ts_env import env_util


def reduce_nist_proc(progress, action_mask):  # pylint: disable=R0912,R0914
    """

    :param progress:
    :param action_mask:
    :return:
    """
    stage_index = progress.todo.stage_index
    stages = progress.op_schedule_info.schedule_obj.stages
    stages_info = progress.op_schedule_info.stages_info
    stage_dtype = stages[stage_index].op.output(0).dtype
    block_size = env_util.get_block_num(stage_dtype)
    stage_info = stages_info[stage_index]
    shape_before_reduce = stage_info.get('shape_before_reduce', [])
    reduce_axis_indexs = stage_info.get('reduce_axis_indexs', [])
    is_keepdims = stage_info.get('is_keepdims', False)
    last_non_raxis_s, last_non_raxis_e = \
        env_util.find_last_none_reduce_axis(shape_before_reduce,
                                            reduce_axis_indexs)
    # a1轴比较小，就不切a1了
    last_none_reduce_size = 1
    for axis_index in range(last_non_raxis_s, last_non_raxis_e + 1):
        if shape_before_reduce:
            last_none_reduce_size *= shape_before_reduce[axis_index]
    reduce_size = 1
    for axis_index, axis_len in enumerate(shape_before_reduce):
        if axis_index in reduce_axis_indexs:
            reduce_size *= axis_len
    if last_none_reduce_size < reduce_size:
        action_mask[1] = 0
        return action_mask

    split_axis_flag = False
    start_index = env_util.find_none_reduce_axis_index(
        last_non_raxis_s, shape_before_reduce, reduce_axis_indexs,
        is_keepdims)
    end_index = env_util.find_none_reduce_axis_index(
        last_non_raxis_e, shape_before_reduce, reduce_axis_indexs,
        is_keepdims)
    nonzero_axes = progress.get_nonzero_axes(stage_index, "axis")
    for axis_index in range(start_index, end_index + 1):
        curr_axis_len = nonzero_axes[axis_index]
        for split_factor in range(1, curr_axis_len + 1):
            # 之前的整块
            tail_len = 1
            if end_index > axis_index:
                tail_len = functools_reduce(
                    lambda x, y: x * y,
                    nonzero_axes[axis_index + 1:end_index + 1])
            non_tail_size = split_factor * tail_len
            # 最后的尾块
            tail_size = util.get_last_slice_len(
                curr_axis_len, split_factor,
                nonzero_axes[axis_index + 1:end_index + 1])
            if non_tail_size % block_size == 0 \
                    and tail_size % block_size == 0:
                split_axis_flag = True
                break
    if not split_axis_flag:
        action_mask[1] = 0
    return action_mask


def proc(progress, action_mask):
    """
    规则内容：选择切reduce轴还是普通轴
    """
    for idx in range(SEARCH_N):
        action_mask[idx] = 0

    # 只用于reduce atomic
    if progress.op_schedule_info.tiling_case > 0:
        for idx in range(2):
            action_mask[idx] = 1

    # reduce nist 切a1无法保证32b对齐的不切普通轴
    if progress.op_schedule_info.tiling_case == 2:
        action_mask = reduce_nist_proc(progress, action_mask)

    return action_mask
