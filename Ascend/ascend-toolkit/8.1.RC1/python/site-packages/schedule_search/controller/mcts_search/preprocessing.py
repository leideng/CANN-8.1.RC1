#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import gzip
import math
import os
import pickle
import sys
from absl import flags

from schedule_search import log
from schedule_search.config import WORKSPACE
from schedule_search.ts_env.te_auto_schedule_env import get_tick

flags.DEFINE_string('get_tick_by', 'evb_run', 'value_file/evb_run')
flags.DEFINE_string('value_dir',
                    os.path.join(WORKSPACE, './replay_dir/value_dir'), '.')

FLAGS = flags.FLAGS

MIN_VALUE = -1
# 特殊场景下，默认value都给1.1，保证可以update
DEFAULT_VALUE = 1.1


class InferData:  # pylint: disable=R0913,R0902
    """
    InferData
    """
    def __init__(
            self,
            op_schedule_infos,
            states,
            final_state,
            pi_value,
            action_tensors,
            moves,
            final_move=None,
            value=None,
            tick=None,
            pk_name=None):

        self.op_schedule_infos = op_schedule_infos
        self.op_name = self.op_schedule_infos[0].op_name
        self.shape = self.op_schedule_infos[0].shape_list_str
        # 指输入的Dtype，输出是啥完全看Compute咋写的
        self.dtypes = '@'.join([
            input_info.dtype
            for input_info in self.op_schedule_infos[0].input_info_list
        ])
        self.states = states  # mcts states
        self.moves = moves
        self.pi_value = pi_value  # 概率pi
        self.action_tensors = action_tensors
        self.value = value  # value
        self.final_state = final_state  # 最终结束的state
        self.final_move = final_move
        self.tick = tick  # 算子跑出来的tick值
        self.pk_name = pk_name

    def __str__(self):
        print_str = "states: %s, pi_value: %s, value: %s, tick: %s, " \
                    "final_state: %s." % \
                    (self.states, self.pi_value, self.value, self.tick,
                     self.final_state)
        return print_str

    def extract_infer_data(self):
        """
        extract_infer_data
        """
        if isinstance(self.value, list):
            for pwc in zip(self.states, self.pi_value, self.value):
                yield pwc
        else:
            for state, pi_v in zip(self.states, self.pi_value):
                yield (state, pi_v, self.value)


def value_algo_reciprocal(tick: int, base_tick: int) -> int:
    """
    transform tick to value
    :param tick: current tick
    :param base_tick: base tick
    :return: value
    """
    # sys.maxsize直接返回, 非int的特殊值直接返回
    if tick in [0, sys.maxsize, None] or not isinstance(tick, int):
        return MIN_VALUE

    # 用统一的量纲，不因op、Shape有区别
    return math.tanh((base_tick - tick) / tick)


def get_tick_proc(op_schedule_infos, action_tensors, infer_data):
    """

    :param op_schedule_infos:
    :param action_tensors:
    :param infer_data:
    :return:
    """
    if op_schedule_infos[0].tik_op:
        bool_ret, tick, _, _ = get_tick(action_tensors,
                                        op_schedule_infos,
                                        moves=infer_data.moves)
    else:
        bool_ret, tick, _, _ = get_tick(action_tensors[0],
                                        op_schedule_infos[0],
                                        moves=infer_data.moves)

    # 运行算子失败，则置为最大整数值
    if bool_ret is False or not tick:
        tick = sys.maxsize
    return tick


def get_tick_afresh(infer_data, valid): # pylint: disable=R0914,R0912
    """

    :param infer_data:
    :param valid:
    :return:
    """
    op_schedule_infos = infer_data.op_schedule_infos
    action_tensors = infer_data.action_tensors

    # 暂时先把这里改成从ValueFile中读取，加快速度，
    # 这样真替换成实时跑EVB也不用太大改动
    if FLAGS.get_tick_by == 'value_file':
        op_name = op_schedule_infos[0].op_name
        stages = op_schedule_infos[-1].schedule_obj.stages
        output_dtype = stages[-1].op.output(0).dtype
        shape = stages[-1].op.output(0).shape
        shape_str = (str(axis.value) for axis in shape)
        pickle_file_name = "%s@%s@%s.pkl" % (op_name, output_dtype, '_'.join(shape_str))
        shape_value_file = os.path.join(FLAGS.value_dir, pickle_file_name)
        if not os.path.exists(shape_value_file):
            log.warn("value_file: %s does not exist.", shape_value_file)
            tick = sys.maxsize
        else:
            with open(shape_value_file, 'rb') as file_handle:
                moves_tick_dict = pickle.load(file_handle)
            moves = tuple(infer_data.moves)
            tick = moves_tick_dict.get(moves, sys.maxsize)
            # 如果是很难遍历的Shape，那要重新去EVB拿一下tick
            if tick == sys.maxsize and sum(shape) > 10000:
                tick = get_tick_proc(op_schedule_infos, action_tensors,
                                     infer_data)
    else:
        # 获取Tick，只有Valid的时候才需要OOM Clean，训练时不需要
        log.dbg('get reward hard. valid: %s', valid)
        tick = get_tick_proc(op_schedule_infos, action_tensors, infer_data)
    # 更新到tick里面
    infer_data.tick = tick
    return infer_data


def update_infer_data_tick(infer_data, valid=False):
    """

    :param infer_data:
    :param valid:
    :return:
    """
    # value已经存在，则无需重复获取
    if infer_data.value:
        return infer_data
    if infer_data.pk_name:
        tick = infer_data.pk_name.strip(".pk").split("_")[-1]
        if tick.startswith("tick"):
            tick = int(tick.lstrip("tick"))
            infer_data.tick = tick

    try:
        # tick不存在场景下，需要重新获取
        if infer_data.tick is None:
            infer_data = get_tick_afresh(infer_data, valid)
        return infer_data
    except Exception as exception:  # pylint: disable=broad-except
        log.warn("RL exception occur: Failed to update infer_data_tick, raise exception: %s", repr(exception))
        infer_data.tick = None
        return infer_data


def set_infer_data_from_raw(raw_data_list: list, infer_data: object) -> None:
    """
    append values to infer_data from raw data
    :param raw_data_list:
    :param infer_data:
    :return:
    """
    for raw_data in raw_data_list:
        _, state, pi_value, _, _, move, _ = raw_data
        infer_data.states.append(state)
        infer_data.moves.append(move)
        infer_data.pi_value.append(pi_value)


def do_read_raw_data(raw_dir, data_files):  # pylint: disable=R0914
    """

    :param raw_dir:
    :param data_files:
    :return:
    """
    # 当数据非常多时，需要知道进度信息
    infer_data_list = []
    for data_file in data_files:
        try:
            with gzip.open(os.path.join(raw_dir, data_file), 'rb') as file_handle:
                raw_data_list = pickle.load(file_handle)
        except Exception as exception:  # pylint: disable=broad-except
            log.warn("RL exception occur: Failed to read raw data, raise exception: %s", repr(exception))
            return []
        finally:
            pass

        final_move = raw_data_list[-1]
        op_schedule_infos, state, _, value, action_tensors, move, tick = final_move
        infer_data = InferData(op_schedule_infos, [],
                                state, [],
                                action_tensors, [],
                                move,
                                value=value,
                                tick=tick,
                                pk_name=data_file)
        # 不需要重复加最后一个state
        set_infer_data_from_raw(raw_data_list, infer_data)
        infer_data_list.append(infer_data)
    return infer_data_list


def read_raw_data(infer_dir):
    """

    :param infer_dir:
    :return:
    """
    infer_data_list = []
    pk_name_list = []

    raw_dir = os.path.join(infer_dir, "raw")
    data_file_list = os.listdir(raw_dir)
    for data_file in data_file_list:
        if not data_file.endswith(".pk"):
            continue
        infer_data = do_read_raw_data(raw_dir, [data_file])[0]
        pk_name_list.append(data_file)
        infer_data_list.append(infer_data)
    return infer_data_list, pk_name_list


def get_val_tick_value(infer_dir):
    """

    :param infer_dir:
    :return:
    """
    # 读取raw数据
    log.dbg("-----------------------Read raw data.-----------------------")
    infer_data_list, _ = read_raw_data(infer_dir)

    values = []
    ticks = []
    for infer_data in infer_data_list:
        values.append(infer_data.value)
        ticks.append(infer_data.tick)

    # 对最优的这个做一次Greedy的get reward的操作
    if infer_data_list:
        action_tensors = infer_data_list[0].action_tensors
        op_schedule_infos = infer_data_list[0].op_schedule_infos

        if len(op_schedule_infos) == 1:
            get_tick(action_tensors[0],
                     op_schedule_infos[0],
                     moves=infer_data_list[0].moves)
        else:
            get_tick(action_tensors,
                     op_schedule_infos)
    return ticks, values
