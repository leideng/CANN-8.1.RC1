#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import copy
import random

import numpy as np
from schedule_search import log
from schedule_search.controller.mcts_search import mcts
from schedule_search.controller.mcts_search import schedule
from schedule_search.controller.mcts_search.features import SEARCH_N
from schedule_search.controller.search_comm import get_move_prob_value

# Percentage of actions that should use softpick
SOFT_PICK_MOVE_CUT_OFF = 1.0
# MCTS readouts/roll outs
NUM_READOUTS = 30
# MCTS readouts/roll outs in valid
VAL_NUM_READOUTS = 20
# Number of searches to execute once
PARALLEL_READOUTS = 4


class MCTSSearcher:  # pylint: disable=R0902
    """
    MCTSSearcher
    """

    def __init__(self, network: object = None, num_readouts: int = 0, valid: bool = False) -> None:
        self.network = network
        self.num_readouts = num_readouts or NUM_READOUTS
        self.temp_threshold = SOFT_PICK_MOVE_CUT_OFF
        self.root = None
        super().__init__()
        self.valid = valid
        self.leaves = []  # 所有搜索过程中见到过的叶子结点
        # State的数据集合
        self.states = []
        # Action的数据集合
        self.moves = []
        # action_tensor的数据合集
        self.action_tensors = []
        # Pi的数据集合
        self.searches_pi = []
        # 本次搜索到的Schedule的Value
        self.result = 0
        # 本次搜索到的Schedule的Tick
        self.tick = 0
        self.child_ns = []
        self.child_qs = []
        self.nn_values = []
        self.self_ns = []
        self.self_qs = []

    def get_progress(self):
        """
        get root's progress
        :return:
        """
        return self.root.progress if self.root else None

    def get_root(self):
        """
        get root
        :return:
        """
        return self.root

    def initialize_search(self, op_schedule_infos):
        """
        search initialization
        :param op_schedule_infos:
        """
        progress_chain = schedule.ProgressChain(op_schedule_infos, valid=self.valid)
        self.root = mcts.MCTSNode(progress_chain)

    def apply_action(self, move: int) -> bool:
        """
        apply the new root
        :param move:
        :return:
        """
        children_pi = self.root.children_as_pi()
        # 需要这些信息作为pi的计算

        self.searches_pi.append(children_pi)
        self.states.append(self.root.progress.state)
        self.moves.append(move)
        self.action_tensors.append(self.root.progress.action_tensor)

        # 加上树的信息
        self.child_ns.append(copy.deepcopy(self.root.child_n))
        self.child_qs.append(copy.deepcopy(self.root.child_q))
        self.nn_values.append(self.root.value)
        self.self_ns.append(self.root.n_value)
        self.self_qs.append(self.root.q_value)

        log.dbg("RL search info: before apply_action, root is %s, move is %s.", self.root, move)
        self.root = self.root.maybe_add_child(move)
        if self.root.is_done():
            self.searches_pi.append(np.array([0] * SEARCH_N, np.float32))
            self.states.append(self.root.progress.state)
            self.moves.append(0)
            self.action_tensors.append(self.root.progress.action_tensor)
            self.result = self.root.value
            self.tick = self.root.progress.tick
            self.nn_values.append(0)
            self.child_ns.append([])
            self.child_qs.append([])
            self.self_ns.append(0)
            self.self_qs.append(0)
        log.dbg("RL search info: after apply_action, new root is %s.", self.root)

        del self.root.parent.children
        return True  # GTP requires positive result.

    def pick_action(self):
        """
        pick the new root
        :return:
        """
        # 前期根据子节点访问次数的分布随机选一个
        # 当进度超过阈值则取N值最大的子节点
        if random.random() > self.temp_threshold:
            fcoord = self.root.best_child()
            log.dbg(
                "pick_action root.child_n:%s root.child_action_score:%s "
                "argmax fcoord:%s", self.root.child_n,
                self.root.child_action_score, fcoord)
        else:
            cdf = (self.root.children_as_pi(squash=True)).cumsum()
            cdf /= cdf[-1]  # Prevents passing via softpick.
            selection = random.random()
            fcoord = cdf.searchsorted(selection)
            if self.root.child_n[fcoord] == 0:
                raise AssertionError("self.root.child_n[fcoord] == 0")
            log.dbg(
                "pick_action root.child_n:%s root.children_as_pi:%s "
                "cdf:%s selection:%s fcoord:%s", self.root.child_n,
                self.root.children_as_pi(squash=True), cdf, selection, fcoord)
        return fcoord

    def mcts_simulation(self, process_share_infos: object, parallel_readouts: int = None) -> None:
        """
        tree search simulation process
        :param process_share_infos
        :param parallel_readouts:
        :return:
        """
        if parallel_readouts is None:
            parallel_readouts = PARALLEL_READOUTS
        nodes = []
        leaves = []
        failsafe = 0

        while len(nodes) < parallel_readouts and failsafe < parallel_readouts * 2:
            failsafe += 1
            node = self.root.select_leaf()
            log.dbg("RL search info: failsafe:%s, select_leaf:%s.", failsafe, node)
            if node.is_done():
                # 基于tick获取value，多进程
                # 进程池消耗的时间比获取tick的耗时还长，因此暂时去掉多进程
                value = node.get_value(process_share_infos)
                self.leaves.append([node, value])
                log.dbg("RL search info: leaf reached is %s, backup value %s up to the current root %s.",
                        node, value, self.root)
                node.backup_value(value, up_to=self.root)
                node.add_virtual_loss(up_to=self.root)
                leaves.append(node)
                continue
            node.add_virtual_loss(up_to=self.root)
            nodes.append(node)

        for node in nodes:
            move_prob, value = get_move_prob_value()
            node.revert_virtual_loss(up_to=self.root)
            node.value = value
            node.incorporate_results(move_prob, value, up_to=self.root)

        for leaf in leaves:
            leaf.revert_virtual_loss(up_to=self.root)

        log.dbg("RL search info: non-leaf nodes: %s, leaves reached: %s", nodes, leaves)

    def tree_search(self, process_share_infos: object, readouts: int, valid: bool = False) -> None:
        """
        mcts tree search
        :param process_share_infos:
        :param readouts:
        :return:
        """
        if not valid:
            self.root.inject_noise()

        # move forward directly if current root has only one child, otherwise do the readouts
        if len(self.root.legal_actions_idx) == 1:
            move = self.root.legal_actions_idx[0]
            log.dbg("RL search info: the current root %s has only one child %s, move forward directly.",
                self.root, self.root.legal_actions_idx)
            # ensure the next node is created and expanded
            next_node = self.root.maybe_add_child(move)
            if next_node.is_done():
                value = next_node.get_value(process_share_infos)
                self.leaves.append([next_node, value])
                next_node.backup_value(value, up_to=self.root)
            else:
                move_prob, value = get_move_prob_value()
                next_node.incorporate_results(move_prob, value, up_to=self.root)
            # apply new root
            self.apply_action(move)
            return

        current_readouts = self.root.n_value
        # we want to do "X additional readouts", rather than "up to X readouts".
        while self.root.n_value < current_readouts + readouts:
            self.mcts_simulation(process_share_infos)

        log.dbg("RL search info: current root progress is %s.", self.root.progress)
        # pick new root
        move = self.pick_action()
        # apply new root
        self.apply_action(move)
        return

    def is_done(self):
        """
        check whether the node is a leaf node
        :return:
        """
        return self.result != 0 or self.root.is_done()

    def extract_data(self):
        """
        extract_data
        """
        for stat, pii, vii, att, mvv, tii in zip(
                self.states,
                self.searches_pi,
                [self.result] * len(self.searches_pi),
                self.action_tensors,
                self.moves,
                [self.tick] * len(self.searches_pi)
        ):
            yield (stat, pii, vii, att, mvv, tii)

    def get_num_readouts(self):
        """
        get num_readouts
        :return:
        """
        return self.num_readouts

    def set_num_readouts(self, readouts):
        """
        set num_readouts
        :param readouts:
        """
        self.num_readouts = readouts


class DFSSearcher:
    """
    DFSSearcher
    """

    def __init__(self) -> None:
        self.root = None

    def initialize_search(self, op_schedule_infos: list):
        """
        search initialization
        :param op_schedule_infos:
        """
        progress_chain = schedule.ProgressChain(op_schedule_infos)
        self.root = mcts.BaseNode(progress_chain)

    def dfs_tree_search(self, process_share_infos: object) -> None:
        """
        dfs tree search
        :param process_share_infos:
        :return:
        """
        stack = [self.root]
        while stack:
            current = stack.pop()

            if current.is_done():
                tick = current.get_value(process_share_infos)
                log.dbg("RL search info: dfs_tree_search reach leaf_node %s with tick %d", current, tick)
                continue

            dfs_idx = current.legal_actions_idx.tolist()
            dfs_idx.reverse()
            for action in dfs_idx:
                stack.append(current.maybe_add_child(action))

            del current
        return
