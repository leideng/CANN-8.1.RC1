#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search import comm
from schedule_search.ts_env.tensor_cfg import AXIS_CNT
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.controller.mcts_search.features import SEARCH_N
import schedule_search.ts_env.tensor_to_code.t2c_util as t2c_util


# 限制最大值，免得mnk有一个采到很大的或很小的
FACTOR_RANGE = [4, 32]


def condition_check(progress):
    '''
    :param progress:
    :return:
    '''
    # 加option控制一下
    if progress.op_schedule_info.option.get('gemm_strict_mask') is not True:
        return False

    # 非gemm不处理
    if progress.c_op not in comm.MAD_OP_ID_LIST:
        return False

    return True


def get_max_index(action_mask):
    '''
    :param action_mask:
    :return:
    '''
    max_index = len(action_mask) - 1
    if sum(action_mask) != 0:
        max_index = len(action_mask) - 1 - list(reversed(action_mask)).index(1)
    return max_index


def need_mask(progress, factor, idx):
    '''
    :param progress:
    :param axis_len:
    :param factor:
    :param idx:
    :return:
    '''
    # 考虑sub_action
    # factor没有采样完成，看其下的所有可能factor是否有满足条件的
    sub_factor = pow(SEARCH_N, progress.todo.sub_action_index)
    if progress.todo.sub_action_index > 0:
        min_new_factor = factor + sub_factor * idx
        max_new_factor = min_new_factor + sub_factor
    # factor全部采样完成，看自己是否满足条件
    else:
        min_new_factor = factor + sub_factor * idx
        max_new_factor = factor + sub_factor * idx

    mask_flag = False
    # tik和Conv算子调整采样空间约束
    if progress.op_schedule_info.tik_op:
        FACTOR_RANGE[0] = 1

    # 卷积限制不切W
    if progress.c_op in comm.CONV_OP_ID_LIST:
        stage_index = progress.todo.stage_index
        stage_info = progress.op_schedule_info.stages_info[stage_index]
        conv_param_dict = progress.op_schedule_info.conv_param_dict
        last_set_fmatrix = max(conv_param_dict.keys())
        w_o = conv_param_dict[last_set_fmatrix]["wo"].value
        if stage_info.get('tag') != "conv_mad":
            _, m_axis_index = t2c_util.get_nm_axis_index(
                progress.op_schedule_info)
            # 只涉及M轴
            if progress.todo.axis_index == m_axis_index and \
                    max_new_factor < w_o:
                return True
        return mask_flag

    if min_new_factor > FACTOR_RANGE[1] or \
            max_new_factor < FACTOR_RANGE[0]:
        mask_flag = True

    return mask_flag


def proc(progress, action_mask):
    '''
    规则内容：
    gemm空间比较大，比较难搜，限制gemm的切分因子不可太大或太小
    '''
    if not condition_check(progress):
        return action_mask

    # 记录一下mask之前的最大值
    max_index = get_max_index(action_mask)

    factor_index = ActionTensorCfg.split_factor_s + \
                   progress.todo.cache_layer * AXIS_CNT + \
                   progress.todo.axis_index
    factor = progress.action_tensor[progress.todo.stage_index][factor_index]

    for idx in range(SEARCH_N):
        if need_mask(progress, factor, idx):
            action_mask[idx] = 0

    # 不能全部都mask掉
    if sum(action_mask) == 0:
        action_mask[max(max_index, FACTOR_RANGE[0])] = 1

    log.dbg('r12_gemm_factor_range_rule: %s', action_mask)
    return action_mask
