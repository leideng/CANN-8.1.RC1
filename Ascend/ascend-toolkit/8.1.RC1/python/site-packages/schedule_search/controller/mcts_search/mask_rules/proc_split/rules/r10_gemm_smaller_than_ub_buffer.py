#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from schedule_search import log
from schedule_search import comm
from schedule_search.ts_env.tensor_cfg import AXIS_CNT
from schedule_search.ts_env.tensor_cfg import FeatureTensorCfg
from schedule_search.ts_env.tensor_cfg import ActionTensorCfg
from schedule_search.controller.mcts_search.features import SEARCH_N
from schedule_search.controller.mcts_search.features import UB_BUFFER_SIZE
from schedule_search.ts_env.tensor_to_code.t2c_util import C_SIZE
from schedule_search.ts_env.tensor_to_code.t2c_util import gemm_identify
from schedule_search.cce_intrin_map import OP_INTRIN_KEY_INDEX


def condition_check(progress):
    '''
    :param progress:
    :return:
    '''
    # 非gemm不处理
    if progress.c_op not in comm.MAD_OP_ID_LIST:
        return False

    return True


def get_start_axis_index(progress):
    '''
    :param progress:
    :return:
    '''
    has_batch, _ = gemm_identify(progress.op_schedule_info)
    start_axis_index = 1 if has_batch else 0
    return start_axis_index


def get_ub_stage_num(op_schedule_info):
    '''
    :param op_schedule_info:
    :return:
    '''
    ub_stage_num = 0
    feature_tensor = op_schedule_info.feature_tensor
    for stage_index, stage_feature in enumerate(feature_tensor):
        if stage_index in op_schedule_info.inlined_stages:
            continue
        intrin = OP_INTRIN_KEY_INDEX[
            stage_feature[FeatureTensorCfg.compute_s]].intrin
        if intrin == "dma_copy":
            ub_stage_num += 1
    return ub_stage_num


def mask_matmul_stage(progress, action_mask, ub_stage_num, ub_size):
    '''
    matmul_stage
    '''
    start_factor_index = ActionTensorCfg.split_factor_s + \
                         progress.todo.cache_layer * AXIS_CNT
    factor = progress.action_tensor[progress.todo.stage_index][
        start_factor_index + progress.todo.axis_index]

    m_factor = progress.action_tensor[progress.stage_num - 1][
        start_factor_index]
    n_factor = progress.action_tensor[progress.stage_num - 1][
        start_factor_index + 1]

    if ub_stage_num >= 3:
        for idx in range(SEARCH_N):
            # UB的buffer判断
            new_factor = factor + pow(SEARCH_N,
                                      progress.todo.sub_action_index) * idx
            if m_factor * n_factor + (
                    m_factor + n_factor) * new_factor > ub_size:
                action_mask[idx] = 0

    return action_mask


def get_k_factor(progress):
    '''
    k_factor
    '''
    mad_stage_index = None
    for idx, info in enumerate(progress.op_schedule_info.stages_info):
        if info.get('tag') in comm.MAD_TAG_LIST:
            mad_stage_index = idx
            break

    start_factor_index = ActionTensorCfg.split_factor_s + \
                         progress.todo.cache_layer * AXIS_CNT

    k_factor = progress.action_tensor[mad_stage_index][start_factor_index]

    # 如果大K没有切，都取大K
    need_split_l0 = progress.op_schedule_info.stages_info[
        progress.todo.stage_index].get('need_split_l0')
    if need_split_l0:
        k_factor = progress.action_tensor[mad_stage_index][
            ActionTensorCfg.split_factor_s]

    return k_factor


def mask_last_stage(progress,  # pylint: disable=R0912
                    action_mask,
                    ub_stage_num,
                    ub_size):
    '''
    last_stage
    '''
    start_axis_index = get_start_axis_index(progress)
    start_factor_index = ActionTensorCfg.split_factor_s + \
                         progress.todo.cache_layer * AXIS_CNT
    factor = progress.action_tensor[progress.todo.stage_index][
        start_factor_index + progress.todo.axis_index]
    k_factor = get_k_factor(progress)

    # N，此时M还没采样，为1
    if progress.todo.axis_index == 1 + start_axis_index:
        another_mn_factor = progress.action_tensor[progress.todo.stage_index][
            start_factor_index]
    # M
    elif progress.todo.axis_index == 0 + start_axis_index:
        another_mn_factor = progress.action_tensor[progress.todo.stage_index][
            start_factor_index + 1]
    else:
        log.dbg('axis_index: %s wrong.', progress.todo.axis_index)
        return action_mask

    for idx in range(SEARCH_N):
        new_factor = factor + pow(SEARCH_N,
                                  progress.todo.sub_action_index) * idx
        # ub stage数量超过3个代表数据是从UB到L1的
        if ub_stage_num >= 3:
            if new_factor * another_mn_factor + (
                    new_factor + another_mn_factor) * k_factor > ub_size:
                log.dbg('ub_size: %s, new_factor: %s, another_mn_factor: '
                        '%s, k_factor: %s', ub_size, new_factor,
                        another_mn_factor, k_factor)
                action_mask[idx] = 0
        else:
            if new_factor * another_mn_factor > ub_size:
                log.dbg('ub_size: %s, new_factor: %s, another_mn_factor: '
                        '%s', ub_size, new_factor, another_mn_factor)
                action_mask[idx] = 0

    return action_mask


def proc(progress, action_mask):
    '''
    规则内容：gemm不超过ub buffer的大小
    m*n + (m+n)*k < ub
    M*N + (M+N)*K < ub
    '''
    if not condition_check(progress):
        return action_mask

    stage_tag = progress.op_schedule_info.stages_info[
        progress.todo.stage_index].get('tag')
    ub_stage_num = get_ub_stage_num(progress.op_schedule_info)
    ub_size = UB_BUFFER_SIZE / C_SIZE / C_SIZE

    # matmul stage
    if stage_tag == 'matmul':
        action_mask = mask_matmul_stage(progress,
                                        action_mask,
                                        ub_stage_num,
                                        ub_size)

    # 最后一个stage
    elif progress.todo.stage_index == progress.stage_num - 1:
        action_mask = mask_last_stage(progress,
                                      action_mask,
                                      ub_stage_num,
                                      ub_size)

    # 不能全部都mask掉
    if sum(action_mask) == 0:
        action_mask[0] = 1

    log.dbg('r10_gemm_smaller_than_ub_buffer: %s', action_mask)
    return action_mask
