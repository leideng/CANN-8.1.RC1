#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
from itertools import combinations
from collections import defaultdict
from io import StringIO
from contextlib import redirect_stdout
from contextlib import redirect_stderr
from typing import NoReturn

import numpy as np

from schedule_search import log
from schedule_search import soc_cfg
from schedule_search.ts_env.code_to_tensor.tvm_compute import DTYPE_INDEX
from schedule_search.ts_env.tensor_cfg import AXIS_CNT
from schedule_search.cce_intrin_map import OP_INTRIN_KEY_TAG
from tbe.common.platform import platform_info
from tbe import tvm
from tbe.tvm import tir as ir_pass
from tbe.tvm.tir import Stmt

# 以下两个值被其他文件使用，但本文件未使用，是否应该搬移到其他文件中？
UB_BUFFER_SIZE = soc_cfg.get_ub_size() // 2  # 考虑double buffer的话要除以2
SEARCH_N = AXIS_CNT

# 最大的iter_var个数
ITERVAR_NUM = 250

# iter_var todo的长度
ITERVAR_TODO_LEN = 5
# iter_var shape的长度
# 默认支持6个输入，后续可以调整
ITERVAR_SHAPE_LEN = AXIS_CNT * 6

# 特征按位转换的通道数 （应该在其他地方有定义？）
FEATURE_CHANNELS = 32
# stage数上限（应该小于最大的iter_var个数，目前置为相等）
FEATURE_MAX_STAGE_NUM = ITERVAR_NUM
# 表示每个Data（Stage）所需的列数。每位（每个通道）表示一个Data。
FEATURE_DATA_COLUMN_NUM = (FEATURE_MAX_STAGE_NUM - 1) // FEATURE_CHANNELS + 1

# 特征各个部分的长度
FEATURE_LOOP_INFO_LEN = 6
FEATURE_COMPUTE_INFO_LEN = 6
FEATURE_AXIS_INFO_LEN = AXIS_CNT * 3  # 3代表Extents, Axis, Reduce_Axis
# 4代表write, read, allocate, pragma
FEATURE_DATA_INFO_LEN = FEATURE_DATA_COLUMN_NUM * 4

# 以下三个值将会输出到外部
# iter_var attr的feature长度
# （即循环特征长度，Shape和Todo会插在循环特征后面，其他特征前面）
ITERVAR_ATTR_FEATURE_LEN = FEATURE_LOOP_INFO_LEN
# 一个iter_var的feature长度
ITERVAR_FEATURE_LEN = \
    FEATURE_LOOP_INFO_LEN + \
    FEATURE_COMPUTE_INFO_LEN + \
    FEATURE_AXIS_INFO_LEN + \
    FEATURE_DATA_INFO_LEN

# 一个iter_var的feature长度加上todo和shape的长度
FEATURE_LEN = ITERVAR_FEATURE_LEN + ITERVAR_TODO_LEN + ITERVAR_SHAPE_LEN


def define_entries():
    """
    定义常量：
    数据搬运路径、运算指令、数据类型、存储单元
    (dma_copy、pragma_emit_insn、dtype、storage)
    并将其转换为1到2个32位(FEATURE_CHANNELS位)整数
    dma_copy、dtype、storage的条目数目小于32个，转换为1个整数
    pragma_emit_insn条目数目为49个，转换为2个整数
    返回4个字典，key为上述内容的字符串，value为整数或整数对
    """
    def list_to_int(lst):
        """
        将列表对应到1到2个32位(FEATURE_CHANNELS位)整数，每项对应一位
        """
        lsts = lst + ["others"]
        dic = {}
        # 如果列表长度较少（小于32个），转换为1个整数
        if len(lsts) <= FEATURE_CHANNELS:
            num = 1
            for k in lsts:
                dic[k] = num
                num *= 2
        # 否则，转换为2个整数
        else:
            num1, num2 = 1, 0
            for k in lsts:
                dic[k] = (num1, num2)
                num1 *= 2
                num2 *= 2
                if num1 >= pow(2, FEATURE_CHANNELS):
                    num1, num2 = 0, 1
        return dic

    # 运算指令
    pragma_emit_insn_list = list(OP_INTRIN_KEY_TAG.keys())
    # 数据类型
    dtype_list = list(DTYPE_INDEX.keys())
    # 存储单元
    storage_list = [
        platform_info.scope_gm,
        platform_info.scope_ubuf,
        platform_info.scope_cbuf,
        platform_info.scope_ca,
        platform_info.scope_cb,
        platform_info.scope_cc,
        platform_info.scope_reg,
        platform_info.scope_aicpu,
    ]
    # 数据搬运路径
    dma_copy_list = list(combinations(storage_list, 2))

    dma_entry_local = list_to_int(dma_copy_list)
    prag_insn_entry_local = list_to_int(pragma_emit_insn_list)
    dtype_entry_local = list_to_int(dtype_list)
    storage_entry_local = list_to_int(storage_list)
    return dma_entry_local, prag_insn_entry_local, dtype_entry_local, storage_entry_local


# 常量：数据搬运路径、运算指令、数据类型、存储单元
DMAENTRY, PRAGINSNENTRY, DTYPEENTRY, STORAGEENTRY = define_entries()


def extract_read_name(expr):  # pylint: disable=R0911,R0912
    """
    从tvm.expr（表达式）中抽取被读取的变量名
    用于检查赋值信息（assign）中数据读取的情况
    返回值为被读取的变量名的set
    递归调用自身来读取表达式
    """
    expr_type = str(type(expr))[17:-2]
    binaryop = {
        "Add", "And", "Div", "EQ", "EqualOp", "FloorDiv", "FloorMod", "GE",
        "GT", "LE", "LT", "Max", "Min", "Mod", "Mul", "NE", "NotEqualOp", "Or",
        "Sub"
    }
    ignore = {"FloatImm", "IntImm", "StringImm", "UIntImm", "Var"}
    if expr_type in ignore:
        return set()

    ret = set()
    if expr_type == "Load":
        ret1 = {expr.buffer_var.name}
        ret2 = extract_read_name(expr.index)
        ret = ret1 | ret2
    elif expr_type == "Call":
        ret1 = set()
        for arg in expr.args:
            ret2 = extract_read_name(arg)
            ret1 = ret1 | ret2
        ret = ret1
    elif expr_type == "Cast":
        ret = extract_read_name(expr.value)
    elif expr_type in binaryop:
        ret1 = extract_read_name(expr.a)
        ret2 = extract_read_name(expr.b)
        ret = ret1 | ret2
    elif expr_type == "Not":
        ret = extract_read_name(expr.a)
    elif expr_type == "Select":
        ret0 = extract_read_name(expr.condition)
        ret1 = extract_read_name(expr.true_value)
        ret2 = extract_read_name(expr.false_value)
        ret = ret0 | ret1 | ret2
    else:
        log.warn("Error extract_read_name Unknown tvm.expr type: %s",
                 expr_type)
    return ret


def get_extent_value(extent):
    """
    返回extent的value
    """
    # int
    if isinstance(extent, tvm.tir.IntImm):
        return extent.value
    # 表达式，如(max(((i1.outer*1024) + 1023), 36547) + 1)，
    # 不好计算，直接返回0
    return 0


def else_case_empty_check(stmt: Stmt) -> NoReturn:
    """
    else_case empty check
    :param stmt:
    :return:
    """
    if stmt.else_case is not None:
        # 目前遇到的情形，If语句只用于判断下标确实属于Tensor之中，
        # 即Else case应该为空
        log.dbg("Error FEC.analyse_stmt tvm.stmt.IfThenElse "
                "Else case not empty")


class FeatureExtraction:  # pylint: disable=R0902
    """
    从tvm.stmt中提取信息，并生成特征。
    是本文件的主要内容。
    使用方法：
    （0）新建一个本类的对象
    （1）调用analyse_sch_stmt，将schedule和stmt中的信息提取到对象中
    （2）使用build_feas返回特征
    """
    def __init__(self):
        # 最后用于生成特征的信息
        # 循环信息, 循环id :EmptyStructure
        self.for_stmt = {}
        # 在analyse_stmt中提取出的临时信息
        self.storage_scope = {}  # key:循环变量名  val:存储位置
        self.double_buffer = {}  # key:循环变量名  val:为1表示是double_buffer
        # key:循环变量名（尚未遇到对应For的）  val:即将赋予的属性
        self.waiting_attr = {}
        # 集合： 尚未遇到nextFor的Allocate的变量名的集合
        self.waiting_allocate = set()
        # 在extract_sch_placeholder中提取出的临时信息
        self.stage_name = []  # 列表： 各个数据（stage）的先后顺序
        # 赋值语句信息, 赋值语句所在的最内层For循环id: EmptyStructure
        # 数据信息
        # key:数据名称  val:EmptyStructure，包括axis和reduce_axis
        # key:数据名称  val:EmptyStructure，包括extents,dtype,nextFor
        # key:placeholder名 val:EmptyStructure，包括axis,dtype
        self.info = {'assign': {},
                     'data': {},
                     'shape': {},
                     'allocate': {},
                     'placeholder': {}}

    def analyse_sch_stmt(self, sch, stmt):
        """
        从tvm.stmt中提取信息的主要流程。
        """
        self.analyse_stmt(stmt, -1, 1)  # 递归分析tvm.stmt
        # 从tvm.schedule中提取placeholder（输入stage）的名称等
        self.extract_sch_placeholder(sch)
        self.process_data()  # 处理数据信息
        self.process_assign()  # 处理赋值信息

    def analyse_stmt(self, stmt, outer_for, depth):  # pylint: disable=R0912
        """
        递归地分析tvm.stmt
        outer_for: 外层For循环的id
        depth: For循环语句嵌套的深度 （而不是本函数递归调用的深度）
        """
        is_attr_stmt = isinstance(stmt, tvm.tir.stmt.AttrStmt)
        is_thread_ext = (getattr(stmt, 'attr_key', '') == "thread_extent")
        # tvm.tir.stmt.AttrStmt 给某一对象赋予某种属性的结点
        # （除了thread_extent是循环的一种）
        non_thread_ext_stmt_flag = is_attr_stmt and not is_thread_ext
        thread_ext_stmt_flag = isinstance(stmt, tvm.tir.stmt.For) or (is_attr_stmt and is_thread_ext)
        if non_thread_ext_stmt_flag:
            self._analyse_non_thread_ext_stmt(stmt)
            # 递归调用
            self.analyse_stmt(stmt.body, outer_for, depth)
        # tvm.tir.stmt.For 循环语句 （包括AttrStmt的thread_extent）
        elif thread_ext_stmt_flag:
            idx = self._analyse_thread_ext_stmt(stmt, outer_for, depth)
            # 递归调用。只有本处outer_for,depth会变动
            self.analyse_stmt(stmt.body, idx, depth + 1)
        # tvm.stmt.ProducerConsumer 表示非输入Stage的产生和使用
        # 除输出Stage外成对出现，先出Producer，然后出Consumer
        # 使用这一结构来提取shape（axis,reduce_axis）信息，先存在self.shape字典之中
        # 之后在process_data函数中写到self.data中
        elif isinstance(stmt, tvm.tir.stmt.AttrStmt) and getattr(stmt, 'attr_key', '') == "is_producer":
            self._analyse_prod_consm_stmt(stmt)
            # 递归调用
            self.analyse_stmt(stmt.body, outer_for, depth)
        # tvm.stmt.Block 前后均为一个Stmt，分别递归读取前部分和后部分即可
        elif isinstance(stmt, tvm.stmt.Block):
            self.analyse_stmt(stmt.first, outer_for, depth)
            self.analyse_stmt(stmt.rest, outer_for, depth)
        elif isinstance(stmt, tvm.tir.stmt.SeqStmt):
            for i in range(len(stmt.seq)):
                self.analyse_stmt(stmt.seq[i], outer_for, depth)
        # tvm.stmt.tir.Store 赋值语句
        elif isinstance(stmt, tvm.tir.stmt.Store):
            self._analyse_store_stmt(stmt, outer_for)
        # tvm.stmt.Allocate分配内存 读取dtype、extents（实际分配内存的张量shape）
        # 先存在self.allocate，之后在process_data子函数中写到self.data中去
        elif isinstance(stmt, tvm.tir.stmt.Allocate):
            self._analyse_allocate_stmt(stmt, outer_for)
            # 递归调用
            self.analyse_stmt(stmt.body, outer_for, depth)
        # IfThenElse 判断语句
        elif isinstance(stmt, tvm.tir.stmt.IfThenElse):
            else_case_empty_check(stmt)
            # 递归调用
            self.analyse_stmt(stmt.then_case, outer_for, depth)
        elif isinstance(stmt, tvm.tir.stmt.SeqStmt):
            for stmt_tmp in stmt.seq:
                self.analyse_stmt(stmt_tmp, outer_for, depth)

    def extract_sch_placeholder(self, sch):
        """
        从tvm.schedule中提取placeholder（输入stage）的name,axis,dtype
        以及各个数据（stage）的先后顺序
        """
        # 读取placeholder的name,axis,dtype
        for stage in sch.stages:
            if not isinstance(stage.origin_op, tvm.PlaceholderOp):
                continue
            empty_stru = defaultdict(lambda: None)
            name = stage.origin_op.name
            empty_stru['name'] = name
            empty_stru['axis'] = []
            for shape in stage.origin_op.shape:
                empty_stru['axis'].append(shape.value)
            empty_stru['dtype'] = stage.origin_op.dtype
            self.info['placeholder'][name] = empty_stru
        # 各个数据（stage）的先后顺序
        for stage in sch.stages:
            self.stage_name.append(stage.origin_op.name)

    def process_data(self):  # pylint: disable=R0912
        """
        处理数据信息：
        1、从赋值语句assign中抽取数据名
        2、从allocate, shape, double_buffer,
        storage_scope, placeholder中丰富数据条目信息
        3、利用stage_name给数据编号
        """
        # 1、从赋值语句中抽取数据名
        self._process_data_get_name()

        # 2、丰富条目的信息
        self._process_data_fill_info()

        # 3、给data编号，按照stage_name的顺序进行编号
        self._process_data_index_data()

    def process_assign(self):  # pylint: disable=R0912
        """
        处理赋值信息：
        确定赋值的编译指令
        """
        # 对每个赋值语句
        for idx, assign_obj in self.info['assign'].items():
            cur_id, cur_attr, ids = self._get_assign_info(idx)
            # 如果没有找到任何编译指令，标记为no_pragma_assign，continue
            if cur_id == -1:
                assign_obj['p_id'] = -1
                assign_obj['p_ids'] = []
                assign_obj['p_fist'] = 'no_pragma_assign'
                assign_obj['p_rest'] = 'no_pragma_assign'
                continue
            # 如果找到
            assign_obj['p_id'] = cur_id  # 编译指令所在位置的id
            assign_obj['p_ids'] = ids  # 包含在编译指令内的For循环id
            if cur_attr[1] == 'dma_copy':
                # 如果是dma_copy,从data中读出对应数据的搬运出入存储位置
                assign_obj['p_fist'] = 'dma_copy'
                wbuffer = self.info.get('data').get(assign_obj.get('write_name')).get('storage_scope')
                rset = set(assign_obj.get('read_name'))
                read_name = rset.pop()
                rbuffer = self.info.get('data').get(read_name).get('storage_scope')
                tps = (rbuffer, wbuffer)
                assign_obj['p_rest'] = tps
            else:
                # 否则，记下编译指令
                assign_obj['p_fist'] = 'pragma_emit_insn'
                assign_obj['p_rest'] = cur_attr[1]

    def build_feas(self):
        """
        构建特征矩阵，返回feas
        """
        # 初始化特征矩阵
        feas, itervar_num_too_large = self._build_feas_init()

        # 开始构建特征矩阵
        part_begin = 0
        # Loop信息
        feas = self._build_feas_loop_info(feas, part_begin)
        # Compute信息
        part_begin += FEATURE_LOOP_INFO_LEN
        feas = self._build_feas_compute_info(feas, part_begin)
        # Axis信息
        part_begin += FEATURE_COMPUTE_INFO_LEN
        feas = self._build_feas_axis_info(feas, part_begin)
        # Data信息
        part_begin += FEATURE_AXIS_INFO_LEN
        feas = self._build_feas_data_info(feas, part_begin)
        part_begin += FEATURE_DATA_INFO_LEN
        # IterVar的数目超过上限时（init返回值），最后进行截取
        if itervar_num_too_large:
            feas = feas[:ITERVAR_NUM, :]
        return feas

    def _analyse_non_thread_ext_stmt(self,  # pylint: disable=R0912,R0915,R0914
                                     stmt):
        '''
        _analyse_non_thread_ext_stmt
        :param stmt:
        :return:
        '''
        # storage_scope 存储位置
        if stmt.attr_key == "storage_scope":
            self.storage_scope[stmt.node.name] = stmt.value.value
        # double_buffer_scope 存储double_buffer
        elif stmt.attr_key == "double_buffer_scope":
            self.double_buffer[stmt.node.name] = 1
        # 已知的一些编译指令，将其放到waiting_attr中（key:循环变量名）
        # 待实际遇到该名的循环变量，再将其写入对应的For循环信息中
        elif stmt.attr_key == "pragma_emit_insn" or \
                stmt.attr_key == "pragma_k_outer" or \
                stmt.attr_key == "pragma_mad_pattern":
            self.waiting_attr.setdefault(stmt.node.var.name, [])
            if isinstance(stmt.value,
                          (tvm.tir.StringImm, tvm.tir.IntImm)):
                val = stmt.value.value
                self.waiting_attr[stmt.node.var.name].append(
                    [stmt.attr_key, val])
            elif isinstance(stmt.value, tvm.Var):
                val = stmt.value.name
                self.waiting_attr[stmt.node.var.name].append(
                    [stmt.attr_key, val])
            else:
                log.dbg(
                    "Error FEC.analyse_stmt tvm.tir.stmt.AttrStmt "
                    "Unknown value type: %s", str(type(stmt.value)))
        else:
            log.dbg(
                "Error FEC.analyse_stmt tvm.tir.stmt.AttrStmt "
                "Unknown attr_key: %s", str(stmt.attr_key))

    def _analyse_thread_ext_stmt(self, stmt, outer_for, depth):
        '''
        _analyse_thread_ext_stmt
        :param stmt:
        :return:
        '''
        # 定义一个EmptyStructure，向其中写入信息
        empty_stru = defaultdict(lambda: None)
        # 循环变量名和循环长度
        if isinstance(stmt, tvm.tir.stmt.For):
            empty_stru['var'] = stmt.loop_var.name
            empty_stru['extent'] = get_extent_value(stmt.extent)
        else:
            empty_stru['var'] = stmt.node.var.name
            empty_stru['extent'] = stmt.value.value
        # idx,外层循环idx, For循环深度
        idx = len(self.for_stmt)
        empty_stru['idx'] = idx
        empty_stru['outer_for'] = outer_for
        empty_stru['depth'] = depth
        # 将waiting_attr中，赋给此循环变量名的属性读出
        if empty_stru['var'] in self.waiting_attr:
            empty_stru['attr'] = self.waiting_attr[empty_stru['var']]
            del self.waiting_attr[empty_stru['var']]
        else:
            empty_stru['attr'] = []
        # 将EmptyStructure放入self.for_stmt字典中
        self.for_stmt[idx] = empty_stru

        # 将waiting_allocate中存在的所有Allocate的nextFor指定为本语句，并清空
        for name in self.waiting_allocate:
            self.info['allocate'][name]['nextFor'] = idx
        self.waiting_allocate = set()
        return idx

    def _analyse_prod_consm_stmt(self, stmt):
        '''
        _analyse_prod_consm_stmt
        :param stmt:
        :return:
        '''
        # 成对输出，信息重复，所以只在Producer中提取
        if stmt.is_producer == 1:
            # 名称
            name = stmt.func.name
            # 定义一个EmptyStructure，向其中写入信息
            shape = defaultdict(lambda: None)
            # axis
            shape['axis'] = []
            for axis in stmt.func.axis:
                shape['axis'].append(axis.dom.extent.value)
            # reduce_axis
            shape['reduce_axis'] = []
            for axis in stmt.func.reduce_axis:
                shape['reduce_axis'].append(axis.dom.extent.value)
            # 将其放入self.shape字典之中
            if name in self.info['shape']:
                # 非输入Stage的产生应该只有一次，不应该有同名的
                log.dbg(
                    "Error FEC.analyse_stmt tvm.tir.stmt.ProducerConsumer "
                    "shape of %s has existed", name)
            else:
                self.info['shape'][name] = shape

    def _analyse_store_stmt(self, stmt, outer_for):
        '''
        _analyse_store_stmt
        :param stmt:
        :param outer_for:
        :return:
        '''
        # 定义一个EmptyStructure，向其中写入信息
        store = defaultdict(lambda: None)
        # 赋值语句写入的变量名
        write_name = stmt.buffer_var.name
        store['write_name'] = write_name
        # 赋值语句读取的变量名，利用函数extract_read_name来递归地抽取
        store['read_name'] = extract_read_name(stmt.value)
        # 外层循环
        store['outer_for'] = outer_for
        if outer_for in self.info['assign']:
            # 目前遇到的情形，每个最内层For循环中只会包含一句赋值语句。
            # 基于这个假设，self.assign中赋值语句的key，
            # 是包含其的最内层的For循环id
            # 如果最内层For循环中包含2句赋值语句，会先后互相覆盖
            log.dbg("Error FEC.analyse_stmt tvm.stmt.Store "
                    "Multi Store after a For")
            return
        # 放入self.assign中
        self.info['assign'][outer_for] = store

    def _analyse_allocate_stmt(self, stmt, outer_for):
        '''
        _analyse_allocate_stmt
        :param stmt:
        :param outer_for:
        :return:
        '''
        # 定义一个EmptyStructure，向其中写入信息
        allocate = defaultdict(lambda: None)
        # 变量名、外层For循环的id、dtype、extents
        name = stmt.buffer_var.name
        allocate['outer_for'] = outer_for
        allocate['dtype'] = stmt.dtype
        allocate['extents'] = []
        for ex in stmt.extents:
            allocate['extents'].append(get_extent_value(ex))
        # 存入self.allocate
        if name in self.info['allocate']:
            # 一个变量只会被分配内存一次
            log.dbg(
                "Error FEC.analyse_stmt tvm.tir.stmt.Allocate "
                "allocate of %s has existed", name)
        else:
            self.info['allocate'][name] = allocate
            # 为了知道其下一个For循环的id（nextFor），
            # 存入一个set集合waiting_allocate中，在遇到下一个For循环时写入
            self.waiting_allocate.add(name)

    def _process_data_get_name(self):
        '''
        1、从赋值语句assign中抽取数据名 _process_data_get_name
        :return:
        '''
        data = self.info['data']
        for store in self.info['assign'].values():
            # 读、写的所有名称
            names = {store['write_name']}
            for read_name in store['read_name']:
                names.add(read_name)
            # 在Data中创建条目
            for name in names:
                if name not in data:
                    empty_stru = defaultdict(lambda: None)
                    empty_stru['name'] = name
                    empty_stru['write'] = -1
                    data[name] = empty_stru
            # 数据被写入的位置（赋值语句外层For循环的id）
            outer_for = store['outer_for']
            data[store['write_name']]['write'] = outer_for

    def _parse_info_from_allocate(self: object, name: str, data_obj: defaultdict) -> defaultdict:
        """
        parse memory info from allocate
        """
        if name in self.info.get('allocate'):
            buff = self.info.get('allocate').get(name)
            data_obj['allocate_outer_for'] = buff['outer_for']
            data_obj['allocate_nextFor'] = buff['nextFor']
            data_obj['dtype'] = buff['dtype']
            data_obj['extents'] = buff['extents']
        else:
            # 某些数据（主要是输入数据，placeholder）没有分配内存
            data_obj['allocate_outer_for'] = -1
            data_obj['allocate_nextFor'] = -1
            data_obj['dtype'] = "unknown"
            data_obj['extents'] = [-1]
        return data_obj

    def _process_data_fill_info(self):  # pylint: disable=R0912
        """
        _process_data_fill_info
        :return:
        """
        data = self.info['data']
        for name, data_obj in data.items():
            # 从allocate中抽取分配内存的位置、dtype、extents
            data_obj = self._parse_info_from_allocate(name, data_obj)
            # shape信息
            if name in self.info['shape']:
                shape_obj = self.info['shape'][name]
                data_obj['axis'] = shape_obj['axis']
                data_obj['reduce_axis'] = shape_obj['reduce_axis']
            else:
                data_obj['axis'] = [-1]
                data_obj['reduce_axis'] = [-1]
            # double_buffer和storage_scope信息
            if name in self.double_buffer:
                data_obj['double_buffer'] = 1
            else:
                data_obj['double_buffer'] = 0
            if name in self.storage_scope:
                data_obj['storage_scope'] = self.storage_scope[name]
            else:
                data_obj['storage_scope'] = "global"
        # 输入数据的信息在placeholder中
        for name, plhd in self.info['placeholder'].items():
            if (name in data) and (data[name]['dtype'] == "unknown"):
                data[name]['axis'] = plhd['axis']
                data[name]['dtype'] = plhd['dtype']
                data[name]['extents'] = plhd['axis']
                data[name]['reduce_axis'] = []

    def _process_data_index_data(self):
        """
        :return:
        """
        data = self.info['data']
        for name, data_obj in data.items():
            data_obj['idx'] = -1
        data_id = 0
        for i in range(len(self.stage_name)):
            name = self.stage_name[i]
            if name in data:
                data[name]['idx'] = data_id
                data_id += 1
        # 剩下的（不应该有剩下的）按顺序编号
        for name, data_obj in data.items():
            if data_obj['idx'] == -1:
                log.dbg(
                    "Error FEC.process_dataAssign: data: %s "
                    "not exist in stage", name)
                data[name]['idx'] = data_id
                data_id += 1

    def _get_assign_info(self: object, idx: int) -> (int, list, list):
        """
        获取assign pragma信息：
        :param: cur_id
        """
        ids = []  # 包含在编译指令内的For循环id
        cur_id = idx
        cur_attr = []  # 当前找到的编译指令
        # 从赋值语句的那个For循环开始，从内到外找编译指令
        while cur_id != -1:
            # 将当前位置加入
            ids.append(cur_id)
            found = False
            # 检查当前位置是否有编译指令
            for attr in self.for_stmt.get(cur_id).get('attr'):
                if attr[0] == "pragma_emit_insn":
                    cur_attr = attr
                    found = True
                    break
            # 如果找到，停止寻找
            if found:
                break
            # 否则，向外一层For循环
            cur_id = self.for_stmt.get(cur_id).get('outer_for')
        return cur_id, cur_attr, ids

    def _build_feas_init(self):
        '''
        检查IterVar的数目是否超过上限，如果是，报Warning，
        并暂时用一个较大的矩阵写入，最后截取
        '''
        if len(self.for_stmt) > ITERVAR_NUM:
            itervar_num_too_large = True
            log.dbg("Number of IterVar ( %s ) > ITERVAR_NUM ( %s )",
                    len(self.for_stmt), ITERVAR_NUM)
            feas = np.zeros([len(self.for_stmt), ITERVAR_FEATURE_LEN],
                            dtype="int32")
        else:
            itervar_num_too_large = False
            feas = np.zeros([ITERVAR_NUM, ITERVAR_FEATURE_LEN],
                            dtype="int32")
        return feas, itervar_num_too_large

    def _build_feas_loop_info(self, feas, part_begin):
        # 循环特征 Loop Info
        for idx, for_obj in self.for_stmt.items():
            # length
            feas[idx, part_begin + 0] = for_obj['extent']
            # nest_level
            feas[idx, part_begin + 1] = for_obj['depth']
            # isBlockIdx
            if for_obj['var'] == "blockIdx.x":
                feas[idx, part_begin + 2] = 1
            # isFinalFor & topdown
            feas[idx, part_begin + 3] = 1
            topdown = for_obj['extent']
            outer_id = for_obj['outer_for']
            while outer_id != -1:
                feas[outer_id, part_begin + 3] = 0
                topdown *= self.for_stmt[outer_id]['extent']
                outer_id = self.for_stmt[outer_id]['outer_for']
            bits = pow(2, FEATURE_CHANNELS)
            feas[idx, part_begin + 4] = topdown % bits
            feas[idx, part_begin + 5] = topdown // bits
        return feas

    def _build_feas_compute_info(self,  # pylint: disable=R0912
                                 feas,
                                 part_begin):
        """
        抽取运算特征 Compute Info
        :return:
        """
        for idx, assign_obj in self.info['assign'].items():
            if assign_obj['p_fist'] == 'dma_copy':
                tps = assign_obj['p_rest']
                if tps not in DMAENTRY:
                    log.dbg("dma_copy: %s not defined", tps)
                    tps = "others"
                feas[idx, part_begin + 0] = DMAENTRY[tps]
            elif assign_obj['p_fist'] == 'pragma_emit_insn':
                tps = assign_obj['p_rest']
                if tps not in PRAGINSNENTRY:
                    log.dbg("pragma_emit_insn: %s not defined", tps)
                    tps = "others"
                feas[idx, part_begin + 1] = PRAGINSNENTRY[tps][0]
                feas[idx, part_begin + 2] = PRAGINSNENTRY[tps][1]
            else:
                pass
            # dtype
            tps = self.info['data'][assign_obj['write_name']]['dtype']
            if tps not in DTYPEENTRY:
                log.dbg("dtype: %s not defined", tps)
                tps = "others"
            feas[idx, part_begin + 3] = DTYPEENTRY[tps]
            # storage_scope
            tps = self.info['data'][assign_obj['write_name']]['storage_scope']
            if tps not in STORAGEENTRY:
                log.dbg("storage: %s not defined", tps)
                tps = "others"
            feas[idx, part_begin + 4] = STORAGEENTRY[tps]
            # double_buffer
            feas[idx, part_begin + 5] = \
                self.info['data'][assign_obj['write_name']]['double_buffer']
        return feas

    def _build_feas_axis_info(self, feas, part_begin):  # pylint: disable=R0912
        '''
        Axis特征: Extents, Axis, Reduce_Axis
        '''
        for idx, assign_obj in self.info['assign'].items():
            extents = self.info['data'][assign_obj['write_name']]['extents']
            axis = self.info['data'][assign_obj['write_name']]['axis']
            reduce_axis \
                = self.info['data'][assign_obj['write_name']]['reduce_axis']
            for i, extent in enumerate(extents):
                if extent < 0:
                    continue
                feas[idx, part_begin + i] = extent
            for i, axis_len in enumerate(axis):
                if axis_len < 0:
                    continue
                feas[idx, part_begin + AXIS_CNT + i] = axis_len
            for i, aixs_len in enumerate(reduce_axis):
                if aixs_len < 0:
                    continue
                feas[idx, part_begin + 2 * AXIS_CNT + i] = aixs_len
        return feas

    def _build_feas_data_info(self, feas, part_begin):  # pylint: disable=R0914
        '''
        数据特征 Data Access Info (write, read, allocate, pragma, )
        '''
        da_bits = np.zeros([len(self.for_stmt), FEATURE_DATA_INFO_LEN],
                           np.uint32)
        for assign_f_id, assign_obj in self.info['assign'].items():
            # write
            write_assign_obj = self.info['data'][assign_obj['write_name']]
            w_c = write_assign_obj['idx'] // FEATURE_CHANNELS
            w_b = write_assign_obj['idx'] % FEATURE_CHANNELS
            da_bits[assign_f_id][w_c] |= pow(2, w_b)
            # read
            for read_name in assign_obj['read_name']:
                r_c = self.info['data'][read_name]['idx'] // FEATURE_CHANNELS
                r_b = self.info['data'][read_name]['idx'] % FEATURE_CHANNELS
                da_bits[assign_f_id][FEATURE_DATA_COLUMN_NUM + r_c] \
                    |= pow(2, r_b)

            allocate_f_id = write_assign_obj['allocate_nextFor']
            da_bits[allocate_f_id][2 * FEATURE_DATA_COLUMN_NUM + w_c] \
                |= pow(2, w_b)
            for pragma_f_id in assign_obj['p_ids']:
                da_bits[pragma_f_id][3 * FEATURE_DATA_COLUMN_NUM + w_c] \
                    |= pow(2, w_b)
        for j in range(len(self.for_stmt)):
            for i in range(FEATURE_DATA_INFO_LEN):
                feas[j, part_begin + i] = da_bits[j][i]
        return feas


def ana_lower(sch,  # pylint: disable=no-member
              args,
              binds=None):
    """
    Do lower while keeping all axes in IR
    i.e. Do not eliminate loop with extent of 1,
    do not vectorize, unroll or inject virtual threads
    """
    # tvm底层可能会有一些奇怪的打印，我们在此统一封装下，让它不要吱声
    f_out = StringIO()
    f_err = StringIO()
    with redirect_stderr(f_err), redirect_stdout(f_out):
        binds, out_args = tvm.driver.build_module.get_binds(args, binds=binds)
        sch = sch.normalize()
        # Phase 0
        bounds = tvm.te.schedule.InferBound(sch)  # pylint: disable=E1101
        stmt = tvm.te.schedule.ScheduleOps(sch, bounds, True)
        func = tvm.te.schedule.SchedulePostProcToPrimFunc(out_args, stmt, binds)
        mod = tvm.IRModule.from_expr(func)
        mod = tvm.tir.transform.StorageFlatten(64)(mod)
        mod = tvm.tir.transform.CanonicalSimplify()(mod)
        stmt = mod["main"].body
    return stmt


def sch_to_stmt(sch):
    """
    把schedule对象转为stmt
    :param sch: 输入的schedule对象
    :return: stmt
    """
    # 获取输入输出tensor
    args_tensors = []
    for stage in sch.stages:
        # 这里的output只有叶子输出，没有中间输出
        if str(stage.op).startswith('placeholder') or stage.is_output:
            for idx in range(stage.op.num_outputs):
                args_tensors.append(stage.op.output(idx))
    # 获取ana_lower
    from tbe.common.buildcfg import build_config
    with build_config():
        stmt = ana_lower(sch, args_tensors)
    return stmt


def sch_to_state(sch):
    """
    把schedule对象转为state
    :param sch: 输入的schedule对象
    :return: features
    """
    try:
        stmt = sch_to_stmt(sch)
        worker = FeatureExtraction()
        worker.analyse_sch_stmt(sch, stmt)
        feas = worker.build_feas()
    except Exception as exception:  # pylint: disable=broad-except
        log.warn("exception: %s", str(exception))
        feas = np.zeros([ITERVAR_NUM, ITERVAR_FEATURE_LEN], dtype="int32")

    return feas
