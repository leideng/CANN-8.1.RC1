#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import hashlib
from typing import Union
import numpy as np

from schedule_search import log
from schedule_search import util


def generate_md5(option: dict, value: Union[list, np.ndarray]) -> str:
    """
    generate action tensor hash
    :param option: op_schedule_info.option
    :param value: action_tensors or cheque_list
    :return:
    """
    if isinstance(value, list):
        action_tensors_list = []
        for action_tensor in value:
            action_tensor_add = action_tensor
            if isinstance(action_tensor, np.ndarray):
                action_tensor_add = action_tensor.tolist()
            action_tensors_list.append(action_tensor_add)
    elif isinstance(value, np.ndarray):
        action_tensors_list = value.tolist()
    else:
        action_tensors_list = value

    md5_obj = hashlib.sha256()
    key_str = str(option) + str(action_tensors_list)
    md5_obj.update(key_str.encode())
    key_md5 = md5_obj.hexdigest()[:util.HASH_LEN]
    return key_md5


def query_history_dict(op_md5: str, key_md5: str, shared_history_dict: dict) -> [str, int, int]:
    """
    query shared_history_dict and match key, return corresponding value if hit
    :param op_md5: op hash
    :param key_md5: action_md5 or cheque_md5
    :param shared_history_dict: ACTION_HISTORY_DICT or CHEQUE_HISTORY_DICT
    :return: err_code, tick, hit_num
    """
    log.dbg("query shared_history_dict, op_md5: %s, key_md5: %s.", op_md5, key_md5)

    if op_md5 in shared_history_dict and key_md5 in shared_history_dict.get(op_md5, {}):
        log.dbg("hit shared_history_dict result, op_md5: %s, key_md5: %s", op_md5, key_md5)
    return shared_history_dict.get(op_md5, {}).get(key_md5, ["", None, 0])


def update_history_dict(op_md5: str,
                        key_md5: str,
                        new_tick: int,
                        new_hit_res: str,
                        shared_history_dict: dict) -> (int, str):
    """
    update shared_history_dict
    :param op_md5: op hash
    :param key_md5: action_md5 or cheque_md5
    :param new_tick: tick from get_tick
    :param new_hit_res: err_code from get_tick
    :param shared_history_dict: ACTION_HISTORY_DICT or CHEQUE_HISTORY_DICT
    :return: tick, err_code
    """
    # other independent tree maybe already update action history, retry query_action_history
    hit_res, tick, _ = query_history_dict(op_md5, key_md5, shared_history_dict)
    if hit_res:
        return tick, hit_res
    # if not in history, initialize one
    if op_md5 not in shared_history_dict:
        shared_history_dict[op_md5] = {key_md5: [new_hit_res, new_tick, 0]}
    else:
        new_value = shared_history_dict.get(op_md5, {})
        new_value.update({key_md5: [new_hit_res, new_tick, 0]})
        shared_history_dict[op_md5] = new_value
    log.dbg("update shared_history_dict result succ, op_md5: %s, key_md5: %s, value: %s.",
             op_md5, key_md5, [new_hit_res, new_tick, 0])
    return new_tick, new_hit_res


def update_hit_num(op_md5: str, key_md5: str, shared_history_dict: dict) -> None:
    """
    update hit number
    :param op_md5:
    :param key_md5: action_md5 or cheque_md5
    :param shared_history_dict: ACTION_HISTORY_DICT or CHEQUE_HISTORY_DICT
    :return:
    """
    new_value = shared_history_dict.get(op_md5, {})
    if new_value and key_md5 in new_value and len(new_value.get(key_md5, [])) >= 1:
        new_value[key_md5][-1] += 1
        shared_history_dict[op_md5] = new_value
        log.dbg("update shared_history_dict hit_num succ, op_md5: %s, key_md5: %s, value: %s.",
                op_md5, key_md5, shared_history_dict.get(op_md5, {}).get(key_md5, ["", None, 0]))
