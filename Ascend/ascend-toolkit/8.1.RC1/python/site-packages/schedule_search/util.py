#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.

rl schedule search, tss
"""
import copy
import datetime
import errno
import getpass
import glob
import json
import multiprocessing
import os
import stat
import random
import shutil
import subprocess
import sys
import time
import math
from configparser import ConfigParser
from collections import namedtuple
from functools import reduce as functools_reduce

from schedule_search import config
from schedule_search import log
from schedule_search.timeout_func_class import FuncTimeout
from schedule_search.timeout_func_class import get_print_log
from schedule_search.timeout_func_class import print_log_proc

from tbe import tvm

HASH_LEN = 32
FAIL_SAFE = 500000
OPEN_FILE_FLAGS = os.O_WRONLY | os.O_CREAT
WRITE_FILE_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_TRUNC
OPEN_FILE_MODES_640 = stat.S_IWUSR | stat.S_IRUSR | stat.S_IRGRP
OPEN_FILE_MODES_644 = stat.S_IWUSR | stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH
DIR_PERMISSION_750 = 0o750
TOP_TEN_CHEQUE = 10

LogParams = namedtuple("LogPrint", ["cmd", "quiet", "ret", "ret_str", "output", "print_output"])


#  如果通过配置指定了输出目录用配置，没有则根据op_name、
#  TASK_ID和STORE_TMP_ID组成输出目录
def get_store_tmp_dir(op_name, config_dict):
    """

    :param op_name:
    :param config_dict:
    :return:
    """
    if config_dict.get("output_dir", ''):
        store_tmp_dir = config_dict.get("output_dir", '')
        return store_tmp_dir

    if "flag_workspace" in config_dict:
        workspace = config_dict["flag_workspace"]
        store_tmp_dir = os.path.join(workspace, "store_tmp",
                                     op_name).strip("_")
        return store_tmp_dir

    workspace = config_dict.get("WORKSPACE", '')
    store_tmp_dir = os.path.join(
        workspace, "store_tmp",
        op_name + "@" + config_dict.get("search_algo", "rl") + "@" +
        config_dict.get("TASK_ID", 'llt') + "_" +
        config_dict.get("STORE_TMP_ID", '')).strip("_")
    return store_tmp_dir


def get_op_layers(sch_obj):
    """

    :param sch_obj:
    :return:
    """
    for stage in sch_obj.stages:
        # 只要以.local.L1.local.L0A, .local.L1.local.L0A,
        # .local.L1.local.L0A结尾，那就是2层无疑了
        if stage.op.name.endswith('.local.L1.local.L0A') \
                or stage.op.name.endswith('.local.L1.local.L0') \
                or stage.op.name.endswith('.local.L1.local.L0C'):
            log.dbg('Found a L0 stage: %s. So op_layers is 2.', stage.op.name)
            return 2
        # WILLDO: 目前链路没有OUT -> L0的，因此先简化处理，发现L0A则直接认为是2层
        if stage.op.name.endswith('.local.L0A'):
            return 2
    # 其他情况都是1层
    log.dbg('No L0 stage. So op_layers is 1.')
    return 1


# shell=True时，该函数的执行时间可能超过timeout，请谨慎使用timeout
# 如果cmd的执行时间超过timeout，那么cmd执行完后才会抛出TimeoutExpired异常
def run_cmd_comm(cmd: str, timeout: int = 1800, print_output: bool = False,
                 shell: bool = True, quiet: bool = False) -> tuple:
    """
    :param cmd:
    :param timeout:
    :param print_output:
    :param shell:
    :param quiet:
    :return:
    """
    # 打印debug日志
    print_log = get_print_log(cmd, "")
    log.dbg("begin to %s", print_log)

    if not shell:
        cmd = cmd.split(" ")
    # 规范timeout类型
    try:
        timeout = float(timeout)
    except (ValueError, TypeError):
        timeout = None
    finally:
        pass
    if sys.version_info >= (3, 5):
        try:
            out_bytes = subprocess.check_output(cmd, stderr=subprocess.PIPE, shell=shell, timeout=timeout)
        except subprocess.CalledProcessError as proc_err:
            stderr_str = proc_err.stderr.decode('utf-8', errors="ignore")
            output_str = proc_err.output.decode('utf-8', errors="ignore")
            output_str += stderr_str
            log_params = LogParams(cmd, quiet, False, "fail", output_str, print_output)
            print_log_proc(log_params)
            return False, output_str
        except subprocess.TimeoutExpired:
            log_params = LogParams(cmd, quiet, False, "timeout", "timeout:%d" % timeout, print_output)
            print_log_proc(log_params)
            return False, 'timeout'
        finally:
            pass
    else:
        return False, 'unsupported python version'
    log_params = LogParams(cmd, quiet, True, "succ", out_bytes.decode('utf-8', errors="ignore"), print_output)
    print_log_proc(log_params)
    return True, out_bytes.decode('utf-8', errors="ignore")


def write_to_file(file_path: str, content: str = "") -> bool:
    """
    write to file
    :param file_path:
    :param content:
    :return: T/F
    """
    file_path = os.path.realpath(file_path)
    dir_name = os.path.dirname(file_path)
    ret = create_dir(dir_name)
    if not ret:
        log.warn('can not create dir: %s.', dir_name)
        return False

    with os.fdopen(os.open(file_path, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), 'w') as file_handler:
        file_handler.write(content)
    return True


def mv_src_to_dst(src_path, dst_path):
    """

    :param src_path:
    :param dst_path:
    :return:
    """
    if not os.path.exists(src_path):
        log.warn('src: %s not exist.', src_path)
        return False

    dst_dir = os.path.dirname(dst_path)
    create_dir(dst_dir)
    if not os.path.isdir(dst_dir):
        log.warn('can not create %s.', dst_dir)
        return False

    shutil.move(src_path, dst_path)
    return False


def cp_src_to_dst(src_path, dst_path, overwriting=True, mode=None):
    """

    :param src_path:
    :param dst_path:
    :param overwriting:
    :return:
    """
    if overwriting is False:
        if os.path.exists(dst_path):
            return True

    if not os.path.exists(src_path):
        log.warn('src: %s not exist.', src_path)
        return False

    dst_dir = os.path.dirname(dst_path)
    create_dir(dst_dir)
    if not os.path.isdir(dst_dir):
        log.warn('can not create %s.', dst_dir)
        return False

    shutil.copy(src_path, dst_path)
    if mode is not None:
        os.chmod(dst_path, mode)
    return True


def rm_proc(path):
    """

    :param path:
    :return:
    """
    try:
        if os.path.isdir(path):
            shutil.rmtree(path)
        elif os.path.isfile(path):
            os.remove(path)
    except OSError as excp:
        log.warn('can not rm tree: %s', excp)

    return True


def get_evb_info_from_str(option: dict) -> list:
    """
    get info from option, when option is str
    """
    evbs = []
    if not os.path.exists(option.get("evb_conf")):
        raise RuntimeError('evb_conf file %s does not exists, please check.' % (option.get("evb_conf")))
    ini_config = ConfigParser()
    try:
        ini_config.read(option.get("evb_conf"), encoding='utf-8')
    except (OSError, ValueError) as exception:
        log.warn('exception: %s', str(exception))
        raise RuntimeError('%s is illegal, must be ini format!' % (option.get("evb_conf")))
    finally:
        pass
    for section in ini_config.sections():
        evb_info = {}
        for key, value in ini_config.items(section):
            if key == "device_idx":
                value = value.replace(" ", "").split(",")
            evb_info[key] = value
        evbs.append(evb_info)
    return evbs


def evb_conf_parser(option):
    """

    :param option:
    :return:
    """
    if isinstance(option.get("evb_conf"), dict):
        return [option.get("evb_conf")]

    if isinstance(option.get("evb_conf"), list):
        return option.get("evb_conf")

    evbs = []
    if isinstance(option.get("evb_conf"), str):
        evbs = get_evb_info_from_str(option)
    return evbs


def get_device_id_by_env():
    """

    :return:
    """
    logic_device_id = os.getenv("ASCEND_DEVICE_ID", None)
    if logic_device_id is not None:
        return logic_device_id

    phy_device_id = os.getenv("DEVICE_ID", None)
    return phy_device_id


def get_all_evbs(option):
    """

    :param option:
    :return:
    """

    if option.get("rl_mode", "") == "rl_tune_om":
        evbs = [{
            "host_ip": "localhost",
            "host_user": getpass.getuser(),
            "device_idx": [0]
        }]
        return evbs

    no_device_err_args = {"errCode": "ED0000"}
    # 读取evb信息
    if not option.get("evb_conf", []):
        device_id = get_device_id_by_env()
        if device_id is not None:
            evbs = [{
                "host_ip": "localhost",
                "host_user": getpass.getuser(),
                "device_idx": [device_id],
            }]
            return evbs
        ret, output = run_cmd_comm("PATH=$PATH:/usr/sbin/ lspci | grep"
                                   " 'Processing accelerators' | wc -l")
        if not ret:
            raise RuntimeError(no_device_err_args)
        device_cnt_str = output.split("\n")[0]
        if device_cnt_str.isdigit() and device_cnt_str != "0":
            evbs = [{
                "host_ip": "localhost",
                "host_user": getpass.getuser(),
                "device_idx": list(range(int(device_cnt_str)))
            }]
        else:
            raise RuntimeError(no_device_err_args)
    else:
        evbs = evb_conf_parser(option)
    return evbs


def validate_option_value(option_value: object, option_yaml_dict: dict, option_key: str, value_type: object) -> object:
    """
    validate option value
    """
    # 如果传入的option的type与config的type配置不一致，则需要进行类型转化
    if not isinstance(option_yaml_dict[option_key], value_type):
        # 转化失败则报错退出
        old_option_value = option_value
        try:
            option_value = value_type(old_option_value)
        except (ValueError, TypeError) as exception:
            err_msg = "format error, type of %s must be %s." % (option_key, value_type)
            log.warn(err_msg)
            raise RuntimeError(err_msg, repr(exception))
        finally:
            pass
        log.warn(
            'Input option %s[%s] is %s type. It is converted to %s type: %s.', option_key, old_option_value,
            type(old_option_value), value_type, option_value)

    return option_value


def init_option(option: object) -> object:
    """
    option配置的优先级：
    1、用户传入的option;
    2、代码库上的config.py文件
    """
    option_yaml_dict = {}
    option_yaml_dict.update(option)

    # 没有配置的option以OPTION_CONFIG为准
    config_option = copy.deepcopy(config.OPTION_CONFIG)

    for option_key in option_yaml_dict:
        option_value = option_yaml_dict[option_key]
        if option_key in config_option:
            value_type = type(config_option[option_key])
            option_value = validate_option_value(option_value, option_yaml_dict, option_key, value_type)
        # 正常赋值
        config_option[option_key] = option_value

    # 校验error_tolerance数据输入
    if "error_tolerance" in config_option:
        error_tolerance = config_option["error_tolerance"]
        if error_tolerance < 0 or error_tolerance > 1:
            raise RuntimeError("error_tolerance must be in the range (0,1)!")

    config_option["evbs"] = get_all_evbs(config_option)

    option = copy.deepcopy(config_option)
    # option的timeout很容易溢出，所以设定一个上限
    option['timeout'] = min(2000000, option['timeout'])
    workspace = option["WORKSPACE"]
    # workspace不存在情况则需要先生成
    create_dir(workspace)
    return option


def init_output_dir(option):
    """
    初始化输出目录
    :param option:
    :return:
    """
    op_name = option.get("op_name", "default")
    output_dir = get_store_tmp_dir(op_name, option)
    option["output_dir"] = output_dir

    if not os.path.isdir(output_dir):
        log.info("Path %s does not exist. Creating.", output_dir)
        create_dir(output_dir)
    else:
        log.info("Path %s exists. Remove and remake.", output_dir)
        shutil.rmtree(output_dir)
        create_dir(output_dir)


def get_evb_info(option):
    """

    :param option:
    :return:
    """
    # 获取cluster的evb信息
    evbs = option["evbs"]
    evb_info = copy.deepcopy(random.choice(evbs))
    device_idx = evb_info.get('device_idx', "0")
    # 如果配置的device_idx是list形式
    if device_idx and isinstance(device_idx, list):
        evb_device_idx = random.choice(device_idx)
    else:
        evb_device_idx = device_idx

    evb_info['device_idx'] = evb_device_idx
    return evb_info


def ensure_dir_exists(directory, reset=True):
    """
    Creates local directories if they don't exist.
    """
    if not os.path.isdir(directory):
        create_dir(directory)
    elif reset:
        shutil.rmtree(directory)
        create_dir(directory)


def launch_process(name, function, daemon, *args, **kwargs):
    """
    launch process for TssWorkerManager
    """
    process = multiprocessing.Process(target=function,
                                      name=name,
                                      args=args,
                                      kwargs=kwargs)
    process.daemon = daemon
    process.start()
    log.info("launch process %s start.", process.pid)
    return process


def cpu_num():
    """

    :return:
    """
    return multiprocessing.cpu_count()


def create_dir(folder: str) -> bool:
    """
    create_dir
    """
    folder = os.path.realpath(folder)
    is_exists = os.path.exists(folder)
    if not is_exists:
        try:
            os.makedirs(folder, DIR_PERMISSION_750, exist_ok=True)
        except (OSError) as excep:
            log.err("An error happened when trying to create %s, error %s.", folder, repr(excep))
            raise excep
        finally:
            pass

    log.info("create_dir: %s: is_exists: %s.", str(folder), str(is_exists))
    return True


def get_reduce_axis_index(stage_op):
    """

    :param stage_op:
    :return:
    """
    # 从指定stage动态获取reduce_axis索引
    reduce_axis_var = []
    for i in stage_op.reduce_axis:
        reduce_axis_var.append(i.var)
    source_len = len(stage_op.body[0].source)
    # 对于Gemm这样的Reduce就处理不了
    try:
        data_axis_var = stage_op.body[0].source[source_len - 1].indices
    except AttributeError:
        log.dbg('stage: %s, body: %s, reduce_axis_var: %s', stage_op,
                stage_op.body, reduce_axis_var)
        data_axis_var = []
    reduce_axis_list = []
    for axis in reduce_axis_var:
        axis_num = 0
        for i in data_axis_var:
            if i.same_as(axis):
                reduce_axis_list.append(axis_num)
            axis_num += 1
    reduce_axis_list.sort()
    return reduce_axis_list


def gen_rl_schedule_key(input_info_list, output_info_list, sch_obj):
    """

    :param input_info_list:
    :param output_info_list:
    :param sch_obj:
    :return:
    """
    shape_dtype_list = []
    for tensor_info in input_info_list + output_info_list:
        shape_dtype_list.extend(
            [str(list(tensor_info.shape)), tensor_info.dtype])

    real_stages = list(sch_obj.stages)
    reduce_axis_str_list = []
    for stage in real_stages:
        if isinstance(stage.op, tvm.PlaceholderOp) \
                or not stage.op.reduce_axis:
            continue
        reduce_axis_list = get_reduce_axis_index(stage.op)
        reduce_axis_str = "_".join([str(x) for x in reduce_axis_list])
        reduce_axis_str_list.append(reduce_axis_str)

    rl_schedule_key = "_".join(shape_dtype_list).replace(" ", "")
    rl_schedule_key = rl_schedule_key.replace(",", "_").replace("[", "").replace("]", "")
    if reduce_axis_str_list:
        rl_schedule_key += "_" + "_r_".join(reduce_axis_str_list)
    return rl_schedule_key


def proc_single_best(best_py_path, tick, rl_schedule_dict):
    """

    :param best_py_path:
    :param tick:
    :param rl_schedule_dict:
    :return:
    """
    with open(best_py_path, 'r') as file_handler:
        best_py_content = file_handler.read()
    best_py_lines = best_py_content.split("\n")
    new_codes = []
    res_list = []
    rl_schedule_key = ""
    start_line_index = end_line_index = len(best_py_lines)
    for i, line in enumerate(best_py_lines):
        if ".output(0)" in line:
            start_line_index = i + 1
            res = line.split(" = ")[0].replace(" ", "")
            res_list.append(res)
            new_codes.append("    {res}_op = {res}.op".format(res=res))
        elif "# feature(without action):" in line:
            end_line_index = i
        elif "#rl_schedule_key: " in line:
            rl_schedule_key = line.split("#rl_schedule_key: ")[-1].strip()
        elif ".auto_schedule(" in line:
            # 忽略base
            return

        if start_line_index <= i < end_line_index:
            new_codes.append(line)

    func_name = "best_%s_sch" % rl_schedule_key
    new_codes.insert(
        0, "    print('rl offline, ===============%s enter!"
        "==============')" % rl_schedule_key)
    new_codes.insert(0, "def %s(%s):" % (func_name, ", ".join(res_list)))
    new_codes.append("    return sch")
    new_codes.append("\n")
    rl_schedule_dict[rl_schedule_key] = {
        "code": "\n".join(new_codes),
        "tick": tick,
        "evb": ""
    }


def gen_rl_schedule_py(best_py_dir, rl_schedule_path):
    """

    :param best_py_dir:
    :param rl_schedule_path:
    :return:
    """
    shape_dir_list = os.listdir(best_py_dir)
    ret = True
    rl_schedule_dict = {}
    for shape_item in shape_dir_list:
        shape_dir = os.path.join(best_py_dir, shape_item)
        best_py_list = glob.glob("best_*.py")
        # 优先找best schedule，不存在的话，再去run succ找最优的
        if best_py_list:
            py_file_path = best_py_list[0]
            tmp_tick = os.path.basename(py_file_path).split("@")
            tmp_tick = tmp_tick[0].split("_")[1]
            best_tick = int(tmp_tick)
        else:
            run_succ_path = os.path.join(shape_dir, "run_succ")
            if not os.path.exists(run_succ_path):
                log.warn("%s no exists!", run_succ_path)
                ret = False
                continue
            py_file_list = os.listdir(run_succ_path)
            # 只取耗时最低的那个py
            py_file_list = sorted(py_file_list,
                                  key=lambda x: int(x.split("_")[0]))
            py_file_path = os.path.join(run_succ_path, py_file_list[0])
            best_tick = int(py_file_list[0].split("_")[0])
        proc_single_best(py_file_path, best_tick, rl_schedule_dict)
    with os.fdopen(os.open(rl_schedule_path, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), "w") as file_handler:
        json.dump(rl_schedule_dict, file_handler, indent=4)
    log.dbg("rl_schedule_path is %s", rl_schedule_path)
    return ret


def option_prepare(flags: object, option: object) -> None:
    """
    :param flags:
    :param option:
    """
    for key, value in option.items():
        if key in flags:
            flag_type = flags[key].flag_type()
            try:
                flags[key].parse(value)
            except (LookupError, ValueError, TypeError) as exception:
                log.warn("%s must be %s in flags,while value is %s in option", key, flag_type, value)
                raise RuntimeError("option format fail! please check it!", str(exception))
            finally:
                pass


def upddata_workspace(flags: object, option: object) -> None:
    """
    :param flags:
    :param option:
    """
    workspace = option.get("WORKSPACE", config.WORKSPACE)
    time_stamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S_%f')
    flags.workspace = os.path.join(workspace,
        option.get("tune_workspace", "tune_workspace_" + time_stamp))
    workspace = option.get("WORKSPACE", config.WORKSPACE)
    # 新建目录
    ensure_dir_exists(flags.workspace, reset=False)


def update_flags(flags, option):
    """
    :param flags:
    :param option:
    """
    # option和flag重复时，优先使用option里的
    option_prepare(flags, option)

    if flags:
        if "workspace" in flags:
            upddata_workspace(flags, option)

        # evb_host上的workspace
        if not option.get("tss_workspace", None):
            option["tss_workspace"] = os.path.basename(flags.workspace)


def get_exec_cmd(cmd, ip_addr, usr, pwd, timeout=2):
    """

    :param cmd:
    :param ip_addr:
    :param usr:
    :param pwd:
    :param timeout:
    :return:
    """
    # 一般都是简短的命令 默认设置2s超时
    if timeout:
        cmd = "timeout %s " % timeout + cmd
    print_cmd = cmd
    if ip_addr != "localhost":
        print_cmd = "ssh ... " + cmd
        cmd = "sshpass -p %s ssh -o StrictHostKeyChecking=no %s@%s \"%s\"" % (
            pwd, usr, ip_addr, cmd)
        if timeout:
            #  给ssh加一秒时间
            cmd = "timeout %s " % (timeout + 1) + cmd
    log.dbg("get_exec_cmd:%s", print_cmd)
    return cmd


def get_disk_size(dir_path: str) -> int:
    """

    Parameters
    ----------
    dir_path

    Returns
    -------
    available disk size GB

    """
    stinfo = os.statvfs(dir_path)
    avail_disk_size = math.ceil(stinfo.f_bavail * stinfo.f_bsize / 1024 / 1024 / 1024)
    log.info('path: %s, available size: %sG.', dir_path, str(avail_disk_size))
    return avail_disk_size


def input_check(option, res_list):
    """

    :param option:
    :param res_list:
    :return:
    """
    if not isinstance(res_list, list):
        log.err("res_list must be a list")
        return False
    if option.get("expected_tick_list", []):
        if not isinstance(option["expected_tick_list"], list):
            log.err("expected_tick_list muse be a list!")
            return False
        if len(option["expected_tick_list"]) != len(res_list):
            log.err("expected_tick_list length muse be same with res_list!")
            return False

        new_list = []
        for idx, value in enumerate(option["expected_tick_list"]):
            try:
                new_list.append(int(value))
            except ValueError:
                log.err("expected_tick must be a number, while expected_tick_list[%s] is %s.", idx, value)
                return False
        option["expected_tick_list"] = new_list

    return True


def get_dtype_size(dtype):
    """
    :param dtype:
    :return:
    """
    if dtype in ["bool", "uint1"]:
        bit_size = 8
    else:
        digit_list = list(filter(str.isdigit, dtype))
        bit_size = int("".join(digit_list))
    return bit_size // 8


def get_last_slice_len(axis_len, factor, tail_list):
    """

    :param axis_len:
    :param factor:
    :param tail_list:
    :return:
    """
    tail_len = 1
    if tail_list:
        tail_len = functools_reduce(lambda x, y: x * y, tail_list)
    # 获取最后一块数据的大小
    last_slice_len = (axis_len % factor) * tail_len
    if last_slice_len == 0:
        last_slice_len = factor * tail_len
    return last_slice_len


def find_paths(graph, start, end, path):
    """

    :param graph:
    :param start:
    :param end:
    :param path:
    :return:
    """
    path = path + [start]
    if start == end:
        return [path]
    all_paths = []
    if start not in graph:
        return all_paths
    for node in graph[start]:
        all_paths.extend(find_paths(graph, node, end, path))
    return all_paths


def shape_to_list(tvm_shape):
    """
    :param tvm_shape:
    :return:
    """
    tmp = []
    for i in tvm_shape:
        tmp.append(i.value)
    return tmp


def func_timeout(func: object, args: object = None, kwargs: object = None,
                 timeout: object = None, context: object = None) -> object:
    """
    thread的方式执行func，超时抛出异常
    """
    if args is None:
        args = ()
    if kwargs is None:
        kwargs = {}
    func_thread = FuncTimeout(func, args, kwargs, context)
    func_thread.start()
    func_thread.join(timeout)
    if func_thread.is_alive():
        func_thread.stop()
        raise RuntimeError('%s timeout %ss' % (repr(func), timeout))
    if func_thread.exception is not None:
        # raise func_thread.exception 直接抛出这个异常会有pylint错误，
        # raising-bad-type / Raising NoneType while only classes or instances are allowed
        raise RuntimeError(str(func_thread.exception))
    return func_thread.result


def pid_exists(pid):
    """
    Check whether pid exists in the current process table.
    UNIX only.
    Possible error values are EINVAL, EPERM, ESRCH
    EINVAL:invalid argument
    ESRCH:No such process
    EPERM:operation not permitted
    """
    pid = int(pid)
    if pid <= 0:
        return False
    try:
        os.kill(pid, 0)
    except OSError as exc:
        if exc.errno == errno.EPERM:
            return True
        if exc.errno == errno.ESRCH:
            return False
        raise
    else:
        return True


def get_at_axis_list(stage_info, axis_num):
    """

    :param stage_info:
    :param axis_num:
    :return:
    """
    # 没有broadcast_groups，直接返回
    broadcast_groups = stage_info.get('broadcast_groups')
    if not broadcast_groups:
        return []

    # 获取reorder顺序
    broadcast_axis_reorder = stage_info.get('broadcast_axis_reorder', [])
    axis_reorder = sorted(set(range(axis_num)) - set(broadcast_axis_reorder))
    axis_reorder.extend(broadcast_axis_reorder)

    # 切分轴之前的轴
    choose_axis = stage_info.get('choose_axis', 0)
    choose_axis_index = axis_reorder.index(choose_axis)
    at_axis_list = axis_reorder[:choose_axis_index + 1]
    return at_axis_list
