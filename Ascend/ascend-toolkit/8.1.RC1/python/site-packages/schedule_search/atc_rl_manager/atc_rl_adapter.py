#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2021-2022. All rights reserved.

rl schedule search, tss
"""

import datetime
import json
import os
import subprocess

from tbe.common.platform.platform_info import get_soc_spec
from tbe.common.platform import CORE_NUM
from schedule_search import config
from schedule_search import log
from schedule_search import util
from schedule_search import tune_util
from schedule_search.log import LOGGING_INSTANCE
from schedule_search.soc_cfg import set_product_code
from schedule_search.util import OPEN_FILE_MODES_640
from schedule_search.util import WRITE_FILE_FLAGS

TUNE_FILE_CONTENT = """#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
import os
import pickle
import json

from tbe import tvm
from tbe.common.platform.platform_info import set_current_compile_soc_info
{set_cce_product}

from schedule_search.atc_rl_manager import atc_rl_search
from schedule_search import log
from schedule_search import tune_util

def rl_tune_func():
    try:
        sch_dump_list = {sch_dump_list}
        TUNE_OPTION = {tune_option}
        res_names_list = {res_names_list}
        op_config_list = {op_config_list}

        all_res_list = []
        for task_idx, sch_list in enumerate(sch_dump_list):
            res_list = []
            for i, sch_dump in enumerate(sch_list):
                sch = pickle.loads(sch_dump)
                op_outputs = res_names_list[task_idx][i]
                res = tune_util.get_res_by_output_name(sch, op_outputs)
                res_list.append(res)
            if res_list and "tik_tensor" not in op_config_list[task_idx]:
                res_list = res_list[0]
            all_res_list.append(res_list)

        ret, best_py_path_list, _ = \\
            atc_rl_search.{tune_type}(all_res_list, TUNE_OPTION, op_config_list)

        if not isinstance(best_py_path_list, list):
            return False

        tune_res_dict = {{}}
        tune_res_file_name = '{tune_res_file_name}'

        for i, best_py_path in enumerate(best_py_path_list):
            tune_res_dict[op_config_list[i]['kernel_name']] = best_py_path

        with open(tune_res_file_name, 'w') as outfile:
            json.dump(tune_res_dict, outfile, sort_keys=True)

        return ret
    except Exception as exp:
        log.err("RL exception occur: rl tune failed, error msg: %s.", repr(exp))
        return False

if __name__ == '__main__':
    # true = 0 = succ, false = 1 = fail
    exit(int(not rl_tune_func()))
"""


def online_tune_proc(
        tune_type: str,
        sch_dump_list: list,
        res_names_list: list,
        op_config_list: list,
        tune_workspace: dict = None) -> dict:
    """
    online_tune_proc
    :param tune_type:
    :param sch_dump_list:
    :param res_names_list:
    :param op_config_list:
    :param tune_workspace:
    :return:
    """
    LOGGING_INSTANCE.info("RL tune info: RL tune begin, tune_type: %s, tune_workspace: %s.", tune_type, tune_workspace)
    log.info("RL tune info: RL tune begin, tune_type: %s, tune_workspace: %s.", tune_type, tune_workspace)
    time_stamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S_%f')
    if tune_workspace is None:
        tune_workspace = os.path.join(config.WORKSPACE, tune_type + "_workspace_" + time_stamp)
        util.create_dir(tune_workspace)
    tune_py_path = os.path.join(tune_workspace, "%s_%s.py" % (tune_type, time_stamp))
    tune_res_file_name = tune_py_path.replace(".py", ".json")
    tune_timeout = tune_util.get_timeout() * len(sch_dump_list)
    tune_option = {
        "rl_tune": True,
        "need_valid": False,
        "timeout": tune_timeout,
        "tune_workspace": tune_workspace,
        "tss_workspace": os.path.basename(tune_workspace)
    }
    for op_config in op_config_list:
        op_config["core_num"] = get_soc_spec(CORE_NUM)

    with os.fdopen(os.open(tune_py_path, WRITE_FILE_FLAGS, OPEN_FILE_MODES_640), "w") as file_handler:
        file_handler.write(
            TUNE_FILE_CONTENT.format(set_cce_product=set_product_code(),
                                     sch_dump_list=str(sch_dump_list),
                                     res_names_list=str(res_names_list),
                                     op_config_list=str(op_config_list),
                                     tune_type=tune_type,
                                     tune_option=str(tune_option),
                                     tune_res_file_name=tune_res_file_name))
    LOGGING_INSTANCE.info("RL tune info: %s %s tasks by running %s , it takes about %s minutes.",
             tune_type, len(sch_dump_list), tune_py_path,
             "5-10" if tune_type == "infer" else max(1, int(tune_timeout) // 60))
    log.info("RL tune info: %s %s tasks by running %s , it takes about %s minutes.",
             tune_type, len(sch_dump_list), tune_py_path,
             "5-10" if tune_type == "infer" else max(1, int(tune_timeout) // 60))
    # 执行完删除，执行的超时时间比TUNE超时多半个小时
    p_tune = subprocess.Popen(['python3', tune_py_path], shell=False)
    try:
        output, _ = p_tune.communicate(timeout=int(tune_timeout) + 1800)
    except (subprocess.TimeoutExpired, KeyboardInterrupt, BrokenPipeError):
        p_tune.kill()
        output, _ = p_tune.communicate()
    finally:
        pass

    tune_res_dict = {}
    # 用生成py的方式执行，通过tune_res.json拿到best_py_path
    if os.path.exists(tune_res_file_name):
        log.info("RL tune info: get %s result from %s.", tune_type, tune_res_file_name)
        with open(tune_res_file_name, "r") as file_handler:
            tune_res_dict = json.load(file_handler)
    else:
        log.warn("RL tune info: %s not exists after running %s, output:%s.", tune_res_file_name, tune_py_path, output)
    log.info("RL tune info: RL tune end, tune_type: %s, tune_res_dict: %s.", tune_type, tune_res_dict)
    return tune_res_dict
