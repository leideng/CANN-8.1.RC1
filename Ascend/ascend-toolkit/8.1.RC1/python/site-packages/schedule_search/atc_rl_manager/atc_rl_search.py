#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
Copyright (c) Huawei Technologies Co., Ltd. 2021-2022. All rights reserved.

rl schedule search, tss
"""

import sys
import time
import multiprocessing
import math
from absl import flags

from schedule_search import log
from schedule_search.global_manager import MultiprocessManager
from schedule_search.backgroud.bg_main import bg_main
from schedule_search.log import LOGGING_INSTANCE
from schedule_search.controller import search_comm
from schedule_search.controller.mcts_search.mcts_searcher import mcts_search
from schedule_search.controller.mcts_search.mcts_searcher import mcts_search_valid


FLAGS = flags.FLAGS
# flags都是通过option的方式暴露给用户，不让用户直接指定flags，
# 所以这里不接受外部的flag参数，只做初始化赋值
FLAGS([sys.argv])


def search(res_list: list, option: dict, op_config_list: list = None) -> (bool, list, list):
    """
    RL搜索（demo用），无infer进程
    :param res_list: 算子输出tensor列,list of list
    :param option: 搜索的选项
    :param op_config_list: 每个算子独有的一些配置
    :return: bool, best_path_list, op_schedule_infos_list
    """
    if not isinstance(res_list, list):
        res_list = [res_list]

    # 剔出那些不进行调优的Case
    ignore_ops = get_ignore_ops(res_list, op_config_list)
    if None in res_list:
        raise Exception('One of the output tensor is None. Check the compute code.')
    if not res_list:
        return False, [], []

    # prepare
    ret, option_list = search_comm.pre_processing_proc(FLAGS, option, res_list, op_config_list)
    if ret is False:
        log.err("RL tune info: RL schedule search pre_processing failed.")
        return False, [""] * len(res_list), []

    op_schedule_infos_list, all_op_schedule_infos_list = search_comm.wrt_op_schedule_infos(res_list, option_list,
                                                                                           FLAGS, op_config_list)

    multiprocessing.current_process().daemon = False
    # search
    if not op_schedule_infos_list:
        return False, [], []

    # 起一个daemon进程处理定时任务
    guard_process = multiprocessing.Process(name='guard_process', target=bg_main,
                                            args=(op_schedule_infos_list, option, ignore_ops),
                                            daemon=True)
    guard_process.start()
    log.info("RL tune info: guard_process %s start.", guard_process.pid)
    # search process
    time_out_per_op = int(option_list[0]['timeout']) // len(op_schedule_infos_list)

    global_multiprocess_mgr = MultiprocessManager()
    try:
        global_multiprocess_mgr.init_shared_dict()
        for opidx, op_schedule_infos in enumerate(op_schedule_infos_list):
            LOGGING_INSTANCE.info("RL tune info: The %sth op %s start search with timeout %s seconds.",
                                  opidx + 1, option_list[opidx].get("kernel_name", None), time_out_per_op)
            log.info("RL tune info: The %sth op %s start search with timeout %s seconds.",
                     opidx + 1, option_list[opidx].get("kernel_name", None), time_out_per_op)
            global_multiprocess_mgr.clear_shared_dict()

            # start mcts search
            mcts_search(op_schedule_infos, time_out_per_op)

            LOGGING_INSTANCE.info("RL tune info: The %sth op %s search finish.",
                                  opidx + 1, option_list[opidx].get("kernel_name", None))
            log.info("RL tune info: The %sth op %s search finish.",
                     opidx + 1, option_list[opidx].get("kernel_name", None))
    finally:
        global_multiprocess_mgr.shutdown()

    # 本次搜索完毕，杀死bg_main
    guard_process.kill()
    guard_process.join()

    base_instead = option_list[0].get("base_instead", True)
    if option_list[0].get("rl_tune", False):
        base_instead = False
    ret, best_path_list = search_comm.post_processing_proc(all_op_schedule_infos_list, base_instead=base_instead)
    if not ret:
        return False, best_path_list, op_schedule_infos_list
    LOGGING_INSTANCE.info("RL tune info: RL schedule search finish succ!")
    log.info("RL tune info: RL schedule search finish succ!")
    return ret, best_path_list, op_schedule_infos_list


def _do_infer(op_schedule_infos_list: list, option_list: list, option: dict, ignore_ops: list) -> None:
    """
    do once infer
    """
    log.info("RL tune info: _do_infer begin, ignore_ops: %s, option_list: %s.", ignore_ops, option_list)
    mcts_search_valid(op_schedule_infos_list)

    # inference比较快，不用起进程，直接执行
    bg_main(op_schedule_infos_list,
            option,
            ignore_ops,
            bank_update_interval=0,
            run_once=True)
    log.info("RL tune info: _do_infer end, ignore_ops: %s, option_list: %s.", ignore_ops, option_list)


def infer(res_list: list, option: dict, op_config_list: list = None) -> (bool, list, list):
    """
    RL推理（demo用），无mcts_search进程
    :param res_list: 算子输出tensor列表
    :param option: 推理选项
    :param op_config_list: 每个算子独有的一些配置
    :return: bool, best_path_list, op_schedule_infos_list
    """
    log.info("RL tune info: RL schedule infer begin, res_list: %s, option: %s.", res_list, option)
    # 离线推理
    if not isinstance(res_list, list):
        res_list = [res_list]

    # 剔出那些不进行调优的Case
    ignore_ops = get_ignore_ops(res_list, op_config_list)
    if None in res_list:
        raise Exception('One of the output tensor is None. Check the compute code.')
    if not res_list:
        log.err("RL tune info: RL schedule infer failed, res_list is empty.")
        return False, [], []

    # 默认用auto_schedule作为Golden
    option["auto_schedule_golden"] = True
    ret, option_list = search_comm.pre_processing_proc(FLAGS, option, res_list,
                                                       op_config_list)
    if ret is False:
        log.err("RL tune info: RL schedule infer failed, because pre_processing_proc failed.")
        return False, [""] * len(res_list), []

    op_schedule_infos_list, all_op_schedule_infos_list = search_comm.wrt_op_schedule_infos(res_list, option_list,
                                                                                           FLAGS, op_config_list)

    if op_schedule_infos_list:
        # 预估耗时
        cost_predictor(op_schedule_infos_list)
        _do_infer(op_schedule_infos_list, option_list, option, ignore_ops)

    base_instead = option_list[0].get("base_instead", True)
    if option_list[0].get("rl_tune", False):
        base_instead = False
    ret, best_path_list = search_comm.post_processing_proc(all_op_schedule_infos_list, base_instead=base_instead)
    if not ret:
        log.err("RL tune info: RL schedule infer failed, because post_processing_proc failed.")
        return False, best_path_list, op_schedule_infos_list
    LOGGING_INSTANCE.info("RL tune info: RL schedule infer finish succ.")
    log.info("RL tune info: RL schedule infer finish succ.")
    return True, best_path_list, op_schedule_infos_list


def cost_predictor(op_schedule_infos_list: list) -> bool:
    """
    预估耗时
    :param op_schedule_infos_list: 算子调度信息
    :return:
    """
    if not op_schedule_infos_list:
        log.warn("op_schedule_infos_list is empty.")
        return False

    try:
        linearity = 1.0 / math.pow(FLAGS.cpu_process_num, 0.25)
    except ZeroDivisionError:
        log.warn("RL exception occur: cost predictor raise exception.")
        return False
    finally:
        pass

    for op_schedule_infos in op_schedule_infos_list:
        complexity = op_schedule_infos[0].complexity
        cost = int((240 + complexity * 15) / linearity)
        layer_name = op_schedule_infos[0].ori_op_name
        log.info("RL tune info: %s will cost about %ss.", layer_name, cost)
    return True


def get_ignore_ops(res_list: list, op_config_list: list) -> list:
    """
    剔除不进行调优的算子
    :param res_list: 算子输出tensor列表
    :param op_config_list: 每个算子独有的一些配置
    :return: ignore_ops
    """
    if not op_config_list or len(op_config_list) != len(res_list):
        return []

    ignore_indices = []
    ignore_ops = []
    for idx, op_cfg in enumerate(op_config_list):
        if op_cfg.get('ignore_reason'):
            ignore_indices.append(idx)
            tune_result_key = op_cfg.get('tune_result_key')
            if not tune_result_key:
                tune_result_key = op_cfg.get('ori_op_name')
            if not tune_result_key:
                tune_result_key = op_cfg.get('kernel_name', 'default_op_%s' % time.time())
            ignore_ops.append({'tune_result_key': tune_result_key,
                               'ignore_reason': op_cfg['ignore_reason'],
                               'hit_bank': op_cfg.get('hit_bank', False)})

    for idx in reversed(ignore_indices):
        res_list.pop(idx)
        op_config_list.pop(idx)
    return ignore_ops
