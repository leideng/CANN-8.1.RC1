#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -------------------------------------------------------------------
# Copyright (c) 2024 Huawei Technologies Co., Ltd.
# This file is a part of the CANN Open Software.
# Licensed under CANN Open Software License Agreement Version 1.0 (the "License").
# Please refer to the License for details. You may not use this file except in compliance with the License.
# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
# See LICENSE in the root of the software repository for the full text of the License.
# ======================================================================================================================

from typing import Union, List, Tuple
import numpy as np
from llm_datadist.utils import utils
from llm_datadist import data_type, metadef_wrapper, llm_wrapper
from llm_datadist.status import handle_llm_status
from llm_datadist.data_type import _dwrapper_dtype_to_python_dtype

llm_wrapper.init_datatype_manager({metadef_wrapper.DT_FLOAT: np.array([], np.float32),
                                   metadef_wrapper.DT_FLOAT16: np.array([], np.float16),
                                   metadef_wrapper.DT_BF16: np.array([], np.float16),
                                   metadef_wrapper.DT_INT8: np.array([], np.int8),
                                   metadef_wrapper.DT_INT16: np.array([], np.int16),
                                   metadef_wrapper.DT_UINT16: np.array([], np.uint16),
                                   metadef_wrapper.DT_UINT8: np.array([], np.uint8),
                                   metadef_wrapper.DT_INT32: np.array([], np.int32),
                                   metadef_wrapper.DT_INT64: np.array([], np.int64),
                                   metadef_wrapper.DT_UINT32: np.array([], np.uint32),
                                   metadef_wrapper.DT_UINT64: np.array([], np.uint64),
                                   metadef_wrapper.DT_BOOL: np.array([], np.bool_),
                                   metadef_wrapper.DT_DOUBLE: np.array([], np.double)
                                   })


class TensorDesc(object):
    def __init__(self, dtype: data_type.DataType, shape: Union[List[int], Tuple[int]]):
        """
        初始化
        Args:
            dtype: 数据类型
            shape: 数据维度信息
        """
        utils.check_isinstance("dtype", dtype, data_type.DataType)
        utils.check_isinstance("shape", shape, [list, tuple], int)
        self._dtype = dtype
        self._shape = list(shape)

    @property
    def dtype(self):
        return self._dtype

    @property
    def shape(self):
        return self._shape

    def __str__(self):
        return f"TensorDesc(dtype={str(self.dtype)}, shape={str(self.shape)})"


class Tensor(object):
    def __init__(self, data, tensor_desc: TensorDesc = None):
        """
        初始化
        Args:
            data: 数据
            tensor_desc: 描述信息
        """
        utils.check_isinstance("data", data, [np.ndarray, Tensor, int])
        utils.check_isinstance("tensor_desc", tensor_desc, TensorDesc)
        self._tensor_id = 0
        if isinstance(data, Tensor):
            self._tensor_desc = data._tensor_desc
            self._tensor_id = llm_wrapper.clone_tensor(data._tensor_id)
        elif isinstance(data, int):
            self._tensor_desc = tensor_desc
            self._tensor_id = data
        else:
            self._init_by_ndarray(data, tensor_desc)

    def __del__(self):
        # 保底释放kv cache, 但更推荐主动通过调用kv_cache_manager.deallocate_cache来释放kv cache，而不应该遗留到此处自动释放
        if self._tensor_id != 0:
            llm_wrapper.destroy_tensor(self._tensor_id)

    def __str__(self):
        return f"Tensor({self.numpy(True if self._is_inner_dtype_str() else False)},tensor_desc={self._tensor_desc})"

    @staticmethod
    def from_tensor_tuple(tensor_tuple: Tuple[int, int, List[int]]):
        tensor_desc = TensorDesc(_dwrapper_dtype_to_python_dtype[tensor_tuple[1]], tensor_tuple[2])
        return Tensor(tensor_tuple[0], tensor_desc)

    def _init_by_ndarray(self, data: np.ndarray, tensor_desc: TensorDesc = None):
        if tensor_desc:
            if list(data.shape) != tensor_desc.shape:
                raise RuntimeError(
                    f"The shape of data:{data.shape} is not same as tensor_desc shape:{tensor_desc.shape}")
            desc_np_dtype = data_type.dtype_to_np_dtype.get(tensor_desc.dtype)
            if data.dtype != desc_np_dtype:
                raise RuntimeError(
                    f"The dtype of data:{data.dtype} is not same as tensor_desc dtype:{tensor_desc.dtype}")
        else:
            if data.dtype not in data_type.valid_np_dtypes and not self._is_origin_dtype_str(data.dtype):
                raise RuntimeError(
                    f"The dtype of data:{data.dtype} is not valid, only support {data_type.valid_np_dtypes}")
        if tensor_desc:
            self._tensor_desc = tensor_desc
        elif self._is_origin_dtype_str(data.dtype):
            self._tensor_desc = TensorDesc(data_type.DataType.DT_STRING, list(data.shape))
        else:
            self._tensor_desc = TensorDesc(data_type.np_dtype_to_dtype[data.dtype], list(data.shape))
        if self._is_origin_dtype_str(data.dtype):
            data = self._convert_raw_str_data(data)
        self._tensor_id = llm_wrapper.build_tensor(
            data,
            data_type.python_dtype_2_dwrapper_dtype.get(self._tensor_desc.dtype),
            list(self._tensor_desc.shape))

    def _is_origin_dtype_str(self, dtype):
        return np.issubdtype(dtype, np.str_) or np.issubdtype(dtype, np.string_)

    def _is_inner_dtype_str(self):
        return self._tensor_desc is not None and self._tensor_desc.dtype == data_type.DataType.DT_STRING

    def _convert_raw_str_data(self, data):
        format_data = data.astype(np.string_)
        end_point = '\0'.encode('ascii', errors='ignore')
        new_data = np.char.add(format_data, end_point)
        return new_data

    def numpy(self, copy=False):
        """
        获取数据的numpy表示
        Args:
            copy: 是否复制

        Returns:
            数据的numpy表示
        """
        utils.check_isinstance("copy", copy, bool)
        if self._is_inner_dtype_str():
            if not copy:
                raise RuntimeError("String tensor only support when param copy is True.")
            return np.array(llm_wrapper.get_string_tensor(self._tensor_id)).reshape(self._tensor_desc.shape)
        ret, tensor = llm_wrapper.tensor_get_buffer(self._tensor_id)
        handle_llm_status(ret, 'Tensor.numpy', 'Failed to get tensor buffer')
        if self._tensor_desc.dtype == data_type.DataType.DT_BF16:
            return (tensor.view(np.uint16).astype(np.uint32) << 16).view(np.float32)
        ret = np.array(tensor, copy=copy)
        return ret
