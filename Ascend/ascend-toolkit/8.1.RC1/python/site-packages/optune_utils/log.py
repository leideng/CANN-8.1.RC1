#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

Define the optune log
"""
import inspect
import logging
import traceback
import os
import sys

FILE_PATH = os.path.dirname(os.path.realpath(__file__))
LOG_DEFAULT_LEVEL = logging.INFO
OPAT = "OPAT"

RUN_LOG_MASK = 0x01000000

IS_USE_SLOG = True
try:
    from te.utils.AscendLog import AscendLog
    S_LOGGER = AscendLog()
except ImportError:
    IS_USE_SLOG = False

    GLOBAL_LOG_ID = "OPTUNE_LOG"
    LOGGER = logging.getLogger(GLOBAL_LOG_ID)
    LOGGER.propagate = 0
    LOGGER.setLevel(LOG_DEFAULT_LEVEL)

    STREAM_HANDLER = logging.StreamHandler(stream=sys.stdout)
    STREAM_HANDLER.setLevel(LOG_DEFAULT_LEVEL)
    LOG_FORMAT = "[%(levelname)s][%(asctime)s]%(message)s"
    STREAM_HANDLER.setFormatter(logging.Formatter(LOG_FORMAT))
    LOGGER.addHandler(STREAM_HANDLER)
finally:
    pass


def get_log_msg(log_msg: str, *log_paras: tuple) -> str:
    """
    get log msg
    """
    line_no = inspect.currentframe().f_back.f_back.f_lineno
    co_filename = inspect.currentframe().f_back.f_back.f_code.co_filename
    filename = os.path.relpath(co_filename, FILE_PATH)
    log_str = '[%s:%d][%s] ' % (filename, line_no, OPAT)
    log_all_msg = log_str + log_msg % log_paras
    return log_all_msg


def info(log_msg: str, *log_paras: tuple) -> None:
    """
    info log
    :param log_msg:
    :param log_paras:
    """
    log_all_msg = get_log_msg(log_msg, *log_paras)

    if IS_USE_SLOG:
        S_LOGGER.info(S_LOGGER.module.tune, log_all_msg)
    else:
        LOGGER.info(log_all_msg)


def debug(log_msg: str, *log_paras: tuple) -> None:
    """
    debug log
    :param log_msg:
    :param log_paras:
    """
    log_all_msg = get_log_msg(log_msg, *log_paras)

    if IS_USE_SLOG:
        S_LOGGER.debug(S_LOGGER.module.tune, log_all_msg)
    else:
        LOGGER.debug(log_all_msg)


def warn(log_msg: str, *log_paras: tuple) -> None:
    """
    warning log
    :param log_msg:
    :param log_paras:
    """
    log_all_msg = get_log_msg(log_msg, *log_paras)

    if IS_USE_SLOG:
        S_LOGGER.warn(S_LOGGER.module.tune, log_all_msg)
    else:
        LOGGER.warning(log_all_msg)


def error(log_msg: str, *log_paras: tuple) -> None:
    """
    error log
    :param log_msg:
    :param log_paras:
    """
    log_all_msg = get_log_msg(log_msg, *log_paras)

    if IS_USE_SLOG:
        S_LOGGER.error(S_LOGGER.module.tune, log_all_msg)
    else:
        LOGGER.error(log_all_msg)


def event(log_msg: str, *log_paras: tuple) -> None:
    """
    event log
    :param log_msg:
    :param log_paras:
    """
    if not IS_USE_SLOG:
        return
    log_all_msg = get_log_msg(log_msg, *log_paras)

    S_LOGGER.info((S_LOGGER.module.tune | RUN_LOG_MASK), log_all_msg)


def get_py_exception_dict(etype: object, value: object, tback: object) -> dict:
    """
    return python exception dict, calling from C for error log uploading
    """
    _ = traceback.format_exception(etype, value, tback)
    err_msg = value.args
    err_dict = {}
    if isinstance(err_msg, tuple) and err_msg[0] and isinstance(err_msg[0], dict):
        for dict_key, dict_value in err_msg[0].items():
            err_dict[dict_key] = str(dict_value)
        return err_dict
    if isinstance(err_msg, tuple):
        message_list = []
        for tuple_element in err_msg:
            if not isinstance(tuple_element, str):
                message_list.append(str(tuple_element))
            else:
                message_list.append(tuple_element)
        err_dict['errCode'] = 'E90000'
        err_dict['message'] = "".join(message_list)
        err_dict['traceback'] = "".join(traceback.format_tb(tback))
        return err_dict
    return err_dict


def get_py_exception_str(etype: object, value: object, tback: object, eprint: bool = False) -> list:
    """
    return python exception string, calling from C for error log printing
    """
    exc_list = traceback.format_exception(etype, value, tback)
    msg_list = []
    for item in exc_list:
        for msg in item.split("\n"):
            msg_list.append(msg)

    if eprint:
        traceback.print_exception(etype, value, tback)

    return msg_list
