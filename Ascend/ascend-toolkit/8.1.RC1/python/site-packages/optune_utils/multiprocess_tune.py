#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

Define the multiprocess tune class
"""
import os
import sys
import time
import copy
import errno
import signal
import threading
import types
import importlib
import multiprocessing
from typing import List
from typing import Dict
from collections import namedtuple

from te_fusion.compile_task_manager import sync_op_tune_params
from te_fusion.parallel_compilation import compile_op
import tbe.common.context.op_context as op_context
from tbe.common.context import get_context
from tbe.common.platform import set_current_compile_soc_info
from tbe.common.tiling.tiling_api import reset_repository
from auto_search.auto_search import auto_search
from auto_tune.auto_tune_main import auto_tune_compile
from auto_tune.util_atc import INVALID_COST_TIME
from auto_tune.common_module.common_util import calc_costtime_upperbound
from auto_tune.common_module.common_util import DEFAULT_OM_RUN_THRESHOLD
from auto_tune.impl_tune_main import impl_tune_main
from auto_tune.format_tune.format_tune_main import format_tune_main
from schedule_search.rl_tune_om import rl_tune_om
from tik_tune.tik_tune_main import tik_tune_main
from tik_tune.tik_tune_space_parser import get_tik_tune_space
from optune_utils.global_manager import GlobalManager
from optune_utils.report_module.progress_manager import TuneProgressManager
from optune_utils.report_module.progress_manager import GA_MEANINGLESS_ROUND
from optune_utils.report_module.tune_report_manager import TuneResReportManager

from optune_utils import log

TUNE_MODE = ("GA", "RL", "TIK", "AS", "FORMAT")
TIME_SLEEP = 0.1
CNT_MAX = 100
AOE_MALLOC_ERROR_CODE = [3001, 245000]
QUERY_NOT_EXIST = 642
NOINTEGRATE_SUFFIX = "_nointegrate"
# high_perf switch
HIGH_PERF_ON = "on"
ImplTaskParams = namedtuple("ImplTaskParams", ["impl_cbkeys", "dynamic_and_impl", "impl_res_list",
    "option", "index", "op_arg"])


def check_need_integrate(task_param: dict, build_run_query_res: tuple) -> bool:
    """
    check if task need integrate
    """
    if isinstance(task_param, dict) and "need_integrate" in task_param:
        return int(build_run_query_res[1]) in AOE_MALLOC_ERROR_CODE and task_param["need_integrate"]
    return False


class ReleaseCompileOpThread(threading.Thread):
    """
    ReleaseCompileOpThread
    """
    def __init__(self, global_mgr: GlobalManager, opat_utils: types.ModuleType = None) -> None:
        super(ReleaseCompileOpThread, self).__init__()
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.opat_utils = opat_utils

    def run(self) -> None:
        """
        run ReleaseCompileOpThread
        :return:
        """
        current_thread = None
        if self.opat_utils:
            current_thread = self.opat_utils.get_thread_id()
        log.event("[Tid:%s]ReleaseCompileOpThread Entry!" % current_thread)
        while not self.event.is_set():
            while not self.global_mgr.release_compile_q.empty():
                del_item = self.global_mgr.release_compile_q.get()
                log.debug("COMPILE_OP_RESULT_D to del %s" % (del_item))
                del self.global_mgr.compile_result_d[del_item]
            time.sleep(TIME_SLEEP)

        log.event("[Tid:%s]ReleaseCompileOpThread event set, stop run!" % current_thread)

    def stop(self) -> None:
        """
        stop ReleaseCompileOpThread
        :return:
        """
        while True:
            if self.global_mgr.release_compile_q.empty():
                break
        log.info("ReleaseCompileOpThread set event to stop compile_thread.")
        self.event.set()
        self.join()
        log.info("ReleaseCompileOpThread stop compile_thread succ!")


class ReleaseTikTuneSpaceThread(threading.Thread):
    """
    ReleaseTikTuneSpaceThread
    """
    def __init__(self, global_mgr: GlobalManager, opat_utils: types.ModuleType = None) -> None:
        super(ReleaseTikTuneSpaceThread, self).__init__()
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.opat_utils = opat_utils

    def run(self) -> None:
        """
        run ReleaseTikTuneSpaceThread
        :return:
        """
        current_thread = None
        if self.opat_utils:
            current_thread = self.opat_utils.get_thread_id()
        log.event("[Tid:%s]ReleaseTikTuneSpaceThread Entry!" % current_thread)
        while not self.event.is_set():
            while not self.global_mgr.release_tik_tune_space_q.empty():
                del_item = self.global_mgr.release_tik_tune_space_q.get()
                log.debug("COMPILE_OP_RESULT_D to del %s" % (del_item))
                del self.global_mgr.tik_tune_space_result_d[del_item]
            time.sleep(TIME_SLEEP)

        log.event("[Tid:%s]ReleaseTikTuneSpaceThread event set, stop run!" % current_thread)

    def stop(self) -> None:
        """
        stop ReleaseTikTuneSpaceThread
        :return:
        """
        while True:
            if self.global_mgr.release_tik_tune_space_q.empty():
                break
        log.info("ReleaseTikTuneSpaceThread set event to stop ReleaseTikTuneSpaceThread.")
        self.event.set()
        self.join()
        log.info("ReleaseTikTuneSpaceThread stop ReleaseTikTuneSpaceThread succ!")


class ReleaseBuildRunAsync(threading.Thread):
    """
    ReleaseBuildRunAsync
    """
    def __init__(self, global_mgr: GlobalManager, opat_utils: types.ModuleType = None) -> None:
        super(ReleaseBuildRunAsync, self).__init__()
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.opat_utils = opat_utils

    def run(self) -> None:
        """
        run ReleaseBuildRunAsync
        :return:
        """
        current_thread = None
        if self.opat_utils:
            current_thread = self.opat_utils.get_thread_id()
        log.event("[Tid:%s]ReleaseBuildRunAsync Entry!" % current_thread)
        while not self.event.is_set():
            while not self.global_mgr.release_tune_q.empty():
                del_item = self.global_mgr.release_tune_q.get()
                log.debug("TUNE_RESULT_D del %s" % (del_item))
                del self.global_mgr.tune_result_d[del_item]
            time.sleep(TIME_SLEEP)

        log.event("[Tid:%s]ReleaseBuildRunAsync event set, stop run!" % current_thread)

    def stop(self) -> None:
        """
        stop ReleaseBuildRunAsync
        :return:
        """
        while True:
            if self.global_mgr.release_tune_q.empty():
                break
        log.info("ReleaseBuildRunAsync set event to stop compile_thread.")
        self.event.set()
        self.join()
        log.info("ReleaseBuildRunAsync stop compile_thread succ!")


class QueryCompileOpThread(threading.Thread):
    """
    QueryCompileOpThread
    """
    def __init__(self, global_mgr: GlobalManager, opat_utils: types.ModuleType = None) -> None:
        super(QueryCompileOpThread, self).__init__()
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.opat_utils = opat_utils

    def run(self) -> None:
        """
        run QueryCompileOpThread
        :return:
        """
        current_thread = None
        if self.opat_utils:
            current_thread = self.opat_utils.get_thread_id()
        log.event("[Tid:%s]QueryCompileOpThread Entry!" % current_thread)
        while not self.event.is_set():
            if not self.global_mgr.parallel_compile_res_d:
                time.sleep(TIME_SLEEP)
                continue
            for item in list(self.global_mgr.parallel_compile_res_d.keys()):
                compile_res = self.global_mgr.parallel_compile_res_d[item]
                if compile_res.get():
                    self.global_mgr.compile_result_d[item] = compile_res.get()
                    del self.global_mgr.parallel_compile_res_d[item]
                    log.info("Get compile res from parallel_compile_res_d, item: %s" % (str(item)))

        log.event("[Tid:%s]QueryCompileOpThread event set, stop run!" % current_thread)

    def stop(self) -> None:
        """
        stop QueryCompileOpThread
        :return:
        """
        log.info("QueryCompileOpThread set event to stop query_compile_thread.")
        self.event.set()
        self.join()
        log.info("QueryCompileOpThread stop query_compile_thread succ!")


class CompileOpThread(threading.Thread):
    """
    CompileOpThread
    """
    def __init__(self, global_mgr: GlobalManager, opat_utils: types.ModuleType = None) -> None:
        super(CompileOpThread, self).__init__()
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.opat_utils = opat_utils

    def run(self) -> None:
        """
        run CompileOpThread
        :return:
        """
        current_thread = None
        if self.opat_utils:
            current_thread = self.opat_utils.get_thread_id()
        log.event("[Tid:%s]CompileOpThread Entry!" % current_thread)
        while not self.event.is_set():
            if self.global_mgr.compile_task_q.empty():
                time.sleep(TIME_SLEEP)
                continue
            task = self.global_mgr.compile_task_q.get()
            log.info("GET COMPILE_OP_TASK_Q:%s" % (str(task.keys())))
            for item in task:
                compile_res = compile_op(task[item]["json_str"], task[item]["pre_and_post"])
                log.info("finish COMPILE_OP_TASK_Q:%s" % (str(item)))
                self.global_mgr.parallel_compile_res_d[item] = compile_res

            log.info("leave COMPILE_OP_TASK_Q %s" % (str(task.keys())))

        log.event("[Tid:%s]CompileOpThread event set, stop run!" % current_thread)

    def stop(self) -> None:
        """
        stop CompileOpThread
        :return:
        """
        log.info("CompileOpThread set event to stop compile_thread.")
        self.event.set()
        self.join()
        log.info("CompileOpThread stop compile_thread succ!")


class TikTuneSpaceThread(threading.Thread):
    """
    TikTuneSpaceThread
    """
    def __init__(self, global_mgr: GlobalManager, opat_utils: types.ModuleType = None) -> None:
        super(TikTuneSpaceThread, self).__init__()
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.opat_utils = opat_utils

    def run(self) -> None:
        """
        run TikTuneSpaceThread
        :return:
        """
        current_thread = None
        if self.opat_utils:
            current_thread = self.opat_utils.get_thread_id()
        log.event("[Tid:%s]TikTuneSpaceThread Entry!" % current_thread)
        while not self.event.is_set():
            if self.global_mgr.tik_tune_space_task_q.empty():
                time.sleep(TIME_SLEEP)
                continue

            task = self.global_mgr.tik_tune_space_task_q.get()
            log.debug("GET TikTuneSpaceThread:%s" % (str(task)))
            for item in task:
                tune_space = get_tik_tune_space(task[item])
                log.debug("finish TikTuneSpaceThread res:%s" % (str(tune_space)))
                self.global_mgr.tik_tune_space_result_d[item] = tune_space
            log.debug("leave TikTuneSpace_TASK_Q %s" % (str(task)))

        log.event("[Tid:%s]TikTuneSpaceThread event set, stop run!" % current_thread)

    def stop(self) -> None:
        """
        stop TikTuneSpaceThread
        :return:
        """
        log.info("TikTuneSpaceThread set event to stop TikTuneSpaceThread.")
        self.event.set()
        self.join()
        log.info("TikTuneSpaceThread stop TikTuneSpaceThread succ!")


class TimerThread(threading.Thread):
    """
    TimerThread
    """
    def __init__(self, global_mgr: GlobalManager, opat_utils: types.ModuleType = None) -> None:
        super(TimerThread, self).__init__()
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.opat_utils = opat_utils

    def run(self) -> None:
        """
        run TimerThread
        :return:
        """
        current_thread = self.opat_utils.get_thread_id()
        log.event("[Tid:%s]TimerThread Entry!" % current_thread)
        curr_pid = os.getpid()
        while not self.event.is_set():
            if self.global_mgr.timer_q.empty():
                time.sleep(TIME_SLEEP)
                continue

            timer_task = self.global_mgr.timer_q.get()
            if timer_task[0] == "start":
                self.opat_utils.start_event(str(timer_task[2]), str(timer_task[1]), str(curr_pid))
            elif timer_task[0] == "stop":
                self.opat_utils.stop_event(str(timer_task[2]), str(timer_task[1]), str(curr_pid))

        log.event("[Tid:%s]TimerThread event set, stop run!" % current_thread)

    def stop(self) -> None:
        """
        stop TimerThread
        :return:
        """
        log.info("TimerThread set event to stop timer_thread.")
        self.event.set()
        self.join()
        log.info("TimerThread stop timer_thread succ!")


class BuildRunAsyncPoll(threading.Thread):
    """
    BuildRunAsyncPoll
    """
    def __init__(self,
                 global_mgr: GlobalManager, opat_utils: types.ModuleType = None,
                 callback_query: str = "CompileAndExecuteTools.CompileAndExecuteAsyncQuery",
                 callback_get: str = "CompileAndExecuteTools.CompileAndExecuteAsyncGet") -> None:
        super(BuildRunAsyncPoll, self).__init__()
        query_module, query_func = callback_query.split(".")
        self.build_run_query = getattr(importlib.import_module(query_module), query_func)
        get_res_module, get_res_func = callback_get.split(".")
        self.build_run_get_res = getattr(importlib.import_module(get_res_module), get_res_func)
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.task_mgr = {}
        self.sort_out_thread = {}
        self.opat_utils = opat_utils
        self.cb_key_all_finished = {}
        self.cb_key_task_clean_q = self.global_mgr.cb_key_task_clean_q
        self.cb_key_clean_res_d = self.global_mgr.cb_key_clean_res_d
        self.cycle_cnt = 0

    def deal_with_query_res(self, task_cb_key: str, build_run_query_res: tuple) -> None:
        """
        deal with query res
        """
        task_param = self.global_mgr.cur_tune_task_d.pop(task_cb_key, None)
        if int(build_run_query_res[1]) == QUERY_NOT_EXIST:
            log.warn("build run query res is not exit: task_cb_key[%s] resource_cb_key [%s]." % (
                str(task_cb_key), str(self.task_mgr.get(task_cb_key))))
            return
        if check_need_integrate(task_param, build_run_query_res):
            task_param["need_integrate"] = False
            tune_task = {}
            task_cb_key_copy = task_cb_key + NOINTEGRATE_SUFFIX
            tune_task[task_cb_key_copy] = copy.deepcopy(task_param)
            log.info("BuildRunAsyncPoll[%s] roll back the fusion model to single operator model!" % str(task_cb_key))
            self.global_mgr.tune_task_q.put(tune_task)
        else:
            buildrun_res = self.build_run_get_res(task_cb_key, self.task_mgr.get(task_cb_key))
            if int(build_run_query_res[1]) in AOE_MALLOC_ERROR_CODE:
                for res in buildrun_res:
                    res["totalCostTime"] = INVALID_COST_TIME
            task_cb_key_ori = task_cb_key.split(NOINTEGRATE_SUFFIX)[0]
            log.info("BuildRunAsyncPoll task_cb_key[%s] resource_cb_key [%s] success!" % (
                str(task_cb_key), str(self.task_mgr.get(task_cb_key))))
            self.global_mgr.tune_result_d[task_cb_key_ori] = buildrun_res

    def update_build_run_async_tasks(self, waiting_thread: dict) -> None:
        """
        update build_run tasks
        """
        finished_item = []
        for task_cb_key in self.task_mgr:
            resource_cb_key = self.task_mgr[task_cb_key]
            build_run_query_res = self.build_run_query(task_cb_key, resource_cb_key)
            if self.cycle_cnt >= CNT_MAX:
                log.info(
                    "Build run query[cb_key:%s][cb_struct_key:%s]" % (str(task_cb_key), self.task_mgr[task_cb_key]))
            if build_run_query_res[0]:
                self.deal_with_query_res(task_cb_key, build_run_query_res)
                finished_item.append(task_cb_key)
                continue
            for thread_id in self.sort_out_thread:
                if self.task_mgr[task_cb_key] in self.sort_out_thread[thread_id]:
                    if self.cycle_cnt >= CNT_MAX:
                        log.info(
                            "Waiting for the task[%s][%s] to end!" % (str(task_cb_key), self.task_mgr[task_cb_key]))
                    waiting_thread[thread_id] = False
            if resource_cb_key in self.cb_key_all_finished:
                self.cb_key_all_finished[resource_cb_key] = False

        keys_to_del = list()
        for item in self.cb_key_all_finished.keys():
            if self.cb_key_all_finished[item]:
                log.event("BuildRunAsyncPoll cb_key[%s] all finished!" % str(item))
                self.cb_key_clean_res_d[item] = True
                keys_to_del.append(item)
        for item in keys_to_del:
            del self.cb_key_all_finished[item]

        for item in finished_item:
            del self.task_mgr[item]

        for thread_id in waiting_thread:
            if waiting_thread[thread_id]:
                for item in self.sort_out_thread[thread_id]:
                    log.event("BuildRunAsyncPoll all del request[%s] has ready: %s" % (str(thread_id), str(item)))
                self.global_mgr.finish_sort_out_q.put(thread_id)
                del self.sort_out_thread[thread_id]
        self.cycle_cnt += 1
        if self.cycle_cnt > CNT_MAX:
            self.cycle_cnt = 0

    def run(self) -> None:
        """
        run BuildRunAsyncPoll
        :return:
        """
        current_thread = None
        if self.opat_utils:
            current_thread = self.opat_utils.get_thread_id()
        log.event("[Tid:%s]BuildRunAsyncPoll Entry!" % current_thread)
        while not self.event.is_set():
            while not self.global_mgr.buildrun_task_q.empty():
                task_cb_key, resource_cb_key = self.global_mgr.buildrun_task_q.get()
                self.task_mgr[task_cb_key] = resource_cb_key

            while not self.global_mgr.wait_sort_out_finish_q.empty():
                thread_id, sort_out = self.global_mgr.wait_sort_out_finish_q.get()
                self.sort_out_thread[thread_id] = sort_out
            waiting_thread = {}
            for thread_id in self.sort_out_thread:
                waiting_thread[thread_id] = True

            while not self.cb_key_task_clean_q.empty():
                self.cb_key_all_finished[self.cb_key_task_clean_q.get()] = True

            for item in self.cb_key_all_finished:
                self.cb_key_all_finished[item] = True
            self.update_build_run_async_tasks(waiting_thread)

            time.sleep(TIME_SLEEP)

        log.event("[Tid:%s]BuildRunAsyncPoll event set, stop run!" % current_thread)

    def stop(self) -> None:
        """
        stop BuildRunAsyncPoll
        :return:
        """
        log.info("BuildRunAsyncPoll set event to stop cb_thread.")
        self.event.set()
        self.join()
        log.info("BuildRunAsyncPoll stop cb_thread succ!")


class BuildRunAsync(threading.Thread):
    """
    BuildRunAsync
    """
    def __init__(self, global_mgr: GlobalManager, opat_utils: types.ModuleType = None,
                 callback_str: str = "CompileAndExecuteTools.CompileAndExecuteAsync") -> None:
        super(BuildRunAsync, self).__init__()
        module_name, func_name = callback_str.split(".")
        self.run_and_excute = getattr(importlib.import_module(module_name), func_name)
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.opat_utils = opat_utils

    def update_build_run_tasks(self, sort_out: List[str]) -> None:
        """
        update build_run tasks
        """
        task_list = []
        if sort_out:
            while not self.global_mgr.tune_task_q.empty():
                task_list.append(self.global_mgr.tune_task_q.get())
                log.debug("GET TUNE_TASK_Q %s" % (str(task_list[-1])))
        else:
            task_list = [self.global_mgr.tune_task_q.get()]
            log.debug("GET TUNE_TASK_Q %s" % (str(task_list[-1])))
        for task in task_list:
            for task_cb_key in task:
                self.global_mgr.cur_tune_task_d[task_cb_key] = {"strategy_list": task[task_cb_key]["strategy_list"],
                                                        "cb_struct_key": task[task_cb_key]["cb_struct_key"],
                                                        "need_integrate": task[task_cb_key]["need_integrate"],
                                                        "tune_mode": task[task_cb_key].get("tune_mode", "NONE"),
                                                        "costtime_baseline": task[task_cb_key]["costtime_baseline"],
                                                        "cmp_style": task[task_cb_key].get("cmp_style", 0),
                                                        "cmp_scope": task[task_cb_key].get("cmp_scope", [])}
                if task[task_cb_key]["cb_struct_key"] in sort_out:
                    log.info("The task[%s] is not delivered because the thread[%s] proactively releases the task." % (
                        task_cb_key, str(task_list[-1])))
                    continue
                costtime_upperbound = calc_costtime_upperbound(task[task_cb_key]["costtime_baseline"])
                log.debug("costtime upperbound for task %s is %s." % (task[task_cb_key]["cb_struct_key"],
                    str(costtime_upperbound)))
                build_run_distribute = self.run_and_excute(task[task_cb_key]["strategy_list"],
                                                           task[task_cb_key]["cb_struct_key"],
                                                           task[task_cb_key]["need_integrate"],
                                                           task[task_cb_key].get("tune_mode", "NONE"),
                                                           costtime_upperbound,
                                                           task_cb_key,
                                                           # Precision comparison is not performed by default.
                                                           task[task_cb_key].get("cmp_style", 0),
                                                           task[task_cb_key].get("cmp_scope", []))
                if not build_run_distribute:
                    log.warn("can not distribute build run task. res[%s]" % (str(build_run_distribute)))
                    self.global_mgr.tune_result_d[task_cb_key] = None
                    continue
                self.global_mgr.buildrun_task_q.put((task_cb_key, task[task_cb_key]["cb_struct_key"]))
                log.info("build run task queue put task_cb_key[%s] resource_cb_key[%s]!" % (
                    str(task_cb_key), str(task[task_cb_key]["cb_struct_key"])))

    def run(self) -> None:
        """
        run BuildRunAsync
        :return:
        """
        current_thread = None
        if self.opat_utils:
            current_thread = self.opat_utils.get_thread_id()
        log.event("[Tid:%s]BuildRunAsync Entry!" % current_thread)
        while not self.event.is_set():
            sort_out = []
            while not self.global_mgr.buildrun_task_sort_out_q.empty():
                sort_out_tuple = self.global_mgr.buildrun_task_sort_out_q.get()
                self.global_mgr.wait_sort_out_finish_q.put(sort_out_tuple)
                sort_out = sort_out + sort_out_tuple[1]
                for item in sort_out_tuple[1]:
                    log.event("BuildRunAsync clear new task: %s" % str(item))

            if self.global_mgr.tune_task_q.empty():
                time.sleep(TIME_SLEEP)
            else:
                self.update_build_run_tasks(sort_out)

        log.event("[Tid:%s]BuildRunAsync event set, stop run!" % current_thread)

    def stop(self) -> None:
        """
        stop BuildRunAsync
        :return:
        """
        log.info("BuildRunAsync set event to stop cb_thread")
        self.event.set()
        self.join()
        log.info("BuildRunAsync stop cb_thread succ!")


class DataCmpSync(threading.Thread):
    """
    DataCmpSync
    """
    def __init__(self, global_mgr: GlobalManager, opat_utils: types.ModuleType = None,
                 callback_str: str = "CompileAndExecuteTools.DataCompare") -> None:
        super(DataCmpSync, self).__init__()
        module_name, func_name = callback_str.split(".")
        self.datacmp = getattr(importlib.import_module(module_name), func_name)
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.opat_utils = opat_utils

    def run_datacmp_task(self, data_cmptask: dict) -> None:
        """
        run data_compare task
        """
        log.debug("GET DATACMP_TASK_Q %s.", str(data_cmptask))
        for task_id in data_cmptask:
            datacmp_res = self.datacmp(data_cmptask[task_id].get("strategy_list", "NONE"),
                                       data_cmptask[task_id].get("cb_struct_key", ""),
                                       False,
                                       data_cmptask[task_id].get("tune_mode", "NONE"),
                                       DEFAULT_OM_RUN_THRESHOLD,
                                       task_id,
                                       # Default precision comparison mode and default random number range
                                       data_cmptask[task_id].get("cmp_style", 1),
                                       data_cmptask[task_id].get("cmp_scope", []))
        if datacmp_res is None:
            datacmp_res = []
            log.warn("DATACMP_TASK_Q [%s] can not get result", str(task_id))

        self.global_mgr.datacmp_res_d[task_id] = datacmp_res
        log.info("DATACMP_TASK_Q [%s] finished.", str(task_id))

    def run(self) -> None:
        """
        run DataCmpSync
        :return:
        """
        current_thread = None
        if self.opat_utils:
            current_thread = self.opat_utils.get_thread_id()
        log.event("[Tid:%s]DataCmpSync Entry!" % current_thread)
        while not self.event.is_set():
            if self.global_mgr.datacmp_task_q.empty():
                time.sleep(TIME_SLEEP)
            else:
                self.run_datacmp_task(self.global_mgr.datacmp_task_q.get())
        log.event("[Tid:%s]DataCmpSync event set, stop run!" % current_thread)

    def stop(self) -> None:
        """
        stop DataCmpSync
        :return:
        """
        log.info("DataCmpSync set event to stop datacmp_thread.")
        self.global_mgr.datacmp_res_d.clear()
        self.event.set()
        self.join()
        log.info("DataCmpSync stop datacmp_thread succ!")


def daemon_process(daemon_event: object, mgr_pid: int, ppid: str) -> None:
    """
    daemon_process
    """
    def pid_exists(pid: str) -> bool:
        """Check whether pid exists in the current process table.
        UNIX only.
        """
        pid = int(pid)
        if pid <= 0:
            return False
        try:
            os.kill(pid, 0)
        except OSError as err:
            if err.errno == errno.ESRCH:
                # ESRCH == No such process
                return False
            if err.errno == errno.EPERM:
                # EPERM clearly means there's a process to deny access to
                return True
            # According to "man 2 kill" possible error values are
            # EINVAL, EPERM, ESRCH
            raise
        finally:
            pass
        return True

    def signal_handler(signum: int, frame: object) -> None:
        """
        Parameters
        ----------
        signum
        frame

        Returns
        -------

        """
        log.warn("Signal handler called with signal %d, frame %s.", signum, frame)

    signal.signal(signal.SIGINT, signal_handler)
    while not daemon_event.is_set():
        if not pid_exists(ppid):
            log.error("The main process does not exist. We would kill multiprocess manager process: %d.", mgr_pid)
            os.kill(mgr_pid, signal.SIGKILL)
            break
        time.sleep(TIME_SLEEP)


class AutoTuneTask():
    """
    call auto_tune funcs
    """
    def __init__(self, global_mgr: GlobalManager, soc_version: str, aicore_num: int) -> None:
        """
        init AutoTuneTask
        """
        super(AutoTuneTask, self).__init__()
        self.err_msg_q = global_mgr["err_msg_q"]
        self.timer = global_mgr["timer_q"]
        self.soc_version = soc_version
        self.aicore_num = aicore_num
        self.tune_progress_q = global_mgr.get("tune_progress_q")

    def run_auto_tune(self, *args: tuple, **kwds: dict) -> bool:
        """
        call auto_tune_compile and catch runtimeerror
        """
        cbkey = kwds.get("option").get("cb_struct_key")
        try:
            with op_context.OpContext("pre_static") as ctx:
                ctx.add_addition("master_pid", args[1])
                set_current_compile_soc_info(self.soc_version, aicore_num=self.aicore_num)
                log.info("run_auto_tune[%s] start!", cbkey)
                self.timer.put(("start", os.getpid(), cbkey))
                ret = auto_tune_compile(args[0], **kwds)
                self.timer.put(("stop", os.getpid(), cbkey))
                log.info("run_auto_tune[%s] end!", cbkey)
                return ret
        except RuntimeError as err_msg:
            self.err_msg_q.put((err_msg.args[0], "kernel_name"))
            return False
        finally:
            self.tune_progress_q.put({"GA": (cbkey, GA_MEANINGLESS_ROUND, GA_MEANINGLESS_ROUND)})

    def run_format_tune(self, *args: tuple, **kwds: dict) -> bool:
        """
        call format_tune_main and catch runtimeerror
        """
        cbkey = kwds.get("option").get("cb_struct_key")
        try:
            with op_context.OpContext("pre_static") as ctx:
                ctx.add_addition("master_pid", args[1])
                set_current_compile_soc_info(self.soc_version, aicore_num=self.aicore_num)
                log.info("run_format_tune[%s] start!", cbkey)
                self.timer.put(("start", os.getpid(), cbkey))
                ret = format_tune_main(args[0], **kwds)
                self.timer.put(("stop", os.getpid(), cbkey))
                log.info("run_format_tune[%s] end!", cbkey)
                return ret
        except RuntimeError as err_msg:
            self.err_msg_q.put((err_msg.args[0], "kernel_name"))
            return False
        finally:
            pass

    def run_tik_tune(self, *args: tuple, **kwds: dict) -> bool:
        """
        call tik_tune_main and catch runtimeerror
        """
        try:
            with op_context.OpContext("pre_static"):
                context = get_context()
                if context:
                    context.add_addition("master_pid", int(kwds.get("option").get("master_pid")))
                set_current_compile_soc_info(self.soc_version, aicore_num=self.aicore_num)
                log.info("run_tik_tune[%s] start!", kwds.get("option").get("cb_struct_key"))
                self.timer.put(("start", os.getpid(), kwds.get("option").get("cb_struct_key")))
                ret = tik_tune_main(*args, **kwds)
                self.timer.put(("stop", os.getpid(), kwds.get("option").get("cb_struct_key")))
                log.info("run_tik_tune[%s] end!", kwds.get("option").get("cb_struct_key"))
            return ret
        except RuntimeError as err_msg:
            self.err_msg_q.put((err_msg.args[0], "kernel_name"))
            return False
        finally:
            pass

    def run_rl_om(self, rl_event: object, rl_task_q: object, rl_task_d: object, mgr_dict: object) -> None:
        """
        call rl_tune_om and catch runtimeerror
        """
        while not rl_event.is_set():
            if rl_task_q.empty():
                time.sleep(TIME_SLEEP)
                continue
            set_current_compile_soc_info(self.soc_version, aicore_num=self.aicore_num)
            thread_id, rl_jsons, rl_cbkeys, option = rl_task_q.get()
            option_list = []
            for idx, cbkey in enumerate(rl_cbkeys):
                option_new = copy.deepcopy(option)
                option_new["cb_struct_key"] = cbkey
                option_new["global_mgr"] = mgr_dict
                profiling_names = option.get("profiling_names", [])
                if profiling_names:
                    option_new["profiling_name"] = profiling_names[idx].split(";")[0]
                option_list.append(option_new)
            rl_task_d[thread_id] = "start"
            self.timer.put(("start", thread_id, "run_rl_om"))
            try:
                rl_tune_om(rl_jsons, option_list)
            except RuntimeError as err_msg:
                self.err_msg_q.put((err_msg.args[0], "kernel_name"))
            finally:
                self.timer.put(("stop", thread_id, "run_rl_om"))
                rl_task_d[thread_id] = "end"
        log.event("run_rl_om async Process end!")

    def run_as_om(self, as_event: object, as_task_q: object, as_task_d: object, mgr_dict: object) -> None:
        """
        call auto_search and catch runtimeerror
        """
        while not as_event.is_set():
            if as_task_q.empty():
                time.sleep(TIME_SLEEP)
                continue
            set_current_compile_soc_info(self.soc_version, aicore_num=self.aicore_num)
            thread_id, as_jsons, as_cbkeys, option = as_task_q.get()
            option_list = []
            for idx, cbkey in enumerate(as_cbkeys):
                option_new = copy.deepcopy(option)
                option_new["cb_struct_key"] = cbkey
                option_new["global_mgr"] = mgr_dict
                profiling_names = option.get("profiling_names", [])
                if profiling_names:
                    option_new["profiling_name"] = profiling_names[idx].split(";")[0]
                option_list.append(option_new)
            as_task_d[thread_id] = "start"
            self.timer.put(("start", thread_id, "run_as_om"))
            try:
                auto_search(as_jsons, option_list)
            except RuntimeError as err_msg:
                self.err_msg_q.put((err_msg.args[0], "kernel_name"))
            finally:
                self.timer.put(("stop", thread_id, "run_as_om"))
                as_task_d[thread_id] = "end"
        log.event("run_as_om async Process end!")

    def run_post_process(self, *args: tuple, **kwds: dict) -> bool:
        """
        call impl_tune_main and catch runtimeerror
        """
        with op_context.OpContext("pre_static"):
            context = get_context()
            if context:
                context.add_addition("master_pid", int(kwds.get("option").get("master_pid")))
            set_current_compile_soc_info(self.soc_version, aicore_num=self.aicore_num)
            log.info("run_impl_tune[%s] start!", kwds.get("option").get("cb_struct_key"))
            self.timer.put(("start", os.getpid(), kwds.get("option").get("cb_struct_key")))
            try:
                ret = impl_tune_main(*args, **kwds)
            except RuntimeError as err_msg:
                self.err_msg_q.put((err_msg.args[0], "kernel_name"))
                return False
            finally:
                self.timer.put(("stop", os.getpid(), kwds.get("option").get("cb_struct_key")))
        log.info("run_impl_tune[%s] end!", kwds.get("option").get("cb_struct_key"))
        return ret


def config_main_info() -> tuple:
    """
    config __file__ and name of main to None

    @return: (orignal main module name, path)
    """
    main_module = sys.modules['__main__']
    main_mod_name = getattr(main_module.__spec__, "name", None)
    if main_mod_name is not None:
        setattr(main_module.__spec__, "name", None)

    main_path = getattr(main_module, '__file__', None)
    if main_path is not None:
        setattr(main_module, '__file__', None)

    return (main_mod_name, main_path)


def restore_main_info(name: str, path: str) -> None:
    """
    restore main module name and path
    """
    main_module = sys.modules['__main__']
    if name is not None:
        setattr(main_module.__spec__, "name", name)
    if path is not None:
        setattr(main_module, '__file__', path)


class MultiTune:
    """
    class multitune
    """
    def __init__(self, tmp_file_path: str, soc_version: str, multi_num: int, aicore_num: int) -> None:
        """
        init class
        :param multi_num:multiprocessing num of tune
        """
        self._reset_repository()
        ctx = multiprocessing.get_context("forkserver")
        ctx.set_forkserver_preload([])
        main_mod, main_path = config_main_info()
        self.multi_pool = ctx.Pool(multi_num)
        self.tik_pool = ctx.Pool(multi_num)
        self.impl_pool = ctx.Pool(multi_num)
        self.format_pool = ctx.Pool(multi_num)
        self.tmp_bank_path = copy.deepcopy(tmp_file_path)
        self.soc_version = copy.deepcopy(soc_version)
        opat_utils = importlib.import_module("OpatUtils")
        self.global_mgr = GlobalManager()
        self.auto_tune_task = AutoTuneTask(self.global_mgr.mgr_dict, soc_version, aicore_num)
        self.rl_process = ctx.Process(
            target=self.auto_tune_task.run_rl_om,
            args=(self.global_mgr.rl_event,
                  self.global_mgr.rl_task_q,
                  self.global_mgr.rl_task_d,
                  self.global_mgr.mgr_dict,),
            daemon=False)
        self.rl_process.start()
        self.as_process = ctx.Process(
            target=self.auto_tune_task.run_as_om,
            args=(self.global_mgr.as_event,
                  self.global_mgr.as_task_q,
                  self.global_mgr.as_task_d,
                  self.global_mgr.mgr_dict,),
            daemon=False)
        self.as_process.start()
        self.daemon_process = ctx.Process(target=daemon_process,
            args=(self.global_mgr.daemon_event, self.global_mgr.multi_mgr._process.pid, os.getpid(),))
        self.daemon_process.start()
        self.run_cb_thread = BuildRunAsync(self.global_mgr, opat_utils)
        self.run_cb_thread.start()
        self.run_cb_query_thread = BuildRunAsyncPoll(self.global_mgr, opat_utils)
        self.run_cb_query_thread.start()
        self.run_dc_thread = DataCmpSync(self.global_mgr, opat_utils)
        self.run_dc_thread.start()
        self.compile_op_thread = CompileOpThread(self.global_mgr, opat_utils)
        self.compile_op_thread.start()
        self.query_compile_op_thread = QueryCompileOpThread(self.global_mgr, opat_utils)
        self.query_compile_op_thread.start()
        self.tik_tune_space_thread = TikTuneSpaceThread(self.global_mgr, opat_utils)
        self.tik_tune_space_thread.start()
        self.release_run_cb_thread = ReleaseBuildRunAsync(self.global_mgr, opat_utils)
        self.release_run_cb_thread.start()
        self.release_compile_thread = ReleaseCompileOpThread(self.global_mgr, opat_utils)
        self.release_compile_thread.start()
        self.release_tik_tune_space_thread = ReleaseTikTuneSpaceThread(self.global_mgr, opat_utils)
        self.release_tik_tune_space_thread.start()
        self.tune_progress_thread = TuneProgressManager(self.global_mgr, opat_utils)
        self.tune_progress_thread.start()
        self.tune_report_thread = TuneResReportManager(self.global_mgr, opat_utils)
        self.tune_report_thread.start()
        self.timer = TimerThread(self.global_mgr, opat_utils)
        self.timer.start()
        self.res_dict = {}
        self.cbkey_dict = {}
        self.task_end = []
        self.tune_cbkeys = []
        self.exited_tune = False
        restore_main_info(main_mod, main_path)

    @staticmethod
    def tune_post_process() -> None:
        """
        sync op tune params
        """
        # reload rl bank for result om
        sync_op_tune_params("tbe.common.rl_bank.rl_bank", "reset_repository")
        return

    @staticmethod
    def _reset_repository() -> None:
        with op_context.OpContext("pre_static"):
            reset_repository()

    def tune(self, tune_param_dict: Dict) -> None:
        """
        distribute tune task to subprocess
        """
        thread_id = tune_param_dict.get("thread_id")
        thread_id_local = copy.deepcopy(thread_id)
        if thread_id not in self.res_dict.keys():
            self.res_dict[thread_id_local] = []
        if thread_id not in self.cbkey_dict.keys():
            self.cbkey_dict[thread_id_local] = []

        option = {
            "option": {
                "soc_version": self.soc_version,
                "tmp_file_path": tune_param_dict.get("tmp_file_path"),
                "suboptimal_path": tune_param_dict.get("suboptimal_path", ""),
                "job_id": tune_param_dict.get("job_id"),
                "high_perf": tune_param_dict.get("high_perf") == HIGH_PERF_ON,
                "master_pid": os.getpid(),
                "format_options": tune_param_dict.get("format_options", []),
                "profiling_names": tune_param_dict.get("profiling_names", []),
            },
            "thread_id": thread_id_local
        }

        mode = tune_param_dict.get("mode")
        jsons = tune_param_dict.get("json_strs")
        cbkeys = tune_param_dict.get("cb_keys")

        self.tune_report_thread.add_new_report_object(tune_param_dict.get("job_id"))

        if (mode in TUNE_MODE) and jsons and cbkeys:
            func = getattr(self, "_tune_%s" % mode.lower())
            func(copy.deepcopy(jsons), copy.deepcopy(cbkeys), option)
            self.cbkey_dict[thread_id_local].extend(copy.deepcopy(cbkeys))

        if mode == "IMPL" and jsons and cbkeys:
            dynamic_and_impl = tune_param_dict.get("dynamic_and_impl")
            func = getattr(self, "_tune_%s" % mode.lower())
            func(copy.deepcopy(jsons), copy.deepcopy(cbkeys), copy.deepcopy(dynamic_and_impl), option)
            self.cbkey_dict[thread_id_local].extend(copy.deepcopy(cbkeys))

    def exit_tune(self) -> None:
        """
        exit without wait
        """
        if not self.exited_tune:
            self.run_cb_thread.stop()
            self.run_cb_query_thread.stop()
            self.run_dc_thread.stop()
            self.compile_op_thread.stop()
            self.query_compile_op_thread.stop()
            self.tik_tune_space_thread.stop()
            self.release_tik_tune_space_thread.stop()
            self.release_run_cb_thread.stop()
            self.release_compile_thread.stop()
            self.timer.stop()
            self.tune_progress_thread.stop()
            self.tune_report_thread.stop()
            self.global_mgr.rl_event.set()
            self.global_mgr.as_event.set()
            self.rl_process.join()
            self.rl_process.close()
            self.as_process.join()
            self.as_process.close()
            self.multi_pool.close()
            self.multi_pool.join()
            self.tik_pool.close()
            self.tik_pool.join()
            self.impl_pool.close()
            self.impl_pool.join()
            self.format_pool.close()
            self.format_pool.join()
            self.global_mgr.daemon_event.set()
            self.daemon_process.join()
            self.global_mgr.multi_mgr.shutdown()
            self._obj_release()
            self.exited_tune = True

    def del_item(self, thread_id: str) -> bool:
        """
        del complete task
        """
        d_thread_id = copy.deepcopy(thread_id)
        task_end = False
        if d_thread_id in self.res_dict:
            del_request = copy.deepcopy(self.cbkey_dict[d_thread_id])
            for item in del_request:
                log.event("del_item[%s] request:%s" % (str(d_thread_id), str(item)))
            self.global_mgr.buildrun_task_sort_out_q.put((d_thread_id, del_request))
            del self.res_dict[d_thread_id]
            del self.cbkey_dict[d_thread_id]
        else:
            while not self.global_mgr.finish_sort_out_q.empty():
                self.task_end.append(self.global_mgr.finish_sort_out_q.get())
            if d_thread_id in self.task_end:
                log.event("del_item[%s] request success!" % str(d_thread_id))
                self.task_end.remove(d_thread_id)
                self._reset_repository()
                task_end = True
        return task_end

    def polling_task_complete(self, thread_id: str) -> bool:
        """
        Whether all polling tasks are complete
        """
        d_thread_id = copy.deepcopy(thread_id)
        if thread_id not in self.res_dict:
            self.task_end.append(d_thread_id)
            return True
        task_not_ready = []
        for cb_ky, task in self.res_dict[d_thread_id]:
            if not task.ready():
                task_not_ready.append(cb_ky)
                continue
            if not task.get() in (True, False):
                log.error("task error!\n%s" % str(task.get()))
        log.info("There are %s GA and TIK tasks, %s of which are not completed: %s." % \
            (str(len(self.res_dict[d_thread_id])), str(len(task_not_ready)), "\n".join(task_not_ready)))
        rl_status = self.global_mgr.rl_task_d.get(d_thread_id, None) is None
        rl_status = rl_status or self.global_mgr.rl_task_d.get(d_thread_id, None) == "end"
        as_status = self.global_mgr.as_task_d.get(d_thread_id, None) is None
        as_status = as_status or self.global_mgr.as_task_d.get(d_thread_id, None) == "end"
        return len(task_not_ready) == 0 and rl_status and as_status

    def get_err_happened(self) -> tuple:
        """
        get_err_message
        """
        if self.global_mgr.err_msg_q.empty():
            return ()
        return self.global_mgr.err_msg_q.get()

    def _tune_ga(self, ga_jsons: List[str], ga_cbkeys: List[str], option: Dict) -> None:
        """
        distribute ga tune task to subprocess
        """
        log.event("multiprocess_tune receive ga tune task[%s]: ga_cbkeys:%s ", len(ga_jsons), str(ga_cbkeys))
        self.tune_cbkeys.extend(ga_cbkeys)
        ga_res_list = []
        self.global_mgr.job_tune_progress_q.put({option["option"]["job_id"]: {"GA": ga_cbkeys}})
        for index, ga_json in enumerate(ga_jsons):
            option_new = {"option": copy.deepcopy(option["option"])}
            option_new["option"]["cb_struct_key"] = ga_cbkeys[index]
            option_new["option"]["global_mgr"] = self.global_mgr.mgr_dict
            cur_pid = os.getpid()
            ga_res_list.append((ga_cbkeys[index], self.multi_pool.apply_async(self.auto_tune_task.run_auto_tune,
                args=(ga_json, cur_pid), kwds=option_new)))
        self.res_dict[option["thread_id"]].extend(ga_res_list)

    def _tune_tik(self, tik_op_args: List[str], tik_cbkeys: List[str], option: Dict) -> None:
        """
        distribute tik tune task to subprocess
        """
        log.event("multiprocess_tune receive tik tune task: tik_thread:%s, tik_cbkeys:%s ",
                str(option["thread_id"]), str(tik_cbkeys))
        self.tune_cbkeys.extend(tik_cbkeys)
        tik_res_list = []
        for index, op_arg in enumerate(tik_op_args):
            option_new = {"option": copy.deepcopy(option["option"])}
            option_new["option"]["cb_struct_key"] = tik_cbkeys[index]
            option_new["option"]["global_mgr"] = self.global_mgr.mgr_dict
            option_new["option"]["master_pid"] = os.getpid()
            tik_res_list.append((tik_cbkeys[index],
                self.tik_pool.apply_async(self.auto_tune_task.run_tik_tune, args=(op_arg,), kwds=option_new)))
        self.res_dict[option["thread_id"]].extend(tik_res_list)

    def _tune_rl(self, rl_jsons: List[str], rl_cbkeys: List[str], option: Dict) -> None:
        """
        distribute rl tune task to subprocess
        """
        log.event("multiprocess_tune receive rl tune task: rl_cbkeys:%s ", str(rl_cbkeys))
        self.tune_cbkeys.extend(rl_cbkeys)
        self.global_mgr.job_tune_progress_q.put({option["option"]["job_id"]: {"RL": rl_cbkeys}})
        self.global_mgr.rl_task_d[option["thread_id"]] = "async"
        self.global_mgr.rl_task_q.put((option["thread_id"], rl_jsons, rl_cbkeys, option["option"]))

    def _tune_as(self, as_jsons: List[str], as_cbkeys: List[str], option: Dict) -> None:
        """
        distribute as tune task to subprocess
        """
        log.event("multiprocess_tune receive as tune task: as_cbkeys:%s ", str(as_cbkeys))
        self.tune_cbkeys.extend(as_cbkeys)
        self.global_mgr.job_tune_progress_q.put({option["option"]["job_id"]: {"AS": as_cbkeys}})
        self.global_mgr.as_task_d[option["thread_id"]] = "async"
        self.global_mgr.as_task_q.put((option["thread_id"], as_jsons, as_cbkeys, option["option"]))

    def _impl_pool_apply_async(self, impl_task_params: ImplTaskParams):
        option_new = {"option": copy.deepcopy(impl_task_params.option["option"])}
        option_new["option"]["cb_struct_key"] = impl_task_params.impl_cbkeys[impl_task_params.index]
        option_new["option"]["dynamic_and_impl"] = impl_task_params.dynamic_and_impl[impl_task_params.index]
        option_new["option"]["global_mgr"] = self.global_mgr.mgr_dict
        option_new["option"]["master_pid"] = os.getpid()
        impl_task_params.impl_res_list.append((impl_task_params.impl_cbkeys[impl_task_params.index],
            self.impl_pool.apply_async(self.auto_tune_task.run_post_process,
            args=(impl_task_params.op_arg,), kwds=option_new)))

    def _tune_impl(self, impl_op_args, impl_cbkeys, dynamic_and_impl, option):
        """
        distribute impl tune task to subprocess
        """
        log.event("multiprocess_tune receive impl tune task: impl:%s, impl_cbkeys:%s ",
                str(option["thread_id"]), str(impl_cbkeys))
        impl_res_list = []
        impl_cbkeys_bak = copy.deepcopy(impl_cbkeys)
        for index, op_arg in enumerate(impl_op_args):
            if impl_cbkeys[index] not in self.tune_cbkeys:
                impl_cbkeys_bak.remove(impl_cbkeys[index])
                impl_task_params = ImplTaskParams(impl_cbkeys, dynamic_and_impl, impl_res_list, option, index, op_arg)
                self._impl_pool_apply_async(impl_task_params)
        self.res_dict[option["thread_id"]].extend(impl_res_list)

        impl_tune_res_list = []
        while impl_cbkeys_bak:
            for index, op_arg in enumerate(impl_op_args):
                if impl_cbkeys[index] in self.tune_cbkeys and impl_cbkeys[index] in self.global_mgr.task_finished_list:
                    impl_cbkeys_bak.remove(impl_cbkeys[index])
                    impl_task_params = ImplTaskParams(impl_cbkeys, dynamic_and_impl, impl_tune_res_list,
                        option, index, op_arg)
                    self._impl_pool_apply_async(impl_task_params)
            time.sleep(TIME_SLEEP)
        self.res_dict[option["thread_id"]].extend(impl_tune_res_list)

    def _tune_format(self, format_op_args, format_cbkeys, option):
        """
        distribute format tune task to subprocess
        """
        log.event("multiprocess_tune receive format tune task:[%s], format:%s, format_cbkeys:%s ",
            len(format_cbkeys), str(option["thread_id"]), str(format_cbkeys))
        if len(format_op_args) != len(option["option"]["format_options"]):
            log.warn("the num of ops is not equal to the num of format_options. format_op_args: %s, \
                     format_options: %s", len(format_op_args), len(option["option"]["format_options"]))
            return
        self.tune_cbkeys.extend(format_cbkeys)
        format_res_list = []
        for index, op_arg in enumerate(format_op_args):
            option_new = {"option": copy.deepcopy(option["option"])}
            format_option = option_new["option"]["format_options"][index]
            if not format_option:
                continue
            option_new["option"]["format_option"] = format_option
            option_new["option"]["cb_struct_key"] = format_cbkeys[index]
            option_new["option"]["global_mgr"] = self.global_mgr.mgr_dict
            cur_pid = os.getpid()
            format_res_list.append((format_cbkeys[index], self.format_pool.apply_async( \
                                    self.auto_tune_task.run_format_tune, args=(op_arg, cur_pid), kwds=option_new)))
        self.res_dict[option["thread_id"]].extend(format_res_list)


    def _obj_release(self) -> None:
        """
        _obj_release
        Proactively releases objects to reclaim resources.
        """
        del self.run_cb_thread
        del self.run_cb_query_thread
        del self.run_dc_thread
        del self.compile_op_thread
        del self.query_compile_op_thread
        del self.tik_tune_space_thread
        del self.release_tik_tune_space_thread
        del self.release_run_cb_thread
        del self.release_compile_thread
        del self.timer
        del self.tune_progress_thread
        del self.tune_report_thread
        del self.multi_pool
        del self.tik_pool
        del self.impl_pool
        del self.format_pool
        del self.global_mgr.daemon_event
        del self.daemon_process
        del self.global_mgr
        del self.auto_tune_task
