#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2022. Huawei Technologies Co., Ltd. All rights reserved.

Define the tune progress manager class
"""
import time
import threading
import types
from dataclasses import make_dataclass
from dataclasses import field

from optune_utils import log
from optune_utils.global_manager import GlobalManager


TUNE_MODE = ("GA", "RL", "TIK", "AS")
LOC_GA = 0
LOC_RL = 1
LOC_AS = 3
VEC_TUNING_TIME = 10
TUNE_PROGRESS_MAX = 100
VEC_START = "start"
VEC_SKIP = "skip"
VEC_END = "end"
ALL_FINISH = "all_finish"
GA_MEANINGLESS_ROUND = -1
TIME_SLEEP = 0.1
GA_SKIP = "skip"

OperatorProgressInfo = make_dataclass("OperatorProgressInfo",
    ["job_id", "tune_mode", "progress_value", (GA_SKIP, bool, field(default=False))])
OpatProgressHandle = make_dataclass("OpatProgressHandle", ["opat_progress", "total_cnt"])
VECTuneStatus =  make_dataclass("VECTuneStatus", ["cbkey", "begin_time", "cur_time", "time_out", "tune_state"])


class TuneProgressManager(threading.Thread):
    """
    Tune Progress Manage
    """
    def __init__(self, global_mgr: GlobalManager, opat_utils: types.ModuleType = None) -> None:
        """
        TuneProgressManager init
        """
        super(TuneProgressManager, self).__init__()
        self.event = threading.Event()
        self.global_mgr = global_mgr
        self.opat_utils = opat_utils
        self.job_tune_progress_d = {} # e.g. {"xxxcbkey":{"job_id":"xxx","tune_mode":"GA","progress_value":50}}
        self.opat_res_handle = {} # e.g. {"jobidXXX":{"opat_progress": 0; "total_cnt": 0}}
        self.cur_rl_status = {} # e.g. {"jobidXXX":["cbkey", "begin_time", "cur_time", "time_out", "tune_state"]}
        self.cur_as_status = {} # e.g. {"jobidXXX":["cbkey", "begin_time", "cur_time", "time_out", "tune_state"]}

    def add_new_tuning_task(self) -> None:
        """
        run TuneProgressManager
        :return:
        """
        while not self.global_mgr.job_tune_progress_q.empty():
            job_tune_progress = self.global_mgr.job_tune_progress_q.get()
            job_id = list(job_tune_progress.keys())[0]
            cbkey_dict = job_tune_progress.get(job_id)
            tune_mode = list(cbkey_dict.keys())[0]
            for cbk in cbkey_dict.get(tune_mode):
                progress_info = OperatorProgressInfo(job_id, tune_mode, 0)
                self.job_tune_progress_d[cbk] = progress_info
            if job_id not in self.opat_res_handle:
                opat_progress_res = OpatProgressHandle(0, 0)
                self.opat_res_handle[job_id] = opat_progress_res
            self.opat_res_handle.get(job_id).total_cnt += len(cbkey_dict.get(tune_mode))

    def ga_cbkey_mark_skip(self, cbkey: str) -> None:
        """
        mark ga cbkey skip
        :return: None
        """
        if cbkey in self.job_tune_progress_d:
            self.job_tune_progress_d.get(cbkey).skip = True

    def ga_vec_tune_msg_process(self) -> None:
        """
        run TuneProgressManager
        :return:
        """
        if not self.global_mgr.tune_progress_q.empty():
            tune_progress_msg = self.global_mgr.tune_progress_q.get()
            # GA tune (cbkey, round, total_round)
            if TUNE_MODE[LOC_GA] in tune_progress_msg:
                ga_progress_receive = tune_progress_msg.get(TUNE_MODE[LOC_GA])
                if GA_SKIP in ga_progress_receive: # skip
                    self.ga_cbkey_mark_skip(ga_progress_receive[0])
                    self.global_mgr.task_finished_list.append(ga_progress_receive[0])
                    return
                cbkey, cur_round, total_round = ga_progress_receive
                log.debug("Receive ga tune report cbkey:%s cur_round:%s, total_round:%s" % \
                    (cbkey, cur_round, total_round))
                if cbkey and cur_round and total_round:
                    self.__ga_calc_report_progress(cbkey, cur_round, total_round)
            # RL tune (cbkey, timeout, start/end)
            elif TUNE_MODE[LOC_RL] in tune_progress_msg:
                cbkey, time_out, rl_status = tune_progress_msg.get(TUNE_MODE[LOC_RL])
                log.debug("Receive rl tune report cbkey:%s time_out:%s, rl_status:%s" % (cbkey, time_out, rl_status))
                if cbkey and time_out and rl_status:
                    self.__vec_tune_msg_process(cbkey, time_out, rl_status, self.cur_rl_status)
            # AS tune (cbkey, timeout, start/end)
            elif TUNE_MODE[LOC_AS] in tune_progress_msg:
                cbkey, time_out, as_status = tune_progress_msg.get(TUNE_MODE[LOC_AS])
                log.debug("Receive as tune report cbkey:%s time_out:%s, as_status:%s" % (cbkey, time_out, as_status))
                if cbkey and time_out and as_status:
                    self.__vec_tune_msg_process(cbkey, time_out, as_status, self.cur_as_status)

    def vec_runing_process(self, cur_vec_status: dict) -> None:
        """
        when vec Tune is start, update vec progress every 10s
        :return:
        """
        for job_id, status_info in cur_vec_status.items():
            cur_time = time.time()
            if status_info.tune_state == VEC_START and cur_time - status_info.cur_time > VEC_TUNING_TIME:
                status_info.cur_time = cur_time
                self.__vec_calc_report_progress(job_id, cur_vec_status)

    def run(self) -> None:
        """
        run TuneProgressManager
        :return:
        """
        log.event("[TuneProgressManager]TuneProgressManager Entry!")
        while not self.event.is_set():
            # add all tuning jobid-cbkeys
            self.add_new_tuning_task()
            # check ga/rl/as tune msg
            self.ga_vec_tune_msg_process()
            # cal rl times
            self.vec_runing_process(self.cur_rl_status)
            # cal as times
            self.vec_runing_process(self.cur_as_status)
            time.sleep(TIME_SLEEP)
        log.event("[TuneProgressManager] event set, stop run!")

    def stop(self) -> None:
        """
        stop TuneProgressManager
        :return:
        """
        log.info("TuneProgressManager set event to stop tune_progress_manage.")
        self.event.set()
        self.join()
        log.info("TuneProgressManager stop tune_progress_manage succ!")

    def __vec_tune_msg_process(self, cbkey: str, time_out: int, vec_status: str, cur_vec_status: dict) -> None:
        """
        vec tune msg process
        :return:
        """
        valid_flag = cbkey in self.job_tune_progress_d and isinstance(time_out, int) and \
            time_out > 0 and vec_status in (VEC_START, VEC_SKIP, VEC_END, ALL_FINISH)
        if not valid_flag:
            log.error("__vec_tune_msg_process: input is invalid!")
            return
        vec_job_id = self.job_tune_progress_d.get(cbkey).job_id
        if vec_status in (VEC_START, VEC_SKIP):
            cur_time = time.time()
            vec_tune_states = VECTuneStatus(cbkey, cur_time, cur_time, time_out, vec_status)
            cur_vec_status[vec_job_id] = vec_tune_states
            self.__vec_calc_report_progress(vec_job_id, cur_vec_status)
        elif vec_status == VEC_END and cur_vec_status.get(vec_job_id):
            cur_vec_status.get(vec_job_id).tune_state = vec_status
            self.__vec_calc_report_progress(vec_job_id, cur_vec_status)
        elif vec_status == ALL_FINISH:
            cur_time = time.time()
            vec_tune_states = VECTuneStatus(cbkey, cur_time, cur_time, time_out, vec_status)
            cur_vec_status[vec_job_id] = vec_tune_states
            self.__vec_calc_report_progress(vec_job_id, cur_vec_status)
        else:
            log.error("__vec_tune_msg_process:vec msg is invalid for curent vec status!")

    def __vec_calc_report_progress(self, job_id: str, cur_vec_status: dict) -> None:
        """
        calc single vec tune progress
        :return: tune_msg
        """
        vec_run_info = cur_vec_status.get(job_id)
        if not vec_run_info:
            log.error("vec_calc_report_progress:vec_run_info is invalid!")
            return
        state_flag = vec_run_info.tune_state
        # vec all finished
        if state_flag == ALL_FINISH:
            for _, progress_info in self.job_tune_progress_d.items():
                if job_id == progress_info.job_id and \
                    (progress_info.tune_mode == TUNE_MODE[LOC_AS] or progress_info.tune_mode == TUNE_MODE[LOC_AS]):
                    progress_info.progress_value = TUNE_PROGRESS_MAX
            tune_msg = "The vec tune is finished, job_id: " + str(job_id)
            self.__opat_calc_report_progress(job_id, tune_msg)
            return

        run_time = vec_run_info.cur_time - vec_run_info.begin_time
        tmp_progress = 0
        if vec_run_info.time_out > 0:
            tmp_progress = run_time * TUNE_PROGRESS_MAX / vec_run_info.time_out
        cbkey = vec_run_info.cbkey
        cbkey_str = cbkey.split("/")[-1]
        # vec skip: fix progress_value but not report
        if state_flag == VEC_SKIP:
            self.job_tune_progress_d.get(cbkey).progress_value = TUNE_PROGRESS_MAX
            log.info("TuneProgressManager:skip vec tune [%s]" % cbkey)
            self.global_mgr.task_finished_list.append(cbkey)
            return
        # vec start/end: fix progress_value and report
        tune_msg = "Tuning the " + cbkey_str + " operator has taken " + str(int(run_time)) + "s"
        if state_flag == VEC_END:
            tmp_progress = TUNE_PROGRESS_MAX
            tune_msg = "The tuning of " + cbkey_str + " is finished"
            self.global_mgr.task_finished_list.append(cbkey)
        elif state_flag == VEC_START and tmp_progress >= TUNE_PROGRESS_MAX:
            tmp_progress = TUNE_PROGRESS_MAX - 1
        self.job_tune_progress_d.get(cbkey).progress_value = tmp_progress
        self.__opat_report_progress(cbkey, tune_msg)

    def __ga_calc_report_progress(self, cbkey: str, cur_round: int, total_round: int) -> None:
        """
        calc single ga tune progress
        :return: tune_msg
        """
        valid_flag = cbkey in self.job_tune_progress_d and \
            isinstance(cur_round, int) and isinstance(total_round, int)
        if not valid_flag:
            log.error("ga_calc_report_progress:input is invalid!")
            return
        if self.job_tune_progress_d.get(cbkey).skip:
            return
        tmp_progress = (cur_round * TUNE_PROGRESS_MAX) / total_round
        cbkey_str = cbkey.split("/")[-1]
        tune_msg = "The [" + str(cur_round) + "]th round tuning of " + cbkey_str + " is finished"
        if cur_round == GA_MEANINGLESS_ROUND and total_round == GA_MEANINGLESS_ROUND:
            tune_msg = "The tuning of " + cbkey_str + " is finished"
            self.global_mgr.task_finished_list.append(cbkey)
        if tmp_progress > self.job_tune_progress_d.get(cbkey).progress_value:
            self.job_tune_progress_d.get(cbkey).progress_value = tmp_progress
        self.__opat_report_progress(cbkey, tune_msg)

    def __opat_report_progress(self, cbkey: str, tune_msg: str) -> None:
        """
        get job id and call __opat_calc_report_progress
        :return:
        """
        job_id = self.job_tune_progress_d.get(cbkey).job_id
        self.__opat_calc_report_progress(job_id, tune_msg)

    def __opat_calc_report_progress(self, job_id: str, tune_msg: str) -> None:
        """
        calc opat total progress and report
        :return:
        """
        if not job_id:
            log.error("opat_calc_report_progress:job_id is invalid!")
            return
        tag = job_id + "opat"
        total_progress = 0
        total_cnt = 0
        for _, progress_info in self.job_tune_progress_d.items():
            if job_id == progress_info.job_id and not progress_info.skip:
                total_progress += progress_info.progress_value
                total_cnt += 1

        cal_progress = total_progress / total_cnt if total_cnt > 0 else TUNE_PROGRESS_MAX
        self.opat_res_handle.get(job_id).opat_progress = cal_progress
        self.opat_utils.update_tune_progress(int(cal_progress), tune_msg, tag)
