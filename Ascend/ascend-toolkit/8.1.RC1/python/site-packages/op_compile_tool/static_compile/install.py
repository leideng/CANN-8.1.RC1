#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# ----------------------------------------------------------------------------
# Copyright (c) Huawei Technologies Co., Ltd. 2023. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------
import argparse
import json
import logging
import os
import shutil
import subprocess
import sys

import time

# 运行时禁止生成__pycache__/文件夹
sys.dont_write_bytecode = True

SCRIPT_DIR_PATH = os.path.dirname(os.path.realpath(__file__))


def setting_logformat(log_level='INFO'):
    """
    :param log_level: 设置安装日志级别
    :return: None
    """
    if log_level.upper() not in ['DEBUG', 'INFO', 'WARNING', 'ERROR']:
        logging.error(f'{log_level} is not the correct configuration option')

    log_format = "%(asctime)s-%(levelname)s-%(message)s"
    date_format = "%m/%d/%Y %H:%M"
    logging.basicConfig(level=log_level, format=log_format, datefmt=date_format)
    return True


def _uninstall_package(prefix_path: str, package_name: str):
    """
    :param prefix_path:  静态算子包路径
    :param package_name: run包名
    :return: True/False
    """
    info = input(f'{package_name}.run package has been installed, do you want to continue? [y/n]')
    if info == 'y':
        cmd = f'{prefix_path}/{package_name}/uninstall.sh'
        logging.info(f'start uninstall {package_name}...')
        _, data = subprocess.getstatusoutput(cmd)
        logging.info(data)
        return True
    else:
        return False


def copy_files(install_path: str) -> bool:
    """
    :param install_path: 包安装路径
    :return: True/False
    """
    if not install_path:
        install_path = os.environ.get('ASCEND_OPP_PATH')
    if not os.path.isdir(install_path):
        logging.error(f'===={install_path} is not existential; please install opp package====')
        return False
    try:
        config_file = os.path.join(SCRIPT_DIR_PATH, '../..', 'config.ini')
        if not os.path.isfile(config_file):
            logging.error(f'===={config_file} is not existential;please check.====')
            return False

        with open(config_file, mode='rt', encoding='utf-8') as f:
            package_name = f.read().split('=')[-1].split(',')[-1].strip()

        src_path = os.path.join(SCRIPT_DIR_PATH, '..', '..', package_name)

        prefix_path = os.path.join(install_path, 'static_kernel', 'ai_core')
        if not os.path.isdir(prefix_path):
            logging.debug(f'make dir({prefix_path})')
            os.makedirs(prefix_path)
        logging.debug(f'copy {src_path} to {prefix_path}')
        if os.path.exists(f'{prefix_path}/{package_name}'):
            status = _uninstall_package(prefix_path, package_name)
            if not status:
                return False
        shutil.copytree(src_path, f'{prefix_path}/{package_name}')

        # 获取芯片名
        soc_version_list = [name for name in os.listdir(f'{src_path}/config/')]
        logging.info(f'soc_version: {soc_version_list}')

        # 处理shape_info
        dst_shape_info_path = os.path.join(prefix_path, 'config', soc_version_list[0], 'shape_info')
        if not os.path.isdir(dst_shape_info_path):
            os.makedirs(dst_shape_info_path)
        src_shape_info_path = os.path.join(src_path, 'config', soc_version_list[0], 'shape_info')
        for root, _, files in os.walk(src_shape_info_path):
            for shape_file in files:
                shutil.copy2(os.path.join(root, shape_file),
                             dst_shape_info_path)

        # 处理config.ini
        dts_config_file = os.path.join(prefix_path, 'config.ini')
        src_config_file = os.path.join(SCRIPT_DIR_PATH, '..', '..', 'config.ini')
        if not os.path.isfile(dts_config_file):
            shutil.copy(src_config_file, os.path.dirname(dts_config_file))
        else:
            with open(dts_config_file, mode='a') as f:
                f.write(f',{package_name}')

        # 处理version_info
        dst_version_info = os.path.join(prefix_path, 'version.info')
        src_version_info = os.path.join(SCRIPT_DIR_PATH, '../..', 'version.info')
        shutil.copy(src_version_info, os.path.dirname(dst_version_info))

        # 生成静态算子包根目录下的uninstall.sh
        dst_uninstall_file = os.path.join(prefix_path, 'uninstall.sh')
        with open(dst_uninstall_file, 'w') as file:
            file.write('''#!/bin/bash
''')
            file.write('''#-------------------------------------------------------------------
''')
            file.write('''# Purpose:
''')
            file.write('''# Copyright 2023 Huawei Technologies Co., Ltd. All rights reserved.
''')
            file.write('''#-------------------------------------------------------------------
''')
            file.write('''set -e
''')
            file.write('''real_path=$(realpath "$0")
''')
            file.write('''LOCAL_PATH=$(cd $(dirname "$real_path"); pwd)
''')
            file.write('''PY_PATH=$(cd ${LOCAL_PATH}/%s/scripts; pwd)
''' % package_name)
            file.write('''execute_cmd="${PY_PATH}/uninstall.py --all"
''')
            file.write('''${execute_cmd}
''')
        os.chmod(dst_uninstall_file, 0o755)

        # 处理uninstall.sh
        uninstall_file = os.path.join(prefix_path, package_name, 'scripts', 'uninstall.sh')
        if not os.path.isfile(uninstall_file):
            logging.error('====uninstall.sh is not existential;please check.====')
            return False
        shutil.move(uninstall_file, f'{prefix_path}/{package_name}')

        # 处理json
        status = parse_and_make_json(prefix_path, soc_version_list)
        if not status:
            logging.error('parse_and_make_json error.')
            return False
    finally:
        logging.debug('def copy_files() over.')

    return True


def _update_full_info(key: str, part_info: dict, full_info: dict) -> dict:
    if 'valueDependIndex' in part_info[key]:
        full_info[key]['valueDependIndex'] = part_info[key]['valueDependIndex']
    elif 'valueDependIndex' in full_info[key]:
        del full_info[key]['valueDependIndex']
    if 'simplifiedKeyMode' in part_info[key]:
        full_info[key]['simplifiedKeyMode'] = part_info[key]['simplifiedKeyMode']
    elif 'simplifiedKeyMode' in full_info[key]:
        del full_info[key]['simplifiedKeyMode']
    for i in part_info[key]['staticList']:
        simplified_key = i['simplifiedKey']
        for index, j in enumerate(full_info[key]['staticList']):
            if simplified_key == j['simplifiedKey']:
                full_info[key]['staticList'][index] = i
                break
        else:
            full_info[key]['staticList'].append(i)


def parse_and_make_json(prefix_path: str, soc_version_list: list) -> bool:
    """
    :param prefix_path: 安装目录的子目录
    :param soc_version_list: 需要安装的芯片名列表
    :return: True/False
    """
    dst_json_file = os.path.join(prefix_path, 'config', soc_version_list[0], 'binary_info_config.json')
    src_json_file = os.path.join(SCRIPT_DIR_PATH, '../', 'config', soc_version_list[0], 'binary_info_config.json')
    if not os.path.isfile(src_json_file):
        logging.debug(src_json_file)
        logging.error('binary_info_config.json is not in run package, please check!')
        return False
    if not os.path.isfile(dst_json_file):
        if not os.path.exists(os.path.dirname(dst_json_file)):
            os.makedirs(os.path.dirname(dst_json_file))
        shutil.copy(src_json_file, os.path.dirname(dst_json_file))
    else:
        with open(dst_json_file, mode='r') as f:
            full_info = json.load(f)
            logging.debug(f'full_info: {full_info}')
        with open(src_json_file, mode='r') as f:
            part_info = json.load(f)
            logging.debug(f'part_info: {part_info}')
        keys_list = part_info.keys()
        for key in keys_list:
            if key not in full_info:
                full_info.setdefault(key, part_info[key])
                continue
            _update_full_info(key, part_info, full_info)
        logging.debug(f'full_info: {full_info}')
        with open(dst_json_file, mode='w') as f:
            json.dump(full_info, f, indent=2, sort_keys=True)
    return True


def process_query():
    pid = os.getpid()
    query_cmd = f'ps -ef | grep "python.*install.py\|python.*uninstall.py" | grep -v grep | grep -v {pid}'
    logging.debug(f'pid: {pid}')
    for _ in range(5):
        _, data = subprocess.getstatusoutput(query_cmd)
        logging.debug(f'{data}, type is {type(data)}')
        if data:
            time.sleep(1)
        else:
            return True

    logging.error('wait too long time, please check install or uninstall in process_cmd(ps -ef | grep install)')
    return False


def args_parse():
    """
    :return: 外界传入的参数值
    """
    parser = argparse.ArgumentParser(description='Parses the input parameters')
    parser.add_argument('-i', '--install-path', metavar='install-path', dest='install_path', nargs='?', const='',
                        default='', help='please input install_path.')
    return parser.parse_args(sys.argv[3:])


def main():
    setting_logformat()
    status = process_query()
    if not status:
        return False
    install_path = args_parse().install_path
    status = copy_files(install_path)
    if not status:
        logging.error('====install  failed ====')
        return False
    else:
        logging.info(f'====install  success into {install_path} ====')
        return True


if __name__ == '__main__':
    if not main():
        sys.exit(1)
