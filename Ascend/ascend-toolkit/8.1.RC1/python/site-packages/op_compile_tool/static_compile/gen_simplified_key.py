#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# ----------------------------------------------------------------------------
# Copyright (c) Huawei Technologies Co., Ltd. 2023. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------

import argparse
import os
import stat
import sys
import json
import struct

from tbe.common.utils import log as logger


# 运行时禁止生成__pycache__/文件夹
sys.dont_write_bytecode = True

VALUE_DEPEND_CONST_VALUE_NUM_MAX = 32
DYNAMIC_INPUT_NUM_MAX = 32


DATA_TPYE_DICT = {
    'float32': 0,
    'float': 0,
    'float16': 1,
    'half': 1,
    'int8': 2,
    'int16': 6,
    'uint16': 7,
    'uint8': 4,
    'int32': 3,
    'int64': 9,
    'uint32': 8,
    'uint64': 10,
    'bool': 12,
    'double': 11,
    'string': 13,
    'complex64': 16,
    'complex128': 17,
    'qint8': 18,
    'qint16': 19,
    'qint32': 20,
    'quint8': 21,
    'quint16': 22,
    'resource': 23,
    'dual': 25,
    'variant': 26,
    'bf16': 27,
    'bfloat16': 27,
    'undefined': 28,
    'int4': 29,
    'uint1': 30,
    'int2': 31,
    'uint2': 32
}


FORMAT_DICT = {
    'NCHW': 0,
    'NHWC': 1,
    'ND': 2,
    'NC1HWC0': 3,
    'FRACTAL_Z': 4,
    'NC1C0HWPAD': 5,
    'NHWC1C0': 6,
    'FSR_NCHW': 7,
    'FRACTAL_DECONV': 8,
    'C1HWNC0': 9,
    'FRACTAL_DECONV_TRANSPOSE': 10,
    'FRACTAL_DECONV_SP_STRIDE_TRANS': 11,
    'NC1HWC0_C04': 12,
    'FRACTAL_Z_C04': 13,
    'CHWN': 14,
    'FRACTAL_DECONV_SP_STRIDE8_TRANS': 15,
    'HWCN': 16,
    'NC1KHKWHWC0': 17,
    'BN_WEIGHT': 18,
    'FILTER_HWCK': 19,
    'HASHTABLE_LOOKUP_LOOKUPS': 20,
    'HASHTABLE_LOOKUP_KEYS': 21,
    'HASHTABLE_LOOKUP_VALUE': 22,
    'HASHTABLE_LOOKUP_OUTPUT': 23,
    'HASHTABLE_LOOKUP_HITS': 24,
    'C1HWNCoC0': 25,
    'MD': 26,
    'NDHWC': 27,
    'FRACTAL_ZZ': 28,
    'FRACTAL_NZ': 29,
    'NCDHW': 30,
    'DHWCN': 31,
    'NDC1HWC0': 32,
    'FRACTAL_Z_3D': 33,
    'CN': 34,
    'NC': 35,
    'DHWNC': 36,
    'FRACTAL_Z_3D_TRANSPOSE': 37,
    'FRACTAL_ZN_LSTM': 38,
    'FRACTAL_Z_G': 39,
    'RESERVED': 40,
    'ALL': 41,
    'NULL': 42,
    'ND_RNN_BIAS': 43,
    'FRACTAL_ZN_RNN': 44,
    'NYUV': 45,
    'NYUV_A': 46,
    'NCL': 47
}


def load_json(json_file: str):
    with open(json_file, encoding='utf-8') as file:
        json_content = json.load(file)
    return json_content


def _get_dtype_key(dtype):
    if dtype is None:
        raise Exception(f"error: lack of dtype description")
    if isinstance(dtype, str):
        if dtype in DATA_TPYE_DICT:
            return '{:x}'.format(DATA_TPYE_DICT[dtype])
    elif isinstance(dtype, int):
        return '{:x}'.format(dtype)

    raise Exception(f"error: dtype description cannot find, which is {dtype}")


def _get_format_key_from_desc(desc):
    fmt = desc.get("format")
    if fmt is None:
        raise Exception(f"error: lack of format description")
    key = ''
    fmt_big_digit = 0
    if isinstance(fmt, str):
            if fmt in FORMAT_DICT:
                fmt_big_digit = FORMAT_DICT[fmt]
    elif isinstance(fmt, int):
        fmt_big_digit = fmt & 0xFF
    sub_format = desc.get("sub_format")
    if sub_format is not None:
        fmt_big_digit += (sub_format & 0xFFFF) << 8
    c0_format = desc.get("c0_format")
    if c0_format is not None:
        fmt_big_digit += (c0_format & 0xF) << 24
    return '{:x}'.format(fmt_big_digit)


def _gen_shape_key(shape:list):
    if shape is None:
        raise Exception(f"error: lack of shape description")
    key = []
    for shape_item in shape:
        if shape_item < 0:
            raise Exception(f"error: shape of static op cannot be negtive, which is {shape_item}")
        key.append('{:x}'.format(shape_item))
    return ','.join(key)


def _gen_desc_key(desc):
    key = _get_dtype_key(desc.get("dtype")) + ','
    key += _get_format_key_from_desc(desc) + ','
    key += '({})'.format(_gen_shape_key(desc.get("shape")))
    return key


def _get_int_key(val, dtype:str):
    if dtype == 'int8':
        return '{:x}'.format(val & 0xFF)
    elif dtype == 'int16':
        return '{:x}'.format(val & 0xFFFF)
    elif dtype == 'int32':
        return '{:x}'.format(val & 0xFFFFFFFF)
    elif dtype == 'int64':
        return '{:x}'.format(val & 0xFFFFFFFFFFFFFFFF)
    elif dtype[0:4] == 'uint':
        if val < 0:
            raise Exception(f"error: dtype is {dtype} but value is negative, which is {val}")
        return '{:x}'.format(val)
    else:
        raise Exception(f"error: unsupport integer dtype: {dtype}")


def _get_float_key(val: float):
    x = struct.pack('>f', val)
    return x.hex()


def _gen_const_data_key(const_value: list, dtype: str):
    if const_value is None:
        raise Exception(f"error: valueDepend param must have const value")
    if len(const_value) > VALUE_DEPEND_CONST_VALUE_NUM_MAX:
        raise Exception(f"error: valueDepend param must less equal than {VALUE_DEPEND_CONST_VALUE_NUM_MAX},"
                        f" which is {len(const_value)}")
    const_data_key = []
    if dtype == 'float32':
        for const_value_item in const_value:
            const_data_key.append(_get_float_key(const_value_item))
    else:
        # else are all treated int
        for const_value_item in const_value:
            const_data_key.append(_get_int_key(const_value_item, dtype))
    return '[{}]'.format(','.join(const_data_key))


def _check_valuedepend_dtype_valid(dtype):
    if dtype == 'half' or dtype == 'float16' or dtype == 'bfloat16':
        raise Exception(f"error: dtype of valueDepend tensor cannot be {dtype}")


def _get_valuedepend_key(desc):
    dtype = desc.get("dtype")
    _check_valuedepend_dtype_valid(dtype)
    return ',{}'.format(_gen_const_data_key(desc.get('const_data'), dtype))


def _gen_dynamic_input_output_key(desc):
    desc_key = []
    if len(desc) > DYNAMIC_INPUT_NUM_MAX:
        logger.warn(f"input desc length must less than {DYNAMIC_INPUT_NUM_MAX},"
                        f" actual is {len(desc)}, which may impack the performace of key match")
    for single_desc in desc:
        param_type = single_desc.get('param_type')
        if param_type != 'dynamic':
            raise Exception(f"error: paramType of list tensor must be dynamic, which is {param_type}")
        single_key = _gen_desc_key(single_desc)
        if single_desc.get("value_depend"):
            single_key += _get_valuedepend_key(single_desc)
        desc_key.append(single_key)
    return ';'.join(desc_key)


def _gen_input_output_key(descs):
    if descs is None:
        raise Exception(f"error: lack of input or output description")
    key = ''
    for desc in descs:
        if desc is None:
            # placehoder when optional is not selected
            key += '/_'
        elif isinstance(desc, list):
            # dynamic
            key += '/' + _gen_dynamic_input_output_key(desc)
        else:
            param_type = desc.get("param_type")
            if param_type == "required" or param_type == "optional":
                key += '/' + _gen_desc_key(desc)
            else:
                raise Exception(f"error: paramType of tensor error, which is {param_type}")
            if desc.get("value_depend"):
                key += _get_valuedepend_key(desc)
    return key


def _gen_list_int_key(val: list):
    if val is None:
        logger.warn('attr: list int has not "value"')
        return '[]'
    list_int_key = []
    for val_item in val:
        int_val = _get_int_key(val_item, 'int64')
        list_int_key.append(int_val)
    return '[{}]'.format(','.join(list_int_key))


def _gen_list_bool_key(val: list):
    if val is None:
        logger.warn('attr: list bool has not "value"')
        return '[]'
    list_bool_key = []
    for val_item in val:
        if bool(val_item):
            list_bool_key.append('1')
        else:
            list_bool_key.append('0')
    return '[{}]'.format(','.join(list_bool_key))


def _get_attr_bool_key(attr):
    val = attr.get('value')
    if val is None:
        raise Exception(f"error: attr bool has no value")
    if bool(val):
        key = '1'
    else:
        key = '0'
    return key


def _get_attr_string_key(attr):
    val = attr.get('value')
    key = ''
    if isinstance(val, str):
        for ch in val[::-1]:
            key += '{:x}'.format(ord(ch))
    else:
        raise Exception(f"error: attr must be string type, which is {val}")
    return key


def _gen_attr_key(attr):
    key = ''
    dtype = attr.get('dtype')
    if dtype == "bool":
        key += _get_attr_bool_key(attr)
    elif dtype == "int"  or dtype == "data_type":
        val = attr.get('value')
        key += _get_int_key(val, 'int64')
    elif dtype == "string":
        key += _get_attr_string_key(attr)
    elif dtype == "float":
        val = attr.get('value')
        key += _get_float_key(val)
    elif dtype == "list_float" or dtype == "listFloat":
        val = attr.get('value')
        list_float_key = []
        for val_item in val:
            list_float_key.append(_get_float_key(val_item))
        key += '[{}]'.format(','.join(list_float_key))
    elif dtype == "list_int" or dtype == "listInt" or dtype == "list_data_type":
        val = attr.get('value')
        key += _gen_list_int_key(val)
    elif dtype == "list_bool" or dtype == "listBool":
        val = attr.get('value')
        key += _gen_list_bool_key(val)
    elif dtype == "list_list_int" or dtype == "listListInt":
        val = attr.get('value')
        list_list_int_key = []
        for val_item in val:
            list_list_int_key.append(_gen_list_int_key(val_item))
        key += '[{}]'.format(','.join(list_list_int_key))
    else:
        raise Exception(f"error: attr dtype not supported, which is {dtype}")
    return key


def _gen_attrs_key(attrs):
    if attrs is None:
        return ''
    attr_key = []
    for attr in attrs:
        attr_key.append(_gen_attr_key(attr))
    return '/{}'.format('/'.join(attr_key))


def gen_simplified_key(shape_config: str):
    shape_js = load_json(shape_config)
    logger.info(f'info : gen simplified key of shape file:{shape_config}')
    op_type = shape_js.get("op_type")
    key = ""
    if op_type is not None:
        key = op_type
    else:
        raise Exception(f"error: cannot find optype in shape json")
    impl_mode = shape_js.get("impl_mode")
    deter_flag = shape_js.get("deterministic")
    if deter_flag == "true":
        key += '/d=1'
    else:
        key += '/d=0'
    if impl_mode == "high_performance":
        key += ',p=1'
    elif impl_mode == "high_precision":
        key += ',p=2'
    else:
        key += ',p=0'
    inputs = shape_js.get("inputs")
    key += _gen_input_output_key(inputs)
    outputs = shape_js.get("outputs")
    key += _gen_input_output_key(outputs)
    attrs = shape_js.get("attrs")
    key += _gen_attrs_key(attrs)
    return key


if __name__ == "__main__":
    if len(sys.argv) <= 1:
        raise RuntimeError('arguments must greater than 1')
    print(gen_simplified_key(sys.argv[1]))
