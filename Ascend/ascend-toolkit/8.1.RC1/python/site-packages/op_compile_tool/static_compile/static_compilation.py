#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# ----------------------------------------------------------------------------
# Copyright (c) Huawei Technologies Co., Ltd. 2023. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------

import argparse
import datetime
import itertools
import json
import multiprocessing
import os
import shutil
import subprocess
import sys
import time
import stat
from collections import namedtuple

from tbe.common.utils import log as logger


from op_compiler_parse_args import OptionParser
from static_compile.gen_binary_info_config import gen_binary_info_config
from op_compiler_common import time_stamp
from op_compiler_common import trans_soc_ver_to_short
from op_compiler_common import make_dirs
from op_compiler_common import remove_tempfile
from op_compiler_common import generate_version_info

# 运行时禁止生成__pycache__/文件夹
sys.dont_write_bytecode = True
SCRIPT_DIR_PATH = os.path.dirname(os.path.realpath(__file__))

DETERMIN_DIR_MAP = {'false': 'd0', 'true': 'd1'}
# 留多种精度模式可能性
IMPL_MODE_DIR_MAP = {'': ''}

# black list of ops : will not support static compile
OP_BLACK_LIST = {'FlashAttentionScore', 'FlashAttentionScoreGrad'}


def _get_extra_option(deter, impl):
    return f'{DETERMIN_DIR_MAP[deter]}{IMPL_MODE_DIR_MAP[impl]}'


def aoe_optimization(aoe_params) -> bool:
    """
    :param aoe_params:
    aoe_params.op_tune_file: 指定调优json所在路径
    aoe_params.op_tune_mode: 指定调优模式fast/static_kernel
    aoe_params.op_tune_kernel_path: 指定调优输出路径
    aoe_params.device: 指定调优使用的device id
    aoe_params.job_type: 指定调优为算子类型
    aoe_params.log: 指定调优日志级别
    :return:
    """
    if not os.path.isdir(aoe_params.op_tune_file):
        logger.error(f'{aoe_params.op_tune_file} is not existential, please check.')
        return False
    make_dirs(aoe_params.op_tune_kernel_path)
    aoe_optimization_md = f'aoe --op_tune_file={aoe_params.op_tune_file} ' \
                          f'--op_tune_mode={aoe_params.op_tune_mode} ' \
                          f'--op_tune_kernel_path={aoe_params.op_tune_kernel_path} ' \
                          f'--device={aoe_params.device} ' \
                          f'--job_type={aoe_params.job_type} ' \
                          f'--precision_mode=must_keep_origin_dtype ' \
                          f'--log={aoe_params.log}'
    logger.debug(f'aoe_optimization_md is: {aoe_optimization_md}')
    result = subprocess.run(aoe_optimization_md, shell=True, check=False)
    if result.returncode != 0:
        logger.error('aoe execute error, please check'
                      '(ascend/log/debug/plog/plog-pid-*.log)')
        return False
    return True


def get_real_package_name(package_name: str) -> str:
    """
    :param package_name: 传入的run包名
    :return: 需要生成的run包名
    """
    logger.debug(f'default package_name is {package_name}')
    if package_name:
        if package_name.endswith('.run'):
            return package_name
        else:
            return package_name + '.run'

    formatted_time = time_stamp()
    return 'static_kernel_{}.run'.format(formatted_time[:12])


def _generate_list(operator_info_list, values, operator_info, operator_type):
    """
    :param operator_info_list: 空列表
    :param values: 当前算子的所有信息
    :param operator_info: 封装算子信息
    :param operator_type: 算子类型
    :return: 封装后的算子信息列表
    """
    for key, staticlist_info in values.items():
        if key == 'staticList':
            for i in staticlist_info:
                operator_info_list.append(operator_info(operator_type, i.get('simplifiedKey'), i.get('binPath')))


def parse_json(output_path):
    """
    :param output_path: 产物输出路径
    :return: 各个算子的信息列表，每个算子为其中一个元素
    """
    json_path = os.path.join(output_path, 'binary_info_config.json')
    with open(json_path, mode='r', encoding='utf-8') as f:
        data = json.load(f)
    operator_info_list = []
    operator_info = namedtuple('operator_info', 'operator_type, simplified_key, bin_path')
    for operator_type, values in data.items():
        _generate_list(operator_info_list, values, operator_info, operator_type)
    logger.debug(f'operator_info_list is {operator_info_list}')
    return operator_info_list


def _generate_dict(tmp_dir):
    """
    :param tmp_dir: 产物生成路径
    :return: 编译产物字典{‘产物名称’: '产物路径'}
    """
    file_dic = {}
    for root, _, files in os.walk(tmp_dir):
        for file in files:
            if file.endswith('.o') or file.endswith('.json'):
                file_dic[file] = os.path.join(root, file)
    return file_dic


def copy_files(soc_version, package_name, output_path, tmp_dir, shape_info_dir):
    """
    :param soc_version: 芯片名代号
    :param package_name: 包名
    :param output_path: 产物输出路径
    :param tmp_dir: 产物生成路径
    :param shape_info_dir: 输入的json文件路径
    :return: True/False
    """
    operator_info_list = parse_json(output_path)
    ascend_opp_path = f'{output_path}/delivery'
    operator_prefix_path = os.path.join(ascend_opp_path, 'operator_package', 'static_kernel', 'ai_core',
                                        package_name[:-4])
    logger.info('====start of copy files====')
    try:
        if os.path.exists(ascend_opp_path):
            shutil.rmtree(ascend_opp_path)
        make_dirs(os.path.join(operator_prefix_path, 'scripts'))
        make_dirs(os.path.join(operator_prefix_path, 'config', soc_version))
        make_dirs(os.path.join(operator_prefix_path, 'config', soc_version, 'shape_info'))
        make_dirs(os.path.join(ascend_opp_path, 'operator_package', 'static_kernel', 'ai_core', 'config'))

        file_dic = _generate_dict(tmp_dir)
        logger.debug(f'file dic: {file_dic}')
        for operator_info in operator_info_list:
            operator_o_name = operator_info.bin_path.split('/')[-1]
            operator_json_name = operator_o_name.replace('.o', '.json')
            dst_path = '/'.join(operator_info.bin_path.split('/')[1:-1])
            config_soc_version = dst_path.split('/')[0]
            if config_soc_version != soc_version:
                logger.error(f'soc_version({config_soc_version}) of binary_info_config.json or '
                              f'script input --soc-version({soc_version}) is not correct')
                return False
            make_dirs(os.path.join(operator_prefix_path, dst_path))
            logger.debug(f'dst_path: {dst_path}')
            if operator_o_name in file_dic:
                shutil.copy(file_dic[operator_o_name],
                            os.path.join(operator_prefix_path, dst_path))
            else:
                logger.error(f'{operator_o_name} is not found, please check.')
                return False
            if operator_json_name in file_dic:
                shutil.copy(file_dic[operator_json_name],
                            os.path.join(operator_prefix_path, dst_path))
            else:
                logger.error(f'{operator_json_name} is not found, please check.')
                return False

        # 拷贝安装卸载脚本/binary_info_config.json
        shutil.copy(os.path.join(f'{SCRIPT_DIR_PATH}', 'install.py'),
                    os.path.join(operator_prefix_path, 'scripts'))
        shutil.copy(os.path.join(f'{SCRIPT_DIR_PATH}', 'uninstall.py'),
                    os.path.join(operator_prefix_path, 'scripts'))
        shutil.copy(os.path.join(f'{SCRIPT_DIR_PATH}', 'uninstall.sh'),
                    os.path.join(operator_prefix_path, 'scripts'))
        shutil.copy(os.path.join(f'{SCRIPT_DIR_PATH}', 'help.info'),
                    os.path.join(operator_prefix_path, 'scripts'))
        shutil.copy(os.path.join(f'{output_path}', 'binary_info_config.json'),
                    os.path.join(operator_prefix_path, 'config', soc_version))

        # 拷贝shape_info_dir目录下的文件
        for root, _, files in os.walk(shape_info_dir):
            for shape_file in files:
                if not shape_file.endswith('.json'):
                    continue
                shutil.copy(os.path.join(root, shape_file),
                            os.path.join(operator_prefix_path, 'config', soc_version, 'shape_info'))

        # 生成config.ini并拷贝到对应目录
        with open(f'{ascend_opp_path}/operator_package/static_kernel/ai_core/config.ini', mode='wt',
                  encoding='utf-8') as f:
            f.write(f"load_priority={package_name[:-4]}")

        # 生成version.info
        flag, version, version_dir = generate_version_info()
        if flag:
            with open(f'{ascend_opp_path}/operator_package/static_kernel/ai_core/version.info', mode='wt',
                      encoding='utf-8') as file:
                file.write(version)
        else:
            logger.error("failed to obtain the OPP version info")
            return False
    except Exception as e:
        logger.error(e)
        return False
    finally:
        logger.info('====end of copy files====')
    return True


def compose_makeself_command(ascend_opp_path, package_name, output_path) -> tuple:
    """
    组装makeself包打包命令
    :param ascend_opp_path: 环境变量
    :param package_name: run包名
    :param output_path: run包输出路径
    :return: makeself包打包命令
    """

    father_path = os.path.dirname(ascend_opp_path)
    makeself_dir = os.path.join(father_path,
                                'tools/msopgen/template/custom_operator_sample/TIK/PyTorch/cmake/util/makeself')

    makeself_tool = os.path.join(makeself_dir, 'makeself.sh')
    if not os.path.isfile(makeself_tool):
        return None, f"makeself_tool({makeself_tool}) does not exist."
    makeself_header = os.path.join(makeself_dir, 'makeself-header.sh')
    if not os.path.isfile(makeself_header):
        return None, f"makeself_header({makeself_header}) does not exist."
    help_info = os.path.join(output_path, 'delivery', 'operator_package', 'static_kernel', 'ai_core',
                             package_name[:-4],
                             'scripts', 'help.info')
    install_script = os.path.join('static_kernel', 'ai_core',
                                  package_name[:-4],
                                  'scripts', 'install.py')

    comments = '"STATIC KERNEL RUN PACKAGE"'
    commands = itertools.chain(
        [makeself_tool, "--header", makeself_header, "--help-header", help_info, '--complevel', '4',
         '--nomd5', '--sha256', '--nooverwrite', '--chown', '--tar-format', 'gnu',
         '--tar-extra', '--numeric-owner', '--tar-quietly'
         ],
        [f'{output_path}/delivery/operator_package', package_name, comments, install_script]
    )

    command = ' '.join(commands)
    return command, ''


def create_run_package_command(package_name, output_path):
    """
    :param package_name: run包名
    :param output_path: run包输出路径
    :return: True/False
    """
    ascend_opp_path = os.environ.get('ASCEND_OPP_PATH')
    if not ascend_opp_path:
        return False, 'please setting ASCEND_OPP_PATH'
    makeself_cmd, data = compose_makeself_command(ascend_opp_path,
                                                  package_name,
                                                  output_path
                                                  )
    if not makeself_cmd:
        logger.error(data)
        return False, ''
    run_package_cmd = f'cd {output_path} && {makeself_cmd}'
    logger.debug(f'run_package_cmd: {run_package_cmd}')
    status, data = subprocess.getstatusoutput(run_package_cmd)
    if status != 0:
        return False, data
    return True, data


def rm_run_package(output_path, package_name):
    """
    :param output_path: run包输出路径
    :param package_name: run包名称
    :return:None
    """
    rm_cmd = f'rm -rf {output_path}/{package_name}'
    logger.debug(f'rm_cmd: {rm_cmd}')
    status, data = subprocess.getstatusoutput(rm_cmd)
    if status != 0:
        logger.error(f'remove run package{package_name} failed. the reason is {data}')


def install_run_package(output_path, package_name):
    """
    :param output_path: run包输出路径
    :param package_name: run包名称
    :return: True/False
    """
    install_cmd = f'cd {output_path} && ' \
                  f'chmod +x {package_name} ' \
                  f'&& ./{package_name}'
    logger.debug(f'install_cmd: {install_cmd}')
    status, data = subprocess.getstatusoutput(install_cmd)
    if status != 0:
        logger.error(f'install run package ({package_name}) failed. the reason is {data}')
        return False
    else:
        logger.info(data)
    rm_run_package(output_path, package_name)
    return True


def _modify_fileds_into_opc_format(param):
    dtype = param.get('dtype')
    if dtype == 'float':
        param['dtype'] = 'float32'
    param_type = param.get('param_type')
    if param_type is not None:
        param['paramType'] = param_type
        del param['param_type']
    const_data = param.get('const_data')
    if const_data is not None:
        param['const_value'] = const_data
        del param['const_data']


def _modify_json_file_into_opc_format(params):
    for param in params:
        if param is None:
            continue
        if isinstance(param, list):
            for item in param:
                _modify_fileds_into_opc_format(item)
        else:
            _modify_fileds_into_opc_format(param)


def _trans_dump_file_into_opc_format(json_dir, json_file, opc_dump_dir):
    with open(os.path.join(json_dir, json_file), encoding='utf-8') as file:
        js = json.load(file)
        op_type = js.get('op_type')
        if op_type is None:
            raise Exception(f"error: cannot find field op_type in dump shape json: {json_file}")
        del js['op_type']
        for params in ['inputs', 'outputs', 'attrs']:
            _modify_json_file_into_opc_format(js.get(params))
        bin_filename = js.get('bin_filename')
        if bin_filename is None:
            js['bin_filename'] = json_file[:-5]
        js_out = {}
        js_out['op_type'] = op_type
        js_out['op_list'] = [js]
        wr_flag = os.O_WRONLY | os.O_CREAT
        wr_mode = stat.S_IWUSR | stat.S_IRUSR
        dump_opc_format_path = os.path.join(opc_dump_dir, json_file)
        with open(dump_opc_format_path, 'w') as file_path:
            json.dump(js_out, file_path, sort_keys=True, indent=2, separators=(',', ':'))


def _trans_dump_dir_into_opc_format(shape_info, opc_dump_dir):
    make_dirs(opc_dump_dir)
    opc_json_list = []
    for root, _, files in os.walk(shape_info):
        for file in files:
            if file.endswith('.json'):
                _trans_dump_file_into_opc_format(root, file, opc_dump_dir)
                opc_json_list.append(os.path.join(opc_dump_dir, file))
    return opc_json_list


def _opc_compile_single(opc_json, compile_res_dir, soc_version, log_level):
    opc_compile_md = f'opc --input_param={opc_json} ' \
                     f'--output={compile_res_dir} ' \
                     f'--op_mode=static ' \
                     f'--soc_version={soc_version} ' \
                     f'--log={log_level} '
    logger.debug(f'opc_compile_md is: {opc_compile_md}')
    result = subprocess.run(opc_compile_md, shell=True, check=False)
    if result.returncode != 0:
        logger.error('opc execute error, please check'
                      '(ascend/log/debug/plog/plog-pid-*.log)')


def _opc_compile(opc_params):
    if not os.path.isdir(opc_params.shape_info):
        logger.error(f'{opc_params.shape_info} is not existential, please check.')
        return False
    make_dirs(opc_params.compile_res_dir)
    opc_json_list = _trans_dump_dir_into_opc_format(opc_params.shape_info, opc_params.opc_dump_dir)

    from multiprocessing import Pool
    from functools import partial
    with Pool(opc_params.job) as pool:
        pool.map(partial(_opc_compile_single, compile_res_dir=opc_params.compile_res_dir, \
                         soc_version=opc_params.soc_version, log_level=opc_params.log_level), opc_json_list)
    return True


def _extent_shape_json_content(shape_extent_dir, file, js):
    # filter : only all and static_kenrel will go on static compile
    tune_mode = js.get('tune_mode')
    if tune_mode is not None and tune_mode not in ['all', 'static_kernel']:
        logger.warn(f'{file} tune mode is "{tune_mode}", only support "all" and "static_kernel".')
        return
    # OP BLACK LIST FILTER
    op_type = js.get('op_type')
    if op_type in OP_BLACK_LIST:
        logger.warn(f'op compiler tool do not support static compile of op type: {op_type}')
        return
    bin_file_name = js.get('bin_filename')
    for deter in DETERMIN_DIR_MAP:
        for impl in IMPL_MODE_DIR_MAP:
            extra_option = _get_extra_option(deter, impl)
            js['deterministic'] = deter
            if bin_file_name is not None:
                js['bin_filename'] = f'{bin_file_name}_{extra_option}'
            # when we need impl mode, can add js['impl_mode'] = impl here
            with open(os.path.join(shape_extent_dir, f'{file[:-5]}_{extra_option}.json'), 'w') as file_path:
                json.dump(js, file_path, sort_keys=True, indent=2, separators=(',', ':'))


def _extent_shape_json(shape_info, shape_extent_dir):
    if os.path.exists(shape_extent_dir):
        shutil.rmtree(shape_extent_dir)
    if not os.path.exists(shape_extent_dir):
        os.mkdir(shape_extent_dir)

    for root, _, files in os.walk(shape_info):
        for file in files:
            if not file.endswith('.json'):
                continue
            with open(os.path.join(root, file), encoding='utf-8') as f:
                js = json.load(f)
                _extent_shape_json_content(shape_extent_dir, file, js)


def static_kernel_compile(parameters: OptionParser):
    # 获取执行参数
    shape_info, soc_version, package_name, compile_mode, output_path, job, log_level, install_flag = (
        parameters.full_options["--op_params_dir"].get_value(),
        parameters.full_options["--soc_version"].get_value(),
        parameters.full_options["--package_name"].get_value(),
        parameters.full_options["--compile_mode"].get_value(),
        parameters.full_options["--output_path"].get_value(),
        int(parameters.full_options["--job"].get_value()),
        parameters.full_options["--log"].get_value().lower(),
        None
    )
    if job < 1:
        logger.error(f'job must greater or equal than 1, but actual is {job}, reset to 1')
        job = 1
    logger.debug(f'multi jobs num has been set: {job}')
    shape_extent_dir = f'{output_path}/{os.path.basename(os.path.realpath(shape_info))}_extent'
    _extent_shape_json(shape_info, shape_extent_dir)
    binary_json_file = f'{output_path}/binary_info_config.json'
    try:
        if not os.path.exists(output_path):
            logger.error(f'{output_path} is not existential, please check.')
            return False
        if not os.access(output_path, os.W_OK):
            logger.error(f'{output_path} do not have the write permission., please setting.')
            return False

        formatted_time = time_stamp()
        compile_res_dir = f'{output_path}/tmp_{formatted_time[:12]}'
        opc_dump_dir = f'{output_path}/opcdump_{formatted_time[:12]}'

        opc_params = namedtuple('opc_params', \
                                'shape_info, opc_dump_dir, soc_version, job, log_level, compile_res_dir')
        aoe_params = namedtuple('aoe_params', \
                                'op_tune_file, op_tune_mode, op_tune_kernel_path, device, job_type, log')

        if compile_mode == "tune" or compile_mode == "aoe":
            # 调用aoe调优工具
            print("[Aoe tool compile]")
            if compile_mode == "tune":
                aoe_mode = "static_kernel"
            else:
                aoe_mode = "fast"
            status = aoe_optimization(aoe_params(shape_extent_dir, aoe_mode, compile_res_dir, 0, 2, log_level))
            if not status:
                logger.error('aoe_optimization execute failed.')
                return False
            logger.info('aoe_optimization execute success')
        else:
            # opc mode
            print("[Opc compile]")
            _opc_compile(opc_params(shape_extent_dir, opc_dump_dir, soc_version, job, log_level, compile_res_dir))

        short_soc_version = trans_soc_ver_to_short(soc_version)

        gen_binary_info_config(package_name[:-4], short_soc_version, shape_extent_dir, compile_res_dir,
                               binary_json_file)

        # 拷贝文件
        status = copy_files(short_soc_version, package_name, output_path, compile_res_dir, os.path.realpath(shape_info))
        if not status:
            logger.error('copy_files execute failed.')
            return False
        logger.debug('copy_files execute success')

        # 打包成run包
        status, data = create_run_package_command(package_name, output_path)
        if not status:
            logger.error(f'run_package_cmd execute failed. the reason is {data}')
            return False
        print(f'generate run package {package_name} success')
        logger.info(f'generate run package {package_name} success')

        # 安装run包
        if install_flag:
            status = install_run_package(output_path, package_name)
            if not status:
                return False
            logger.info(f'install run package {package_name} success')
        return True
    finally:
        delivery_dir = os.path.join(output_path, 'delivery')
        if os.path.exists(delivery_dir):
            shutil.rmtree(delivery_dir)
        if log_level != 'debug':
            remove_tempfile([compile_res_dir, opc_dump_dir, shape_extent_dir, binary_json_file])
