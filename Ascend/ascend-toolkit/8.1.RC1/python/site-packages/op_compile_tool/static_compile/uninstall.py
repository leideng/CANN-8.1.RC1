#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# ----------------------------------------------------------------------------
# Copyright Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
# ----------------------------------------------------------------------------
import json
import logging
import os
import subprocess
import sys
import shutil
import time
import re

# 运行时禁止生成__pycache__/文件夹
sys.dont_write_bytecode = True


def setting_logformat(log_level='INFO'):
    """
    :param log_level: 设置安装日志级别
    :return: None
    """
    if log_level.upper() not in ['DEBUG', 'INFO', 'WARNING', 'ERROR']:
        logging.error(f'{log_level} is not the correct configuration option')

    log_format = "%(asctime)s-%(levelname)s-%(message)s"
    date_format = "%m/%d/%Y %H:%M"
    logging.basicConfig(level=log_level, format=log_format, datefmt=date_format)


class UninstallPackage:
    def __init__(self, args):
        self.uninstall_mode = args[0] if len(args) == 1 else ''
        self.script_dir = os.path.dirname(os.path.realpath(__file__))
        self.package_dir = os.path.dirname(self.script_dir)
        self.package_prefix_dir = os.path.dirname(self.package_dir)
        self.package_name = os.path.basename(self.package_dir)
        self.install_path = os.path.dirname(os.path.dirname(self.package_prefix_dir))
        self.soc_version = ''

    def __update_config_ini(self):
        ini_file = os.path.join(self.package_prefix_dir, 'config.ini')
        for root, _, files in os.walk(f'{self.package_dir}/config'):
            for file in files:
                if file == 'binary_info_config.json':
                    self.soc_version = os.path.basename(root)
                    logging.info(f'soc_version:---{self.soc_version}---')
                    break
        with open(ini_file, mode='r') as f:
            data = f.read()
        update_data = data.replace(f'={self.package_name},', '=').replace(f',{self.package_name}', '').replace(
            f'{self.package_name}', '').strip()
        logging.info('read and update config.ini settings')
        with open(ini_file, mode='w') as f:
            f.write(update_data)

        if update_data.endswith('='):
            return []
        package_list = update_data.split('=')[-1].split(',')

        return package_list

    def _update_uninstall_file(self, package_list):
        src_file = f'{self.package_prefix_dir}/uninstall.sh'
        with open(src_file, mode='r') as file:
            data = file.read()
        logging.debug(data)
        pattern = r'(?<=/)[^/]+(?=/scripts)'
        data = re.sub(pattern, package_list[-1], data)

        with open(src_file, mode='w') as file:
            file.write(data)
        os.chmod(src_file, 0o755)

    def update_shape_info(self, package_list):
        # 清空所有已存在的且soc_version相同的shape_info文件夹
        for root, dirs, _ in os.walk(f'{self.package_prefix_dir}/config/', topdown=False):
            for shape_info_dir in dirs:
                if shape_info_dir == 'shape_info' and self.soc_version in root:
                    logging.debug(f'shape_info_dir is: {root}/{shape_info_dir}')
                    shutil.rmtree(os.path.join(root, shape_info_dir))
        # shape_file更新
        shape_info_dir_list = []
        for i in package_list:
            if os.path.isdir(f'{self.package_prefix_dir}/{i}/config/{self.soc_version}/shape_info'):
                shape_info_dir_list.append(f'{self.package_prefix_dir}/{i}/config/{self.soc_version}/shape_info')
        if len(shape_info_dir_list) == 0:
            return
        if not os.path.isdir(f'{self.package_prefix_dir}/config/{self.soc_version}/shape_info'):
            os.makedirs(f'{self.package_prefix_dir}/config/{self.soc_version}/shape_info')
        for shape_info_dir in shape_info_dir_list:
            for root, dirs, files in os.walk(shape_info_dir):
                for shape_file in files:
                    shutil.copy2(os.path.join(root, shape_file),
                                 f'{self.package_prefix_dir}/config/{self.soc_version}/shape_info')

    def update_json(self):
        package_list = self.__update_config_ini()
        if self.uninstall_mode != '':
            package_list = []
        logging.debug(f'package_list: ---{package_list}---')
        logging.info('ready to update binary_info_config.json')
        if len(package_list) == 0:
            logging.debug('删除整个目录')
            shutil.rmtree(f'{self.install_path}/static_kernel/ai_core')
            return True
        self._update_uninstall_file(package_list)
        json_list = [f'{self.package_prefix_dir}/{i}/config/{self.soc_version}/binary_info_config.json'
                     for i in package_list if
                     os.path.isfile(f'{self.package_prefix_dir}/{i}/config/{self.soc_version}/binary_info_config.json')]
        logging.debug(f'json_list: ---{json_list}---')
        if len(json_list) >= 1:
            with open(json_list[0], mode='r') as f:
                src_info = json.load(f)
            del json_list[0]
            src_info = self.__parse_json(src_info, json_list)
            logging.debug(f'comment of binary_info_config.json is: {src_info}')
            with open(f'{self.package_prefix_dir}/config/{self.soc_version}/binary_info_config.json', mode='w') as f:
                json.dump(src_info, f, indent=4, sort_keys=True)

            shutil.rmtree(self.package_dir)
            self.update_shape_info(package_list)

        else:
            logging.debug('删除当前子包整个目录')
            shutil.rmtree(f'{self.package_prefix_dir}/config/{self.soc_version}')
            shutil.rmtree(self.package_dir)
            return True

        return True

    @staticmethod
    def __update_src_info(key: str, dst_info: dict, src_info: dict) -> dict:
        if 'valueDependIndex' in dst_info[key]:
            src_info[key]['valueDependIndex'] = dst_info[key]['valueDependIndex']
        elif 'valueDependIndex' in src_info[key]:
            del src_info[key]['valueDependIndex']

        if 'simplifiedKeyMode' in dst_info[key]:
            src_info[key]['simplifiedKeyMode'] = dst_info[key]['simplifiedKeyMode']
        elif 'simplifiedKeyMode' in src_info[key]:
            del src_info[key]['simplifiedKeyMode']
        for i in dst_info[key]['staticList']:
            simplified_key = i['simplifiedKey']
            for index, j in enumerate(src_info[key]['staticList']):
                if simplified_key == j['simplifiedKey']:
                    src_info[key]['staticList'][index] = i
                    break
            else:
                src_info[key]['staticList'].append(i)

    def __parse_json(self, src_info, json_list):
        if len(json_list) >= 1:
            with open(json_list[0], mode='r') as f:
                dst_info = json.load(f)
            keys_list = dst_info.keys()
            for key in keys_list:
                if key not in src_info:
                    src_info.setdefault(key, dst_info[key])
                    continue
                self.__update_src_info(key, dst_info, src_info)
            logging.debug(f'src_info: {src_info}')

            del json_list[0]
            if len(json_list) < 1:
                return src_info
        else:
            return src_info
        return self.__parse_json(src_info, json_list)


def process_query():
    pid = os.getpid()
    query_cmd = f'ps -ef | grep "python.*uninstall.py" | grep -v grep | grep -v {pid}'
    logging.debug(f'pid: {pid}')
    for _ in range(5):
        _, data = subprocess.getstatusoutput(query_cmd)
        logging.debug(f'{data}, type is {type(data)}')
        if data:
            logging.warning('maybe someone else execute uninstall of STATIC KERNEL RUN PACKAGE')
            logging.warning('please wait a little while')
            time.sleep(1)
        else:
            return True

    logging.error('wait too long time, please check uninstall in process_cmd(ps -ef | grep uninstall)')
    return False


def main():
    setting_logformat()
    status = process_query()
    if not status:
        return False
    args = sys.argv[1:]
    if len(args) != 0 and len(args) != 1:
        logging.error(f'number of input parameters is not right')
        return False
    worker = UninstallPackage(args)
    worker.update_json()
    return True


if __name__ == '__main__':
    if not main():
        sys.exit(1)
