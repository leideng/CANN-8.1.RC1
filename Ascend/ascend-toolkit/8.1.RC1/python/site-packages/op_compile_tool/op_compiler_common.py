#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# ----------------------------------------------------------------------------
# Copyright (c) Huawei Technologies Co., Ltd. 2023. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------

"""
op compiler common
"""
import os
import sys
import time
import datetime
import logging
import inspect
import shutil
from collections import namedtuple
from typing import List, Tuple, Dict
from tbe.common.utils import log as logger
import configparser 
import platform   


# 运行时禁止生成__pycache__/文件夹
sys.dont_write_bytecode = True


LOG_LEVEL_DICT = {
    "debug": 0,
    "info": 1,
    "warning": 2,
    "error": 3,
}


SOC_TO_SHORT_SOC_MAP = {}


PLATFORM_INFO = {}


op_type_list = {
    "MatMulV2" : "MatMul"
}


class OPTOptions:
    """
    op compile tool support arguments
    """
    # 1.command line arguments
    HELP = "help"
    HELP_H = "h"

    # required(必填)
    SOC_VERSION = "soc_version"
    SOC_VERSION_V = "v"

    # optional(非必填)
    OP_PARAMS_DIR = "op_params_dir"
    OP_PARAMS_DIR_P = "p"
    KERNEL_NAME = "kernel_name"
    KERNEL_NAME_K = "k"
    OP_TYPE = "op_type"
    OP_TYPE_T = "t"
    OP_DEBUG_CONFIG = "op_debug_config"
    OP_DEBUG_CONFIG_D = "d"
    OUTPUT = "output"
    OUTPUT_O = "o"
    COMPILE_MODE = "compile_mode"
    COMPILE_MODE_M = "m"
    JOB = "job"
    JOB_J = "j"
    LOG = "log"
    LOG_L = "l"

    OUTPUT_PATH = "output_path"
    PACKAGE_NAME = "package_name"

    COUNT = "count"


COMPILING_OPTION_KEYS = [
    OPTOptions.HELP, OPTOptions.HELP_H,
    OPTOptions.OP_PARAMS_DIR, OPTOptions.OP_PARAMS_DIR_P,
    OPTOptions.SOC_VERSION, OPTOptions.SOC_VERSION_V,
    OPTOptions.OUTPUT, OPTOptions.OUTPUT_O,
    OPTOptions.KERNEL_NAME, OPTOptions.KERNEL_NAME_K,
    OPTOptions.OP_TYPE, OPTOptions.OP_TYPE_T,
    OPTOptions.OP_DEBUG_CONFIG, OPTOptions.OP_DEBUG_CONFIG_D,
    OPTOptions.COMPILE_MODE, OPTOptions.COMPILE_MODE_M,
    OPTOptions.JOB, OPTOptions.JOB_J,
    OPTOptions.LOG, OPTOptions.LOG_L,
    OPTOptions.COUNT
]


Parameter_Mapping = [
    ["-h", "--help"],
    ["-l", "--log"],
    ["-p", "--op_params_dir"],
    ["-o", "--output"],
    ["-k", "--kernel_name"],
    ["-t", "--op_type"],
    ["-d", "--op_debug_config"],
    ["-v", "--soc_version"],
    ["-m", "--compile_mode"],
    ["-j", "--job"],
    ["--count"]
]


def get_platform():
    """
    Obtaining Related Architecture Information
    """    
    architecture = platform.machine()  
    PLATFORM_INFO["architecture"] = architecture
    logger.debug(f"architecture is {architecture}")


def parse_platform_config(path: str):  
    """
    Parse the platform_config file activity to the corresponding soc_verison.
    :params: path:
    """
    for root, _, files in os.walk(path):  
        for file in files:  
            if file.endswith(".ini"):  
                file_path = os.path.join(root, file)  
                parse_ini(file_path)  
    logger.debug(f"SOC_TO_SHORT_SOC_MAP is {SOC_TO_SHORT_SOC_MAP}")


def parse_ini(file_path):  
    """
    Parse soc_version and short_soc_version.
    :params: path:
    """
    config = configparser.ConfigParser()  
    version_key = "version"
    try:  
        config.read(file_path)  
        if version_key in config:  
            soc_version = config[version_key].get('soc_version', None)  
            short_soc_version = config[version_key].get('short_soc_version', None)  
            if soc_version and short_soc_version:  
                SOC_TO_SHORT_SOC_MAP[soc_version.lower()] = short_soc_version.lower()  
            else:  
                logger.exception(f"Missing soc_version or short_soc_version in {file_path}")
    except Exception as e: 
        logger.error(f" parsing {file_path}: {e}") 


def verify_pathfile_exist_permission(path_file: str, type_: str, modes: str) -> bool:
    """
    verify that the input path exists
    :params: path:
             type: path/file
             model: e/r/w/x
    :return: True/False
    """
    exist_state = None
    r_permission_state = None
    w_permission_state = None
    x_permission_state = None
    modes = modes.lower() 
    pathfile_state = namedtuple("pathfile_state", \
        ["status", "exist_state", "r_permission_state", "w_permission_state", "x_permission_state"])
    try:
        for mode in modes:
            if mode == "e":
                if type_ == "path":
                    exist_state = False if not os.path.isdir(path_file) else True
                elif type_ == "file":
                    exist_state = False if not os.path.isfile(path_file) else True
            elif mode == "r":
                r_permission_state = True if os.access(path_file, os.R_OK) else False
            elif mode == "w":
                w_permission_state = True if os.access(path_file, os.W_OK) else False
            elif mode == "x":
                x_permission_state = True if os.access(path_file, os.X_OK) else False
    except Exception as e:
        logger.exception(f"failed to verify file or dir attributes.")
        return pathfile_state(False, exist_state, r_permission_state, w_permission_state, x_permission_state)

    return pathfile_state(True, exist_state, r_permission_state, w_permission_state, x_permission_state)


def time_stamp() -> str:
    """
    get time stamp
    :return: time stamp
    """
    timestamp = time.time()
    dt = datetime.datetime.fromtimestamp(timestamp)
    formatted_time = dt.strftime('%y%m%d%H%M%S%f')
    return formatted_time


def get_opp_path() -> Tuple[bool, str]:
    """
    get opp path
    :return: True/False, opp_path
    """
    opp_path = None
    try:
        opp_path = os.environ["ASCEND_OPP_PATH"]
        opp_path = os.path.realpath(opp_path)
        outputpath_state = verify_pathfile_exist_permission(opp_path, "path", "erwx")
        if not outputpath_state.exist_state:
            logger.error(f"[{path}] path does not exist. please check.")
            return False, opp_path
        if not outputpath_state.w_permission_state or not outputpath_state.r_permission_state:
            logger.error(f"[{path}] do not have the read or write permission., please setting.")
            return False, opp_path
        logger.debug("obtaining ASCEND_OPP_PATH succeeded.")
    except Exception as e:
        logger.exception(f"failed to obtain ASCEND_OPP_PATH, please setting environment variable, {e}")
        return False, opp_path
    return True , opp_path


def judgment_option_exist(key: str, options: dict) -> bool:
    """
    check whether the key exists in the compilation parameter.
    :params: key
             options
    :return: True/False
    """
    if len(key) == 1:
        short_key = key
        temp_key = "-" + key
        for item in Parameter_Mapping:
            if item[0] == temp_key:
                long_key = item[-1][2:]
    else:
        long_key = key
        temp_key = "--" + key
        for item in Parameter_Mapping:
            if item[-1] == temp_key:
                short_key = item[0][1:]
    if short_key in options or long_key in options:
        return True
    return False


def trans_soc_ver_to_short(soc_ver: str) -> str:
    """
    :params: soc version
    :return: soc version
    """
    low_soc_ver = soc_ver.lower()
    if low_soc_ver not in SOC_TO_SHORT_SOC_MAP:
        logger.warn(f'WARNING: caution: {soc_ver} will trans into ascend910, if not your intention,'
                        f'use ascend910b1~4 instead')
    logger.debug(f'{soc_ver} has trans into {SOC_TO_SHORT_SOC_MAP[low_soc_ver]}')
    return SOC_TO_SHORT_SOC_MAP[low_soc_ver]


def make_dirs(dir_path: str) -> bool:
    """
    :params: dir path
    :return: True/False
    """
    try:
        if not verify_pathfile_exist_permission(dir_path, "path", "e").exist_state:
            os.makedirs(dir_path)
            logger.debug(f"{dir_path} created successfully.")
        else:
            if not verify_pathfile_exist_permission(dir_path, "path", "w ").w_permission_state \
                or not verify_pathfile_exist_permission(dir_path, "path", "r").r_permission_state:
                logger.warn(f"{dir_path} already exists, but do not have the read or write permission")
                os.chmod(dir_path, 0o755)
                logger.warn(f"set the 755 permission for {dir_path}.")
    except Exception as e:
        logger.exception(f"{dir_path} created failed.")
        return False
    return True


def remove_tempfile(dirfile_list: list):
    """
    :params: dirfile path list
    """
    for dirfile in dirfile_list:
        if not os.path.exists(dirfile):
            continue
        if os.path.isdir(dirfile):
            try:
                shutil.rmtree(dirfile)
                logger.debug(f"deleting succeeded, [{dirfile}]")
            except Exception as e:
                logger.warn(f"failed to delete [{dirfile}]")
        elif os.path.isfile(dirfile):
            try:
                os.remove(dirfile)
                logger.debug(f"deleting succeeded, [{dirfile}]")
            except Exception as e:
                logger.warn(f"failed to delete [{dirfile}]")


def camel_to_snake(hump_variable: str) -> str:
    """
    :params: variable name
    :return: True/False, Version, version_dir
    """
    snake_case = ""
    for index, char in enumerate(hump_variable):
        if index != 0 and char.isupper():
            snake_case += "_" + char.lower()
        elif index == 0 and char.isupper():
            snake_case += char.lower()
        else:
            snake_case += char
    return snake_case


def generate_version_info() -> Tuple[bool, str, str]:
    """
    :return: True/False, version, version_dir
    """
    version, version_dir = None, None
    flag, ascend_opp_path = get_opp_path()
    if not flag:
        return False, version, version_dir
    try:
        with open(f'{ascend_opp_path}/version.info', mode='r') as file:
            for line in  file.readlines():
                if "version=" in line:
                    version = line
                elif "version_dir=" in line:
                    version_dir = line
    except Exception as e:
        logger.exception(f"failed to open {ascend_opp_path}/version.info")
        return False, version, version_dir
    if version and version_dir:
        return True, version, version_dir
    else:
        return False, version, version_dir


def path_conversion(path: str) -> Tuple[bool, str]:
    """
    convert a path to an absolute path
    :params: path
    :return: True/False, path
    """
    real_path = None
    if path:
        try:
            real_path = os.path.realpath(path)
        except Exception as e:
            logger.exception(f"path conversio failed, {path}")
            return False, real_path
        return True, real_path
    logger.debug(f"input parameter is invalid, {path}")
    return False, real_path


def del_dict(dict_: dict, key_list: list, kernel_dyn_binary_json) -> dict:
    """
    :params: dict_
    :return: dict
    """  
    for key in key_list:
        if key in dict_:
            dict_.pop(key)
        else:
            logger.warn(f"key  {key} does not exist in the dictionary {dict_}.")
    return dict_
        

def corrections_op_type(op_type: str) -> str:
    """
    :params: op_type
    :return: op_type
    """
    if op_type in op_type_list:
        return op_type_list[op_type]
    return op_type
