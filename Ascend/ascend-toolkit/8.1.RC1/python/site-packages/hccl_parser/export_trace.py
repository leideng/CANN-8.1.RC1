#!/usr/bin/env python
# coding=utf-8

# Copyright (c) Huawei Technologies Co., Ltd. 2017-2019. All rights reserved.
# description: trace文件导出
# Create: 2021-5-5

import os
import json
import shutil

def find_op_start_ts(hwts_trace, stid_list, online_mode):
    iter_num = 0
    start_ts_list = []
    flag = True
    while flag:
        if not stid_list[0]:
            return []
        start_ts = float('inf')
        for stid in stid_list[0]:
            stid_key = (stid[0], stid[1], stid[2])
            if hwts_trace.get(stid_key, None) is None:
                flag = False
                break
            else:
                if len(hwts_trace[stid_key]) <= 2 * iter_num:
                    flag = False
                    break
                start_ts = min(start_ts, hwts_trace[stid_key][2*iter_num][0])
        if flag:
            start_ts_list.append([stid_list, iter_num, start_ts])
        # 表示是单算子模式，匹配一次
        if online_mode == 1:
            flag = False
        iter_num += 1
    return start_ts_list

def find_first_time_list(hwts_trace, stid_lists, max_num, online_mode):
    start_ts_list = []
    for stid_list in stid_lists:
        start_ts_list += find_op_start_ts(hwts_trace, stid_list, online_mode)
    start_ts_list.sort(key=lambda x: x[-1])
    start_ts_list = start_ts_list[:max_num]
    return start_ts_list

# get_op_from_ops 功能：根据返回的hwts index中的sid，tid，索引到具体的op
def get_op_from_ops(id, ops):
    ret_ops = []
    for op in ops:
        if op['tag'] == id[0][-1]:
            ret_ops.append(op)
            return ret_ops
    return ret_ops

#这里有个偏差：老工具使用devicedata，包括了所有的op，现在的要求是针对给定op
class TaskRecord:

    __slots__ = ('iteration_num', 'start_ts', 'end_ts', \
                 'duration', 'bandwidth')

    def __init__(self, iteration_num, start_ts, end_ts='NULL', bandwidth=None):
        self.iteration_num = iteration_num
        self.start_ts = start_ts
        self.end_ts = end_ts
        if end_ts == 'NULL':
            self.duration = 'NULL'
        else:
            self.duration = end_ts - start_ts
        self.bandwidth = bandwidth

    def cal_bandwidth(self, datasize):
        if datasize is not None and self.duration != 'NULL':
            if self.duration == 0:
                self.duration = 100
            self.bandwidth = round(datasize / 1000.0 / self.duration, 2)
        else:
            self.bandwidth = 'NULL'

# mode B: 针对给定的op，从指定的index开始，遍历每个task，给每个task赋值hwts的时间戳
def hccl_relate_hwts_mode_b(devicedata, hwts_trace, iter_num):
    for stream in devicedata.stream:
        for task in stream.task:
            stid_key = (stream.stream_id, task.task_id, task.batch_id)
            if hwts_trace.get(stid_key) is None:
                continue
            if (iter_num < len(hwts_trace[stid_key]) // 2):
                if hwts_trace[stid_key][2*iter_num][0] != 0:
                    hwts_trace[stid_key].insert(2*iter_num, (0, 0xffffffff))
                    print('[{}][{}]: lost start task'.format(task.op_type, iter_num))
                start_ts = hwts_trace[stid_key][2 * iter_num][-1]
                if hwts_trace[stid_key][2*iter_num+1][0] != 1:
                    hwts_trace[stid_key].insert(2*iter_num+1, (1, 0xffffffff))
                    print('[{}][{}]: lost end task'.format(task.op_type, iter_num))
                end_ts = hwts_trace[stid_key][2 * iter_num + 1][-1]
            else:
                start_ts = 0xffffffff
                end_ts = 0xffffffff
                print('[{}][{}]: lost task'.format(task.op_type, iter_num))
            tmp_task_record = TaskRecord(0, start_ts, end_ts)
            tmp_task_record.cal_bandwidth(task.datasize)
            task.add_task_record(tmp_task_record)

# export_result 功能描述:生成最终的json文件
def export_result(deviceid, server_data, out_path):
    if os.path.exists(out_path):
        shutil.rmtree(out_path)
        os.mkdir(out_path)

    i = 1
    # devicedata个数表示迭代轮数
    for devicedata in server_data:
        trace_events = []
        for stream in devicedata.stream:

            for task in stream.task:
                planeid = task.plane_id
                deviceid = devicedata.device_id
                if len(task.task_record) > 0:
                    start_ts = task.task_record[0].start_ts
                    duration = task.task_record[0].duration
                    bandwidth = task.task_record[0].bandwidth

                name = task.name
                notifyid = task.notify_id
                stage = task.stage
                step = task.step
                streamid = stream.stream_id
                taskid = task.task_id
                tag = task.op_type
                tasktype = task.task_type
                src_rank = task.src_rank
                dst_rank = task.dst_rank
                transport_type = task.transport_type
                size = task.datasize

                trace_events.append({
                    "tid": planeid,
                    "pid": deviceid,
                    "ts": start_ts,
                    "dur": duration,
                    "ph": "X",
                    "name": name,
                    "args": {
                        "notify id": notifyid,
                        "duration estimated": duration,
                        "stage": stage,
                        "step": step,
                        "bandwidth(Gbyte/s)": bandwidth,
                        "stream id": streamid,
                        "task id": taskid,
                        "task type": tasktype,
                        "src rank": int(src_rank),
                        "dst rank": int(dst_rank),
                        "transport type": transport_type,
                        "size(Byte)": size,
                        "tag": tag
                    }
                })

        tag = devicedata.stream[0].task[0].op_type
        out_dict = {"device id": deviceid, "iteration": i, \
                    "traceEvents": trace_events}
        json_content = json.dumps(out_dict)
        file_name = '%s%s%s%s' % (tag, os.sep, 'iter', str(i))
        i = i + 1
        if not out_path.endswith('/'):
            out_path = '%s%s' % (out_path, '/')
        file_path = out_path + tag
        if not os.path.exists(file_path):
            os.makedirs(file_path)
        ret_path = '%s%s%s' % (out_path, file_name, '.trace')
        with open(ret_path, 'w') as fout:
            fout.write(json_content)
