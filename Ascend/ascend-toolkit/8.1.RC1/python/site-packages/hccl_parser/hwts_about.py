#!/usr/bin/env python
# coding=utf-8

# Copyright (c) Huawei Technologies Co., Ltd. 2017-2019. All rights reserved.
# description: hwts文件相关的解析
# Create: 2021-5-5

import os
import re
import struct
from . import list_file


def get_log_slice_id(file_name=None):
    pattern = re.compile(r'(?<=slice_)\d+')
    slice_id = pattern.findall(file_name)
    return int(slice_id[0])


def hwts_binfile_merge(file_path, flag):
    name_list = []
    file_join_name = ''

    if os.path.exists(file_path):
        files = os.listdir(file_path)
        for file_name in files:
            if 'slice_' in file_name and not file_name.endswith('done') and file_name.startswith(flag.split('.')[0])\
                    and 'complete' not in file_name:
                name_list.append(file_name)

        name_list.sort(key=get_log_slice_id)

        file_join_name = file_path + os.sep + flag
        if os.path.exists(file_join_name):
            os.remove(file_join_name)

        with open(file_join_name, 'ab') as bin_data:
            for name in name_list:
                file_name = file_path + os.sep + name
                with open(file_name, 'rb') as txt:
                    bin_data.write(txt.read())
    return file_join_name

# 按照struct格式解析hwts bin文件
def hwts_parser_bin(sid_set, _line, hwts_trace, task_id_repeat, batch_id):
    cnt_res0_type, core_id, hex_6bd3, block_id, task_id = struct.unpack('2B3H', _line[0:8])
    hwts_type = cnt_res0_type & 0x07
    if hwts_type == 0 or hwts_type == 1:
        syscnt, stream_id = struct.unpack('QI', _line[8:20])
        if stream_id in sid_set:
            if task_id_repeat.get(stream_id) is None:
                task_id_repeat[stream_id] = task_id
                batch_id[stream_id] = 0
            elif task_id < task_id_repeat[stream_id]:
                task_id_repeat[stream_id] = task_id
                batch_id[stream_id] += 1
            else:
                task_id_repeat[stream_id] = task_id

            stid = (stream_id, task_id, batch_id[stream_id])

            if hwts_trace.get(stid) is None:
                hwts_trace[stid] = []
            hwts_trace[stid].append((hwts_type, syscnt / 100))

# 按照struct格式解析stars bin文件
def stars_parser_bin(sid_set, _line, hwts_trace, dict1, task_id_repeat, batch_id):
    _type_cnt, sqe_type_cnt, hex_6bd3, stream_id, task_id = struct.unpack('BBHHH', _line[0:8])
    _type = _type_cnt & 0x3F
    sqe_type = sqe_type_cnt & 0xFC
    if _type == 0 or _type == 1:
        if stream_id in sid_set:
            if task_id_repeat.get(stream_id) is None:
                task_id_repeat[stream_id] = task_id
                batch_id[stream_id] = 0
            elif task_id < task_id_repeat[stream_id]:
                task_id_repeat[stream_id] = task_id
                batch_id[stream_id] += 1
            else:
                task_id_repeat[stream_id] = task_id

            stid = (stream_id, task_id, batch_id[stream_id])
            if stid not in hwts_trace:
                hwts_trace[stid] = []
            syscnt = struct.unpack('QI', _line[8:20])
            # 解决rts中处理task type为rdmasend时下发两个sqe的问题
            # 取第一个start的时间
            if sqe_type == 20 and _type == 0:
                if (_type, sqe_type, stream_id, task_id) == dict1['check_start']:
                    dict1['check_start'] = None
                    return dict1['check_start'], dict1
                else:
                    dict1['check_start'] = (_type, sqe_type, stream_id, task_id)

            # 取第一个end的时间
            if sqe_type == 20 and _type == 1:
                if (_type, sqe_type, stream_id, task_id) == dict1['check_end']:
                    dict1['check_end'] = None
                    return dict1['check_start'], dict1
                else:
                    dict1['check_end'] = (_type, sqe_type, stream_id, task_id)
            hwts_trace[stid].append((_type, syscnt[0] / 50))


def get_num(end_stid_list, hwts_trace):
    num = 0
    for end_stid in end_stid_list:
        end_stid[-1] = float('inf')
        for stid in end_stid[0]:
            stid_key = (stid[0], stid[1])
            if stid_key in hwts_trace:
                end_stid[-1] = min(end_stid[-1], len(hwts_trace[stid_key]) // 2)
            else:
                end_stid[-1] = 0
        num += end_stid[-1]
    return num


def hwts_parser(file_path, sid_set, end_stid_list, flag, max_num):
    hwts_trace = {}
    count = 0
    batch_id = {}
    # 为了减少查询次数，提高性能，每1000次去查询一次
    search_count = 1000
    task_id_repeat = {}
    file_join_name = hwts_binfile_merge(file_path, flag)
    if file_join_name:
        dict1 = {'check_end': None, 'check_start': None}
        with open(file_join_name, 'rb') as hwts_data:
            while 1:
                _line = hwts_data.read(64)
                count += 1
                if _line:
                    if not _line.strip():
                        continue
                # hwts/stars数据本身异常的场景
                else:
                    break
                if flag == 'hwts.data':
                    hwts_parser_bin(sid_set, _line, hwts_trace, task_id_repeat, batch_id)
                elif flag == 'stars_soc.data':
                    stars_parser_bin(sid_set, _line, hwts_trace, dict1, task_id_repeat, batch_id)
                if count > search_count:
                    count = 0
                    num = get_num(end_stid_list, hwts_trace)
                    if num > max_num:
                        break

    else:
        print('ERROR! hwts bin file parsing error!')
    # remove中间文件
    os.remove(file_join_name)
    return hwts_trace
