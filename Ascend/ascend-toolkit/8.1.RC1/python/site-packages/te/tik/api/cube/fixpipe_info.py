#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     fixpipe.py
DESC:     provide tiling method
CREATED:  2020-4-23 21:12:13
MODIFIED: 2021-11-18 18:14:00
"""
import math
from tbe.common.platform import scope_ubuf
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.common_util import is_tensor
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_params import FRAC_LEN
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager


class FixpipeInfoV2:
    """
    fixpipe api info
    """

    def __init__(self, fixpipe_api):
        self.fixpipe_api = fixpipe_api
        self.extend_params = fixpipe_api.extend_params
        howo = fixpipe_api.burst_len * ONE_BLK_SIZE // DTYPE_SIZE.get(fixpipe_api.src.dtype) // FRAC_LEN
        round_howo = ceil_div(howo, FRAC_LEN) * FRAC_LEN
        self.frac_len = FRAC_LEN
        self.dst_dtype = fixpipe_api.dst.dtype
        self.src_dtype = fixpipe_api.src.dtype
        self.c_0 = FRAC_LEN

        # for 910Pro
        # burst is defined as consective ceil(M/16) 16X16 fractals,
        # and burst length is defined as M*16*sizeof(data_type)
        self.n_size = fixpipe_api.cburst_num * FRAC_LEN
        self.m_size = howo

        # original src_stride unit is 256 elements, it's the gap
        # new src_busrt_gap unit is C0_size, for example, src dtype is b32, gap unit is 16*4, it's the stride
        self.src_stride = fixpipe_api.src_stride * FRAC_LEN + round_howo

        # original dst_stride unit is 32B, it's the gap
        # new dst_burst_gap unit is 32B, it's the stride
        # note: input burst_len is calculated by src dtype,
        # if src dtype is different with dst dtype, need to re-caculate burst_len for dst
        self.dst_stride = fixpipe_api.dst_stride + fixpipe_api.burst_len * \
                          DTYPE_SIZE[self.dst_dtype] // DTYPE_SIZE[self.src_dtype]

        self.sid = 0
        self.quant_mode = self.get_quant_mode()
        self.relu = self.has_relu()
        self.channel_split = False
        self.nz2nd_mode = 0
        self.unit_flag_mode = 0
        self.deq_value = self.get_deq_value()
        self.clip_relu_pre = 0
        # include QUANT_POST, RELU_POST, CLIP_RELU_POST, ELTWISE_OP, ELTWISE_ANTQ_CFG, C0_PAD_EN
        # fixpipe not support these functions, so the value is set to zero
        self.disable_params = [0] * 6
        if TikSocManager.is_610l_soc():
            self.disable_params = [0] * 11

    def has_deq(self):
        """
        check quantize_params
        """
        return self.fixpipe_api.extend_params is not None and \
               'quantize_params' in self.fixpipe_api.extend_params and \
               self.fixpipe_api.extend_params['quantize_params'] is not None

    def get_quant_mode(self):
        """
        get the quant mode according the input params
        :return:
        """
        # (1) NoQuant (2) F322F16 (3) DEQF16 (s32->f16 with scalar/imm mode_param)
        # (4) VDEQF16 (s32->f16 with tensor mode_param)
        quant_modes = [0, 1, 2, 3]
        quant_modes_str = ["NoQuant", "F322F16", "DEQF16", "VDEQF16"]
        if not self.has_deq():
            quant_mode_index = quant_modes[0]
        else:
            quant_mode = self.fixpipe_api.extend_params['quantize_params']["mode"]
            if quant_mode == "int322fp16":
                quant_mode_index = quant_modes[2]
                if is_tensor(self.fixpipe_api.extend_params['quantize_params']["mode_param"]):
                    quant_mode_index = quant_modes[3]
            elif quant_mode == "fp322fp16":
                quant_mode_index = quant_modes[1]
            else:
                quant_mode_index = quant_modes[0]

        return quant_modes_str[quant_mode_index]

    def get_deq_value(self):
        """
        get the deq value for int322fp16
        :return:
        the input deq value, scalar or Tensor of L1, dtype is fp16
        """
        if not self.has_deq():
            return None
        if self.quant_mode in ["DEQF16", "VDEQF16"]:
            return self.fixpipe_api.extend_params['quantize_params']["mode_param"]
        else:
            return None

    def has_relu(self):
        """
        check relu
        """
        return self.fixpipe_api.extend_params is not None and \
               'relu' in self.fixpipe_api.extend_params and self.fixpipe_api.extend_params['relu'] is True

    def evaluate_expr(self, context):
        self.n_size = context.evaluate_expr(self.n_size)
        self.m_size = context.evaluate_expr(self.m_size)
        self.dst_stride = context.evaluate_expr(self.dst_stride)
        self.src_stride = context.evaluate_expr(self.src_stride)


class FixpipeInfo:
    """
    fixpipe api info
    """

    def __init__(self, fixpipe_api):
        self.fixpipe_api = fixpipe_api
        self.cburst_num = fixpipe_api.cburst_num
        self.burst_len = fixpipe_api.burst_len
        self.dst_stride = fixpipe_api.dst_stride
        self.src_stride = fixpipe_api.src_stride
        self.extend_params = fixpipe_api.extend_params
        self.howo = fixpipe_api.burst_len * ONE_BLK_SIZE // DTYPE_SIZE.get(fixpipe_api.src.dtype) // 16
        self.round_howo = ceil_div(self.howo, 16) * 16
        self.howo_has_round = self.howo != self.round_howo
        self.howo_blocks = self.round_howo // 16
        self.frac_len = 16
        self.dst_dtype = fixpipe_api.dst.dtype
        self.src_dtype = fixpipe_api.src.dtype
        self.deq_value = None
        self.l0c_shape = []
        self.src = fixpipe_api.src
        self.dst = fixpipe_api.dst
        self.c_0 = 16
        if fixpipe_api.dst.dtype in ("int8", "uint8"):
            self.c_0 = 32
        self.bias_value = None
        self.ele_bias_value = None

    def has_bias(self):
        """
        check bias
        """
        return self.fixpipe_api.extend_params is not None and \
               'bias' in self.fixpipe_api.extend_params and \
               self.fixpipe_api.extend_params['bias'] is not None

    def has_deq(self):
        """
        check quantize_params
        """
        return self.fixpipe_api.extend_params is not None and \
               'quantize_params' in self.fixpipe_api.extend_params and \
               self.fixpipe_api.extend_params['quantize_params'] is not None

    def has_ele_wise_bias(self):
        """
        check element-wise-add
        """
        return self.fixpipe_api.extend_params is not None and \
               'element-wise-add' in self.fixpipe_api.extend_params and \
               self.fixpipe_api.extend_params['element-wise-add'] is not None

    def has_relu(self):
        """
        check relu
        """
        return self.fixpipe_api.extend_params is not None and \
               'relu' in self.fixpipe_api.extend_params and \
               self.fixpipe_api.extend_params['relu'] is True


# @endcond


# @cond
class FixpipeTileInfo:
    """
    fixpipe tiling info
    """
    vector_issue_heuristic = 24
    max_repeat = 255

    def __init__(self, fixpipe_tile):
        self.has_bias = fixpipe_tile.has_bias
        self.has_deq = fixpipe_tile.has_deq
        self.vconv_merge_channel = fixpipe_tile.vconv_merge_channel
        self.l1out_iter_num = math.ceil(fixpipe_tile.l1out_blocks / fixpipe_tile.l1out_tile_blocks)
        self.howo_iter_num = math.ceil(fixpipe_tile.howo_blocks / fixpipe_tile.howo_tile_blocks)
        self.l1out_blocks = fixpipe_tile.l1out_blocks
        self.l1out_tile_blocks = fixpipe_tile.l1out_tile_blocks
        self.l1out_thread_num = fixpipe_tile.l1out_thread_num
        self.howo_blocks = fixpipe_tile.howo_blocks
        self.howo_tile_blocks = fixpipe_tile.howo_tile_blocks
        self.howo_thread_num = fixpipe_tile.howo_thread_num

        self.repeat_per_block = 16 * 16 // 128

        self.bias_blocks = fixpipe_tile.bias_blocks
        self.bias_tail_repeat = fixpipe_tile.bias_tail_repeat

        self.l0c_to_ub_count = 1
        self.bias_repeat = fixpipe_tile.bias_repeat

        # issue count for 8 block bias
        self.bias_issue_count = math.ceil(
            fixpipe_tile.howo_tile_blocks * self.repeat_per_block / self.max_repeat)
        self.bias_count = fixpipe_tile.bias_repeat * self.bias_issue_count

        if fixpipe_tile.bias_tail_repeat > 0:
            self.bias_tail_issue_count = math.ceil(
                fixpipe_tile.howo_tile_blocks * self.repeat_per_block / self.max_repeat)
            self.bias_count += self.bias_tail_issue_count

        self.deq_count = math.ceil(fixpipe_tile.howo_tile_blocks * fixpipe_tile.l1out_tile_blocks *
                                   self.repeat_per_block / self.max_repeat)
        self.vector_issue_num = \
            (self.l0c_to_ub_count + self.bias_count + self.deq_count) * \
            self.l1out_iter_num * self.howo_iter_num

        partial_utilization = self.l1out_tile_blocks / \
                              (math.ceil(self.l1out_tile_blocks / 8) * 8)

        self.vector_bias_utilization = 1
        if fixpipe_tile.has_bias:
            self.vector_bias_utilization = partial_utilization
        self.vector_fp16_to_b8_utilization = 1
        if fixpipe_tile.vconv_merge_channel:
            self.vector_fp16_to_b8_utilization = partial_utilization

        self.vector_utilization = (self.vector_bias_utilization +
                                   self.vector_fp16_to_b8_utilization) / 2

        self.howo_has_tail = fixpipe_tile.howo_blocks != fixpipe_tile.howo_tile_blocks * self.howo_iter_num
        self.l1out_has_tail = fixpipe_tile.l1out_blocks != fixpipe_tile.l1out_tile_blocks * self.l1out_iter_num

        self.howo_tail_blk = fixpipe_tile.howo_blocks - (self.howo_iter_num - 1) * fixpipe_tile.howo_tile_blocks
        self.l1out_tail_blk = fixpipe_tile.l1out_blocks - (self.l1out_iter_num - 1) * fixpipe_tile.l1out_tile_blocks

    def __lt__(self, other):
        # maximize vector utilization and minimize vector issue count
        if self.get_vector_utilization() > other.get_vector_utilization():
            compare_result = True
        elif self.get_vector_utilization() < other.get_vector_utilization():
            compare_result = False

        elif self.get_vector_issue_num() < other.get_vector_issue_num():
            compare_result = True
        elif self.get_vector_issue_num() > other.get_vector_issue_num():
            compare_result = False

        elif self.l1out_thread_num > other.l1out_thread_num:
            compare_result = True
        elif self.l1out_thread_num < other.l1out_thread_num:
            compare_result = False

        elif self.howo_thread_num > other.howo_thread_num:
            compare_result = True
        elif self.howo_thread_num < other.howo_thread_num:
            compare_result = False

        elif self.l1out_tile_blocks < other.l1out_tile_blocks:
            compare_result = True
        elif self.l1out_tile_blocks > other.l1out_tile_blocks:
            compare_result = False
        else:
            compare_result = self.howo_tile_blocks < other.howo_tile_blocks

        return compare_result

    def __str__(self):
        return "FixpipeTileInfo:\n" \
               "l1out blocks:{} tile:{} thread:{}\n" \
               "hw blocks:{} tile:{} thread:{}\n" \
               "vector issue num {} " \
               "vector utilization {}\n" \
               "has bias {} " \
               "has vconv deq {} " \
               "has vconv merge channel {}" \
            .format(self.l1out_blocks, self.l1out_tile_blocks,
                    self.l1out_thread_num, self.howo_blocks,
                    self.howo_tile_blocks, self.howo_thread_num,
                    self.vector_issue_num, self.vector_utilization,
                    self.has_bias, self.has_deq, self.vconv_merge_channel)

    def get_vector_issue_num(self):
        """
        get vector issue num
        """
        return self.vector_issue_num

    def get_vector_utilization(self):
        """
        get vector utilization
        """
        return self.vector_utilization
