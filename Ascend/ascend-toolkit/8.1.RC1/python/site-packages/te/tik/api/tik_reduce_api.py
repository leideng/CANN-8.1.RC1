#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_whole_reduce_api.py
DESC:     provide reduce vector instructions
CREATED:  2020-3-16 21:12:13
MODIFIED: 2020-3-16 21:12:45
"""

from collections import namedtuple
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.tik.common.tik_get_soc_name import is_compatible_mode
from tbe.tik.tik_lib.tik_vector_api.tik_vector_reduce_api_ import ReduceOp
from tbe.tik.tik_lib.tik_vector_api.tik_vector_reduce_add_api_ import ReduceAddOp
from tbe.tik.tik_lib.tik_vector_api.tik_vector_reduce_add_api_ import ReduceOpNanoCompatible
from tbe.tik.tik_lib.tik_vector_api.tik_whole_reduce_api_ import PairReduceOps
from tbe.tik.tik_lib.tik_vector_api.tik_whole_reduce_api_ import NanoPairReduceOps
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager

_DEFAULT_STRIDE = 1


class TikReduceApiv1(TikIRBuilder):
    """
    Provide whole-reduce group-reduce pair-reduce api for open
    """
    reduce_op = namedtuple(
        "ReduceApi", ["name", "mask", "dst", "src", "work_tensor", "repeat_times", "src_rep_stride", "cal_index"])

    reduce_add_op = namedtuple(
        "ReduceAddApi",
        ["mask", "dst", "src", "work_tensor", "repeat_times", "src_rep_stride"])

    reduce_api = namedtuple('WholeReduceApi', ["name", "mask", "dst", "src", "repeat_times", "dst_rep_stride",
                                               "src_blk_stride", "src_rep_stride", "stride_unit", "order",
                                               "maxmin_cnt_index"])

    def vec_cpadd(self, mask, dst, src, repeat_times, dst_rep_stride, src_rep_stride):
        """
        Adds elements (odd and even) between adjacent pairs

        Parameter
        ----------
        mask : Effective operation on element, divided into two model: Continuous and bit by bit.
        dst : Destination operand.
        src : Source operand.
        repeat_times : Number of iteration repeats
        dst_rep_stride : Block-to-block stride between adjacent iterations of the destination operand
        src_rep_stride : Block-to-block stride between adjacent iterations of the source operand

        Returns
        ----------
        no return
        """
        src_blk_stride = 1
        stride_unit = 0
        order = None
        maxmin_cnt_index = None
        pair_reduce_api = TikReduceApiv1.reduce_api("vec_cpadd", mask, dst, src, repeat_times, dst_rep_stride,
                                                    src_blk_stride, src_rep_stride, stride_unit, order,
                                                    maxmin_cnt_index)
        if TikSocManager.is_nano_soc():
            vcpadd_obj = NanoPairReduceOps(self, pair_reduce_api)
        else:
            vcpadd_obj = PairReduceOps(self, pair_reduce_api)
        vcpadd_obj.run_all()

    @source_info_decorator()
    def vec_reduce_add(self, mask, dst, src, work_tensor, repeat_times, src_rep_stride):
        """
        Adds all input data.

        Parameter
        ----------
        mask : Effective operation on element, divided into two model: Continuous and bit by bit.
        dst : Destination operand.
        src : Source operand.
        work_tensor: User-defined temporary buffer space for storing intermediate results. The space is limited to
        scope_ubuf and is used for internal calculation.
        repeat_times : Number of iteration repeats
        src_rep_stride : Block-to-block stride between adjacent iterations of the source operand

        Returns
        ----------
        no return

        """
        reduce_add_api = self.reduce_add_op(mask, dst, src, work_tensor, repeat_times, src_rep_stride)
        if TikSocManager.is_nano_soc() and is_compatible_mode():
            reduce_add_obj = ReduceOpNanoCompatible(self, "vcadd", self.reduce_add_op, reduce_add_api)
        else:
            reduce_add_obj = ReduceAddOp(self, reduce_add_api)
        reduce_add_obj.run_add_all()

    @source_info_decorator()
    def vec_reduce_max(self, mask, dst, src, work_tensor, repeat_times, src_rep_stride, cal_index=False):
        """
        Obtains the maximum value and its corresponding index position among the input data.

        Parameter
        ----------
        mask : Effective operation on element, divided into two model: Continuous and bit by bit.
        dst : Destination operand.
        src : Source operand.
        work_tensor: User-defined temporary buffer space for storing intermediate results. The space is limited to
        scope_ubuf and is used for internal calculation.
        repeat_times : Number of iteration repeats
        src_rep_stride : Block-to-block stride between adjacent iterations of the source operand
        cal_index : A bool that specifies whether to obtain the index with the minimum value.

        Returns
        ----------
        no return
        """
        reduce_api = self.reduce_op("vcmax", mask, dst, src, work_tensor, repeat_times, src_rep_stride, cal_index)
        if TikSocManager.is_nano_soc() and is_compatible_mode():
            reduce_obj = ReduceOpNanoCompatible(self, "vcmax", self.reduce_op, reduce_api)
        else:
            reduce_obj = ReduceOp(self, reduce_api)
        reduce_obj.run_all()

    @source_info_decorator()
    def vec_reduce_min(self, mask, dst, src, work_tensor, repeat_times, src_rep_stride, cal_index=False):
        """
        Obtains the minimum value and its corresponding index position among the input data.

        Parameter
        ----------
        mask : Effective operation on element, divided into two model: Continuous and bit by bit.
        dst : Destination operand.
        src : Source operand.
        work_tensor: User-defined temporary buffer space for storing intermediate results. The space is limited to
        scope_ubuf and is used for internal calculation.
        repeat_times : Number of iteration repeats
        src_rep_stride : Block-to-block stride between adjacent iterations of the source operand
        cal_index : A bool that specifies whether to obtain the index with the minimum value.

        Returns
        ----------
        no return
        """
        reduce_api = self.reduce_op("vcmin", mask, dst, src, work_tensor, repeat_times, src_rep_stride, cal_index)
        if TikSocManager.is_nano_soc() and is_compatible_mode():
            reduce_obj = ReduceOpNanoCompatible(self, "vcmin", self.reduce_op, reduce_api)
        else:
            reduce_obj = ReduceOp(self, reduce_api)
        reduce_obj.run_all()
