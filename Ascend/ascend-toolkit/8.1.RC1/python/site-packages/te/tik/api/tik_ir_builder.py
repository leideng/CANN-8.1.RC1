#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_ir_builder.py
DESC:     Developer API of IR node builder make function for TIK.
CREATED:  2019-08-12 18:53:42
MODIFIED: 2019-08-12 21:29:18
"""
from __future__ import absolute_import as _abs
from tbe import tvm
from tbe.tvm import thread_axis
from tbe.tvm.tir import Simplify
from tbe.tvm.tir import Evaluate
from tbe.tvm.tir.stmt import SeqStmt
from tbe.tvm.tir.stmt import AttrStmt
from tbe.tvm.tir.stmt import Stmt
from tbe.tvm.tir.ir_builder import IRBuilder
from tbe.tik import debug
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.debug.decorators import tik_break_decorator
from tbe.tik.debug.decorators import tik_continue_decorator
from tbe.tik.common.common_util import check_begin_end_value
from tbe.tik.common.tik_ir_builder_util import set_for_params_min_extent
from tbe.tik.common.tik_ir_builder_util import check_params_for_range
from tbe.tik.common.tik_ir_builder_util import gen_ret_loop_var
from tbe.tik.common.tik_ir_builder_util import ForRangeTuple
from tbe.tik.tik_lib.tik_expr import is_basic_expr
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_params import GROUP_COPROC_SCOPE_VALUE
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_check_util import TIK_CONTROL
from tbe.tik.tik_lib.tik_check_util import print_error_msg
from tbe.tik.tik_lib.tik_ir_builder_lib import TikWithScope
from tbe.tik.tik_lib.tik_ir_builder_lib import TikIRBuilderInner
from tbe.tik.tik_lib.tik_ir_builder_lib import SubInfo


_LAST_ELEMENT = -1
# block num min should greater than 0, less than 65536
_MIN_BLOCK_NUM, _MAX_BLOCK_NUM = 1, 65536

_DEFAULT_THREAD_BLOCK_NUM = 1
_MIN_NIDX, _DEVICE_API = 3, 0
# for type id value
_SERIAL_FOR_TYPE_ID = 0
# elif and else follow an if should less than 400
# because maximum recursion depth exceeded in comparison
_MAX_IFTHENELIF_DEEP = 400
_SUB_SYNC_WAIT = "pragma_multicore_subblock_sync_wait_before"
_SUB_SYNC_SET = "pragma_multicore_subblock_sync_set_before"
_ALL_SYNC_BEFORE = "pragma_multicore_all_block_sync_before"
_ALL_SYNC_AFTER = "pragma_multicore_all_block_sync_after"


class TikIRBuilder(TikIRBuilderInner, IRBuilder):
    """
    Auxiliary builder to build IR for testing and dev.
    Inherit from IRBuilder of ir_builder
    """
    none_value = None

    def __init__(self):
        TikIRBuilderInner.__init__(self)
        IRBuilder.__init__(self)

        # subblk flag
        self.for_subblk_num = 1
        self._subblock_id = None
        self.has_multi_subblk = False
        self.enable_multi_core = False
        self.has_multi_block = False
        # sub_sync and group_sync flag
        self.sub_sync_flag = False
        self.all_sync_flag = False
        self.sync_count = 0
        self._barrier = None
        self.is_double_buffer_for_loop = False
        self.buffer_num = 1
        self.is_n_buffer_for_loop_list = []
        self.for_blk_num = 1
        self._sync_flag = False
        self._block_id = None
        self._is_for_multi_core = []
        self.is_break = False
        self.is_continue = False
        self.is_multi_block = False
        self.for_begin_end = []
        self.for_var_list = []

    @staticmethod
    def _get_max_if_condition(extent, thread_num):
        if isinstance(extent, int):
            if extent % thread_num != 0:
                return extent
            return TikIRBuilder.none_value
        return extent

    @staticmethod
    def _get_attr_key(thread_type):
        """
        get attr key by thread_type
        Parameters
        ----------
        thread_type: thread type

        Returns
        -------
        key
        """
        if thread_type == "whole":
            attr_key = "dthread_whole"
        elif thread_type == "partial":
            attr_key = "dthread_partition"
        else:
            TikCheckUtil.raise_error("thread_type(%s) only support 'partial' "
                                     "and 'whole' mode" % thread_type)
        return attr_key

    @staticmethod
    def _get_loop_var(block_id, name, dtype):
        """
        get variable in loop
        Parameters
        ----------
        block_id:
        name: variable name
        dtype: data dtype

        Returns
        -------
        var
        """
        if block_id is not None:
            return block_id.var
        return tvm.var(name, dtype=dtype)

    @staticmethod
    def _get_begin_offset_and_extent(begint, endt):
        """
        get the value of extent and offset when they are scalar
        Parameters
        ----------
        begint: scalar begin
        endt: scalar end

        Returns
        -------
        begin, offset, extent
        """
        if is_basic_expr([begint]):
            begin = begint.get()
            offset = begint.get()
        else:
            begin = Expr(begint).get()
            offset = begint
        # get the end value
        end = endt
        if is_basic_expr([endt]):
            end = endt.get()

        if begin == 0:
            extent = end
        else:
            extent = Simplify(end - begin)
            begin = 0  # set begin index to 0
        if isinstance(extent, tvm.tir.IntImm):
            extent = extent.value

        return begin, offset, extent

    @staticmethod
    def _check_thread_block_num(thread_num, block_num):
        """
        check thread number and block number
        Parameters
        ----------
        thread_num: thread number
        block_num: block number

        Returns
        -------
        no return

        """
        if isinstance(block_num, Scalar) and thread_num not in (0, 1):
            print_error_msg("when block_num's type is Scalar, "
                            "thread_num should be 0 or 1, but input is %d" % (thread_num))
        if isinstance(block_num, int):
            if block_num > 1 and thread_num not in (0, 1):
                print_error_msg("when block_num's type is int and block_num > 1, "
                                "thread_num should be 0 or 1, but input is %d" % (thread_num))

    @staticmethod
    def _check_extent_num(extent, thread_num):
        """
        check extent number
        Parameters
        ----------
        extent: extent value
        thread_num: thread number

        Returns
        -------
        no return
        """
        extent_value = Expr(extent).eval_value()
        if extent_value is not None:
            TikCheckUtil.check_ge(
                extent_value, 0,
                "for_range function parameter end(%d) must be more than or equal to begin(0)" % extent_value)

    @staticmethod
    def _get_for_type_id(for_type):
        # currently only support serial
        if for_type == "serial":
            return _SERIAL_FOR_TYPE_ID
        return TikCheckUtil.raise_error("Unknown for_type(%s)" % for_type, exception_type=ValueError)

    @staticmethod
    def _check_block_nest_(has_multi_block: bool, has_multi_subblk: bool) -> None:
        """
        check Illegal nest
        Parameters
        ----------
        has_multi_block: flag of multi block
        has_multi_subblk: flag of multi subblock
        """
        if has_multi_block or has_multi_subblk:
            TikCheckUtil.raise_error(
                "Nest error: for_range of block shoud not be nested within for_range of block or subblock")

    @source_info_decorator()
    def for_range(self, begint, endt, name="i", thread_num=1, thread_type="whole", block_num=1, dtype="int32",
                  for_type: any = "serial", subblock_num: int = 0,
                  sub_dtype: str = "int32", enable_subblk: bool = False) -> any:
        """
        Indicates the for loop statement of the TIK.

        Parameters
        ----------
        begint : Start of the for loop.
        endt : End of the for loop.
        name : Name of a variable in the for loop. The default name is i.
        thread_num : Whether to enable double buffers in the for loop.
        thread_type : Thread type of the for loop.
        block_num : Number of cores used in the for loop.
        dtype : Variable type of the for loop.
        for_type : Type of the for loop.

        Returns
        -------
        TikWithScope object
        """
        if not enable_subblk:
            for_range_tuple_ = ForRangeTuple(begint, endt, name, thread_num, thread_type, block_num, dtype, for_type)
            return self.for_range_(for_range_tuple_)
        sub_info = SubInfo(begint, endt, subblock_num, sub_dtype)
        sub_info.name = name
        sub_info.thread_num = thread_num
        sub_info.thread_type = thread_type
        sub_info.for_type = for_type
        return self.__for_range_subblk(sub_info)

    @debug.for_range_decorator
    def for_range_(self, range_tuple):
        """
        Create a for iteration scope.
        note: use this function to call for_range inside!!
        """
        # check block nest
        block_num, endt = self._check_block_num_type(range_tuple)
        self._check_block_nest()
        check_params_for_range(range_tuple.thread_num, block_num, range_tuple.thread_type,
                               range_tuple.dtype, range_tuple.for_type)
        self._check_thread_block_num(range_tuple.thread_num, block_num)
        self._seq_stack.append([])
        endt = self._init_for_range_params(endt)
        check_begin_end_value(range_tuple.begint, endt, range_tuple.dtype)
        # set begin to 0, extent to (endt-begint), offset to begint
        begin, offset, extent = self._get_begin_offset_and_extent(range_tuple.begint, endt)
        self._check_extent_num(extent, range_tuple.thread_num)
        # calculate the for loop times
        loop_times = extent
        if range_tuple.thread_num > _DEFAULT_THREAD_BLOCK_NUM:
            loop_times = (extent + range_tuple.thread_num - 1) // range_tuple.thread_num
        name = self._get_loop_var_name(range_tuple.name) if range_tuple.name == 'i' else range_tuple.name
        # if block_num > 1, enable multi-AIcore,
        # endt and begint must be satisfy the conditions
        self._multi_core_init(block_num)
        block_id = self._get_block_id(block_num)
        for_var = None
        dthread_var = None
        if range_tuple.thread_num > _DEFAULT_THREAD_BLOCK_NUM:
            dthread_var, for_var, loop_var = self._get_dthread_for_loop_var(
                name, range_tuple.dtype, range_tuple.thread_num)
            self.for_var_list.append([for_var, dthread_var])
            self.for_begin_end.append([[begin, (extent - 1) // range_tuple.thread_num],
                                       [_DEFAULT_THREAD_BLOCK_NUM - 1, range_tuple.thread_num - 1]])
        else:  # no double buffer and no multi-core
            loop_var = self._get_loop_var(block_id, name, range_tuple.dtype)
            self.for_var_list.append(loop_var)
            self.for_begin_end.append([begin, extent - 1])
        self._set_buffer_num(range_tuple.thread_num)
        # check if True in double buffer loop
        self._check_if_true_in_db_loop()
        self._update_code_manager_info(range_tuple.thread_num, 1)

        def _exit_cb():
            for_type_id = self._for_range_exit_cb_init(range_tuple.thread_num,
                                                       block_num, range_tuple.for_type)
            if range_tuple.thread_num <= _DEFAULT_THREAD_BLOCK_NUM:
                self._gen_for_range_exit_cb_when_thread_one((block_num, block_id, endt, loop_var, begin,
                                                             loop_times, for_type_id, range_tuple.thread_type,
                                                             range_tuple.thread_num))
            else:
                # set the max_if_condition
                max_if_condition = self._get_max_if_condition(extent, range_tuple.thread_num)
                stmt = self._create_stmt_for_double_buffer((
                    dthread_var, max_if_condition, loop_var, range_tuple.thread_type, range_tuple.thread_num))
                begin_actual, loop_times_actual = set_for_params_min_extent(
                    range_tuple.dtype, begin, loop_times)
                stmt = tvm.tir.For(for_var, begin_actual, loop_times_actual, for_type_id, stmt)
                self.source_info.set_node_span(stmt)
                self.emit(stmt)
            if not self.is_n_buffer_for_loop_list:
                self.is_double_buffer_for_loop = False
                self.buffer_num = 1
            if range_tuple.thread_num > _DEFAULT_THREAD_BLOCK_NUM:
                self._del_loop_var(dthread_var)
                self._del_loop_var(for_var)
            else:
                self._del_loop_var(loop_var)
            if len(self.for_begin_end) > 0:
                self.for_begin_end.pop()
            if len(self.for_var_list) > 0:
                self.for_var_list.pop()
            self._is_for_multi_core.pop()

        with_scope = TikWithScope(gen_ret_loop_var(loop_var, range_tuple, offset), _exit_cb,
                                  self.source_info.get_source_info())
        if range_tuple.thread_num > _DEFAULT_THREAD_BLOCK_NUM:
            with_scope.debug_hint = [(for_var, (begin, loop_times)), (dthread_var, (0, range_tuple.thread_num))]
        else:
            with_scope.debug_hint = [(loop_var, (begin, loop_times))]
        with_scope.debug_limit = (loop_var, extent)
        return with_scope

    @source_info_decorator()
    def multi_for_range(self, begint, endt, name="i", dtype="int32", for_type="serial"):
        """
        Create a for iteration scope.

        Parameters
        ----------
        begint : The min iteration scope.
        endt : The end iteration scope
        name : The name of iteration variable, if no input names, using typical index names i, j, k, then i_nidx
        dtype : The data type of iteration variable.
        for_type : The special tag on the for loop.

        Returns
        -------
        loop_scope : The for scope, when enters returns loop_var
        """
        self.for_scope_level += 1
        TikCheckUtil.check_type_match(dtype, str, "dtype(%s) should be str" % str(type(dtype)))
        TikCheckUtil.check_type_match(for_type, str, "for_type(%s) should be str" % str(type(for_type)))
        TikCheckUtil.check_type_match(begint, (list, tuple), "begint(%s) should be list or tuple" % str(type(begint)))
        TikCheckUtil.check_type_match(endt, (list, tuple), "endt(%s) should be list or tuple" % str(type(endt)))
        var_number = len(begint)
        TikCheckUtil.check_equality(var_number, len(endt), "length of begint(%d) should be equal to length of endt(%d)"
                                    % (var_number, len(endt)))
        control_tuple = (begint, endt)
        loop_var_list, extent_list, begin = self._get_multi_for_range_params(var_number, name, dtype, control_tuple)
        self._seq_stack.append([])
        _multi_for_range_loc = self.source_info.get_source_info()
        # multi_for_range do not have debug decorator,so must handle source info

        def _exit_cb():
            if TIK_CONTROL.is_user_call:
                self.source_info.register_source_info(source_info=_multi_for_range_loc)
                self.source_info.set_not_user_call()
                self._multi_for_range_exit_cb_((for_type, var_number, loop_var_list, begin, extent_list))
                self.source_info.set_is_user_call()
                self.source_info.clear_source_info()
            else:
                self._multi_for_range_exit_cb_((for_type, var_number, loop_var_list, begin, extent_list))

        return TikWithScope(loop_var_list, _exit_cb, self.source_info.get_source_info())
    # @endcond

    @source_info_decorator()
    def if_scope(self, cond):
        """
        Creates an if statement of the TIK.
        Parameters
        ----------
        cond : An Expr specifying the judgment condition.

        Returns
        -------
        TikWithScope object
        """
        return self.if_scope_(cond)

    @source_info_decorator()
    def elif_scope(self, cond):
        """
        Creates an else if statement of the TIK.

        Parameters
        ----------
        cond : An Expr specifying the judgment condition.

        Returns
        -------
        TikWithScope object
        """
        return self.elif_scope_(cond)

    @source_info_decorator()
    def else_scope(self):
        """
        Creates an else statement of the TIK.

        Returns
        -------
        TikWithScope object
        """
        return self.else_scope_()

    @source_info_decorator()
    def new_stmt_scope(self, disable_sync=False):
        """
        Indicates a new scope (C language). And control whether to automatically insert a synchronization signal in
        new_stmt_scope through "disable_sync".

        Parameters
        ----------
        disable_sync: If the value is False, automatically insert the sync signal into IR. Otherwise,
        Don't insert the sync signal into IR.

        Returns
        -------
        TikWithScope object.
        """
        self.stmt_scope_level += 1
        self._seq_stack.append([])
        self.code_buffer_manager.new_scope()
        self.code_scalar_manager.new_scope()
        _new_stmt_scope_source_info = self.source_info.get_source_info()
        if not self.init_scope(disable_sync):
            TikCheckUtil.raise_error("Don't support nested call new_stmt_scope"
                                     " api in new_stmt_scope with disable the sync")

        def _exit_cb_():
            self.stmt_scope_level -= 1
            # check stmt_scope_level whether or not less than 0
            TikCheckUtil.check_ge(
                self.stmt_scope_level, 0, "stmt_scope_level(%d) should be more than 0" % self.stmt_scope_level)
            # check the high level api
            self.check_new_stmt_scope()

            attr_value = 0
            if disable_sync:
                group_coproc_attr = AttrStmt(tvm.thread_axis("cce"), "group_coproc_scope",
                                             GROUP_COPROC_SCOPE_VALUE, self._pop_seq())
                new_scope_attr = AttrStmt(tvm.thread_axis("cce"), "new_stmt_scope", attr_value, group_coproc_attr)
                self.source_info.set_node_span(new_scope_attr)
                # body scope include two ir
                self.emit(new_scope_attr)
            else:
                new_scope_attr = AttrStmt(tvm.thread_axis("cce"), "new_stmt_scope", attr_value, self._pop_seq())
                self.source_info.set_node_span(new_scope_attr)
                # body scope include one ir
                self.emit(new_scope_attr)

            self.code_buffer_manager.del_scope()
            self.code_scalar_manager.del_scope()

        # new_stmt_scope do not have debug decorator, so must handle source info
        def _exit_cb():
            if TIK_CONTROL.is_user_call:
                self.source_info.register_source_info(source_info=_new_stmt_scope_source_info)
                self.source_info.set_not_user_call()
                _exit_cb_()
                self.source_info.set_is_user_call()
                self.source_info.clear_source_info()
            else:
                _exit_cb_()
            self.pop_scope()
        return TikWithScope(None, _exit_cb, self.source_info.get_source_info())

    @source_info_decorator()
    @debug.tik_return_decorator
    def tik_return(self):
        """
        Returns at an instruction or layer position as required, which is often used to set a breakpoint.
        """
        self.emit(tvm.call_extern("uint64", "return",))

    @source_info_decorator()
    @tik_break_decorator
    def tik_break(self):
        """
        Stop the entire for_range loop
        """
        self._check_continue_break_is_valid(
            self._is_for_multi_core, self.code_buffer_manager.double_buffer_enable_stack_, 'tik_break')
        self.emit(tvm.call_extern("uint64", "break",))
        self.is_break = True

    @source_info_decorator()
    @tik_continue_decorator
    def tik_continue(self):
        """
        Quit the current loop in the entire for_range loop
        """
        self._check_continue_break_is_valid(
            self._is_for_multi_core, self.code_buffer_manager.double_buffer_enable_stack_, 'tik_continue')
        self.emit(tvm.call_extern("uint64", "continue",))
        self.is_continue = True

    @source_info_decorator()
    def subblock_group_barrier(self: any) -> None:
        """
        Generate IR Attr for subblock synchronization.
        """
        if not self.is_barrier_in_scope():
            TikCheckUtil.raise_error(
                "subblock_group_barrier must be used inside for_range and enable multi-core please.")
        iter_node = tvm.call_extern("uint64", "iter_var")
        self.sync_count = self.sync_count + 1
        self.scope_attr(iter_node, _SUB_SYNC_SET, value=self.sync_count)
        self.scope_attr(iter_node, _SUB_SYNC_WAIT, value=self.sync_count)
        self.sub_sync_flag = True

    @source_info_decorator()
    def block_barrier_all(self: any) -> None:
        """
        Generate IR Attr for all-block synchronization.
        """
        if not self.is_barrier_in_scope():
            TikCheckUtil.raise_error("block_barrier_all must be used inside for_range and enable multi-core please.")
        iter_node = tvm.call_extern("uint64", "iter_var")
        self.sync_count = self.sync_count + 1
        self.scope_attr(iter_node, _ALL_SYNC_BEFORE, value=self.sync_count)
        self.scope_attr(iter_node, _ALL_SYNC_AFTER, value=self.sync_count)
        self.all_sync_flag = True

    @debug.del_loop_var_decorator
    def _del_loop_var(self, loop_var):
        """
        delete loop var in debug context
        Parameters
        ----------
        loop_var: loop var in for range

        Returns
        -------
        None
        """

    def _update_code_manager_info(self, thread_num, enter_or_exit):
        """
        update code_buffer_manager and code_scalar_manager info
        Parameters
        ----------
        thread_num: the input num of thread
        enter_or_exit: enter for_range or exit for_range

        Returns
        -------
        None
        """
        if enter_or_exit == 1:
            if thread_num > 1:
                self.code_buffer_manager.double_buffer_enable_stack_.append(True)
                self.code_buffer_manager.double_buffer_thread_num = self.buffer_num
            else:
                self.code_buffer_manager.double_buffer_enable_stack_.append(False)

            self.code_buffer_manager.new_scope()
            self.code_scalar_manager.new_scope()
        elif enter_or_exit == 0:
            self.code_buffer_manager.double_buffer_enable_stack_.pop()
            self.code_buffer_manager.del_scope()
            self.code_scalar_manager.del_scope()

    def _get_block_id(self, block_num):
        """
        get block id
        Parameters
        ----------
        block_num: block number

        Returns
        -------
        block id
        """
        block_id = None
        if self.is_multi_block:
            block_id = thread_axis("blockIdx.x")
            self._block_id = Expr(block_id.var)
        return block_id

    def _create_stmt_for_double_buffer(self, params_tuple):
        """
        create the body stmt for double buffer
        Parameters
        ----------
        params_tuple:
            dthread_var: the inner loop var for double buffer
            max_if_condition: the max loop time of for
            loop_var: the expr of dthread_var and for_var
            thread_type: the thread type
            thread_num: input num of thread

        Returns
        -------
        the stmt of the double buffer
        """
        dthread_var, max_if_condition, loop_var, thread_type, thread_num = params_tuple
        TikCheckUtil.check_not_equality(dthread_var, 0, "dthread_var is 0")
        stmt = self._pop_seq()
        begin_min_value = 0
        if max_if_condition is not None:
            stmt = tvm.tir.IfThenElse(loop_var < max_if_condition, stmt, None)
            self.source_info.set_node_span(stmt)
        attr_key = self._get_attr_key(thread_type)
        begin_min_value, thread_num = set_for_params_min_extent(loop_var.dtype, begin_min_value, thread_num)
        tmp_for = tvm.tir.For(dthread_var, begin_min_value, thread_num, 0, stmt)
        self.source_info.set_node_span(tmp_for)
        stmt = AttrStmt(tvm.thread_axis("cce"), attr_key, thread_num, tmp_for)
        self.source_info.set_node_span(stmt)
        return stmt

    def _gen_for_range_exit_cb_when_thread_one(self, params_tuple):
        """
        get serial param for multi_for_range

        Parameters
        ----------
        params_tuple : a tuple of params

        Returns
        -------
        None
        """
        block_num, block_id, endt, loop_var, begin, loop_times, for_type_id, thread_type, thread_nums = params_tuple
        if isinstance(block_num, int) and block_num == _DEFAULT_THREAD_BLOCK_NUM:
            attr_key = self._get_attr_key(thread_type)
            stmt_db = AttrStmt(tvm.thread_axis("cce"), attr_key, thread_nums, self._pop_seq())
            begin, loop_times = set_for_params_min_extent(loop_var.dtype, begin, loop_times)
            tmp_for = tvm.tir.For(loop_var, begin, loop_times, for_type_id, stmt_db)
            self.source_info.set_node_span(tmp_for)
            self.emit(tmp_for)
        else:
            TikCheckUtil.check_not_is(block_id, None, "block_id is None")
            endt = Expr(endt, loop_var.dtype).get()
            tmp_attr = AttrStmt(block_id, "thread_extent", endt, self._pop_seq())
            self.source_info.set_node_span(tmp_attr)
            self.emit(tmp_attr)

    def _for_range_block_init(self, block_num):
        """
        init value when in for_range

        Parameters
        ----------
        block_num : multiple operating cores

        Returns
        -------
        None
        """
        if not isinstance(block_num, int) or block_num > _DEFAULT_THREAD_BLOCK_NUM:
            # reset multi-core flag
            self.enable_multi_core = False
            self.for_blk_num = 1
            # barrier_sync flag
            self._sync_flag = False
            self._barrier = None
            self._block_id = None
            self.has_multi_block = False

    def _check_for_scope_level(self):
        """
        check for_scope_level

        Returns
        -------
        None
        """
        TikCheckUtil.check_ge(
            self.for_scope_level, 0, "for_scope_level(%d) should be more than 0" % self.for_scope_level)
        # check for_scope_level whether or not less than 0
        TikCheckUtil.check_ge(
            len(self.is_n_buffer_for_loop_list), 0, "is_n_buffer_for_loop_list length should be more than 0")

    def _for_range_exit_cb_init(self, thread_num, block_num, for_type):
        """
        init value when in for_range

        Parameters
        ----------
        thread_num : number of buffer
        block_num : number of block
        for_type : the type of the loop itself

        Returns
        -------
        for_type_id
        """
        self._update_code_manager_info(thread_num, 0)
        self.for_scope_level -= 1
        self._for_range_block_init(block_num)

        self.is_n_buffer_for_loop_list.pop(-1)
        self._check_if_true_in_db_loop()
        # check for_scope_level whether or not less than 0
        self._check_for_scope_level()
        for_type_id = self._get_for_type_id(for_type)
        return for_type_id

    def _multi_core_init(self, block_num):
        """
        init value when in for_range multi core

        Parameters
        ----------
        block_num : multiple operating cores
        """
        if self.is_multi_block:
            # set multi-core flag
            self.enable_multi_core = True
            self.for_blk_num = block_num
            self.has_multi_block = True
            self._is_for_multi_core.append(True)
        else:
            self._is_for_multi_core.append(False)

    def _check_begint(self, begint):
        """
        check begint of for_range

        Parameters
        ----------
        begint : begint of for_range

        Returns
        -------
        None
        """
        TikCheckUtil.check_type_match(
            begint, int, "type of begint should be int, but input is %s" % (type(begint)))

    def _check_block_num_type(self, range_tuple):
        """
        check block_num type

        Parameters
        ----------
        range_tuple : parmas tuple of for_range
        """
        # frontend tiling
        block_num = range_tuple.block_num
        endt = range_tuple.endt
        if isinstance(block_num, Scalar) and block_num.is_tiling_scalar:
            block_num = int(block_num.const_value)
        if isinstance(endt, Scalar) and endt.is_tiling_scalar:
            endt = int(endt.const_value)

        self.is_multi_block = False
        if isinstance(block_num, int) and block_num > 1:
            self.is_multi_block = True
            TikCheckUtil.check_equality(type(endt), type(block_num),
                                        "The type of endt must be the same as the type of block_num")
            self._check_begint(range_tuple.begint)
            if range_tuple.begint != 0:
                print_error_msg("begint should be 0 when block_num > 1, but input is %d" % (range_tuple.begint))
        elif isinstance(block_num, Scalar):
            self.is_multi_block = True
            if "float" in block_num.dtype:
                print_error_msg("when block_num is scalar, scalar's dtype should be int or uint ")
            if endt is not block_num:
                print_error_msg("endt and block_num should be the same scalar")
            TikCheckUtil.check_equality(type(endt), type(block_num),
                                        "The type of endt must be the same as the type of block_num")
            self._check_begint(range_tuple.begint)
            if range_tuple.begint != 0:
                print_error_msg("begint should be 0 when block_num is a Scalar, but input is %d" % (range_tuple.begint))
        TikCheckUtil.check_type_match(
            block_num, (int, Scalar), "block num of for_range should be int, Scalar")
        if isinstance(block_num, int) and isinstance(endt, int):
            if not (block_num == 1 or block_num == endt):
                print_error_msg("block_num should be 1 or %s, "
                                "but input is %s" % (endt, block_num))
        return block_num, endt

    def _check_block_nest(self):
        """
        check block nect

        Parameters
        ----------
        range_tuple : parmas tuple of for_range
        """
        if self.is_multi_block:
            self._check_block_nest_(self.has_multi_block, self.has_multi_subblk)

    def _set_buffer_num(self, thread_num):
        # set the thread num for current for_range according the outer for_range thread num
        if thread_num == 0:
            self.buffer_num = 1
        else:
            self.buffer_num = thread_num
            if self.is_n_buffer_for_loop_list:
                self.buffer_num = max(self.is_n_buffer_for_loop_list[-1], thread_num)
        self.is_n_buffer_for_loop_list.append(self.buffer_num)

    def _check_if_true_in_db_loop(self):
        """
        check if True in double buffer loop
        """
        if self.is_n_buffer_for_loop_list and self.is_n_buffer_for_loop_list[-1] > 1:
            self.is_double_buffer_for_loop = True
        else:
            self.is_double_buffer_for_loop = False

    def _init_for_range_params(self, endt):
        """
        initalize params in for_range
        """
        if self.for_scope_level == 0:
            # every time for for scope level is 0, set to False
            self.is_n_buffer_for_loop_list = []
        # into for scope increase the for_scope_level
        self.for_scope_level += 1
        if isinstance(endt, float):
            # for python3
            endt = int(endt)
        return endt

    def _multi_for_range_exit_cb_(self, params_tuple):
        """
        exit func when exit multi_for_range
        """
        for_type, var_number, loop_var_list, begin, extent_list = params_tuple
        self.for_scope_level -= 1
        # check for_scope_level whether or not less than 0
        TikCheckUtil.check_ge(
            self.for_scope_level, 0, "for_scope_level(%d) should be more than 0" % self.for_scope_level)
        for_type_id = self._get_for_type_id(for_type)
        stmt = self._pop_seq()
        for index in range(var_number - 1, -1, -1):
            begin_actual, extent_actual = set_for_params_min_extent(
                loop_var_list[index].dtype, begin[index], extent_list[index])
            stmt = tvm.tir.For(loop_var_list[index], begin_actual, extent_actual, for_type_id, stmt)
            self.source_info.set_node_span(stmt)
        self.emit(stmt)

    def _get_multi_for_range_params(self, var_number, name, dtype, control_tuple):
        """
        get serial param for multi_for_range

        Parameters
        ----------
        var_number : var number
        name : api name
        dtype : tensor dtype
        control_tuple : begint, endt

        Returns
        -------
        loop_var_list, extent_list, begin
        """
        name_list = []
        loop_var_list = []
        extent_list = []
        begin = []
        begint, endt = control_tuple
        for i in range(var_number):
            name_list.append(self._get_loop_var_name(name))
            # last_name
            loop_var_list.append(tvm.var(name_list[-1], dtype=dtype))
            if begint[i] == 0:
                extent_list.append(endt[i])
            else:
                extent_list.append(Simplify(endt[i] - begint[i]))
            if is_basic_expr([begint[i]]):
                begin.append(begint[i].get())
            else:
                begin.append(begint[i])
        return loop_var_list, extent_list, begin

    def _check_else_follow(self, scope_name):
        """
        check elif_scope and else_scope instance if_scope or elif_scope

        Parameters
        ----------
        scope_name : "if_scope" or "else_scope", for error information
        """
        if not self._seq_stack[_LAST_ELEMENT]:
            TikCheckUtil.raise_error("{} can only follow an if_scope or an elif_scope".format(scope_name))
        head = self._seq_stack[_LAST_ELEMENT][_LAST_ELEMENT]
        if not isinstance(head, tvm.tir.IfThenElse):
            TikCheckUtil.raise_error("{} can only follow an if_scope or an elif_scope".format(scope_name))

    def _gen_if_then_else(self, node, else_case, deep):
        """
        add an elif_scope or an else_scope to IfThenElse AST

        Parameters
        ----------
        node : root of IfThenElse AST, if_scope
        else_case : node to add, elif_scope or else_scope
        deep : recursion depth

        Returns
        -------
        new root of IfThenElse AST
        """
        TikCheckUtil.check_le(deep, _MAX_IFTHENELIF_DEEP, "num of elif_scope and elif_scope follow an if_scope "
                                                          "can not be over {}".format(_MAX_IFTHENELIF_DEEP))
        if not isinstance(node.else_case, tvm.tir.IfThenElse):
            return tvm.tir.IfThenElse(node.condition, node.then_case, else_case)
        return tvm.tir.IfThenElse(node.condition, node.then_case,
                                  self._gen_if_then_else(node.else_case, else_case, deep+1))

    def _pop_seq(self):
        """
        Pop sequence from stack
        """
        seq = self._seq_stack.pop()
        if not seq or callable(seq[-1]):
            tmp_node = Evaluate(0)
            self.source_info.set_node_span(tmp_node)
            seq.append(tmp_node)

        seqwrap = lambda x: x[0] if len(x) == 1 else SeqStmt(list(reversed(x)))
        ret_seq = [seq[-1]]
        for statement in reversed(seq[:-1]):
            if callable(statement):
                ret_seq = [statement(seqwrap(ret_seq))]
            else:
                TikCheckUtil.check_type_match(statement, Stmt)
                ret_seq.append(statement)
        self.is_continue = False
        self.is_break = False
        self.is_multi_block = False
        return seqwrap(ret_seq)

    def _check_continue_break_is_valid(self, is_multi_core, is_n_buffer, name):
        """
        check continue or break whether is valid
        """
        # check tik_continue and break scope
        TikCheckUtil.check_not_equality(len(is_multi_core), 0,
                                        "%s() must be used within the scope of for_range." % name)
        # Check whether multi-core is enabled in the scope of continue or break.
        TikCheckUtil.check_equality(
            is_multi_core[-1], False, 'if block_num > 1 or subblock_num > 1, for_range is not support %s().' % name)
        # Check whether n-buffer is enabled in the scope of continue or break.
        if is_n_buffer[-1]:
            self.buffer_num = 1
            TikCheckUtil.raise_warning("In current for_range(), thread_num will be set to 1, because used %s." % name)

    def _multi_core_subblock_init(self, subblock_num):
        """
        init value when in for_range multi core
        """
        if subblock_num > _DEFAULT_THREAD_BLOCK_NUM:
            self.enable_multi_core = True
            self.for_subblk_num = subblock_num
            self.has_multi_subblk = True
            self._is_for_multi_core.append(True)
        else:
            self._is_for_multi_core.append(False)

    @debug.for_range_sub_decorator
    def __for_range_subblk(self: any, sub_info: any) -> any:
        """
        Create a for iteration scope.
        note: use this function to call for_range inside!!
        """
        thread_num = sub_info.thread_num
        subblock_num = sub_info.subblock_num

        if subblock_num > _MIN_BLOCK_NUM:
            sub_info.check_subblock_nest_(self.has_multi_subblk)

        check_params_for_range(thread_num, subblock_num, sub_info.thread_type, sub_info.sub_dtype, sub_info.for_type)
        self._check_thread_block_num(thread_num, subblock_num)
        self._seq_stack.append([])
        sub_info.endt = self._init_for_range_params(sub_info.endt)
        check_begin_end_value(sub_info.begint, sub_info.endt, sub_info.sub_dtype)
        begin, offset, extent = self._get_begin_offset_and_extent(sub_info.begint, sub_info.endt)
        self._check_extent_num(extent, thread_num)
        loop_times = (extent + thread_num - 1) // thread_num

        if sub_info.name == 'i':
            sub_info.name = self._get_loop_var_name(sub_info.name)
        # modify subblock flag
        self._multi_core_subblock_init(subblock_num)
        subblock_id = sub_info.get_subblock_id(subblock_num)
        if subblock_id is not None:
            self._subblock_id = Expr(subblock_id.var)
        loop_var = self._get_loop_var(subblock_id, sub_info.name, sub_info.sub_dtype)
        self.is_n_buffer_for_loop_list.append(1)
        ret_loop_var = loop_var
        if Expr(sub_info.begint).eval_value() != 0:
            ret_loop_var = loop_var + offset
        self._update_code_manager_info(thread_num, 1)
        self.for_var_list.append(loop_var)
        self.for_begin_end.append([begin, extent - 1])

        def _exit_cb():
            self._update_code_manager_info(thread_num, 0)
            self.for_scope_level -= 1
            if subblock_num > _DEFAULT_THREAD_BLOCK_NUM:
                # reset multi-core flag
                if not self.has_multi_block:
                    self.enable_multi_core = False
                self.for_subblk_num = 1
                # barrier_sync flag
                self.sub_sync_flag = False
                self._barrier = None
                self._subblock_id = None
                self.has_multi_subblk = False
            self.is_n_buffer_for_loop_list.pop(-1)
            self._check_if_true_in_db_loop()
            TikCheckUtil.check_ge(
                self.for_scope_level, 0, "for_scope_level(%d) should be more than 0" % self.for_scope_level)
            TikCheckUtil.check_ge(
                len(self.is_n_buffer_for_loop_list), 0, "is_n_buffer_for_loop_list length should be more than 0")
            self._gen_for_range_exit_cb_when_thread_one((sub_info.subblock_num, subblock_id, sub_info.endt, loop_var,
                                                        begin, loop_times, self._get_for_type_id(sub_info.for_type),
                                                        sub_info.thread_type, thread_num))
            if not self.is_n_buffer_for_loop_list:
                self.is_double_buffer_for_loop = False
                self.buffer_num = 1
            self._is_for_multi_core.pop()
            if len(self.for_begin_end) > 0:
                self.for_begin_end.pop()
            if len(self.for_var_list) > 0:
                self.for_var_list.pop()
        with_scope = TikWithScope(ret_loop_var, _exit_cb, self.source_info.get_source_info())
        with_scope.debug_hint = [(loop_var, (begin, loop_times))]
        with_scope.debug_limit = (loop_var, extent)
        return with_scope

    def _get_loop_var_name(self, name):
        if self.nidx < _MIN_NIDX:
            name = chr(ord(name) + self.nidx)
        else:
            name = "%s_%d" % (name, (self.nidx - _MIN_NIDX))
        self.nidx += 1
        return name

    def _get_dthread_for_loop_var(self, name, dtype, thread_num):
        name_dthread = "%s_thread_%d" % (name, self.nidx)
        dthread_var = tvm.var(name_dthread, dtype=dtype)

        name_for = "%s_for_%d" % (name, self.nidx)
        for_var = tvm.var(name_for, dtype=dtype)

        loop_var = for_var * thread_num + dthread_var
        return dthread_var, for_var, loop_var
