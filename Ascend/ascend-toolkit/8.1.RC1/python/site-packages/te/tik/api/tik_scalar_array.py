#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_scalar.py
DESC:     scalar
CREATED:  2019-04-18 18:53:42
MODIFIED: 2019-07-18 21:29:18
"""
from tbe import tvm
from tbe.common.platform import scope_reg
from tbe.tik import debug
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_scalar_array_ import ScalarArrayInner


@debug.scalar_array_register
class ScalarArray(ScalarArrayInner):
    """
    hint:scalar array
    """
    def __init__(self, ir_generator, dtype="int64", length=1, name="reg_buf", init_value=None, buffer_=None,
                 offset=None, debug_var=None):
        """
        scalar array initialization
        Parameters
        ----------
        ir_generator:Halide IR generator
        dtype:scalar array data type
        length:scalar array length
        name:scalar array  name
        init_value:scalar array value
        buffer_:reg buffer
        offset:offset
        debug_var:debug var

        Returns
        ----------
        return:no return
        """
        self.__check_scalar_array_params(dtype, length, name)
        ScalarArrayInner.__init__(self, ir_generator)

        self.ir_generator = ir_generator
        self.dtype = dtype
        self.length = length
        self.offset = 0

        # if any of below is None, new buffer will be created
        if buffer_ is None or offset is None or debug_var is None:
            Scalar.COUNT += 1
            self._name = '%s%s' % (name, str(Scalar.COUNT))
            self.debug_var = [tvm.var('scalar_debug_var_%s_%s' % (self._name, str(i)), dtype)
                              for i in range(length)]
            self._set_reg_buffer(init_value, dtype)
            ir_generator.code_scalar_manager.new_scalar(self)
        else:
            self._name = name
            self.debug_var = debug_var
            self.reg_buffer = buffer_
            self.offset = offset

    @source_info_decorator()
    def __getitem__(self, index_in):
        """
        Obtains a new scalar from scalar array.

        Parameters
        ----------
        index_in : scalar array index. The options are as follows:
        -          int, Scalar, Expr type.

        Returns
        -------
        A new Scalar
        """
        if not isinstance(index_in, (int, Scalar, Expr, tvm.tir.IntImm)):
            TikCheckUtil.raise_error(
                "index should be int, Scalar or Expr.")
        if isinstance(index_in, (Scalar, Expr)):
            if not index_in.dtype.startswith(("int", "uint")):
                TikCheckUtil.raise_error(
                    "When the index is Scalar or Expr, it's dtype cannot be float.")
        index_in_eval = Expr(index_in).eval_value()
        if index_in_eval is not None:
            if index_in_eval < 0:
                index_in_eval += self.length
            if index_in_eval < 0 or index_in_eval >= self.length:
                TikCheckUtil.raise_error(
                    "index(%d) out of range, it should be in range [0, %d)." %
                    (index_in, self.length))
            index_in = index_in_eval
        return self.get_scalar_by_index(index_in)

    @staticmethod
    def __check_scalar_array_params(dtype, length, name):
        """
        check scalar params

        Parameters
        ----------
        dtype: scalar array data type
        length: scalar array length
        name: scalar array  name

        Returns
        -------
        None
        """
        TikCheckUtil.check_type_match(dtype, str, "dtype should be str")
        TikCheckUtil.check_type_match(length, (int, tvm.tir.IntImm),
                                      "length should be Int")
        if isinstance(length, tvm.tir.IntImm):
            length = length.value
        if length <= 0:
            TikCheckUtil.raise_error("invalid length: %s" % length)
        TikCheckUtil.check_name_str_valid(name)

    @source_info_decorator()
    @debug.scalar_array_set_as_decorator
    def set_as(self, value):
        """
        Sets the scalar array value.

        Parameters
        ----------
        value : Value to be assigned from:
        -       An immediate of type int or float
        -       A Scalar variable
        -       A Tensor value
        -       An Expr (consisting of a Scalar variable and an immediate)
        -       A list / tuple of immediate, Scalar, Tensor value or Expr

        Returns
        -------
        no return
        """
        with self.ir_generator.context.freeze():
            if isinstance(value, (list, tuple)):
                TikCheckUtil.check_equality(
                    len(value), self.length, "length of value(%d) should be equal to "
                                             "length of ScalarArray(%d)." % (len(value), self.length))
                for i in range(self.length):
                    self[i].set_as(value[i])
            else:
                with self.ir_generator.for_range(0, self.length) as i:
                    self[i].set_as(value)

    def _set_reg_buffer(self, init_value, dtype):
        """
        Sets the reg_buffer for ScalarArray.
        Description: Sets the reg_buffer for ScalarArray.
        Args:
        init_value : Value to be assigned from:
        - An immediate of type int or float
        - A Scalar variable
        - A Tensor value
        - An Expr (consisting of a Scalar variable and an immediate)
        - A list / tuple of immediate, Scalar, Tensor value or Expr
        dtype: ScalarArray dtype

        Returns: None
        """
        with self.ir_generator.context.freeze():
            if init_value is None:
                self.reg_buffer = self.ir_generator.allocate(
                    (dtype, (self.length, ), self._name), scope=scope_reg)
            elif isinstance(init_value, (list, tuple)):
                TikCheckUtil.check_equality(
                    len(init_value), self.length, "length of init_value(%d) should be equal to "
                                                  "length of ScalarArray(%d)." % (len(init_value), self.length))
                init_value_imm = [0] * self.length
                is_init_value_imm = [False] * self.length
                for i, value in enumerate(init_value):
                    if isinstance(value, (int, float)):
                        init_value_imm[i] = value
                        is_init_value_imm[i] = True
                # init_value of imm will be set in reg_buffer here
                self.reg_buffer = self.ir_generator.allocate(
                    (dtype, (self.length,), self._name), scope=scope_reg, init_value=init_value_imm)
                for i, flag in enumerate(is_init_value_imm):
                    if not flag:
                        self[i].set_as(init_value[i])
            else:
                if isinstance(init_value, (int, float)):
                    init_value_imm = [init_value] * self.length
                    self.reg_buffer = self.ir_generator.allocate(
                        (dtype, (self.length, ), self._name), scope=scope_reg, init_value=init_value_imm)
                else:
                    self.reg_buffer = self.ir_generator.allocate(
                        (dtype, (self.length, ), self._name), scope=scope_reg)
                    with self.ir_generator.for_range(0, self.length) as i:
                        self[i].set_as(init_value)
