#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     load3dv2_cylces.py
DESC:     for evaluate load3dv2 instructions cost times
CREATED:  2022-3-26 17:35:36
MODIFIED: 2022-3-26 19:17:00
"""

import math
from collections import namedtuple

from tbe.common.platform.platform_info import get_soc_spec
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.tik_lib.tik_params import BYTE_PER_FRACTAL
from tbe.tik.tik_lib.tik_params import C1_C04
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager

TilingCyclesEvalParams = namedtuple("TilingCyclesEvalParams",
                                    ["fm_desc", "filter_dsec", "m_tile_block", "k_tile_block", "c_0"])

IsPingPongBufRdyParams = namedtuple("IsPingPongBufRdyParams", ["isa_para", "index_i", "index_j", "write_offset",
                                                               "fetch_num", "fpoint", "fetch_size"])


class IsaPara:
    """
    for record the load3d params
    """

    def __init__(self, blk_c_size, fm_desc, filter_desc):
        self.src_data_size = DTYPE_SIZE[fm_desc.input_dtype]
        self.blk_c_size = blk_c_size
        self.fm_desc = fm_desc
        self.filter = filter_desc
        self.k_e = 0
        self.k_s = 0
        self.m_s = 0
        self.m_start = 0
        self.m_e = 0
        self.k_e_origin = 0
        self.k_s_origin = 0
        self.k_length_origin = 0
        self.repeat_times = 0
        self.filter_pos_w = 0
        self.filter_pos_h = 0
        self.num_c0 = 0
        self.cx = 0
        self.x = 0
        self.y = 0
        self.c = 0
        self.c_size_type = 3
        self.c_size_type_origin = 3
        self.l1_3d_size_byte = get_soc_spec("L1_SIZE")
        self.valid_fetch_length = 0
        self.img2col_c0_size = 0
        self.img2col_c0_size_p = 0
        self.c_offset = 0
        self.c_size_split = 0
        self.fetch_pos_w = 0
        self.fetch_pos_h = 0
        self.c_dim_idx = 0
        self.k_length = 0
        self.fm_c_size = 0
        self.src_addr = 0
        self.c0_opt2 = False
        self.repeat_num = 0
        self.fpoints = []
        self.channel_size = filter_desc.cin


def load3dv2_decode(tiling_cycles_eval_params):
    """
    according the input params create a IsaPara object
    Parameters
    ----------
    tiling_cycles_eval_params: input params of load3dv2

    Returns
    -------
    the instruction decode result

    """
    instr_q = []
    isa_para = IsaPara(tiling_cycles_eval_params.c_0, tiling_cycles_eval_params.fm_desc,
                       tiling_cycles_eval_params.filter_dsec)

    load3dv2_decode_rpt(tiling_cycles_eval_params, isa_para)

    instr_q.append(isa_para)
    return instr_q


class FPoint:
    """
    for record the read site of FM
    """

    def __init__(self):
        self.read_addr = 0
        self.read_size = 0
        self.x = 0
        self.y = 0
        self.c = 0
        self.is_pad = False
        self.write_addr_right = 0
        self.write_addr_right1 = 0
        self.write_addr1 = 0
        self.flush_set = False
        self.fm_c_size = 0
        self.src_addr = 0
        self.k_length = 0
        self.k_flush_length = 0
        self.is_invalid_k = False
        self.retire_set = 0
        self.filter_w_remain = 0
        self.row_switch = False


def split_csize_type(isa, iteration_num_w):
    """
    according current isa's c_size_split and c_size_type to c_size_split/iteration_num_w/c_size_type
    Parameters
    ----------
    isa: IsaPara object
    iteration_num_w: current data num of W

    Returns
    -------
    new iteration_num_w

    """
    if isa.c_size_split == 1 and isa.c_size_type == 2:
        isa.c_size_type = 1
        if isa.cx <= 0:
            return 0
        isa.fm_c_size = isa.cx
        isa.c_dim_idx = 0  # the reminder is only 1
        # c_offset is used as the mask for the write operation for small channel,
        # there is an assumption that the offset is no more than a cx, it may not be true for the filter_w extension.
        # but it still be ok to write more. for the c_offset, we just overwrite it
        isa.c_offset = 0
        isa.fetch_pos_w = 0
        isa.fetch_pos_h = 0
        # add the address of the num_c0
        isa.src_addr = isa.src_addr_origin + isa.fm_w * isa.fm_h * (isa.num_c0 / isa.filter_w / isa.filter_h * 32)
        isa.K_s = isa.num_c0
        isa.K_e = isa.K_e_origin
        isa.k_length = isa.K_length_origin - isa.k_length
        isa.c_size_type = 3
        iteration_num_w = 0 - isa.c_offset
    elif isa.c_size_split == 1 and isa.c_size_type == 3:
        isa.c_size_split = 0
    else:
        isa.c_size_type = 3
    return iteration_num_w


def compute_coord_valid(iteration_num_w, isa_para, fp):
    """
    check whether current iteration coord is valid
    Parameters
    ----------
    iteration_num_w: iteration w size
    isa_para: IsaPara object
    fp: read data of L1 FM point info

    Returns
    -------

    """
    if iteration_num_w + isa_para.fm_c_size > isa_para.channel_size * isa_para.filter.width * isa_para.filter.height:
        fp.is_invalid_k = True
    # for the case for cross-c0, the iteration_num_w is not accurate
    elif (fp.fm_c_size != isa_para.blk_c_size) and (fp.c > 0):
        fp.is_invalid_k = True
    else:
        fp.is_invalid_k = False


def compute_w_k(compute_params):
    """
    iteration num of W must less then K extension size
    Parameters
    ----------
    compute_params

    Returns
    -------
    iteration_num_w
    """
    iteration_num_w, isa_para, fetch_pos_c, k_padding_length, fetch_pos_w, fetch_pos_h, stride_w, stride_h, \
    filter_pos_w, filter_pos_h, dilation_w, dilation_h = compute_params

    while iteration_num_w < k_padding_length:
        cur_iter_fetch_pos_w = filter_pos_w
        cur_iter_fetch_pos_h = filter_pos_h
        cur_iter_fetch_pos_c = fetch_pos_c
        for j in range(0, isa_para.img2col_c0_size):  # img2col_c0_size is 16, create 16 FP
            fp = FPoint()
            fp.x = cur_iter_fetch_pos_w + dilation_w * fetch_pos_w
            fp.y = cur_iter_fetch_pos_h + dilation_h * fetch_pos_h
            fp.c = cur_iter_fetch_pos_c
            fp.flush_set = 0
            if (iteration_num_w + isa_para.fm_c_size) >= isa_para.k_length:  # K direction is full
                fp.flush_set = 1
            fp.k_flush_length = isa_para.src_data_size * (isa_para.k_length - iteration_num_w)
            fp.fm_c_size = isa_para.fm_c_size
            fp.src_addr = isa_para.src_addr
            fp.k_length = isa_para.k_length

            fp.filter_w_remain = isa_para.filter.width - filter_pos_w
            if fp.filter_w_remain < 0:
                fp.filter_w_remain = 65535

            compute_coord_valid(iteration_num_w, isa_para, fp)  # check coord is valid

            # update coordinate
            cur_iter_fetch_pos_w += stride_w

            if cur_iter_fetch_pos_w > isa_para.valid_fetch_length:
                cur_iter_fetch_pos_w = 0 - isa_para.fm_desc.pad_list[0]
                cur_iter_fetch_pos_h += stride_h
                fp.row_switch = True  # multi line will cost more cycles
            isa_para.fpoints.append(fp)

        isa_para.repeat_num = isa_para.repeat_num + 1  # create 16 coord add one repeat

        # update the read site of FM
        fetch_pos_w += 1
        if fetch_pos_w >= isa_para.filter.width:
            fetch_pos_w = 0
            fetch_pos_h += 1
            if fetch_pos_h >= isa_para.filter.height:
                fetch_pos_h = 0
                fetch_pos_c += 1

        iteration_num_w = iteration_num_w + isa_para.fm_c_size
    return iteration_num_w


def compute_coord(tiling_cycles_eval_params, isa_para):
    """
    according the load3dv2 params to calculate the coord for each read operator
    Parameters
    ----------
    tiling_cycles_eval_params: load3dv2 params
    isa_para: IsaPara object for save the coord info

    Returns
    -------

    """
    # get load3dv2 params
    dilation_w = isa_para.fm_desc.dilation_w
    dilation_h = isa_para.fm_desc.dilation_h
    filter_pos_w = isa_para.filter_pos_w
    filter_pos_h = isa_para.filter_pos_h
    stride_w = isa_para.fm_desc.stride_w
    stride_h = isa_para.fm_desc.stride_h
    iteration_num_w = 0 - isa_para.c_offset
    iteration_num_h = 0
    m_length_frac = tiling_cycles_eval_params.m_tile_block

    # iteration num of H must less then M block nums
    while iteration_num_h < m_length_frac:
        cur_iter_fetch_pos_w = filter_pos_w
        cur_iter_fetch_pos_h = filter_pos_h

        # 3 is QFINISH_ONCE
        while (isa_para.c_size_split == 1) or (isa_para.c_size_type != 3):
            fetch_pos_w = isa_para.fetch_pos_w
            fetch_pos_h = isa_para.fetch_pos_h
            fetch_pos_c = isa_para.c_dim_idx
            k_padding_length = isa_para.k_length  # K extension, k_tile_block multi k_block_size

            iteration_num_w = compute_w_k([iteration_num_w, isa_para, fetch_pos_c, k_padding_length, fetch_pos_w,
                                           fetch_pos_h, stride_w, stride_h, filter_pos_w, filter_pos_h, dilation_w,
                                           dilation_h])
            # for the case of split
            iteration_num_w = split_csize_type(isa_para, iteration_num_w)

        isa_para.c_size_type = isa_para.c_size_type_origin
        iteration_num_w = 0 - isa_para.c_offset
        iteration_num_h += 1

        filter_pos_w = cur_iter_fetch_pos_w
        filter_pos_h = cur_iter_fetch_pos_h


def compute_is_pad(isa_para):
    """
    check the read point whether is pad site
    Parameters
    ----------
    isa_para: IsaPara object

    Returns
    -------

    """
    for index in range(0, len(isa_para.fpoints)):
        fpoint = isa_para.fpoints[index]
        if (fpoint.x >= 0) and (fpoint.x < isa_para.fm_desc.w_i) and \
                (fpoint.y >= 0) and (fpoint.y < isa_para.fm_desc.h_i):
            isa_para.fpoints[index].is_pad = False
        else:
            isa_para.fpoints[index].is_pad = True


def compute_fm_addr(isa_para):
    """
    compute the FM addr according the read point
    Parameters
    ----------
    isa_para: IsaPara object

    Returns
    -------

    """
    point_sz = 32
    if isa_para.c0_opt2 is True:
        point_sz = 8

    for index in range(0, len(isa_para.fpoints)):
        fpoint = isa_para.fpoints[index]
        read_addr = fpoint.src_addr + \
                    (fpoint.x + fpoint.y * isa_para.fm_desc.w_i +
                     fpoint.c * isa_para.fm_desc.w_i * isa_para.fm_desc.h_i) * \
                    fpoint.fm_c_size * isa_para.src_data_size
        isa_para.fpoints[index].read_addr = read_addr % isa_para.l1_3d_size_byte
        if fpoint.read_addr + point_sz > isa_para.l1_3d_size_byte:
            fpoint.row_switch = True


def load3dv2_decode_para_pre(tiling_cycles_eval_params, isa_para):
    """
    init the isa_para according the load3dv2 params
    Parameters
    ----------
    tiling_cycles_eval_params: load3dv2 params
    isa_para: IsaPara object need to init

    Returns
    -------

    """
    isa_para.k_s = 0
    isa_para.m_s = 0
    isa_para.k_e = tiling_cycles_eval_params.k_tile_block
    isa_para.m_e = tiling_cycles_eval_params.m_tile_block
    isa_para.k_e_origin = isa_para.k_e
    isa_para.k_s_origin = isa_para.k_s
    isa_para.k_length_origin = isa_para.k_e * isa_para.blk_c_size
    isa_para.k_length = isa_para.k_e * isa_para.blk_c_size
    isa_para.repeat_times = isa_para.k_e

    if isa_para.blk_c_size != C1_C04:
        isa_para.filter_pos_w = (isa_para.m_start % isa_para.fm_desc.w_o) * isa_para.fm_desc.stride_w - \
                                isa_para.fm_desc.pad_list[0]
        isa_para.filter_pos_h = (isa_para.m_start % isa_para.fm_desc.w_o) * isa_para.fm_desc.stride_h - \
                                isa_para.fm_desc.pad_list[2]
    else:
        isa_para.filter_pos_w = (isa_para.m_s * 32 % isa_para.fm_desc.w_o) * isa_para.fm_desc.stride_w - \
                                isa_para.fm_desc.pad_list[0]
        isa_para.filter_pos_h = (isa_para.m_s * 32 % isa_para.fm_desc.w_o) * isa_para.fm_desc.stride_h - \
                                isa_para.fm_desc.pad_list[2]

    isa_para.num_c0 = (isa_para.channel_size // isa_para.blk_c_size) * isa_para.filter.width * isa_para.filter.height
    isa_para.cx = isa_para.channel_size % isa_para.blk_c_size
    if isa_para.k_e <= isa_para.num_c0:
        isa_para.c_size_type = 0
    elif isa_para.k_s >= isa_para.num_c0:
        isa_para.c_size_type = 1
    else:
        isa_para.c_size_type = 2
        raise RuntimeError(" current don't support isa_para.c_size_type is 2")


def load3dv2_decode_para_post(isa_para):
    """
    update the isa_para info according it's init value
    Parameters
    ----------
    isa_para: IsaPara object

    Returns
    -------

    """
    if isa_para.c_size_type == 0:
        isa_para.fm_c_size = isa_para.blk_c_size
        isa_para.cx = isa_para.blk_c_size
        rem = (isa_para.k_s % (isa_para.filter.width * isa_para.filter.height))
        isa_para.fetch_pos_w = rem % isa_para.filter.width
        isa_para.fetch_pos_h = rem // isa_para.filter.width
        isa_para.c_dim_idx = isa_para.k_s // (isa_para.filter.width * isa_para.filter.height)
    elif isa_para.c_size_type == 1:
        if isa_para.cx == 0:
            isa_para.cx = 8
        isa_para.fm_c_size = isa_para.cx
        rem = math.floor((isa_para.k_s - isa_para.num_c0) * isa_para.blk_c_size / isa_para.cx)
        isa_para.c_dim_idx = 0
        isa_para.c_offset = (isa_para.k_s - isa_para.num_c0) * isa_para.blk_c_size % isa_para.cx
        isa_para.fetch_pos_w = rem % isa_para.filter.width
        isa_para.fetch_pos_h = math.floor(rem / isa_para.filter.width)
        isa_para.src_addr = isa_para.src_addr + \
                            math.ceil(isa_para.fm_desc.w_i * isa_para.fm_desc.h_i *
                                      (isa_para.num_c0 / isa_para.filter.width / isa_para.filter.height * 32))
    else:
        raise RuntimeError("isa_para.c_size_type can only be 0 or 1")

    isa_para.c_size_type_origin = isa_para.c_size_type


def load3dv2_decode_rpt(tiling_cycles_eval_params, isa_para):
    """
    according the load3dv2 params to init the isa_para
    Parameters
    ----------
    tiling_cycles_eval_params: load3dv2 params
    isa_para: IsaPara object need to be init

    Returns
    -------

    """
    fm_desc = tiling_cycles_eval_params.fm_desc
    filter_desc = tiling_cycles_eval_params.filter_dsec

    load3dv2_decode_para_pre(tiling_cycles_eval_params, isa_para)
    load3dv2_decode_para_post(isa_para)

    dilated_filter_w = (filter_desc.width - 1) * fm_desc.dilation_w + 1
    isa_para.valid_fetch_length = fm_desc.w_i + fm_desc.pad_list[1] - dilated_filter_w
    isa_para.img2col_c0_size = 16
    isa_para.img2col_c0_size_p = BYTE_PER_FRACTAL // isa_para.img2col_c0_size

    compute_coord(tiling_cycles_eval_params, isa_para)
    compute_is_pad(isa_para)
    compute_fm_addr(isa_para)


def is_pingpong_buf_rdy(is_pingpong_buf_rdy_params):
    """
    check whether read data can be write to L0A and update the write offset
    Parameters
    ----------
    is_pingpong_buf_rdy_params: isa_para, index_i, index_j, write_offset, fetch_num, fpoint, fetch_size
    -isa_para: IsaPara object
    -index_i: index of w in a fractal
    -index_j: index of c in a fractal
    -write_offset: offset of L0A
    -fetch_num: once read nums
    -fpoint: coord point
    -fetch_size: read size

    Returns
    -------
    write_en: whether can be write
    write_offset: offset of L0A

    """
    write_en = False
    write_offset = is_pingpong_buf_rdy_params.write_offset
    if is_pingpong_buf_rdy_params.index_j + 1 >= is_pingpong_buf_rdy_params.isa_para.img2col_c0_size:
        write_en = True

    if write_en is True:
        write_offset += is_pingpong_buf_rdy_params.fetch_size
        if write_offset >= is_pingpong_buf_rdy_params.isa_para.img2col_c0_size_p:
            write_offset -= is_pingpong_buf_rdy_params.isa_para.img2col_c0_size_p
        elif write_offset != 0 and is_pingpong_buf_rdy_params.fpoint.flush_set == 1:
            write_offset = 0
        elif write_offset != 0 and (is_pingpong_buf_rdy_params.index_i + is_pingpong_buf_rdy_params.fetch_num) >= \
                (len(is_pingpong_buf_rdy_params.isa_para.fpoints) //
                 is_pingpong_buf_rdy_params.isa_para.img2col_c0_size):
            write_offset = 0
        else:
            write_en = False
    return write_en, write_offset


def compute_fetch_count(fm_desc):
    """
    read one fractal from FM of L1 can create w size of L0A
    Parameters
    ----------
    fm_desc: FM info

    Returns
    -------
    once fetch count of w

    """
    count = 1
    if fm_desc.stride_w in [1, 2, 4, 8]:
        count = (((BYTE_PER_FRACTAL / fm_desc.cin) - 1) / fm_desc.stride_w) + 1
        count = min(count, 16)
    return count


def get_fetch_nums(fm_desc, blk_c_size, fpoint):
    """
    calculate fetch once can get how much k of L0A
    Parameters
    ----------
    fm_desc: FM info
    blk_c_size: c size
    fpoint: read point

    Returns
    -------
    fetch data nums

    """
    max_fetch_num = math.ceil(blk_c_size / fpoint.fm_c_size)
    fetch_num = min(max_fetch_num, fpoint.k_flush_length)
    fetch_num = min(fetch_num, fpoint.filter_w_remain)
    if fm_desc.dilation_w != 1:
        fetch_num = 1
    if fetch_num == 0:
        fetch_num = 1
    return fetch_num


def _ticks_count_with_img2col(params):
    """
    rd total ticks coutn with img2col c0 size
    Parameters
    ----------
    params

    Returns
    -------

    """
    isa_para, point_cnt, write_offset, index_i, fetch_nums, fpoint, fetch_size, is_invalid_k, \
        fp_index, count, fm_desc, one_c0_data_size, rd_total_ticks, rd_bw, fpoints_nums = params
    for index_j in range(0, isa_para.img2col_c0_size):
        point_cnt += 1
        is_pingpong_buf_rdy_params = IsPingPongBufRdyParams(isa_para, index_i, index_j, write_offset,
                                                            fetch_nums, fpoint, fetch_size)
        write_en, write_offset = is_pingpong_buf_rdy(is_pingpong_buf_rdy_params)
        if is_invalid_k is True and isa_para.fpoints[fp_index + index_j].is_invalid_k is False:
            is_invalid_k = False
        if isa_para.fpoints[fp_index + index_j].row_switch or point_cnt >= count or write_en is True:
            read_size = (point_cnt - 1) * fm_desc.stride_w * one_c0_data_size + fetch_size
            point_cnt = 0
            if is_invalid_k is True:
                continue
            rd_total_ticks += math.ceil(read_size / rd_bw)
            if fp_index + index_j + 1 < fpoints_nums:
                is_invalid_k = isa_para.fpoints[fp_index + index_j + 1].is_invalid_k

    return rd_total_ticks


def eval_load3dv2_cycles(tiling_cycles_eval_params):
    """
    for calculate the read FM times of load3d according the m_tile_block and k_tile_block
    Parameters
    ----------
    tiling_cycles_eval_params: input params of load3dv2

    Returns
    -------
    the read times

    """
    rd_total_ticks = 0
    fm_desc = tiling_cycles_eval_params.fm_desc

    # analysis load3dv2 process
    instr_q = load3dv2_decode(tiling_cycles_eval_params)
    rd_bw = 512  # read byte width of L1 to L0A
    if TikSocManager.is_910b_soc():
        rd_bw = 256  # 910b l1_to_l0a's widthbyte is 256B
    # according the analysis result calculate read times
    for isa_para in instr_q:
        is_invalid_k = isa_para.fpoints[0].is_invalid_k
        write_offset = 0
        count = compute_fetch_count(fm_desc)

        index_i = 0
        fpoints_nums = len(isa_para.fpoints)
        max_loop_times = fpoints_nums // isa_para.img2col_c0_size
        while index_i < max_loop_times:
            fp_index = index_i * isa_para.img2col_c0_size
            point_cnt = 0
            fpoint = isa_para.fpoints[fp_index]
            fetch_nums = get_fetch_nums(fm_desc, isa_para.blk_c_size, fpoint)

            one_c0_data_size = DTYPE_SIZE[fm_desc.input_dtype] * fpoint.fm_c_size
            fetch_size = one_c0_data_size * fetch_nums

            # according stride_w and fetch_size update count
            if fm_desc.stride_w == 8 or count == 1:
                count = 1
            else:
                count = min(BYTE_PER_FRACTAL // fetch_size, isa_para.img2col_c0_size)

            rd_total_ticks = _ticks_count_with_img2col(
                [isa_para, point_cnt, write_offset, index_i, fetch_nums, fpoint, fetch_size, is_invalid_k,
                 fp_index, count, fm_desc, one_c0_data_size, rd_total_ticks, rd_bw, fpoints_nums])

            index_i += fetch_nums
    return rd_total_ticks
