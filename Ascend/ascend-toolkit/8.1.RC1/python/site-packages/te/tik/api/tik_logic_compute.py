#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_logic_compute.py
DESC:     api of tik.all and tik.any, all/any for tik if_scope, elif_scope condition expr
CREATED:  2021-12-11 19:53:00
MODIFIED: 2020-12-15 19:55:00
"""
from tbe import tvm
from tbe.tik.common.common_util import is_scalar
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_expr import invalid_dtype_for_version
from tbe.tik.tik_lib.tik_source_info import source_info_decorator

_CONST_TRUE = 1
_CONST_FALSE = 0
# non comparison type tvm expr
_TVM_NON_CMP_EXPR_MAP = (
    tvm.tir.IntImm, tvm.tir.FloatImm, tvm.tir.Cast, tvm.tir.Var, tvm.tir.Add, tvm.tir.Sub, tvm.tir.Mul,
    tvm.tir.Mod, tvm.tir.FloorMod, tvm.tir.Min, tvm.tir.Max, tvm.tir.Load, tvm.tir.Div, tvm.tir.FloorDiv
)


def _check_scalar(arg, name):
    """
    check func argument when argument type is scalar
    Parameters
    ----------
    name: func name
    arg: argument

    Returns
    -------
    None
    """
    if hasattr(arg, "dtype") and arg.dtype in invalid_dtype_for_version():
        TikCheckUtil.raise_error("scalar is not support %s for %s" % (arg.dtype, name))


def _check_args_dtype(args, print_name):
    """
    check args dtype for any,all,negate

    Parameters
    ----------
    args : input argument
    print_name : name of interface

    Returns
    -------
    args_new
    """
    args_new = []
    for i in args:
        # If you import at the top of the file, it causes a loop
        if isinstance(i, (int, float, bool)):
            args_new.append(tvm.const(_CONST_TRUE if i else _CONST_FALSE, "uint1"))
        elif isinstance(i, Expr):
            if isinstance(i.get(), _TVM_NON_CMP_EXPR_MAP):
                _check_scalar(i, print_name)
                args_new.append(tvm.tir.NE(i.get(), 0))
            else:
                args_new.append(i.get())
        elif is_scalar(i):
            _check_scalar(i, print_name)
            args_new.append(tvm.tir.NE(i.get(), 0))
        else:
            TikCheckUtil.raise_error("%s only support Bool, Immediate, Scalar, InputScalar, Expr" % print_name)

    if not args_new:
        raise TikCheckUtil.raise_error("%s must take at least 1 argument" % print_name)

    return args_new


@source_info_decorator()
def all(*args):
    """
    judging whether the all input argument result are true
    For example: a and b and c and ...

    Parameters
    ----------
    args :input argument

    Returns
    -------
    bool all result
    """

    # If you import at the top of the file, it causes a loop
    args_new = _check_args_dtype(args, "all")
    return Expr(tvm.tir.all(*args_new))


@source_info_decorator()
def any(*args):
    """
    judging whether any result are true
    For example: a or b or c or ...

    Parameters
    ----------
    args :input argument

    Returns
    -------
    bool or result
    """

    # If you import at the top of the file, it causes a loop

    args_new = _check_args_dtype(args, "any")
    return Expr(tvm.tir.any(*args_new))


@source_info_decorator()
def negate(cond):
    """
    negate operands
    For example: !a, !(a<1) ...

    Parameters
    ----------
    cond :input argument

    Returns
    -------
    expr
    """
    args_new = _check_args_dtype((cond, ), "negate")
    return Expr(tvm.tir.negate(*args_new))
