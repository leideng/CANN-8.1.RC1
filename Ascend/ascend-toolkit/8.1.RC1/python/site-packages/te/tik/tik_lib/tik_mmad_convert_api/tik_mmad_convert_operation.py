#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_mmad_convert_operation.py
DESC:     tik_mmad_conver_operation
CREATED:  2021-12-03 5:59 AM
MODIFIED: 2021-12-03 5:59 AM
"""
from tbe import tvm
from tbe.common.platform import scope_ca
from tbe.common.platform import scope_cb
from tbe.common.platform import scope_ubuf
from tbe.common.platform import scope_cbuf
from tbe.common.platform import api_check_support
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.tik.common.tik_api_map import ASCEND_910
from tbe.tik.common.tik_api_map import HI3796CV300ES
from tbe.tik.common.tik_api_map import ASCEND_910B
from tbe.tik.common.tik_api_map import VEC_610
from tbe.tik.common.tik_api_map import VEC_310P
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import reduce_mul
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import TikUtil
from tbe.tik.common.common_util import check_address_align
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_soc_core_type
from tbe.tik.debug.mmad_decorators import load2dv1_decorator
from tbe.tik.debug.mmad_decorators import load2dv3_decorator
from tbe.tik.debug.mmad_decorators import load3dv1_decorator
from tbe.tik.debug.mmad_decorators import load3dv2_decorator
from tbe.tik.debug.mmad_decorators import col2img_decorator
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_api_util import check_repeat_times
from tbe.tik.tik_lib.tik_api_util import do_load3d_padding
from tbe.tik.tik_lib.tik_api_constants import SCOPE_MAP
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_api_constants import LOAD2D_DMA_LIST
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_util import concat_params
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_params import REG_FCOL2IMG_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import REG_FCOL2IMG_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import MAX_START_PT
from tbe.tik.tik_lib.tik_params import ELE_PER_FRACTAL_EDGE
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_params import MIN_EXTENSION
from tbe.tik.tik_lib.tik_params import MAX_EXTENSION
from tbe.tik.tik_lib.tik_params import MAX_FETCH_POS
from tbe.tik.tik_lib.tik_params import MIN_START_POINT
from tbe.tik.tik_lib.tik_params import MAX_START_POINT
from tbe.tik.tik_lib.tik_params import PAD_LENGTH
from tbe.tik.tik_lib.tik_params import PADDING_LEFT_IDX
from tbe.tik.tik_lib.tik_params import MAX_PADDING
from tbe.tik.tik_lib.tik_params import PADDING_RIGHT_IDX
from tbe.tik.tik_lib.tik_params import PADDING_TOP_IDX
from tbe.tik.tik_lib.tik_params import PADDING_BOT_IDX
from tbe.tik.tik_lib.tik_params import MIN_TENSOR_WIDTH
from tbe.tik.tik_lib.tik_params import MAX_TENSOR_WIDTH
from tbe.tik.tik_lib.tik_params import MIN_STRIDE
from tbe.tik.tik_lib.tik_params import MAX_STRIDE
from tbe.tik.tik_lib.tik_params import MIN_FILTER_WIDTH
from tbe.tik.tik_lib.tik_params import MAX_FILTER_WIDTH
from tbe.tik.tik_lib.tik_params import MIN_DILATION
from tbe.tik.tik_lib.tik_params import MAX_DILATION
from tbe.tik.tik_lib.tik_params import MAX_C1_INDEX
from tbe.tik.tik_lib.tik_params import MIN_JUMP_OFFSET
from tbe.tik.tik_lib.tik_params import MAX_JUMP_OFFSET
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_MODE
from tbe.tik.tik_lib.tik_params import MAX_C_SIZE
from tbe.tik.tik_lib.tik_params import PIPE_MTE1
from tbe.tik.tik_lib.tik_params import FMATRIX_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import FMATRIX_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import DST_TYPE_LEN
from tbe.tik.tik_lib.tik_params import INC_MODE
from tbe.tik.tik_lib.tik_params import DEC_MODE
from tbe.tik.tik_lib.tik_params import MAX_START_INDEX
from tbe.tik.tik_lib.tik_params import MAX_DST_GAP_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_BLK_STRIDE_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_SID
from tbe.tik.tik_lib.tik_params import BYTE_PER_FRACTAL
from tbe.tik.tik_lib.tik_params import UINT_MIN
from tbe.tik.tik_lib.tik_params import UINT8_MAX
from tbe.tik.tik_lib.tik_params import UINT16_MAX
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import COL2IMG_REG_XM_OFFSET_LIST
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import COL2IMG_REG_XM_SEGMENT_LIST
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import COL2IMG_REG_XT_OFFSET_LIST
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import COL2IMG_REG_XT_SEGMENT_LIST
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import get_sk_tp
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import load2d_3d_align_fn
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_mmad_param_type_range
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_load3dv2_channel_size
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_load3dv2_k_extension
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_load3dv2_m_extension
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_dilation_filter_size
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import is_610_610b_310p_aic

_ADDR_MODE_BIT_INCREASE = 1
_ADDR_MODE_BIT_DECREASE = 0


class Load2DApi(TikIRBuilder):
    """
    load2d api class
    """

    def __init__(self, tik_instance, load2d_api):
        super(Load2DApi, self).__init__()
        self.api_name = load2d_api.name
        self.tik_instance = tik_instance
        self.dst = load2d_api.dst
        self.src = load2d_api.src
        self.start_index = load2d_api.start_index
        self.repeat_times = load2d_api.repeat_times
        self.dst_gap = load2d_api.dst_gap
        self.src_stride = load2d_api.src_stride
        self.sid = load2d_api.sid
        self.en_transpose = load2d_api.en_transpose
        self.addr_mode = load2d_api.addr_mode
        self.addr_mode_bit = None

    def check_params_all(self, src_scope, dst_scope):
        """
        check input params
        :param src_scope: src scope
        :param dst_scope: dst scope
        :return: no return
        """
        TikCheckUtil.check_equality(api_check_support("tik." + self.api_name, self.src.dtype), True,
                                    gen_api_check_statement(self.src.dtype, self.api_name))
        TikCheckUtil.check_var_in_list(
            (src_scope, dst_scope), LOAD2D_DMA_LIST,
            "load2d not support from %s to %s" % (src_scope, dst_scope))
        src_align, dst_align = load2d_3d_align_fn(self.dst, self.src)
        check_address_align((self.src,), ("src",), src_align)
        check_address_align((self.dst,), ("dst",), dst_align)

        # check dtype
        TikCheckUtil.check_equality(self.dst.dtype, self.src.dtype,
                                    "Intrinsic {}'s src's dtype should be equal to dst's dtype".format("load2d"))
        TikCheckUtil.check_equality(api_check_support("tik." + self.api_name, self.dst.dtype), True,
                                    gen_api_check_statement(self.dst.dtype, self.api_name))
        # check addr_mode
        # not support online config yet
        TikCheckUtil.check_var_in_list(
            self.addr_mode, ['inc', INC_MODE, 'dec', DEC_MODE, None],
            "addr_mode should be 'inc', 'dec', 0, 1 or None")

        if self.addr_mode in ("dec", DEC_MODE):
            TikCheckUtil.check_equality(
                (get_soc_name() in (ASCEND_910, HI3796CV300ES, ASCEND_910B) or is_610_610b_310p_aic()),
                True, "current soc not support addr_dec_mode")
            # 1 increase
            self.addr_mode_bit = _ADDR_MODE_BIT_INCREASE
        else:
            # 0 decrease
            self.addr_mode_bit = _ADDR_MODE_BIT_DECREASE
        # check en_transpose
        # not support online config yet
        TikCheckUtil.check_type_match(self.en_transpose, bool, "en_transpose should be bool")

    @source_info_decorator(depth=2)
    @load2dv1_decorator
    def run_all(self):
        """
        load2d api run_all
        :return: no return
        """
        # check scope
        src_scope = SCOPE_MAP.get(self.src.scope)
        dst_scope = SCOPE_MAP.get(self.dst.scope)
        self.check_params_all(src_scope, dst_scope)
        if self.en_transpose:
            TikCheckUtil.check_var_in_list(src_scope, ['cbuf', ], "src_scope should be cbuf if enabling transpose")
            TikCheckUtil.check_var_in_list(
                dst_scope, ['ca', 'cb'], "dst_scope should be ca or cb if enabling transpose")
        self.en_transpose = int(self.en_transpose)

        # check repeat_times
        check_repeat_times(self.repeat_times)
        # gen start_index
        check_mmad_param_type_range('start_index', self.start_index, end=MAX_START_INDEX)

        args = [self.start_index, self.repeat_times, self.src_stride, self.sid]
        # check dst_gap
        if self.dst_gap is not None:
            TikCheckUtil.check_equality((is_610_610b_310p_aic() or TikSocManager.is_hisi_soc()) or
                                        TikSocManager.is_910b_soc() or TikSocManager.is_310b_610l_soc(), True,
                                        "current soc not support dst_gap")
            check_mmad_param_type_range('dst_gap', self.dst_gap, end=MAX_DST_GAP_DOUBLE_BYTE)
            args = [self.start_index, self.repeat_times, self.src_stride, self.dst_gap, self.sid]

        if TikSocManager.is_310b_610l_soc() and src_scope == 'cbuf':
            # is 310b soc, load_cbuf_to_ca & load_cbuf_to_cb, remove sid param
            args.pop(-1)

        # check src_stride
        check_mmad_param_type_range('src_stride', self.src_stride, end=MAX_BLK_STRIDE_DOUBLE_BYTE)
        # check sid
        TikCheckUtil.check_in_range_by_dtype(
            self.sid, msg="sid should be in the range of [%s, %s]" % (0, MAX_SID), var_range=[0, MAX_SID])
        # gen
        if src_scope in ('cbuf',):
            args.append(self.en_transpose)
        if not TikSocManager.is_mini_soc():
            args.append(self.addr_mode_bit)
        dtype_str = self._get_load2d_dtype_str()
        # calculate extent
        src_extent, dst_extent = self._calculate_extent_load2d()
        pipe_line, intrin_name = LOAD2D_DMA_LIST[(src_scope, dst_scope)]
        if TikSocManager.is_610l_soc():
            self._check_610l_params(src_scope, dst_scope)
            dst_frac_stride, src_frac_stride = 0, 0
            args = [self.start_index, self.repeat_times, self.src_stride, self.dst_gap,
                    self.addr_mode_bit, dst_frac_stride, src_frac_stride]
            intrin_name = "load_cbuf_to_cb_transpose"
        if TikSocManager.is_310b_soc() and self.dst.dtype in ("uint8", "int8") and self.en_transpose:
            # 310b only support transpose true and l1 to l0a/l0b
            dst_frac_stride = 0
            args = [self.start_index, self.repeat_times, self.src_stride, self.dst_gap,
                    self.addr_mode_bit, dst_frac_stride]
            intrin_name = f"load_cbuf_to_{dst_scope}_transpose"

        with self.tik_instance.new_scope():
            instr = tvm.call_extern(self.dst.dtype, intrin_name,
                                    self.dst.reinterpret_cast_to(dtype_str).access_ptr("w", extent=dst_extent),
                                    self.src.reinterpret_cast_to(dtype_str).access_ptr("r", extent=src_extent),
                                    *(type_convert(args)))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", pipe_line)
            # one ir is call_extent
            self.tik_instance.emit(instr)

    def _check_610l_params(self, src_scope, dst_scope):
        """
        610l only support transpose true and l1 to l0b
        Parameters
        ----------
        src_scope: src scope
        dst_scope: dst scope

        Returns
        -------

        """
        msg = "%s AiCore %s only support transpose true." % (get_soc_name(), self.api_name)
        TikCheckUtil.check_equality(self.en_transpose, True, msg)
        msg = "%s AiCore %s not support %s to %s" % (get_soc_name(), self.api_name, src_scope, dst_scope)
        TikCheckUtil.check_equality(src_scope == "cbuf" and dst_scope == "cb", True, msg)

    def _get_load2d_dtype_str(self):
        """
        get dtype str for load2d instruciton
        """
        dtype_str = DTYPE_MAP[self.dst.dtype] + DTYPE_MAP[self.src.dtype]
        if dtype_str in ("s4s4", "u4u4"):
            dtype_str = "int4"
        elif dtype_str in ("s16s16", "u16u16"):
            dtype_str = "float16"
        else:
            dtype_str = self.dst.dtype
        return dtype_str

    def _calculate_extent_load2d(self):
        """
        calculate src_extent and dst_extent of instruction load2dv1 and load2dv2

        Returns
        -------
        src_extent
        dst_extent
        """
        data_len = Expr((self.repeat_times - 1) * self.src_stride + 1)
        src_extent = Expr((self.start_index + data_len) * BYTE_PER_FRACTAL).get()
        # repeat_times*512
        if self.dst_gap is None:
            self.dst_gap = 0
        dst_extent = self.repeat_times * BYTE_PER_FRACTAL + (self.repeat_times - 1) * self.dst_gap * BYTE_PER_FRACTAL
        dst_extent_val = Expr(dst_extent).get()
        return src_extent, dst_extent_val


class Load2DV3Api(TikIRBuilder):
    def __init__(self, tik_instance, load2dv3):
        super(Load2DV3Api, self).__init__()
        self.tik_instance = tik_instance
        self.name = load2dv3.name
        self.dst = load2dv3.dst
        self.src = load2dv3.src
        self.m_start_pt = load2dv3.m_start_pt
        self.k_start_pt = load2dv3.k_start_pt
        self.dst_stride = load2dv3.dst_stride
        self.src_stride = load2dv3.src_stride
        self.m_step = load2dv3.m_step
        self.k_step = load2dv3.k_step
        self.en_transpose = load2dv3.en_transpose

    def check_params_all(self, src_scope, dst_scope):
        """
        check params
        Parameters
        ----------
        src_scope: src scope
        dst_scope: dst scope

        Returns
        -------

        """
        TikCheckUtil.check_var_in_list(
            (src_scope, dst_scope), LOAD2D_DMA_LIST,
            "load2d not support from %s to %s" % (src_scope, dst_scope))
        # The unit is byte.
        src_align, dst_align = load2d_3d_align_fn(self.dst, self.src)
        check_address_align((self.src,), (self.src.name,), src_align)
        check_address_align((self.dst,), (self.dst.name,), dst_align)
        # check dtype
        TikCheckUtil.check_equality(self.dst.dtype, self.src.dtype,
                                    "Intrinsic {}'s src's dtype should be equal to dst's dtype".format(self.name))
        msg = "Ascend610Lite AiCore %s does not support %s %s to %s." % (
            self.name, self.src.dtype, src_scope, dst_scope)
        TikCheckUtil.check_equality(api_check_support("tik.%s" % self.name, self.dst.dtype), True, msg)
        # check m_start_pt
        TikCheckUtil.check_type_match(self.m_start_pt, (int, Expr, Scalar),
                                      "m_start_pt should be int/Expr/Scalar, but input type: {}".format(
                                          type(self.m_start_pt)))
        check_scalar_dtype(self.m_start_pt, "scalar m_start_pt should be a scalar of int/uint")
        TikCheckUtil.check_in_range_by_dtype(
            self.m_start_pt, var_range=[UINT_MIN, UINT16_MAX],
            msg=f"m_start_pt should be in range of [{UINT_MIN}, {UINT16_MAX}], input: {self.m_start_pt}"
        )
        # check k_start_pt
        TikCheckUtil.check_type_match(self.k_start_pt, (int, Expr, Scalar),
                                      "k_start_pt should be int/Expr/Scalar, but input type: {}".format(
                                          type(self.k_start_pt)))
        check_scalar_dtype(self.k_start_pt, "scalar k_start_pt should be a scalar of int/uint")
        TikCheckUtil.check_in_range_by_dtype(
            self.k_start_pt, var_range=[UINT_MIN, UINT16_MAX],
            msg=f"k_start_pt should be in range of [{UINT_MIN}, {UINT16_MAX}], input: {self.k_start_pt}"
        )
        # check m_step
        TikCheckUtil.check_type_match(self.m_step, (int, Expr, Scalar),
                                      "m_step should be int/Expr/Scalar, but input type: {}".format(
                                          type(self.m_step)))
        check_scalar_dtype(self.m_step, "scalar m_step should be a scalar of int/uint")
        TikCheckUtil.check_in_range_by_dtype(
            self.m_step, var_range=[UINT_MIN, UINT8_MAX],
            msg=f"m_step should be in range of [{UINT_MIN}, {UINT8_MAX}], input: {self.m_step}"
        )
        # check k_step
        TikCheckUtil.check_type_match(self.k_step, (int, Expr, Scalar),
                                      "k_step should be int/Expr/Scalar, but input type: {}".format(
                                          type(self.k_step)))
        check_scalar_dtype(self.k_step, "scalar k_step should be a scalar of int/uint")
        TikCheckUtil.check_in_range_by_dtype(
            self.k_step, var_range=[UINT_MIN, UINT8_MAX],
            msg=f"k_step should be in range of [{UINT_MIN}, {UINT8_MAX}], input: {self.k_step}"
        )
        # check src_stride
        TikCheckUtil.check_type_match(self.src_stride, (int, Expr, Scalar),
                                      "src_stride should be int/Expr/Scalar, but input type: {}".format(
                                          type(self.src_stride)))
        check_scalar_dtype(self.src_stride, "scalar src_stride should be a scalar of int/uint")
        TikCheckUtil.check_in_range_by_dtype(
            self.src_stride, var_range=[UINT_MIN, UINT16_MAX],
            msg=f"src_stride should be in range of [{UINT_MIN}, {UINT16_MAX}], input: {self.src_stride}"
        )
        # check dst_stride
        TikCheckUtil.check_type_match(self.dst_stride, (int, Expr, Scalar),
                                      "dst_stride should be int/Expr/Scalar, but input type: {}".format(
                                          type(self.dst_stride)))
        check_scalar_dtype(self.dst_stride, "scalar dst_stride should be a scalar of int/uint")
        TikCheckUtil.check_in_range_by_dtype(
            self.dst_stride, var_range=[UINT_MIN, UINT16_MAX],
            msg=f"dst_stride should be in range of [{UINT_MIN}, {UINT16_MAX}], input: {self.dst_stride}"
        )
        # check en_transpose
        TikCheckUtil.check_var_in_list(self.en_transpose, (True, False, 1, 0), "en_transpose should be bool")

    def gen_code(self):
        """
        Generate Instruction Map
        Returns
        -------

        """
        src_scope = SCOPE_MAP.get(self.src.scope)
        dst_scope = SCOPE_MAP.get(self.dst.scope)
        scope_map = {
            "gm to cbuf": "load_gm_to_cbuf_2dv2",
            "gm to ca": "load_gm_to_ca_2dv2",
            "gm to cb": "load_gm_to_cb_2dv2",
            "cbuf to ca": "load_cbuf_to_ca",
            "cbuf to cb": "load_cbuf_to_cb"
        }
        # Byte uint
        src_matrix_size = 512
        dst_matrix_size = 32
        self.check_params_all(src_scope, dst_scope)
        intrin_name = scope_map.get("%s to %s" % (src_scope, dst_scope))
        args = [self.m_start_pt, self.k_start_pt, self.src_stride, self.dst_stride, self.m_step, self.k_step]
        pipe_line, _ = LOAD2D_DMA_LIST[(src_scope, dst_scope)]
        src_matrix_w = self.k_start_pt + self.k_step
        src_matrix_h = self.src_stride
        src_extent = src_matrix_w * src_matrix_h * src_matrix_size
        dst_matrix_w = self.k_step
        dst_matrix_h = self.dst_stride
        dst_extent = dst_matrix_w * dst_matrix_h * dst_matrix_size
        if not isinstance(dst_extent, int):
            dst_extent = dst_extent.get()
        if not isinstance(src_extent, int):
            src_extent = src_extent.get()
        if intrin_name in ("load_cbuf_to_ca", "load_cbuf_to_cb"):
            args = [self.m_start_pt, self.k_start_pt, self.m_step, self.k_step, self.src_stride, self.dst_stride,
                    int(self.en_transpose)]
        with self.tik_instance.new_scope():
            instr = tvm.call_extern(self.dst.dtype, intrin_name,
                                    self.dst.reinterpret_cast_to(self.dst.dtype).access_ptr("w", extent=dst_extent),
                                    self.src.reinterpret_cast_to(self.src.dtype).access_ptr("r", extent=src_extent),
                                    *(type_convert(args)))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", pipe_line)
            # one ir is call_extent
            self.tik_instance.emit(instr)

    @source_info_decorator(depth=2)
    @load2dv3_decorator
    def run_all(self):
        """
        load2dv3 api run_all
        Returns
        -------

        """
        self.gen_code()


class Load3DApi(TikIRBuilder):
    """
    load3d api class
    """

    def __init__(self, tik_instance, load3d_api):
        super(Load3DApi, self).__init__()
        self.tik_instance = tik_instance
        self.dst = load3d_api.dst
        self.src = load3d_api.src
        self.pad = load3d_api.pad
        self.l1_h = load3d_api.l1_h
        self.l1_w = load3d_api.l1_w
        self.stride_w = load3d_api.stride_w
        self.stride_h = load3d_api.stride_h
        self.filter_w = load3d_api.filter_w
        self.filter_h = load3d_api.filter_h
        self.dilation_filter_w = load3d_api.dilation_filter_w
        self.dilation_filter_h = load3d_api.dilation_filter_h

    def check_load3d_params_type_range(self):
        """
        check load3dv2's and col2img's params
        """
        # check pad
        TikCheckUtil.check_type_match(
            self.pad, (list, tuple),
            "pad_list should be list or tuple, please specify padding: [left, right, top, bottom].")
        TikCheckUtil.check_equality(len(self.pad), PAD_LENGTH,
                                    "pad length should be 4, input pad length: {}".format(len(self.pad)))
        check_mmad_param_type_range('pad[0]', self.pad[PADDING_LEFT_IDX], end=MAX_PADDING)
        check_mmad_param_type_range('pad[1]', self.pad[PADDING_RIGHT_IDX], end=MAX_PADDING)
        check_mmad_param_type_range('pad[2]', self.pad[PADDING_TOP_IDX], end=MAX_PADDING)
        check_mmad_param_type_range('pad[3]', self.pad[PADDING_BOT_IDX], end=MAX_PADDING)

        # check feature map
        check_mmad_param_type_range('l1_w', self.l1_w, start=MIN_TENSOR_WIDTH, end=MAX_TENSOR_WIDTH)
        check_mmad_param_type_range('l1_h', self.l1_h, start=MIN_TENSOR_WIDTH, end=MAX_TENSOR_WIDTH)

        # check stride
        check_mmad_param_type_range('stride_w', self.stride_w, start=MIN_STRIDE, end=MAX_STRIDE)
        check_mmad_param_type_range('stride_h', self.stride_h, start=MIN_STRIDE, end=MAX_STRIDE)

        # check filter
        check_mmad_param_type_range('filter_w', self.filter_w, start=MIN_FILTER_WIDTH, end=MAX_FILTER_WIDTH)
        check_mmad_param_type_range('filter_h', self.filter_h, start=MIN_FILTER_WIDTH, end=MAX_FILTER_WIDTH)

        # check dilation
        check_mmad_param_type_range('dilation_filter_w', self.dilation_filter_w, start=MIN_DILATION, end=MAX_DILATION)
        check_mmad_param_type_range('dilation_filter_h', self.dilation_filter_h, start=MIN_DILATION, end=MAX_DILATION)

    def do_load3d_fmatrix(self, reg_fmatrix):
        """
        set load3d fmatrix
        """
        if "fmatrix" in self.tik_instance.global_dict:
            fmatrix = self.tik_instance.global_dict["fmatrix"]
        else:
            fmatrix = self.tik_instance.global_scalar(dtype="int64")
            self.tik_instance.global_dict["fmatrix"] = fmatrix
        with self.tik_instance.context.freeze():
            with self.tik_instance.new_scope():
                t_fmatrix = self.tik_instance.scalar_(dtype="int64")
                t_fmatrix.set_as(reg_fmatrix)
                self.tik_instance.scope_attr(tvm.thread_axis("cce"), "if_protect", PIPE_MTE1)
                with self.tik_instance.if_scope_(fmatrix != t_fmatrix):
                    fmatrix.set_as(t_fmatrix)
                    # one ir is call_extern
                    self.tik_instance.emit(tvm.call_extern("int64", "set_fmatrix", fmatrix.get()))


class Load3DV1Api(Load3DApi):
    """
    load3dv1 api class
    """

    def __init__(self, tik_instance, load3dv1_api):
        Load3DApi.__init__(self, tik_instance, load3dv1_api)
        self.c1_index = load3dv1_api.c1_index
        self.fetch_filter_w = load3dv1_api.fetch_filter_w
        self.fetch_filter_h = load3dv1_api.fetch_filter_h
        self.left_top_w = load3dv1_api.left_top_w
        self.left_top_h = load3dv1_api.left_top_h
        self.jump_offset = load3dv1_api.jump_offset
        self.repeat_mode = load3dv1_api.repeat_mode
        self.repeat_time = load3dv1_api.repeat_time
        self.csize = load3dv1_api.csize
        self.pad_value = load3dv1_api.pad_value

    def calculate_extent_load3dv1(self):
        """
        Calculate dst load3dv's extent by different type

        Returns
        -------
        dst extent
        """
        # cal dst_extent, not support repeat_mode SCALAR
        repeat_mode = Expr(self.repeat_mode).eval_value()
        if repeat_mode is not None:
            if repeat_mode == 0:
                dst_extent = Expr(self.repeat_time * BYTE_PER_FRACTAL).get()
            elif repeat_mode == 1:
                dst_extent = Expr((Expr(self.repeat_time) - 1) * Expr(self.jump_offset) *
                                  BYTE_PER_FRACTAL + BYTE_PER_FRACTAL).get()
            else:
                dst_extent = Expr(reduce_mul(self.dst.original_shape) * DTYPE_SIZE.get(self.dst.dtype)).get()
        else:
            dst_extent = (reduce_mul(self.dst.original_shape) - self.dst.offset) * DTYPE_SIZE.get(self.dst.dtype)
            dst_extent = Expr(dst_extent).get()
        return dst_extent

    @source_info_decorator(depth=2)
    @load3dv1_decorator
    def run_all(self):
        """
        load3dv1 api run_all
        :return: no return
        """
        scope_map = {'l0a': 'ca', 'l0b': 'cb', 'ub': 'ub'}
        # check type
        self._check_load3dv1_type()
        # check core_arch
        TikCheckUtil.check_not_contains(get_soc_name() + get_soc_core_type(),
                                        (VEC_610, VEC_310P), "current soc does't support load3dv1")

        dst_scope = self.dst.scope.split(".")[-1].lower()
        src_scope = self.src.scope.split(".")[-1].lower()

        # check tensor scope
        self._check_load3dv1_tensor_scope_dtyoe(src_scope, dst_scope)
        # check input params
        self._check_load3dv1_params_type_range()

        # FMATRIX
        params = [self.l1_w, self.l1_h, self.pad[PADDING_LEFT_IDX], self.pad[PADDING_RIGHT_IDX],
                  self.pad[PADDING_TOP_IDX], self.pad[PADDING_BOT_IDX]]
        reg_fmatrix = concat_params(params, FMATRIX_OFFSET_LIST, FMATRIX_SEGMENT_LIST)

        self.do_load3d_fmatrix(reg_fmatrix)
        # padding
        if self.pad_value is not None:
            do_load3d_padding(self.tik_instance, self.src, self.pad_value)
        # code gen
        params = [self.fetch_filter_w, self.fetch_filter_h, self.left_top_w, self.left_top_h, self.c1_index]
        reg_xm = type_convert(params)

        params = [self.stride_w, self.stride_h, self.filter_w, self.filter_h, self.dilation_filter_w,
                  self.dilation_filter_h, self.jump_offset, self.repeat_mode, self.repeat_time]
        reg_xt = type_convert(params)

        # cal extent
        dst_extent = self.calculate_extent_load3dv1()

        with self.tik_instance.new_scope():
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_MTE1)
            if get_bit_len(self.dst.dtype) == DST_TYPE_LEN:
                instr = tvm.call_extern(
                    self.dst.dtype, "img2col_cbuf_to_" + scope_map.get(dst_scope),
                    self.dst.reinterpret_cast_to("float16").access_ptr("w", extent=dst_extent),
                    self.src.reinterpret_cast_to("float16").access_ptr("r"), *reg_xm, *reg_xt, self.csize)
            else:
                instr = tvm.call_extern(
                    self.dst.dtype, "img2col_cbuf_to_" + scope_map.get(dst_scope),
                    self.dst.access_ptr("w", extent=dst_extent),
                    self.src.access_ptr("r"), *reg_xm, *reg_xt, self.csize)
            # one ir is call_extern
            self.tik_instance.emit(instr)

    def _check_load3dv1_type(self):
        """
        check load3d's params dtype
        """
        TikCheckUtil.check_type_match(
            self.c1_index, (int, Scalar, Expr), "c1_index should be int, Scalar or Expr")
        # check jumpOffset
        TikCheckUtil.check_type_match(
            self.jump_offset, (int, Scalar, Expr), "jump_offset should be int, Scalar or Expr")
        # check repeatMode
        TikCheckUtil.check_type_match(
            self.repeat_mode, (int, Scalar, Expr), "repeat_mode should be int, Scalar or Expr")
        # check pad_value
        TikCheckUtil.check_type_match(
            self.pad_value, (int, float),
            "pad_value should be python int or float, input type is: {}".format(type(self.pad_value)))
        # check _csize
        TikCheckUtil.check_type_match(
            self.csize, (int, Expr),
            "_csize should be int or Expr, input type of _csize: {}".format(self.csize))

    def _check_load3dv1_params_type_range(self):
        # check fetch pos in filter
        check_mmad_param_type_range('fetch_filter_w', self.fetch_filter_w, end=MAX_FETCH_POS)
        check_mmad_param_type_range('fetch_filter_h', self.fetch_filter_h, end=MAX_FETCH_POS)

        # check start-point
        check_mmad_param_type_range('left_top_h', self.left_top_h, start=MIN_START_POINT, end=MAX_START_POINT)
        check_mmad_param_type_range('left_top_w', self.left_top_w, start=MIN_START_POINT, end=MAX_START_POINT)

        self.check_load3d_params_type_range()

        # check c1_index
        check_mmad_param_type_range('c1_index', self.c1_index, end=MAX_C1_INDEX)

        # check jump_offset
        check_mmad_param_type_range('jump_offset', self.jump_offset, start=MIN_JUMP_OFFSET, end=MAX_JUMP_OFFSET)

        # check repeat_time
        check_repeat_times(self.repeat_time)

        # check repeat_mode
        check_mmad_param_type_range('repeat_mode', self.repeat_mode, end=MAX_REPEAT_MODE)

        # check _csize
        check_mmad_param_type_range('_csize', self.csize, end=MAX_C_SIZE, is_debug=True)

    def _check_load3dv1_tensor_scope_dtyoe(self, src_scope, dst_scope):
        """
        check tensor scope and dtype
        """
        dst_src_dtype_list = ["u8u8", "s8s8", "f16f16"]

        TikCheckUtil.check_var_in_list(dst_scope, ['l0a', 'l0b', 'ub'],
                                       "dst_scope %s is not supported for load3dv1." % self.dst.scope)
        TikCheckUtil.check_equality(src_scope, 'l1',
                                    "src_scope %s is not supported for load3dv1." % self.src.scope)
        src_align, dst_align = load2d_3d_align_fn(self.dst, self.src)
        check_address_align((self.src,), ("src",), src_align)
        check_address_align((self.dst,), ("dst",), dst_align)

        # check tensor dtype
        dtype_str = DTYPE_MAP[self.dst.dtype] + DTYPE_MAP[self.src.dtype]
        TikCheckUtil.check_var_in_list(
            dtype_str, dst_src_dtype_list, "dtype of dst should be u8u8, s8s8, or f16f16.")


class Load3DV2Api(Load3DApi):
    """
    load3dv1 api class
    """

    def __init__(self, tik_instance, load3dv2_api):
        Load3DApi.__init__(self, tik_instance, load3dv2_api)
        self.channel_size = load3dv2_api.channel_size
        self.k_extension = load3dv2_api.k_extension
        self.m_extension = load3dv2_api.m_extension
        self.k_start_pt = load3dv2_api.k_start_pt
        self.m_start_pt = load3dv2_api.m_start_pt
        self.en_transpose = load3dv2_api.en_transpose
        self.en_small_k = load3dv2_api.en_small_k
        self.pad_value = load3dv2_api.pad_value
        self.instr_name = "load3dv2"

    @source_info_decorator(depth=2)
    @load3dv2_decorator
    def run_all(self):
        """
        load3dv1 api run_all
        :return: no return
        """
        TikCheckUtil.check_equality(TikSocManager.is_v100_soc(), False, "load3dv2 not support v100 version.")
        scope_map = {scope_ca: 'ca', scope_cb: 'cb', scope_ubuf: 'ub', scope_cbuf: 'cbuf'}
        dtype_str = DTYPE_MAP[self.dst.dtype] + DTYPE_MAP[self.src.dtype]

        # check tensor scope and dtype
        self._check_load3dv2_tensor_scope_dtyoe(scope_map)

        # check params
        self._check_load3dv2_params_type_range()

        # check channel_size
        check_load3dv2_channel_size(self.channel_size, self.src.dtype)

        # check dilation filter size and l1_h_w size
        check_dilation_filter_size([self.filter_w, self.dilation_filter_w, self.l1_w,
                                    self.pad[PADDING_LEFT_IDX], self.pad[PADDING_RIGHT_IDX]], "W")
        check_dilation_filter_size([self.filter_h, self.dilation_filter_h, self.l1_h,
                                    self.pad[PADDING_TOP_IDX], self.pad[PADDING_BOT_IDX]], "H")

        # check m_extension and k_extension
        # if not the rightmost fractal matrix, k_extension should be multiple of 16 for fp16, 32 for s8
        # if not the lowermost fractal matrix, m_extension should be multiple of 16 for fp16/s8
        check_load3dv2_m_extension(
            [self.filter_w, self.filter_h, self.dilation_filter_w, self.dilation_filter_h],
            [self.pad, self.m_extension, self.l1_w, self.l1_h, self.stride_w, self.stride_h, self.m_start_pt])
        check_load3dv2_k_extension([self.channel_size, self.k_extension,
                                    self.filter_h, self.filter_w, self.k_start_pt], self.src.dtype)

        # check dst tensor overflow
        self._check_dst_overflow_load3dv2()
        # check en_small_k en_and transpose
        sk_tp_bit = get_sk_tp(self)
        # FMATRIX
        orig_params = []
        params = [self.l1_w, self.l1_h, *self.pad]
        orig_params += params[:]
        reg_fmatrix = concat_params(params, FMATRIX_OFFSET_LIST, FMATRIX_SEGMENT_LIST)
        self.do_load3d_fmatrix(reg_fmatrix)
        # padding
        if self.pad_value is not None:
            do_load3d_padding(self.tik_instance, self.src, self.pad_value)
        # cal extent
        dst_extent = Expr(self.m_extension * self.k_extension * DTYPE_SIZE.get(self.dst.dtype)).get()
        # code gen
        params = [self.k_extension, self.m_extension, self.k_start_pt, self.m_start_pt]
        reg_xm = type_convert(params)
        orig_params += params[:]

        if TikSocManager.is_910b_soc() or TikSocManager.is_310b_610l_soc():
            params = [self.stride_w, self.stride_h, self.filter_w, self.filter_h,
                      self.dilation_filter_w, self.dilation_filter_h, 0, 0, 0, sk_tp_bit, self.channel_size]
        else:
            params = [self.stride_w, self.stride_h, self.filter_w, self.filter_h,
                      self.dilation_filter_w, self.dilation_filter_h, sk_tp_bit, self.channel_size]
        reg_xt = type_convert(params)
        orig_params += params[:]

        if dtype_str in ("s4s4", "u4u4"):
            dtype_str = "int4"
        else:
            dtype_str = self.dst.dtype
        self._set_l3d_rpt_for_610l()
        with self.tik_instance.new_scope():
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_MTE1)
            instr = tvm.call_extern(
                self.dst.dtype, "img2colv2_cbuf_to_" + scope_map.get(self.dst.scope),
                self.dst.reinterpret_cast_to(dtype_str).access_ptr("w", extent=dst_extent),
                self.src.reinterpret_cast_to(dtype_str).access_ptr("r"), *reg_xm,
                *reg_xt)
            self.tik_instance.emit(instr)

    def _set_l3d_rpt_for_610l(self):
        """
        set l3d rpt in 610l soc, set dst stride
        """
        if TikSocManager.is_610l_soc():
            l3d_rpt = 0  # Is the repeat stride.
            l3d_rpt |= 1 << 16  # Is the repeat times in the M or K direction.
            l3d_rpt |= 0 << 24  # repeat in the M direction.
            # Is the dst stride of the output matrix in K in unit of fractals.
            l3d_rpt |= ceil_div(self.m_extension, 16) << 32
            l3d_rpt |= 0 << 48  # Is the destination start position of the output matrix in the M direction.
            instr = tvm.call_extern('uint64', "set_l3d_rpt", type_convert(l3d_rpt))
            self.tik_instance.emit(instr)

    def _check_load3dv2_tensor_scope_dtyoe(self, scope_map):
        # check dst type
        TikCheckUtil.check_type_match(self.dst, Tensor,
                                      "dst should be tensor, input type of dst: {}".format(type(self.dst)))
        # check src type
        TikCheckUtil.check_type_match(self.src, Tensor,
                                      "src should be tensor, input type of src: {}".format(type(self.src)))
        # check tensor scope
        TikCheckUtil.check_var_in_list(
            scope_map[self.dst.scope], ['ca', 'cb', 'ub'],
            "dst_scope should be l0a, l0b or ub for load3dv2, input dst_scope: {}".format(self.dst.scope))
        TikCheckUtil.check_equality(
            scope_map[self.src.scope], 'cbuf',
            "src_scope should be l1 for load3dv2, input src_scope: {}".format(self.src.scope))
        src_align, dst_align = load2d_3d_align_fn(self.dst, self.src)
        check_address_align((self.src,), ("src",), src_align)
        check_address_align((self.dst,), ("dst",), dst_align)
        # check tensor dtype
        TikCheckUtil.check_equality(
            self.dst.dtype, self.src.dtype,
            "Intrinsic {}'s src's dtype should be equal to dst's dtype".format("load3dv2"))
        if TikSocManager.is_610l_soc():
            src_scope = TikUtil.get_storage_scope(self.src.scope)
            dst_scope = TikUtil.get_storage_scope(self.dst.scope)
            TikCheckUtil.check_equality(api_check_support("tik.load3dv2%s2%s" % (src_scope, dst_scope),
                                                          self.dst.dtype), True,
                                        gen_api_check_statement(self.dst.dtype, "load3dv2"))
        else:
            TikCheckUtil.check_equality(api_check_support("tik." + "load3dv2", self.dst.dtype), True,
                                        gen_api_check_statement(self.dst.dtype, "load3dv2"))

    def _check_load3dv2_params_type_range(self):
        self.check_load3d_params_type_range()
        check_mmad_param_type_range('k_extension', self.k_extension, start=MIN_EXTENSION, end=MAX_EXTENSION)
        check_mmad_param_type_range('m_extension', self.m_extension, start=MIN_EXTENSION, end=MAX_EXTENSION)

        check_mmad_param_type_range('k_start_pt', self.k_start_pt, end=MAX_START_PT)
        if isinstance(self.k_start_pt, int):
            k_start_pt_byte_align = 32
            if self.k_start_pt * DTYPE_SIZE[self.src.dtype] % k_start_pt_byte_align != 0:
                TikCheckUtil.raise_error(
                    "k_start_pt in Byte should be multiple of 32B, input "
                    "k_start_pt: {}, input src dtype: {}".format(self.k_start_pt, self.src.dtype))

        check_mmad_param_type_range('m_start_pt', self.m_start_pt, end=MAX_START_PT)
        if isinstance(self.m_start_pt, int):
            m_start_pt_ele_align = 16
            if self.m_start_pt % m_start_pt_ele_align != 0:
                TikCheckUtil.raise_error(
                    "m_start_ptshould be multiple of 16, input m_start_pt: {}".format(self.m_start_pt))

        # check pad_value
        if self.pad_value is not None:
            TikCheckUtil.check_type_match(
                self.pad_value, (int, float),
                "pad_value should be python int or float, input type of pad_value: {}".format(type(self.pad_value)))
        else:
            self.pad_value = 0

    def _check_dst_overflow_load3dv2(self):
        """
        calculate src_extent and dst_extent of instruction load2dv1 and load2dv2
        """
        if all(Expr(value).eval_value() is not None
               for value in [self.k_start_pt, self.m_start_pt, self.k_extension, self.m_extension, self.dst.offset]):
            dst_size = DTYPE_SIZE.get(self.dst.dtype)
            src_size = DTYPE_SIZE.get(self.dst.dtype)
            k_ext = ceil_div(self.k_extension * dst_size, ONE_BLK_SIZE) * ONE_BLK_SIZE // src_size
            m_ext = ceil_div(self.m_extension, ELE_PER_FRACTAL_EDGE) * ELE_PER_FRACTAL_EDGE
            dst_expected_ele = Expr(k_ext * m_ext + self.dst.offset).eval_value()
            dst_actual_ele = reduce_mul(self.dst.original_shape)
            TikCheckUtil.check_ge(
                dst_actual_ele, dst_expected_ele,
                "dst tensor overflow, expected dst shape: {},"
                " actual dst shape: {}".format(dst_expected_ele, dst_actual_ele))


class Col2ImgApi(Load3DApi):
    """
    col2img api class
    """

    def __init__(self, tik_instance, col2img_api):
        Load3DApi.__init__(self, tik_instance, col2img_api)
        self.fetch_filter_w = col2img_api.fetch_filter_w
        self.fetch_filter_h = col2img_api.fetch_filter_h
        self.left_top_w = col2img_api.left_top_w
        self.left_top_h = col2img_api.left_top_h
        self.repeat_time = col2img_api.repeat_time

    def check_tensor_scope_type(self):
        """
        check dst src scope and type
        """
        # check tensor scope
        dst_scope = self.dst.scope.split(".")[-1].lower()
        src_scope = self.src.scope.split(".")[-1].lower()
        TikCheckUtil.check_equality(dst_scope, "ub", "dst scope should be ub.")
        TikCheckUtil.check_equality(src_scope, "ub", "src scope should be ub.")
        # check operator address 32B aligned
        check_address_align((self.src, self.dst), ("src", "dst"))
        # check tensor dtype
        TikCheckUtil.check_equality(
            self.dst.dtype, self.src.dtype,
            "Intrinsic {}'s src's dtype should be equal to dst's dtype".format("col2img"))
        TikCheckUtil.check_equality(api_check_support("tik." + "col2img", self.dst.dtype), True,
                                    gen_api_check_statement(self.dst.dtype, "col2img"))

    @source_info_decorator(depth=2)
    @col2img_decorator
    def run_all(self):
        """
        col2img api run_all
        """
        self.check_tensor_scope_type()

        # check params
        self._check_col2img_params_type_range()

        # check repeatMode
        repeat_mode = 1

        # gen
        params = [self.l1_w, self.l1_h, *self.pad]
        reg_fcol2_img = concat_params(params, REG_FCOL2IMG_OFFSET_LIST, REG_FCOL2IMG_SEGMENT_LIST)

        params = [self.fetch_filter_w, self.fetch_filter_h, self.left_top_w, self.left_top_h]
        reg_xm = concat_params(params, COL2IMG_REG_XM_OFFSET_LIST, COL2IMG_REG_XM_SEGMENT_LIST)

        params = [self.stride_w, self.stride_h, self.filter_w, self.filter_h,
                  self.dilation_filter_w, self.dilation_filter_h, repeat_mode, self.repeat_time]
        reg_xt = concat_params(params, COL2IMG_REG_XT_OFFSET_LIST, COL2IMG_REG_XT_SEGMENT_LIST)

        with self.tik_instance.context.freeze():
            if "fcol2img" in self.tik_instance.global_dict:
                fcol2img = self.tik_instance.global_dict["fcol2img"]
            else:
                fcol2img = self.tik_instance.global_scalar(dtype="int64")
                self.tik_instance.global_dict["fcol2img"] = fcol2img
            TikCheckUtil.check_type_match(fcol2img, Scalar, "fcol2img should be Scalar")
            with self.tik_instance.new_scope():
                temp_scalar = self.tik_instance.scalar_(dtype="int64")
                temp_scalar.set_as(reg_fcol2_img)
                self.tik_instance.scope_attr(tvm.thread_axis("cce"), "if_protect", PIPE_MTE1)
                with self.tik_instance.if_scope_(fcol2img != temp_scalar):
                    fcol2img.set_as(temp_scalar)
                    # one ir is call_extern
                    self.tik_instance.emit(tvm.call_extern("int64", "set_fcol2img", fcol2img.get()))
            with self.tik_instance.new_scope():
                self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
                instr = tvm.call_extern(self.dst.dtype, "col2img",
                                        self.dst.access_ptr("w"), self.src.access_ptr("r"), reg_xm, reg_xt)
                # one ir is call_extern
                self.tik_instance.emit(instr)

    def _check_col2img_params_type_range(self):
        # check fetch pos in filter
        check_mmad_param_type_range('fetch_filter_w', self.fetch_filter_w, end=MAX_FETCH_POS)
        check_mmad_param_type_range('fetch_filter_h', self.fetch_filter_h, end=MAX_FETCH_POS)

        # check start-point
        check_mmad_param_type_range('left_top_h', self.left_top_h, start=MIN_START_POINT, end=MAX_START_POINT)
        check_mmad_param_type_range('left_top_w', self.left_top_w, start=MIN_START_POINT, end=MAX_START_POINT)

        self.check_load3d_params_type_range()

        # check repeat_time
        check_repeat_times(self.repeat_time)
