#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_data_move_operation_.py
DESC:     tik data_move related operation api
CREATED:  2021-10-25 14:04:45
MODIFIED: 2021-10-27 14:04:45
"""
from collections import namedtuple
import numpy as np
from tbe import tvm

from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.tik.common.expr_bound_analyzer import analysis_args_check_overflow
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import TikUtil
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_soc_core_type
from tbe.tik.common.tik_get_soc_name import get_compatible_blk_size
from tbe.tik.debug.data_move_decorators import tensor_move_decorator
from tbe.tik.debug.data_move_decorators import vcopy_decorator
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_api_constants import SCOPE_MAP
from tbe.tik.tik_lib.tik_api_constants import CR_MODE_MAP
from tbe.tik.tik_lib.tik_api_util import set_ctrl_counter_mask
from tbe.tik.tik_lib.tik_api_util import reset_ctrl_value
from tbe.tik.tik_lib.tik_api_util import check_mask_mode
from tbe.tik.tik_lib.tik_util import set_tensor_addr_to_scalar
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_util import dtype_convert
from tbe.tik.tik_lib.tik_util import type_convert
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import ONE_BYTE_BIT_LEN
from tbe.tik.tik_lib.tik_params import PADMODE_NO_PADDING
from tbe.tik.tik_lib.tik_params import DEQSCALE_SHIFT_POS
from tbe.tik.tik_lib.tik_params import SCALE_SHIFT_POS
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_2
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_8
from tbe.tik.tik_lib.tik_params import SCALE_ADDR_BIT_POS
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import BLK_NUM_PER_REP
from tbe.tik.tik_lib.tik_mask_concat_ import mask_concat
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import calculate_extent
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import get_scope_str
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_check import DataMoveCheck
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_check import VCopyCheck
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import archversion_convrelu
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import tensor_mov_dma_list
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_operation_ import DataMovePadApi


class TensorMoveApi(TikIRBuilder):
    """
    TensorMov class
    """

    def __init__(self, tik_instance, tm_obj):
        super(TensorMoveApi, self).__init__()
        self.tik_instance = tik_instance
        self.dst = tm_obj.dst
        self.src = tm_obj.src
        self.block_mode = tm_obj.block_mode
        self.nburst = tm_obj.nburst
        self.burst = tm_obj.burst_len
        self.dst_stride = tm_obj.dst_stride
        self.src_stride = tm_obj.src_stride
        self.deqscale = tm_obj.deqscale
        self.sid_store_mode = tm_obj.sid_store_mode
        self.relu = tm_obj.relu
        self.pad_mode = tm_obj.pad_mode
        self.pad_value = tm_obj.pad_value
        self.onthefly_mode = tm_obj.onthefly_mode
        self.src_onthefly = tm_obj.src_onthefly
        self.src_onthefly_stride = tm_obj.src_onthefly_stride
        self.check = DataMoveCheck(self, 'tensor_mov')
        if self.block_mode == "":
            self.block_mode = "m"
        if self.pad_value is None:
            self.pad_value = 0
        self.for_var = set()

    def _compatible_v310_tensor_mov(self, src_key_str, dst_key_str):
        """
        v310 aic data move not support ub2out out2ub l12out, so call data_move_pad to be compatible.
        Parameters
        ----------
        src_key_str: src scope str
        dst_key_str: dst scope str

        Returns
        -------
        None
        """
        data_move_pad_api = namedtuple('DataMovePadApi', ['dst', 'src', 'nburst', 'burst', 'dst_gap', 'src_gap',
                                                          'right_padding', 'left_padding', 'padding_value'])

        right_padding, left_padding = 0, 0
        padding_value, block_size_num = None, 32
        dst_gap = self.dst_stride * block_size_num if dst_key_str == "OUT" else self.dst_stride
        src_gap = self.src_stride * block_size_num if src_key_str == "OUT" else self.src_stride
        # 610l data move pad not support b64, so dst src need to convert the type
        if self.dst.dtype in ("int64", "uint64"):
            self.dst = self.dst.reinterpret_cast_to("int32")
            self.src = self.src.reinterpret_cast_to("int32")
        dmp_api = data_move_pad_api(self.dst, self.src, self.nburst, self.burst * block_size_num,
                                    dst_gap, src_gap, right_padding, left_padding, padding_value)
        dmp_obj = DataMovePadApi(self.tik_instance, dmp_api)
        dmp_obj.name = "tensor_mov"
        dmp_obj.check.name = "tensor_mov"
        dmp_obj.run_all()

    @source_info_decorator(depth=2)
    @tensor_move_decorator
    def run_all(self):
        """
        tensor_mov run_all
        """
        self.check.check_all()
        src_key_str = TikUtil.get_storage_scope(self.src.scope)
        dst_key_str = TikUtil.get_storage_scope(self.dst.scope)
        key = src_key_str + " " + dst_key_str
        if TikSocManager.is_610l_soc() and key in ("UB OUT", "OUT UB", "L1 OUT"):
            self._compatible_v310_tensor_mov(src_key_str, dst_key_str)
            return
        if self.onthefly_mode != 0:
            en_onthefly = True
            self.check.check_onthefly_mode()
        else:
            en_onthefly = False

        dtype_str = DTYPE_MAP[self.src.dtype] + DTYPE_MAP[self.dst.dtype]
        deq_mode = self._make_deq_mode(dtype_str)
        # regen scope
        src_scope, dst_scope = self._regen_tensor_mov_scope()
        dtype_str, deq_mode = self._set_dtype_deq_mode(dtype_str, deq_mode, dst_scope, src_scope)
        self._set_pad_mode((src_scope, dst_scope))
        self.check.check_deqscale_sid()
        analysis_args_check_overflow(self)
        # set deqscale
        self._set_deqscale(deq_mode, en_onthefly)
        # xt gen
        # low 2 bits: sid_store_mode   high 2 bits: onthefly_mode
        sid_store_mode = self.sid_store_mode + (self.onthefly_mode << SHIFT_BIT_POS_2)
        dst_onthefly_stride = self._set_dst_onthefly_stride(en_onthefly)
        config = [sid_store_mode, self.nburst, self.burst, self.src_stride, dst_onthefly_stride]
        TikCheckUtil.check_var_in_list((src_scope, dst_scope), tensor_mov_dma_list,
                                       "tensor_move doesn't support %s to %s" % (src_scope, dst_scope))
        # config: sid_store_mode, nburst, burst, src_stride, dst_stride
        scope_str = get_scope_str(self.block_mode, self.src, self.dst)
        src_extent = calculate_extent(scope_str, self.src, [self.nburst, self.burst, self.src_stride], True)
        dst_extent = calculate_extent(scope_str, self.src, [self.nburst, self.burst, dst_onthefly_stride],
                                      False, en_onthefly)
        if (src_scope, dst_scope) == ("gm", "cbuf"):
            config.append(self.pad_mode)
        elif (src_scope, dst_scope) in [("ubuf", "cc_m"), ("ubuf", "cc_v"),
                                        ("ubuf", "cc_sc"), ("cc_m", "ubuf"),
                                        ("cc_v", "ubuf"), ("cc_sc", "ubuf"),
                                        ("cc_dp", "ubuf")]:
            config.append(CR_MODE_MAP[dtype_str])
        pipe_line, intrin_name = tensor_mov_dma_list[(src_scope, dst_scope)]
        with self.tik_instance.new_scope():
            if TikSocManager.is_310b_610l_soc() and \
                    self.src.scope == "local.UB" and self.dst.scope == "local.UB":
                self.tik_instance.add_source_id()
            if en_onthefly:
                self.tik_instance.scope_attr(
                    tvm.thread_axis("cce"), "critical_bank_conflict",
                    tvm.call_extern(self.dst.dtype, "tvm_tuple", self.dst.access_ptr("w"),
                                    self.deqscale.access_ptr("r"), self.src_onthefly.access_ptr("r")))
            if intrin_name == "copy_matrix_cc_to_ubuf" \
                    and DTYPE_MAP[self.dst.dtype] in ('s8', 'u8'):
                instr = tvm.call_extern("int8", intrin_name + "_s8",
                                        self.dst.reinterpret_cast_to("int8").access_ptr("w", extent=dst_extent),
                                        self.src.access_ptr("r", extent=src_extent), *type_convert(config))
            else:
                instr = tvm.call_extern(self.dst.dtype, intrin_name,
                                        self.dst.access_ptr("w", extent=dst_extent),
                                        self.src.access_ptr("r", extent=src_extent), *type_convert(config))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", pipe_line)
            # one ir is call_extern
            self.tik_instance.emit(instr)

    def cvt_float_to_uint(self, dtype):
        """
        convert float to uint
        """
        np_dt = getattr(np, dtype)
        d_t = np.dtype(dtype)
        bit_size = d_t.itemsize * ONE_BYTE_BIT_LEN
        target_np = getattr(np, 'uint' + str(bit_size))
        return np_dt(self.deqscale).view(target_np).item()

    def _make_deq_mode(self, dtype_str):
        """
        get deq_mode
        """
        # deq/vdeq/deq16/vdeq16
        if dtype_str in ("s32f16",):
            deq_mode = self._get_s32f16_deq_mode()
        # deq
        elif dtype_str in ("f16f16",):
            deq_mode = self._get_f16f16_deq_mode()
        # deq8/vdeq8
        elif dtype_str in ("s32s8", "s32u8"):
            deq_mode = self._get_s32s8u8_deq_mode()
        # deqs16/vdeqs16
        elif dtype_str in ("s32s16",):
            deq_mode = self._get_s32s16_deq_mode()
        else:
            deq_mode = ''
        return deq_mode

    def _get_s32f16_deq_mode(self):
        """
        get deq mode when dtype is s32f16
        Parameters
        ----------
        deqscale: deqscale

        Returns
        -------
        deq mode
        """
        if not isinstance(self.deqscale, (float, int)):
            if not (isinstance(self.deqscale, (Scalar, Tensor)) and
                    (self.deqscale.dtype in ('uint64', 'float16', 'float32'))):
                TikCheckUtil.raise_error("deqscale type error.")
        if isinstance(self.deqscale, float) or (isinstance(self.deqscale, Scalar) and
                                                (self.deqscale.dtype in ('float16',))):  # deq
            deq_mode = 'deq'
        elif isinstance(self.deqscale, Tensor) and (self.deqscale.dtype in ('float16',)):  # vdeq
            deq_mode = 'vdeq'
        elif isinstance(self.deqscale, int) or (isinstance(self.deqscale, Scalar)
                                                and (self.deqscale.dtype in ('uint64',))):  # deq16
            deq_mode = 'deq16'
        else:
            deq_mode = 'vdeq16'
        return deq_mode

    def _get_f16f16_deq_mode(self):
        """
        get deq mode when dtype is s32f16
        Parameters
        ----------
        deqscale: deqscale

        Returns
        -------
        deq mode
        """
        if self.deqscale is None:
            deq_mode = ''
        else:
            if not isinstance(self.deqscale, float):
                if not (isinstance(self.deqscale, Scalar) and (self.deqscale.dtype in ('float16',))):
                    TikCheckUtil.raise_error("deqscale type error.")
            deq_mode = 'deq'
        return deq_mode

    def _get_s32s8u8_deq_mode(self):
        """
        get deq mode when dtype is s32f16
        Parameters
        ----------
        deqscale: deqscale

        Returns
        -------
        deq mode
        """
        if not isinstance(self.deqscale, int):
            if not (isinstance(self.deqscale, (Scalar, Tensor)) and self.deqscale.dtype in 'uint64'):
                TikCheckUtil.raise_error("deqscale type error.")
        if isinstance(self.deqscale, (int, Scalar)):
            deq_mode = 'deq8'
        else:
            deq_mode = 'vdeq8'
        return deq_mode

    def _get_s32s16_deq_mode(self):
        """
        get deq mode when dtype is s32f16
        Parameters
        ----------
        deqscale: deqscale

        Returns
        -------
        deq mode
        """
        if not isinstance(self.deqscale, int):
            if not (isinstance(self.deqscale, (Scalar, Tensor)) and self.deqscale.dtype in 'uint64'):
                TikCheckUtil.raise_error("deqscale type error.")
        if isinstance(self.deqscale, (int, Scalar)):
            deq_mode = 'deqs16'
        else:
            deq_mode = 'vdeqs16'
        return deq_mode

    def _regen_tensor_mov_scope(self):
        """
        regenerate src_scope and dst_scope in tensor_mov

        Parameters
        ----------
        src: src operator
        dst: dst operator
        block_mode

        Returns
        -------
        src_scope
        dst_scope
        """
        src_scope = SCOPE_MAP[self.src.scope]
        dst_scope = SCOPE_MAP[self.dst.scope]
        if src_scope == "cc":
            src_scope = src_scope + "_" + self.block_mode
        if dst_scope == "cc":
            dst_scope = dst_scope + "_" + self.block_mode
        return src_scope, dst_scope

    def _set_call_extern(self, dtype, addr):
        with self.tik_instance.new_scope():
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(tvm.call_extern(dtype, "set_deqscale", addr))

    def _set_deqscale(self, deq_mode, en_onthefly):
        # subclass has the member but parent class call it, so disable E1101
        if deq_mode in ("deq",):
            if en_onthefly:
                with self.tik_instance.context.freeze():
                    scale_addr = self.tik_instance.scalar_("int64")
                    set_tensor_addr_to_scalar(self.tik_instance, scale_addr, self.src_onthefly)
                    scale_addr.set_as((scale_addr << DEQSCALE_SHIFT_POS) | self.deqscale)
                    self._set_call_extern('float16', scale_addr.get())
            else:
                self._set_call_extern('float16', dtype_convert(self.deqscale, "float16"))
        elif deq_mode in ("deq8", "deq16", "deqs16"):
            with self.tik_instance.context.freeze():
                scale_addr = self.tik_instance.scalar_("int64")
                if en_onthefly:
                    set_tensor_addr_to_scalar(self, scale_addr, self.src_onthefly)
                    scale_addr.set_as((scale_addr << DEQSCALE_SHIFT_POS) | self.deqscale)
                else:
                    scale_addr.set_as(self.deqscale)
                scale_addr.set_as(scale_addr | (int(self.relu) << SCALE_SHIFT_POS))
                self._set_call_extern('int64', scale_addr.get())
        else:
            self._set_deqscale_expansion(deq_mode, en_onthefly)

    def _set_deqscale_expansion(self, deq_mode, en_onthefly):
        """
        deq_mode in ("vdeq", "vdeq8", "vdeqs16") or else scope
        """
        if deq_mode in ("vdeq", "vdeq8", "vdeqs16"):
            with self.tik_instance.context.freeze():
                scale_addr = self.tik_instance.scalar_("int64")
                # lsb: 32B
                set_tensor_addr_to_scalar(self.tik_instance, scale_addr, self.deqscale)
                if deq_mode == "vdeq":
                    scale_addr.set_as(scale_addr | (int(self.relu) << SCALE_ADDR_BIT_POS))
                else:
                    scale_addr.set_as(scale_addr | (int(self.relu) << SCALE_SHIFT_POS))
                if en_onthefly:
                    onthefly_addr = self.tik_instance.scalar_("int64")
                    set_tensor_addr_to_scalar(self.tik_instance, onthefly_addr, self.src_onthefly)
                    scale_addr.set_as(scale_addr | (onthefly_addr << DEQSCALE_SHIFT_POS))
                self._set_call_extern('int64', scale_addr.get())
        else:
            if deq_mode == "vdeq16" and not en_onthefly:
                with self.tik_instance.context.freeze():
                    scale_addr = self.tik_instance.scalar_("int64")
                    set_tensor_addr_to_scalar(self, scale_addr, self.deqscale)
                    scale_addr.set_as(scale_addr | (int(self.relu) << SCALE_ADDR_BIT_POS))
                    self._set_call_extern('int64', scale_addr.get())
            if en_onthefly:
                with self.tik_instance.context.freeze():
                    scale_addr = self.tik_instance.Scalar("int64")
                    set_tensor_addr_to_scalar(self, scale_addr, self.src_onthefly)
                    scale_addr.set_as(scale_addr << DEQSCALE_SHIFT_POS)
                    self._set_call_extern('int64', scale_addr.get())

    def _set_pad_mode(self, tensor_scope):
        # check padMode
        self.check.check_pad_mode(tensor_scope)
        if self.pad_mode is None:
            self.pad_mode = PADMODE_NO_PADDING

    def _set_dst_onthefly_stride(self, en_onthefly):
        if en_onthefly:
            # low 8 bits: dst_stride  high 8 bits: src_onthefly_stride
            dst_onthefly_stride = self.dst_stride + self.src_onthefly_stride << SHIFT_BIT_POS_8
        else:
            dst_onthefly_stride = self.dst_stride

        return dst_onthefly_stride

    def _set_dtype_deq_mode(self, dtype_str, deq_mode, dst_scope, src_scope):
        arch_version_str = get_soc_name() + get_soc_core_type()
        # check dtype
        dtype_str = dtype_str + deq_mode
        if self.relu:
            dtype_str = dtype_str + "relu"
            # check convrelu
            TikCheckUtil.check_var_in_list(
                CR_MODE_MAP[dtype_str], archversion_convrelu[arch_version_str],
                "%s doesn't support this convrelu mode: %s." % (arch_version_str, CR_MODE_MAP[dtype_str]))

        # check drc and dst scope range
        self.check.check_scope_range(dtype_str, dst_scope, src_scope)

        if TikSocManager.is_hisi_sd_cs():
            _, intrin_name = tensor_mov_dma_list[(src_scope, dst_scope)]
            if intrin_name == "copy_matrix_cc_to_ubuf" and deq_mode == "deq":
                deq_mode = "deq16"
                dtype_str = dtype_str + "16"
                if not isinstance(self.deqscale, float):
                    TikCheckUtil.raise_error("the deq value must be float")
                self.deqscale = self.cvt_float_to_uint('float32')

        return dtype_str, deq_mode


class VCopyOpApi(TikIRBuilder):
    """
    Single Vector Ops
    """

    def __init__(self, tik_instance, vcopy_obj):
        super().__init__()
        self.tik_instance = tik_instance
        self.mask = vcopy_obj.mask
        self.dst = vcopy_obj.dst
        self.src = vcopy_obj.src
        self.repeat_times = vcopy_obj.repeat_times
        self.dst_blk_stride = vcopy_obj.dst_blk_stride
        self.src_blk_stride = vcopy_obj.src_blk_stride
        self.dst_rep_stride = vcopy_obj.dst_rep_stride
        self.src_rep_stride = vcopy_obj.src_rep_stride
        self.mask_mode = vcopy_obj.mask_mode
        self.name = 'vcopy'
        self.check = VCopyCheck(self)
        self.block_size = get_compatible_blk_size()

    def cal_dst_src_extent_vcopy(self, new_dst_blk_stride=None, is_src=False):
        """
        calculate tensor extent, based on mask and mask mode, only for vcopy

        Parameters
        ----------
        is_src: whether calculate the src extent.
        Returns
        -------
        extent
        """
        if is_src:
            dtype = self.src.dtype
            rep_stride = self.src_rep_stride
            blk_stride = self.src_blk_stride
        else:
            dtype = self.dst.dtype
            rep_stride = self.dst_rep_stride
            blk_stride = new_dst_blk_stride
        one_repeat_blocks = BLK_NUM_PER_REP
        if self.mask_mode == 'counter':
            # one repeat element nums is mask value
            one_repeat_ele_nums = self.mask * DTYPE_SIZE[dtype]
            one_repeat_blocks = ceil_div(one_repeat_ele_nums, self.block_size)

        extent = ((self.repeat_times - 1) * rep_stride +
                  (one_repeat_blocks - 1) * blk_stride + 1) * self.block_size
        return Expr(extent).get()

    @source_info_decorator(depth=2)
    @vcopy_decorator
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        if isinstance(self.dst_blk_stride, int) and self.dst_blk_stride == 0:
            self.check.dst_blk_stride = 1

        self.check.check_dst_src_tensor()

        # check strides
        self.check.check_vector_stride_repeat()
        check_mask_mode(self.mask_mode)

        config = [
            self.repeat_times, self.dst_blk_stride, self.src_blk_stride, self.dst_rep_stride, self.src_rep_stride
        ]

        mask_o = mask_concat(self.tik_instance, self.mask, mask_mode=self.mask_mode,
                             tensor_bit_len=get_bit_len(self.dst.dtype))

        # check tensor overflow, overlapping
        self.check.check_all()

        self.code_gen(config, mask_o)

    def code_gen(self, config, mask):
        """
        Generate code for the instruction.

        Parameters
        ----------
        config : The configuration of the instruction.
        mask : The mask of the instruction.
        """
        dtype_str = self.dst.dtype
        if dtype_str == "float16":
            dtype_str = "uint16"
        elif dtype_str == "float32":
            dtype_str = "uint32"

        if not TikSocManager.is_v300_610l_soc() and not TikSocManager.is_v210_vec_soc():
            orig_ctrl = 0
            if self.mask_mode == "counter":
                orig_ctrl = set_ctrl_counter_mask(self.tik_instance)
        else:
            config.append(self.mask_mode)

        with self.tik_instance.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.tik_instance.add_source_id()
            instr = tvm.call_extern(self.dst.dtype, self.name,
                                    self.dst.reinterpret_cast_to(dtype_str).access_ptr(
                                        "w", extent=self.cal_dst_src_extent_vcopy(False)),
                                    self.src.reinterpret_cast_to(dtype_str).access_ptr(
                                        "r", extent=self.cal_dst_src_extent_vcopy(True)),
                                    *type_convert(config))
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *mask))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(instr)

        if self.mask_mode == "counter" and not TikSocManager.is_v300_610l_soc() and not TikSocManager.is_v210_vec_soc():
            reset_ctrl_value(self.tik_instance, orig_ctrl)
