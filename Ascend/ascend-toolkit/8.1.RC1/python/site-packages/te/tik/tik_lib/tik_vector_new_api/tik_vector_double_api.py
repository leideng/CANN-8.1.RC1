#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_double_api.py
DESC:     v210 double source api
CREATED:  2021-11-26 8:38
MODIFIED: 2021-11-26 8:38
"""

from tbe.common.platform import scope_vreg
from tbe.common.platform import scope_wreg
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.tik_lib.tik_check_util import print_error_msg
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.api.tik_vector import Vector
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_new_api_base import TikVectorNewApiBase


class TikVectorDoubleApi(TikVectorNewApiBase):
    """
    tik v210 double api contain mask dst src0 src1 args and other args
    """

    @source_info_decorator()
    def vector_vshr(self, mask, dst, src0, src1, rs_mode=False, part_mode=None):
        """
        Do logic or arithmetic left shift for each active elements.
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation
        rs_mode: only for wpack,
        -        False: disable rounding and disable saturation
        -        True: enable rounding and saturation
        part_mode: None, "EVEN", "ODD", only for wpack
        -          part_mode = "EVEN": even part
        -          part_mode = "ODD": odd part

        Returns
        -------
        None
        """

        if isinstance(src0, Vector) and src0.scope == scope_wreg:
            api_name = "vector_vshr"
            if isinstance(src1, Vector):
                instr_name = "vectorized_wpack"
                vec_wpack_wpacks_ins = TikVectorDoubleApi.vec_wpack_wpacks(
                    instr_name, api_name, mask, dst, src0, src1, rs_mode, part_mode)

                self.check_params_obj.check_vector_one_dst_two_src_params("vectorized_vshr", vec_wpack_wpacks_ins)
                self._vector_wpack(vec_wpack_wpacks_ins)  # wpack
            else:
                instr_name = "vectorized_wpacks"
                vec_wpack_wpacks_ins = TikVectorDoubleApi.vec_wpack_wpacks(
                    instr_name, api_name, mask, dst, src0, src1, rs_mode, part_mode)

                self.check_params_obj.check_elewise_tensor_func_params(
                    "vectorized_vshrs", vec_wpack_wpacks_ins, api_name=api_name)
                self._vector_wpacks(vec_wpack_wpacks_ins)  # wpacks
        elif isinstance(src1, Vector):
            vec_wpack_wpacks_ins = TikVectorDoubleApi.vec_wpack_wpacks(
                "vectorized_vshr", None, mask, dst, src0, src1, None, None)
            self._vector_elewise_func(vec_wpack_wpacks_ins)  # vshr
        else:
            vec_op_params_ins = TikVectorDoubleApi.vec_op_params(
                "vectorized_vshrs", mask, dst, src0, src1, None, None)
            self._vector_elewise_scalar_func(vec_op_params_ins,
                                             mode="MODE_MERGING", api_name="vector_vshr")  # vshrs

    @source_info_decorator()
    def vector_vavg(self, mask, dst, src0, src1, rnd_mode=False):
        """
        do vector average element

        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation or scalar,expr,imm
        rnd_mode : the rounding control bit
        when rnd_mode = False: no rounding
        -    rnd_mode = True:rounding to nearest integer

        Returns
        -------
        None
        """
        if rnd_mode not in [True, False]:
            print_error_msg("Intrinsic vector_vavg's rnd_mode must be bool type")
        vec_op_params_ins = TikVectorDoubleApi.vec_op_params('vectorized_vavg', mask, dst, None, None, src0, src1)
        return self._vector_reg_binary_tenary_elewise_func(vec_op_params_ins, rnd_mode, mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vsub(self, mask, dst, src0, src1, acc_mode=None):
        """
        Do add by single element.

        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation
        acc_mode: accumulate mode, can be None, "SUBA"
        -         None: dst = src0 - src1
        -         "SUBA": dst = src0 - src1 + dst

        Returns
        -------
        None
        """
        instr_name = 'vectorized_vsub'
        if isinstance(dst, Vector) and dst.scope == scope_wreg and \
                acc_mode is not None and acc_mode != "SUBA":
            print_error_msg("Intrinsic vector_vsub's acc_mode can only be [None, \"SUBA\"]")
        vec_op_params_ins = TikVectorDoubleApi.vec_op_params(instr_name, mask, dst, None, None, src0, src1)
        return self._vector_elewise_func(vec_op_params_ins, acc_mode=acc_mode)

    @source_info_decorator()
    def vector_vadd(self, mask, dst, src0, src1, acc_mode=None):
        """
        Do add by single element.
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation
        acc_mode: accumulate mode, available value:None, "ADDA", "ADDSUB",
        -         None: dst = src0 + src1
        -         "ADDA": dst = src0 + src1 + dst
        -         "ADDSUB": dst = src0 + src1 - dst

        Returns
        -------
        None
        """
        instr_name = "vectorized_vadd"
        if isinstance(dst, Vector) and dst.dtype in ["float16", "float32"] and acc_mode is not None:
            print_error_msg("For instrinsic vector_vadd, when dst dtype is float16 or float32,"
                            " acc_mode can only be None")
        elif isinstance(dst, Vector) and dst.scope == scope_wreg and \
                acc_mode is not None and acc_mode not in ["ADDA", "ADDSUB"]:
            print_error_msg("For instrinsic vector_vadd, when dst dtype is int24 or int48,"
                            " acc_mode can only be [None, \"ADDA\", \"ADDSUB\"]")
        elif isinstance(dst, Vector) and dst.scope == scope_vreg and \
                acc_mode is not None and acc_mode != "ADDA":
            print_error_msg("For instrinsic vector_vadd, when dst dtype is int8, uint8,"
                            " int16, uint16, int32 or uint32, acc_mode can only be [None, \"ADDA\"]")
        vec_op_params_ins = TikVectorDoubleApi.vec_op_params(instr_name, mask, dst, None, None, src0, src1)
        return self._vector_elewise_func(vec_op_params_ins, acc_mode=acc_mode)

    @source_info_decorator()
    def vector_wmul_v2(self, dst, src0, src1, src2, acc_mode=None):

        instr_name = "vectorized_wmul_v2"
        if acc_mode == "MULA":
            instr_name = "vectorized_wmula_v2"
        vec_op_params_ins = TikVectorDoubleApi.wmul_v2(
            instr_name, dst, src0, src1, src2, acc_mode, "vector_wmul_v2")

        self.wmul_v2_dst_vector(vec_op_params_ins)

    @source_info_decorator()
    def vector_wmuls_v2(self, dst, src0, src1, acc_mode=None):
        instr_name = "vectorized_wmuls"
        if acc_mode == "MULAS":
            instr_name = "vectorized_wmulas"
        vec_op_params_ins = TikVectorDoubleApi.wmuls_v2(
            instr_name, dst, src0, src1, acc_mode, "vector_wmuls_v2")
        self.wmuls_v2_dst_vector(vec_op_params_ins)


    @source_info_decorator()
    def vector_vmul(self, mask, dst, src0, src1, acc_mode=None, part_mode=None):
        """
        Do add by single element.
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation
        acc_mode: accumulate mode, available value:None, "MULA",
        -         None: dst = src0*src1
        -         "MULA": dst = src0*src1 + dst
        part_mode: None, "EVEN", "ODD", only for wmul, wmula, wmuls, wmulas
        -          part_mode = "EVEN": even part
        -          part_mode = "ODD": odd part

        Returns
        -------
        None
        """

        if isinstance(dst, Vector) and dst.scope == scope_wreg:
            instr_name = "vectorized_wmul"
            api_name = "vector_vmul"
            vec_op_params_ins = TikVectorDoubleApi.vec_wmul_wmuls(
                instr_name, mask, dst, src0, src1, acc_mode, part_mode, api_name)
            self.vmul_dst_vector(vec_op_params_ins)
        elif isinstance(src1, Vector):
            if acc_mode is not None and acc_mode not in ["MULA"]:
                print_error_msg("Intrinsic vector_vmul's acc_mode can only be [None, \"MULA\"]")
            elif acc_mode is None:
                vec_op_params_ins = TikVectorDoubleApi.vec_op_params(
                    "vectorized_vmul", mask, dst, None, None, src0, src1)
                self._vector_elewise_func(vec_op_params_ins)
            elif acc_mode == "MULA":
                vec_op_params_ins = TikVectorDoubleApi.vec_op_params(
                    "vectorized_vmula", mask, dst, None, None, src0, src1)
                self._vector_elewise_func(vec_op_params_ins, api_name="vector_vmul")
        else:
            vec_op_params_ins = TikVectorDoubleApi.vec_op_params("vectorized_vmuls", mask, dst, src0, src1, None, None)
            self._vector_elewise_scalar_func(vec_op_params_ins,
                                             mode="MODE_MERGING", api_name="vector_vmul")

    @source_info_decorator()
    def vector_vabsdif(self, mask, dst, src0, src1, acc_mode=None):
        """
        Do difference -and-absolute by single element.
        Parameters
        ----------
        acc_mode
        mask: effective operation on element, only support one model: Continuous
        dst : vector destination operator
        src0 : vector source operation
        src1 : vector source operation

        When acc_mode is None, the value indicates vabsdif. The calculation formula is Vd = abs(Vn-Vm)
        When acc_mode is "ADDA", the value indicates vsad. The calculation formula is Vd = abs(Vn-Vm)+Vd
        Returns
        -------
        None
        """
        soc_name = get_soc_name()
        if acc_mode is None:
            if src0.dtype == "uint32" or src1.dtype == "uint32" or dst.dtype == "uint32":
                print_error_msg("current chip: %s VectorCore doesn't support src0 uint32 dst uint32 for "
                                "Instruction vector_vabsdif when acc_mode is 'ADDA'" % soc_name)
            vec_op_params_ins = TikVectorDoubleApi.vec_op_params(
                "vectorized_vabsdif", mask, dst, None, None, src0, src1)
            self._vector_elewise_func(vec_op_params_ins, acc_mode=acc_mode)
        elif acc_mode == "ADDA":
            if src0.dtype == "float16" or src1.dtype == "float16" or dst.dtype == "float16":
                print_error_msg("current chip: %s VectorCore doesn't support src0 float16 dst float16 for "
                                "Instruction vector_vabsdif when acc_mode is 'ADDA'" % soc_name)
            elif src0.dtype == "float32" or src1.dtype == "float32" or dst.dtype == "float32":
                print_error_msg("current chip: %s VectorCore doesn't support src0 float32 dst float32 for "
                                "Instruction vector_vabsdif when acc_mode is 'ADDA'" % soc_name)
            vec_op_params_ins = TikVectorDoubleApi.vec_op_params("vectorized_vsad", mask, dst, None, None, src0, src1)
            self._vector_elewise_func(vec_op_params_ins, acc_mode=acc_mode, api_name="vector_vabsdif")
        else:
            print_error_msg("Intrinsic vector_vabsdif's acc_mode can only be [None, \"ADDA\"]")
