#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_data_move_check.py
DESC:     tik_data_move_check
CREATED:  2021-11-10 5:12 AM
MODIFIED: 2021-11-10 5:12 AM
"""
from tbe import tvm
from tbe.common.platform import scope_ubuf
from tbe.common.platform import intrinsic_check_support

from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.api.tik_tensor_addr_list import TensorAddrList
from tbe.tik.common.common_util import dma_align_fn
from tbe.tik.common.common_util import vec_template_align
from tbe.tik.common.common_util import get_blk_valid_list
from tbe.tik.common.common_util import get_8or16bit_dtype_mask_len
from tbe.tik.common.common_util import check_param_type_range
from tbe.tik.common.common_util import check_address_align
from tbe.tik.common.common_util import tik_api_check_support
from tbe.tik.common.common_util import is_tensor_addr_list
from tbe.tik.common.common_check_func import check_overlap_param
from tbe.tik.common.common_check_func import get_32bit_dtype_mask_len
from tbe.tik.common.tik_get_soc_name import get_compatible_blk_size
from tbe.tik.common.tik_get_soc_name import get_compatible_rep_size
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_soc_core_type
from tbe.tik.common.tik_get_soc_name import is_compatible_mode
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import DTYPE_SHORT_NAME_MAP
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import TikUtil
from tbe.tik.common.util import reduce_mul
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_expr import is_basic_expr
from tbe.tik.tik_lib.tik_expr import BasicExpr
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_api_constants import ARCHVERSION_ONTHEFLY
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_api_constants import SCOPE_MAP
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_check_util import print_error_msg
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import get_scope_str
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import archversion_scope
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import archversion_nd2nz
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import archversion_convrelu
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import block_mode_appendix_map
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import src_dst_scope_dtype_map
from tbe.tik.tik_lib.tik_params import MIN_ONTHEFLY_MODE
from tbe.tik.tik_lib.tik_params import MAX_ONTHEFLY_MODE
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_TIMES
from tbe.tik.tik_lib.tik_params import MAX_REP_STRIDE_12_BITS
from tbe.tik.tik_lib.tik_params import BLK_NUM_PER_REP
from tbe.tik.tik_lib.tik_params import MASK_VALUE_ZERO
from tbe.tik.tik_lib.tik_params import BIT_LEN_8
from tbe.tik.tik_lib.tik_params import BIT_LEN_16
from tbe.tik.tik_lib.tik_params import BIT_LEN_32
from tbe.tik.tik_lib.tik_params import MAX_PADMODE
from tbe.tik.tik_lib.tik_params import MIN_NBURST
from tbe.tik.tik_lib.tik_params import MAX_NBURST_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_params import MIN_BURST_LEN
from tbe.tik.tik_lib.tik_params import MAX_BURST_LEN_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_SID
from tbe.tik.tik_lib.tik_params import DEFAULT_STRIDE
from tbe.tik.tik_lib.tik_params import MAX_BLK_STRIDE_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_BLK_STRIDE_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_params import PRINT_SCOPE_MAP

_MAX_SID_MOD = 2


def _check_param_type(params):
    for key, valul in params.items():
        if key == 'nburst':
            start = MIN_NBURST
            end = MAX_NBURST_DOUBLE_BYTE
        elif key == 'burst_len':
            start = MIN_BURST_LEN
            end = MAX_BURST_LEN_DOUBLE_BYTE
        elif key == 'sid':
            start = 0
            end = MAX_SID
        else:
            start = DEFAULT_STRIDE
            end = MAX_BLK_STRIDE_DOUBLE_BYTE
        TikCheckUtil.check_type_match(valul, (int, Scalar, Expr), "%s should be int, Scalar or Expr" % key)
        check_scalar_dtype(valul, "scalar_%s should be a scalar of int/uint" % key)
        TikCheckUtil.check_in_range_by_dtype(
            valul, msg="%s should be in the range of [%s, %s], input value is: %s"
            % (key, start, end, valul), var_range=[start, end])


class DataMoveCheck:
    """
    data move check class
    """

    def __init__(self, dm_obj, name=''):
        self.dm_obj = dm_obj
        self.name = name

    @source_info_decorator(depth=2)
    def check_all(self, params_value=None):
        """
        check params of data_move data_move_quant tensor_move
        """
        if not params_value:
            if self.name == 'tensor_mov':
                params_value = {
                    "nburst": self.dm_obj.nburst,
                    "burst_len": self.dm_obj.burst,
                    "src_stride": self.dm_obj.src_stride,
                }
            elif self.name == 'data_move_multi_nd2nz':
                params_value = {}
            else:
                params_value = {
                    "sid": self.dm_obj.sid,
                    "nburst": self.dm_obj.nburst,
                    "burst_len": self.dm_obj.burst,
                    "src_stride": self.dm_obj.src_stride,
                    "dst_stride": self.dm_obj.dst_stride
                }
        self._check_param_type_all(params_value)

    def check_mov_pad_instr_params(self, params=None):
        """
        check params of mov pad
        """
        if self.dm_obj.src.scope == scope_ubuf:
            check_address_align([self.dm_obj.src], ["src"])
        if self.dm_obj.dst.scope == scope_ubuf:
            check_address_align([self.dm_obj.dst], ["dst"])

        if params is None:
            params = [self.dm_obj.nburst, self.dm_obj.burst, self.dm_obj.dst_gap, self.dm_obj.src_gap,
                      self.dm_obj.right_padding, self.dm_obj.left_padding]

        _, _, _, _, right_padding, left_padding = params

        # OUT to UB, padding can be set, the nano soc doesn't support these two parameters.
        if not TikSocManager().is_nano_soc():
            self._check_padding_value(left_padding, right_padding)

        if TikSocManager.is_910b_soc() or TikSocManager.is_v300_610l_soc():
            max_padding_len = 32 // DTYPE_SIZE[self.dm_obj.dst.dtype]
            check_param_type_range(
                params, [1, 1, 0, 0, 0, 0], [4095, 2097151, 4294967295, 4294967295, max_padding_len, max_padding_len],
                ["nburst", "burst", "dst_gap", "src_gap", "right_padding", "left_padding"], "data_move_pad")
        else:
            check_param_type_range(
                params, [1, 1, 0, 0, 0, 0], [4095, 65535, 65535, 65535, 4, 4],
                ["nburst", "burst", "dst_gap", "src_gap", "right_padding", "left_padding"], "data_move_pad")
        if self.dm_obj.padding_value is not None:
            msg = "Intrinsic %s's padding_value should be in the range of %s" % (self.name, self.dm_obj.dst.dtype)
            TikCheckUtil.check_in_range_by_dtype(self.dm_obj.padding_value, self.dm_obj.dst.dtype, msg)

    def check_inter_key(self, instr_key, mov_pad_list):
        """
        inter_key mast in mov_pad_list.keys, if inter_key is UB to OUT, no need padding.
        """
        if instr_key not in mov_pad_list.keys() and\
                (isinstance(self.dm_obj.src, Tensor) and isinstance(self.dm_obj.dst, Tensor)):
            print_error_msg("Instruction %s doesn't support move data from %s to %s." %
                            (self.name, PRINT_SCOPE_MAP[self.dm_obj.src.scope], PRINT_SCOPE_MAP[self.dm_obj.dst.scope]))

        # check padding setting
        # UB to OUT, no need padding
        if instr_key == "UB OUT":
            TikCheckUtil.check_equality(
                self.dm_obj.right_padding, 0, "%s UB to OUT, right_padding must be 0" % self.name)
            TikCheckUtil.check_equality(
                self.dm_obj.left_padding, 0, "%s UB to OUT, left_padding must be 0" % self.name)
            TikCheckUtil.check_equality(
                self.dm_obj.padding_value, None, "%sUB to OUT, padding_value must be None" % self.name)

    def check_onthefly_mode(self):
        """
        check params when onthefly mode is not 0
        """
        arch_version_str = get_soc_name() + get_soc_core_type()
        TikCheckUtil.check_type_match(
            self.dm_obj.onthefly_mode, int,
            "onthefly_mode should be int, input type: {}".format(type(self.dm_obj.onthefly_mode)))
        TikCheckUtil.check_in_range_by_dtype(
            self.dm_obj.onthefly_mode, msg="Please specify onthefly_mode 1-add, 2-sub, input onthefly_mode: {}".format(
                self.dm_obj.onthefly_mode), var_range=[MIN_ONTHEFLY_MODE, MAX_ONTHEFLY_MODE])
        TikCheckUtil.check_var_in_list(
            arch_version_str, ARCHVERSION_ONTHEFLY.keys(), "%s doesn't support onthefly." % arch_version_str)
        TikCheckUtil.check_type_match(
            self.dm_obj.src_onthefly, Tensor,
            "when onthefly_mode is not 0, src_onthefly should be Tensor, input type: {}"
                .format(type(self.dm_obj.src_onthefly)))
        src_onthefly_dtype = DTYPE_MAP.get(self.dm_obj.src_onthefly.dtype)
        TikCheckUtil.check_var_in_list(
            src_onthefly_dtype, ARCHVERSION_ONTHEFLY.get(arch_version_str),
            "src_onthefly dtype should be in {}, input dtype: {}".format(ARCHVERSION_ONTHEFLY.get(arch_version_str),
                                                                         src_onthefly_dtype))
        TikCheckUtil.check_not_equality(
            self.dm_obj.src_onthefly_stride, None,
            "when onthefly_mode is not 0, src_onthefly_stride should not be None")

    def check_pad_mode(self, scope):
        """
        check tensor_mov pad_mode
        """
        if self.dm_obj.pad_mode is not None:
            TikCheckUtil.check_type_match(self.dm_obj.pad_mode, int, "padMode doesn't support online config or expr.")
            TikCheckUtil.check_in_range_by_dtype(
                self.dm_obj.pad_mode, msg="padMode should in range [%s, %s]." % (0, MAX_PADMODE),
                var_range=[0, MAX_PADMODE])
            TikCheckUtil.check_equality(scope, ("gm", "cbuf"), "PadMode only support OUT to L1.")

    def check_deqscale_sid(self):
        """
        check tensor_mov deqscale sid
        """
        # check deqscale
        if isinstance(self.dm_obj.deqscale, Tensor):
            TikCheckUtil.check_equality(SCOPE_MAP.get(self.dm_obj.deqscale.scope), "ubuf", "deqscale should in UB.")
        # check sid
        TikCheckUtil.check_in_range_by_dtype(
            self.dm_obj.sid_store_mode, msg="sid_store_mode should be in the range of [%s, %s], input value: %s"
            % (0, _MAX_SID_MOD, str(self.dm_obj.sid_store_mode)), var_range=[0, _MAX_SID_MOD])

    def check_scope_range(self, dtype_str, dst_scope, src_scope):
        """
        check scope range

        Parameters
        ----------
        dst: dst
        src: src
        dtype_str: dtype str
        dst_scope: dst's scope
        src_scope: src's scope

        Returns
        -------
        None
        """
        TikCheckUtil.check_var_in_list(
            dtype_str, src_dst_scope_dtype_map.get(src_scope).get(dst_scope),
            "%s Instruction tensor_mov doesn't support %s in %s to %s in %s." %
            (get_soc_name() + get_soc_core_type(), self.dm_obj.src.dtype, src_scope, self.dm_obj.dst.dtype, dst_scope))

    def check_mov_pad_tensor_dtype(self):
        """
        check dst and src dtype for instr mov_pad
        """
        if not all(isinstance(t, (Tensor, TensorAddrList)) for t in (self.dm_obj.src, self.dm_obj.dst)):
            TikCheckUtil.raise_error("src or dst should be Tensor, TensorAddrList")

        is_all_tensor_addr_list = all(is_tensor_addr_list(t) for t in (self.dm_obj.src, self.dm_obj.dst))
        if is_all_tensor_addr_list and (self.dm_obj.src.is_value is True or self.dm_obj.dst.is_value is True):
            TikCheckUtil.raise_error("data_move_pad doesn't support OUT to OUT")
        if self.dm_obj.src.scope == scope_ubuf and self.dm_obj.dst.scope == scope_ubuf and is_all_tensor_addr_list:
            TikCheckUtil.raise_error("data_move_pad doesn't support UB to UB")
        if isinstance(self.dm_obj.src, Tensor) and isinstance(self.dm_obj.dst, Tensor):
            TikCheckUtil.check_equality(self.dm_obj.dst.dtype, self.dm_obj.src.dtype,
                                        "Instruction %s's dst's dtype should be equal to src's dtype" % self.name)
        if not isinstance(self.dm_obj.dst, TensorAddrList):
            TikCheckUtil.check_equality(
                intrinsic_check_support("Intrinsic_data_move_pad", self.dm_obj.dst.dtype), True,
                gen_api_check_statement(self.dm_obj.dst.dtype, self.name))

    def _check_block_mode(self):
        """
        check tensor_mov block_mode
        """
        TikCheckUtil.check_var_in_list(
            self.dm_obj.block_mode, block_mode_appendix_map, "Please specify block_mode: ''/'m'/'v'/'sc'.")

    def _check_pad_value(self):
        """
        check padValue type
        """
        if self.dm_obj.pad_value is not None:
            TikCheckUtil.check_type_match(
                self.dm_obj.pad_value, (int, Scalar), "type of pad_value should be int or Scalar")

    def _check_tensor(self, tensor, tensor_name):
        if self.name == 'data_move':
            TikCheckUtil.check_type_match(tensor, (Tensor, TensorAddrList),
                                          "%s should be tensor or TensorAddrList" % tensor_name)
        else:
            TikCheckUtil.check_type_match(tensor, Tensor, "%s should be tensor" % tensor_name)
        tensor_align = dma_align_fn(tensor)
        if isinstance(tensor, Tensor):
            check_address_align((tensor,), (tensor_name,), tensor_align)

    def _check_tensor_mov_dst_stride(self):
        """
        check tensor_mov dst_stride
        """
        TikCheckUtil.check_type_match(self.dm_obj.dst_stride, (int, Scalar, Expr),
                                      "dst_stride should be int, Scalar or Expr")
        check_scalar_dtype(self.dm_obj.dst_stride,
                           "scalar_dst_stride should be a scalar of int/uint")
        if self.dm_obj.onthefly_mode != 0:
            TikCheckUtil.check_in_range_by_dtype(
                self.dm_obj.dst_stride, msg="dst_stride should be in the range of [{}, {}], input value is: {}".format(
                    DEFAULT_STRIDE, MAX_BLK_STRIDE_SINGLE_BYTE, self.dm_obj.dst_stride),
                var_range=[DEFAULT_STRIDE, MAX_BLK_STRIDE_SINGLE_BYTE])
            TikCheckUtil.check_equality(
                self.dm_obj.src_onthefly_stride, 0,
                "tensor_mov onthefly doesn't support src_onthefly_stride which is "
                "greater than 0, input src_onthefly_stride: %s" %
                str(self.dm_obj.rc_onthefly_stride))
            TikCheckUtil.check_in_range_by_dtype(
                self.dm_obj.src_onthefly_stride,
                msg="src_onthefly_stride should be in the range of [{}, {}], input value is: {}".format(
                    DEFAULT_STRIDE, MAX_BLK_STRIDE_SINGLE_BYTE, self.dm_obj.src_onthefly_stride),
                var_range=[DEFAULT_STRIDE, MAX_BLK_STRIDE_SINGLE_BYTE])
        else:
            TikCheckUtil.check_in_range_by_dtype(
                self.dm_obj.dst_stride, msg="dst_stride should be in the range of [{}, {}], input value is: {}".format(
                    DEFAULT_STRIDE, MAX_BLK_STRIDE_DOUBLE_BYTE, self.dm_obj.dst_stride),
                var_range=[DEFAULT_STRIDE, MAX_BLK_STRIDE_DOUBLE_BYTE])

    def _check_tensor_mov_scope(self):
        arch_version_str = get_soc_name() + get_soc_core_type()
        src_scope = SCOPE_MAP.get(self.dm_obj.src.scope)
        dst_scope = SCOPE_MAP.get(self.dm_obj.dst.scope)
        scope_str = get_scope_str(self.dm_obj.block_mode, self.dm_obj.src, self.dm_obj.dst)
        TikCheckUtil.check_var_in_list(arch_version_str, archversion_convrelu,
                                       "%s doesn't support convrelu feature." % arch_version_str)
        TikCheckUtil.check_var_in_list(scope_str, archversion_scope.get(arch_version_str),
                                       "%s Instruction tensor_mov doesn't support %s to %s." %
                                       (arch_version_str, src_scope, dst_scope))

    def _check_data_move_multi_nd2nz_scope(self):
        arch_version_str = get_soc_name() + get_soc_core_type()
        src_scope = SCOPE_MAP.get(self.dm_obj.src.scope)
        dst_scope = SCOPE_MAP.get(self.dm_obj.dst.scope)
        scope_str = get_scope_str("", self.dm_obj.src, self.dm_obj.dst)
        TikCheckUtil.check_var_in_list(arch_version_str, archversion_nd2nz,
                                       "%s doesn't support data_move_multi_nd2nz." % arch_version_str)
        TikCheckUtil.check_var_in_list(scope_str, archversion_nd2nz.get(arch_version_str),
                                       "%s Instruction data_move_multi_nd2nz doesn't support %s to %s." %
                                       (arch_version_str, src_scope, dst_scope))

    def _check_mov_nd2nz_instr_params(self):
        """
        check params of mov nd2nz
        """
        # check dtype
        TikCheckUtil.check_equality(self.dm_obj.dst.dtype, self.dm_obj.src.dtype,
                                    "data_move_multi_nd2nz's src's dtype should be equal to dst's dtype")
        short_dype = DTYPE_SHORT_NAME_MAP.get(self.dm_obj.dst.dtype, self.dm_obj.dst.dtype)
        TikCheckUtil.check_equality(tik_api_check_support("tik.data_move_out2l1_nd2nz", short_dype), True,
                                    gen_api_check_statement(short_dype, self.name))

        check_address_align([self.dm_obj.dst], ["dst"])

        params = [self.dm_obj.nd_num, self.dm_obj.nd_n, self.dm_obj.nd_d,
                  self.dm_obj.src_nd_stride, self.dm_obj.src_n_stride,
                  self.dm_obj.dst_c0_stride, self.dm_obj.dst_n_stride, self.dm_obj.dst_nd_stride]

        check_param_type_range(
            params, [0, 0, 0, 0, 1, 1, 1, 1], [4095, 16384, 65535, 65535, 65535, 16384, 16384, 65535],
            ["nd_num", "nd_n", "nd_d", "src_nd_stride", "src_n_stride",
             "dst_c0_stride", "dst_n_stride", "dst_nd_stride"],
            "data_move_multi_nd2nz")

    def _check_mov_nd2nz_overlap(self):
        # element
        c0 = 32 / DTYPE_SIZE[self.dm_obj.src.dtype]

        extent_dst_nd = Expr((self.dm_obj.nd_n - 1) * self.dm_obj.dst_n_stride * c0 + c0).eval_value()
        stride_dst_nd = Expr(self.dm_obj.dst_nd_stride).eval_value()
        if extent_dst_nd is not None and stride_dst_nd is not None:
            TikCheckUtil.check_ge(stride_dst_nd, extent_dst_nd,
                                  "Destination data must not be overlap")

        extent_dst_c0 = Expr((self.dm_obj.nd_num - 1) * self.dm_obj.dst_nd_stride +
                             (self.dm_obj.nd_n - 1) * self.dm_obj.dst_n_stride * c0 + c0).eval_value()
        stride_dst_c0 = Expr(self.dm_obj.dst_c0_stride * c0).eval_value()
        if extent_dst_c0 is not None and stride_dst_c0 is not None:
            TikCheckUtil.check_ge(stride_dst_c0, extent_dst_c0,
                                  "Destination data must not be overlap")

    def _check_param_type_all(self, params_value):
        self._check_tensor(self.dm_obj.src, 'src')
        self._check_tensor(self.dm_obj.dst, 'dst')
        _check_param_type(params_value)
        if self.name == 'tensor_mov':
            self._check_tensor_mov_dst_stride()
            self._check_block_mode()
            self._check_pad_value()
            self._check_tensor_mov_scope()
        elif self.name == "data_move_multi_nd2nz":
            self._check_data_move_multi_nd2nz_scope()
            self._check_mov_nd2nz_instr_params()
            self._check_mov_nd2nz_overlap()

    def _check_padding_value(self, left_padding, right_padding):
        if self.dm_obj.padding_value is not None:
            TikCheckUtil.check_type_match(
                self.dm_obj.padding_value, (int, float), "When padding_value is not None, it can be int or float")
            if isinstance(self.dm_obj.right_padding, int) and self.dm_obj.right_padding == 0 and \
                    isinstance(self.dm_obj.left_padding, int) and self.dm_obj.left_padding == 0:
                print_error_msg("When right_padding and left_padding is 0, padding_value must be set to None")
        else:
            if (isinstance(right_padding, int) and right_padding != 0) or \
                    (isinstance(left_padding, int) and left_padding != 0):
                print_error_msg("When right_padding or left_padding is not 0, padding_value cannot be set to None")


class VCopyCheck:
    """
    vcopy api check class
    """

    def __init__(self, vcopy_obj):
        self.dst = vcopy_obj.dst
        self.src = vcopy_obj.src
        self.mask = vcopy_obj.mask
        self.mask_mode = vcopy_obj.mask_mode
        self.repeat_times = vcopy_obj.repeat_times
        self.dst_blk_stride = vcopy_obj.dst_blk_stride
        self.src_blk_stride = vcopy_obj.src_blk_stride
        self.dst_rep_stride = vcopy_obj.dst_rep_stride
        self.src_rep_stride = vcopy_obj.src_rep_stride
        self.context = None
        self.block_size = get_compatible_blk_size()
        self.repeat_size = get_compatible_rep_size()

    @staticmethod
    def _check_vcopy_overlap(dst_extend_interval, src_extend_interval, msg):
        for interval_dst in dst_extend_interval:
            for interval_src in src_extend_interval:
                if max(interval_src[0], interval_dst[0]) < min(interval_src[1], interval_dst[1]):
                    TikCheckUtil.raise_error(msg)

    @staticmethod
    def _cal_mask_rep_for_counter_mode(mask, tensor_dtype, block_size):
        block_len = block_size // DTYPE_SIZE[tensor_dtype]
        TikCheckUtil.check_type_match(
            mask, int, "mask here should be int, input type of mask: %s" % type(mask))
        nblock = ceil_div(mask * DTYPE_SIZE[tensor_dtype], block_size)
        mask = mask % (nblock * block_len)
        if mask == MASK_VALUE_ZERO:
            mask = nblock * block_len
        return mask, nblock

    @staticmethod
    def _calculate_vecotor_max_offset(repeat, blk_stride, rep_stride, mask_len, block_len):

        blk_num_last_rep = ceil_div(mask_len, block_len)
        ele_num_last_blk = mask_len % block_len if mask_len % block_len else block_len

        # last rep has multi blocks, blk_stride is zero, last blk num must be set to block len
        if blk_num_last_rep > 0 and blk_stride == 0:
            ele_num_last_blk = block_len

        # blk_stride: stride, rep_stride: stride, unit: 32B
        max_offset = ((repeat - 1) * rep_stride + (blk_num_last_rep - 1) * blk_stride) * block_len + ele_num_last_blk

        return max_offset

    def set_value(self, params_val):
        """
        set params value use context in debug
        """
        self.mask = params_val[0]
        self.repeat_times = params_val[1]
        self.dst_blk_stride = params_val[2]
        self.src_blk_stride = params_val[3]
        self.dst_rep_stride = params_val[4]
        self.src_rep_stride = params_val[5]

    def check_repeat_times(self, is_debug=False):
        """
        check repeat_times dtype, range

        Parameters
        ----------
        max_repeat: max repeat times, some times set to MAX_REPEAT_TIME_DOUBLE_BYTE
        is_debug: if is debug mode

        Returns
        -------
        None
        """
        min_repeat = 0
        if not is_debug:
            min_repeat = 1
            TikCheckUtil.check_type_match(
                self.repeat_times, (int, Scalar, Expr),
                "repeat_times should be int, Scalar or Expr, input type of repeat_times:"
                " {}".format(type(self.repeat_times)))
            check_scalar_dtype(self.repeat_times, "scalar_repeat_time should be a Scalar or Expr of int/uint")
        TikCheckUtil.check_in_range_by_dtype(
            self.repeat_times, msg="repeat_times should be in the range of [%s, %s], input repeat_times: %s"
            % (min_repeat, MAX_REPEAT_TIMES, self.repeat_times), var_range=[min_repeat, MAX_REPEAT_TIMES])

    def check_vector_stride_repeat(self, is_debug=False):
        """
        check blk_stride and rep_stride params of vector instructions
        """
        # check repeat
        if TikSocManager.is_nano_soc() and is_compatible_mode():
            max_blk_stride, max_rep_stride = MAX_BLK_STRIDE_DOUBLE_BYTE // 2, MAX_REP_STRIDE_12_BITS // 2
        else:
            max_blk_stride, max_rep_stride = MAX_BLK_STRIDE_DOUBLE_BYTE, MAX_REP_STRIDE_12_BITS
        self.check_repeat_times(is_debug=is_debug)

        vector_stride_info = {
            "src_rep_stride": self.src_rep_stride,
            "dst_rep_stride": self.dst_rep_stride,
            "src_blk_stride": self.src_blk_stride,
            "dst_blk_stride": self.dst_blk_stride,
        }
        for name, value in vector_stride_info.items():
            TikCheckUtil.check_type_match(
                value, (int, BasicExpr), "%s should be int, Expr or Scalar, input type is %s" % (name, type(value)))

            check_scalar_dtype(value, "scalar %s should be a scalar of int/uint" % name)

            if 'rep' in name:
                stride_range = max_rep_stride
            else:
                stride_range = max_blk_stride

            TikCheckUtil.check_in_range_by_dtype(
                value, msg="%s should be in the range of [%s, %s], input value is %s"
                % (name, DEFAULT_STRIDE, stride_range, value), var_range=[DEFAULT_STRIDE, stride_range])

    def get_extend_interval(self, mask, time, offset, is_src=False):
        """
        get tensor each blk interval
        """
        if is_src:
            blk_valid_list, block_len = self._get_src_dst_blk_list(mask, self.src.dtype)
            blk_stride = self.src_blk_stride
            rep_stride = self.src_rep_stride
            dtype = self.src.dtype
        else:
            blk_valid_list, block_len = self._get_src_dst_blk_list(mask, self.dst.dtype)
            blk_stride = self.dst_blk_stride
            rep_stride = self.dst_rep_stride
            dtype = self.dst.dtype

        extend_interval = []
        for blk_id in blk_valid_list:
            # blk_stride, rep_stride, unit: 32B
            begin = blk_id * blk_stride * block_len + time * rep_stride * block_len + offset
            end = begin + block_len
            extend_interval.append([begin * DTYPE_SIZE[dtype], end * DTYPE_SIZE[dtype]])
        return extend_interval

    def check_vcopy_address_overlapping(self, dst_offset, src_offset):
        """
        check address overlap
        """
        nblock = BLK_NUM_PER_REP
        block_len = self.repeat_size // get_bit_len(self.dst.dtype)

        if not check_overlap_param(self.mask, self.repeat_times, dst_offset, src_offset):
            return
        mask = self.mask
        if self.mask_mode == "counter":
            # for vcopy, counter mode is special
            mask = nblock * block_len

        # check address overlap
        if self.repeat_times == 1:
            if src_offset == dst_offset and self.src_blk_stride == self.dst_blk_stride:
                # 100 percent same, support
                pass
            else:
                self._check_vcopy_overlap_single(mask, dst_offset, src_offset)
        else:
            self._check_vcopy_overlap_many(mask, dst_offset, src_offset)

    def vector_max_offset_cal(self, mask, blk_stride, rep_stride, nblock):
        """
        get max offset of calculate vector
        Parameters
        ----------
        mask: Effective operation on element, divided into two model: Continuous and bit by bit.
        dtype: tensor dtype
        blk_stride: blk_stride
        rep_stride: rep_stride

        Returns
        -------
        max_offset
        """
        block_len = self.block_size // DTYPE_SIZE[self.dst.dtype]
        if not isinstance(mask, (list, tuple)):
            mask = [mask]
        # mask_len, the last effective element
        mask_len = 0
        bit_len = get_bit_len(self.dst.dtype)
        if bit_len == BIT_LEN_32:
            mask_len = get_32bit_dtype_mask_len(mask, self.mask_mode)
        elif bit_len == BIT_LEN_8 or BIT_LEN_16:
            mask_len = get_8or16bit_dtype_mask_len(mask)

        if self.mask_mode == "normal":
            max_offset = self._calculate_vecotor_max_offset(
                self.repeat_times, blk_stride, rep_stride, mask_len, block_len)

        # counter mode, offset at penultimate repeat may be larger than offset
        # at last repeat
        else:
            full_mask = nblock * block_len
            if mask_len == full_mask:
                max_offset = self._calculate_vecotor_max_offset(
                    self.repeat_times, blk_stride, rep_stride, mask_len, block_len)
            else:
                offset_0 = self._calculate_vecotor_max_offset(
                    self.repeat_times - 1, blk_stride, rep_stride, full_mask, block_len)
                offset_1 = self._calculate_vecotor_max_offset(
                    self.repeat_times, blk_stride, rep_stride, mask_len, block_len)
                max_offset = max(offset_0, offset_1)
        return max_offset

    def check_vcopy_tensor_op_overflow(self, is_src=True):
        """
        check tensor overflow
        """

        if is_src:
            tensor = self.src
            blk_stride = self.src_blk_stride
            rep_stride = self.src_rep_stride
            name = 'src'
        else:
            tensor = self.dst
            blk_stride = self.dst_blk_stride
            rep_stride = self.dst_rep_stride
            name = 'dst'

        if is_basic_expr(TikUtil.to_list(self.mask)) or\
                any(is_basic_expr([value]) for value in [self.repeat_times, blk_stride, rep_stride]):
            return
        if self.repeat_times == 0:
            return
        mask = self.mask
        nblock = BLK_NUM_PER_REP
        if self.mask_mode == "counter":
            mask, nblock = self._cal_mask_rep_for_counter_mode(mask, tensor.dtype, self.block_size)

        total_size, offset = self._get_total_size_offset(tensor)

        if isinstance(offset, (tvm.tir.IntImm, tvm.tir.FloatImm, tvm.tir.StringImm)):
            offset = offset.value

        extend_offset = self.vector_max_offset_cal(mask, blk_stride, rep_stride, nblock)
        # offset means offset away from tensor head address, it's 16 for tensor[16]
        # entend_offset means valid data offset
        need_offset = Expr(extend_offset + offset).eval_value()
        if need_offset is not None:
            TikCheckUtil.check_le(need_offset, total_size,
                                  "%s tensor overflow, expected elements nums: %s,"
                                  " actual elements nums: %s" % (name, need_offset, total_size))

    def check_dst_src_tensor(self):
        """
        used to check vector api's params of one dst one src
        Parameters
        ----------
        name: inner instr name
        dst: dst tensor, should be ubuf
        src: src tensor, should be ubuf
        src_name: tensor src's param name of api
        Returns
        -------
        no return
        """
        TikCheckUtil.check_type_match(self.dst, Tensor, "dst should be tensor, but input type: %s" % type(self.dst))
        TikCheckUtil.check_equality(
            self.dst.scope, scope_ubuf, "dst scope should be %s, but input scope: %s" % (
                PRINT_SCOPE_MAP[scope_ubuf], PRINT_SCOPE_MAP[self.dst.scope]))
        TikCheckUtil.check_type_match(self.src, Tensor, "src should be tensor, but input type: %s" % type(self.src))
        TikCheckUtil.check_equality(
            self.src.scope, scope_ubuf, "src scope should be %s, but input scope: %s" % (
                PRINT_SCOPE_MAP[scope_ubuf], PRINT_SCOPE_MAP[self.src.scope]))

        # check UB address 32B align
        align = vec_template_align(self.src.dtype)
        check_address_align((self.dst, self.src), ("dst", "src"), align)

        # check dtype
        TikCheckUtil.check_equality(self.dst.dtype, self.src.dtype,
                                    "Intrinsic vcopy's src's dtype should be equal to dst's dtype")
        TikCheckUtil.check_equality(intrinsic_check_support("Intrinsic_vcopy", self.dst.dtype), True,
                                    gen_api_check_statement(self.dst.dtype, 'vcopy'))

    def check_all(self):
        """
        vcopy api check all
        """
        dst_offset, src_offset = self._get_tensor_offset()

        # check address overlap
        value_range = (self.repeat_times, self.dst_blk_stride, self.src_blk_stride,
                       self.dst_rep_stride, self.src_rep_stride)
        if self.dst.buffer == self.src.buffer and all(isinstance(value, int) for value in value_range):
            self.check_vcopy_address_overlapping(dst_offset, src_offset)

        # check tensor overflow
        self.check_vcopy_tensor_op_overflow(is_src=False)
        self.check_vcopy_tensor_op_overflow(is_src=True)

    def _get_total_size_offset(self, tensor):
        """
        get tensor shape, offset use context
        """
        if self.context:
            offset = self.context.get_tensor_offset(tensor)
            original_shape_val = self.context.get_tensor_original_shape(tensor)
        else:
            offset = tensor.offset
            original_shape_val = tensor.original_shape

        return reduce_mul(original_shape_val), offset

    def _check_vcopy_overlap_single(self, mask, dst_offset, src_offset):

        dst_extend_interval = self.get_extend_interval(mask, self.repeat_times - 1, dst_offset, False)
        src_extend_interval = self.get_extend_interval(mask, self.repeat_times - 1, src_offset, True)

        error_msg = "vcopy address overlapping error. when repeat_times=1," \
                    " only support dst and src 100 percent same, and stride must be same too."
        self._check_vcopy_overlap(dst_extend_interval, src_extend_interval, msg=error_msg)

    def _check_vcopy_overlap_many(self, mask, dst_offset, src_offset):
        for time in range(self.repeat_times - 1):
            dst_extend_interval = self.get_extend_interval(mask, time, dst_offset, False)
            src_extend_interval = self.get_extend_interval(mask, time + 1, src_offset, True)

            error_msg = "When repeat_times>1, vcopy dst and src address overlapping error." \
                        " It is not support iteration N's destination is the source of next iteration"

            self._check_vcopy_overlap(dst_extend_interval, src_extend_interval, msg=error_msg)

    def _get_tensor_offset(self):
        if self.context:
            dst_offset = self.context.evaluate_expr(self.dst.offset)
            src_offset = self.context.evaluate_expr(self.src.offset)
        else:
            dst_offset = Expr(self.dst.offset).eval_value()
            src_offset = Expr(self.src.offset).eval_value()

        return dst_offset, src_offset

    def _get_src_dst_blk_list(self, mask, dtype):
        """
        get blk valid list for check overlap
        """
        if not isinstance(self.mask, (list, tuple)):
            mask = [self.mask]
        block_len = self.repeat_size // get_bit_len(dtype)
        blk_valid_list = get_blk_valid_list(mask, dtype, block_len)
        return blk_valid_list, block_len
