#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_new_api_base.py
DESC:     v210 vector api base class
CREATED:  2021-11-24 17:07
MODIFIED: 2021-11-24 17:07
"""

from collections import namedtuple
from tbe import tvm
from tbe.common.platform import scope_preg
from tbe.common.platform import scope_vreg
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.util import TikCheckUtil
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.tik_lib.tik_check_util import print_error_msg
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.tik_lib.tik_mask_concat_ import mask_concat
from tbe.tik.api.tik_vector import Vector
from tbe.tik.tik_lib.tik_vector_new_api.tik_preg_api_ import TikPregApiInner
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_new_api_ import TikVectorNewApiInner
from tbe.tik.tik_lib.tik_vector_new_api.tik_wide_api_ import TikWideApiInner


class TikVectorNewApiBase(TikPregApiInner, TikVectorNewApiInner, TikWideApiInner):
    """
    v210 vector api base
    """
    intlv_params = namedtuple("VdintlvParams", "name dst0 dst1 src0 src1")
    vec_op_params = namedtuple("VecOpParams", "name mask dst src scalar src0 src1")
    vec_wmul_wmuls = namedtuple(
        "Wmul", "name mask dst src0 src1 acc_mode part_mode api_name, src1_dtype", defaults=[None])
    wmul_v2 = namedtuple("Wmul", "name dst src0 src1 src2 acc_mode api_name")
    wmuls_v2 = namedtuple("Wmuls", "name dst src0 src1 acc_mode api_name")
    vec_wpack_wpacks = namedtuple("Wpack", "name api_name mask dst src0 src1 rs_mode part_mode")
    vec_vslide = namedtuple("Vslide", "name dst src0 src1 dtype slide_size")
    vec_vcb_params = namedtuple("vcb", "name mask dst dst1 src")
    vec_unpack_params = namedtuple("Upack", "name dst src part_mode")
    vec_cast_vfcvt = namedtuple("CastVfcvt", "mask dst src saturate_flag part_indicator round_mode")
    vec_filter1d = namedtuple(
        "Filter1d", "name api_name dst src window_size line_num dst_stride src_stride"
                    " r1c1 r1c2 r1c3 r1c4 r1c5 r1t r2t r3t r4t r5t rsah rsa")
    vec_filter_max_min = namedtuple(
        "FilterMaxMin", "name instr_name api_name dst src window_size line_num dst_stride src_stride")
    vec_vfilter = namedtuple("Filter", "name dst src0 src1 coef0 coef1 coef2 coef3 coef4 filter_mode")
    vec_vbr = namedtuple("Vbr", "name dst src api_name")
    vec_load = namedtuple("Load", "mask dst src ld_mode ureg vlen str_ld_mode st_mode str_st_mode")
    vec_data_move_gather = namedtuple("DataMoveGather", "dst src src_index index_num ele_size dst_stride")

    def __init__(self):
        super(TikVectorNewApiBase, self).__init__()
        self.core_arch = None
        self.core_version = None

    @staticmethod
    def get_min_value(dtype):
        """
        get min value
        Parameters
        ----------
        dtype: data type

        Returns
        -------
        min value
        """
        if dtype == "float16":
            return 0.0
        return 0

    def get_vector_length(self, dtype):
        """
        get vector length
        Parameters
        ----------
        dtype: data type

        Returns
        -------
        length
        """
        if dtype not in DTYPE_SIZE:
            print_error_msg("input data type not support now!")
        # if not v210, total_reg is 0
        return self.code_buffer_manager.get_reg_len(scope_vreg, dtype)

    def vdintlv_code(self, intlv_params, dtype):
        """
        vdintlv code
        Parameters
        ----------
        intlv_params
        dtype

        Returns
        -------

        """
        self.check_params_obj.check_vector_two_dst_two_src_params(intlv_params, dtype)
        if intlv_params.dst0.scope == scope_preg:
            instr_name = intlv_params.name.replace('vectorized_v', 'vectorized_p')
            intlv_params = TikVectorNewApiBase.intlv_params(instr_name, *intlv_params[1:])
            return self._mask_intlv_pintlv_make_code(intlv_params, dtype)
        # for scope_vreg
        return self._vec_intlv_dintlv_gen_code(intlv_params)

    def apply_for_new_vector(self, dtype, shape=None, scope=scope_vreg, name='tmp_vector'):
        """
        alloc buffer
        Parameters
        ----------
        dtype : vector's dtype
        shape : vector's shape
        scope : scope_vreg
        name : vector's name

        Returns
        -------
        buffer
        """
        buf_var = self.allocate((dtype, shape, name), scope=scope)
        tmp_buffer = tvm.decl_buffer(shape, buf_var.dtype, name=name, scope=scope, data=buf_var)
        return tmp_buffer

    def mask_to_pg_args(self, mask):
        """
        create pg args according mask
        Parameters
        ----------
        mask: effective operation on element, only support one model: Continuous

        Returns
        -------
        pg args
        """
        if isinstance(mask, (list, tuple)):
            TikCheckUtil.raise_error("not support list/tuple mask")
        TikCheckUtil.check_type_match(
            mask, (int, Scalar),
            "In counter mode, mask should be int or Scalar, input type of mask: %s" % type(mask))
        if isinstance(mask, Scalar):
            check_scalar_dtype(mask, "scalar_mask should be a scalar of int/uint")
            TikCheckUtil.raise_error("not support Scalar mask")
        return mask_concat(self, mask)

    def vmul_dst_vector(self, vec_op_params_ins):
        """
        vmul dst is vector
        Parameters
        ----------
        vec_op_params_ins

        Returns
        -------

        """
        acc_mode = vec_op_params_ins.acc_mode
        if acc_mode is not None and acc_mode not in ["MULA"]:
            print_error_msg("Intrinsic vector_vmul's acc_mode can only be [None, \"MULA\"]")
        else:
            self.check_params_obj.check_vector_one_dst_one_src_params(
                "vectorized_vmul", vec_op_params_ins.dst, vec_op_params_ins.src0,
                src_name="src0", api_name=vec_op_params_ins.api_name)
            src1_dtype = self.check_params_obj.get_and_check_wmul_src1_dtype(
                vec_op_params_ins.src0.dtype, vec_op_params_ins.src1,
                vec_op_params_ins.part_mode, vec_op_params_ins.api_name)
            instr_name = vec_op_params_ins.name
            if not isinstance(vec_op_params_ins.src1, Vector):
                instr_name = "vectorized_wmuls"
                if acc_mode is not None:
                    acc_mode = "MULAS"  # to user, this mode only be None or "MULA", here change MULA to MULAS
            vec_op_params_ins = TikVectorNewApiBase.vec_wmul_wmuls(
                instr_name, vec_op_params_ins.mask, vec_op_params_ins.dst,
                vec_op_params_ins.src0, vec_op_params_ins.src1, acc_mode,
                vec_op_params_ins.part_mode, vec_op_params_ins.api_name, src1_dtype)
            self._vector_wmul_wmuls(vec_op_params_ins)

    def wmul_v2_dst_vector(self, vec_op_params_ins):
        """
        wmul_v2 dst is vector
        Parameters
        ----------
        vec_op_params_ins

        Returns
        -------

        """

        self.check_params_obj.check_wmul_v2(vec_op_params_ins)

        self._vector_wmul_wmula_gen_code_v300(vec_op_params_ins)

    def wmuls_v2_dst_vector(self, vec_op_params_ins):
        """
        wmuls_v2 dst is vector
        Parameters
        ----------
        vec_op_params_ins

        Returns
        -------

        """
        self.check_params_obj.check_wmuls_v2(vec_op_params_ins)
        src1_dtype = self.check_params_obj.get_and_check_wmul_src1_dtype(
            vec_op_params_ins.src0.dtype, vec_op_params_ins.src1,
            "EVEN", vec_op_params_ins.api_name)
        self._vector_wmuls_wmulas_gen_code_v300(vec_op_params_ins, src1_dtype)
