#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_proposal_api_.py
DESC:     provide proposal instructions
CREATED:  2019-08-12 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""
from collections import namedtuple
from tbe import tvm
from tbe.common.platform import scope_ubuf
from tbe.common.platform import intrinsic_check_support

from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.tik_lib.tik_check_util import float_in_range
from tbe.tik.common.util import reduce_mul
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.tik_lib.tik_expr import is_basic_expr
from tbe.tik.common.common_util import check_vector_stride
from tbe.tik.common.common_check_func import check_overlapping_vsort32
from tbe.tik.common.common_check_func import check_vms4v2_repeat_times
from tbe.tik.common.common_check_func import check_vms4_repeat_times
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_spr_debug import vms4_to_scalar_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_spr_debug import set_rpn_cor_ir_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_spr_debug import set_rpn_offset_decorator
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik import debug
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_util import concat_params
from tbe.tik.tik_lib.tik_api_util import check_tensor_list
from tbe.tik.tik_lib.tik_api_util import check_repeat_times
from tbe.tik.tik_lib.tik_params import RPN_COR_IR
from tbe.tik.tik_lib.tik_params import MIN_MODE_NUMBER
from tbe.tik.tik_lib.tik_params import VMS4_SR
from tbe.tik.tik_lib.tik_params import RPN_OFFSET
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import MAX_MODE_NUMBER
from tbe.tik.tik_lib.tik_params import VMS4_REGION_LIST0_POS
from tbe.tik.tik_lib.tik_params import VMS4_REGION_LIST2_POS
from tbe.tik.tik_lib.tik_params import VMS4_REGION_LIST1_POS
from tbe.tik.tik_lib.tik_params import VMS4_REG_BIT_ALL_ONE
from tbe.tik.tik_lib.tik_params import SRC_LIST_LEN
from tbe.tik.tik_lib.tik_params import MAX_ELEMENTS_LEN
from tbe.tik.tik_lib.tik_params import VALID_BIT_TUPLE
from tbe.tik.tik_lib.tik_params import MAX_REP_STRIDE_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_params import VMRGSORT4_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import VMRGSORT4_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import RPN_COR_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import RPN_COR_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import MAX_MODE_NUMBER_VEXTRACT_V100
from tbe.tik.tik_lib.tik_params import VALID_BIT_TUPLE_V200
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_params import VMS4V2_REG_BIT_ALL_ONE
from tbe.tik.tik_lib.tik_params import VMS4V2_REGION_LIST_POS
from tbe.tik.tik_lib.tik_params import MAX_ELEMENTS_LEN_V2
from tbe.tik.tik_lib.tik_params import VMRGSORT4V2_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import VMRGSORT4V2_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import VMRGSORT4V2_SRC1_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import VMRGSORT4V2_SRC1_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import MAX_NUMBER
from tbe.tik.tik_lib.tik_params import SCALAR_LIST_LEN
from tbe.tik.tik_lib.tik_params import DEFAULT_STRIDE
from tbe.tik.tik_lib.tik_params import DTYPE_REL_TOL
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.common.common_util import check_address_align
from tbe.tik.tik_lib.tik_proposal_util import get_vms4_addr_align
from tbe.tik.tik_lib.tik_proposal_util import check_vms4_dst_tensor_overflow
from tbe.tik.tik_lib.tik_proposal_util import check_vms4_src_tensor_overflow
from tbe.tik.tik_lib.tik_proposal_util import check_vms4_tensor_overlap
from tbe.tik.tik_lib.tik_proposal_util import check_vms4v2_dst_tensor_overflow
from tbe.tik.tik_lib.tik_proposal_util import check_vms4v2_src_tensor_overflow
from tbe.tik.tik_lib.tik_proposal_util import check_vms4v2_tensor_overlap
from tbe.tik.tik_lib.tik_proposal_util import check_overflow
from tbe.tik.tik_lib.tik_proposal_util import check_special_intrin_func_overflow
from tbe.tik.tik_lib.tik_proposal_util import addr_array_make
from tbe.tik.tik_lib.tik_proposal_util import check_tensor_and_scope
from tbe.tik.tik_lib.tik_proposal_util import check_vms4_src_list
from tbe.tik.tik_lib.tik_proposal_util import check_vms_src_list
from tbe.tik.tik_lib.tik_proposal_util import check_vms_vms4_dtype
from tbe.tik.tik_lib.tik_proposal_util import check_element_lengths
from tbe.tik.tik_lib.tik_proposal_util import check_scalar_array_and_suspension
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vconcate_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vms_decarator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import rpn_cor_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vextract_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vbs32_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import vmsv2_decarator

# one proposal contanis 8 elements
_ELEMENTS_COUNT = 8
# each repeat computes 16 proposals
_PROPOSAL_NUM = 16
# element number per proposal
_ELEMENTS_PER_PROPOSAL = 8


class TikProposalApi(TikIRBuilder):
    """
    Proposal Operation Api
    """
    align_dst = 32
    align_src = 8
    # used to define attr vmrgsort4 value
    vmrgsort4_attr_value = 0
    proposal_api = namedtuple("ProposalApi", ["dst", "src", "repeat_times", "mode_number"])
    rpn_cor_api = namedtuple("Rpn_corApi", ["src0", "src1", "src0_rep_stride", "src1_rep_stride", "repeat_times"])
    vmrgsort4_api = namedtuple("Vmrgsort4Api", ["dst", "src_list", "element_count_list", "if_exhausted_suspension",
                                                "valid_bit", "repeat_times", "vms4_sr_scalar_array", "exh_susp_number"])
    vsort32_api = namedtuple("Vsort32Api", ["dst", "src0", "src1", "repeat_times"])

    @staticmethod
    def get_vm4_value() -> str:
        """
        create index for addr_array variable
        Parameters
        ----------

        Returns
        -------
        current addr_array variable index
        """
        TikProposalApi.vmrgsort4_attr_value += 1
        return str(TikProposalApi.vmrgsort4_attr_value)

    @staticmethod
    def _rnp_offset_check(offset, offset_dtype):
        # check core_version
        if TikSocManager.is_mini_soc() or TikSocManager.is_v300_610l_soc():
            TikCheckUtil.raise_error("current soc unsupported set_rpn_offset")
        # check number
        TikCheckUtil.check_type_match(offset, (int, float, Scalar), "offset should be int, float or Scalar")

        # v200 offset can be float16 or float32
        if TikSocManager.is_v200_soc() or TikSocManager.is_v210_soc() or TikSocManager.is_910b_soc():
            if offset_dtype not in ("float16", "float32"):
                TikCheckUtil.raise_error("for current chip, offset_dtype can support float16 and float32")
        else:  # v100 offset can be float16
            if offset_dtype != "float16":
                TikCheckUtil.raise_error("for current chip, offset_dtype only support float16")

        if isinstance(offset, Scalar):
            TikCheckUtil.check_equality(offset.dtype, offset_dtype, "offset's dtype mismatch with offset_dtype")
        elif not float_in_range(offset, offset_dtype, DTYPE_REL_TOL[offset_dtype]):
            TikCheckUtil.raise_error("offset value should be in the range of %s" % offset_dtype)

    @source_info_decorator()
    def vextract(self, dst, src, repeat_times, mode_number):
        """
        Extract the corresponding element from the proposal

        Parameters
        ----------
        dst:destination tensor
        src:source tensor
        mode_number: 0: x1, 1: y1, 2: x2, 3: y2, 4: score, 5:label
        repeat_times:[1,255]

        Returns
        -------
        None
        """
        # check dst src
        TikCheckUtil.check_type_match(dst, Tensor, "dst should be tensor")
        TikCheckUtil.check_equality(dst.scope, scope_ubuf, "dst scope should be ub, input scope: %s" % dst.scope)
        TikCheckUtil.check_type_match(src, Tensor, "src should be tensor")
        TikCheckUtil.check_equality(src.scope, scope_ubuf, "src scope should be ub, input scope: %s" % src.scope)
        # check UB address 32B align
        check_address_align((dst, src), ("dst", "src"))
        # check repeat_times
        check_repeat_times(repeat_times)
        TikCheckUtil.check_type_match(mode_number, (int, Scalar, Expr), "mode_number should be int, Scalar or Expr")
        check_scalar_dtype(mode_number, "scalar_mode_number should be a scalar of int/uint")
        if TikSocManager.is_mini_soc():
            TikCheckUtil.check_in_range_by_dtype(
                mode_number, msg="mode_number should be in the range of [%d, %d], input value is %s"
                % (MIN_MODE_NUMBER, MAX_MODE_NUMBER_VEXTRACT_V100, str(mode_number)),
                var_range=[MIN_MODE_NUMBER, MAX_MODE_NUMBER_VEXTRACT_V100])
        else:
            TikCheckUtil.check_in_range_by_dtype(
                mode_number, msg="mode_number should be in the range of [%d, %d], input value is %s"
                % (MIN_MODE_NUMBER, MAX_MODE_NUMBER, str(mode_number)), var_range=[MIN_MODE_NUMBER, MAX_MODE_NUMBER])
        # check dtype
        TikCheckUtil.check_equality(dst.dtype, src.dtype,
                                    "Instruction vextract's src's dtype should be equal to dst's dtype")
        TikCheckUtil.check_equality(intrinsic_check_support("Intrinsic_" + "vextract", dst.dtype), True,
                                    gen_api_check_statement(dst.dtype, "vextract"))
        # check dst src tensor overflow
        # in 1 repeat, read 16 proposals in which there're 8 elements.
        # write 16 elements
        if all(Expr(value).eval_value() is not None for value in (repeat_times, src.offset)):
            src_expected_size = repeat_times*16*8 + src.offset
            src_total_size = reduce_mul(src.original_shape)
            TikCheckUtil.check_ge(src_total_size, src_expected_size,
                                  "src tensor overflow, expected src shape: %s, "
                                  "actual src shape: %s" % (src_expected_size, src_total_size))

        if all(Expr(value).eval_value() is not None for value in (repeat_times, dst.offset)):
            dst_expected_size = repeat_times*16 + dst.offset
            dst_total_size = reduce_mul(dst.original_shape)
            TikCheckUtil.check_ge(dst_total_size, dst_expected_size,
                                  "dst tensor overflow, expected dst shape: %s, "
                                  "actual dst shape: %s" % (dst_expected_size, dst_total_size))
        # code gen
        vextract_obj = TikProposalApi.proposal_api(dst, src, repeat_times, mode_number)
        self.vextract_gen_code(vextract_obj)

    @vextract_decorator
    def vextract_gen_code(self, vextract_obj):
        """
        vextract gen code

        Parameters
        ----------
        vextract_obj: vextract object

        Returns
        -------
        None
        """
        config = [vextract_obj.repeat_times, vextract_obj.mode_number]
        # extracts 16 region proposals coordination,
        # and merge result into one 32B, each result occupies dtype_size Byte
        # 8 elements/proposal, dtype_size
        dst_extent = Expr(vextract_obj.repeat_times * 16 * DTYPE_SIZE[vextract_obj.dst.dtype])
        src_extent = Expr(vextract_obj.repeat_times * 16 * 8 * DTYPE_SIZE[vextract_obj.src.dtype])
        with self.new_scope():
            instr = tvm.call_extern(vextract_obj.dst.dtype, "vextract",
                                    vextract_obj.dst.access_ptr("w", extent=dst_extent.get()),
                                    vextract_obj.src.access_ptr("r", extent=src_extent.get()),
                                    *type_convert(config))
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.emit(instr)

    # special intrin of NMS
    @source_info_decorator()
    def vconcat(self, dst, src, repeat_times, mode_number):
        """
        Contrary to vextract, the elements are merged into the
        corresponding position of the proposal

        Parameters
        ----------
        dst:destination tensor
        src:source tensor
        mode_number: 0: x1, 1: y1, 2: x2, 3: y2, 4: score, 5:label
        repeat_times:[1,255]

        Returns
        -------
        None
        """
        min_mode_value = 0
        # check dst tensor and scope
        TikCheckUtil.check_type_match(dst, Tensor,
                                      "dst should be tensor, input type: %s" % type(dst))
        TikCheckUtil.check_equality(
            dst.scope, scope_ubuf, "dst's scope must be UB, input scope: %s" % dst.scope)
        # check src tensor and scope
        TikCheckUtil.check_type_match(
            src, Tensor, "src should be tensor, input type: %s" % type(src))
        TikCheckUtil.check_equality(
            src.scope, scope_ubuf, "src's scope must be UB, input scope: %s" % src.scope)
        # check UB address 32B align
        check_address_align((dst, src), ("dst", "src"))
        # check repeat_times
        check_repeat_times(repeat_times)
        TikCheckUtil.check_type_match(
            mode_number, (int, Scalar, Expr),
            "mode_number should be int, Scalar or Expr, input type: %s" % type(mode_number))
        check_scalar_dtype(mode_number,
                           "scalar_mode_number should be a scalar of int/uint")
        if TikSocManager.is_mini_soc():
            TikCheckUtil.check_in_range_by_dtype(
                mode_number, msg="mode_number should be in the range of [%d, %d], input value is %s"
                % (min_mode_value, MAX_MODE_NUMBER, str(mode_number)), var_range=[min_mode_value, MAX_MODE_NUMBER])
        else:
            TikCheckUtil.check_in_range_by_dtype(
                mode_number, msg="mode_number should be in the range of [%d, %d], input value is %s"
                % (MIN_MODE_NUMBER, MAX_MODE_NUMBER, str(mode_number)), var_range=[MIN_MODE_NUMBER, MAX_MODE_NUMBER])
        # check dtype
        TikCheckUtil.check_equality(dst.dtype, src.dtype,
                                    "Instruction vconcat's src's dtype should be equal to dst's dtype")
        TikCheckUtil.check_equality(intrinsic_check_support("Intrinsic_" + "vconcat", dst.dtype), True,
                                    gen_api_check_statement(dst.dtype, "vconcat"))
        # check tensor overflow
        check_special_intrin_func_overflow("vconcat", dst, [src], repeat_times)
        # code gen
        vconcat_obj = TikProposalApi.proposal_api(dst, src, repeat_times, mode_number)
        self.vconcat_gen_code(vconcat_obj)

    @vconcate_decorator
    def vconcat_gen_code(self, vconcat_obj):
        """
        vconcat gen code

        Parameters
        ----------
        vconcat_obj: vconcat object

        Returns
        -------
        None
        """
        config = [vconcat_obj.repeat_times, vconcat_obj.mode_number]
        # splits 16 numbers into 16 region proposals
        # 8 elements/proposal, dtype_size
        src_extent = Expr(vconcat_obj.repeat_times*16*DTYPE_SIZE[vconcat_obj.src.dtype])
        dst_extent = Expr(vconcat_obj.repeat_times*16*8*DTYPE_SIZE[vconcat_obj.dst.dtype])
        with self.new_scope():
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            instr = tvm.call_extern(vconcat_obj.dst.dtype, "vconcat",
                                    vconcat_obj.dst.access_ptr("w", extent=dst_extent.get()),
                                    vconcat_obj.src.access_ptr("r", extent=src_extent.get()),
                                    *type_convert(config))
            self.emit(instr)

    @source_info_decorator()
    def vmrgsort4(self, dst, src_list, element_lengths, if_exhausted_suspension, valid_bit,
                  repeat_times=1, vms4_sr_scalar_array=None):
        """
        Arrange and merge multiple (up to four) proposal queues that have been queued into one queue

        Parameters
        ----------
        dst : destination operation
        src_list : source operation list
        element_lengths : length of the proposal list
        if_exhausted_suspension : 0 not stop, 1 stop
        valid_bit : 0011 two lines are valid
        -           0111 three lines are valid
        -           1111 four lines are valid
        repeat_times: times of invoke this instrction
        vms4_sr_scalar_array: list consist of 4 scalar, as a return value

        Returns
        -------
        None or scalar_list
        """
        # check dtype
        check_tensor_and_scope(dst)
        # get address align and check
        align = get_vms4_addr_align(dst)
        check_address_align((dst,), ("dst",), align)
        # check src_list type, scope, dtype
        check_tensor_list([src_list], ["src_list"], align)
        # check src_list
        check_vms4_src_list(src_list)
        # src_list dtype are same, choose src_list[0].dtype as src_dtype
        check_vms_vms4_dtype(dst, src_list, "vmrgsort4", "vmrgsort4")
        # check element_lengths
        element_lengths = check_element_lengths(element_lengths, src_list, SRC_LIST_LEN)

        for index in range(len(src_list)):
            TikCheckUtil.check_in_range_by_dtype(
                element_lengths[index], msg="element_lengths[%s] should be in the range of [%d, %d]"
                % (index, 0, MAX_ELEMENTS_LEN), var_range=[0, MAX_ELEMENTS_LEN])
        # check valid_bit
        TikCheckUtil.check_type_match(valid_bit, (int, str, Scalar),
            "valid_bit should be int or str or Scalar, input type of valid_bit: %s" % type(valid_bit))
        check_scalar_dtype(valid_bit, "scalar_valid_bit should be a scalar of int/uint")
        if not isinstance(valid_bit, Scalar):
            if isinstance(valid_bit, str):
                # binary dtype -> int dtype
                valid_bit = int(valid_bit, 2)
            if TikSocManager.is_v100_soc():
                TikCheckUtil.check_var_in_list(
                    valid_bit, VALID_BIT_TUPLE, "valid bits only support 1111, 0111 or 0011 // binary, "
                    "input valid bits: %s // decimal" % valid_bit)
            TikCheckUtil.check_var_in_list(
                valid_bit, VALID_BIT_TUPLE_V200, "valid bits only support 1111, 0111, 0011 or 0001 // binary, "
                "input valid_bit: %s // decimal" % valid_bit)
        # check if_exhausted_suspension
        TikCheckUtil.check_type_match(
            if_exhausted_suspension, bool, "if_exhausted_suspension should be bool, input type of "
            "if_exhausted_suspension: %s" % type(if_exhausted_suspension))

        # check repeat_times
        check_repeat_times(repeat_times)
        check_vms4_repeat_times(repeat_times, element_lengths, valid_bit, if_exhausted_suspension)

        # 1 need suspend; 0 don't need suspend
        exh_susp_number = 1 if if_exhausted_suspension else 0

        # check tensor overflow
        check_vms4_src_tensor_overflow(src_list, element_lengths, valid_bit, repeat_times, if_exhausted_suspension)
        check_vms4_dst_tensor_overflow(dst, element_lengths, valid_bit, repeat_times, if_exhausted_suspension)
        # check tensor overlapping
        check_vms4_tensor_overlap(dst, src_list, element_lengths, valid_bit, repeat_times)
        # element_lengths has four proposal, 0-3 is idx of four proposal
        # gen code
        vmrgsort4_obj = TikProposalApi.vmrgsort4_api(dst, src_list, element_lengths, if_exhausted_suspension,
                                                     valid_bit, repeat_times, vms4_sr_scalar_array, exh_susp_number)
        return self.vmrgsort4_gen_code(vmrgsort4_obj)

    @vms_decarator
    def vmrgsort4_gen_code(self, vmrgsort4_obj):
        """
        vmrgsort4 gen code

        Parameters
        ----------
        vmrgsort4_obj: vmrgsort4 object

        Returns
        -------
        None
        """
        reg = None
        params = [vmrgsort4_obj.repeat_times, vmrgsort4_obj.element_count_list[0], vmrgsort4_obj.element_count_list[1],
                  vmrgsort4_obj.element_count_list[2], vmrgsort4_obj.element_count_list[3],
                  vmrgsort4_obj.exh_susp_number, vmrgsort4_obj.valid_bit]
        self._generate_code_vmrgsort4(params, vmrgsort4_obj.dst, vmrgsort4_obj.src_list)
        # read vms4_sr
        if vmrgsort4_obj.vms4_sr_scalar_array is None:
            reg = VMS4_SR
            return reg
        check_scalar_array_and_suspension(vmrgsort4_obj.vms4_sr_scalar_array, vmrgsort4_obj.if_exhausted_suspension)
        with self.new_scope():
            scalar_tmp = self.scalar_("int64", init_value=0)
            self.emit(tvm.call_extern(scalar_tmp.dtype, "reg_set", scalar_tmp.get(),
                                      tvm.call_extern(scalar_tmp.dtype, "get_vms4_sr")))
            # vms4_sr_scalar_array has four scalar element,
            # 0-3 is idx of scalar array
            with self.context.freeze():
                vmrgsort4_obj.vms4_sr_scalar_array[3].set_as((scalar_tmp >> VMS4_REGION_LIST0_POS) &
                                                             VMS4_REG_BIT_ALL_ONE)
                vmrgsort4_obj.vms4_sr_scalar_array[2].set_as((scalar_tmp >> VMS4_REGION_LIST1_POS) &
                                                             VMS4_REG_BIT_ALL_ONE)
                vmrgsort4_obj.vms4_sr_scalar_array[1].set_as((scalar_tmp >> VMS4_REGION_LIST2_POS) &
                                                             VMS4_REG_BIT_ALL_ONE)
                vmrgsort4_obj.vms4_sr_scalar_array[0].set_as(scalar_tmp & VMS4_REG_BIT_ALL_ONE)

        return reg

    @source_info_decorator()
    def vmrgsort(self, dst, src_list, element_count_list, if_exhausted_suspension,
                 repeat_times=1, vms4_sr_scalar_array=None):
        """
        Arrange and merge multiple (up to four) proposal queues that have been queued into one queue

        Parameters
        ----------
        dst : destination operation
        src_list : source operation list
        element_count_list : length of the proposal list
        if_exhausted_suspension : 0 not stop, 1 stop
        repeat_times: times of invoke this instrction
        vms4_sr_scalar_array: list consist of 4 scalar, as a return value

        Returns
        -------
        None or scalar_list
        """
        # check dst type, scope, dtype, align
        check_tensor_and_scope(dst)
        check_address_align((dst,), ("dst",), TikProposalApi.align_dst)
        # check src_list type, scope, dtype, align
        check_tensor_list([src_list], ["src_list"], TikProposalApi.align_src)
        # check src_list
        check_vms_src_list(src_list)
        # src_list dtype are same, choose src_list[0].dtype as src_dtype
        check_vms_vms4_dtype(dst, src_list, "vmrgsort4v2", "vmrgsort")
        # check element_lengths
        element_count_list = check_element_lengths(element_count_list, src_list, len(src_list))
        for index in range(len(src_list)):
            check_scalar_dtype(element_count_list[index],
                               "element_count_list[%s] should be a Scalar or Expr of int/uint" % index)
            TikCheckUtil.check_in_range_by_dtype(
                element_count_list[index], msg="element_count[%s] should be in the range of [%d, %d]"
                % (index, 0, MAX_ELEMENTS_LEN_V2), var_range=[0, MAX_ELEMENTS_LEN_V2])

        # check if_exhausted_suspension
        TikCheckUtil.check_type_match(
            if_exhausted_suspension, bool, "if_exhausted_suspension should be bool, input type of "
            "if_exhausted_suspension: %s" % type(if_exhausted_suspension))
        # check repeat_times
        check_repeat_times(repeat_times)
        check_vms4v2_repeat_times(repeat_times, element_count_list, if_exhausted_suspension)

        # 1 need suspend; 0 don't need suspend
        exh_susp_number = 1 if if_exhausted_suspension else 0

        # check tensor overflow
        check_vms4v2_src_tensor_overflow(src_list, element_count_list, repeat_times, if_exhausted_suspension)
        check_vms4v2_dst_tensor_overflow(dst, element_count_list, repeat_times, if_exhausted_suspension)
        # check tensor overlapping
        check_vms4v2_tensor_overlap(dst, src_list, element_count_list, repeat_times)
        # element_count_list has four proposal, 0-3 is idx of four proposal
        valid_bit = [0, 1, 3, 7, 15]
        vmrgsort_obj = TikProposalApi.vmrgsort4_api(dst, src_list, element_count_list, if_exhausted_suspension,
                                                    valid_bit, repeat_times, vms4_sr_scalar_array, exh_susp_number)
        self.vmrgort_gen_code(vmrgsort_obj)

    @vmsv2_decarator
    def vmrgort_gen_code(self, vmrgsort_obj):
        """
        vmrgort gen code

        Parameters
        ----------
        vmrgsort_obj: vmrgsort object

        Returns
        -------
        None
        """
        reg = None
        params = [vmrgsort_obj.repeat_times,
                  vmrgsort_obj.valid_bit[len(vmrgsort_obj.src_list)], vmrgsort_obj.exh_susp_number]
        self._generate_code_vmrgsort4v2(params, vmrgsort_obj.dst,
                                        vmrgsort_obj.src_list, vmrgsort_obj.element_count_list)
        # read vms4_sr
        if vmrgsort_obj.vms4_sr_scalar_array is None:
            reg = VMS4_SR
            return reg
        TikCheckUtil.check_type_match(
            vmrgsort_obj.vms4_sr_scalar_array, (list, tuple),
            "vms4_sr_scalar_array should be list or tuple, input type of "
            "vms4_sr_scalar_array: %s" % type(vmrgsort_obj.vms4_sr_scalar_array))
        TikCheckUtil.check_ge(
            len(vmrgsort_obj.vms4_sr_scalar_array), len(vmrgsort_obj.src_list),
            "length of vms4_sr_scalar_array should be equal to or greater than length of src_list, "
            "input length of vms4_sr_scalar_array: %s" % len(vmrgsort_obj.vms4_sr_scalar_array))
        if not is_basic_expr(vmrgsort_obj.vms4_sr_scalar_array):
            TikCheckUtil.raise_error("vms4_sr_scalar_array should be scalar")
        for i, vms4_sr_scalar in enumerate(vmrgsort_obj.vms4_sr_scalar_array):
            TikCheckUtil.check_var_in_list("int", vms4_sr_scalar.dtype,
                                           "vms4_sr_scalar_array[%d] should be a Scalar of int/uint." % i)
        if not vmrgsort_obj.if_exhausted_suspension:
            TikCheckUtil.raise_error("vms4_sr can't be read in non-exhausted mode.")
        with self.new_scope():
            scalar_tmp = self.scalar_("int64", init_value=0)
            self.emit(tvm.call_extern(scalar_tmp.dtype, "reg_set", scalar_tmp.get(),
                                      tvm.call_extern(scalar_tmp.dtype, "get_vms4_sr")))
            # vms4_sr_scalar_array has four scalar element,
            with self.context.freeze():
                for i, vms4_sr_scalar in enumerate(vmrgsort_obj.vms4_sr_scalar_array):
                    vms4_sr_scalar.set_as((scalar_tmp >> (i * VMS4V2_REGION_LIST_POS)) & VMS4V2_REG_BIT_ALL_ONE)
        return reg

    @source_info_decorator()
    @vms4_to_scalar_decorator
    def mov_vmrgsort4_sr_to_scalar(self, scalar_list, vms4_sr):
        """
        get finished elements of 4 lists to scalar-array.

        Parameters
        ----------
        scalar_list: a list of Scalar

        vms4_sr: tik_params's VMS4 SR

        Returns
        ----------
        the list which have 4 scalar
        """
        TikCheckUtil.check_is(vms4_sr, VMS4_SR, "Please assure the vms4_sr is the return of vmrgsort4.")
        TikCheckUtil.check_type_match(scalar_list, list, "scalar_list should be list")
        TikCheckUtil.check_equality(len(scalar_list), SCALAR_LIST_LEN, "Please specify a list of scalar of 4 elements.")
        for i in range(SCALAR_LIST_LEN):
            TikCheckUtil.check_type_match(scalar_list[i], Scalar, "scalar_list[%d] should be scalar" % i)
            TikCheckUtil.check_var_in_list("int", scalar_list[i].dtype,
                                           "scalar_list[%d] should be a Scalar of int/uint." % i)

        with self.new_scope():
            scalar_tmp = self.scalar_("int64", init_value=0)

            self.emit(tvm.call_extern(scalar_tmp.dtype, "reg_set",  scalar_tmp.get(),
                                      tvm.call_extern(scalar_tmp.dtype, "get_vms4_sr")))
            with self.context.freeze():
                scalar_list[3].set_as((scalar_tmp >> VMS4_REGION_LIST0_POS)
                                      & VMS4_REG_BIT_ALL_ONE)
                scalar_list[2].set_as((scalar_tmp >> VMS4_REGION_LIST1_POS)
                                      & VMS4_REG_BIT_ALL_ONE)
                scalar_list[1].set_as((scalar_tmp >> VMS4_REGION_LIST2_POS)
                                      & VMS4_REG_BIT_ALL_ONE)
                scalar_list[0].set_as(scalar_tmp & VMS4_REG_BIT_ALL_ONE)

    @source_info_decorator()
    @set_rpn_cor_ir_decorator
    def set_rpn_cor_ir(self, number):
        """
        Set special register variables for intermediate
        suppression vector storage

        Parameters
        ----------
        number : the set number

        Returns
        -------
        None
        """
        # check number
        TikCheckUtil.check_type_match(number, (int, Scalar), "number should be int or Scalar")
        TikCheckUtil.check_in_range_by_dtype(
            number, msg="set value should in the range of [%d, %d]" % (0, MAX_NUMBER), var_range=[0, MAX_NUMBER])
        if isinstance(number, Scalar):
            TikCheckUtil.check_equality(number.dtype, "uint16", "scalar_number should be uint16")
        with self.new_scope():
            if isinstance(number, Scalar):
                self.emit(tvm.call_extern("int64", "set_rpn_cor_ir", number.get()))
            else:
                self.emit(tvm.call_extern("int64", "set_rpn_cor_ir", number))
        return RPN_COR_IR

    @source_info_decorator()
    @set_rpn_offset_decorator
    def set_rpn_offset(self, offset, offset_dtype="float16"):
        """
        Set the offset of area and join for computing rpn_proposal

        Parameters
        ----------
        offset : offset value
        offset_dtype: offset dtype

        Returns
        -------
        None
        """
        self._rnp_offset_check(offset, offset_dtype)

        with self.new_scope():
            if isinstance(offset, Scalar):
                self.emit(tvm.call_extern(offset_dtype, "set_rpn_offset", offset.get()))
            else:
                self.emit(tvm.call_extern(offset_dtype, "set_rpn_offset", type_convert(offset, offset_dtype)))
        return RPN_OFFSET

    @source_info_decorator()
    def rpn_cor(self, src0, src1, src0_rep_stride, src1_rep_stride, repeat_times):
        """
        Find a new 16 proposal suppresion vector

        Parameters
        ----------
        src0 : source operation
        src1 : source operation
        repeat_times : Repeated iterations times
        src0_rep_stride : offset of src operator in the same block between adjacent iterations
        src1_rep_stride : offset of src operator in the same block between adjacent iterations

        Returns
        -------
        The median value of the suppression vector
        """
        # check tensor
        TikCheckUtil.check_type_match(src0, Tensor, "src0 should be tensor")
        TikCheckUtil.check_type_match(src1, Tensor, "src1 should be tensor")
        TikCheckUtil.check_equality(
            src0.dtype, 'uint16', "suppression matrix should use uint16")
        TikCheckUtil.check_equality(
            src1.dtype, 'uint16', "suppression Vector should use uint16")
        # check repeat
        check_repeat_times(repeat_times)
        # check stride
        check_vector_stride(None, [src0_rep_stride, src1_rep_stride],
                            None, MAX_REP_STRIDE_DOUBLE_BYTE, ["src0", "src1"])

        # check tensor scope
        TikCheckUtil.check_equality(
            src1.scope, scope_ubuf, "src1's scope must be UB")
        TikCheckUtil.check_equality(
            src0.scope, scope_ubuf, "src0's scope must be UB")
        # check UB address 32B align
        check_address_align((src0, src1), ("src0", "src1"))
        # gen code
        rpn_cor_obj = TikProposalApi.rpn_cor_api(src0, src1, src0_rep_stride, src1_rep_stride, repeat_times)
        return self.rpn_cor_gen_code(rpn_cor_obj)

    @rpn_cor_decorator
    def rpn_cor_gen_code(self, rpn_cor_obj):
        """
        rpn_cor gen code

        Parameters
        ----------
        rpn_cor_obj: rpn_cor object

        Returns
        -------
        RPN_COR_IR
        """
        params = [rpn_cor_obj.src0_rep_stride, rpn_cor_obj.src1_rep_stride, rpn_cor_obj.repeat_times]
        offset_list = RPN_COR_OFFSET_LIST
        segment_list = RPN_COR_SEGMENT_LIST
        config = concat_params(params, offset_list, segment_list)
        # get 16-bit suppression vector intermediate result,
        # only update RPN_COR_IR special register
        # extent: ((repeat_times - 1) * src0_rep_stride + 1) * 32Byte/Block
        src0_extent = Expr(((rpn_cor_obj.repeat_times - 1)*rpn_cor_obj.src0_rep_stride + 1)*32)
        src1_extent = Expr(((rpn_cor_obj.repeat_times - 1)*rpn_cor_obj.src1_rep_stride + 1)*32)
        with self.new_scope():
            instr = tvm.call_extern(rpn_cor_obj.src0.dtype, "rpn_cor",
                                    rpn_cor_obj.src0.reinterpret_cast_to("float16").
                                    access_ptr("r", extent=src0_extent.get()),
                                    rpn_cor_obj.src1.reinterpret_cast_to("float16").
                                    access_ptr("r", extent=src1_extent.get()),
                                    type_convert(config))
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.emit(instr)
        return RPN_COR_IR

    @source_info_decorator()
    @debug.rpn_cor_diag_decorator
    def rpn_cor_diag(self, dst, src, src_register):
        """
        Find a new 16 proposal suppresion vector

        Parameters
        ----------
        dst : destination operation
        src : source operation
        src_register : specieal register

        Returns
        -------
        The median value of the suppression vector
        """
        # check tensor
        TikCheckUtil.check_type_match(src, Tensor, "src should be tensor")
        TikCheckUtil.check_type_match(dst, Tensor, "dst should be tensor")
        TikCheckUtil.check_equality(
            src.dtype, 'uint16', "suppression matrix should use uint16")
        TikCheckUtil.check_equality(
            dst.dtype, 'uint16', "suppression Vector should use uint16")
        # check rpn_cor_ir
        TikCheckUtil.check_equality(
            src_register, RPN_COR_IR, "src_register not equal to RPN_COR_IR")
        # check tensor scope
        TikCheckUtil.check_equality(
            src.scope, scope_ubuf, "src's scope must be UB")
        TikCheckUtil.check_equality(
            dst.scope, scope_ubuf, "dst's scope must be UB")
        # check UB address 32B align
        check_address_align((dst, src), ("dst", "src"))
        # 16 elements * each elements occupies 2B
        extent = Expr(16*2)
        with self.new_scope():
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.emit(
                tvm.call_extern(
                    dst.dtype, "rpn_cor_diag",
                    dst.reinterpret_cast_to("float16").access_ptr("w", extent=extent.get()),
                    src.reinterpret_cast_to("float16").access_ptr("r", extent=extent.get())
                    ))

    @source_info_decorator()
    def vsort32(self, dst, src0, src1, repeat_times):
        """
        Sort 32 input region proposals according to the score in src0

        Parameters
        ----------
        dst:destination tensor
        src0:source tensor
        src1:source tensor
        repeat_times:[1,255]

        Returns
        -------
        None
        """
        # check dst src is UB tensor, align
        TikCheckUtil.check_type_match(
            dst, Tensor, "dst should be tensor, input type of dst: %s" % type(dst))
        TikCheckUtil.check_equality(
            dst.scope, scope_ubuf, "dst scope should be ub, input scope: %s" % dst.scope)
        TikCheckUtil.check_type_match(
            src0, Tensor, "src0 should be tensor, input type of dst: %s" % type(src0))
        TikCheckUtil.check_equality(
            src0.scope, scope_ubuf, "src0 scope should be ub, input scope: %s" % src0.scope)
        TikCheckUtil.check_type_match(
            src1, Tensor, "src1 should be tensor, input type of dst: %s" % type(src1))
        TikCheckUtil.check_equality(
            src1.scope, scope_ubuf, "src1 scope should be ub, input scope: %s" % src1.scope)
        check_address_align((dst, src0, src1), ("dst", "src0", "src1"))

        # check repeat_times
        check_repeat_times(repeat_times)

        # check dtype
        TikCheckUtil.check_equality(dst.dtype, src0.dtype,
                                    "Instruction vsort32's src0's dtype should "
                                    "be equal to dst's dtype")
        TikCheckUtil.check_equality("uint32", src1.dtype,
                                    "Instruction vsort32's src1's dtype should "
                                    "be uint32")
        TikCheckUtil.check_equality(intrinsic_check_support("Intrinsic_" +
                                                            "vbitsort32",
                                                            dst.dtype), True,
                                    gen_api_check_statement(dst.dtype,
                                                            "vsort32"))
        # check dst src tensor overflow
        # in 1 repeat, read 32 elements from src0, read 32 elements from src1.
        # write 64 elements for float32, 128 elements for float16.
        check_overflow(dst, repeat_times * 256 // DTYPE_SIZE[dst.dtype], "dst")
        check_overflow(src0, repeat_times * 32, "src0")
        check_overflow(src1, repeat_times * 32, "src1")

        # check tensor overlapping
        if dst.buffer is src0.buffer:
            check_overlapping_vsort32(dst.offset, src0.offset, repeat_times, dst.dtype)

        # code gen
        vsort32_obj = TikProposalApi.vsort32_api(dst, src0, src1, repeat_times)
        self.vsort32_gen_code(vsort32_obj)

    @vbs32_decorator
    def vsort32_gen_code(self, vsort32_obj):
        """
        vsort32 gen code

        Parameters
        ----------
        vsort32_obj: vsort32 object

        Returns
        -------
        None
        """
        instr_name = "vbitsort"
        if TikSocManager.is_v300_610l_soc():
            config = [vsort32_obj.repeat_times] + [DEFAULT_STRIDE] * 8
            instr_name = "vbs"
        else:
            config = [vsort32_obj.repeat_times]
        dst_extent = Expr(vsort32_obj.repeat_times * 32 * 8)
        src0_extent = Expr(vsort32_obj.repeat_times * 32 * DTYPE_SIZE[vsort32_obj.src0.dtype])
        src1_extent = Expr(vsort32_obj.repeat_times * 32 * DTYPE_SIZE[vsort32_obj.src1.dtype])
        with self.new_scope():
            instr = tvm.call_extern(vsort32_obj.dst.dtype, instr_name,
                                    vsort32_obj.dst.access_ptr("w", extent=dst_extent.get()),
                                    vsort32_obj.src0.access_ptr("r", extent=src0_extent.get()),
                                    vsort32_obj.src1.access_ptr("r", extent=src1_extent.get()),
                                    *type_convert(config))
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.emit(instr)

    def _generate_code_vmrgsort4v2(self, params, dst, src_list, element_count_list):
        """
        generate code

        Parameters
        ----------
        params: list of param
        dst : destination operation
        src_list : source operation list
        element_count_list : element count list

        Returns
        -------
        None
        """
        element_len = len(element_count_list)
        config = concat_params(params, VMRGSORT4V2_OFFSET_LIST, VMRGSORT4V2_SEGMENT_LIST, "uint64")
        src1 = concat_params(element_count_list, VMRGSORT4V2_SRC1_OFFSET_LIST[0: element_len],
                             VMRGSORT4V2_SRC1_SEGMENT_LIST[0: element_len], "uint64")
        addr_array_name = "addr_array_" + TikProposalApi.get_vm4_value()
        src_array = addr_array_make(self, src_list, addr_array_name)
        with self.new_scope():
            instr = tvm.tir.Evaluate(
                tvm.call_extern(dst.dtype, "vmrgsort4", dst.access_ptr("w"),
                                tvm.call_cce_pure_intrin("uint64", "tvm_cce_string_print", addr_array_name),
                                type_convert(src1), type_convert(config)))
            self.source_info.set_node_span(instr)
            instr_block = tvm.tir.stmt.SeqStmt([src_array, instr])
            self.source_info.set_node_span(instr_block)
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.scope_attr(tvm.thread_axis("cce"), "mem_access_scope",
                            tvm.call_extern("int64", "__vmrgsort4__", addr_array_name))
            self.emit(instr_block)

    def _generate_code_vmrgsort4(self, params, dst, src_list):
        """
        generate code

        Parameters
        ----------
        params: list of param
        dst : destination operation
        src_list : source operation list

        Returns
        -------
        None
        """
        offset_list = VMRGSORT4_OFFSET_LIST
        segment_list = VMRGSORT4_SEGMENT_LIST
        config = concat_params(params, offset_list, segment_list)
        addr_array_name = "addr_array_" + TikProposalApi.get_vm4_value()
        src_array = addr_array_make(self, src_list, addr_array_name)

        with self.new_scope():
            instr = tvm.tir.Evaluate(
                tvm.call_extern(dst.dtype, "vmrgsort4", dst.access_ptr("w"),
                                tvm.call_cce_pure_intrin("uint64", "tvm_cce_string_print", addr_array_name),
                                type_convert(config)))
            self.source_info.set_node_span(instr)
            instr_block = tvm.tir.stmt.SeqStmt([src_array, instr])
            self.source_info.set_node_span(instr_block)
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.scope_attr(tvm.thread_axis("cce"), "mem_access_scope",
                            tvm.call_extern("int64", "__vmrgsort4__", addr_array_name))
            self.emit(instr_block)
