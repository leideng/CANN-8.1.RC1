#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_mask_concat_.py
DESC:     create mask for vector instructions
CREATED:  2021-11-09 18:53:42
MODIFIED: 2021-11-09 21:29:18
"""
from collections import namedtuple
from tbe import tvm
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_expr import BasicExpr
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.util import is_immediate_number
from tbe.tik.tik_lib.tik_expr import is_basic_expr
from tbe.tik.common.util import check_imme_mask_full_mode
from tbe.tik.common.tik_get_soc_name import is_compatible_mode
from tbe.tik.tik_lib.tik_params import MASK_LEN_CONTINOUS_MODE
from tbe.tik.tik_lib.tik_params import MASK_LEN_FULL_MODE
from tbe.tik.tik_lib.tik_params import MASK_LEN_B8_MODE
from tbe.tik.tik_lib.tik_params import MIN_MASK
from tbe.tik.tik_lib.tik_params import MASK_VALUE_ZERO
from tbe.tik.tik_lib.tik_params import MAX_COUNTER_MASK
from tbe.tik.tik_lib.tik_params import BIT_LEN_16
from tbe.tik.tik_lib.tik_params import BIT_LEN_8
from tbe.tik.tik_lib.tik_params import BIT_LEN_64
from tbe.tik.tik_lib.tik_params import MAX_MASK
from tbe.tik.tik_lib.tik_params import MAX_MASK_32
from tbe.tik.tik_lib.tik_params import MAX_MASK_64
from tbe.tik.tik_lib.tik_params import MAX_MASK_256
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager

B8MaskList = namedtuple("MaskList", ["mask1", "mask2", "mask3", "mask4"])


def set_mask_imm(length, bit_len):
    """
    calculate MASK in cce

    Parameters
    ----------
    bit_len: tensor bit len
    length : int, calculate length

    Returns
    -------
    mask : tuple of int, low and high bit of mask.
    """
    if bit_len == BIT_LEN_8:
        length = int(length)
        # 192-256 bits
        mask1 = 2 ** max(length - 192, 0) - 1
        # 128-191 bits
        mask2 = 2 ** min(max(length - 128, 0), 64) - 1
        # 64-127 bits
        mask3 = 2 ** min(max(length - 64, 0), 64) - 1
        # 0-63 bits
        mask4 = 2 ** min(length, 64) - 1
        return B8MaskList(mask1, mask2, mask3, mask4)
    else:
        length = int(length)
        # high 64bits
        mask1 = 2 ** max(length - 64, 0) - 1
        # low 64bits
        mask2 = 2 ** min(length, 64) - 1
    return mask1, mask2


def _set_mask_expr_high(length_expr, tvm_one):
    length_h = tvm.tir.Max((length_expr - 64).get(), 0)

    # 96-127 bits
    shift_h1 = tvm.tir.Max((length_h - 32), 0)
    # do left shift 1 with shift_h1, then decrease 1
    mask_h1 = tvm.call_intrin("uint64", "tir.shift_left", tvm_one, shift_h1) - tvm_one

    # 64-95 bits
    shift_h2 = tvm.tir.Min(length_h, 32)
    # do left shift 1 with shift_h2, then decrease 1
    mask_h2 = tvm.call_intrin("uint64", "tir.shift_left", tvm_one, shift_h2) - tvm_one

    # create mask bits of 96-127
    mask_h1_h = tvm.call_intrin("uint64", "tir.shift_left", mask_h1, 32)

    # do mask_h1_h bit or mask_h2, create mask bits of 64-127
    mask_h = tvm.call_intrin("uint64", "tir.bitwise_or", mask_h1_h, mask_h2)
    return mask_h


def _set_mask_expr_low(length_expr, tvm_one):
    length_l = tvm.tir.Min(length_expr.get(), 64)

    # 32-63 bits
    shift_l1 = tvm.tir.Max((length_l - 32), 0)
    # do left shift 1 with shift_l1, then decrease 1
    mask_l1 = tvm.call_intrin("uint64", "tir.shift_left", tvm_one, shift_l1) - tvm_one

    # 0-31 bits
    shift_l2 = tvm.tir.Min(length_l, 32)
    # do left shift 1 with shift_l1, then decrease 1
    mask_l2 = tvm.call_intrin("uint64", "tir.shift_left", tvm_one, shift_l2) - tvm_one

    # create mask bits of 32-63
    mask_l1_h = tvm.call_intrin("uint64", "tir.shift_left", mask_l1, 32)
    # do mask_l1_h bit or mask_l2, create mask bits of 0-63
    mask_l = tvm.call_intrin("uint64", "tir.bitwise_or", mask_l1_h, mask_l2)
    return mask_l


def _get_mask_64(length_expr):
    """
    for example:
    Mask: 0 to 63 bits == > 2**X (X=>0-63)
    mask = (0, 0, 0, 2**X)

    Parameters
    ----------
    length_expr: expr mask value

    Returns
    -------
    mask 0-63 bit
    """
    # intercept Length from mask 0-63 bit
    mask_len_64 = tvm.tir.Min(length_expr.get(), 64)
    return _compute_mask_common(mask_len_64)


def _get_mask_64_192(length_expr, offset):
    """
    for example:
    Mask: 64 to 127 bits == > 2**X (X=>64-127) or 128 to 191 bits == > 2**X (X=>128-191)
    mask = (0, 2**X, 0, 0) or (0, 0, 2**X, 0)

    Parameters
    ----------
    length_expr: expr mask value

    Returns
    -------
    mask 64-127 bit or 128-191 bit

    """
    max_length = tvm.tir.Max((length_expr - offset).get(), 0)
    length_h = tvm.tir.Min(max_length, 64)
    return _compute_mask_common(length_h)


def _compute_mask_common(length_h):
    # intercept Length from mask 32-63 bit
    shift_h1 = tvm.tir.Max((length_h - 32), 0)
    mask_h1 = tvm.call_intrin("uint64", "tir.shift_left", 1, shift_h1) - 1
    # intercept Length from mask 0-31 bit
    shift_h2 = tvm.tir.Min(length_h, 32)
    mask_h2 = tvm.call_intrin("uint64", "tir.shift_left", 1, shift_h2) - 1
    mask_h1_h = tvm.call_intrin("uint64", "tir.shift_left", mask_h1, 32)
    return tvm.call_intrin("uint64", "tir.bitwise_or", mask_h1_h, mask_h2)


def _get_mask_192(length_expr):
    """
    for example:
    Mask: 192 to 255 bits == > 2**X (X=>192-255)
    mask = (2**X, 0, 0, 0)

    Parameters
    ----------
    length_expr: expr mask value

    Returns
    -------
    mask 192-255 bit
    """
    length_h = tvm.tir.Max((length_expr - 192).get(), 0)
    return _compute_mask_common(length_h)


def set_b8_mask_expr(length):
    """
    calculate MASK in cce

    Parameters
    ----------
    length : Expr, calculate length

    Returns
    -------
    mask : tuple of _expr.Call node, [high, low] bit of mask.
    """
    length_expr = Expr(length, "int64")
    # scalar mask 192-255
    mask1 = _get_mask_192(length_expr)
    # scalar mask 128-191
    mask2 = _get_mask_64_192(length_expr, 128)
    # scalar mask 64-127
    mask3 = _get_mask_64_192(length_expr, 64)
    # scalar mask 0-63
    mask4 = _get_mask_64(length_expr)
    return B8MaskList(mask1, mask2, mask3, mask4)


def set_mask_expr(length, tensor_bit_len):
    """
    calculate MASK in cce

    Parameters
    ----------
    tensor_bit_len
    length : Expr, calculate length

    Returns
    -------
    mask : tuple of _expr.Call node, [high, low] bit of mask.
    """
    if tensor_bit_len == BIT_LEN_8:
        return set_b8_mask_expr(length)
    length = Expr(length, "int64")
    tvm_one = tvm.const(1, "uint64")
    mask_h = _set_mask_expr_high(length, tvm_one)
    mask_l = _set_mask_expr_low(length, tvm_one)

    return mask_h, mask_l


def mask_concat(tik, mask, mask_mode="normal", tensor_bit_len=BIT_LEN_16):
    """
    concat mask
    """
    with tik.context.freeze():
        ret = create_vec_mask(tik, mask, mask_mode, tensor_bit_len)
    return ret


def create_vec_mask(tik_instance, mask, mask_mode="normal", tensor_bit_len=BIT_LEN_16):
    """
    Create mask for vector instructions
    Parameters
    ----------
    tik_instance: Tik object
    mask: mask value of input
    mask_mode: "normal" or "counter"
    tensor_bit_len: dtype bit length

    Returns
    -------
    high 64bits mask value, low 64bits mask value

    """
    # mask mode is counter
    if is_compatible_mode():
        max_mask_b16 = MAX_MASK
        max_mask_b32 = MAX_MASK_64
    else:
        # In non-compatible mode, the mask register is only half of that in compatible mode.
        max_mask_b16 = MAX_MASK // 2
        max_mask_b32 = MAX_MASK_64 // 2
    if mask_mode == "counter":
        return _mask_concat_counter_mode(tik_instance, mask)

    # mask mode is normal
    if not isinstance(mask, (list, tuple)):
        mask = [mask]
    # continous mode
    if len(mask) == MASK_LEN_CONTINOUS_MODE and is_basic_expr(mask):
        # check mask
        for msk in mask:
            check_scalar_dtype(msk, "scalar_mask should be a scalar of int/uint")
        return [mask for mask in set_mask_expr(mask[0], tensor_bit_len)]
    if len(mask) == MASK_LEN_CONTINOUS_MODE and is_immediate_number(mask):
        # check mask
        for msk in mask:
            TikCheckUtil.check_type_match(msk, int, "mask should be int, input type is %s" % type(msk))
        # for immediate mask, value should  be in range of [1,128], b16
        if tensor_bit_len == BIT_LEN_16:
            TikCheckUtil.check_in_range_by_dtype(
                mask[0], msg="mask value should be in the range of [%d, %d] for b16 tensor, input mask: %s"
                % (MIN_MASK, max_mask_b16, mask[0]), var_range=[MIN_MASK, max_mask_b16])
        elif tensor_bit_len == BIT_LEN_8:
            TikCheckUtil.check_in_range_by_dtype(
                mask[0], msg="mask value should be in the range of [%d, %d] for b8 tensor, input mask: %s"
                             % (MIN_MASK, MAX_MASK_256, mask[0]), var_range=[MIN_MASK, MAX_MASK_256])
        elif tensor_bit_len == BIT_LEN_64:
            TikCheckUtil.check_in_range_by_dtype(
                mask[0], msg="mask value should be in the range of [%d, %d] for b64 tensor, input mask: %s"
                             % (MIN_MASK, MAX_MASK_32, mask[0]), var_range=[MIN_MASK, MAX_MASK_32])
        # check b32 is in [1, 64]
        else:
            TikCheckUtil.check_in_range_by_dtype(
                mask[0], msg="mask value should be in the range of [%d, %d] for b32 tensor, input mask: %s"
                % (MIN_MASK, max_mask_b32, mask[0]), var_range=[MIN_MASK, max_mask_b32])
        return type_convert(set_mask_imm(mask[0], tensor_bit_len), "uint64")
    # full mode and others
    return _mask_concat_normal_full_mode_and_other(mask, tensor_bit_len)


def _mask_concat_counter_mode(tik_instance, mask):
    TikCheckUtil.check_type_match(
        mask, (int, BasicExpr),
        "In counter mode, mask should be int, Expr or Scalar, input type of mask: %s" % type(mask))
    check_scalar_dtype(mask, "scalar_mask should be a scalar of int/uint")
    if isinstance(mask, int):
        TikCheckUtil.check_in_range_by_dtype(
            mask, msg="In counter_mode, mask value should be in the range of [%d, %d], input mask: %d"
            % (MIN_MASK, MAX_COUNTER_MASK, mask), var_range=[MIN_MASK, MAX_COUNTER_MASK])
        return type_convert([0, mask], "uint64")
    mask_h = tik_instance.scalar_(dtype="uint64", init_value=MASK_VALUE_ZERO)
    return type_convert([mask_h.get(), mask.get()], "uint64")


def _mask_concat_normal_full_mode_and_other(mask, tensor_bit_len):
    if len(mask) == MASK_LEN_B8_MODE and tensor_bit_len != BIT_LEN_8:
        TikCheckUtil.raise_error("only b8 tensor support mask list len equals 4")
    if len(mask) == MASK_LEN_FULL_MODE and is_basic_expr(mask):
        for msk in mask:
            check_scalar_dtype(msk, "scalar_mask should be a scalar of int/uint")
        return type_convert(mask, "uint64")
    if len(mask) == MASK_LEN_FULL_MODE and is_immediate_number(mask):
        # check mask
        check_imme_mask_full_mode(mask, tensor_bit_len)
        return type_convert(mask, "uint64")
    if len(mask) == MASK_LEN_B8_MODE and is_immediate_number(mask):
        check_imme_mask_full_mode(mask, tensor_bit_len)
        return type_convert(mask, "uint64")
    if len(mask) == MASK_LEN_B8_MODE and is_basic_expr(mask):
        for msk in mask:
            check_scalar_dtype(msk, "scalar_mask should be a scalar of int/uint")
        return type_convert(mask, "uint64")
    # others
    return TikCheckUtil.raise_error("not support this type of mask now")
