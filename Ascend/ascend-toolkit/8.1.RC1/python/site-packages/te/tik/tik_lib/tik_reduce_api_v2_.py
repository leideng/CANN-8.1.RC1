#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_reduce_api_v2_.py
DESC:     provide reduce vector instructions
CREATED:  2019-08-16 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""
from tbe.common.platform import scope_ubuf
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.common_util import check_vector_stride
from tbe.tik.tik_lib.tik_api_util import check_repeat_times
from tbe.tik.tik_lib.tik_api_util import check_mask_mode
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.tik_lib.tik_params import MAX_BLK_STRIDE_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_REP_STRIDE_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import MIN_SRC1_PATTERN
from tbe.tik.tik_lib.tik_params import MAX_SRC1_PATTERN
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_TIMES
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_check_util import print_error_msg
from tbe.tik.common.common_util import check_address_align
from tbe.tik.common.common_util import vec_template_align
from tbe.tik.tik_lib.tik_vec_check_dst_src import check_one_dst_one_src_params
from tbe.tik.tik_lib.tik_params import PRINT_SCOPE_MAP
from tbe.tik.tik_lib.tik_params import MIN_MASK
from tbe.tik.tik_lib.tik_params import MAX_COUNTER_MASK


def _check_vreduce_src1(src1_pattern, max_src1_pattern, isdebug=False):
    # check src1_pattern
    if not isdebug:
        TikCheckUtil.check_type_match(src1_pattern, (int, Tensor, Scalar),
                                      "src_pattern should be int, Tensor or Scalar")
        check_scalar_dtype(src1_pattern, "When src1_pattern is scalar, it should be dtype of int/uint")
    TikCheckUtil.check_in_range_by_dtype(
        src1_pattern, msg="When src1_pattern is immediate, it should be in the range of [%d, %d], "
        "but input src1_pattern: %s" % (MIN_SRC1_PATTERN, max_src1_pattern, src1_pattern),
        var_range=[MIN_SRC1_PATTERN, max_src1_pattern])


def _check_src1_tensor_info(src1_pattern, dst_dtype):
    TikCheckUtil.check_equality(src1_pattern.scope, scope_ubuf,
                                "src1_pattern scope should be scope_ubuf, but input src1_pattern "
                                "scope: %s" % PRINT_SCOPE_MAP[src1_pattern.scope])
    # check UB address 32B align
    align = vec_template_align(src1_pattern.dtype)
    check_address_align((src1_pattern,), ("src1_pattern",), align)

    if dst_dtype in ("float16", "int16", "uint16"):
        TikCheckUtil.check_equality(
            src1_pattern.dtype, "uint16",
            "When dst dtype is %s, src1 dtype should be uint16, "
            "but input src1 dtype: %s" % (dst_dtype, src1_pattern.dtype))
    elif dst_dtype in ("uint8", "int8"):
        TikCheckUtil.check_equality(
            src1_pattern.dtype, "uint8",
            "When dst dtype is %s, src1 dtype should be uint8, "
            "but input src1 dtype: %s" % (dst_dtype, src1_pattern.dtype))
    else:
        TikCheckUtil.check_equality(
            src1_pattern.dtype, "uint32",
            "When dst dtype is %s, src1 dtype should be uint32, "
            "but input src1 dtype: %s" % (dst_dtype, src1_pattern.dtype))


def _check_mask(mask, isdebug=False):
    if not isdebug:
        TikCheckUtil.check_type_match(
            mask, (int, Expr, Scalar),
            "In counter mode, mask should be int, Expr or Scalar, but input type of mask: %s" % type(mask))
        check_scalar_dtype(mask, "scalar_mask should be a scalar of int/uint")
    if isinstance(mask, int):
        TikCheckUtil.check_in_range_by_dtype(
            mask, msg="In counter_mode, mask value should be in the range of [%d, %d], input mask: %d"
                      % (MIN_MASK, MAX_COUNTER_MASK, mask), var_range=[MIN_MASK, MAX_COUNTER_MASK])


def vreduce_tensor_check(api_name, input_params, is_reducev2=False):
    """
    vreduce's tensor check

    Parameters
    ----------
    api_name : api's name
    input_params : params list
    is_reducev2: whether check for api vreducev2

    Returns
    -------
    None
    """
    mask, dst, src0, src1_pattern, src1_rep_stride, rsvd_scalar, mask_mode = input_params

    # check dst src
    check_one_dst_one_src_params((api_name, dst, src0), src_name="src0")
    if isinstance(src1_pattern, Tensor):
        _check_src1_tensor_info(src1_pattern, dst.dtype)

    # check mask, mask_mode
    check_mask_mode(mask_mode)
    if is_reducev2:
        if mask_mode == "counter":  # for vreducev2, if mask mode is "counter", src1_pattern must be Tensor
            TikCheckUtil.check_type_match(src1_pattern, Tensor,
                                          "When mask_mode is 'counter', src1_pattern must be Tensor")
        else:  # for vreducev2, if mask mode is "normal", mask must be set to None
            TikCheckUtil.check_is(mask, None, "When mask_mode is 'normal', mask must be set to None")
            if not isinstance(src1_pattern, Tensor):
                if isinstance(src1_rep_stride, int):
                    TikCheckUtil.check_equality(src1_rep_stride, 0,
                                                "When mask_node is 'normal' and src1_pattern is special pattern, "
                                                "src1_rep_stride must be set to 0")
                else:
                    print_error_msg("When mask_node is 'normal' and src1_pattern is special pattern, "
                                    "src1_rep_stride must be set to 0")
    # check rsvd_scalar
    if rsvd_scalar is not None:
        TikCheckUtil.check_type_match(
            rsvd_scalar, Scalar,
            "rsvd_scalar should be None or Scalar, but input type of rsvd_scalar: %s" % type(rsvd_scalar))
        TikCheckUtil.check_equality(
            rsvd_scalar.dtype, "uint32",
            "rsvd_scalar dtype should be uint32, input rsvd_scalar dtype: %s" % rsvd_scalar.dtype)


def vreduce_param_check(input_params, max_repeat_times=MAX_REPEAT_TIMES,
                        max_repeat_stride=MAX_REP_STRIDE_SINGLE_BYTE, max_pattern=MAX_SRC1_PATTERN, isdebug=False):
    """
    vreduce's tensor check

    Parameters
    ----------
    input_params : params list
    max_repeat_times : max repeat times
    max_repeat_stride : max repeat stride
    max_pattern : max pattern
    isdebug : if in debug mode

    Returns
    -------
    None
    """
    mask, src1_pattern, repeat_times, src0_blk_stride, src0_rep_stride, \
        src1_rep_stride, mask_mode, api_name = input_params
    # check src1_pattern
    _check_vreduce_src1(src1_pattern, max_pattern, isdebug)

    # check mask, mask_mode
    if mask_mode == "counter":
        _check_mask(mask, isdebug)

    # check repeat_times
    # when the mask mode of vreduce is counter, repeat_time is invalid, the repeat_time does not need to be checked
    # when the mask mode of vreducev2 is counter, repeat_time is valid, repeat_time needs to be checked
    if not (mask_mode == "counter" and api_name == "vreduce"):
        check_repeat_times(repeat_times, max_repeat_times, isdebug, mask_mode)
    # check strides
    check_vector_stride([src0_blk_stride], None, MAX_BLK_STRIDE_SINGLE_BYTE, None, ["src0"])
    check_vector_stride(None, [src0_rep_stride, src1_rep_stride],
                        None, max_repeat_stride, ["src0", "src1"])
