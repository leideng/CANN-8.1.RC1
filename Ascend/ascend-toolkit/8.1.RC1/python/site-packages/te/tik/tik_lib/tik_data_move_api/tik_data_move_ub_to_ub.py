#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_data_move_ub_to_ub.py
DESC:     data move vector core ub to ub common function
CREATED:  2022-02-18 10:17
MODIFIED: 2022-02-18 10:17
"""
from tbe.tik.api.tik_logic_compute import all as tik_all
from tbe.tik.api.tik_logic_compute import any as tik_any
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.debug.decorators import high_level_api_debug_decorator
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_TIMES
from tbe.tik.tik_lib.tik_params import BLK_NUM_PER_REP

# blk num per rep * max rep times
_MAX_REP_BLK_NUM = 2040


def get_consecutive_vadds_count(data_move_ins, burst, nburst):
    """
    ub_data_move_vadds_consecutive function's vadds instruction count number
    Parameters
    ----------
    data_move_ins: data move class instance
    burst: burst
    nburst: nburst

    Returns
    -------

    """
    add_call_count = data_move_ins.tik_instance.scalar_(init_value=0, dtype="uint64")
    full_rep = burst // _MAX_REP_BLK_NUM
    full_left = burst % _MAX_REP_BLK_NUM
    rep = full_left // BLK_NUM_PER_REP
    left = full_left % BLK_NUM_PER_REP
    with data_move_ins.tik_instance.if_scope(tik_all(rep > 0, left > 0)):
        add_call_count += nburst * (full_rep + 2)
    with data_move_ins.tik_instance.elif_scope(tik_any(rep > 0, left > 0)):
        add_call_count += nburst * (full_rep + 1)
    with data_move_ins.tik_instance.else_scope():
        add_call_count += nburst * full_rep

    return add_call_count


def get_cross_vadds_count(data_move_ins, burst, nburst):
    """
    ub_data_move_vadds_cross function's vadds instruction count number
    Parameters
    ----------
    data_move_ins: data move class instance
    burst: burst
    nburst: nburst

    Returns
    -------

    """
    add_call_count = data_move_ins.tik_instance.scalar_(init_value=0, dtype="uint64")
    full_rep = nburst // MAX_REPEAT_TIMES
    full_left = nburst % MAX_REPEAT_TIMES
    rep = burst // BLK_NUM_PER_REP
    left = burst % BLK_NUM_PER_REP
    with data_move_ins.tik_instance.if_scope(full_left > 0):
        add_call_count += rep * (full_rep + 1)
    with data_move_ins.tik_instance.else_scope():
        add_call_count += rep * full_rep
    with data_move_ins.tik_instance.if_scope(left > 0):
        with data_move_ins.tik_instance.if_scope(full_left > 0):
            add_call_count += (full_rep + 1)
        with data_move_ins.tik_instance.else_scope():
            add_call_count += full_rep

    return add_call_count


def ub_data_move_burst_eq_1_or_2(data_move_ins, src_burst_rep_stride, dst_burst_rep_stride, per_block_elem_num, mask):
    """
    data move ub to ub when burst equals 1 or 2
    Parameters
    ----------
    mask: mask
    per_block_elem_num: per block elements number
    dst_burst_rep_stride: the sums of burst and dst stride
    src_burst_rep_stride: the sums of burst and src stride
    data_move_ins: data move instance

    Returns
    -------

    """

    with data_move_ins.tik_instance.for_range(0, data_move_ins.burst) as per_blk_index:
        full_rep = data_move_ins.nburst // BLK_NUM_PER_REP // MAX_REPEAT_TIMES
        max_src_rep_offset = src_burst_rep_stride * _MAX_REP_BLK_NUM * per_block_elem_num
        max_dst_rep_offset = dst_burst_rep_stride * _MAX_REP_BLK_NUM * per_block_elem_num
        with data_move_ins.tik_instance.for_range(0, full_rep) as i:
            src_offset_start = i * max_src_rep_offset + per_blk_index * per_block_elem_num
            dst_offset_start = i * max_dst_rep_offset + per_blk_index * per_block_elem_num
            data_move_ins.tik_instance.vadds(mask, data_move_ins.dst[dst_offset_start],
                                             data_move_ins.src[src_offset_start],
                                             0, MAX_REPEAT_TIMES, dst_burst_rep_stride, src_burst_rep_stride,
                                             8 * dst_burst_rep_stride,
                                             8 * src_burst_rep_stride)
        rep = data_move_ins.nburst // BLK_NUM_PER_REP % MAX_REPEAT_TIMES
        left = data_move_ins.nburst % BLK_NUM_PER_REP % MAX_REPEAT_TIMES
        with data_move_ins.tik_instance.if_scope(rep > 0):
            src_offset_start = full_rep * max_src_rep_offset + per_blk_index * per_block_elem_num
            dst_offset_start = full_rep * max_dst_rep_offset + per_blk_index * per_block_elem_num
            data_move_ins.tik_instance.vadds(mask, data_move_ins.dst[dst_offset_start],
                                             data_move_ins.src[src_offset_start],
                                             0, rep, dst_burst_rep_stride, src_burst_rep_stride,
                                             8 * dst_burst_rep_stride,
                                             8 * src_burst_rep_stride)
        with data_move_ins.tik_instance.if_scope(left > 0):
            src_offset_start = \
                full_rep * max_src_rep_offset + \
                rep * BLK_NUM_PER_REP * src_burst_rep_stride * per_block_elem_num + \
                per_blk_index * per_block_elem_num

            dst_offset_start = \
                full_rep * max_dst_rep_offset + \
                rep * BLK_NUM_PER_REP * dst_burst_rep_stride * per_block_elem_num + \
                per_blk_index * per_block_elem_num
            data_move_ins.tik_instance.vadds(left * per_block_elem_num,
                                             data_move_ins.dst[dst_offset_start],
                                             data_move_ins.src[src_offset_start], 0, 1,
                                             dst_burst_rep_stride, src_burst_rep_stride,
                                             8 * dst_burst_rep_stride,
                                             8 * src_burst_rep_stride)


def ub_data_move_stride_eq_0(data_move_ins, per_block_elem_num):
    """
    data move ub to ub when stride equals 0
    Parameters
    ----------
    per_block_elem_num
    data_move_ins: data move instance
    Returns
    -------

    """
    data_move_ins.tik_instance.vadds(data_move_ins.nburst * data_move_ins.burst * per_block_elem_num,
                                     data_move_ins.dst,
                                     data_move_ins.src, 0, MAX_REPEAT_TIMES,
                                     1, 1, 8, 8, mask_mode="counter")


def ub_data_move_vadds_cross(data_move_ins, src_burst_rep_stride, dst_burst_rep_stride, per_block_elem_num, mask):
    """
    data move ub to ub, cross eval vadds
    Parameters
    ----------
    mask
    per_block_elem_num: per block elements number
    dst_burst_rep_stride: the sums of burst and dst stride
    src_burst_rep_stride: the sums of burst and src stride
    data_move_ins: data move instance

    Returns
    -------

    """

    full_rep = data_move_ins.nburst // MAX_REPEAT_TIMES
    full_left = data_move_ins.nburst % MAX_REPEAT_TIMES
    rep = data_move_ins.burst // BLK_NUM_PER_REP
    left = data_move_ins.burst % BLK_NUM_PER_REP

    with data_move_ins.tik_instance.for_range(0, rep) as i:
        per_mask_offset = i * mask
        src_offset_elem_num = src_burst_rep_stride * MAX_REPEAT_TIMES * per_block_elem_num
        dst_offset_elem_num = dst_burst_rep_stride * MAX_REPEAT_TIMES * per_block_elem_num
        with data_move_ins.tik_instance.for_range(0, full_rep) as j:
            data_move_ins.tik_instance.vadds(mask, data_move_ins.dst[j * dst_offset_elem_num + per_mask_offset],
                                             data_move_ins.src[j * src_offset_elem_num + per_mask_offset],
                                             0, MAX_REPEAT_TIMES, 1, 1,
                                             dst_burst_rep_stride,
                                             src_burst_rep_stride)

        with data_move_ins.tik_instance.if_scope(full_left > 0):
            data_move_ins.tik_instance.vadds(mask,
                                             data_move_ins.dst[full_rep * dst_offset_elem_num + per_mask_offset],
                                             data_move_ins.src[full_rep * src_offset_elem_num + per_mask_offset],
                                             0, full_left, 1, 1,
                                             dst_burst_rep_stride,
                                             src_burst_rep_stride)
    with data_move_ins.tik_instance.if_scope(left > 0):
        src_offset_elem_num = src_burst_rep_stride * MAX_REPEAT_TIMES * per_block_elem_num
        dst_offset_elem_num = dst_burst_rep_stride * MAX_REPEAT_TIMES * per_block_elem_num

        with data_move_ins.tik_instance.for_range(0, full_rep) as j:
            data_move_ins.tik_instance.vadds(left * per_block_elem_num,
                                             data_move_ins.dst[j * dst_offset_elem_num + rep * mask],
                                             data_move_ins.src[j * src_offset_elem_num + rep * mask],
                                             0, MAX_REPEAT_TIMES, 1, 1,
                                             dst_burst_rep_stride,
                                             src_burst_rep_stride)

        with data_move_ins.tik_instance.if_scope(full_left > 0):
            data_move_ins.tik_instance.vadds(left * per_block_elem_num,
                                             data_move_ins.dst[full_rep * dst_offset_elem_num + rep * mask],
                                             data_move_ins.src[full_rep * src_offset_elem_num + rep * mask], 0,
                                             full_left, 1, 1,
                                             dst_burst_rep_stride,
                                             src_burst_rep_stride)


def ub_data_move_vadds_consecutive(data_move_ins, dst_burst_rep_stride, src_burst_rep_stride, per_block_elem_num):
    """
    data move ub to ub, consecutive eval vadds per burst
    Parameters
    ----------
    per_block_elem_num: per block elem num
    src_burst_rep_stride: src burst rep_stride
    dst_burst_rep_stride: dst burst rep stride
    data_move_ins: data move instance

    Returns
    -------

    """

    with data_move_ins.tik_instance.for_range(0, data_move_ins.nburst) as i:
        per_burst_src_offset = \
            i * per_block_elem_num * src_burst_rep_stride
        per_burst_dst_offset = \
            i * per_block_elem_num * dst_burst_rep_stride

        data_move_ins.tik_instance.vadds(data_move_ins.burst * per_block_elem_num,
                                         data_move_ins.dst[per_burst_dst_offset],
                                         data_move_ins.src[per_burst_src_offset],
                                         0, 1, 1, 1, 8, 8, mask_mode="counter")


def ub_data_move_nq_1_or_2(data_move_ins, dst_burst_rep_stride, src_burst_rep_stride, per_block_elem_num, mask):
    """
    eval ub_data_move_vadds_consecutive or ub_data_move_vadds_cross data move scheme
    Parameters
    ----------
    mask: mask
    per_block_elem_num: per block element num
    src_burst_rep_stride: the sums of burst and src stride
    dst_burst_rep_stride: the sums of burst and dst stride
    data_move_ins: data move instance

    Returns
    -------

    """
    with data_move_ins.tik_instance.if_scope(
            tik_any(dst_burst_rep_stride > MAX_REPEAT_TIMES, src_burst_rep_stride > MAX_REPEAT_TIMES)):
        ub_data_move_vadds_consecutive(
            data_move_ins, dst_burst_rep_stride, src_burst_rep_stride, per_block_elem_num)
    with data_move_ins.tik_instance.else_scope():
        if not (isinstance(src_burst_rep_stride, int) and isinstance(dst_burst_rep_stride, int) and
                (src_burst_rep_stride > MAX_REPEAT_TIMES or dst_burst_rep_stride > MAX_REPEAT_TIMES)):
            with data_move_ins.tik_instance.if_scope(get_consecutive_vadds_count(
                    data_move_ins, data_move_ins.burst, data_move_ins.nburst) <
                                                     get_cross_vadds_count(
                                                         data_move_ins, data_move_ins.burst, data_move_ins.nburst)):
                ub_data_move_vadds_consecutive(
                    data_move_ins, dst_burst_rep_stride, src_burst_rep_stride, per_block_elem_num)
            with data_move_ins.tik_instance.else_scope():
                ub_data_move_vadds_cross(
                    data_move_ins, src_burst_rep_stride, dst_burst_rep_stride, per_block_elem_num, mask)


def data_move_vec(tik_ins, data_move_ins):
    """
    data move when soc equals vector core and ub to ub
    Parameters
    ----------
    tik_ins: tik instance
    data_move_ins: data move instance

    Returns
    -------

    """
    per_block_elem_num = ONE_BLK_SIZE // DTYPE_SIZE.get(data_move_ins.src.dtype)
    mask = per_block_elem_num * BLK_NUM_PER_REP
    src_burst_rep_stride = data_move_ins.src_stride + data_move_ins.burst
    dst_burst_rep_stride = data_move_ins.dst_stride + data_move_ins.burst
    with tik_ins.if_scope(tik_all(data_move_ins.src_stride == 0, data_move_ins.dst_stride == 0)):
        ub_data_move_stride_eq_0(data_move_ins, per_block_elem_num)
    with tik_ins.elif_scope(tik_any(8 * src_burst_rep_stride > MAX_REPEAT_TIMES,
                                    8 * dst_burst_rep_stride > MAX_REPEAT_TIMES)):
        ub_data_move_nq_1_or_2(
            data_move_ins, dst_burst_rep_stride, src_burst_rep_stride, per_block_elem_num, mask)
    with tik_ins.else_scope():
        if not (isinstance(src_burst_rep_stride, int) and isinstance(dst_burst_rep_stride, int)
                and (8 * src_burst_rep_stride > MAX_REPEAT_TIMES or
                     8 * dst_burst_rep_stride > MAX_REPEAT_TIMES)):
            # when burst equals 1 or 2, it has good performance
            with tik_ins.if_scope(data_move_ins.burst < 3):
                ub_data_move_burst_eq_1_or_2(
                    data_move_ins, src_burst_rep_stride, dst_burst_rep_stride, per_block_elem_num, mask)
            with tik_ins.else_scope():
                ub_data_move_nq_1_or_2(
                    data_move_ins, dst_burst_rep_stride, src_burst_rep_stride, per_block_elem_num, mask)


@high_level_api_debug_decorator
def data_move_vec_ub_to_ub(tik_ins, data_move_ins):
    """
    data move when soc equals vector core and ub to ub
    Parameters
    ----------
    tik_ins: tik instance
    data_move_ins: data move instance

    Returns
    -------

    """
    dst_type = data_move_ins.dst.dtype
    src_type = data_move_ins.src.dtype
    if data_move_ins.src.dtype in ("int8", "uint8", "uint16", "uint32", "uint64", "int64", "float32"):
        data_move_ins.dst = data_move_ins.dst.reinterpret_cast_to("int32")
        data_move_ins.src = data_move_ins.src.reinterpret_cast_to("int32")
    elif data_move_ins.src.dtype in ("float16", ):
        data_move_ins.dst = data_move_ins.dst.reinterpret_cast_to("int16")
        data_move_ins.src = data_move_ins.src.reinterpret_cast_to("int16")

    # Avoid multi-layer nesting and disable_sync all is true.
    if tik_ins.stmt_scope_stack and tik_ins.stmt_scope_stack[-1][0]:
        data_move_vec(tik_ins, data_move_ins)
    else:
        with tik_ins.new_stmt_scope(disable_sync=True):
            data_move_vec(tik_ins, data_move_ins)

    if dst_type != data_move_ins.dst.dtype:
        data_move_ins.dst = data_move_ins.dst.reinterpret_cast_to(dst_type)
        data_move_ins.src = data_move_ins.src.reinterpret_cast_to(src_type)
