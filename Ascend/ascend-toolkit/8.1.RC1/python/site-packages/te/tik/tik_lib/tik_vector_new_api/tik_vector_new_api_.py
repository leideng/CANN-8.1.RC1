#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vecotr_new_api.py
DESC:     provide vector instructions
CREATED:  2020-03-10 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""
import numpy as np
from tbe import tvm
from tbe.tvm.tir import StringImm
from tbe.common.platform import intrinsic_check_support
from tbe.common.platform import scope_preg
from tbe.common.platform import scope_wreg
from tbe.common.platform import scope_areg
from tbe.tik.debug.decorators_v210 import vector_elewise_scalar_decorator
from tbe.tik.debug.decorators_v210 import vector_elewise_decroator
from tbe.tik.debug.decorators_v210 import vector_intlv_dintlv_decorator
from tbe.tik.debug.decorators_v210 import vector_reg_ele_wise_decorator
from tbe.tik.debug.decorators_v210 import vector_whole_reduce_decorator
from tbe.tik.debug.decorators_v210 import vector_single_elewise_decorator
from tbe.tik.debug.decorators_v210 import vector_vmov_decorator
from tbe.tik.debug.decorators_v210 import vector_vusqz_decorator
from tbe.tik.debug.decorators_v210 import vector_vslide_decorator
from tbe.tik.debug.decorators_v210 import vector_vselr_decorator
from tbe.tik.debug.decorators_v210 import vector_vpack_vunpack_decorator
from tbe.tik.debug.decorators_v210 import vector_vcmp_decorator
from tbe.tik.debug.decorators_v210 import vector_vcmps_decorator
from tbe.tik.debug.decorators_v210 import vector_vdupi_b8_decorator
from tbe.tik.debug.decorators_v210 import vector_vdupi_b16_decorator
from tbe.tik.debug.decorators_v210 import vector_vdups_decorator
from tbe.tik.debug.decorators_v210 import vector_vdup_decorator
from tbe.tik.debug.decorators_v210 import vector_vscatter_decorator
from tbe.tik.debug.decorators_v210 import vector_vtrc_decorator
from tbe.tik.debug.decorators_v210 import vector_vfcvt_vsfcvt_decorator
from tbe.tik.debug.decorators_v210 import fifr1_decorator
from tbe.tik.debug.decorators_v210 import vector_initial_decorator
from tbe.tik.debug.decorators_v210 import vector_vgather_decorator
from tbe.tik.debug.decorators_v210 import vector_vgatherv2_decorator
from tbe.tik.debug.decorators_v210 import vector_load_ld_decorator
from tbe.tik.debug.decorators_v210 import vector_load_unalign_decorator
from tbe.tik.debug.decorators_v210 import vector_store_unalign_decorator
from tbe.tik.debug.decorators_v210 import vector_store_unalign_sqzn_decorator
from tbe.tik.debug.decorators_v210 import vector_store_st_decorator
from tbe.tik.debug.decorators_v210 import fmax_fmin_decorator
from tbe.tik.debug.decorators_v210 import vector_vcvt_vscvt_decorator
from tbe.tik.debug.decorators_v210 import vector_vcbmax_vcbmin_decroator
from tbe.tik.debug.decorators_v210 import mvf_data_move_decorator
from tbe.tik.tik_lib.tik_check_util import print_error_msg
from tbe.tik.common.util import TikCheckUtil
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.tik_lib.tik_params import PIPE_MTE2
from tbe.tik.tik_lib.tik_params import UINT_MIN
from tbe.tik.tik_lib.tik_params import UINT8_MAX
from tbe.tik.tik_lib.tik_params import INT8_MIN
from tbe.tik.tik_lib.tik_params import INT8_MAX
from tbe.tik.tik_lib.tik_params import INT16_MIN
from tbe.tik.tik_lib.tik_params import INT16_MAX
from tbe.tik.tik_lib.tik_params import UINT16_MAX
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import DTYPE_IMM_MIN
from tbe.tik.tik_lib.tik_params import DTYPE_IMM_MAX
from tbe.tik.tik_lib.tik_util import dtype_convert
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_vector import Vector
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import check_param_is_preg
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import check_param_is_vreg
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import scalar_dtype_check
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import vrnd_scalar_check
from tbe.tik.common.util import get_instr_name_by_acc_mode
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import gen_vfcvt_param
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import gen_vcvt_param
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_new_api_inner_base import TikVectorNewApiInnerBase


class TikVectorNewApiInner(TikVectorNewApiInnerBase):
    """
    Vector, Serialization, Spr Operation Api
    """
    @fifr1_decorator
    def fifr1_gen_code(self, fifr1_params):
        """
        Generate Filtering Code
        Parameters
        ----------
        fifr1_params
        - dst: dst
        - src: src
        - window_size: Filter weight matrix size
        - line_num: Number of rows continuously operated in the horizontal direction
        - dst_stride: dst stride
        - src_stride: src stride
        - r1c1: First coefficient of row vector RC
        - r1c2: Second coefficient of row vector RC
        - r1c3: Row vector RC third coefficient
        - r1c4: Row vector RC fourth coefficient
        - r1c5: Row vector RC fifth coefficient
        - r1t: First coefficient of column vector RT
        - r2t: Second coefficient of column vector RT
        - r3t: Third coefficient of column vector RT
        - r4t: Fourth coefficient of column vector RT
        - r5t: Fifth coefficient of column vector RT
        - rsah: Right Shift Number of One-Dimensional Horizontal Filtering Results
        - rsa: Number of right shifts in the final result of filtering calculation

        Returns
        -------
        no return
        """
        type_args = [fifr1_params.window_size, fifr1_params.src_stride, fifr1_params.line_num, fifr1_params.dst_stride,
                     fifr1_params.r1c1, fifr1_params.r1c2, fifr1_params.r1c3, fifr1_params.r1c4,
                     fifr1_params.r1c5, fifr1_params.r1t, fifr1_params.r2t, fifr1_params.r3t, fifr1_params.r4t,
                     fifr1_params.r5t, fifr1_params.rsah, fifr1_params.rsa]
        instr_name = "fifr1"
        with self.new_scope():
            instr = tvm.call_extern(fifr1_params.dst.dtype, instr_name, fifr1_params.dst.access_ptr("w"),
                                    fifr1_params.src.access_ptr("r"), *type_convert(type_args))
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.emit(instr)

    @fmax_fmin_decorator
    def fmax_fmin_gen_code(self, gen_code_params):
        """
        Code generated by filtering maximum and minimum values

        Parameters
        ----------
        instr_name: instr name
        dst: dst
        src: src
        window_size: Filter weight matrix size
        line_num: Number of rows that are continuously operated in the horizontal direction.
        The data type supports immediate numbers.
        dst_stride: dst stride
        src_stride: src stride

        Returns
        -------
        no return
        """
        type_args = [gen_code_params.window_size, gen_code_params.src_stride,
                     gen_code_params.line_num, gen_code_params.dst_stride, 0, 0, 0, 0, 0]
        with self.new_scope():
            instr = tvm.call_extern(
                gen_code_params.dst.dtype, gen_code_params.instr_name, gen_code_params.dst.access_ptr("w"),
                gen_code_params.src.access_ptr("r"), *type_convert(type_args))
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.emit(instr)

    @mvf_data_move_decorator
    def data_move_gather_gen_code(self, gather_params, name, type_args):
        """
        data move gather gen code
        Parameters
        ----------
        gather_params
        name
        type_args

        Returns
        -------

        """
        with self.new_stmt_scope():
            instr = tvm.call_extern(gather_params.dst.dtype, name, gather_params.dst.access_ptr("w"),
                                    gather_params.src_index.access_ptr("r"), gather_params.src.access_ptr("r"),
                                    *type_convert(type_args))
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_MTE2)
            self.emit(instr)

    @vector_store_st_decorator
    def _vector_store_st(self, st_params):
        with self.new_scope():
            preg = self._gen_mask(st_params.mask, st_params.dst.dtype)
            with self.context.freeze():
                areg = Vector(self, dtype="int32", name='address_buf_', scope=scope_areg)
            if st_params.st_mode == 'INTLV':
                src_args = type_convert(st_params.src)
            else:
                src_args = type_convert([st_params.src])
            vst_name = "vectorized_vst"
            instr = tvm.call_extern(
                st_params.dst.dtype, vst_name, *src_args,
                st_params.dst.access_ptr("w", extent=st_params.vlen * DTYPE_SIZE[st_params.dst.dtype]),
                type_convert(areg),
                tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', StringImm(st_params.str_st_mode)),
                type_convert(preg))
            self.emit(instr)

    @vector_elewise_scalar_decorator
    def _vector_elewise_scalar_make_code(self, code_make_params, mode=None):
        """
        dst = src <op> scalar
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: scalar or imm

        Returns
        -------
        None
        """
        if code_make_params.name in ("vectorized_vshrs", "vectorized_vshls"):
            scalar_tmp = dtype_convert(code_make_params.scalar, "int16")
        else:
            scalar_tmp = dtype_convert(code_make_params.scalar, code_make_params.dst.dtype)
        with self.new_scope():
            preg = self._gen_mask(code_make_params.mask, code_make_params.dst.dtype)
            if mode is None:
                instr = tvm.call_extern(code_make_params.dst.dtype, code_make_params.name,
                                        type_convert(code_make_params.dst),
                                        type_convert(code_make_params.src), scalar_tmp, type_convert(preg))
            else:
                load_mode = StringImm(mode)
                instr = tvm.call_extern(
                    code_make_params.dst.dtype, code_make_params.name, type_convert(code_make_params.dst),
                    type_convert(code_make_params.src), scalar_tmp,
                    type_convert(preg), tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            self.emit(instr)

    def _vector_reg_scalar_single_elewise_func(self, vec_reg_params, **kwargs):
        """
        dst = src <op> scalar
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: scalar or imm
        mode: is or not MODE_MERGING
        scalar_name: scalar's name
        api_name: real name

        Returns
        -------
        None
        """
        src_name = kwargs.get("src_name")
        mode = kwargs.get("mode")
        scalar_name = kwargs.get("scalar_name")
        api_name = kwargs.get("api_name")
        if src_name is None:
            src_name = "src"
        if scalar_name is None:
            scalar_name = "scalar"

        self.check_params_obj.check_vector_one_dst_one_src_params(
            vec_reg_params.name, vec_reg_params.dst, vec_reg_params.src, src_name, api_name=api_name)
        if api_name is None:
            api_name = vec_reg_params.name.replace("vectorized_", "vector_")
        # check scalar
        if api_name == "vector_vrnd":
            vrnd_scalar_check(api_name, scalar_name, "uint16", vec_reg_params.scalar)
        else:
            TikCheckUtil.check_type_match(
                vec_reg_params.scalar, (float, Expr, Scalar),
                "Instruction %s's %s should be float, Expr or Scalar, "
                "input type of %s: %s" % (api_name, scalar_name, scalar_name, type(vec_reg_params.scalar)))
            scalar_dtype_check(api_name, scalar_name, vec_reg_params.dst.dtype, vec_reg_params.scalar)
        self._vector_elewise_scalar_make_code(vec_reg_params, mode)

    @vector_whole_reduce_decorator
    def _vector_reg_whole_reduce_func(self, vec_reg_params, mode=None):
        """
        src is a vector, dst is vector, reduce src to dst
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation

        Returns
        -------
        None
        """
        self.check_params_obj.check_vector_one_dst_one_src_params(
            vec_reg_params.name, vec_reg_params.dst, vec_reg_params.src)
        with self.new_scope():
            preg = self._gen_mask(vec_reg_params.mask, vec_reg_params.src.dtype)
            if mode is None:
                instr = tvm.call_extern(vec_reg_params.dst.dtype, vec_reg_params.name,
                                        type_convert(vec_reg_params.dst),
                                        type_convert(vec_reg_params.src), type_convert(preg))
            else:
                load_mode = StringImm(mode)
                instr = tvm.call_extern(vec_reg_params.dst.dtype, vec_reg_params.name,
                                        type_convert(vec_reg_params.dst), type_convert(vec_reg_params.src),
                                        type_convert(preg),
                                        tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            self.emit(instr)

    @vector_vcbmax_vcbmin_decroator
    def _vector_reg_tenary_whole_reduce_func(self, vec_reg_params):
        """
        src is a vector, dst is vector, reduce src to dst
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        dst1: vector source operation
        src: vector source operation

        Returns
        -------
        None
        """
        # check instruction
        api_name = vec_reg_params.name.replace("vectorized_", "vector_")
        TikCheckUtil.check_type_match(vec_reg_params.dst, Vector, "dst0 should be Vector")
        TikCheckUtil.check_type_match(vec_reg_params.src, Vector, "src should be Vector")
        check_param_is_preg(api_name, vec_reg_params.dst1, "dst1")
        TikCheckUtil.check_equality(vec_reg_params.dst.dtype, vec_reg_params.src.dtype,
                                    "Intrinsic %s's src's dtype should be equal to dst0's dtype" % api_name)
        TikCheckUtil.check_equality(intrinsic_check_support("Intrinsic_" + vec_reg_params.name,
                                                            vec_reg_params.dst.dtype), True,
                                    gen_api_check_statement(vec_reg_params.dst.dtype, api_name))
        if isinstance(vec_reg_params.mask, Vector) and vec_reg_params.mask.scope == scope_preg:
            if id(vec_reg_params.mask) == id(vec_reg_params.dst1):
                print_error_msg("Intrinsic %s's mask and dst1 cannot be same Vector" % api_name)
        with self.new_scope():
            preg = self._gen_mask(vec_reg_params.mask, vec_reg_params.dst.dtype)
            instr = tvm.call_extern(vec_reg_params.dst.dtype, vec_reg_params.name, type_convert(vec_reg_params.dst),
                                    type_convert(vec_reg_params.dst1),
                                    type_convert(vec_reg_params.src), type_convert(preg))
            self.emit(instr)

    @vector_elewise_decroator
    def _vector_elewise_gen_code(self, name, gen_code_params):
        with self.new_scope():
            preg = self._gen_mask(gen_code_params.mask, gen_code_params.src0.dtype)
            mode = "MODE_MERGING"
            load_mode = StringImm(mode)
            instr = tvm.call_extern(gen_code_params.dst.dtype, name, type_convert(gen_code_params.dst),
                                    type_convert(gen_code_params.src0), type_convert(gen_code_params.src1),
                                    type_convert(preg),
                                    tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            self.emit(instr)

    def _vector_elewise_func(self, vector_params, acc_mode=None, api_name=None):
        """
        do <op> by single element,
        for instructions: VADD, VSUB, VMUL, VMULA, VMAX, VMIN, VSHL, VSHR, VABSDIF, VADIF, VADD3, VSAD
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation
        acc_mode: only for instruction vector_vadd, vector_vsub

        Returns
        -------
        None
        """
        self.check_params_obj.check_vector_one_dst_two_src_params(vector_params.name, vector_params, api_name=api_name)
        name = vector_params.name
        # code gen
        if vector_params.dst.scope == scope_wreg:
            name = vector_params.name.replace("vectorized_v", "vectorized_w")
            name = get_instr_name_by_acc_mode(acc_mode, name)
        elif vector_params.name == "vectorized_vadd" and acc_mode == "ADDA":
            name = "vectorized_vadd3"
        self._vector_elewise_gen_code(name, vector_params)

    @vector_reg_ele_wise_decorator
    def _vector_reg_binary_tenary_elewise_code(self, vector_reg_params, rnd_mode=None, mode=None):
        name = vector_reg_params.name
        if name == "vectorized_vlrelu":
            name = "vectorized_vprelu"
        with self.new_scope():
            preg = self._gen_mask(vector_reg_params.mask, vector_reg_params.dst.dtype)
            if rnd_mode is None:
                if mode is None:
                    instr = tvm.call_extern(vector_reg_params.dst.dtype, name,
                                            type_convert(vector_reg_params.dst), type_convert(vector_reg_params.src0),
                                            type_convert(vector_reg_params.src1), type_convert(preg))
                else:
                    load_mode = StringImm(mode)
                    instr = tvm.call_extern(vector_reg_params.dst.dtype, name, type_convert(vector_reg_params.dst),
                                            type_convert(vector_reg_params.src0),
                                            type_convert(vector_reg_params.src1), type_convert(preg),
                                            tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            else:
                if rnd_mode is False:
                    rnd_value = StringImm("NO_RND")
                else:
                    rnd_value = StringImm("RND")
                if mode is None:
                    instr = tvm.call_extern(
                        vector_reg_params.dst.dtype, name, type_convert(vector_reg_params.dst),
                        type_convert(vector_reg_params.src0), type_convert(vector_reg_params.src1),
                        tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', rnd_value), type_convert(preg))
                else:
                    load_mode = StringImm(mode)
                    instr = tvm.call_extern(
                        vector_reg_params.dst.dtype, name, type_convert(vector_reg_params.dst),
                        type_convert(vector_reg_params.src0),
                        type_convert(vector_reg_params.src1),
                        tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', rnd_value),
                        type_convert(preg), tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            self.emit(instr)

    @vector_vmov_decorator
    def _vector_vmov_make_code(self, vmov_params):
        with self.new_scope():
            instr = tvm.call_extern(vmov_params.dst.dtype, vmov_params.name,
                                    type_convert(vmov_params.dst), type_convert(vmov_params.src))
            self.emit(instr)

    @vector_single_elewise_decorator
    def _vector_reg_single_elewise_code_gen(self, vec_reg_params, mode):
        with self.new_scope():
            if vec_reg_params.name == "vectorized_pnot":
                preg = self._gen_mask(vec_reg_params.mask, "uint8")
            else:
                preg = self._gen_mask(vec_reg_params.mask, vec_reg_params.dst.dtype)
            if mode is None:
                instr = tvm.call_extern(vec_reg_params.dst.dtype, vec_reg_params.name,
                                        type_convert(vec_reg_params.dst), type_convert(vec_reg_params.src),
                                        type_convert(preg))
            else:
                if vec_reg_params.name == "vectorized_vsqz" and TikSocManager.is_v300_610l_soc():
                    store_mode = StringImm("MODE_NO_STORED")
                    instr = tvm.call_extern(
                        vec_reg_params.dst.dtype, vec_reg_params.name, type_convert(vec_reg_params.dst),
                        type_convert(vec_reg_params.src), type_convert(preg),
                    tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', store_mode))
                else:
                    load_mode = StringImm(mode)
                    instr = tvm.call_extern(
                        vec_reg_params.dst.dtype, vec_reg_params.name, type_convert(vec_reg_params.dst),
                        type_convert(vec_reg_params.src), type_convert(preg),
                        tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            self.emit(instr)

    @vector_vusqz_decorator
    def _gen_vusqz_code(self, vusqz_params):
        """
        gen vusqz code
        Parameters
        ----------
        vusqz_params

        Returns
        -------

        """
        self.check_params_obj.check_vector_one_dst_one_src_params(
            vusqz_params.name, vusqz_params.dst, vusqz_params.src)
        with self.new_scope():
            instr = tvm.call_extern(vusqz_params.dst.dtype, vusqz_params.name,
                                    type_convert(vusqz_params.dst), type_convert(vusqz_params.src))
            self.emit(instr)

    @vector_vselr_decorator
    def _vector_vselr_func(self, vselr_params):
        """
        do <op> by single element
        Parameters
        ----------
        name: instr name
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        # code gen
        with self.new_scope():
            instr = tvm.call_extern(vselr_params.dst.dtype, vselr_params.name, type_convert(vselr_params.dst),
                                    type_convert(vselr_params.src0), type_convert(vselr_params.src1))
            self.emit(instr)

    @vector_intlv_dintlv_decorator
    def _vec_intlv_dintlv_gen_code(self, intlv_params):
        """
        do <op> by single element
        Parameters
        ----------
        name: instr name
        dst0: vector destination operator
        dst1: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        with self.new_scope():
            instr = tvm.call_extern(intlv_params.dst0.dtype, intlv_params.name, type_convert(intlv_params.dst0),
                                    type_convert(intlv_params.dst1), type_convert(intlv_params.src0),
                                    type_convert(intlv_params.src1))
            self.emit(instr)

    @vector_vpack_vunpack_decorator
    def _vector_pack_unpack_func(self, unpack_params, merge_mode=None):
        """
        src is a vector, dst is vector, move src to dst
        Parameters
        ----------
        name: instr name
        dst: vector destination operator
        src: vector source operation
        part_mode: True of False for save to which part of dst
        merge_mode: merge mode of dst, only for vpack, for compiler optimization

        Returns
        -------
        None
        """
        with self.new_scope():
            part_mode_tvm = StringImm("HIGHER")
            if unpack_params.part_mode is False:
                part_mode_tvm = StringImm("LOWER")
            if merge_mode is None:
                instr = tvm.call_extern(unpack_params.dst.dtype, unpack_params.name,
                                        type_convert(unpack_params.dst), type_convert(unpack_params.src),
                                        tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', part_mode_tvm))
            else:
                mode_tvm = StringImm(merge_mode)
                instr = tvm.call_extern(unpack_params.dst.dtype, unpack_params.name,
                                        type_convert(unpack_params.dst), type_convert(unpack_params.src),
                                        tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', part_mode_tvm),
                                        tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', mode_tvm))
            self.emit(instr)

    @vector_vcmps_decorator
    def _vcmps_elewise_func(self, vcmps_params):
        """
        do vcmps and vcmp instruction
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support one model: Continuous
        dst: vector destination operator
        src: vector source operation
        scalar: scalar value for compare

        Returns
        -------
        None
        """
        api_name = vcmps_params.name.replace("vectorized", "vector")
        # check vector
        check_param_is_vreg(api_name, vcmps_params.src, "src")
        check_param_is_preg(api_name, vcmps_params.dst, "dst")

        TikCheckUtil.check_type_match(
            vcmps_params.scalar, (int, float, Expr, Scalar),
            "Instruction %s's src1 should be int, float, Expr or Scalar, "
            "input dtype of src1: %s" % (api_name, type(vcmps_params.scalar)))

        # check data type
        vector_dtype = vcmps_params.src.dtype
        if isinstance(vcmps_params.scalar, Expr) and \
                vcmps_params.src.dtype == "float16" and TikSocManager.is_v210_soc():
            vector_dtype = "float32"
        if isinstance(vcmps_params.scalar, (Scalar, Expr)):
            TikCheckUtil.check_equality(vector_dtype, vcmps_params.scalar.dtype,
                                        "Instruction %s's src1's dtype should be equal to src's dtype "
                                        "when src1 is Scalar/Expr" % api_name)
        else:
            if isinstance(vcmps_params.scalar, float):
                TikCheckUtil.check_var_in_list(
                    vcmps_params.src.dtype, ["float16", "float32"],
                    "Instruction %s's src1's dtype should be int when src's dtype is int" % api_name)
            err_msg = "Instruction %s's src1 should be in range [%d, %d] when src is %s" \
                      % (api_name, DTYPE_IMM_MIN[vcmps_params.src.dtype],
                         DTYPE_IMM_MAX[vcmps_params.src.dtype], vcmps_params.src.dtype)
            TikCheckUtil.check_in_range_by_dtype(vcmps_params.scalar, vcmps_params.src.dtype, msg=err_msg)
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + vcmps_params.name, vcmps_params.src.dtype), True,
            gen_api_check_statement(vcmps_params.src.dtype, api_name))

        with self.new_scope():
            preg = self._gen_mask(vcmps_params.mask, vcmps_params.src.dtype)
            scalar = dtype_convert(vcmps_params.scalar, vcmps_params.src.dtype)
            instr = tvm.call_extern(vcmps_params.dst.dtype, vcmps_params.name, type_convert(vcmps_params.dst),
                                    type_convert(vcmps_params.src), scalar, type_convert(preg))
            self.emit(instr)

    @vector_vslide_decorator
    def _vector_vslide_gen_code(self, vslide_params):
        with self.new_scope():
            instr = tvm.call_extern(vslide_params.dst.dtype, vslide_params.name,
                                    type_convert(vslide_params.dst), type_convert(vslide_params.src0),
                                    type_convert(vslide_params.src1), type_convert(vslide_params.slide_size))
            self.emit(instr)

    @vector_vcmp_decorator
    def _vcmpx_elewise_func(self, vcmp_params):
        """
        do vcmp instruction
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support one model: Continuous
        dst: predicate vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        api_name = vcmp_params.name.replace("vectorized", "vector")
        # check vector
        TikCheckUtil.check_type_match(vcmp_params.src0, Vector, "Instruction %s's src0 should be Vector" % api_name)
        TikCheckUtil.check_type_match(vcmp_params.src1, Vector, "Instruction %s's src1 should be Vector" % api_name)
        check_param_is_preg(api_name, vcmp_params.dst, "dst")

        # check data type
        TikCheckUtil.check_equality(vcmp_params.src0.dtype, vcmp_params.src1.dtype,
                                    "Instruction %s's src1's dtype should be equal to src0's dtype" % api_name)
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + vcmp_params.name, vcmp_params.src0.dtype), True,
            gen_api_check_statement(vcmp_params.src0.dtype, api_name))

        with self.new_scope():
            preg = self._gen_mask(vcmp_params.mask, vcmp_params.src0.dtype)
            instr = tvm.call_extern(vcmp_params.dst.dtype, vcmp_params.name, type_convert(vcmp_params.dst),
                                    type_convert(vcmp_params.src0), type_convert(vcmp_params.src1), type_convert(preg))
            self.emit(instr)

    @vector_vdupi_b8_decorator
    def _gen_vector_vdupi_b8(self, vdup_params):
        if DTYPE_MAP[vdup_params.dst.dtype] == "u8":
            TikCheckUtil.check_in_range_by_dtype(
                vdup_params.src, "uint8", msg="dst Vector dtype is %s, input immediate value must in range(%d, %d)"
                                              % (vdup_params.dst.dtype, UINT_MIN, UINT8_MAX))
        else:
            TikCheckUtil.check_in_range_by_dtype(
                vdup_params.src, "int8", msg="dst Vector dtype is %s, input immediate value must in range(%d, %d)"
                                             % (vdup_params.dst.dtype, INT8_MIN, INT8_MAX))
        instr = tvm.call_extern(vdup_params.dst.dtype, vdup_params.name, type_convert(vdup_params.dst),
                                type_convert(vdup_params.src), type_convert(vdup_params.mask))
        self.emit(instr)

    @vector_vdupi_b16_decorator
    def _gen_vector_vdupi_b16(self, vdup_params, mode):
        preg = vdup_params.mask
        if DTYPE_MAP[vdup_params.dst.dtype] == "s16":
            TikCheckUtil.check_in_range_by_dtype(
                vdup_params.src, "int16", msg="dst Vector dtype is %s, input immediate value must in range(%d, %d)"
                                              % (vdup_params.dst.dtype, INT16_MIN, INT16_MAX))
            src_value = np.array([vdup_params.src]).astype(np.int16)
        elif DTYPE_MAP[vdup_params.dst.dtype] == "u16":
            TikCheckUtil.check_in_range_by_dtype(
                vdup_params.src, "uint16", msg="dst Vector dtype is %s, input immediate value must in range(%d, %d)"
                                               % (vdup_params.dst.dtype, UINT_MIN, UINT16_MAX))
            src_value = np.array([vdup_params.src]).astype(np.uint16)
        else:
            src_value = np.array([vdup_params.src]).astype(np.float16)
        temp_value = src_value.view(np.uint8)
        if mode in (0, 1):
            load_mode = StringImm("PART_ODD")
            if mode == 0:
                load_mode = StringImm("PART_EVEN")
            instr = tvm.call_extern(vdup_params.dst.dtype, vdup_params.name, type_convert(vdup_params.dst),
                                    type_convert(temp_value[0]), type_convert(preg),
                                    tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            self.emit(instr)
        elif mode == 2:
            load_mode = StringImm("PART_EVEN")
            instr = tvm.call_extern(vdup_params.dst.dtype, vdup_params.name,
                                    type_convert(vdup_params.dst), type_convert(temp_value[0]),
                                    type_convert(preg),
                                    tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            self.emit(instr)
            load_mode = StringImm("PART_ODD")
            instr = tvm.call_extern(vdup_params.dst.dtype, vdup_params.name, type_convert(vdup_params.dst),
                                    type_convert(temp_value[1]), type_convert(preg),
                                    tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            self.emit(instr)
        else:
            TikCheckUtil.raise_error("model input value is %d, should be 0, 1 or 2" % mode)

    @vector_vdups_decorator
    def _gen_vector_vdups_code(self, vdup_params, load_mode):
        preg = self._gen_mask(vdup_params.mask, vdup_params.dst.dtype)
        instr = tvm.call_extern(vdup_params.dst.dtype, "vectorized_vdup", type_convert(vdup_params.dst),
                                type_convert(vdup_params.src), type_convert(preg),
                                tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
        self.emit(instr)

    @vector_vdup_decorator
    def _gen_vector_vdup_code(self, vdup_params, load_mode):
        pos_value = StringImm("POS_HIGHEST")
        if vdup_params.name == "vectorized_vdup":
            pos_value = StringImm("POS_LOWEST")
        preg = self._gen_mask(vdup_params.mask, vdup_params.dst.dtype)
        instr = tvm.call_extern(
            vdup_params.dst.dtype, "vectorized_vdup", type_convert(vdup_params.dst),
            type_convert(vdup_params.src), type_convert(preg),
            tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', pos_value),
            tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
        self.emit(instr)

    @vector_vscatter_decorator
    def _vector_vscatter_code_gen(self, vscatter_params):

        with self.new_scope():
            preg = self._gen_mask(vscatter_params.mask, vscatter_params.src1.dtype)
            instr = tvm.call_extern(vscatter_params.dst.dtype, vscatter_params.name,
                                    type_convert(vscatter_params.src0), vscatter_params.dst.access_ptr("w"),
                                    type_convert(vscatter_params.src1), type_convert(preg))
            self.emit(instr)

    @vector_vfcvt_vsfcvt_decorator
    def _gen_vector_vfcvt_code(self, vfcvt_params, literal_value):
        dtype_str = DTYPE_MAP[vfcvt_params.src.dtype] + "2" + DTYPE_MAP[vfcvt_params.dst.dtype]
        args = gen_vfcvt_param(vfcvt_params.part_indicator, vfcvt_params.round_mode, literal_value,
                               vfcvt_params.saturate_flag, dtype_str)
        if TikSocManager.is_v300_610l_soc():
            vfcvt_name = "vectorized_vcvt"
        else:
            vfcvt_name = "vectorized_vfcvt"
            if vfcvt_params.saturate_flag:
                vfcvt_name = "vectorized_vsfcvt"
        with self.new_scope():
            if dtype_str in ["f162s16", "s162f16", "s322f32", "f322s32"]:
                mask = self._gen_mask(vfcvt_params.mask, vfcvt_params.src.dtype)
                instr = self._gen_vector_vfcvt_dtype_f2s_or_s2f(
                    vfcvt_params.src, vfcvt_params.dst, mask, vfcvt_name, args)
            else:
                if TikSocManager.is_v300_610l_soc():
                    mask = self._gen_mask(vfcvt_params.mask, vfcvt_params.src.dtype)
                    instr = self._gen_vector_vfcvt_dtype_f2s_or_s2f(
                        vfcvt_params.src, vfcvt_params.dst, mask, vfcvt_name, args)
                else:
                    instr = tvm.call_extern(vfcvt_params.dst.dtype, vfcvt_name,
                                            type_convert(vfcvt_params.dst), type_convert(vfcvt_params.src), *args)
            self.emit(instr)

    @vector_vtrc_decorator
    def _gen_vector_vtrc_code(self, vtrc_params, mode):
        mode_value = StringImm(mode)
        with self.new_scope():
            preg = self._gen_mask(vtrc_params.mask, vtrc_params.dst.dtype)
            load_mode = StringImm("MODE_MERGING")
            instr = tvm.call_extern(vtrc_params.dst.dtype, vtrc_params.name,
                                    type_convert(vtrc_params.dst), type_convert(vtrc_params.src),
                                    tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', mode_value),
                                    type_convert(preg),
                                    tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', load_mode))
            self.emit(instr)

    @vector_initial_decorator
    def _vector_initial_func(self, ini_params):
        """
         initial the vector value according to input data src
         Parameters
         ----------
         name: instr name
         dst: vector destination operator
         src: imm, scalar, or expr
         api_name: api name, not cce instruction's name

         Returns
         -------
         None
         """
        TikCheckUtil.check_type_match(
            ini_params.dst, Vector, "Intrinsic %s's dst should be Vector, but input type of dst: %s" % \
                                    (ini_params.api_name, type(ini_params.dst)))
        TikCheckUtil.check_type_match(ini_params.src, (int, float, Expr, Scalar),
                                      "Intrinsic %s's src should be int, float, Expr or Scalar, "
                                      "but input type of src: %s" % (ini_params.api_name, type(ini_params.src)))

        # check instruction
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + ini_params.name, ini_params.dst.dtype), True,
            gen_api_check_statement(ini_params.dst.dtype, ini_params.api_name))

        src_dtype = ini_params.dst.dtype
        if ini_params.name == "vectorized_vbr":
            scalar_dtype_check(ini_params.api_name, "br_data", src_dtype, ini_params.src)
        elif ini_params.name == "vectorized_vci":
            src_range = None
            if not TikSocManager.is_v300_610l_soc():
                if src_dtype == "float16":
                    src_dtype = "uint16"
                    # float16 sn is unsigned int16, fp16 only has 10bit mantissa, so Sn must be less then 2**11 - 128
                    src_range = [0, 1920]
                elif src_dtype == "float32":
                    src_dtype = "uint32"
                    # float32 sn is unsigned int32, fp32 only has 23bit mantissa, so Sn must be less then 2**23 - 64
                    src_range = [0, 16777152]
            # src's dtype must be same with src_dtype
            scalar_dtype_check(ini_params.api_name, "start_index", src_dtype, ini_params.src, src_range)

        # type convert according src_dtype
        scalar_tmp = dtype_convert(ini_params.src, src_dtype)
        with self.new_scope():
            instr = tvm.call_extern(ini_params.dst.dtype, ini_params.name, type_convert(ini_params.dst), scalar_tmp)
            self.emit(instr)

    @vector_vgather_decorator
    def _gen_vgather_code(self, vgather_params):
        src0_vlen = self.get_vector_length(vgather_params.src0.dtype)
        with self.new_scope():
            with self.context.freeze():
                address_reg = Vector(self, dtype="int32", name="address_buf_", scope=scope_areg)
            if vgather_params.name == "vectorized_vgatherb":
                instr = tvm.call_extern(
                    vgather_params.dst.dtype, vgather_params.name, type_convert(vgather_params.dst),
                    vgather_params.src0.access_ptr("r", extent=src0_vlen * DTYPE_SIZE[vgather_params.src0.dtype]),
                    type_convert(address_reg), type_convert(vgather_params.src1))
            else:
                instr = tvm.call_extern(
                    vgather_params.dst.dtype, vgather_params.name, type_convert(vgather_params.dst),
                    vgather_params.src0.access_ptr("r", extent=src0_vlen * DTYPE_SIZE[vgather_params.src0.dtype]),
                    type_convert(address_reg), vgather_params.src1.access_ptr("r"))
            self.emit(instr)

    @vector_vgatherv2_decorator
    def _gen_vgatherv2_code(self, vgather_params):
        src0_vlen = self.get_vector_length(vgather_params.src0.dtype)
        with self.new_scope():
            if vgather_params.name == "vectorized_vgatherb":
                instr = tvm.call_extern(
                    vgather_params.dst.dtype, vgather_params.name, type_convert(vgather_params.dst),
                    vgather_params.src0.access_ptr("r", extent=src0_vlen * DTYPE_SIZE[vgather_params.src0.dtype]),
                    type_convert(vgather_params.src1))
            else:
                # mask's type is vector bool
                preg = self._gen_mask(vgather_params.mask, vgather_params.src1.dtype)
                instr = tvm.call_extern(
                    vgather_params.dst.dtype, vgather_params.name,
                    type_convert(vgather_params.dst),
                    vgather_params.src0.access_ptr("r", extent=src0_vlen * DTYPE_SIZE[vgather_params.src0.dtype]),
                    type_convert(vgather_params.src1),
                    type_convert(preg),)
            self.emit(instr)

    @vector_vcvt_vscvt_decorator
    def _gen_vector_vcvt_code(self, vct_params):
        vcvt_name = "vectorized_vcvt"
        if TikSocManager.is_v300_610l_soc():
            literal_value = "MODE_ZEROING"
        else:
            literal_value = "MODE_MERGING"
            if vct_params.saturate_flag:
                vcvt_name = "vectorized_vscvt"
        dtype_str = DTYPE_MAP[vct_params.src.dtype] + "2" + DTYPE_MAP[vct_params.dst.dtype]
        if dtype_str in ["u82u16", "s82s16", "u162u32", "s162u32", "s162s32", "u82u32", "s82s32"]:
            literal_value = None
        args = gen_vcvt_param(vct_params.part_indicator, literal_value, vct_params.saturate_flag, dtype_str)

        with self.new_scope():
            if TikSocManager.is_v300_610l_soc():
                preg = self._gen_mask(vct_params.mask, vct_params.src.dtype)
                instr = tvm.call_extern(vct_params.dst.dtype, vcvt_name, type_convert(vct_params.dst),
                                        type_convert(vct_params.src), type_convert(preg), *args)
            else:
                instr = tvm.call_extern(vct_params.dst.dtype, vcvt_name, type_convert(vct_params.dst),
                                        type_convert(vct_params.src), *args)
            self.emit(instr)

    @vector_load_unalign_decorator
    def _vector_load_unalign(self, unalign_params):
        with self.new_scope():
            vlda_name = "vectorized_vlda"
            vldu_name = "vectorized_vldu"
            with self.context.freeze():
                areg = Vector(self, dtype="int32", name='address_buf_', scope=scope_areg)
            vlda_instr = tvm.call_extern(unalign_params.ureg.dtype, vlda_name,
                                         type_convert(unalign_params.ureg),
                                         unalign_params.src.access_ptr(
                                            'r', extent=unalign_params.vlen * DTYPE_SIZE[unalign_params.src.dtype]),
                                         type_convert(areg))
            self.emit(vlda_instr)

            vldu_instr = tvm.call_extern(unalign_params.dst.dtype, vldu_name, type_convert(unalign_params.dst),
                                         type_convert(unalign_params.ureg), type_convert(areg),
                                         unalign_params.src.access_ptr(
                                            'r', extent=unalign_params.vlen * DTYPE_SIZE[unalign_params.src.dtype]),
                                         type_convert(0))
            self.emit(vldu_instr)

    @vector_load_ld_decorator
    def _vector_load_ld(self, ld_params):
        vld_name = "vectorized_vld"
        if ld_params.ld_mode in ["BDINTLV", "DINTLV"]:
            dst_arg = type_convert(ld_params.dst)
            if TikSocManager.is_v300_610l_soc():
                vld_name = "vectorized_vld_intlv"
        else:
            dst_arg = type_convert([ld_params.dst])
        with self.new_scope():
            with self.context.freeze():
                areg = Vector(self, dtype="int32", name='address_buf_', scope=scope_areg)
            vld_instr = tvm.call_extern(
                ld_params.src.dtype, vld_name, *dst_arg,
                ld_params.src.access_ptr("r", extent=ld_params.vlen * DTYPE_SIZE[ld_params.src.dtype]),
                type_convert(areg),
                tvm.call_cce_pure_intrin('handle', 'tvm_cce_string_print', StringImm(ld_params.str_ld_mode)))
            self.emit(vld_instr)

    @vector_store_unalign_decorator
    def _vector_store_unalign_v300(self, unalign_params):
        with self.new_scope():
            offset = self.get_vector_length(unalign_params.dst.dtype)
            vstu_instr = tvm.call_extern(
                unalign_params.src.dtype,
                "vectorized_vstus", type_convert(unalign_params.ureg),
                offset, type_convert(unalign_params.src),
                unalign_params.dst.access_ptr(
                    "w", extent=unalign_params.vlen * DTYPE_SIZE[unalign_params.dst.dtype]),
                tvm.call_cce_pure_intrin("handle", "tvm_cce_string_print", StringImm("POST_UPDATE")))
            self.emit(vstu_instr)
            zero_offset = 0
            vsta_instr = tvm.call_extern(
                unalign_params.ureg.dtype, "vectorized_vstas", type_convert(unalign_params.ureg),
                unalign_params.dst.access_ptr(
                    "w", extent=unalign_params.vlen * DTYPE_SIZE[unalign_params.dst.dtype]), zero_offset,
                tvm.call_cce_pure_intrin("handle", "tvm_cce_string_print", StringImm("POST_UPDATE")))
            self.emit(vsta_instr)

    @vector_store_unalign_sqzn_decorator
    def _vector_store_sqzn(self, unalign_params):
        with self.new_scope():
            vstu_instr = tvm.call_extern(
                unalign_params.src.dtype,
                "vectorized_vstur", type_convert(unalign_params.ureg), type_convert(unalign_params.src),
                unalign_params.dst.access_ptr(
                    "w", extent=unalign_params.vlen * DTYPE_SIZE[unalign_params.dst.dtype]),
                tvm.call_cce_pure_intrin("handle", "tvm_cce_string_print", StringImm("POST_UPDATE")))
            self.emit(vstu_instr)
        
            vsta_instr = tvm.call_extern(
                unalign_params.ureg.dtype, "vectorized_vstar", type_convert(unalign_params.ureg),
                unalign_params.dst.access_ptr(
                    "w", extent=unalign_params.vlen * DTYPE_SIZE[unalign_params.dst.dtype]))
            self.emit(vsta_instr)

    @vector_store_unalign_decorator
    def _vector_store_unalign(self, unalign_params):
        with self.new_scope():
            with self.context.freeze():
                areg = Vector(self, dtype="int32", name='address_buf_', scope=scope_areg)
            vstu_instr = tvm.call_extern(
                unalign_params.src.dtype,
                "vectorized_vstu", type_convert(unalign_params.ureg),
                type_convert(areg), type_convert(unalign_params.src),
                unalign_params.dst.access_ptr(
                    "w", extent=unalign_params.vlen * DTYPE_SIZE[unalign_params.dst.dtype]),
                tvm.call_cce_pure_intrin("handle", "tvm_cce_string_print", StringImm("POST_UPDATE")))
            self.emit(vstu_instr)
    
            vsta_instr = tvm.call_extern(
                unalign_params.ureg.dtype, "vectorized_vsta", type_convert(unalign_params.ureg),
                unalign_params.dst.access_ptr(
                    "w", extent=unalign_params.vlen * DTYPE_SIZE[unalign_params.dst.dtype]), type_convert(areg))
            self.emit(vsta_instr)

    def _vector_reg_single_elewise_func(self, vec_reg_params, mode=None):
        """
        src is a vector, dst is vector, trans src to dst
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support Continuous model
        dst: vector destination operator
        src: vector source operation
        mode: merging mode or zeroing mode

        Returns
        -------
        None
        """

        self._vector_reg_single_elewise_code_gen(vec_reg_params, mode)

    def _vector_elewise_scalar_func(self, vec_params, mode=None, api_name=None):
        """
        src is a vector, dst is vector, trans src to dst
        Parameters
        ----------
        name: instr name
        mask: effective operation on element, only support Continuous model
        dst: vector destination operator
        src: vector source operation
        mode: merging mode or zeroing mode
        api_name: if is not None, use it as api name for output

        Returns
        -------
        None
        """
        self.check_params_obj.check_elewise_scalar_func_params(vec_params.name, vec_params, api_name=api_name)

        self._vector_elewise_scalar_make_code(vec_params, mode)
