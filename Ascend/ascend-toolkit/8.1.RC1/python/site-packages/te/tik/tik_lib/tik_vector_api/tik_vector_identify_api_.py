#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_identify_api_.py
DESC:     provide params
CREATED:  2021-11-30 18:53:42
MODIFIED: 2021-11-30 19:17:00
"""
from tbe import tvm
from tbe.tik.common import DTYPE_SIZE
from tbe.tik.common.util import get_bit_len
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_vector_api.tik_tensor_op import TensorOp
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_vector_api.tik_vector_name_map import IDENTIFY_NAME_DICT
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_identify import IdentifyCheckParams
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug import identify_decorator


class IdentifyOp:
    """
    Vcmp Ops
    """
    DEFAULT_STRIDE = 0

    def __init__(self, tik_instance, identify_api):
        super().__init__()
        self.tik_instance = tik_instance
        self.name = IDENTIFY_NAME_DICT.get(identify_api.name)
        self.print_name = identify_api.name

        self.repeat_times = identify_api.repeat_times
        self.dst_op = TensorOp(identify_api.dst, 1, 1, "dst")

        if self.name in ("viou", "vaadd"):
            self.src0_op = TensorOp(identify_api.src0, 1, 1, "src0")
        else:
            self.src0_op = TensorOp(identify_api.src0, 1, 1, "src")

        self.src1_op = TensorOp(identify_api.src1, 1, 1, "src1")
        # debug check instance
        self.check_params = (self.dst_op, self.src0_op, self.src1_op)
        self.identify_check_obj = IdentifyCheckParams(self.print_name, self.check_params, self.repeat_times)

    def check_and_gen_new_tensor(self):
        """
        if instruction is vmergech, check and gen new tensor, chang data's type

        Returns
        -------
        None
        """
        if self.name == "vmergech":
            if get_bit_len(self.dst_op.tensor_obj.dtype) == 16:
                self.dst_op.tensor_obj = self.dst_op.tensor_obj.reinterpret_cast_to("float16")
                self.src0_op.tensor_obj = self.src0_op.tensor_obj.reinterpret_cast_to("float16")
            else:
                self.dst_op.tensor_obj = self.dst_op.tensor_obj.reinterpret_cast_to("uint8")
                self.src0_op.tensor_obj = self.src0_op.tensor_obj.reinterpret_cast_to("uint8")

    @identify_decorator
    def gen_code(self):
        """
        code gen

        Returns
        -------
        None
        """
        self.check_and_gen_new_tensor()
        dst_extent_value = self.repeat_times * DTYPE_SIZE[self.dst_op.tensor_obj.dtype]
        src0_extent_value = self.repeat_times * DTYPE_SIZE[self.src0_op.tensor_obj.dtype]
        if self.name == "vrpac":
            # dst_extent: repeat_times * 16 elements/proposal * dtype_size
            # src_extent: repeat_time * 16 proposal * 8 element/proposal *
            #             dtype_size
            dst_extent = Expr(dst_extent_value * 16)
            src_extent = [Expr(src0_extent_value * 16 * 8)]
        elif self.name == "vbitsort":
            dst_extent = Expr(dst_extent_value * 16 * 8)
            src_extent = [Expr(src0_extent_value * 16 * 8)]
        elif self.name == "viou":
            # dst_extent: repeat_times * 256 intersection area * dtype_size
            # src_extent: 16 region proposals are continous in unified buffer
            #             repeat_times * 16 region proposals *
            #             8 element/proposal * dtype_size
            dst_extent = Expr(dst_extent_value * 256)
            src_extent = [Expr(src0_extent_value * 16 * 8),
                          Expr(16 * 8 * DTYPE_SIZE[self.src1_op.tensor_obj.dtype])]
        elif self.name == "vaadd":
            # dst_extent, src_extent same as "viou"
            dst_extent = Expr(dst_extent_value * 256)
            src_extent = [Expr(src0_extent_value * 16),
                          Expr(16 * DTYPE_SIZE[self.src1_op.tensor_obj.dtype])]
        else:  # name == "vmergech":
            if self.dst_op.tensor_obj.dtype in ["float16", "uint16", "int16"]:
                # extract valid 8B from each 32B for b16
                dst_extent = Expr(self.repeat_times * 8)
            else:  # uint8 int8
                # extract valid 4B from each 32B for b8
                dst_extent = Expr(self.repeat_times * 4)
            src_extent = [Expr(self.repeat_times * 32)]
        tensor_addr = [self.dst_op.tensor_obj.access_ptr("w", extent=dst_extent.get())]
        tensor_addr.append(self.src0_op.tensor_obj.access_ptr("r", extent=src_extent[0].get()))
        if self.name in ("viou", "vaadd"):
            tensor_addr.append(self.src1_op.tensor_obj.access_ptr("r", extent=src_extent[1].get()))
        config = [self.repeat_times]
        with self.tik_instance.new_scope():
            instr = tvm.call_extern(self.dst_op.tensor_obj.dtype, self.name, *tensor_addr, *type_convert(config))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(instr)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.identify_check_obj.check_all()
        self.gen_code()
