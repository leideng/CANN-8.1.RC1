#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vecotr_new_api.py
DESC:     provide vector instructions
CREATED:  2020-03-10 18:53:42
MODIFIED: 2020-12-7 19:17:00
"""

from tbe import tvm
from tbe.common.platform import intrinsic_check_support
from tbe.common.platform import scope_ubuf
from tbe.common.platform import scope_preg
from tbe.common.platform import scope_vreg
from tbe.common.platform import scope_wreg
from tbe.tik.common.tik_api_map import BS9SX1A
from tbe.tik.common.tik_api_map import ASCEND_310B
from tbe.tik.common.tik_api_map import ASCEND_310M
from tbe.tik.common.tik_api_map import ASCEND_610L
from tbe.tik.common.tik_api_map import BS9SX2A
from tbe.tik.common.tik_api_map import MC61AM21A
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import TikUtil
from tbe.tik.common.util import TikCheckUtil
from tbe.tik.common.util import reduce_mul
from tbe.tik.common.common_util import check_param_type_range
from tbe.tik.common.common_util import check_address_align
from tbe.tik.common.common_util import check_extent_overflow
from tbe.tik.debug.decorators_v210 import mvf_dci_decorator
from tbe.tik.debug.decorators_preg_v210 import vector_plt_decorator
from tbe.tik.tik_lib.tik_params import PIPE_MTE2
from tbe.tik.tik_lib.tik_params import MIN_INDEX
from tbe.tik.tik_lib.tik_params import MAX_START_INDEX
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_api_constants import MVF_ELE_SIZE_MAP
from tbe.tik.tik_lib.tik_api_constants import MVF_ELE_SIZE_MAP_V300
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import _vcvt_dtype_check
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.api.tik_vector import Vector
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import check_param_is_vreg
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_common_ import check_slide_size
from tbe.tik.tik_lib.tik_check_util import print_error_msg
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_vector_new_api.tik_vector_new_api_base import TikVectorNewApiBase
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager


class TikVectorNewGeneralApi(TikVectorNewApiBase):
    """
    Vector, Serialization, Spr Operation Api
    """

    @source_info_decorator()
    @mvf_dci_decorator
    def mvf_dci(self):
        """
        mvf data cache invalidate
        """
        soc_name = get_soc_name()
        if soc_name not in (BS9SX1A, ASCEND_310B, ASCEND_310M, ASCEND_610L, BS9SX2A, MC61AM21A):
            TikCheckUtil.raise_error("mvf_dci not support %s " % soc_name)
        with self.new_scope():
            instr_name = "mvf_dci"
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_MTE2)
            self.emit(tvm.call_extern("int64", instr_name, *([])))

    @source_info_decorator()
    def Vector(self, dtype="float16", name="vector_buf_"):
        """
        create vector
        Parameters
        ----------
        dtype: the vector's type
        name: vector's name

        Returns
        -------
        vector
        """
        scope = ""
        TikCheckUtil.check_name_str_valid(name)
        if dtype in ('uint8', 'int8', 'uint16', 'int16', 'float16', 'uint32', 'int32', 'float32'):
            scope = scope_vreg
        elif dtype == "bool":
            scope = scope_preg
        elif dtype in ('int24', 'int48', 'int64'):
            scope = scope_wreg
        else:
            msg = "Error dtype %s, Vector only support dtype: " \
                  "bool/uint8/int8/uint16/int16/float16/uint32/int32/float32/int24/int48/int64" % dtype
            print_error_msg(msg)

        return Vector(self, dtype, name, scope)

    @source_info_decorator()
    @vector_plt_decorator
    def vector_plt(self, mask, dtype, max_index):
        """
        update mask value according the max_index

        Parameters
        ----------
        mask: Predicate register for save valid elements index
        dtype: data type of Vector Register, available bits of mask depend dtype
        max_index: max index of valid element

        Returns
        -------
        None
        """
        instr_name = "vectorized_plt"
        api_name = "vector_plt"
        TikCheckUtil.check_type_match(
            mask, Vector, "Intrinsic %s's mask should be Vector, input type of mask: %s" % (api_name, type(mask)))
        TikCheckUtil.check_equality(
            mask.dtype, "bool",
            "Intrinsic %s's mask's dtype should be bool, but input mask's dtype is: %s" % (api_name, mask.dtype))
        TikCheckUtil.check_type_match(max_index, (int, Expr, Scalar),
                                      "Intrinsic %s's max_index should be int, Expr or Scalar, "
                                      "input type of scalar: %s" % (api_name, type(max_index)))
        if isinstance(max_index, int):
            TikCheckUtil.check_in_range_by_dtype(
                max_index, msg="Intrinsic %s's max_index's value should be in range [%d, %d]"
                               % (api_name, MIN_INDEX, MAX_START_INDEX), var_range=[MIN_INDEX, MAX_START_INDEX])
        elif isinstance(max_index, (Scalar, Expr)):
            TikCheckUtil.check_equality("uint16", max_index.dtype,
                                        "Intrinsic %s's max_index's dtype should be uint16, "
                                        "but it's %s" % (api_name, max_index.dtype))
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + instr_name, dtype), True, gen_api_check_statement(dtype, api_name))

        bit_type_string = TikUtil.bit_type(dtype)
        with self.new_scope():
            instr = tvm.call_extern(
                mask.dtype, instr_name + bit_type_string,
                type_convert(max_index))
            plt_stmt = tvm.tir.Store(type_convert(mask), instr, 0)
            self.emit(plt_stmt)

    @source_info_decorator()
    def vector_vgatherbv2(self, dst, src0, src1):
        """
        do vector gather for indexes
        Parameters
        ----------
        dst: vector destination operator
        src0: Source0 operand
        src1: Source1 operand

        Returns
        -------
        no return
        """
        api_name = "vector_vgatherbv2"
        # check dst, src1 type,scope
        check_param_is_vreg(api_name, dst, "dst")
        check_param_is_vreg(api_name, src1, "src1")

        # check src0 type,scope
        TikCheckUtil.check_type_match(src0, Tensor, "Instruction %s's src0 should be Tensor" % api_name)
        TikCheckUtil.check_equality(src0.scope, scope_ubuf,
                                    "Instruction %s's src0's scope must be scope_ubuf" % api_name)
        TikCheckUtil.check_equality(
            src0.scope, scope_ubuf, "Instruction %s's src1's scope must be scope_ubuf" % api_name)

        name = "vectorized_vgatherb"
        TikCheckUtil.check_equality(src1.dtype, "uint32",
                                    "Instruction %s's src1's dtype should be uint32, "
                                    "but get dtype: %s" % (api_name, src1.dtype))
        TikCheckUtil.check_equality(dst.dtype, src0.dtype, "Instruction %s's src0's "
                                                           "dtype should be equal to dst's dtype" % api_name)
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + name, dst.dtype), True,
            gen_api_check_statement(dst.dtype, api_name))
        check_address_align([src0], ["src0"])

        # check src0 overflow
        block_num = reduce_mul(src0.original_shape) * DTYPE_SIZE[src0.dtype] // 32
        if block_num < 1:
            print_error_msg("The value of src0's block should be greater than or equal to 1")

        vec_op_params_ins = TikVectorNewGeneralApi.vec_op_params(name, None, dst, None, None, src0, src1)
        self._gen_vgatherv2_code(vec_op_params_ins)

    @source_info_decorator()
    def vector_vgather2v2(self, dst, src0, src1, mask=None):
        """
        do vector gather for indexes
        Parameters
        ----------
        dst: vector destination operator
        src0: Source0 operand
        src1: Source1 operand
        gather_flag:
        when gather_flag = False, do vector gather
        when gather_flag = True, do vector block gather

        Returns
        -------
        no return
        """
        api_name = "vector_vgather2v2"
        # check dst, src1 type,scope
        check_param_is_vreg(api_name, dst, "dst")
        check_param_is_vreg(api_name, src1, "src1")

        # check src0 type,scope
        TikCheckUtil.check_type_match(src0, Tensor, "Instruction %s's src0 should be Tensor" % api_name)
        TikCheckUtil.check_equality(src0.scope, scope_ubuf,
                                    "Instruction %s's src0's scope must be scope_ubuf" % api_name)
        TikCheckUtil.check_equality(
            src0.scope, scope_ubuf,
            "Instruction %s's src1's scope must be scope_ubuf, when gather_flag=False" % api_name)

        name = "vectorized_vgather2"
        dtype_str = DTYPE_MAP[dst.dtype] + DTYPE_MAP[src1.dtype] + DTYPE_MAP[src0.dtype]
        dtype_str_error = "src0 " + src0.dtype + " src1 " + src1.dtype + " dst " + dst.dtype
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + name, dtype_str), True,
            gen_api_check_statement(dtype_str_error, api_name))
        check_address_align([src0], ["src0"])

        vec_op_params_ins = TikVectorNewGeneralApi.vec_op_params(name, mask, dst, None, None, src0, src1)
        self._gen_vgatherv2_code(vec_op_params_ins)

    @source_info_decorator()
    def vector_vgather(self, dst, src0, src1, gather_flag=False):
        """
        do vector gather for indexes
        Parameters
        ----------
        dst: vector destination operator
        src0: Source0 operand
        src1: Source1 operand
        gather_flag:
        when gather_flag = False, do vector gather
        when gather_flag = True, do vector block gather

        Returns
        -------
        no return
        """
        api_name = "vector_vgather"
        TikCheckUtil.check_type_match(src0, Tensor, "Instruction %s's src0 should be Tensor" % api_name)
        check_param_is_vreg(api_name, dst, "dst")
        TikCheckUtil.check_equality(src0.scope, scope_ubuf,
                                    "Instruction %s's src0's scope must be scope_ubuf" % api_name)
        TikCheckUtil.check_type_match(
            gather_flag, bool,
            "Instruction %s's gather_flag should be bool type, but get type: %s" % (api_name, type(gather_flag)))

        if gather_flag:
            TikCheckUtil.check_type_match(
                src1, (int, Expr, Scalar),
                "Instruction %s's src1 should be int, Expr or Scalar, when "
                "gather_flag=True, but input type: %s" % (api_name, type(src1)))
        else:
            TikCheckUtil.check_type_match(
                src1, Tensor, "Instruction %s's src1 should be Tensor, when gather_flag=False" % api_name)
            TikCheckUtil.check_equality(
                src1.scope, scope_ubuf,
                "Instruction %s's src1's scope must be scope_ubuf, when gather_flag=False" % api_name)

        # check instruction
        if gather_flag:
            name = "vectorized_vgatherb"
            if isinstance(src1, (Scalar, Expr)):
                TikCheckUtil.check_equality(src1.dtype, "uint32",
                                            "Instruction %s's src1's dtype should be uint32, "
                                            "when gather_flag=True, but get dtype: %s" % (api_name, src1.dtype))
            TikCheckUtil.check_equality(src0.dtype, "uint32",
                                        "Instruction %s's src0's dtype should be uint32, "
                                        "when gather_flag=True, but get dtype: %s" % (api_name, src0.dtype))
            TikCheckUtil.check_equality(
                intrinsic_check_support("Intrinsic_" + name, dst.dtype), True,
                gen_api_check_statement(dst.dtype, api_name))
            check_address_align([src0], ["src0"])
            vl_t = self.get_vector_length("int8") // 32
        else:
            name = "vectorized_vgather2"
            dtype_str = DTYPE_MAP[dst.dtype] + DTYPE_MAP[src0.dtype] + DTYPE_MAP[src1.dtype]
            dtype_str_error = "src0 " + src0.dtype + " src1 " + src1.dtype + " dst " + dst.dtype
            TikCheckUtil.check_equality(
                intrinsic_check_support("Intrinsic_" + name, dtype_str), True,
                gen_api_check_statement(dtype_str_error, api_name))
            check_address_align([src0], ["src0"])
            vl_t = self.get_vector_length(src0.dtype)
        if not TikSocManager.is_v210_vec_soc():
            TikCheckUtil.raise_error(
                "current chip: %s doesn't support %s, use the vector_vgatherbv2 or vector_vgather2v2" %
                (get_soc_name(), api_name))
        # check src0 overflow
        src0_offset = Expr(src0.offset).eval_value()
        check_extent_overflow(
            src0, vl_t * DTYPE_SIZE[src0.dtype], src0_offset, "src0")
        vec_op_params_ins = TikVectorNewGeneralApi.vec_op_params(name, None, dst, None, None, src0, src1)
        self._gen_vgather_code(vec_op_params_ins)

    @source_info_decorator()
    def vector_vpack(self, dst, src, part_mode):
        """
        pack src into dst
        Parameters
        ----------
        dst: vector destination operator
        src: vector source operation
        part_mode:
        part_mode = False: lower part
        part_mode = True: higher part

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorNewGeneralApi.vec_unpack_params("vectorized_vpack", dst, src, part_mode)
        return self._vector_pack_unpack(vec_op_params_ins, merge_mode="MODE_MERGING")

    @source_info_decorator()
    def vector_vunpack(self, dst, src, part_mode):
        """
        pack src into dst
        Parameters
        ----------
        dst: vector destination operator
        src: vector source operation
        part_mode:
        part_mode = False: lower part
        part_mode = True: higher part

        Returns
        -------
        None
        """
        vec_op_params_ins = TikVectorNewGeneralApi.vec_unpack_params("vectorized_vunpack", dst, src, part_mode)
        return self._vector_pack_unpack(vec_op_params_ins)

    @source_info_decorator()
    def vector_vbr(self, dst, br_data):
        """
        the source value in br_data broadcast to all active elements in dst
        Parameters
        ----------
        dst: vector destination operator
        br_data: input variable, support imm, scalar, expr

        Returns
        -------
        None
        """
        vec_vbr_ins = TikVectorNewGeneralApi.vec_vbr("vectorized_vbr", dst, br_data, "vector_vbr")
        return self._vector_initial_func(vec_vbr_ins)

    @source_info_decorator()
    def vector_vci(self, dst, start_index):
        """
        create vector index instruction, start index is start_index
        Parameters
        ----------
        dst: vector destination operator
        start_index: start index, support imm, scalar, expr

        Returns
        -------
        None
        """
        vec_vbr_ins = TikVectorNewGeneralApi.vec_vbr("vectorized_vci", dst, start_index, "vector_vci")
        return self._vector_initial_func(vec_vbr_ins)

    @source_info_decorator()
    def vector_vselr(self, dst, src0, src1):
        """
        do select elements according src0, src1
        Parameters
        ----------
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation

        Returns
        -------
        None
        """
        self.check_vselr_params('vectorized_vselr', dst, src0, src1)
        # code gen
        vec_op_params_ins = TikVectorNewGeneralApi.vec_op_params("vectorized_vselr", None, dst, None, None, src0, src1)
        return self._vector_vselr_func(vec_op_params_ins)

    @source_info_decorator()
    def vector_filter1d(self, dst, src, window_size, line_num,
                        dst_stride, src_stride, r1c1, r1c2, r1c3,
                        r1c4, r1c5, r1t, r2t, r3t, r4t, r5t, rsah, rsa):
        """
        fifr1 instruction
        """
        name = "vector_filter1d"
        api_name = "vector_filter1d"
        vec_filter1d_ins = TikVectorNewGeneralApi.vec_filter1d(name, api_name, dst, src, window_size, line_num,
                                                               dst_stride, src_stride, r1c1, r1c2, r1c3,
                                                               r1c4, r1c5, r1t, r2t, r3t, r4t, r5t, rsah, rsa)
        self._check_filter_params(vec_filter1d_ins)
        self.check_params_obj.check_filter1d(vec_filter1d_ins)
        self.fifr1_gen_code(vec_filter1d_ins)

    @source_info_decorator()
    def vector_vusqz(self, dst, src):
        """
        Ensqueeze dst according to src. For each element, the number of 1s from the first element to the previous
        element of the current element is counted.
        Parameters
        ----------
        dst: vector destination operator
        src: vector source operation

        Returns
        -------
        None
        """

        vec_op_params_ins = TikVectorNewGeneralApi.vec_op_params("vectorized_vusqz", None, dst, src, None, None, None)
        return self._gen_vusqz_code(vec_op_params_ins)

    def vector_vcvt(self, dst, src, saturate_flag, part_indicator):
        """
        convert one integer data type into another integer data type
        Parameters
        ----------
        name: instr name
        dst: vector destination operator
        src: vector storing integer data

        saturate_flag:
        when saturate_flag = True, the instr is vscvt
        when saturate_flag = False, the instr is vcvt

        part_indicator:
        part_indicator can be #part or #pp

        Returns
        -------
        None
        """
        vec_cast_vfcvt_ins = TikVectorNewGeneralApi.vec_cast_vfcvt(
            None, dst, src, saturate_flag, part_indicator, None)
        _vcvt_dtype_check(vec_cast_vfcvt_ins)
        self._gen_vector_vcvt_code(vec_cast_vfcvt_ins)

    @source_info_decorator()
    def data_move_gather(self, dst, src, src_index, index_num, ele_size, dst_stride):
        """
        mvf mov instruction
        """
        sid = 0
        if TikSocManager.is_v300_610l_soc():
            dst_stride = ((dst_stride + 1) % 7)
            ele_size = (ele_size + 1) % 5
            ele_size_byte = MVF_ELE_SIZE_MAP_V300.get(ele_size)
        else:
            ele_size_byte = MVF_ELE_SIZE_MAP.get(ele_size)
        vec_data_move_gather_ins = TikVectorNewGeneralApi.vec_data_move_gather(
            dst, src, src_index, index_num, ele_size, dst_stride)
        self.check_params_obj.data_move_check(vec_data_move_gather_ins)
        # gen code
        type_args = [index_num, dst_stride, sid]
        if src_index.dtype == "uint16":
            dtype = "u16"
        else:
            dtype = "u32"

        instr_name = "mvf_gm_to_ub_b" + str(ele_size_byte) + "_" + dtype
        self.data_move_gather_gen_code(vec_data_move_gather_ins, instr_name, type_args)

    @source_info_decorator()
    def vector_filter_max(self, dst, src, window_size, line_num, dst_stride, src_stride):
        """
        vector_filter_max
        """

        vec_filter_max_min_ins = TikVectorNewGeneralApi.vec_filter_max_min(
            "vectorized_fmax", "maxfilter", "vector_filter_max", dst, src, window_size,
            line_num, dst_stride, src_stride)
        self._check_filter_params(vec_filter_max_min_ins)
        self.fmax_fmin_gen_code(vec_filter_max_min_ins)

    @source_info_decorator()
    def vector_filter_min(self, dst, src, window_size, line_num, dst_stride, src_stride):
        """
        vector_filter_min
        """
        vec_filter_max_min_ins = TikVectorNewGeneralApi.vec_filter_max_min(
            "vectorized_fmin", "minfilter", "vector_filter_min", dst, src, window_size, line_num,
            dst_stride, src_stride)
        self._check_filter_params(vec_filter_max_min_ins)
        self.fmax_fmin_gen_code(vec_filter_max_min_ins)

    @source_info_decorator()
    def vector_vintlv(self, dst0, dst1, src0, src1, dtype=None):
        """
        Interleave 2 source vectors from Vn and Vm,
        and then place the destination vector into Vd and Vd + 1.
        Parameters
        ----------
        dst0: vector destination operator
        dst1: vector destination operator
        src0: vector source operation
        src1: vector source operation
        dtype: if dst is bool dtype, dtype must be set to uint8/int8/int16/uint16/float16/int32/uint32/flaot32

        Returns
        -------
        None
        """
        instr_name = 'vectorized_vintlv'
        intlv_params_ins = TikVectorNewGeneralApi.intlv_params(instr_name, dst0, dst1, src0, src1)
        self.vdintlv_code(intlv_params_ins, dtype)

    @source_info_decorator()
    def vector_vdintlv(self, dst0, dst1, src0, src1, dtype=None):
        """
        De-interleave 2 source vectors Vn and Vm,
        and then place the destination vector into Vd and Vd + 1.
        Vd must be even.
        Parameters
        ----------
        dst0: vector destination operator
        dst1: vector destination operator
        src0: vector source operation
        src1: vector source operation
        dtype: if dst is bool dtype, dtype must be set to uint8/int8/int16/uint16/float16/int32/uint32/flaot32

        Returns
        -------
        None
        """
        instr_name = 'vectorized_vdintlv'
        intlv_params_ins = TikVectorNewGeneralApi.intlv_params(instr_name, dst0, dst1, src0, src1)
        self.vdintlv_code(intlv_params_ins, dtype)

    @source_info_decorator()
    def vector_vslide(self, dst, src0, src1, slide_size, dtype=None):
        """
        Do slide with slide_size, slide window size is VL/dtype_size
        Parameters
        ----------
        dst: vector destination operator
        src0: vector source operation
        src1: vector source operation
        slide_size: slide offset of src0
        dtype: if dst and src is bool, need input dtype to indicate the mask bit wide
        Returns
        -------
        None
        """
        instr_name = "vectorized_vslide"
        if isinstance(dst, Vector) and dst.scope == scope_preg and dtype is None:
            print_error_msg("When instruction vector_vslide's dst's dtype is bool, params dtype cannot be None")

        vec_vslide_ins = TikVectorNewGeneralApi.vec_vslide(instr_name, dst, src0, src1, dtype, slide_size)
        self.check_params_obj.check_vector_one_dst_two_src_params(instr_name, vec_vslide_ins, dtype)

        if dst.scope == scope_vreg:
            dtype = dst.dtype
        vl_t = self.get_vector_length(dtype)
        check_slide_size(instr_name, slide_size, vl_t)

        if dst.scope == scope_preg:
            instr_name = "vectorized_pslide"
            instr_name += TikUtil.bit_type(dtype)
            vec_vslide_ins = TikVectorNewGeneralApi.vec_vslide(instr_name, dst, src0, src1, dtype, slide_size)
            return self._vector_mask_slide_gen_code(vec_vslide_ins)
        # for scope_vreg
        return self._vector_vslide_gen_code(vec_vslide_ins)

    @source_info_decorator()
    def vector_vfilter(self, dst, src_list, coef0, coef1, coef2, coef3, coef4, filter_mode=None):
        """
        for instructions wfifr2 wfifr2a wfifr2s
        Parameters
        ----------
        dst: wide register, only int48
        src_list: vector register list, int16, int8, uint16, uint8
        coef0: first coefficient
        coef1: second coefficient
        coef2: third coefficient
        coef3: forth coefficient
        coef4: fifth coefficient
        filter_mode: None, "ADD", "SUB"

        Returns
        -------
        None
        """
        if get_soc_name() in (ASCEND_310B, ASCEND_610L, BS9SX2A, MC61AM21A):
            TikCheckUtil.raise_error("vector_vfilter not support %s" % (get_soc_name()))

        api_name = "vector_vfilter"
        if not isinstance(src_list, (list, tuple)):
            src_list = [src_list]
        if len(src_list) < 1:
            print_error_msg("For instruction %s, src_list cannot no element" % api_name)

        src0 = src_list[0]
        src1 = None
        # check dst src0 src1 type and dtype
        self.check_params_obj.check_vector_one_dst_one_src_params("vectorized_vfilter", dst, src0,
                                                                  "src_list first element")
        if src0.dtype in ["int8", "uint8"]:
            if len(src_list) != 1:
                print_error_msg("For instruction %s, when src0's dtype is %s, "
                                "src_list should be one Vector variable" % (api_name, src0.dtype))
        elif len(src_list) == 2:
            src1 = src_list[1]
            TikCheckUtil.check_type_match(
                src1, Vector, "Instruction %s's src_list second element should be Vector" % api_name)
            TikCheckUtil.check_equality(
                src0.dtype, src1.dtype, "Instruction %s's src_list elements' dtype should be equal" % api_name)
        else:
            print_error_msg("For instruction %s, when input Vector dtype is %s, "
                            "src_list len cannot be %s" % (api_name, src0.dtype, len(src_list)))

        # check coefficient
        check_param_type_range(
            [coef0, coef1, coef2, coef3, coef4],
            [-16, -16, -16, -16, -16], [15, 15, 15, 15, 15],
            ["coef0", "coef1", "coef2", "coef3", "coef4"], api_name)

        # check filter_mode
        if filter_mode is not None and filter_mode not in ["ADD", "SUB"]:
            print_error_msg("Intrinsic %s's filter_mode can only be [None, \"ADD\", \"SUB\"]" % api_name)
        instr_name = "vectorized_wfifr2"
        if filter_mode == "ADD":
            instr_name += "a"  # vectorized_wfifr2a
        elif filter_mode == "SUB":
            instr_name += "s"  # vectorized_wfifr2s

        vec_vfilter_ins = TikVectorNewGeneralApi.vec_vfilter(
            instr_name, dst, src0, src1, coef0, coef1, coef2, coef3, coef4, filter_mode)
        self._wfifr2_gen_code(vec_vfilter_ins)
