#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_load_image_check.py
DESC:     tik_load_image_check
CREATED:  2021-11-16 6:20 AM
MODIFIED: 2021-11-16 6:20 AM
"""
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.common.common_util import check_address_align
from tbe.tik.common.common_util import check_aipp_one_src_overflow
from tbe.tik.common.common_util import check_aipp_two_src_overflow
from tbe.tik.common.tik_get_soc_name import get_soc_core_type
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.util import check_scalar_dtype_float
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_api_constants import SCOPE_MAP
from tbe.tik.tik_lib.tik_params import INT8_MIN
from tbe.tik.tik_lib.tik_params import MIN_CSC_MATRIX
from tbe.tik.tik_lib.tik_params import MAX_CSC_MATRIX
from tbe.tik.tik_lib.tik_params import MAX_CSC_OUT_BIAS
from tbe.tik.tik_lib.tik_params import MAX_CSC_IN_BIAS
from tbe.tik.tik_lib.tik_params import BIT_LEN_8
from tbe.tik.tik_lib.tik_params import MAX_PAD_MODE
from tbe.tik.tik_lib.tik_params import INT8_MAX
from tbe.tik.tik_lib.tik_params import UINT_MIN
from tbe.tik.tik_lib.tik_params import UINT8_MAX
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AIPP_INPUT_VERSON_AND_FUNCTION
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import YUV420
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import XRGB8888
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import NC1HWC0DI_FP16
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import NC1HWC0DI_INT8
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RGB888
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import ARGB8888
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import YUYV
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import YUV422
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AYUV444
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import YUV400
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW10
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW12
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW16
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AIPP_INPUT_TYPE_SWAP_ALIGN
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import PRE_CLIP
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import SWAP
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import CSC
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import SCF
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import POST_CLIP
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import DTC
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import FLIP
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AERA_PADDING
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import STRETCH
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW24
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW_TO_16_N
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import is_610_610b_310p_aic

param_range = {
    'raw_image_channel': (0, 4),
    'raw_start_channel': (0, 4),
    'post_botton_clip_number': (0, 64),
    'post_top_clip_number': (0, 64),
    'post_right_clip_number': (0, 64),
    'post_left_clip_number': (0, 64),
    'pre_top_clip_number': (0, 2),
    'pre_botton_clip_number': (0, 2),
    "scf_horizontal_size": (16, 1921),
    "scf_vertical_size": (16, 1081),
    "scaling_mode": (0, 2),
    'area_pad_mode': (0, 4),
    'top_pad_rows': (0, 33),
    'botton_pad_rows': (0, 33),
    'left_pad_cols': (0, 33),
    'right_pad_cols': (0, 33),
    'flip_mode': (0, 4),
    'sid': (0, 11),
    "dst_stride_pixel": (0, 65536)
}


def check_param_info_type(params_info, check_range=False):
    """
    check param info type
    """
    for name, value in params_info.items():
        TikCheckUtil.check_type_match(value, (int, Scalar, Expr),
                                      "%s should be int, Scalar, Expr, input type: %s" % (name, type(value)))
        check_scalar_dtype(value, "%s should be a scalar of int/uint" % name)
        if check_range:
            param_value = Expr(value).eval_value()
            if param_value is not None and param_range.get(name) is not None:
                start, end = param_range.get(name)
                TikCheckUtil.check_in_range_by_dtype(
                    param_value, msg='%s should in [%d, %d], input: %s' % (name, start, end - 1, param_value),
                    var_range=[start, end - 1])
            if name in ['top_pad_size', 'botton_pad_size']:
                _aipp_top_area_pad_size_check(params_info.get('area_pad_mode'), name, param_value)


def aipp_check_arch_version(arch_version):
    """
    check arch version
    """
    if not TikSocManager.is_aicore_core():
        TikCheckUtil.raise_error("arch_version not support aipp, arch_version: {}".format(arch_version))


def aipp_check_input_format(arch_version, input_format):
    """
    check input format
    """
    imm_input_format = Expr(input_format).eval_value()
    if imm_input_format is not None:
        format_ = AIPP_INPUT_VERSON_AND_FUNCTION.get(arch_version).get(imm_input_format)

        if format_ is None:
            TikCheckUtil.raise_error("arch_version not support input_format: {}".format(imm_input_format))


def aipp_check_dst(input_format, dst):
    """
    check dst tensor
    """
    TikCheckUtil.check_type_match(dst, Tensor, "dst should be tensor, input: {}".format(type(dst)))
    dst_scope = SCOPE_MAP[dst.scope]
    TikCheckUtil.check_equality(dst_scope, "cbuf", "dst scope must be cubf, input: {}".format(dst_scope))
    # check l1 address 32B align
    check_address_align((dst,), ("dst",))

    TikCheckUtil.check_var_in_list(
        dst.dtype, ["uint8", "int8", "float16"], "dst type error, input type: {}".format(dst.dtype))
    imm_input_format = Expr(input_format).eval_value()
    if imm_input_format is not None:
        if imm_input_format == NC1HWC0DI_INT8:
            TikCheckUtil.check_equality(
                dst.dtype, "int8", "NC1HWC0DI_INT8 dst type must int8, input type: {}".format(dst.dtype))
        elif imm_input_format == NC1HWC0DI_FP16:
            TikCheckUtil.check_equality(
                dst.dtype, "float16", "NC1HWC0DI_FP16 dst type must float16, input type: {}".format(dst.dtype))


def aipp_check_src_info(input_format, src_horizontal_size, src_vertical_size):
    """
    check src tensor info
    """
    max_imm_src_horizontal_size = 4096
    check_param_info_type({'src_horizontal_size': src_horizontal_size, 'src_vertical_size': src_vertical_size})

    imm_src_horizontal_size = Expr(src_horizontal_size).eval_value()
    if imm_src_horizontal_size is not None:
        TikCheckUtil.check_in_range_by_dtype(
            imm_src_horizontal_size, msg="horizontal_resolution should in [{}, {}], input: {}".format(
                BIT_LEN_8, max_imm_src_horizontal_size, imm_src_horizontal_size),
            var_range=[BIT_LEN_8, max_imm_src_horizontal_size])

        imm_input_format = Expr(input_format).eval_value()
        if imm_input_format is not None:
            if imm_input_format in [YUV420, YUYV, YUV422]:
                TikCheckUtil.check_equality(
                    imm_src_horizontal_size % 2, 0,
                    "src_horizontal_size should be even, input: {}".format(imm_src_horizontal_size))

            if TikSocManager.is_hisi_soc() and imm_input_format in [YUV420, YUV422, YUYV, YUV400,
                                                                    RAW10, RAW12, RAW16, RGB888]:
                TikCheckUtil.check_equality(
                    imm_src_horizontal_size % 16, 0,
                    "src_horizontal_size should be multiple of 16, input: {}".format(imm_src_horizontal_size))
            elif TikSocManager.is_hisi_soc() and imm_input_format in [AYUV444, ARGB8888, XRGB8888]:
                TikCheckUtil.check_equality(
                    imm_src_horizontal_size % 4, 0,
                    "src_horizontal_size should be multiple of 4, input: {}".format(imm_src_horizontal_size))

    imm_src_vertical_size = Expr(src_vertical_size).eval_value()
    if imm_src_vertical_size is not None:
        TikCheckUtil.check_ge(
            imm_src_vertical_size, 1, "src_vertical_size should more than 1, input: {}".format(imm_src_vertical_size))


def aipp_check_src(input_format, src0, src1, params_val):
    """
    check src tensor
    """
    src_horizontal_size = params_val.get('src_horizontal_size')
    src_vertical_size = params_val.get('src_vertical_size')
    TikCheckUtil.check_type_match(src0, Tensor, "src0 should be Tensor, input: {}".format(type(src0)))
    src0_scope = SCOPE_MAP[src0.scope]
    TikCheckUtil.check_equality(src0_scope, "gm", "src0 scope must be gm, input scope: {}".format(src0_scope))
    # src need even number
    src_align = 2
    check_address_align((src0,), ("src0",), src_align)

    imm_input_format = Expr(input_format).eval_value()
    if imm_input_format is not None:
        TikCheckUtil.check_var_in_list(
            src0.dtype, AIPP_INPUT_TYPE_SWAP_ALIGN[imm_input_format]["type"],
            "src0 type error, input type: {}".format(src0.dtype))

        imm_src_horizontal_size = Expr(src_horizontal_size).eval_value()
        imm_src_vertical_size = Expr(src_vertical_size).eval_value()
        if src1 is None and imm_src_horizontal_size is not None and imm_src_vertical_size is not None:
            # check src extend
            check_aipp_one_src_overflow(src0, imm_input_format, imm_src_horizontal_size, imm_src_vertical_size)
        elif imm_src_horizontal_size is not None and imm_src_vertical_size is not None:
            TikCheckUtil.check_type_match(src1, Tensor, "src1 should be Tensor, input: {}".format(type(src1)))
            src1_scope = SCOPE_MAP[src1.scope]
            TikCheckUtil.check_equality(src1_scope, "gm", "src1 scope must be gm, input scope: {}".format(src1_scope))
            check_address_align((src1,), ("src1",), src_align)

            # two input
            if imm_input_format in [YUV420, NC1HWC0DI_INT8, NC1HWC0DI_FP16, YUV422]:
                TikCheckUtil.check_var_in_list(
                    src1.dtype, AIPP_INPUT_TYPE_SWAP_ALIGN[imm_input_format]["type"],
                    "src1 type error, input type: {}".format(src1.dtype))

                # check src extend
                check_aipp_two_src_overflow(
                    src0, src1, imm_input_format, imm_src_horizontal_size, imm_src_vertical_size)
            else:
                TikCheckUtil.raise_error("input_format not support two src")


def aipp_check_function_switch(function_switch):
    """
    check function_switch
    """
    if function_switch is None:
        TikCheckUtil.raise_error('function_switch not support None')

    check_param_info_type({'function_switch': function_switch})


def aipp_check_enable_bit(input_format, params_val):
    """
    check aipp function switch
    """
    imm_input_format = Expr(input_format).eval_value()
    if imm_input_format is not None:
        func = AIPP_INPUT_VERSON_AND_FUNCTION.get(params_val.get('arch_version')).get(imm_input_format)

        param_enable_info = {'pre_clip': PRE_CLIP,
                             'swap': SWAP,
                             'csc': CSC,
                             'scf': SCF,
                             'post_clip': POST_CLIP,
                             'dtc': DTC,
                             'area_pad': AERA_PADDING,
                             'stretch': STRETCH,
                             'raw': RAW,
                             'flip': FLIP}
        for name, value in param_enable_info.items():
            if params_val.get("%s_enable" % name) == 1:
                TikCheckUtil.check_var_in_list(value, func, "%s not support, input: %s" % (name, func))


def check_crop_info_range(name, value, input_format_list, value_range, imm_input_format):
    """
    check_crop_info in range
    """
    imm_value = Expr(value).eval_value()
    if imm_value is not None:
        if imm_input_format in input_format_list:
            TikCheckUtil.check_equality(imm_value % 2, 0, "%s should be even, input: %s" % (name, imm_value))
        start, end = value_range
        TikCheckUtil.check_in_range_by_dtype(imm_value, msg="%s should in [%d, %d], input: %s" % (
            name, start, end, imm_value), var_range=[start, end])


def _aipp_check_crop_info(input_format, params_val):
    """
    check crop info
    """
    single_line_mode = params_val.get('single_line_mode')
    horizontal_size = params_val.get('crop_horizontal_size')
    vertical_size = params_val.get('crop_vertical_size')
    horizontal_start = params_val.get('crop_horizontal_start')
    vertical_start = params_val.get('crop_vertical_start')

    check_info = {
        'single_line_mode': single_line_mode,
        'horizontal_size': horizontal_size,
        'vertical_size': vertical_size,
        'horizontal_start': horizontal_start,
        'vertical_start': vertical_start
    }
    check_param_info_type(check_info)

    imm_input_format = Expr(input_format).eval_value()
    imm_single_line_mode = Expr(single_line_mode).eval_value()
    if imm_input_format is not None:
        check_crop_info_range('horizontal_size', horizontal_size, [YUV420, YUYV, YUV422],
                              (8, 4096), imm_input_format)
        check_crop_info_range('horizontal_start', horizontal_start,
                              [YUV420, YUYV, YUV422, XRGB8888, NC1HWC0DI_INT8, NC1HWC0DI_FP16, RGB888, YUV400],
                              (0, 4095), imm_input_format)
        if imm_single_line_mode is not None and imm_single_line_mode == 0:
            check_crop_info_range('vertical_size', vertical_size, [YUV420],
                                  (8, 4096), imm_input_format)
            check_crop_info_range('vertical_start', vertical_start,
                                  [YUV420, XRGB8888, NC1HWC0DI_INT8, NC1HWC0DI_FP16, RGB888, YUV400],
                                  (0, 4095), imm_input_format)


def _aipp_check_crop_in_picture(params_val):
    """
    check crop in picture
    """
    horizontal_size = params_val.get('crop_horizontal_size')
    vertical_size = params_val.get('crop_vertical_size')
    horizontal_start = params_val.get('crop_horizontal_start')
    vertical_start = params_val.get('crop_vertical_start')
    src_horizontal_size = params_val.get('src_horizontal_size')
    src_vertical_size = params_val.get('src_vertical_size')
    imm_src_horizontal_size = Expr(src_horizontal_size).eval_value()
    imm_horizontal_start = Expr(horizontal_start).eval_value()
    if imm_src_horizontal_size is not None and imm_horizontal_start is not None:
        # range
        TikCheckUtil.check_in_range_by_dtype(
            imm_horizontal_start, msg='horizontal_start should in src_horizontal_size, input: {}'.format(
                imm_horizontal_start), var_range=[0, imm_src_horizontal_size])

        imm_horizontal_size = Expr(horizontal_size).eval_value()
        if imm_horizontal_size is not None:
            # range
            TikCheckUtil.check_in_range_by_dtype(
                imm_horizontal_start + imm_horizontal_size, msg='horizontal_start+horizontal_size '
                'should in src_horizontal_size, input: {}'.format(imm_horizontal_start + imm_horizontal_size),
                var_range=[0, imm_src_horizontal_size])

    imm_src_vertical_size = Expr(src_vertical_size).eval_value()
    imm_vertical_start = Expr(vertical_start).eval_value()
    if imm_src_vertical_size is not None and imm_vertical_start is not None:
        # range
        TikCheckUtil.check_in_range_by_dtype(
            imm_vertical_start, msg='imm_vertical_start should in src_vertical_size, imm_vertical_start: {}'.format(
                imm_vertical_start), var_range=[0, imm_src_vertical_size])

        imm_vertical_size = Expr(vertical_size).eval_value()
        if imm_vertical_size is not None:
            # range
            TikCheckUtil.check_in_range_by_dtype(
                imm_vertical_start + imm_vertical_size, msg="vertical_start + vertical_size "
                "should in src_vertical_size, vertical_start + vertical_size: {}".format(
                    vertical_start + vertical_size), var_range=[0, imm_src_vertical_size])


def _aipp_check_crop_single_line_mode(single_line_mode):
    """
    check crop single line mode
    """
    imm_single_line_mode = Expr(single_line_mode).eval_value()
    if imm_single_line_mode is not None:
        if TikSocManager.is_hisi_soc() or TikSocManager.is_910b_soc() or TikSocManager.is_cloud_core():
            TikCheckUtil.check_equality(
                imm_single_line_mode, 0,
                'single_line_mode value error, input: {}'.format(imm_single_line_mode))
        else:
            TikCheckUtil.check_var_in_list(
                imm_single_line_mode, [0, 1],
                'single_line_mode should in [0, 1], input: {}'.format(imm_single_line_mode))


def _check_crop_vertical_size_by_single_line(crop_vertical_size, single_line_mode):
    if is_610_610b_310p_aic() or not TikSocManager.is_mini_soc():
        imm_single_line_mode = Expr(single_line_mode).eval_value()
        if imm_single_line_mode is not None and imm_single_line_mode == 1:
            imm_crop_vertical_size = Expr(crop_vertical_size).eval_value()
            if imm_crop_vertical_size is not None:
                TikCheckUtil.check_equality(
                    imm_crop_vertical_size, 1,
                    'crop_vertical_size should be 1 when single_line_mode enable')


def aipp_check_crop_info(input_format, params_val):
    """
    check crop_info param
    """
    _aipp_check_crop_info(input_format, params_val)
    _aipp_check_crop_in_picture(params_val)
    single_line_mode = params_val.get('single_line_mode')
    _aipp_check_crop_single_line_mode(single_line_mode)
    crop_vertical_size = params_val.get('crop_vertical_size')
    _check_crop_vertical_size_by_single_line(crop_vertical_size, single_line_mode)


def aipp_check_format_convert(format_convert, is_scalar=False):
    """
    check format convert
    """
    TikCheckUtil.check_type_match(
        format_convert, int,
        "format_convert should be int, input: {}".format(type(format_convert)))

    # Whether the CSC function is enabled cannot be obtained during compilation.
    if not is_scalar:
        if TikSocManager.is_hisi_soc():
            # format_convert_list is CSC mode supported by the current SOC,
            # csc mode in data_move_common file's AIPP_FORMAT_CONVERT
            format_convert_list = [0, 10, 11, 12, 13, 14, 15, 16, 17]
            TikCheckUtil.check_var_in_list(
                format_convert, format_convert_list,
                'format_convert should be 0  or in [10, 17] for v200hisi-es, input: {}'.format(format_convert))
        else:
            # format_convert_list is CSC mode supported by the current SOC,
            # csc mode in data_move_common file's AIPP_FORMAT_CONVERT
            format_convert_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 18]
            TikCheckUtil.check_var_in_list(
                format_convert, format_convert_list,
                msg='format_convert should in {} for arch_version not hs, input: {} {}'.format(
                    format_convert_list, get_soc_name() + get_soc_core_type(), format_convert))


def _check_matrix_type_and_range(matrix, shape, in_type, input_range=None):
    """
    check matrix type and range
    """
    # matrix
    if len(matrix) != shape[0] or len(matrix[0]) != shape[1]:
        TikCheckUtil.raise_error("csc_matrix shape error,should 3*3")

    for i in range(shape[0]):
        for j in range(shape[1]):
            TikCheckUtil.check_type_match(
                matrix[i][j], in_type, "csc_matrix type error, input: {}".format(matrix[i][j]))
            check_scalar_dtype(
                matrix[i][j], "csc_matrix[{}][{}] should be a scalar of int/uint".format(str(i), str(j)))
            if not input_range:
                continue
            imm_matrix = Expr(matrix[i][j]).eval_value()
            if imm_matrix is not None:
                imm_matrix_range = [input_range[0], input_range[1]]
                TikCheckUtil.check_in_range_by_dtype(
                    imm_matrix, msg="csc_matrix[{}][{}] number out of range".format(str(i), str(j)),
                    var_range=imm_matrix_range)


def check_list_type_and_range(input_list, length, in_type, input_range=None, name=''):
    """
    check list type and range
    """
    if input_list is None:
        TikCheckUtil.raise_error(name + " is None")

    if len(input_list) != length:
        TikCheckUtil.raise_error(name + "input_list length error, input: {}".format(len(input_list)))

    for i in range(length):
        TikCheckUtil.check_type_match(
            input_list[i], in_type, name + "{}[{}] type error".format(name, str(i)))

        if int in in_type:
            check_scalar_dtype(input_list[i], "{}[{}] should be a scalar of int/uint".format(name, str(i)))
            if not input_range:
                continue
            imm_input = Expr(input_list[i]).eval_value()
            if imm_input is not None:
                imm_input_range = [input_range[0], input_range[1]]
                TikCheckUtil.check_in_range_by_dtype(
                    imm_input, msg="{}[{}] out of range".format(name, str(i)), var_range=imm_input_range)
        else:
            check_scalar_dtype_float(input_list[i], "{}[{}] should be a scalar of float".format(name, str(i)))


def aipp_check_csc_info(csc_matrix, csc_out_bias, csc_in_bias):
    """
    check csc info
    """
    if not any(v is None for v in (csc_matrix, csc_out_bias, csc_in_bias)):
        _check_matrix_type_and_range(
            csc_matrix, [3, 3], (int, Scalar, Expr), (MIN_CSC_MATRIX, MAX_CSC_MATRIX))
        check_list_type_and_range(
            csc_out_bias, 3, (int, Scalar, Expr), (0, MAX_CSC_OUT_BIAS), 'csc_out_bias')
        check_list_type_and_range(
            csc_in_bias, 3, (int, Scalar, Expr), (0, MAX_CSC_IN_BIAS), 'csc_in_bias')


def aipp_check_swap(input_format, rb_swap, uv_swap, ax_swap):
    """
    check swap info
    """
    imm_input_format = Expr(input_format).eval_value()
    if imm_input_format is not None:
        imm_rb_swap = Expr(rb_swap).eval_value()
        if imm_rb_swap is not None:
            TikCheckUtil.check_var_in_list(
                imm_rb_swap, AIPP_INPUT_TYPE_SWAP_ALIGN.get(imm_input_format).get('swap')[0],
                'rb_swap not support, input_format: {}'.format(imm_input_format))

        imm_uv_swap = Expr(uv_swap).eval_value()
        if imm_uv_swap is not None:
            TikCheckUtil.check_var_in_list(
                imm_uv_swap, AIPP_INPUT_TYPE_SWAP_ALIGN.get(imm_input_format).get('swap')[1],
                'uv_swap not support, input_format: {}'.format(imm_input_format))

        imm_ax_swap = Expr(ax_swap).eval_value()
        if imm_ax_swap is not None:
            TikCheckUtil.check_var_in_list(
                imm_ax_swap, AIPP_INPUT_TYPE_SWAP_ALIGN.get(imm_input_format).get('swap')[2],
                'ax_swap not support, input_format: {}'.format(imm_input_format))


def aipp_check_pre_clip(pre_top_clip_number, pre_botton_clip_number, crop_vertical_size):
    """
    check pre clip
    """
    check_info = {
        'pre_top_clip_number': pre_top_clip_number,
        'pre_botton_clip_number': pre_botton_clip_number
    }
    check_param_info_type(check_info, check_range=True)

    imm_crop_vertical_size = Expr(crop_vertical_size).eval_value()
    if pre_top_clip_number is not None and pre_botton_clip_number \
            is not None and imm_crop_vertical_size is not None:
        TikCheckUtil.check_ge(imm_crop_vertical_size, pre_top_clip_number + pre_botton_clip_number + 1,
                              'crop_vertical_size should more than 0, after preclip, crop_vertical_size: {}'.format(
                                  crop_vertical_size))


def aipp_check_scf(scf_horizontal_size, scf_vertical_size, scf_horizontal_start, scf_vertical_start, scaling_mode):
    """
    check scf info
    """
    check_info = {
        "scf_horizontal_size": scf_horizontal_size,
        "scf_vertical_size": scf_vertical_size,
        "scf_horizontal_start": scf_horizontal_start,
        "scf_vertical_start": scf_vertical_start,
        "scaling_mode": scaling_mode
    }
    check_param_info_type(check_info, check_range=True)


def aipp_check_dtc_raw_info(raw_to_f16_n):
    """
    check dtc raw info
    """
    check_param_info_type({'raw_to_f16_n': raw_to_f16_n})
    imm_raw_to_f16_n = Expr(raw_to_f16_n).eval_value()
    if imm_raw_to_f16_n is not None:
        TikCheckUtil.check_var_in_list(
            imm_raw_to_f16_n, RAW_TO_16_N, 'raw_to_f16_n should be 0 or in [8, 16], input: {}'.format(imm_raw_to_f16_n))


def aipp_check_flip_dict(flip_mode):
    """
    check flip mode
    Parameters
    ----------
    arch_version_str: arch_version_str
    flip_mode: 0-3

    Returns
    -------
    no return
    """
    if TikSocManager.is_hisi_soc():
        check_param_info_type({'flip_mode': flip_mode}, check_range=True)


def aipp_check_cpad(dst_type, sfr_cpadding, cpadding_mode):
    """
    check cpadding
    """
    check_param_info_type({'cpadding_mode': cpadding_mode})

    imm_cpadding_mode = Expr(cpadding_mode).eval_value()
    if imm_cpadding_mode is not None:
        # C PADDING
        TikCheckUtil.check_in_range_by_dtype(
            imm_cpadding_mode, msg='cpadding_mode should in [{}, {}], input: {}'.format(
                0, MAX_PAD_MODE, imm_cpadding_mode), var_range=[0, MAX_PAD_MODE])
        if imm_cpadding_mode == 1:
            TikCheckUtil.check_equality(TikSocManager.is_hisi_soc(), True,
                                        'only v200hisi support no padding, now: {}'.format(
                                            get_soc_name() + get_soc_core_type()))
        else:
            if dst_type == 'float16':
                TikCheckUtil.check_type_match(sfr_cpadding, (float, Scalar, Expr),
                                              "sfr_cpadding type error, input: {}".format(type(sfr_cpadding)))
                check_scalar_dtype_float(sfr_cpadding, "sfr_cpadding should be a scalar of int/uint")
            elif dst_type == 'int8':
                check_param_info_type({'sfr_cpadding': sfr_cpadding})
                imm_sfr_cpadding = Expr(sfr_cpadding).eval_value()
                if imm_sfr_cpadding is not None:
                    TikCheckUtil.check_in_range_by_dtype(
                        imm_sfr_cpadding, "int8", "sfr_cpadding should in [{}, {}], input: {}".format(
                            INT8_MIN, INT8_MAX, imm_sfr_cpadding))
            else:
                check_param_info_type({'sfr_cpadding': sfr_cpadding})
                imm_sfr_cpadding = Expr(sfr_cpadding).eval_value()
                if imm_sfr_cpadding is not None:
                    TikCheckUtil.check_in_range_by_dtype(
                        imm_sfr_cpadding, "uint8", "sfr_cpadding should in [{}, {}], input: {}".format(
                            UINT_MIN, UINT8_MAX, imm_sfr_cpadding))


def _aipp_top_area_pad_size_check(padding_mode, name, imm_top_pad_size):
    """
    check top area padding
    """
    if not TikSocManager.is_vector_core() and not TikSocManager.is_hisi_soc():
        imm_padding_mode = Expr(padding_mode).eval_value()
        if imm_padding_mode is not None:
            if imm_padding_mode == 0:
                arch_version = get_soc_name() + get_soc_core_type()
                TikCheckUtil.check_equality(
                    imm_top_pad_size, 0, '%s do not support %s' % (arch_version, name))


def _aipp_check_config_pad_value(imm_padding_mode, input_format, dst_type, filling_hblank):
    """
    check padding config value
    """
    # check config value padding
    imm_input_format = Expr(input_format).eval_value()
    if imm_input_format is not None and isinstance(imm_padding_mode, int) and imm_padding_mode == 0:
        if imm_input_format not in [NC1HWC0DI_FP16, NC1HWC0DI_INT8, RAW24, RAW16, RAW12, RAW10]:
            if dst_type == 'float16':
                check_list_type_and_range(filling_hblank, 4, (float, Scalar, Expr), None, 'filling_hblank')
            elif dst_type == 'int8':
                check_list_type_and_range(filling_hblank, 4, (int, Scalar, Expr),
                                          (INT8_MIN, INT8_MAX), 'filling_hblank')
            else:
                check_list_type_and_range(filling_hblank, 4, (int, Scalar, Expr),
                                          (UINT_MIN, UINT8_MAX), 'filling_hblank')


def aipp_check_area_pad(input_format, dst_type, area_pad_list, filling_hblank):
    """
    check area padding
    """
    # function's input params is too much, so disable them
    check_info = {
        'area_pad_mode': area_pad_list[0],
        'top_pad_rows': area_pad_list[1],
        'botton_pad_rows': area_pad_list[2],
        'left_pad_cols': area_pad_list[3],
        'right_pad_cols': area_pad_list[4],
    }
    check_param_info_type(check_info, check_range=True)

    # check config value padding
    _aipp_check_config_pad_value(area_pad_list[0], input_format, dst_type, filling_hblank)


def aipp_check_stretch(dst_stride_pixel):
    """
    check stretch
    """
    check_param_info_type({'dst_stride_pixel': dst_stride_pixel}, check_range=True)


def aipp_check_raw_info(raw_image_channel, raw_start_channel):
    """
    check raw info
    """
    check_param_info_type({'raw_image_channel': raw_image_channel, 'raw_start_channel': raw_start_channel},
                          check_range=True)


def aipp_check_post_clip(post_botton_clip_number, post_top_clip_number,
                         post_right_clip_number, post_left_clip_number):
    """
    check post clip
    """
    check_info = {
        'post_botton_clip_number': post_botton_clip_number,
        'post_top_clip_number': post_top_clip_number,
        'post_right_clip_number': post_right_clip_number,
        'post_left_clip_number': post_left_clip_number,
    }
    check_param_info_type(check_info, check_range=True)


def aipp_check_dtc_mean(dtc_mean_type, dtc_mean):
    """
    check dtc mean
    """
    check_param_info_type({'dtc_mean_type': dtc_mean_type})

    # dtc mean uint8/int8/b24
    imm_dtc_mean_type = Expr(dtc_mean_type).eval_value()
    if imm_dtc_mean_type is not None:
        TikCheckUtil.check_var_in_list(
            imm_dtc_mean_type, [0, 1],
            'dtc_mean_type out of range, input: {}'.format(imm_dtc_mean_type))

        if imm_dtc_mean_type == 0:
            check_list_type_and_range(
                dtc_mean, 4, (int, Scalar, Expr), None, 'dtc_mean')
        else:
            check_list_type_and_range(
                dtc_mean, 4, (float, Scalar, Expr), None, 'dtc_mean')


def aipp_check_sid(sid):
    """
    check sid
    """
    check_param_info_type({'sid': sid}, check_range=True)


def check_dst_extent(dst, dst_extent):
    """
    check dst_extent
    """
    if dst_extent is not None:
        TikCheckUtil.check_le(
            dst_extent, dst.buffer_size, "output out of dst size, input: {}".format(dst_extent))
        TikCheckUtil.check_equality(
            dst_extent % 32, 0, "output should be 32 align, input: {}".format(dst_extent))
