#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_proposal_util.py
DESC:     provide proposal instructions
CREATED:  2021-12-2 18:53:42
MODIFIED: 2021-12-2 19:17:00
"""
from tbe import tvm
from tbe.tik.common.common_check_func import check_overlapping_vmrgsort4
from tbe.tik.common.common_check_func import check_overlapping_vmrgsort
from tbe.common.platform import scope_ubuf
from tbe.common.platform import intrinsic_check_support
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import reduce_mul
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_params import SRC_LIST_LEN
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_params import VMS4_SR_ARRAY_LEN
from tbe.tik.tik_lib.tik_expr import is_basic_expr

# one proposal contanis 8 elements
_ELEMENTS_COUNT = 8
# each repeat computes 16 proposals
_PROPOSAL_NUM = 16
# element number per proposal
_ELEMENTS_PER_PROPOSAL = 8


def count_bit_1(num):
    """
    count number of bit 1 in integer num

    Parameters
    ----------
    num: input integer

    Returns
    -------
    ret: number of bit 1 in num
    """
    ret = 0
    while num > 0:
        ret += num & 1
        num = num >> 1
    return ret


def get_vms4_addr_align(dst):
    """
    get vms4 instr address align size
    """
    if dst.dtype == "float16":
        align = 16
    else:
        align = 32
    return align


def check_vms4_dst_tensor_overflow(dst, element_count_list, valid_bit, repeat_times, if_exhausted_suspension):
    """
    check vms dst tensor overflow, cannot check repeat condition and
    is_exhausted_suspension = True

    Parameters
    ----------
    dst: dst tensor
    element_count_list : length of the proposal list
    valid_bit:  0001 one lines are valid
    -           0011 two lines are valid
    -           0111 three lines are valid
    -           1111 four lines are valid
    repeat_times: repeat_times: times of invoke this instrction
    if_exhausted_suspension : 0 not stop, 1 stop

    Returns
    -------
    None
    """
    element_dst_count_list = []
    valid_bit = Expr(valid_bit).eval_value()
    if valid_bit is None:
        return
    for value in element_count_list:
        element_value = Expr(value).eval_value()
        if element_value is not None:
            element_dst_count_list.append(element_value)
        else:
            return
    if if_exhausted_suspension is True or valid_bit != 15 or \
            len(set(element_dst_count_list)) != 1:
        repeat_times = 1

    index = count_bit_1(valid_bit)
    least_expected_dst_ele = (sum(element_dst_count_list[0: index]) +
                              (repeat_times - 1) * sum(element_dst_count_list)) * _ELEMENTS_PER_PROPOSAL + dst.offset

    actual_dst_ele = reduce_mul(dst.original_shape)
    least_expected_dst_ele = Expr(least_expected_dst_ele).eval_value()
    actual_dst_ele = Expr(actual_dst_ele).eval_value()
    if all(value is not None for value in (actual_dst_ele, least_expected_dst_ele)):
        TikCheckUtil.check_ge(
            actual_dst_ele, least_expected_dst_ele,
            "dst tensor overflow, expected elements at least: %s, actual "
            "elements: %s" % (least_expected_dst_ele, actual_dst_ele))


def check_vms4_src_tensor_overflow(src_list, element_count_list, valid_bit, repeat_times, if_exhausted_suspension):
    """
    check vms src tensor overflow, cannot check repeat condition

    Parameters
    ----------
    src_list : source operation list
    element_count_list : length of the proposal list
    valid_bit:  0001 one lines are valid
    -           0011 two lines are valid
    -           0111 three lines are valid
    -           1111 four lines are valid
    repeat_times: repeat_times: times of invoke this instrction
    if_exhausted_suspension : 0 not stop, 1 stop

    Returns
    -------
    None
    """
    element_src_count_list = []
    valid_bit = Expr(valid_bit).eval_value()
    if valid_bit is None:
        return
    for value in element_count_list:
        element_value = Expr(value).eval_value()
        if element_value is not None:
            element_src_count_list.append(element_value)
        else:
            return
    if if_exhausted_suspension is True or valid_bit != 15 or \
            len(set(element_src_count_list)) != 1:
        repeat_times = 1
    # valid_bit(binary) contains 1/2/3/4 bit1, check 1/2/3/4 src tensor
    index = 0
    while valid_bit > 0:
        actual_src_ele = reduce_mul(src_list[index].original_shape)
        expected_src_ele = (element_src_count_list[index] + (repeat_times - 1) * \
                           sum(element_src_count_list)) * _ELEMENTS_PER_PROPOSAL + \
                           src_list[index].offset

        actual_src_ele = Expr(actual_src_ele).eval_value()
        expected_src_ele = Expr(expected_src_ele).eval_value()
        if all(value is not None for value in (actual_src_ele, expected_src_ele)):
            TikCheckUtil.check_ge(
                actual_src_ele, expected_src_ele,
                "src_list[%s] tensor overflow, expected elements: %s, "
                "actual elements: %s" % (index, expected_src_ele, actual_src_ele))
        valid_bit = valid_bit >> 1
        index += 1


def check_vms4_tensor_overlap(dst, src_list, element_count_list, valid_bit, repeat_times):
    """
    check vms tensor overlap

    Parameters
    ----------
    dst : dst tensor
    src_list : source operation list
    valid_bit:  0001 one lines are valid
    -           0011 two lines are valid
    -           0111 three lines are valid
    -           1111 four lines are valid
    element_count_list : length of the proposal list
    repeat_times: repeat_times: times of invoke this instrction

    Returns
    -------
    None
    """
    for i, src in enumerate(src_list):
        if dst.buffer is src.buffer and isinstance(valid_bit, int) and (valid_bit & (1 << i)):
            check_overlapping_vmrgsort4(dst.offset, src.offset,
                                        element_count_list, repeat_times, i)


def check_vms4v2_dst_tensor_overflow(dst, element_count_list, repeat_times, if_exhausted_suspension):
    """
    check vms dst tensor overflow, cannot check repeat condition and
    is_exhausted_suspension = True

    Parameters
    ----------
    dst: dst tensor
    element_count_list : length of the proposal list
    repeat_times: repeat_times: times of invoke this instrction
    if_exhausted_suspension : 0 not stop, 1 stop

    Returns
    -------
    None
    """
    for value in element_count_list:
        if Expr(value).eval_value() is None:
            return
    element_count_list = [Expr(value).eval_value() for value in element_count_list]
    if if_exhausted_suspension is True or len(element_count_list) != SRC_LIST_LEN or \
            len(set(element_count_list)) != 1:
        repeat_times = 1
    expected_op_value = (repeat_times - 1) * element_count_list[0] * SRC_LIST_LEN
    least_expected_dst_ele = (sum(element_count_list) + expected_op_value) * 8 // DTYPE_SIZE[dst.dtype] + dst.offset

    actual_dst_ele = reduce_mul(dst.original_shape)
    least_expected_dst_ele = Expr(least_expected_dst_ele).eval_value()
    actual_dst_ele = Expr(actual_dst_ele).eval_value()
    if all(value is not None for value in (actual_dst_ele, least_expected_dst_ele)):
        TikCheckUtil.check_ge(
            actual_dst_ele, least_expected_dst_ele,
            "dst tensor overflow, expected elements at least: %s, actual "
            "elements: %s" % (least_expected_dst_ele, actual_dst_ele))


def check_vms4v2_src_tensor_overflow(src_list, element_count_list, repeat_times, if_exhausted_suspension):
    """
    check vms src tensor overflow, cannot check repeat condition

    Parameters
    ----------
    src_list : source operation list
    element_count_list : length of the proposal list
    repeat_times: repeat_times: times of invoke this instrction
    if_exhausted_suspension : 0 not stop, 1 stop

    Returns
    -------
    None
    """
    for value in element_count_list:
        if Expr(value).eval_value() is None:
            return
    element_count_list = [Expr(value).eval_value() for value in element_count_list]
    if if_exhausted_suspension is True or len(element_count_list) != SRC_LIST_LEN or \
            len(set(element_count_list)) != 1:
        repeat_times = 1

    for index, src in enumerate(src_list):
        actual_src_ele = reduce_mul(src.original_shape)
        expected_op_value = (repeat_times - 1) * element_count_list[0] * SRC_LIST_LEN
        expected_src_ele = (element_count_list[index] + expected_op_value) * 8 // DTYPE_SIZE[src.dtype] + src.offset

        actual_src_ele = Expr(actual_src_ele).eval_value()
        expected_src_ele = Expr(expected_src_ele).eval_value()
        if all(value is not None for value in (actual_src_ele, expected_src_ele)):
            TikCheckUtil.check_ge(
                actual_src_ele, expected_src_ele,
                "src_list[%s] tensor overflow, expected elements: %s, "
                "actual elements: %s" % (index, expected_src_ele, actual_src_ele))


def check_vms4v2_tensor_overlap(dst, src_list, element_count_list, repeat_times):
    """
    check vms tensor overlap

    Parameters
    ----------
    dst : dst tensor
    src_list : source operation list
    element_count_list : length of the proposal list
    repeat_times: repeat_times: times of invoke this instrction

    Returns
    -------
    None
    """
    for i, src in enumerate(src_list):
        if dst.buffer is src.buffer:
            check_overlapping_vmrgsort((dst.offset, src.offset,
                                        element_count_list, repeat_times, dst.dtype, i))


def check_overflow(tensor, extent, tensor_name):
    """
    check tensor overflow

    Parameters
    ----------
    tensor : tensor operation
    extent : max offset of calculate tensor
    tensor_name : operation name

    Returns
    -------
    None
    """
    total_size = reduce_mul(tensor.original_shape)
    offset = tensor.offset
    # check if offset is a Tik Expr
    # switch offset & extent if offset is not a Tik Expr
    if isinstance(offset, Expr):
        total_offset = Expr(offset + extent).eval_value()
    else:
        total_offset = Expr(extent + offset).eval_value()
    if total_offset is not None:
        TikCheckUtil.check_ge(
            total_size, total_offset,
            "%s tensor overflow, expected elements: %s, actual elements: %s"
            % (tensor_name, total_offset, total_size))


def check_special_intrin_func_overflow(name, dst, src_list, repeat_times):
    """
    for proposal api, check tensor overflow

    Parameters
    ----------
    name : instruction name
    dst : destination operator
    src_list : the list of source operation
    repeat_times : Repeated iterations times

    Returns
    -------
    None
    """
    if Expr(repeat_times).eval_value() is None:
        return
    if name == "vaadd":
        check_overflow(dst, repeat_times*_PROPOSAL_NUM*_PROPOSAL_NUM,
                        "dst")
        check_overflow(src_list[0], repeat_times*_PROPOSAL_NUM, "src0")
        check_overflow(src_list[1], _PROPOSAL_NUM, "src1")
    elif name == "viou":
        check_overflow(dst, repeat_times*_PROPOSAL_NUM*_PROPOSAL_NUM,
                        "dst")
        check_overflow(src_list[0],
                        repeat_times*_PROPOSAL_NUM*_ELEMENTS_COUNT, "src0")
        check_overflow(src_list[1], _PROPOSAL_NUM*_ELEMENTS_COUNT, "src1")
    elif name == "vconcat":
        check_overflow(dst, repeat_times*_PROPOSAL_NUM*_ELEMENTS_COUNT,
                        "dst")
        check_overflow(src_list[0], repeat_times*_PROPOSAL_NUM, "src")
    elif name == "vrpac":
        check_overflow(dst, repeat_times*_PROPOSAL_NUM, "dst")
        check_overflow(src_list[0],
                        repeat_times*_PROPOSAL_NUM*_ELEMENTS_COUNT, "src")
    elif name == "vbitsort":
        check_overflow(dst, repeat_times*_PROPOSAL_NUM*_ELEMENTS_COUNT, "dst")
        check_overflow(src_list[0],
                        repeat_times*_PROPOSAL_NUM*_ELEMENTS_COUNT, "src")


def addr_array_make(tik_instance, tensor_list, addr_array_name):
    """
    help generate the input array in VA mode.
    tensor_list -> address_list

    Parameters
    ----------
    tik_instance : tik
    tensor_list : the list of tensor
    addr_array_name: the variable name, type string

    Returns
    -------
    list
    """
    TikCheckUtil.check_type_match(tensor_list, (list, tuple),
                                  "tensor_list should be list or tuple")
    addr_list = []
    scope = None
    dtype = None
    for i in tensor_list:
        TikCheckUtil.check_type_match(i, Tensor,
                                      "element of tensor_list must be Tensor")
        if scope is None:
            scope = i.scope
        else:
            TikCheckUtil.check_equality(scope, i.scope,
                                        "scope should be equal to each other")
        if dtype is None:
            dtype = i.dtype
        else:
            TikCheckUtil.check_equality(dtype, i.dtype,
                                        "dtype should be equal to each other")
        addr_list.append(i.access_ptr("r"))

    tmp_node = tvm.tir.Evaluate(tvm.call_extern(dtype, "addr_array", scope, addr_array_name, *addr_list))
    tik_instance.source_info.set_node_span(tmp_node)
    return tmp_node


def check_tensor_and_scope(dst):
    """
    check tensor and scope
    Parameters
    ----------
    dst : dst tensor

    Returns
    -------
    None
    """
    TikCheckUtil.check_type_match(dst, Tensor, "dst should be tensor, input type of dst: %s" % type(dst))
    TikCheckUtil.check_equality(dst.scope, scope_ubuf, "dst scope should be ub, input scope: %s" % dst.scope)


def check_vms4_src_list(src_list):
    """
    check vms4 src list
    Parameters
    ----------
    src_list : src tensor list

    Returns
    -------
    None
    """
    TikCheckUtil.check_type_match(src_list, (list, tuple),
                                  "src_list should be list or tuple, input type of src_list: %s" % type(src_list))
    TikCheckUtil.check_equality(len(src_list), SRC_LIST_LEN,
                                "the length of src_list should be 4, length of input src_list: %s." % len(src_list))


def check_vms_src_list(src_list):
    """
    check vms src list
    Parameters
    ----------
    src_list : src tensor list

    Returns
    -------
    None
    """
    TikCheckUtil.check_type_match(src_list, (list, tuple),
                                  "src_list should be list or tuple, input type of src_list: %s" % type(src_list))
    length_range = [2, 4]
    TikCheckUtil.check_in_range_by_dtype(
        len(src_list), msg="the length of src_list should be in [%d, %d], length of input src_list: %s."
                           % (length_range[0], length_range[1], len(src_list)), var_range=length_range)


def check_vms_vms4_dtype(dst, src_list, name, print_name):
    """
    check vms and vms4 dtype

    Parameters
    ----------
    dst : dst tensor
    src_list : src tensor list
    name : api name
    print_name : name in print log

    Returns
    -------
    None
    """
    TikCheckUtil.check_equality(dst.dtype, src_list[0].dtype,
                                "Instruction %s's src's dtype should be equal to dst's dtype" % (print_name))
    TikCheckUtil.check_equality(intrinsic_check_support("Intrinsic_" + name, dst.dtype), True,
                                gen_api_check_statement(dst.dtype, print_name))


def check_element_lengths(element_count_list, src_list, src_list_len):
    """
    check element lengths

    Parameters
    ----------
    src_list : src tensor list
    element_count_list : list of every element count
    src_list_len : length of src list

    Returns
    -------
    element_count_list
    """
    TikCheckUtil.check_type_match(
        element_count_list, (tuple, list, int, Scalar, Expr),
        "element_count_list should be tuple, list, int, Scalar or Expr, "
        "input type of element_count_list: %s" % type(element_count_list))
    if isinstance(element_count_list, (tuple, list)):
        TikCheckUtil.check_equality(
            len(element_count_list), len(src_list),
            "length of input element_count_list(length: %s) should be equal"
            " to length of src_list(length: %s)" % (len(element_count_list), len(src_list)))
        for index in range(src_list_len):
            TikCheckUtil.check_type_match(
                element_count_list[index], (int, Scalar, Expr),
                "element_count_list[%s] should be int, Scalar or Expr, "
                "input type: %s" % (index, type(element_count_list[index])))
    else:
        element_count_list = [element_count_list] * len(src_list)
    return element_count_list


def check_scalar_array_and_suspension(vms4_sr_scalar_array, if_exhausted_suspension):
    """
    check vms4_sr_scalar_array and if_exhausted_suspension

    Parameters
    ----------
    vms4_sr_scalar_array : api vms4's scalar array
    if_exhausted_suspension : if exhausted suspension

    Returns
    -------
    None
    """
    TikCheckUtil.check_type_match(
        vms4_sr_scalar_array, (list, tuple), "vms4_sr_scalar_array should be list or tuple, input type of "
                                             "vms4_sr_scalar_array: %s" % type(vms4_sr_scalar_array))
    TikCheckUtil.check_ge(
        len(vms4_sr_scalar_array), VMS4_SR_ARRAY_LEN,
        "length of vms4_sr_scalar_array should contain 4 scalars at least, "
        "input length of vms4_sr_scalar_array: %s" % len(vms4_sr_scalar_array))
    TikCheckUtil.check_equality(
        is_basic_expr(vms4_sr_scalar_array), True, "vms4_sr_scalar_array should be scalar")
    for i in range(VMS4_SR_ARRAY_LEN):
        TikCheckUtil.check_var_in_list("int", vms4_sr_scalar_array[i].dtype,
                                       "vms4_sr_scalar_array[%d] should be a Scalar of int/uint." % i)
    if not if_exhausted_suspension:
        TikCheckUtil.raise_error("vms4_sr can't be read in non-exhausted mode.")
