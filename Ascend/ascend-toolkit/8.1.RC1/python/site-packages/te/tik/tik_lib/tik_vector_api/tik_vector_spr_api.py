#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_spr_api.py
DESC:
CREATED:  2021-12-03 15:40
MODIFIED: 2021-12-03 15:40
"""
from tbe import tvm
from tbe.common.platform import scope_ubuf
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.common.common_util import vec_template_align
from tbe.tik.common.common_util import check_address_align
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_spr_debug import mov_cmpmask_to_tensor_decorator
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_spr_debug import mov_tensor_to_cmpmask_decorator
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import CMPMASK_VAR
from tbe.tik.tik_lib.tik_source_info import source_info_decorator


class SPROpsApi(TikIRBuilder):
    """
    Move Cmpmask To Tensor
    """
    @staticmethod
    def check_cmpmask_to_tensor_param(dst, src_cmpmask):
        """
        Move Cmpmask To Tensor gen_code
        Parameters
        ----------
        dst: target tensor, uint64
        src_cmpmask: the result of vcmp/scatter_vcmp

        Returns
        -------
        None
        """
        TikCheckUtil.check_is(src_cmpmask, CMPMASK_VAR, "src_cmpmask is error")

        TikCheckUtil.check_type_match(dst, Tensor, "dst should be tensor")
        TikCheckUtil.check_var_in_list(dst.dtype, ["uint8", "uint16", "uint32", "uint64"],
                                       "dst's dtype should be uint8, uint16, uint32 or uint64")
        # check tensor scope
        TikCheckUtil.check_equality(dst.scope, scope_ubuf, "dst's scope must be UB")
        # check UB address 32B align
        align = vec_template_align(dst.dtype)
        check_address_align((dst,), ("dst",), align)

    @source_info_decorator()
    def mov_cmpmask_to_tensor(self, dst, src_cmpmask):
        """
        move the data from vcmp/scatter_vcmp to dst tensor

        Parameters
        ----------
        dst : target tensor, uint64
        src_cmpmask : the result of vcmp/scatter_vcmp

        Returns
        -------
        None
        """
        self.check_cmpmask_to_tensor_param(dst, src_cmpmask)
        self.gen_code(dst, src_cmpmask)

    @mov_cmpmask_to_tensor_decorator
    def gen_code(self, dst, src_cmpmask):
        """
        Move Cmpmask To Tensor gen_code
        Parameters
        ----------
        dst: target tensor, uint64
        src_cmpmask: the result of vcmp/scatter_vcmp

        Returns
        -------
        dst, src_cmpmask
        """
        with self.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.add_source_id()
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.emit(tvm.call_extern(
                "uint64", "get_cmpmask", dst.access_ptr("w", extent=Expr(2 * 8).get())))

        return dst, src_cmpmask

    @source_info_decorator()
    @mov_tensor_to_cmpmask_decorator
    def mov_tensor_to_cmpmask(self, src):
        """
        move the data from src tensor to dst_cmpmask

        Parameters
        ----------
        src : 2 continuous uint64 data
        note: use this function to call mov_tensor_to_cmpmask inside!!

        Returns
        -------
        CMPMASK_VAR target var for vsel/scatter_vsel operation
        """
        # check src type
        TikCheckUtil.check_type_match(src, Tensor, "src should be tensor")
        # check tensor scope
        TikCheckUtil.check_equality(src.scope, scope_ubuf, "src's scope must be UB")
        # check UB address 32B align
        align = vec_template_align(src.dtype)
        check_address_align((src,), ("src",), align)
        # extent: 2 uint64, 8 Bytes/uint64
        with self.new_scope():
            if TikSocManager.is_v300_610l_soc():
                self.add_source_id()
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            src_ptr = src.access_ptr("r", extent=16)
            if TikSocManager.is_nano_soc():
                src_ptr = tvm.tir.Cast("uint64", src_ptr)
            self.emit(tvm.call_extern("uint64", "set_cmpmask", src_ptr))
        return CMPMASK_VAR

    @source_info_decorator()
    def set_scalar_to_cmpmask(self, scalar):
        """
        set the scalar to cmpmask

        Parameters
        ----------
        scalar : 2 continuous uint64 data

        Returns
        -------
        CMPMASK_VAR target var for vsel/scatter_vsel operation
        """
        # extent: 2 uint64, 8 Bytes/uint64
        with self.new_scope():
            self.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.emit(tvm.call_extern("uint64", "set_cmpmask", scalar.get()))
        return CMPMASK_VAR
