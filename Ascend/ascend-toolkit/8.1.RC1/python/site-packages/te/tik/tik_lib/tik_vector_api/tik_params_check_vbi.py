#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_params_check_vbi.py
DESC:     provide params
CREATED:  2021-11-23 10:36:42
MODIFIED: 2021-11-23 10:37:00
"""
from tbe.tik.common.common_util import vec_template_align
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import TikUtil
from tbe.tik.common.util import DTYPE_SIZE
from tbe.common.platform import intrinsic_check_support
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_params import MIN_STRIDE
from tbe.tik.tik_lib.tik_params import MAX_BLK_STRIDE_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_BLK_STRIDE_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.tik_lib.tik_mask_concat_ import mask_concat
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_expr import is_basic_expr
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_vector_api.vector_common_util import gen_block_list


class VbiCheckParams:
    """
    Vbi Params Check
    """
    def __init__(self, print_name, params_list):
        self.print_name = print_name
        self.name = print_name
        self.dst_tensor_op, self.src0_tensor_op, self.src1_tensor_op, self.src0_offset_tensor_op, self.vbi_control_op \
            = params_list

    @staticmethod
    def _check_single_point(tensor_op):
        """
        for vbi, tensor[imme] or tensor[scalar] is not support
        """
        msg = "vbi %s not support single point, please use tensor[imme:] or tensor[scalar:]" % tensor_op.tensor_op_name
        TikCheckUtil.check_equality(tensor_op.tensor_obj.is_single_point(), False, msg)

    def check_dtype_support(self):
        """
        check dtypr support

        Returns
        -------
        None
        """
        TikCheckUtil.check_equality(self.dst_tensor_op.tensor_obj.dtype, self.src0_tensor_op.tensor_obj.dtype,
                                    "Intrinsic {}'s src0's dtype should be equal to dst's dtype".format("vbi"))
        TikCheckUtil.check_equality(self.dst_tensor_op.tensor_obj.dtype, self.src1_tensor_op.tensor_obj.dtype,
                                    "Intrinsic {}'s src1's dtype should be equal to dst's dtype".format("vbi"))
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + "vbi", self.dst_tensor_op.tensor_obj.dtype), True,
            gen_api_check_statement(self.dst_tensor_op.tensor_obj.dtype, "vbi"))
        TikCheckUtil.check_equality(self.src0_offset_tensor_op.tensor_obj.dtype, "int32",
                                    "Intrinsic {}'s src0_offset's dtype should be int32".format("vbi"))

    def check_dst_blk_stride(self):
        """
        check dst block stride

        Returns
        -------
        None
        """
        if self.vbi_control_op.context is None:
            TikCheckUtil.check_type_match(
                self.dst_tensor_op.blk_stride, (int, Scalar, Expr),
                "dst_blk_stride should be int, Expr or Scalar, input type is %s" % type(self.dst_tensor_op.blk_stride))
            check_scalar_dtype(self.dst_tensor_op.blk_stride, "scalar dst_blk_stride should be a scalar of int/uint")
        if TikSocManager.is_v200_soc() or TikSocManager.is_v210_soc() or TikSocManager.is_910b_soc():
            TikCheckUtil.check_in_range_by_dtype(
                self.dst_tensor_op.blk_stride, msg="dst_blk_stride should be in the range of [%d, %d], "
                "input value is %s" % (MIN_STRIDE, MAX_BLK_STRIDE_DOUBLE_BYTE, self.dst_tensor_op.blk_stride),
                var_range=[MIN_STRIDE, MAX_BLK_STRIDE_DOUBLE_BYTE])
        elif TikSocManager.is_910b_soc():
            TikCheckUtil.check_in_range_by_dtype(
                self.dst_tensor_op.blk_stride, msg="dst_blk_stride should be in the range of [%d, %d], "
                "input value is %s" % (MIN_STRIDE, MAX_BLK_STRIDE_SINGLE_BYTE, self.dst_tensor_op.blk_stride),
                var_range=[MIN_STRIDE, MAX_BLK_STRIDE_SINGLE_BYTE])

    def check_vbi_overlap(self):
        """
        for vbi instruction, check whether src0_offset and src1 is overlap

        Returns
        -------
        None
        """
        # check src0 and other tensor
        if self.src0_tensor_op.tensor_obj.buffer in (self.dst_tensor_op.tensor_obj.buffer,
                                                     self.src1_tensor_op.tensor_obj.buffer,
                                                     self.src0_offset_tensor_op.tensor_obj.buffer):
            TikCheckUtil.raise_error("vbi src0 cannot overlap with dst, src1 or src0_offset")
        if self.vbi_control_op.mask_len is None or is_basic_expr(TikUtil.to_list(self.vbi_control_op.mask_len)):
            return
        if is_basic_expr([self.vbi_control_op.total_repeat_times_value]):
            return

        # check src0_offset and src1
        self.src1_tensor_op.check_vbi_src1_src0offset_overlap(self.src0_offset_tensor_op, self.vbi_control_op)

        # mask, tensor offset, dst_blk_stride and v_repeat_offset cannot be scalar
        if is_basic_expr(TikUtil.to_list(self.vbi_control_op.mask_value)) or \
                is_basic_expr([self.dst_tensor_op.blk_stride, self.vbi_control_op.vertical_repeat_offset_value]):

            return

        dst_offset = Expr(self.dst_tensor_op.tensor_obj.offset).eval_value()
        if dst_offset is None:
            return
        # check dst and src1 overlap
        self.dst_tensor_op.eval_offset()
        self.src0_tensor_op.eval_offset()
        self.src1_tensor_op.eval_offset()
        self.dst_tensor_op.check_vbi_dst_src1_overlap(self.src1_tensor_op, self.vbi_control_op)
        # check dst and src0_offset
        self.src0_offset_tensor_op.eval_offset()
        self.dst_tensor_op.check_vbi_dst_src0offset_overlap(self.src0_offset_tensor_op, self.vbi_control_op)

    def check_220_h_rep_times_and_v_repeat_offset(self):
        """
        if 220, check horizontal_repeat_times and vertical_repeat_offset

        Returns
        -------
        None
        """
        # check horizontal_repeat_times
        horizontal_dtype_value = 8 // DTYPE_SIZE[self.dst_tensor_op.tensor_obj.dtype]
        horizontal_repeat_value = self.vbi_control_op.horizontal_repeat_times % horizontal_dtype_value
        if isinstance(self.vbi_control_op.horizontal_repeat_times, int) and horizontal_repeat_value != 0:
            TikCheckUtil.raise_error("horizontal_repeat_times must be divisible by %s when dst dtype is %s."
                                     % (horizontal_dtype_value, self.dst_tensor_op.tensor_obj.dtype))
        # check vertical_repeat_offset
        vertical_dtype_value = ONE_BLK_SIZE // DTYPE_SIZE[self.dst_tensor_op.tensor_obj.dtype]
        vertical_repeat_value = self.vbi_control_op.vertical_repeat_offset % vertical_dtype_value
        if isinstance(self.vbi_control_op.vertical_repeat_offset, int) and vertical_repeat_value != 0:
            TikCheckUtil.raise_error("vertical_repeat_offset must be divisible by %s when dst dtype is %s."
                                     % (vertical_dtype_value, self.dst_tensor_op.tensor_obj.dtype))

    def check_all(self, tik_instance):
        """
        all check

        Returns
        -------
        None
        """
        self.dst_tensor_op.check_tensor_and_scope()
        self.src0_tensor_op.check_tensor_and_scope()
        self.src1_tensor_op.check_tensor_and_scope()
        self.src0_offset_tensor_op.check_tensor_and_scope()
        mask_o = mask_concat(tik_instance, self.vbi_control_op.mask,
                             tensor_bit_len=get_bit_len(self.dst_tensor_op.tensor_obj.dtype))
        align = vec_template_align(self.dst_tensor_op.tensor_obj.dtype)
        self.dst_tensor_op.check_tensor_op_address_align(self.name, align)
        self.src0_tensor_op.check_tensor_op_address_align(self.name, align)
        self.src1_tensor_op.check_tensor_op_address_align(self.name, align)
        src0_offset_align = vec_template_align(self.src0_offset_tensor_op.tensor_obj.dtype)
        self.src0_offset_tensor_op.check_tensor_op_address_align(self.name, src0_offset_align)
        self.check_dtype_support()
        self.check_dst_blk_stride()
        self.vbi_control_op.check_vertical_repeat_times()
        self.vbi_control_op.check_horizontal_repeat_times()
        self.vbi_control_op.check_repeat_mode()
        self.vbi_control_op.check_vertical_repeat_offset()
        self._check_single_point(self.dst_tensor_op)
        self._check_single_point(self.src0_tensor_op)
        self._check_single_point(self.src1_tensor_op)
        self._check_single_point(self.src0_offset_tensor_op)
        tensor_bit_len_src0_offset = get_bit_len(self.src0_offset_tensor_op.tensor_obj.dtype)
        block_list_src0_offset = gen_block_list(tensor_bit_len_src0_offset, self.src0_offset_tensor_op.tensor_obj.dtype)
        self.dst_tensor_op.check_vbi_dst_offset_overflow(self.print_name, self.src0_offset_tensor_op,
                                                         self.vbi_control_op, block_list_src0_offset)
        self.src1_tensor_op.check_vbi_src1_tensor_overflow(self.vbi_control_op)
        self.check_vbi_overlap()
        if TikSocManager.is_910b_soc() or TikSocManager.is_v300_610l_soc():
            self.check_220_h_rep_times_and_v_repeat_offset()

        return mask_o
