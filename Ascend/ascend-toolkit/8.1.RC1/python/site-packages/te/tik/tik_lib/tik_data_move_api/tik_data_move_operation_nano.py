#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2023. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_data_move_operation_nano.py
DESC:     tik data_move related operation api for nano
CREATED:  2023-02-25 14:04:45
"""

from tbe import tvm

from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import reassign_mask
from tbe.tik.common.util import check_mask1_mask2
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import TikUtil
from tbe.tik.common.tik_get_soc_name import get_block_size
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import is_compatible_mode
from tbe.tik.tik_lib.tik_api_util import reset_ctrl_value
from tbe.tik.tik_lib.tik_api_util import set_ctrl_counter_mask
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_operation_ import DataMoveApi
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_operation_ import DataMovePadApi
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_operation_ import get_access_ptr
from tbe.tik.tik_lib.tik_data_move_api.tik_data_operation_ import VCopyOpApi
from tbe.tik.tik_lib.tik_params import PIPE_MTE3
from tbe.tik.tik_lib.tik_params import PIPE_MTE2
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_util import type_convert
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_api_util import check_mask_mode
from tbe.tik.tik_lib.tik_mask_concat_ import mask_concat

OUT2UB = "OUT UB"
UB2OUT = "UB OUT"
UB2UB = "UB UB"


class DataMoveApiNano(DataMoveApi):
    """
    DataMove api for nano soc
    """

    def __init__(self, tik_instance, dm_api, args, argv):
        super().__init__(tik_instance, dm_api, args, argv)
        # pad value selector:
        # 0: first element of each burst,
        # 1: value defined in SPR.MOVE_PAD_VAL
        self.pad_value_selector = 0
        # pad mode:
        # 0: padding, 1/2: depadding(not supported)
        self.pad_mode = 0
        # DI: 1bit indicator for data which needs to be confidential
        self.di_data = 0
        self.is_compatible = is_compatible_mode()

    def gen_ub2ub_arg_list(self):
        dst_stride = self.burst + self.dst_stride
        src_stride = self.burst + self.src_stride
        burst = self.burst
        # for compatible mode, block-size for data_move is 32B while hardware block-size is 16B
        # ub->ub burst/dst_stride/src_stride is in unit of block-size, need to multiply 2
        if self.is_compatible:
            burst *= 2
            dst_stride *= 2
            src_stride *= 2
        return [self.nburst, burst, dst_stride, src_stride]

    def gen_ub2out_arg_list(self):
        burst = self.burst * self.block_size
        src_stride = self.burst + self.src_stride  # unit: block size
        dst_stride = (self.burst + self.dst_stride) * self.block_size  # unit: 1byte
        # for compatible mode, src stride is in unit of block-size,
        # hardware block-size is 16, need to multiply 2
        if self.is_compatible:
            src_stride *= 2
        return [self.nburst, burst, dst_stride, src_stride, self.di_data]

    def gen_out2ub_arg_list(self):
        burst = self.burst * self.block_size
        dst_stride = self.burst + self.dst_stride  # unit: block size
        src_stride = (self.burst + self.src_stride) * self.block_size  # unit: 1byte
        # for compatible mode, block-size for data_move is 32B while hardware block-size is 16B
        # dst stride is in unit of block-size, need to multiply 2
        if self.is_compatible:
            dst_stride *= 2
        return [self.nburst, burst, self.pad_value_selector, self.pad_mode,
                src_stride, dst_stride, self.di_data]

    def code_gen(self, dma_list):
        """
        data move code gen
        Parameters
        ----------
        dma_list: dma list

        Returns
        -------

        """
        dma_list = {
            UB2UB: ('copy_ubuf_to_ubuf', self.gen_ub2ub_arg_list),
            OUT2UB: ('copy_gm_to_ubuf_align', self.gen_out2ub_arg_list),
            UB2OUT: ('copy_ubuf_to_gm_align', self.gen_ub2out_arg_list),  # LSU3
        }
        src_key_str = TikUtil.get_storage_scope(self.src.scope)
        dst_key_str = TikUtil.get_storage_scope(self.dst.scope)
        key = src_key_str + " " + dst_key_str
        intrin_name, code_arg_list_func = dma_list.get(key)
        TikCheckUtil.check_not_is(intrin_name, None,
                                  "data_move doesn't support %s to %s" % (src_key_str, dst_key_str))
        with self.tik_instance.context.freeze():
            spec_byte_size = None
            _, src_access_ptr, dst_access_ptr = get_access_ptr(
                self, key, src_key_str, dst_key_str, [self.dst_stride, self.src_stride, spec_byte_size])
            with self.tik_instance.new_scope():
                arg_list = code_arg_list_func()
                instr = tvm.call_extern(
                    self.dst.dtype, intrin_name, dst_access_ptr, src_access_ptr, *(type_convert(arg_list)))
                # one ir is call_extern
                self.tik_instance.emit(instr)


class DataMovePadApiNano(DataMovePadApi):
    """
    DataMovePad api for nano soc
    """

    def __init__(self, tik_instance, dmp_obj):
        super().__init__(tik_instance, dmp_obj)
        # pad value selector:
        # 0: first element of each burst,
        # 1: value defined in SPR.MOVE_PAD_VAL
        self.pad_value_selector = 0 if dmp_obj.padding_value is None else 1
        self.pad_mode = 0
        # DI: 1bit indicator for data which needs to be confidential
        self.di_data = 0
        self.is_compatible = is_compatible_mode()

    def _gen_intrin_infos(self, scope_key):
        """
        generate instruction info

        Parameters
        ----------
        scope_key: string combined by src and dst scope

        Returns
        -------
        pipeline of instruction
        name of instruction
        arg list of instruction
        """
        is_left_padding_legal = isinstance(self.left_padding, int) and self.left_padding == 0
        is_right_padding_legal = isinstance(self.right_padding, int) and self.right_padding == 0
        if is_left_padding_legal is False or is_right_padding_legal is False:
            soc_name = get_soc_name()
            TikCheckUtil.raise_error(
                "%s doesn't support left_padding or right_padding args for %s" % (self.check.name, soc_name))
        gen_arg_func_list = {
            OUT2UB: ("copy_gm_to_ubuf_align", PIPE_MTE2, self._gen_out2ub_arg_list),
            UB2OUT: ("copy_ubuf_to_gm_align", PIPE_MTE3, self._gen_ub2out_arg_list),  # LSU3
        }
        self.check.check_inter_key(scope_key, gen_arg_func_list)
        intrin_name, pipeline, gen_arg_func = gen_arg_func_list[scope_key]
        return pipeline, intrin_name, gen_arg_func()

    def _gen_ub2out_arg_list(self):
        # for nano src_stride/dst_stride is from pre-head to next-head
        dst_stride = self.burst + self.dst_gap  # uint: 1byte
        src_stride = (self.burst + self.block_size - 1) // self.block_size + self.src_gap  # unit: block size
        # for compatible mode, src stride is in unit of block-size,
        # hardware block-size is 16, need to multiply 2
        if self.is_compatible:
            src_stride *= 2
        return [self.nburst, self.burst, dst_stride, src_stride, self.di_data]

    def _gen_out2ub_arg_list(self):
        # for nano src_stride/dst_stride is from pre-head to next-head
        src_stride = self.burst + self.src_gap  # unit: 1byte
        dst_stride = (self.burst + self.block_size - 1) // self.block_size + self.dst_gap  # unit: block size
        # for compatible mode, block-size for data_move is 32B while hardware block-size is 16B
        # dst stride is in unit of block-size, need to multiply 2
        if self.is_compatible:
            dst_stride *= 2
        return [self.nburst, self.burst, self.pad_value_selector, self.pad_mode,
                src_stride, dst_stride, self.di_data]



class VCopyOpApiNano(VCopyOpApi):
    """
    vcopy api for nano soc
    """
    def __init__(self, tik_instance, vcopy_obj):
        super().__init__(tik_instance, vcopy_obj)

    def code_gen_nano(self, dst, src, config, mask):
        if dst.dtype != src.dtype:
            src = src.reinterpret_cast_to(dst.dtype)

        orig_ctrl = 0
        if self.mask_mode == "counter":
            orig_ctrl = set_ctrl_counter_mask(self.tik_instance)

        with self.tik_instance.new_scope():
            instr = tvm.call_extern(dst.dtype, self.name,
                                    dst.access_ptr(
                                        "w", extent=self.cal_dst_src_extent_vcopy(False)),
                                    src.access_ptr(
                                        "r", extent=self.cal_dst_src_extent_vcopy(True)),
                                    *type_convert(config))
            self.tik_instance.emit(tvm.call_extern("int64", "set_vector_mask", *mask))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            self.tik_instance.emit(instr)

        if self.mask_mode == "counter":
            reset_ctrl_value(self.tik_instance, orig_ctrl)

    @source_info_decorator(depth=2)
    def run_all(self):
        """
        run all_check and code_gen

        Returns
        -------
        None
        """
        self.check.check_dst_src_tensor()
        # check strides
        self.check.check_vector_stride_repeat()
        # check tensor overflow, overlapping
        self.check.check_all()
        check_mask_mode(self.mask_mode)
        if not is_compatible_mode():
            config = [self.repeat_times, self.dst_blk_stride,
                      self.src_blk_stride, self.dst_rep_stride, self.src_rep_stride]

            mask_o = mask_concat(self.tik_instance, self.mask, mask_mode=self.mask_mode,
                                 tensor_bit_len=get_bit_len(self.dst.dtype))
            self.code_gen_nano(self.dst, self.src, config, mask_o)
        else:
            tensor_bit_len = get_bit_len(self.dst.dtype)
            one_block_elements = get_block_size() // DTYPE_SIZE[self.dst.dtype]
            mask1, mask2 = reassign_mask(self.tik_instance, self.mask, one_block_elements)
            enable_mask1, enable_mask2 = check_mask1_mask2(mask1, mask2)

            config = [self.repeat_times, 2 * self.dst_blk_stride, 2 * self.src_blk_stride,
                      2 * self.dst_rep_stride, 2 * self.src_rep_stride]
            if enable_mask1:
                mask_o1 = mask_concat(self.tik_instance, mask1, self.mask_mode, tensor_bit_len)
                self.code_gen_nano(self.dst, self.src, config, mask_o1)
            if enable_mask2:
                scalar_offset = self.tik_instance.Scalar(name="scalar_offset", init_value=one_block_elements)
                mask_o2 = mask_concat(self.tik_instance, mask2, self.mask_mode, tensor_bit_len)
                self.code_gen_nano(self.dst[scalar_offset:], self.src[scalar_offset:], config, mask_o2)
