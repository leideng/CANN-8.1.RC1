#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_mmad_other_operation.py
DESC:     tik_mmad_winograd_broadcast_operation
CREATED:  2021-12-08 11:40 AM
MODIFIED: 2021-12-08 11:40 AM
"""
from tbe import tvm
from tbe.common.platform import intrinsic_check_support
from tbe.common.platform.platform_info import api_check_support
from tbe.common.platform import scope_cc
from tbe.common.platform import scope_cbuf
from tbe.common.platform import scope_cb
from tbe.common.platform import scope_ca
from tbe.common.platform import scope_ubuf
from tbe.common.platform import scope_gm
from tbe.common.platform import AIC_610
from tbe.common.platform import HI3796CV300ESAIC
from tbe.common.platform import HI3796CV300CSAIC
from tbe.common.platform import ASCEND_SD_AIC
from tbe.tik.api.tik_scalar import Scalar
from tbe.tik.api.tik_tensor import Tensor
from tbe.tik.api.tik_ir_builder import TikIRBuilder
from tbe.tik.common.tik_api_map import AIC_310P
from tbe.tik.common.tik_api_map import AIC_BS9SX1A
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import reduce_mul
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.common_util import check_address_align
from tbe.tik.common.common_util import get_l0c_align
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_soc_core_type
from tbe.tik.debug.mmad_decorators import broadcast_ub_to_l0c_decorator
from tbe.tik.debug.mmad_decorators import mmad_brc_decorator
from tbe.tik.debug.mmad_decorators import load_winograd_weight_decorator
from tbe.tik.debug.mmad_decorators import load_winograd_fm_decorator
from tbe.tik.debug.mmad_decorators import winograd_weight_trans_decorator
from tbe.tik.debug.mmad_decorators import winograd_fm_transform_decorator
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_expr_convert import type_convert
from tbe.tik.tik_lib.tik_util import concat_params
from tbe.tik.tik_lib.tik_params import PIPE_V
from tbe.tik.tik_lib.tik_params import MIN_CHANNEL_SIZE_WINO
from tbe.tik.tik_lib.tik_params import MIN_EXTENSION_WINO_V2
from tbe.tik.tik_lib.tik_params import MAX_REP_STRIDE_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_REP_STRIDE_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import PIPE_MTE1
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_MODE
from tbe.tik.tik_lib.tik_params import MIN_NBURST
from tbe.tik.tik_lib.tik_params import MAX_NBURST_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_DST_GAP_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_SRC_GAP
from tbe.tik.tik_lib.tik_params import MIN_BURST_REPEAT
from tbe.tik.tik_lib.tik_params import MAX_BURST_REPEAT
from tbe.tik.tik_lib.tik_params import ONE_BLK_SIZE
from tbe.tik.tik_lib.tik_params import ELE_PER_FRACTAL_EDGE
from tbe.tik.tik_lib.tik_params import BYTE_PER_FRACTAL
from tbe.tik.tik_lib.tik_params import MAX_BLK_STRIDE_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import MIN_BURST_LEN
from tbe.tik.tik_lib.tik_params import MAX_BURST_LEN_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import STRIDES_LEN
from tbe.tik.tik_lib.tik_params import DST_BLK_STRIDE_IDX
from tbe.tik.tik_lib.tik_params import SRC_BLK_STRIDE_IDX
from tbe.tik.tik_lib.tik_params import WINO_WGT_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import WINO_WGT_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import WINO_FM_XT_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import WINO_FM_XT_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import WINO_FM_XM_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import WINO_FM_XM_SEGMENT_LIST
from tbe.tik.tik_lib.tik_params import MAX_REP_DIR
from tbe.tik.tik_lib.tik_params import gen_api_check_statement
from tbe.tik.tik_lib.tik_params import MAX_CHANNEL_SIZE_WINO
from tbe.tik.tik_lib.tik_params import MIN_EXTENSION
from tbe.tik.tik_lib.tik_params import MAX_EXTENSION_WINO_V2
from tbe.tik.tik_lib.tik_params import MIN_L1_H_W_C
from tbe.tik.tik_lib.tik_params import MAX_L1_H_W
from tbe.tik.tik_lib.tik_params import MAX_L1_C
from tbe.tik.tik_lib.tik_params import MAX_DST_GAP_WINO
from tbe.tik.tik_lib.tik_params import MAX_EXTENSION
from tbe.tik.tik_lib.tik_params import MAX_K_WINO
from tbe.tik.tik_lib.tik_params import MAX_COL_INDIC
from tbe.tik.tik_lib.tik_params import MAX_START_PT
from tbe.tik.tik_lib.tik_api_constants import DTYPE_MAP
from tbe.tik.tik_lib.tik_api_constants import WINO_PAD_MAP
from tbe.tik.tik_lib.tik_api_util import check_repeat_times
from tbe.tik.tik_lib.tik_api_util import check_weight_offset
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_source_info import source_info_decorator
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import load2d_3d_align_fn
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_mmad_param_type_range

_SRC_BURST_LEN_SIZE_ELE = 16
_DST_BURST_LEN_SIZE_ELE = 256
_SRC_GAP_SIZE_BYTE = 32
_DEFAULT_STRIDE = 0
_STRIDE_UNIT_ZERO = 0
_STRIDE_UNIT_ONE = 1

new_scope_map = {
    scope_ubuf: "ub",
    scope_gm: "gm",
    scope_ca: "ca",
    scope_cb: "cb",
    scope_cc: "cc",
    scope_cbuf: "cbuf",
}

arch_version_dst_src_map = {
    HI3796CV300ESAIC: ['s8s8'],
    HI3796CV300CSAIC: ['s8s8', 'u8u8'],
    ASCEND_SD_AIC: ['s8s8', 'u8u8'],
    AIC_310P: ['s8s8', 'u8u8', 'f16f16'],
    AIC_610: ['s8s8', 'u8u8', 'f16f16'],
    AIC_BS9SX1A: ['s8s8', 'u8u8', 'f16f16']
}


def _check_src_overflow_brc(src, nburst, burst_len, src_gap):
    """
    check src tensor if overflow
    Parameters
    ----------
    src: src tensor
    nburst: number of burst
    burst_len: burst length
    src_gap: src gap

    Returns
    -------
    no return
    """
    offset = src.offset
    total_size = reduce_mul(src.original_shape)
    byte_len = DTYPE_SIZE[src.dtype]
    extend_offset = nburst * (burst_len * _SRC_BURST_LEN_SIZE_ELE +
                              src_gap * _SRC_GAP_SIZE_BYTE // byte_len) - \
                    src_gap * _SRC_GAP_SIZE_BYTE // byte_len
    if Expr(extend_offset + offset).eval_value() is not None:
        TikCheckUtil.check_le(Expr(extend_offset + offset).eval_value(),
                              total_size, "src tensor overflow")


def _calculate_winograd_ft_extent(repeat_times, src_rep_stride, dst_rep_stride, dst_blk_stride):
    """
    calculate winograd_weight_transform src/dst extent

    Parameters
    ----------
    repeat_times: the number of iterations this instruction would be executed
    src_rep_stride: source repeat stride between the base source addresses of 2 successive iterations
    dst_rep_stride: destination repeat stride between the desitination addresses of 2 successive interations
    dst_blk_stride: inner destination stride between the 4 weight matrixes to be
    -               written into L0B in one single iteration in unit of fractal matrix

    Returns
    -------
    src_extent
    dst_extent
    """
    # one instr reads 9 fractals from L1
    src_frac_num = 9
    src_extent = ((repeat_times - 1) * src_rep_stride + src_frac_num) * BYTE_PER_FRACTAL
    src_extent = Expr(src_extent).get()
    # one instr writes 4 fractals to L0B
    dst_frac_num = 4
    dst_extent = ((repeat_times - 1) * dst_rep_stride + (dst_frac_num - 1) *
                  dst_blk_stride + 1) * BYTE_PER_FRACTAL
    dst_extent = Expr(dst_extent).get()
    return src_extent, dst_extent


def _check_dst_overflow_brc(dst, nburst, burst_len, dst_gap):
    """
    check dst tensor if overflow
    Parameters
    ----------
    dst: dst tensor
    nburst: number of burst
    burst_len: burst length
    dst_gap: dst gap

    Returns
    -------
    no return
    """
    offset = dst.offset
    total_size = reduce_mul(dst.original_shape)
    extend_offset = nburst * (burst_len + dst_gap) * _DST_BURST_LEN_SIZE_ELE - \
                    dst_gap * _DST_BURST_LEN_SIZE_ELE
    if Expr(extend_offset + offset).eval_value() is not None:
        TikCheckUtil.check_le(Expr(extend_offset + offset).eval_value(),
                              total_size, "dst tensor overflow")


def _check_input_channel_size(input_channel_size, c0):
    TikCheckUtil.check_type_match(
        input_channel_size, (int, Scalar, Expr),
        "input_channel_size should be int, Scalar, Expr,"
        " input type of input_channel_size: {}".format(type(input_channel_size)))
    check_scalar_dtype(input_channel_size,
                       "input_channel_size should be a scalar of int/uint")
    input_channel_size = Expr(input_channel_size).eval_value()
    if input_channel_size is not None:
        TikCheckUtil.check_in_range_by_dtype(
            input_channel_size, msg="input_channel_size should be in the range of [{}, {}], "
            "input input_channel_size: {}".format(MIN_CHANNEL_SIZE_WINO, MAX_CHANNEL_SIZE_WINO, input_channel_size),
            var_range=[MIN_CHANNEL_SIZE_WINO, MAX_CHANNEL_SIZE_WINO])
        if input_channel_size % c0 != 0:
            TikCheckUtil.raise_error(
                "input_channel_size should be multiple of c0, "
                "input input_channel_size: {}, c0: {}".format(input_channel_size, c0))


def _check_input_kernel_num(input_kernel_num):
    TikCheckUtil.check_type_match(
        input_kernel_num, (int, Scalar, Expr),
        "input_kernel_num should be int, Scalar, Expr, input type of input_kernel_num"
        ": {}".format(type(input_kernel_num)))
    check_scalar_dtype(
        input_kernel_num, "input_kernel_num should be a scalar of int/uint")
    input_kernel_num = Expr(input_kernel_num).eval_value()
    if input_kernel_num is not None:
        TikCheckUtil.check_in_range_by_dtype(
            input_kernel_num, msg="input_kernel_num should be in the range of [{}, {}], "
            "input input_kernel_num: {}".format(MIN_CHANNEL_SIZE_WINO, MAX_CHANNEL_SIZE_WINO, input_kernel_num),
            var_range=[MIN_CHANNEL_SIZE_WINO, MAX_CHANNEL_SIZE_WINO])
        if input_kernel_num % 16 != 0:
            TikCheckUtil.raise_error(
                "Ni: should be multiple of 16, "
                "input Ni: {}".format(input_kernel_num))


def _check_output_kernel_num(input_kernel_num, output_kernel_num):
    TikCheckUtil.check_type_match(
        output_kernel_num, (int, Scalar, Expr),
        "output_kernel_num should be int, Scalar, Expr, input type of output_kernel_num"
        ": {}".format(type(output_kernel_num)))
    check_scalar_dtype(output_kernel_num,
                       "output_kernel_num should be a scalar of int/uint")
    output_kernel_num = Expr(output_kernel_num).eval_value()
    if output_kernel_num is not None:
        TikCheckUtil.check_in_range_by_dtype(
            output_kernel_num, msg="input_output_kernel_num should be in the range of [{}, {}], "
            "input output_kernel_num: {}".format(MIN_CHANNEL_SIZE_WINO, MAX_CHANNEL_SIZE_WINO, output_kernel_num),
            var_range=[MIN_CHANNEL_SIZE_WINO, MAX_CHANNEL_SIZE_WINO])
        TikCheckUtil.check_in_range_by_dtype(
            output_kernel_num, msg="input_output_kernel_num should be in the range of [{}, Ni({})], "
            "input output_kernel_num: {}".format(0, input_kernel_num, output_kernel_num),
            var_range=[0, input_kernel_num])
        if output_kernel_num % 16 != 0:
            TikCheckUtil.raise_error(
                "Nb should be multiple of 16, "
                "input Nb: {}".format(output_kernel_num))


class BroadcastUbToL0cApi(TikIRBuilder):
    """
    broadcast_ub_to_l0c api class
    """
    def __init__(self, tik_instance, b_ubl0c_api):
        super(BroadcastUbToL0cApi, self).__init__()
        self.tik_instance = tik_instance
        self.dst = b_ubl0c_api.dst
        self.src = b_ubl0c_api.src
        self.nburst = b_ubl0c_api.nburst
        self.burst_len = b_ubl0c_api.burst_len
        self.strides = b_ubl0c_api.strides

    def check_all(self):
        """
        check broadcast_ub_to_l0c api params
        """
        # check nburst
        check_mmad_param_type_range('nburst', self.nburst, MIN_NBURST, MAX_NBURST_SINGLE_BYTE)

        # check burst_len
        check_mmad_param_type_range('burst_len', self.burst_len, MIN_BURST_LEN, MAX_BURST_LEN_SINGLE_BYTE)

        # check stride
        TikCheckUtil.check_equality(len(self.strides), STRIDES_LEN, "length of strides should be 2")
        check_mmad_param_type_range('src_blk_stride', self.strides[SRC_BLK_STRIDE_IDX], end=MAX_BLK_STRIDE_SINGLE_BYTE)
        check_mmad_param_type_range('dst_blk_stride', self.strides[DST_BLK_STRIDE_IDX], end=MAX_BURST_LEN_SINGLE_BYTE)

        # check tensor dtype
        TikCheckUtil.check_equality(
            self.dst.dtype, self.src.dtype,
            "Intrinsic {}'s src's dtype should be equal to dst's dtype".format("broadcast_ub_to_l0c"))
        # check operator address 32B aligned
        check_address_align((self.src,), ("src",))
        check_address_align((self.dst,), ("dst",), get_l0c_align(self.dst))
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_broadcast_ub_to_cc",  self.dst.dtype), True,
            gen_api_check_statement(self.dst.dtype, "broadcast_ub_to_l0c"))
        # check tensor overflow
        _check_src_overflow_brc(self.src, self.nburst, self.burst_len, self.strides[SRC_BLK_STRIDE_IDX])
        _check_dst_overflow_brc(self.dst, self.nburst, self.burst_len, self.strides[DST_BLK_STRIDE_IDX])

    @source_info_decorator(depth=2)
    @broadcast_ub_to_l0c_decorator
    def run_all(self):
        """
        broadcast_ub_to_l0c api gen
        """
        self.check_all()
        params = [self.nburst, self.burst_len, *self.strides]
        # src burst_len: 16 element
        # src gap: 32 Byte
        # dst burst_len: 256 element
        # dst gap: 256 element
        # function _calculate_extent_broadcast_ub_to_l0c returns a list, idx 0
        # represents dst_extent and 1 represents src_extent
        extents = self._calculate_extent_broadcast_ub_to_l0c()
        with self.tik_instance.new_scope():
            instr = tvm.call_extern(
                self.dst.dtype, "broadcast_ub_to_cc",
                self.dst.reinterpret_cast_to(self.dst.dtype).access_ptr("w", extent=extents[0]),
                self.src.reinterpret_cast_to(self.src.dtype).access_ptr("r", extent=extents[1]),
                *type_convert(params))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            # one ir is call_extern
            self.tik_instance.emit(instr)

    def _calculate_extent_broadcast_ub_to_l0c(self):
        """
        calculate extent of broadcast ub to l0c

        Returns
        -------
        dst_extent and src_extent
        """
        data_size = DTYPE_SIZE.get(self.dst.dtype)
        # SRC Byte
        src_extent = (self.nburst * self.burst_len * _SRC_BURST_LEN_SIZE_ELE * data_size) + \
                     ((self.nburst - 1) * self.strides[1] * ONE_BLK_SIZE)
        src_extent_val = Expr(src_extent).get()
        # DST Byte
        dst_extent = (self.nburst * self.burst_len * _DST_BURST_LEN_SIZE_ELE * data_size) + \
                     ((self.nburst - 1) * self.strides[0] * _DST_BURST_LEN_SIZE_ELE * data_size)
        dst_extent_val = Expr(dst_extent).get()

        return [dst_extent_val, src_extent_val]


class MMadBroadCastApi(TikIRBuilder):
    """
    mmad_broadcast api class
    """

    def __init__(self, tik_instance, mmad_b_api):
        super(MMadBroadCastApi, self).__init__()
        self.tik_instance = tik_instance
        self.dst = mmad_b_api.dst
        self.src = mmad_b_api.src
        self.repeat_mode = mmad_b_api.repeat_mode
        self.nburst = mmad_b_api.nburst
        self.burst_repeat = mmad_b_api.burst_repeat
        self.dst_gap = mmad_b_api.dst_gap
        self.src_gap = mmad_b_api.src_gap

    def check_all(self):
        """
        check mmad_broadcast api params
        """
        # check scope
        dst_scope = self.dst.scope.split('.')[-1].lower()
        src_scope = self.src.scope.split('.')[-1].lower()
        error_msg = "%s Instruction mmad_broadcast doesn't support broadcast %s to %s" %\
                    (get_soc_name() + get_soc_core_type(), src_scope, dst_scope)
        if TikSocManager.is_v100_soc() or TikSocManager.is_910b_soc():
            TikCheckUtil.check_equality(dst_scope + src_scope, 'l0cub', error_msg)
        elif (TikSocManager.is_v200_soc() or TikSocManager.is_v210_soc()) and TikSocManager.is_aicore_core():
            TikCheckUtil.check_var_in_list(dst_scope + src_scope, ['l0cub', 'l0cl1'], error_msg)

        # check address align
        dst_align = get_l0c_align(self.dst)
        check_address_align((self.dst,), ("dst",), dst_align)
        src_align, _ = load2d_3d_align_fn(self.dst, self.src)
        check_address_align((self.src,), ("src",), src_align)

        # check repeatMode
        TikCheckUtil.check_type_match(self.repeat_mode, (int, Scalar), "repeat_mode should be int or Scalar")
        TikCheckUtil.check_in_range_by_dtype(
            self.repeat_mode, msg="repeat_mode should be %s or %s" % (0, MAX_REPEAT_MODE),
            var_range=[0, MAX_REPEAT_MODE])
        # check nburst
        TikCheckUtil.check_in_range_by_dtype(
            self.nburst, msg="nburst should be in the range of [%s, %s]" % (MIN_NBURST, MAX_NBURST_SINGLE_BYTE),
            var_range=[MIN_NBURST, MAX_NBURST_SINGLE_BYTE])
        # check burst_repeat
        TikCheckUtil.check_in_range_by_dtype(
            self.burst_repeat, msg="burst_repeat should be in the range of [%s, %s]"
            % (MIN_BURST_REPEAT, MAX_BURST_REPEAT), var_range=[MIN_BURST_REPEAT, MAX_BURST_REPEAT])
        # check gap
        TikCheckUtil.check_in_range_by_dtype(
            self.dst_gap, msg="dst_gap should be in the range of [%s, %s]"
            % (0, MAX_DST_GAP_SINGLE_BYTE), var_range=[0, MAX_DST_GAP_SINGLE_BYTE])
        TikCheckUtil.check_in_range_by_dtype(
            self.src_gap, msg="src_gap should be in the range of [%s, %s]"
            % (0, MAX_SRC_GAP), var_range=[0, MAX_SRC_GAP])

        # check tensor dtype
        dtype_str = DTYPE_MAP[self.dst.dtype] + DTYPE_MAP[self.src.dtype]
        dtype_str_err = "src " + self.src.dtype + " dst " + self.dst.dtype
        TikCheckUtil.check_equality(api_check_support("tik.mmad_broadcast", dtype_str), True,
                                    gen_api_check_statement(dtype_str_err, "mmad_broadcast"))

    @source_info_decorator(depth=2)
    @mmad_brc_decorator
    def run_all(self):
        """
        mmad_broadcast api run_all
        """
        self.check_all()
        # code gen
        params = [self.nburst, self.burst_repeat, self.src_gap, self.dst_gap, self.repeat_mode]
        func_namefunc_name = "broadcast_" + new_scope_map.get(self.src.scope) +\
                             "_to_" + new_scope_map.get(self.dst.scope)
        with self.tik_instance.new_scope():
            instr = tvm.call_extern(
                self.dst.dtype, func_namefunc_name,
                self.dst.access_ptr("w"), self.src.access_ptr("r"), *type_convert(params))
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_V)
            # one ir is call_extern
            self.tik_instance.emit(instr)


class LoadWinoGardFmApi(TikIRBuilder):
    """
    load_winograd_fm api class
    """
    def __init__(self, tik_instance, load_w_fm_api):
        super(LoadWinoGardFmApi, self).__init__()
        self.tik_instance = tik_instance
        self.dst = load_w_fm_api.dst
        self.src = load_w_fm_api.src
        self.pad = load_w_fm_api.pad
        self.m_extension = load_w_fm_api.m_extension
        self.m_start_pt = load_w_fm_api.m_start_pt
        self.k_extension = load_w_fm_api.k_extension
        self.k_start_pt = load_w_fm_api.k_start_pt

    def check_mk_extension_start(self):
        """
        check mk_extension_start
        """
        check_mmad_param_type_range('m_extension', self.m_extension, start=MIN_EXTENSION, end=MAX_EXTENSION_WINO_V2)
        check_mmad_param_type_range('m_start_pt', self.m_start_pt, end=MAX_EXTENSION_WINO_V2)
        check_mmad_param_type_range('k_extension', self.k_extension, start=MIN_EXTENSION, end=MAX_EXTENSION_WINO_V2)
        check_mmad_param_type_range('k_start_pt', self.k_start_pt, end=MAX_EXTENSION_WINO_V2)

    def check_wino_ft_params_v2(self, l1_w, l1_h, max_k_num, src_c0):
        """
        use to check wino ft params
        """
        pad_left, pad_right, pad_top, pad_bottom = self.pad
        max_m_num = (l1_h + pad_top + pad_bottom - 2) * (l1_w + pad_left + pad_right - 2) // 4
        min_start_pt = 0
        check_mmad_param_type_range('l1_h', l1_h, start=MIN_L1_H_W_C, end=MAX_L1_H_W, is_debug=True)
        check_mmad_param_type_range('l1_w', l1_w, start=MIN_L1_H_W_C, end=MAX_L1_H_W, is_debug=True)
        check_mmad_param_type_range('cin', max_k_num, start=MIN_L1_H_W_C, end=MAX_L1_C, is_debug=True)

        TikCheckUtil.check_in_range_by_dtype(
            max_m_num, msg="calculate MatrixM should be in the range of [%s, %s], MatrixM: %s"
            % (MIN_EXTENSION_WINO_V2, MAX_EXTENSION_WINO_V2, max_m_num),
            var_range=[MIN_EXTENSION_WINO_V2, MAX_EXTENSION_WINO_V2])

        TikCheckUtil.check_in_range_by_dtype(
            self.m_extension, msg="m_extension should be in the range of [%s, MatrixM(%s)], input m_extension: %s"
            % (MIN_EXTENSION, max_m_num, self.m_extension), var_range=[MIN_EXTENSION, max_m_num])
        TikCheckUtil.check_in_range_by_dtype(
            self.m_start_pt, msg="m_start_pt should be in the range of [%s, MatrixM(%s)], input m_start_pt: %s"
            % (min_start_pt, max_m_num, self.m_start_pt), var_range=[min_start_pt, max_m_num])
        TikCheckUtil.check_in_range_by_dtype(
            self.k_start_pt, msg="k_start_pt should be in the range of [%s, cin(%s)], input k_start_pt: %s"
            % (min_start_pt, max_k_num, self.k_start_pt), var_range=[min_start_pt, max_k_num])
        TikCheckUtil.check_in_range_by_dtype(
            self.k_extension, msg="k_extension should be in the range of [%s, cin(%s)], input k_extension: %s"
            % (MIN_EXTENSION, max_k_num, self.k_extension), var_range=[MIN_EXTENSION, max_k_num])

        k_start_pt = Expr(self.k_start_pt).eval_value()
        if k_start_pt is not None:
            if k_start_pt % src_c0 != 0:
                TikCheckUtil.raise_error(
                    "k_start_pt should be multiple of C0, input k_start_pt: %s, C0: %s" % (k_start_pt, src_c0))

        k_extension = Expr(self.k_extension).eval_value()
        if k_extension is not None:
            if k_extension % src_c0 != 0:
                TikCheckUtil.raise_error(
                    "k_extension should be multiple of C0, input k_extension: %s, C0: %s" % (k_extension, src_c0))
            if k_start_pt is not None:
                # we will calculate k <= matrixK
                TikCheckUtil.check_le(k_start_pt + k_extension, max_k_num,
                                      "k_start_pt + k_extension should less than max_k_num: %s" % max_k_num)

        m_start_pt = Expr(self.m_start_pt).eval_value()
        m_extension = Expr(self.m_extension).eval_value()
        if m_start_pt is not None:
            if m_start_pt % 16 != 0:
                TikCheckUtil.raise_error(
                    "m_start_pt should be multiple of 16, input m_start_pt: %s" % m_start_pt)
            if m_extension is not None:
                # we will calculate m <= matrixM
                TikCheckUtil.check_le(
                    ceil_div(m_extension, 16) * 16 + m_start_pt, max_m_num,
                    "ceil(m_extension, 16)*16 + m_start_pt should less than max_m_num: %s" % max_m_num)

    @source_info_decorator(depth=2)
    @load_winograd_fm_decorator
    def run_all(self):
        """
        load_winograd_fm api run_all
        """
        self._check_all()

        c0 = 32 // DTYPE_SIZE[self.src.dtype]
        _, c1, l1_h, l1_w, src_c0 = self.src.shape
        TikCheckUtil.check_equality(c0, src_c0, "load_winograd_fm's c0 should be {}, but get {}".format(c0, src_c0))
        l1_c = c1 * src_c0

        self.check_wino_ft_params_v2(l1_w, l1_h, l1_c, c0)
        if all(Expr(value).eval_value() is not None for value in [self.k_extension, self.m_extension, self.dst.offset]):
            m_ext = ceil_div(self.m_extension, ELE_PER_FRACTAL_EDGE) * ELE_PER_FRACTAL_EDGE
            dst_expected_ele = Expr(self.k_extension * m_ext * 16 + self.dst.offset).eval_value()
            dst_actual_ele = reduce_mul(self.dst.original_shape)
            TikCheckUtil.check_ge(
                dst_actual_ele, dst_expected_ele,
                "dst tensor overflow, expected dst shape: {}, actual dst shape: "
                "{}".format(dst_expected_ele, dst_actual_ele))
        # one instr writes 4 expand feature maps
        src_extent = Expr(l1_w * l1_h * l1_c * DTYPE_SIZE[self.src.dtype]).get()
        dst_extent = ceil_div(self.m_extension, 16) * 16 * self.k_extension * 16 * DTYPE_SIZE[self.src.dtype]
        dst_extent = Expr(dst_extent).get()
        params = [
            l1_w, l1_h, l1_c, WINO_PAD_MAP[(self.pad[0], self.pad[1])], WINO_PAD_MAP[(self.pad[2], self.pad[3])],
            self.k_extension, self.k_start_pt, self.m_extension, self.m_start_pt
        ]
        with self.tik_instance.new_scope():
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_MTE1)
            instr = tvm.call_extern(
                self.dst.dtype, "load_cbuf_to_ca_winograd_v2",
                self.dst.access_ptr("w", extent=dst_extent),
                self.src.access_ptr("r", extent=src_extent), *type_convert(params))
            self.tik_instance.emit(instr)

    def _check_all(self):
        # check scope
        TikCheckUtil.check_type_match(self.dst, Tensor, "dst should be tensor")
        TikCheckUtil.check_equality(
            self.dst.scope, "local.L0A",
            "dst scope should be l0a, input scope: {}".format(self.dst.scope))
        TikCheckUtil.check_type_match(self.src, Tensor, "src should be tensor")
        TikCheckUtil.check_equality(
            self.src.scope, "local.L1",
            "src scope should be l1, input scope: {}".format(self.src.scope))
        TikCheckUtil.check_equality(
            5, len(self.src.shape), "load_winograd_fm's src should be [N,C1,H,W,C0].")
        # check dtype
        TikCheckUtil.check_equality(
            self.dst.dtype, self.src.dtype, "load_winograd_fm {}'s src's dtype should be equal to dst's dtype")
        TikCheckUtil.check_equality(
            intrinsic_check_support(
                "Intrinsic_" + "load_cbuf_to_ca_winograd_v2", self.dst.dtype), True,
            gen_api_check_statement(self.dst.dtype, "load_winograd_fm"))

        # check pad
        TikCheckUtil.check_type_match(self.pad, (list, tuple), "pad should be list or tuple")
        TikCheckUtil.check_equality(len(self.pad), 4, "pad should be four-dimensional")
        valid_pad_map_for_wino = ([0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [2, 0])
        for num in self.pad:
            TikCheckUtil.check_type_match(num, int, "pad should be a list of int")
        pad_left, pad_right, pad_top, pad_bottom = self.pad
        valid_pad_str = " ".join(str(tuple(valid_pad)) for valid_pad in valid_pad_map_for_wino)
        TikCheckUtil.check_var_in_list(
            [pad_left, pad_right], valid_pad_map_for_wino,
            "left pad and right pad should be equal to " + valid_pad_str +
            "but get (" + str(pad_left) + ", " + str(pad_right) + ").")
        TikCheckUtil.check_var_in_list(
            [pad_top, pad_bottom], valid_pad_map_for_wino,
            "top pad and bottom pad should be equal to " + valid_pad_str +
            "but get (" + str(pad_top) + ", " + str(pad_bottom) + ").")
        # check m & k
        self.check_mk_extension_start()


class LoadWinoGardWeApi(TikIRBuilder):
    """
    load_winograd_fm api class
    """

    def __init__(self, tik_instance, dst, src, dtype_mode):
        super(LoadWinoGardWeApi, self).__init__()
        self.tik_instance = tik_instance
        self.dst = dst
        self.src = src
        self.dtype_mode = dtype_mode

    def check_tensor_scope_type(self):
        """
        checp src dst scope and type
        """
        TikCheckUtil.check_type_match(self.dst, Tensor, "dst should be tensor")
        TikCheckUtil.check_type_match(self.src, Tensor, "src should be tensor")
        # check dtype
        TikCheckUtil.check_equality(self.dst.dtype, self.src.dtype,
                                    "load_winograd_fm {}'s src's dtype should be equal to dst's dtype")
        TikCheckUtil.check_equality(
            intrinsic_check_support("Intrinsic_" + "load_cbuf_to_cb_winograd_v2", self.dst.dtype), True,
            gen_api_check_statement(self.dst.dtype, "load_winograd_weight"))
        TikCheckUtil.check_equality(5, len(self.src.shape),
                                    "load_winograd_weight's src should be (Ci/C0),(Ni/8),(3*3),8,C0.")
        TikCheckUtil.check_equality(5, len(self.dst.shape),
                                    "load_winograd_weight's src should be (Ci/C0),(Nb/16),(4*4),16,32.")
        # check scope
        TikCheckUtil.check_equality(
            self.dst.scope, "local.L0B", "dst scope should be l0b, input scope: {}".format(self.dst.scope))
        TikCheckUtil.check_equality(
            self.src.scope, "local.L1", "src scope should be l1, input scope: {}".format(self.src.scope))
        TikCheckUtil.check_type_match(self.dtype_mode, (int), "dtype_mode must be int.")
        TikCheckUtil.check_var_in_list(
            self.dtype_mode, [0, 1], "dtype_mode must be 0 or 1, but get {}.".format(self.dtype_mode))

    @source_info_decorator(depth=2)
    @load_winograd_weight_decorator
    def run_all(self):
        """
        load_winograd_fm api run_all
        """
        self.check_tensor_scope_type()

        c1, eight_multi_channel, _, _, _ = self.src.shape
        _, sixteen_multi_nb, _, _, _ = self.dst.shape

        if self.dtype_mode == 0:
            c0 = 32
        else:
            c0 = 16

        self._check_tensor_shape(c0)

        input_channel_size = c0 * c1
        _check_input_channel_size(input_channel_size, c0)

        input_kernel_num = eight_multi_channel * 8
        _check_input_kernel_num(input_kernel_num)

        output_kernel_num = sixteen_multi_nb * 16
        _check_output_kernel_num(input_kernel_num, output_kernel_num)

        src_extent = input_channel_size * input_kernel_num * 9 * 512
        dst_extent = input_channel_size * output_kernel_num * 16 * 512

        params = [input_channel_size, input_kernel_num, output_kernel_num, self.dtype_mode]
        with self.tik_instance.new_scope():
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_MTE1)
            instr = tvm.call_extern(
                self.dst.dtype, "load_cbuf_to_cb_winograd_v2",
                self.dst.access_ptr("w", extent=dst_extent),
                self.src.access_ptr("r", extent=src_extent), *type_convert(params))
            self.tik_instance.emit(instr)

    def _check_tensor_shape(self, c0):

        c1, _, fractal_num, eight, src_c0 = self.src.shape
        dst_c1, _, four_dot_four, sixteen, thirty_two = self.dst.shape
        TikCheckUtil.check_equality(eight, 8,
                                    "load_winograd_weight's src should be (Ci/C0),(Ni/8),(3*3),8,C0.")
        TikCheckUtil.check_equality(fractal_num, 9,
                                    "load_winograd_weight's src should be (Ci/C0),(Ni/8),(3*3),8,C0.")
        TikCheckUtil.check_equality(dst_c1, c1,
                                    "load_winograd_weight's dst should be (Ci/C0),(Nb/16),(16),16,32.")
        TikCheckUtil.check_equality(four_dot_four, 16,
                                    "load_winograd_weight's dst should be (Ci/C0),(Nb/16),(16),16,32.")
        TikCheckUtil.check_equality(sixteen, 16,
                                    "load_winograd_weight's dst should be (Ci/C0),(Nb/16),(16),16,32.")
        TikCheckUtil.check_equality(thirty_two, 32,
                                    "load_winograd_weight's dst should be (Ci/C0),(Nb/16),(16),16,32.")

        TikCheckUtil.check_equality(src_c0, c0,
                                    "load_winograd_weight's src should be (Ci/C0),(Ni/8),(3*3),8,C0.")


class WinoFmTfApi(TikIRBuilder):
    """
    winograd_feature_map_transform api class
    """

    def __init__(self, tik_instance, w_fm_tf_api):
        super(WinoFmTfApi, self).__init__()
        self.tik_instance = tik_instance
        self.dst = w_fm_tf_api.dst
        self.src = w_fm_tf_api.src
        self.l1_h = w_fm_tf_api.l1_h
        self.l1_w = w_fm_tf_api.l1_w
        self.l1_c = w_fm_tf_api.l1_c
        self.pad_left = w_fm_tf_api.pad_left
        self.pad_right = w_fm_tf_api.pad_right
        self.pad_top = w_fm_tf_api.pad_top
        self.pad_bottom = w_fm_tf_api.pad_bottom
        self.m_extension = w_fm_tf_api.m_extension
        self.m_start_pt = w_fm_tf_api.m_start_pt
        self.k_extension = w_fm_tf_api.k_extension
        self.k_start_pt = w_fm_tf_api.k_start_pt
        self.column_indicator = w_fm_tf_api.column_indicator
        self.dst_stride = w_fm_tf_api.dst_stride

    def check_all(self):
        """
        check winograd_feature_map_transform all params
        """
        self._check_tensor_scope_type()
        # check src dst address 512B align
        align = 512
        check_address_align((self.src, self.dst), ("src", "dst"), align)

        check_mmad_param_type_range('m_extension', self.m_extension, end=MAX_EXTENSION)

        check_mmad_param_type_range('m_start_pt', self.m_start_pt, end=MAX_START_PT)
        if self.m_start_pt is not None:
            m_start_pt_ele_align = 16
            if self.m_start_pt % m_start_pt_ele_align != 0:
                TikCheckUtil.raise_error("m_start_ptshould be multiple of 16, input m_start_pt: %s" % self.m_start_pt)

        check_mmad_param_type_range('k_start_pt', self.k_start_pt, end=MAX_K_WINO)
        k_start_pt = Expr(self.k_start_pt).eval_value()
        if k_start_pt is not None:
            k_start_pt_byte_align = 32
            if k_start_pt * DTYPE_SIZE[self.src.dtype] % k_start_pt_byte_align != 0:
                TikCheckUtil.raise_error("k_start_pt in Byte should be multiple of 32B, input "
                                         "k_start_pt: %s, input src dtype: %s" % (k_start_pt, self.src.dtype))

        check_mmad_param_type_range('k_extension', self.k_extension, end=MAX_K_WINO)
        k_extension = Expr(self.k_extension).eval_value()
        if k_extension is not None:
            k_extension_byte_align = 32
            if k_extension * DTYPE_SIZE[self.src.dtype] % k_extension_byte_align != 0:
                TikCheckUtil.raise_error("k_extension in Byte should be multiple of 32B, input "
                                         "k_extension: %s, input src dtype: %s" % (k_extension, self.src.dtype))

        # check feature map size
        TikCheckUtil.check_in_range_by_dtype(
            self.l1_h, msg="l1_h should be in the range of [%s, %s], input l1_h: %s"
            % (MIN_L1_H_W_C, MAX_L1_H_W, self.l1_h), var_range=[MIN_L1_H_W_C, MAX_L1_H_W])
        TikCheckUtil.check_in_range_by_dtype(
            self.l1_w, msg="l1_w should be in the range of [%s, %s], input l1_w: %s"
            % (MIN_L1_H_W_C, MAX_L1_H_W, self.l1_w), var_range=[MIN_L1_H_W_C, MAX_L1_H_W])
        TikCheckUtil.check_in_range_by_dtype(
            self.l1_c, msg="l1_c should be in the range of [%s, %s], input l1_c: %s"
            % (MIN_L1_H_W_C, MAX_L1_C, self.l1_c), var_range=[MIN_L1_H_W_C, MAX_L1_C])
        # check dst_stride
        check_mmad_param_type_range('dst_stride', self.dst_stride, end=MAX_DST_GAP_WINO, is_debug=True)

        # check padding
        pad_left = Expr(self.pad_left).eval_value()
        pad_right = Expr(self.pad_right).eval_value()
        if pad_left is not None and pad_right is not None:
            TikCheckUtil.check_var_in_list(
                (pad_left, pad_right), WINO_PAD_MAP.keys(), "(pad_left, pad_right) should be (0, 0), (0, 1), (0, 2), "
                "(1, 0), (1, 1) or (1,2), input pad_left: %s, pad_right: %s" % (pad_left, pad_right))
        pad_top = Expr(self.pad_top).eval_value()
        pad_bottom = Expr(self.pad_bottom).eval_value()
        if pad_top is not None and pad_bottom is not None:
            TikCheckUtil.check_var_in_list(
                (pad_top, pad_bottom), WINO_PAD_MAP.keys(), "(pad_top, pad_bottom) should be (0, 0), (0, 1), (0, 2), "
                "(1, 0), (1, 1) or (1,2), input pad_top: %s, pad_bottom: %s" % (pad_top, pad_bottom))

        # check column_indicator
        check_mmad_param_type_range('column_indicator', self.column_indicator, end=MAX_COL_INDIC, is_debug=True)

    @source_info_decorator(depth=2)
    @winograd_fm_transform_decorator
    def run_all(self):
        """
        winograd_feature_map_transform api run_all
        """
        self.check_all()

        # calculate extent
        src_extent_val = Expr(self.l1_w * self.l1_h * self.l1_c * DTYPE_SIZE[self.src.dtype]).get()
        # one instr writes 4 expand feature maps
        expand_fm_num = 4
        dst_extent = self.m_extension * self.k_extension * expand_fm_num * DTYPE_SIZE[self.src.dtype] + \
                     self.dst_stride * BYTE_PER_FRACTAL * (expand_fm_num - 1)
        dst_extent_val = Expr(dst_extent).get()
        # code gen
        config = [self.l1_w, self.l1_h, self.l1_c, self.dst_stride, self.column_indicator,
                  WINO_PAD_MAP[(self.pad_left, self.pad_right)], WINO_PAD_MAP[(self.pad_top, self.pad_bottom)]]
        reg_xm = concat_params(config, WINO_FM_XM_OFFSET_LIST, WINO_FM_XM_SEGMENT_LIST)

        config = [self.k_extension, self.k_start_pt, self.m_extension, self.m_start_pt]
        reg_xt = concat_params(config, WINO_FM_XT_OFFSET_LIST, WINO_FM_XT_SEGMENT_LIST)
        with self.tik_instance.new_scope():
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_MTE1)
            instr = tvm.call_extern(
                self.dst.dtype, "load_cbuf_to_ca_winograd",
                self.dst.access_ptr("w", extent=dst_extent_val),
                self.src.access_ptr("r", extent=src_extent_val), reg_xm, reg_xt)
            self.tik_instance.emit(instr)

    def _check_tensor_scope_type(self):
        arch_version = get_soc_name() + get_soc_core_type()
        # check instruction
        TikCheckUtil.check_var_in_list(
            arch_version, arch_version_dst_src_map.keys(),
            "input core_arch: {} doesn't support "
            "winograd_feature_map_transform.".format(arch_version))
        # check scope
        TikCheckUtil.check_equality(
            self.dst.scope, "local.L0A", "dst scope should be l0a, input scope: {}".format(self.dst.scope))
        TikCheckUtil.check_equality(
            self.src.scope, "local.L1", "src scope should be l1, input scope: {}".format(self.src.scope))
        # check dtype
        dtype_str = DTYPE_MAP.get(self.dst.dtype) + DTYPE_MAP.get(self.src.dtype)
        TikCheckUtil.check_var_in_list(
            dtype_str, arch_version_dst_src_map.get(arch_version),
            "{} winograd_feature_map_transform doesn't support from {} to {}".format(arch_version,
                                                                                     self.src.dtype, self.dst.dtype))


class WinoWeTfApi(TikIRBuilder):
    """
    winograd_weight_transform api class
    """

    def __init__(self, tik_instance, w_we_tf_api):
        super(WinoWeTfApi, self).__init__()
        self.tik_instance = tik_instance
        self.dst = w_we_tf_api.dst
        self.src = w_we_tf_api.src
        self.column_indicator = w_we_tf_api.column_indicator
        self.repeat_dir = w_we_tf_api.repeat_dir
        self.repeat_times = w_we_tf_api.repeat_times
        self.dst_blk_stride = w_we_tf_api.dst_blk_stride
        self.dst_rep_stride = w_we_tf_api.dst_rep_stride
        self.src_rep_stride = w_we_tf_api.src_rep_stride
        self.en_weight_offset = w_we_tf_api.en_weight_offset
        self.smask = w_we_tf_api.smask

    def check_all(self, arch_version):
        """
        check winograd_weight_transform all params
        """
        # check instruction

        TikCheckUtil.check_var_in_list(
            arch_version, arch_version_dst_src_map.keys(),
            "input core_arch: {} doesn't support winograd_weight_transform.".format(arch_version))

        # check scope
        TikCheckUtil.check_equality(
            self.dst.scope, "local.L0B",
            "dst scope should be l0b, input scope: {}".format(self.dst.scope))
        TikCheckUtil.check_equality(
            self.src.scope, "local.L1",
            "src scope should be l1, input scope: {}".format(self.src.scope))
        # check src dst address 512B align
        align = 512
        check_address_align((self.src, self.dst), ("src", "dst"), align)
        # check dtype
        dtype_str = DTYPE_MAP.get(self.dst.dtype) + DTYPE_MAP.get(self.src.dtype)
        TikCheckUtil.check_var_in_list(
            dtype_str, arch_version_dst_src_map.get(arch_version),
            "{} winograd_weight_transform doesn't support from {} to {}".format(arch_version,
                                                                                self.src.dtype, self.dst.dtype))
        # check column_indicator, repeat_dir
        check_mmad_param_type_range('column_indicator', self.column_indicator, end=MAX_COL_INDIC)
        check_mmad_param_type_range('repeat_dir', self.repeat_dir, end=MAX_REP_DIR)

        # check repeat_times
        check_repeat_times(self.repeat_times)
        # check stride
        check_mmad_param_type_range('dst_blk_stride', self.dst_blk_stride, end=MAX_BLK_STRIDE_SINGLE_BYTE)
        check_mmad_param_type_range('dst_rep_stride', self.dst_rep_stride, end=MAX_REP_STRIDE_SINGLE_BYTE)
        check_mmad_param_type_range('src_rep_stride', self.src_rep_stride, end=MAX_REP_STRIDE_DOUBLE_BYTE)

    @source_info_decorator(depth=2)
    @winograd_weight_trans_decorator
    def run_all(self):
        """
        winograd_weight_transform api run_all
        """
        arch_version = get_soc_name() + get_soc_core_type()
        self.check_all(arch_version)
        # check en_weight_offset
        if self.en_weight_offset:
            TikCheckUtil.check_equality(
                arch_version, HI3796CV300CSAIC,
                "{} doesn't support weight_offset.".format(arch_version))
            check_weight_offset(self.smask, "winograd_weight_transform", "smask")
            # not support smask yet
            smask_addr = self.smask.accss_ptr("r")
            woff_bit = 1
        else:
            smask_addr = 0
            woff_bit = 0
        # calculate extent
        src_extent, dst_extent = _calculate_winograd_ft_extent(
            self.repeat_times, self.src_rep_stride, self.dst_rep_stride, self.dst_blk_stride)
        # code gen
        # smask cannot support config mode
        config = [self.dst_blk_stride, self.src_rep_stride, self.dst_rep_stride, smask_addr,
                  self.column_indicator, self.repeat_dir, woff_bit, self.repeat_times]
        args = concat_params(config, WINO_WGT_OFFSET_LIST, WINO_WGT_SEGMENT_LIST)
        with self.tik_instance.new_scope():
            self.tik_instance.scope_attr(tvm.thread_axis("cce"), "coproc_scope", PIPE_MTE1)
            instr = tvm.call_extern(
                self.dst.dtype, "load_cbuf_to_cb_winograd",
                self.dst.access_ptr("w", extent=dst_extent),
                self.src.access_ptr("r", extent=src_extent), args)
            self.tik_instance.emit(instr)
