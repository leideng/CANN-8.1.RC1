#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     decorators.py
DESC:     this file contains many decorator
CREATED:  2019-7-04 20:12:13
MODIFIED: 2019-7-24 14:04:45
"""
from functools import wraps
from tbe.tik.debug.intrinsic import Set2D
from tbe.tik.debug.intrinsic import LoadSmask
from tbe.tik.debug.intrinsic import Printf
from tbe.tik.debug.intrinsic import GetStatusSPR
from tbe.tik.debug.object_detect import RpnCorDiag
from tbe.tik.debug.statement import SetTensor
from tbe.tik.debug.statement import SetTensorAddr
from tbe.tik.debug.intrinsic_flow_control import ForLoop
from tbe.tik.debug.intrinsic_flow_control import IfScope
from tbe.tik.debug.intrinsic_flow_control import ElseScope
from tbe.tik.debug.intrinsic_flow_control import Break
from tbe.tik.debug.intrinsic_flow_control import Continue
from tbe.tik.debug.intrinsic_flow_control import BlockBarrier
from tbe.tik.debug.statement import Return
from tbe.tik.debug.intrinsic_tensor import TensorDef
from tbe.tik.debug.intrinsic_tensor import TensorProxyDef
from tbe.tik.debug.statement import GetitemScalarArray
from tbe.tik.debug.statement import VectorDef
from tbe.tik.debug.decorators_common import FRAME_INFO_IDX
from tbe.tik.debug.decorators_common import SCALAR_INIT_STACK_DEPTH
from tbe.tik.debug.decorators_common import SCALAR_SET_AS_STACK_DEPTH
from tbe.tik.debug.decorators_common import scalar_array_set_as_fn
from tbe.tik.debug.decorators_common import scalar_set_as_fn
from tbe.tik.debug.decorators_common import WrapCtxMgr
from tbe.tik.debug.decorators_common import change_crtl
from tbe.tik.debug.decorators_common import set_ctx_value
from tbe.tik.debug.intrinsic_flow_control import HighLevelAPIScope
from tbe.tik.debug.statement import GetAddr
from tbe.tik.debug.statement import DelLoopVar
from tbe.tik.debug.intrinsic_tensor import DelTensor
from tbe.tik.debug.tensor_addr_debug import TensorAddrDef
from tbe.tik.debug.tensor_addr_debug import TensorAddrProxyDef
from tbe.tik.debug.tikdbg.codemapping import get_caller_context
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.common.common_util import is_tensor
from tbe.tik.common.common_util import is_scalar
from tbe.tik.common.common_util import is_scalar_array
from tbe.tik.common.tik_ir_builder_util import ForLoopTuple
from tbe.tik.tik_lib.tik_params import get_atomic_add_mod_start_pos
from tbe.tik.tik_lib.tik_params import get_atomic_add_mod_end_pos
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_vdp_debug import VDP


def new_high_level_api_debug_decorator(func):
    """
    bind this decorator with build_cce

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """

    @wraps(func)
    def wrapper(op_obj):
        # the first arg must be tik_instance
        tik_instance = op_obj.tik_instance
        ctx = tik_instance.context
        library_call = HighLevelAPIScope(get_caller_context(), ctx.tik_debugger)
        ctx.add_scope(library_call)
        return_value = func(op_obj)
        ctx.pop_scope()
        return return_value

    return wrapper


def high_level_api_debug_decorator(func):
    """
    bind this decorator with build_cce

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """

    @wraps(func)
    def wrapper(*args, **kwargs):
        # the first arg must be tik_instance
        tik_instance = args[0]
        ctx = tik_instance.context
        library_call = HighLevelAPIScope(get_caller_context(), ctx.tik_debugger)
        ctx.add_scope(library_call)
        return_value = func(*args, **kwargs)
        ctx.pop_scope()
        return return_value

    return wrapper


def printf_decorator(func):
    """
    bind this decorator with printf func

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """

    @wraps(func)
    def wrapper(tik_instance, format_string, *args):
        """
        bind this decorator with load2dv1_decorator
        """
        if not tik_instance.debug_disabled:
            printf_stmt = Printf(get_caller_context(1), format_string, tik_instance.context.tik_debugger, *args)
            tik_instance.context.curr_scope().add_stmt(printf_stmt)
        return func(tik_instance, format_string, *args)

    return wrapper


def build_cce_decorator(func):
    """
    bind this decorator with build_cce

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """

    @wraps(func)
    def wrapper(build_obj):
        """
        bind this decorator with build_cce
        """
        if not build_obj.tik_instance.debug_disabled:
            ctx = build_obj.tik_instance.context
            set_ctx_value(ctx, build_obj)
            # set tik code has gone to BuildCCE.
            ctx.is_build_cce = True
        return func(build_obj)
    return wrapper


def tensor_register(cls):
    """
    bind this decorator with tensor

    Parameters
    ----------
    cls : the decorated class

    Returns
    -------
    class
    """
    original__init__ = cls.__init__

    @wraps(original__init__)
    def __init__(self, *args, **kwargs):
        original__init__(self, *args, **kwargs)
        if not self.ir_generator.debug_disabled:
            ctx = self.ir_generator.context
            if 'dims' not in kwargs:
                # a tensor
                tensor_init_stmt = TensorDef(
                    get_caller_context(depth=FRAME_INFO_IDX), self, ctx.tik_debugger, kwargs)
                ctx.curr_scope().add_stmt(tensor_init_stmt)
                ctx.tensor_list.append(self)
            else:
                # a tensor proxy
                proxy_init_stmt = TensorProxyDef(
                    get_caller_context(depth=FRAME_INFO_IDX), self, ctx.tik_debugger)
                proxy_init_stmt.traceable = False

                # if tik code has gone to BuildCCE(is_build_cce= True), add_stmt cannot be added.
                if not ctx.is_build_cce:
                    ctx.curr_scope().add_stmt(proxy_init_stmt)
                    ctx.add_proxy(self)
        else:
            if 'dims' not in kwargs:
                self.ir_generator.context.tensor_list.append(self)

    cls.__init__ = __init__
    return cls


def tensor_addr_register(cls):
    """
    bind this decorator with tensor addr

    Parameters
    ----------
    cls : the decorated class

    Returns
    -------
    class
    """
    original__init__ = cls.__init__

    @wraps(original__init__)
    def __init__(self, *args, **kwargs):
        original__init__(self, *args, **kwargs)
        if not self.ir_generator.debug_disabled:
            ctx = self.ir_generator.context
            if 'dims' not in kwargs:
                # a tensor addr
                tensor_init_stmt = TensorAddrDef(
                    get_caller_context(depth=FRAME_INFO_IDX), self, ctx.tik_debugger)
                ctx.curr_scope().add_stmt(tensor_init_stmt)
                ctx.tensor_list.append(self)
            else:
                # a tensor addr proxy
                proxy_init_stmt = TensorAddrProxyDef(
                    get_caller_context(depth=FRAME_INFO_IDX), self, ctx.tik_debugger)
                ctx.curr_scope().add_stmt(proxy_init_stmt)
                ctx.add_proxy(self)
        else:
            if 'dims' not in kwargs:
                self.ir_generator.context.tensor_list.append(self)

    cls.__init__ = __init__
    return cls


def vector_register(cls):
    """
    bind this decorator with vector

    Parameters
    ----------
    cls : the decorated class

    Returns
    -------
    class
    """

    original__init__ = cls.__init__

    @wraps(original__init__)
    def __init__(self, *args, **kwargs):
        original__init__(self, *args, **kwargs)
        if not self.ir_generator.debug_disabled:
            ctx = self.ir_generator.context
            # a Vector
            vector_init_stmt = VectorDef(get_caller_context(FRAME_INFO_IDX), self, ctx.tik_debugger)
            ctx.curr_scope().add_stmt(vector_init_stmt)
            ctx.vector_list.append(self)

    cls.__init__ = __init__
    return cls


def scalar_register(cls):
    """
    bind this decorator with scalar

    Parameters
    ----------
    cls : the decorated class

    Returns
    -------
    class
    """
    original__init__ = cls.__init__

    @wraps(original__init__)
    def __init__(self, ir_generator, dtype="int64", name="reg_buf", init_value=None, if_global_scope=False,
                 buffer_=None, offset=None, debug_var=None, available=True):
        # too many arguments
        with ir_generator.context.freeze():
            original__init__(self, ir_generator, dtype, name,
                             init_value, if_global_scope, buffer_, offset, debug_var, available)
        if not ir_generator.debug_disabled:
            self.ir_generator.context.set_scalar_location(self, get_caller_context(depth=FRAME_INFO_IDX))
            if init_value is not None:
                scalar_set_as_fn(self, init_value, SCALAR_INIT_STACK_DEPTH, True)

    cls.__init__ = __init__
    return cls


def scalar_array_register(cls):
    """
    bind this decorator with scalar_array

    Parameters
    ----------
    cls : the decorated class

    Returns
    -------
    class
    """
    original__init__ = cls.__init__

    @wraps(original__init__)
    def __init__(self, ir_generator, dtype="int64", length=1, name="reg_buf", init_value=None, buffer_=None,
                 offset=None, debug_var=None):
        # too many arguments
        with ir_generator.context.freeze():
            original__init__(self, ir_generator, dtype, length, name, init_value, buffer_, offset, debug_var)
        if not ir_generator.debug_disabled:
            self.ir_generator.context.set_scalar_location(self, get_caller_context(depth=FRAME_INFO_IDX))
            if init_value is not None:
                scalar_array_set_as_fn(self, init_value, SCALAR_INIT_STACK_DEPTH, True)

    cls.__init__ = __init__
    return cls


def del_loop_var_decorator(func):
    """
    bind this decorator with loop var set_as to None

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """

    @wraps(func)
    def wrapper(tik_builder, loop_var):
        """
        bind this decorator with loop_var set_as to None
        """
        if not tik_builder.debug_disabled:
            ctx = tik_builder.context
            stmt = DelLoopVar(get_caller_context(depth=SCALAR_SET_AS_STACK_DEPTH), loop_var, ctx.tik_debugger)
            stmt.traceable = False
            ctx.curr_scope().add_stmt(stmt)
        return func(tik_builder, loop_var)
    return wrapper


def del_scalar_decorator(func):
    """
    bind this decorator with Scalar/ScalarArray set_as to None

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """

    @wraps(func)
    def wrapper(scalar_manager, scalar):
        """
        bind this decorator with set_as to None
        """
        if not scalar.ir_generator.debug_disabled:
            if is_scalar(scalar):
                scalar_set_as_fn(scalar, None)
            elif is_scalar_array(scalar):
                scalar_array_set_as_fn(scalar, None)
        return func(scalar_manager, scalar)
    return wrapper


def tensor_set_as_decorator(func):
    """
    bind this decorator with set_as

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """

    @wraps(func)
    def wrapper(self, value, dst_offset=0, src_offset=None):
        """
        bind this decorator with set_as
        """
        if not self.ir_generator.debug_disabled:
            ctx = self.ir_generator.context
            stmt = SetTensor(get_caller_context(depth=2), self, value, ctx.tik_debugger)
            stmt.traceable = False
            ctx.curr_scope().add_stmt(stmt)
        return func(self, value, dst_offset, src_offset)
    return wrapper


def tensor_addr_set_as_decorator(func):
    """
    tensor addr set as decorator
    Parameters
    ----------
    func: set_as function

    Returns
    -------

    """
    @wraps(func)
    def wrapper(self, value, dst_offset=0, src_offset=None):
        if not self.ir_generator.debug_disabled:
            ctx = self.ir_generator.context
            stmt = SetTensorAddr(get_caller_context(depth=2), self, value, ctx.tik_debugger)
            stmt.traceable = False
            ctx.curr_scope().add_stmt(stmt)
        return func(self, value, dst_offset, src_offset)
    return wrapper


def del_tensor_decorator(func):
    """
    bind this decorator with Tensor set_as to None

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """

    @wraps(func)
    def wrapper(tensor_manager, tensor):
        """
        bind this decorator with Tensor set_as to None
        """
        if not tensor.ir_generator.debug_disabled:
            ctx = tensor.ir_generator.context
            stmt = DelTensor(get_caller_context(depth=2), tensor, ctx.tik_debugger)
            stmt.traceable = False
            ctx.curr_scope().add_stmt(stmt)
        return func(tensor_manager, tensor)

    return wrapper


def tensor_get_addr_decorator(func):
    """
    bind this decorator with set_as

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """

    @wraps(func)
    def wrapper(self, value):
        """
        bind this decorator with set_as
        """
        if is_tensor(value):
            if not value.is_single_point():
                return func(self, value)
        if not self.ir_generator.debug_disabled:
            ctx = self.ir_generator.context
            stmt = GetAddr(get_caller_context(depth=2), self, value, ctx.tik_debugger)
            stmt.traceable = False
            ctx.curr_scope().add_stmt(stmt)
        return func(self, value)
    return wrapper


def scalar_set_as_decorator(func):
    """
    bind this decorator with scalar set_as

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(scalar, value, src_offset=None):
        """
        bind this decorator with scalar set_as
        """
        if not scalar.ir_generator.debug_disabled:
            scalar_set_as_fn(scalar, value)
        return func(scalar, value, src_offset)
    return wrapper


def scalar_array_set_as_decorator(func):
    """
    bind this decorator with scalar_array set_as

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(scalar_array, value):
        """
        bind this decorator with scalar_array set_as
        """
        if not scalar_array.ir_generator.debug_disabled:
            scalar_array_set_as_fn(scalar_array, value)
        return func(scalar_array, value)
    return wrapper


def scalar_array_getitem_decorator(func):
    """
    bind this decorator with __getitem__

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(self, index_in):
        """
        bind this decorator with __getitem__
        """
        if not self.ir_generator.debug_disabled:
            ctx = self.ir_generator.context
            stmt = GetitemScalarArray(get_caller_context(depth=2), self, index_in, ctx.tik_debugger)
            stmt.traceable = False
            ctx.curr_scope().add_stmt(stmt)
        return func(self, index_in)

    return wrapper


def block_barrier_decorator(func):
    """
    debug decorator for block_barrier

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(self, block_num):
        """
        bind this decorator with block_barrier
        """
        if not self.debug_disabled:
            ctx = self.context
            stmt = BlockBarrier(get_caller_context(depth=2), ctx.tik_debugger, block_num)
            stmt.traceable = True
            ctx.curr_scope().add_stmt(stmt)
        return func(self, block_num)

    return wrapper


def for_range_decorator(func):
    """
    bind this decorator with for_range

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(self, range_tuple):
        """
        bind this decorator with for_range
        """
        ctx_mgr = func(self, range_tuple)
        if not self.debug_disabled:
            ctx = self.context
            _, extent = ctx_mgr.debug_limit
            for hint in ctx_mgr.debug_hint:
                loop_var, (begint, endt) = hint
                loop_tuple = ForLoopTuple(begint, endt, loop_var, range_tuple.block_num,
                                          get_caller_context(depth=2), range_tuple.dtype, ctx.tik_debugger)
                loop = ForLoop(loop_tuple, range_tuple.thread_num, extent)
                if not isinstance(range_tuple.block_num, int):
                    ctx.tik_debug.block_end = range_tuple.block_num
                if isinstance(range_tuple.block_num, int) and range_tuple.block_num > 1:
                    ctx.tik_debug.is_single_core = False
                    ctx.tik_debug.block_end = range_tuple.block_num

                loop.set_visible(False)
                ctx.add_scope(loop)
                ctx.bind_var(loop_var)
            # since a for loop may be implictly split
            # into multi loops due to muti-threading
            # only the inner most loop is visible to the user
            loop.set_visible(True)

            # insert a if stmt to limit the loop_var
            real_loop_var, real_loop_limit = ctx_mgr.debug_limit
            if_stmt = IfScope('ifscope', real_loop_var < real_loop_limit,
                              get_caller_context(depth=2), ctx.tik_debugger)
            if_stmt.traceable = False
            if_stmt.then_block.traceable = False
            ctx.add_scope(if_stmt)
        return WrapCtxMgr(ctx_mgr, self)

    return wrapper


def for_range_sub_decorator(func: any) -> any:
    """
    bind this decorator with for_range_subblk

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    def insert_if(ctx: any, ctx_mgr: any) -> any:
        """
        Auxiliary function
        """
        real_loop_var, real_loop_limit = ctx_mgr.debug_limit
        if_stmt = IfScope('ifscope', real_loop_var < real_loop_limit,
                          get_caller_context(depth=2), ctx.tik_debugger)
        if_stmt.traceable = False
        if_stmt.then_block.traceable = False
        return if_stmt

    @wraps(func)
    def wrapper(self: any, sub_info: any) -> any:
        """
        bind this decorator with for_range
        """
        ctx_mgr = func(self, sub_info)
        if not self.debug_disabled:
            ctx = self.context
            block_value = sub_info.subblock_num
            thread_num = sub_info.thread_num
            _, extent = ctx_mgr.debug_limit
            for hint in ctx_mgr.debug_hint:
                loop_var, loop_range = hint
                begint, endt = loop_range

                loop_tuple = ForLoopTuple(begint, endt, loop_var, block_value,
                                          get_caller_context(depth=2), sub_info.sub_dtype, ctx.tik_debugger)
                loop = ForLoop(loop_tuple, thread_num=thread_num, extent=extent)
                if block_value > 1:
                    ctx.tik_debug.is_single_core = False
                    ctx.tik_debug.block_end = block_value
                loop.set_visible(False)
                ctx.add_scope(loop)
                ctx.bind_var(loop_var)
            loop.set_visible(True)
            ctx.add_scope(insert_if(ctx, ctx_mgr))
        return WrapCtxMgr(ctx_mgr, self)

    return wrapper


def if_scope_decorator(func):
    """
    bind this decorator with if_scope

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(self, cond):
        """
        bind this decorator with if_scope
        """
        ctx_mgr = func(self, cond)
        if not self.debug_disabled:
            self.context.add_scope(IfScope('ifscope', cond, get_caller_context(depth=2), self.context.tik_debugger))
        return WrapCtxMgr(ctx_mgr, self)
    return wrapper


def elif_scope_decorator(func):
    """
    bind this decorator with elif_scope

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(self, cond):
        """
        bind this decorator with elif_scope
        """
        ctx_mgr = func(self, cond)
        if not self.debug_disabled and not self.context.frozen:
            last_block_stmt = -1
            ctx = self.context
            curr_scope = ctx.curr_scope()
            curr_block = getattr(curr_scope, 'block', curr_scope)
            maybe_if_scope = curr_block.stmts[last_block_stmt]
            for stmt in curr_block.stmts[::-1]:
                if isinstance(stmt, IfScope):
                    maybe_if_scope = stmt
                    break
            if not isinstance(maybe_if_scope, IfScope):
                TikCheckUtil.raise_error(
                    'Input ElifScope not instance IfScope')
            elif_scope = IfScope('elifscope', cond, get_caller_context(depth=2), ctx.tik_debugger)
            ctx.add_scope(elif_scope)
            maybe_if_scope.add_else_block(elif_scope)
        return WrapCtxMgr(ctx_mgr, self)
    return wrapper


def else_scope_decorator(func):
    """
    bind this decorator with else_scope

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(self):
        """
        bind this decorator with else_scope
        """
        ctx_mgr = func(self)
        if not self.debug_disabled and not self.context.frozen:
            last_block_stmt = -1
            ctx = self.context
            curr_scope = ctx.curr_scope()
            curr_block = getattr(curr_scope, 'block', curr_scope)
            maybe_if_else_scope = curr_block.stmts[last_block_stmt]
            for stmt in curr_block.stmts[::-1]:
                if isinstance(stmt, IfScope):
                    maybe_if_else_scope = stmt
                    break
            if not isinstance(maybe_if_else_scope, IfScope):
                TikCheckUtil.raise_error('Input ElseScope not instance IfScope')
            else_scope = ElseScope(get_caller_context(depth=2), ctx.tik_debugger)
            ctx.add_scope(else_scope)
            maybe_if_else_scope.add_else_block(else_scope.block)
        return WrapCtxMgr(ctx_mgr, self)
    return wrapper


def rpn_cor_diag_decorator(func):
    """
    bind this decorator with rpn_cor_diag

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(tik_instance, dst, src, src_register):
        """
        bind this decorator with rpn_cor_diag
        """
        if not tik_instance.debug_disabled:
            rpn_cor_diag_stmt = RpnCorDiag(get_caller_context(), dst, src, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(rpn_cor_diag_stmt)
        return func(tik_instance, dst, src, src_register)
    return wrapper


def tik_return_decorator(func):
    """
    bind this decorator with tik_return

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(tik_instance):
        """
        bind this decorator with tik_return
        """
        if not tik_instance.debug_disabled:
            stmt = Return(get_caller_context(), tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance)
    return wrapper


def tik_break_decorator(func):
    """
    bind this decorator with tik_break
    """
    @wraps(func)
    def wrapper(tik_instance):
        if not tik_instance.debug_disabled:
            stmt = Break(get_caller_context(), tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance)
    return wrapper


def tik_continue_decorator(func):
    """
    bind this decorator with tik_continue
    """
    @wraps(func)
    def wrapper(tik_instance):
        if not tik_instance.debug_disabled:
            stmt = Continue(get_caller_context(), tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance)
    return wrapper


def set_2d_decorator(func):
    """
    bind this decorator with tensor_padding_with_matrix

    Parameters
    ----------
    func : the decorated function

    Returns
    -------
    function
    """
    @wraps(func)
    def wrapper(tik_instance, dst, repeat_times, value=None):
        """
        bind this decorator with tensor_padding_with_matrix

        Parameters
        ----------
        value: value
        tik_instance: an instance of Tik
        dst: the destination tensor
        repeat_times: Repeated iterations times

        Returns
        ----------
        func: the decorated function
        """
        if not tik_instance.debug_disabled:
            stmt = Set2D(get_caller_context(), (dst, repeat_times), value, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, dst, repeat_times, value)
    return wrapper


def get_ctrl_bits(begin, end=None):
    """
    bind this decorator with get ctrl instructions

    Parameters
    ----------
    begin : the begin index of ctrl register
    end : the end index of ctrl register

    Returns
    -------
    function
    """
    def get_ctrl_bits_wrapper(func):
        """
        bind this decorator with get ctrl instructions
        """
        def wrapper(tik_instance, scalar):
            """
            bind this decorator with get ctrl instructions

            Parameters
            ----------
            tik_instance: an instance of Tik
            scalar : the value of ctrl register bits

            Returns
            -------
            function
            """
            if not tik_instance.debug_disabled:
                change_crtl(tik_instance, scalar, begin, end)
            with tik_instance.context.freeze():
                return func(tik_instance, scalar)
        return wrapper
    return get_ctrl_bits_wrapper


def atomic_add_to_scalar():
    """
    bind this decorator with get ctrl instructions

    Parameters
    ----------

    Returns
    -------
    function
    """
    def get_ctrl_bits_wrapper(func):
        """
        bind this decorator with get ctrl instructions
        """
        def wrapper(tik_instance, scalar):
            """
            bind this decorator with get ctrl instructions

            Parameters
            ----------
            tik_instance: an instance of Tik
            scalar : the value of ctrl register bits

            Returns
            -------
            function
            """
            if not tik_instance.debug_disabled:
                begin_ = get_atomic_add_mod_start_pos()
                end_ = get_atomic_add_mod_end_pos()
                change_crtl(tik_instance, scalar, begin_, end_)
            with tik_instance.context.freeze():
                return func(tik_instance, scalar)
        return wrapper
    return get_ctrl_bits_wrapper


def get_status_bits(begin, end=None):
    """
    bind this decorator with get status instructions

    Parameters
    ----------
    begin : the begin index of status register
    end : the end index of status register

    Returns
    -------
    function
    """
    def get_status_bits_wrapper(func):
        """
        bind this decorator with get status instructions
        """
        def wrapper(tik_instance, scalar):
            """
            bind this decorator with get status instructions

            Parameters
            ----------
            tik_instance: an instance of Tik
            scalar : the value of status register bits

            Returns
            -------
            function
            """
            if not tik_instance.debug_disabled:
                # STATUS is 64 bit, if it changed we must change as well
                mask = 0
                end_ = end
                if end_ is None:
                    end_ = begin + 1
                for i in range(begin, end_):
                    mask |= (1 << i)
                stmt = GetStatusSPR(get_caller_context(), (scalar, mask, begin),
                                    tik_instance.context.tik_debugger)
                tik_instance.context.curr_scope().add_stmt(stmt)

            with tik_instance.context.freeze():
                return func(tik_instance, scalar)
        return wrapper
    return get_status_bits_wrapper


def load_smask_decorator(func):
    """
    bind this decorator with load_smask instruction
    """
    @wraps(func)
    def wrapper(tik_instance, dst, src, load_size, sid=0):
        if not tik_instance.debug_disabled:
            stmt = LoadSmask(get_caller_context(), (dst, src, load_size, sid), tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, dst, src, load_size, sid)
    return wrapper


def vdp_decorator(func):
    """
    bind this decorator with vdp instructions
    """
    @wraps(func)
    def wrapper(tik_instance, vdp_api):
        if not tik_instance.debug_disabled:
            stmt = VDP(get_caller_context(), vdp_api, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, vdp_api)
    return wrapper
