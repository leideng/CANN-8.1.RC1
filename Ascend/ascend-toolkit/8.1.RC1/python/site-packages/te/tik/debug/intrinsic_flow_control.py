#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     intrinsic_flow_control.py
DESC:     intrinsic_flow_control
CREATED:  2021-12-29 12:36 PM
MODIFIED: 2021-12-29 12:36 PM
"""
import sys
import re
import time
import multiprocessing
import copy

from tbe.common.platform import scope_gm
from tbe.tik.common.common_util import check_begin_end_value
from tbe.tik.common.common_util import check_tensor_access
from tbe.tik.debug.statement import STMT
from tbe.tik.tik_lib.tik_params import CUR_FRAME_IDX
from tbe.tik.tik_lib.tik_source_info import TikSourceInfo
from tbe.tik.tik_lib.tik_expr import Expr
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import RUN_CMD_FINISHED

# current block_idx status
_BLOCK_NOT_RUN = 0
_BLOCK_RUN = 1
_RESPONSE_ERROR = "RESPONSE ERROR"


def _get_line_and_check_list(block_list, response_queue_list, current_block_idx):
    """
    get line and check for wait_command_over
    Parameters
    ----------
    block_list :  block_list
    response_queue_list : response_queue_list
    current_block_idx : current_block_idx

    Returns
    -------
    reg
    """
    line = None
    for block_idx in block_list:
        # get the cmd run result from the response Queue
        line = response_queue_list[block_idx].get()

    # if the response Queue is not empty, may be run cmd more than expected
    if not response_queue_list[current_block_idx].empty():
        TikCheckUtil.raise_warning("response_queue_list[%d] msg queue is not empty" % current_block_idx)
    return line


class HighLevelAPIScope(STMT):
    """
    tik library implementation in debug process
    """

    def __init__(self, source_info='', tik_debugger=None):
        """
        Initalize class Block.

        Parameters
        ----------
        source_info:str, Information of debugger
        """
        super(HighLevelAPIScope, self).__init__(source_info, tik_debugger)
        self.stmts = []
        self.trace_event = 'block'

    def add_stmt(self, stmt):
        """
        Add stmt node to current node

        Parameters
        ----------
        stmt:instance of STMT. AST node
        """
        if self.frozen:
            return

        stmt.set_parent(self)
        self.stmts.append(stmt)

    def eval_(self, context):
        """
        eval_ function. evaluate all of self.function

        Parameters
        ----------
        context:information of debugger, store all of debugger's information
        """
        # note: try not add check here!
        old_running_state = context.tik_debug.force_interactive
        context.tik_debug.force_interactive = False
        for stmt in self.stmts:
            stmt.evaluate(context)
        context.tik_debug.force_interactive = old_running_state


class DisableScopeTrace(STMT):
    """
    tik library implementation in debug process
    """

    def __init__(self, source_info='', tik_debugger=None):
        """
        Initalize class Block.

        Parameters
        ----------
        source_info:str, Information of debugger
        """
        super(DisableScopeTrace, self).__init__(source_info, tik_debugger)
        self.stmts = []
        self.trace_event = 'block'

    def add_stmt(self, stmt):
        """
        Add stmt node to current node

        Parameters
        ----------
        stmt:instance of STMT. AST node
        """
        if self.frozen:
            return

        stmt.set_parent(self)
        self.stmts.append(stmt)

    def eval_(self, context):
        """
        eval_ function, evaluate all of self.function
        """
        # note: try not add check here!
        TikSourceInfo.register_source_info(source_info=self.source_info)
        TikCheckUtil.raise_error(
            "barrier.sync() not support debug "
            "currently, please run again with it commented.")


class Block(STMT):
    """
    Class Block inherits from STMT
    A block of statement.
    """

    def __init__(self, source_info='', tik_debugger=None):
        """
        Initalize class Block.

        Parameters
        ----------
        source_info:str, Information of debugger
        """
        super(Block, self).__init__(source_info, tik_debugger)
        self.stmts = []
        self.trace_event = 'block'

    def add_stmt(self, stmt):
        """
        Add stmt node to current node

        Parameters
        ----------
        stmt:instance of STMT. AST node
        """
        if self.frozen:
            return

        stmt.set_parent(self)
        self.stmts.append(stmt)

    def eval_(self, context):
        """
        eval_ function, evaluate all of self.function

        Parameters
        ----------
        context:information of debugger, store all of debugger's information
        """
        for stmt in self.stmts:
            if not isinstance(stmt, (ForLoop, IfScope, HighLevelAPIScope, DisableScopeTrace)):
                TikSourceInfo.register_source_info(source_info=stmt.source_info)
            if not (isinstance(stmt, IfScope) and stmt.trace_event == 'elifscope'):
                stmt.evaluate(context)
            if not isinstance(stmt, (ForLoop, IfScope, HighLevelAPIScope, DisableScopeTrace)):
                TikSourceInfo.clear_source_info()


class ForLoop(STMT):
    """
    Class ForLoop inherits from STMT
    """

    def __init__(self, loop_tuple, thread_num=1, extent=Expr(0)):
        """
        Initialize class ForLoop

        Parameters
        ----------
        loop_tuple: loop var list, contain begin,end,bind_var,block_nums,source_info
        thread_num: thread number
        extent: the (end - begin) of expr
        """
        super(ForLoop, self).__init__(loop_tuple.source_info, loop_tuple.tik_debugger)
        self.traceable = False
        # begin is the begin of expression
        self.begin = loop_tuple.begin
        # end is the end of exppression
        self.end = loop_tuple.end
        self.i = self.begin
        # bind_var is bind variable
        self.bind_var = loop_tuple.bind_var
        # block_nums is multi core nums
        self.block_nums = loop_tuple.block_nums
        self.thread_num = thread_num
        self.extent = extent
        self.trace_event = 'forloop'
        # for multi-core, check whether set breakpoint in the for_range
        self.set_break_point = False

        self.block = Block(loop_tuple.source_info, loop_tuple.tik_debugger)
        self.dtype = loop_tuple.dtype
        check_begin_end_value(loop_tuple.begin, loop_tuple.end, loop_tuple.dtype)

        self.process_list = {}  # all child process
        self.queue_list = {}  # Queue for write cmd to child process
        self.response_queue_list = {}  # Queue for get msg from child process
        self.block_process_map = {}  # bind block_idx with process
        self.is_interactive_map = {}  # save child process interactive status
        if not isinstance(self.block_nums, int):
            self.is_scalar_block = True
        else:
            self.is_scalar_block = False

    @staticmethod
    def _update_breakpoint_info(context, block_idx):
        # enable/disable breakpoint for block, according the break_block_map info
        new_break_point = []
        for break_point in context.tik_debugger.break_points:
            add_break_point = False
            breakpoint_id = break_point.id
            break_block_map_info = context.tik_debugger.break_block_map[breakpoint_id]
            for block_id in break_block_map_info:
                # find the breakpoint for current block
                if block_id == block_idx and break_point not in new_break_point:
                    new_break_point.append(break_point)
                    add_break_point = True

            # delete the break point for current block
            if add_break_point is False:
                break_point.ast_node.break_point = None
        return new_break_point

    @staticmethod
    def _add_tensor_to_access_info(context, begin, end):
        """
        add all gm tensor, include workspace tensor
        """
        # init the dict for save the dst tensor access info
        manager = multiprocessing.Manager()
        context.gm_tensor_access_info = manager.dict()
        for block_idx in range(begin, end):
            context.gm_tensor_access_info[block_idx] = manager.dict()
            for defined_tensor in context.tensor_list:
                if defined_tensor.scope == scope_gm and \
                        defined_tensor.name not in context.gm_tensor_access_info[block_idx]:
                    context.gm_tensor_access_info[block_idx][defined_tensor.name] = manager.list()

    @staticmethod
    def _set_block_idx_list(context):
        for break_id in context.tik_debugger.break_block_map.keys():
            for block_idx in context.tik_debugger.break_block_map[break_id]:
                if block_idx not in context.tik_debug.block_idx_list:
                    context.tik_debug.block_idx_list.append(block_idx)
        context.tik_debug.block_idx_list.sort()

    def set_add_scalar_all_break(self, key, context):
        """
        add all break when blcok is scalar and value is 'all'

        Parameters
        ----------
        key : key of break_block_map
        context : context

        Returns
        -------
        None
        """
        if context.tik_debugger.break_block_map.get(key) == ["all"]:
            context.tik_debugger.break_block_map[key] = []
            for block_point in range(0, self.block_nums):
                if block_point not in context.tik_debugger.break_block_map.get(key):
                    context.tik_debugger.break_block_map.get(key).append(block_point)

    def do_clear_invalids_break_block(self, key, value, pop_multi_list, context):
        """
        do_clear invalids block of break

        Parameters
        ----------
        key : key of break_block_map
        value : the value of break_block_map is a list, value is each value of the list
        pop_multi_list : list of some breakpoints to be deleted
        context : context

        Returns
        -------
        None
        """
        if value < 0 or value > self.block_nums - 1:
            context.tik_debugger.do_clear(str(key) + " block " + str(value))
            if value not in pop_multi_list:
                pop_multi_list.append(value)

    def pop_invalids_break_block(self, pop_multi_list, context):
        """
        pop invalids block of break

        Parameters
        ----------
        pop_multi_list : list of some breakpoints to be deleted
        context : context

        Returns
        -------
        pop_multi_list
        """
        temporary_block_dic = copy.deepcopy(context.tik_debugger.break_block_map)
        for key in temporary_block_dic.keys():
            for value in temporary_block_dic.get(key):
                self.do_clear_invalids_break_block(key, value, pop_multi_list, context)
        return pop_multi_list

    def set_scalar_blocknum_break_point(self, context):
        """
        set break_point when block_num is scalar
        """
        if self.is_scalar_block :
            pop_multi_list = []
            temporary_block_dic = copy.deepcopy(context.tik_debugger.break_block_map)
            for key in temporary_block_dic.keys():
                self.set_add_scalar_all_break(key, context)
            # break_block_map may be changed
            pop_multi_list = self.pop_invalids_break_block(pop_multi_list, context)
            if pop_multi_list:
                pop_multi_list.sort()
                print("[WARNING]: No valid block, set breakpoint failed, the range of breakpoint is [0, %d], "
                      "but input is" % (self.block_nums), pop_multi_list)

    def eval_(self, context):
        """
        ForLoop eval
        """
        # check whether is multi-core process
        self.block_nums = context.evaluate_expr(self.block_nums)
        context.tik_debug.block_end = self.block_nums
        if context.tik_debugger:
            context.tik_debugger.current_for_range_eval = True
            self.set_scalar_blocknum_break_point(context)
        self.check_begin_end_with_thread_num(context)
        if self.block_nums > 1:
            # check whether set break point in this line
            self._check_breakpoint(context)
            # close multi process daemonic processes
            ori_process_daemon = multiprocessing.current_process().daemon
            multiprocessing.current_process().daemon = False

            context.tik_debug.is_single_core = False

            begin_ = context.evaluate_expr(self.begin)
            end_ = context.evaluate_expr(self.end)
            # add all gm tensor, include workspace tensor
            self._add_tensor_to_access_info(context, begin_, end_)

            context.tik_debug.block_idx_list = []
            if context.tik_debugger is not None:
                self._set_block_idx_list(context)

            # if no set block, set interactive with all blocks
            if context.tik_debug.force_interactive and len(context.tik_debug.block_idx_list) == 0:
                for block_idx in range(begin_, end_):
                    context.tik_debug.block_idx_list.append(block_idx)

            # do multi core debug
            self._eval_multi_core(context, begin_, end_)
            # open multi process daemonic processes
            multiprocessing.current_process().daemon = ori_process_daemon

            # after multi core block, check the dst gm memory access addr
            check_tensor_access(context.gm_tensor_access_info)
        else:
            if len(context.tik_debug.block_idx_list) == 0:
                context.tik_debug.block_idx_list = [0]
            context.tik_debug.is_single_core = True
            self._eval_single_core_(context)

    def check_begin_end_with_thread_num(self, context):
        """
        check begin and end value format
        Parameters
        ----------
        context: information of debugger, store all of debugger's information
        """
        if self.thread_num > 1:
            # add source info for debug error can show the tik code
            TikSourceInfo.register_source_info(source_info=self.source_info)
            begin_expr = Expr(self.begin)
            end_expr = Expr(self.begin + self.extent)
            begin_val = context.evaluate_expr(begin_expr)
            end_val = context.evaluate_expr(end_expr)

            if begin_val > end_val:
                TikCheckUtil.raise_error("for_range end(%d) should be Greater than or equal to begin(%d)"
                                         % (end_val, begin_val))

            check_begin_end_value(begin_val, end_val, begin_expr.dtype)
            check_begin_end_value(begin_val, end_val, end_expr.dtype)
            # here must clear the source info for run for_scope body code
            TikSourceInfo.clear_source_info()

    def set_visible(self, visible):
        """
        Set visible for a block

        Parameters
        ----------
        visible:True or False, A flag for a block
        """
        self.block.traceable = visible

    def add_stmt(self, stmt):
        """
        Add stmt in a block

        Parameters
        ----------
        stmt:A list of STMT instance

        Returns
        ----------
        None
        """
        if self.frozen:
            return

        # ATTENTION!!!!!!!!!!!
        # we can't capture the name of var x in `for_range as x` stmt.
        # so we have to merge for range scope with its child scope
        self.block.source_info[CUR_FRAME_IDX].get("sym_table").update(
            stmt.source_info[CUR_FRAME_IDX].get("sym_table"))
        self.block.add_stmt(stmt)

    def _check_breakpoint(self, context):
        """
        check whether has break point of the for_range line
        """
        if context.tik_debugger is None:
            return
        cano_filename = context.tik_debugger.canonic(self.source_info[CUR_FRAME_IDX].get("filename"))
        tik_primitive_list = context.tik_debugger.debug_info.get(cano_filename)
        for source_info, ast_node in tik_primitive_list:
            if self.source_info == source_info and ast_node.traceable and \
                    ast_node.break_point in context.tik_debugger.break_points:
                self.set_break_point = True

    def _eval_single_core_(self, context):
        """
        Eval function, evaluate all of self.function

        Parameters
        ----------
        context:information of debugger, store all of debugger's information
        """
        # into for loop, update the for loop info
        context.cur_for_loop = self
        context.for_loop_times_map[self] = 0

        begin_ = context.evaluate_expr(self.begin)
        end_ = context.evaluate_expr(self.end)
        # add source info for debug error can show the tik code
        TikSourceInfo.register_source_info(source_info=self.source_info)
        check_begin_end_value(begin_, end_, self.dtype)
        # here must clear the source info for run for_scope body code
        TikSourceInfo.clear_source_info()

        for self.i in range(begin_, end_):
            context.update_var(self.bind_var, self.i)
            if (end_ - begin_) > 1:  # only for range more than 1, need to update the var to debug vm
                # for_range(0, 2) as i:
                #     for_range(0, 0) as j:
                #         do_something
                # these IRs will be simplified by pass. bind_var i will not be parsed in vm.
                if context.check_var_exist_in_vm(self.bind_var):
                    context.update_var_to_vm(self.bind_var, self.i)
            self.block.evaluate(context)

            # may be for loop inner has for loop,
            # so after block.evaluate, update the for loop info
            context.cur_for_loop = self
            context.for_loop_times_map[self] += 1
            # check whether tik_break is executed.
            if context.is_debug_break:
                # Reset the is_debug_break at the end of the for_range loop.
                context.is_debug_break = False
                break

            # check whether tik_continue is executed.
            # Reset the is_debug_continue at the end of this for_range loop.
            context.is_debug_continue = False
        # Reset the is_debug_continue at the end of the for_range loop.
        context.is_debug_continue = False

    def _update_process_status(self, context):
        """
        check child process whether it's alive and whether in interactive state, select a new child process to run
        """
        # first check current interactive process status
        blk_val = context.tik_debug.cur_block_idx.value
        if not self.block_process_map.get(blk_val).is_alive():
            context.tik_debug.cur_block_idx.value = -1  # current process is finished
        else:
            return

        # select a new interactive child process to run
        for block_idx, value in self.block_process_map.items():
            if value.is_alive() and self.is_interactive_map.get(block_idx).value == 1:
                # insert last_cmd after switch block when block_idx core is not executed.
                if context.tik_debug.all_block_status[block_idx] == _BLOCK_NOT_RUN and not self.set_break_point:
                    self.queue_list.get(block_idx).put(context.tik_debugger.last_cmd)
                    context.tik_debug.all_block_status[block_idx] = _BLOCK_RUN
                # show current line info when next/continue into a new interactive child process
                self.queue_list.get(block_idx).put("list_ide")
                context.tik_debug.cur_block_idx.value = block_idx
                return

    def _get_cur_block_idx(self, context):
        """
        check child process whether it's alive and if it's alive, begin to run it
        Parameters
        ----------
        context: information of debugger, store all of debugger's information

        Returns
        -------
        whether child process is finished and child process block index
        """
        finished = True
        current_block_idx = None
        # if current child process is in interactive status and not finished
        if context.tik_debug.cur_block_idx is not None and context.tik_debug.cur_block_idx.value != -1 and \
                self.block_process_map.get(context.tik_debug.cur_block_idx.value).is_alive():
            return False, context.tik_debug.cur_block_idx.value

        # find a new child process to run
        for block_idx, value in self.block_process_map.items():
            if value.is_alive() and self.is_interactive_map.get(block_idx).value == 1:
                finished = False
                current_block_idx = block_idx
                context.tik_debug.cur_block_idx.value = block_idx
                break

        return finished, current_block_idx

    def _put_cmd_to_queue(self, context, cmd, block_list):
        active_block_list = []
        for block_idx in block_list:
            if block_idx >= self.block_nums:
                print("[Warning]: Block %d doesn't exist, cannot run cmd '%s'" % (block_idx, cmd))
                continue
            if block_idx in context.tik_debug.block_idx_list and self.block_process_map.get(block_idx).is_alive() and \
                    self.is_interactive_map.get(block_idx).value == 1:
                self.queue_list.get(block_idx).put(cmd)
                active_block_list.append(block_idx)
            else:
                print("[Warning]: Block %d doesn't in interactive status, cannot run cmd '%s'" % (block_idx, cmd))
        return active_block_list

    def _do_breakpoint_cmd(self, context, cmd, re_str_list, block_value_position):
        """
        run the cmd releated with breakpoint
        Parameters
        ----------
        cmd: input cmd msg
        re_str_list:
        -           re_str: regular expression string
        -           re_all_str: regular expression string of all
        block_value_position: block releated value index in cmd
        Returns
        -------
        the child process's block index of which run cmd
        """
        re_str, re_all_str = re_str_list
        block_list = []
        match_result = re.compile(re_str).match(cmd.strip())
        if not match_result:  # cannot find result according the re_str, put the cmd only to current child process
            re_all_break_command = re.compile(re_all_str)
            match_result = re_all_break_command.match(cmd.strip())
            if not match_result:
                print("[Error]: Input cmd:'%s' error" % cmd)
            else:
                # cannot find block, cmd for all
                block_list = self._put_cmd_to_queue(context, cmd, context.tik_debug.block_idx_list)
        else:
            # get the blocks info by group(block_value_position)
            cmd_split_result = cmd.split(match_result.group(block_value_position))
            # get all block nums from the str, cmd_split_result[1] is block nums list string
            block_nums_result = list(map(int, re.compile(r"\d+").findall(cmd_split_result[1])))
            block_list = self._put_cmd_to_queue(context, cmd_split_result[0], block_nums_result)
        return block_list

    def _do_clear_breakpoint_cmd(self, context, cmd):
        """
        run the cmd releated with clear breakpoint

        Paraeters
        ---------

        cmd: input cmd msg
        queue_list: Queue of child process
        is_interactive_map:  all interactive process's interactive status
        block_process_map: all interactive process's block index
        Returns
        -------
        the child process's block index of which run cmd
        """
        # clear all breakpoint for some blocks, clear block 1 2
        re_str = r"^\s*(clear)\s*( block )\s*(\d+)\s*"
        block_value_position = 2  # block info's index in cmd
        match_result = re.compile(re_str).match(cmd.strip())
        if not match_result:
            # breakpoint clear cmd for some blocks, clear 1 block 1 2
            re_str = r"^\s*(clear )\s*(\d+)\s*( block )\s*(\d+)\s*"
            re_all_str = r"^\s*(clear )\s*(\d+)\s*"
            block_value_position = 3  # block info's index in cmd
            block_list = self._do_breakpoint_cmd(context, cmd, (re_str, re_all_str), block_value_position)
        else:
            # get the blocks info by group(block_value_position)
            cmd_split_result = cmd.split(match_result.group(block_value_position))
            # get all block nums from the str, cmd_split_result[1] is block nums list
            block_nums_result = list(map(int, re.compile(r"\d+").findall(cmd_split_result[1])))
            block_list = self._put_cmd_to_queue(context, cmd_split_result[0], block_nums_result)
        return block_list

    def _wait_command_over(self, context, cmd, current_block_idx, block_list):
        """
        to check whether the command run finished, if command run finshed, continue to read cmd
        """
        line = None
        while not line:
            # if block_list is [], no cmd be runned, so return here
            if len(block_list) == 0:
                return
            time.sleep(0.1)  # wait 0.1s, wait the cmd run finished
            line = _get_line_and_check_list(block_list, self.response_queue_list, current_block_idx)
            if line != RUN_CMD_FINISHED:
                line = None
            else:
                # wait current_block_idx process finished or into interactive status again
                if cmd.strip() not in ["c", "c -a", "c -all", "continue", "continue -a", "continue -all",
                                       "continue_ide", "continue_ide -a", "continue_ide -all"]:
                    continue
                while self.block_process_map.get(context.tik_debug.cur_block_idx.value).is_alive() and \
                        self.is_interactive_map.get(context.tik_debug.cur_block_idx.value).value == 0:
                    # wait 0.1s to run continue cmd
                    self.block_process_map.get(context.tik_debug.cur_block_idx.value).join(0.1)

    def _show_block_info(self, context, current_block_idx):
        # show blocks info
        print("Block\t Status\t  Current")
        for block_idx in range(self.block_nums):
            is_current = False
            if block_idx in context.tik_debug.block_idx_list:
                if block_idx == current_block_idx:
                    is_current = True
                if self.process_list.get(block_idx).is_alive():
                    print("  %d\t%s   %s" % (block_idx, "Stepping", str(is_current)))
                else:
                    print("  %d\t%s   %s" % (block_idx, "Finished", str(is_current)))
            else:
                if self.process_list.get(block_idx).is_alive():
                    print("  %d\t%s   %s" % (block_idx, "Running", str(is_current)))
                else:
                    print("  %d\t%s   %s" % (block_idx, "Finished", str(is_current)))

    def _insert_last_cmd(self, context, cmd):
        """
        insert last_cmd after switch block for the first time
        """
        if cmd.strip().startswith("switch_block ") and not self.set_break_point:
            block_idx = context.tik_debug.cur_block_idx.value
            if context.tik_debug.all_block_status[block_idx] == _BLOCK_NOT_RUN:
                self.queue_list.get(block_idx).put(context.tik_debugger.last_cmd)
                # marks the switch_block_num core as executed.
                context.tik_debug.all_block_status[block_idx] = _BLOCK_RUN
        elif cmd.strip() in ["c", "continue"]:
            for block_idx in context.tik_debug.block_idx_list:
                context.tik_debug.all_block_status[block_idx] = _BLOCK_RUN

    def _run_command(self, context, cmd, current_block_idx):
        """
        deal with the cmd from user input, may be command for all child process
        """
        block_list = []
        if cmd.strip() == "block":
            self._show_block_info(context, current_block_idx)
            return
        if cmd.strip().startswith("block "):
            # switch block to input child process block index
            cmd = "%s_%s" % ("switch", cmd)
            self.queue_list.get(current_block_idx).put(cmd)
            block_list.append(current_block_idx)
        elif cmd.strip() in ["c -a", "c -all", "continue -a", "continue -all", "continue_ide -a", "continue_ide -all",
                             "n -a", "n -all", "next -a", "next -all", "next_ide -a", "next_ide -all", "q", "quit"]:
            # continue, next or quit cmd for all process
            # continue all blocked blocks or next all blocked blocks or quit all blocked blocks
            for block_idx in context.tik_debug.block_idx_list:
                if self.block_process_map.get(block_idx).is_alive():
                    self.queue_list.get(block_idx).put(cmd)
                    block_list.append(block_idx)
                    # marks the block_idx core as executed.
                    context.tik_debug.all_block_status[block_idx] = _BLOCK_RUN
        elif cmd.strip().startswith("b ") or cmd.strip().startswith("break "):
            # break cmd to some blocks, break xxx.py:num_line block 1 2
            re_str = r"^\s*(break |b )\s*(\S+)\s*:\s*(\d+)\s*( block )\s*(\d+)\s*"
            re_all_str = r"^\s*(break |b )\s*(\S+)\s*:\s*(\d+)\s*"
            block_value_position = 4  # block info's index in cmd
            block_list = self._do_breakpoint_cmd(context, cmd, (re_str, re_all_str), block_value_position)
        elif cmd.strip().startswith("disable ") or cmd.strip().startswith("enable "):
            # breakpoint disable or enable cmd for some blocks, disable|enable 1 block 1 2
            re_str = r"^\s*(disable |enable )\s*(\d+)\s*( block )\s*(\d+)\s*"
            re_all_str = r"^\s*(disable |enable )\s*(\d+)\s*"
            block_value_position = 3  # block info's index in cmd
            block_list = self._do_breakpoint_cmd(context, cmd, (re_str, re_all_str), block_value_position)
        elif cmd.strip().startswith("clear "):
            block_list = self._do_clear_breakpoint_cmd(context, cmd)
        elif cmd.strip().startswith("clear"):
            # send "clear" to all block
            block_list = self._put_cmd_to_queue(context, cmd, context.tik_debug.block_idx_list)
        else:
            # others command
            self.queue_list.get(current_block_idx).put(cmd)
            block_list.append(current_block_idx)
            # marks the current core as executed.
            context.tik_debug.all_block_status[current_block_idx] = _BLOCK_RUN

        # wait the cmd run finished
        self._wait_command_over(context, cmd, current_block_idx, block_list)
        self._insert_last_cmd(context, cmd)

    def _multi_core_debug_function(self, context, *args):
        """
        multi-core multi-block function
        """
        block_idx, gm_lock, stdin, stdout, cmd_queue, resp_msg_queue, is_interactive, cur_block_idx, \
            blk_barrier_flag, blk_barrier_lock = args
        context.update_var(self.bind_var, block_idx)  # update blockIdx.x's value
        context.update_var_to_vm(self.bind_var, block_idx)  # update blockIdx.x's value to debug vm
        context.gm_lock = gm_lock  # set the gm access lock, it's a multi-block shared lock
        context.tik_debug.stdin = stdin  # update the stdin of TikDebug, child process cannot direct use sys.stdin
        context.tik_debug.stdout = stdout  # update the stdout of TikDebug, child process cannot direct use sys.stdout
        context.tik_debug.cmd_queue = cmd_queue  # Queue for get cmd from father process
        context.tik_debug.resp_msg_queue = resp_msg_queue  # Queue for get response msg from child process
        context.tik_debug.block_index = block_idx
        context.blk_barrier_flag = blk_barrier_flag
        context.blk_barrier_lock = blk_barrier_lock
        # set child process interactive status according the interactive info
        if block_idx in context.tik_debug.block_idx_list:
            # set to interactive status
            context.tik_debug.force_interactive = True
            context.tik_debug.is_interactive = is_interactive
            context.tik_debugger.break_points = self._update_breakpoint_info(context, block_idx)
        else:
            # no need to interactive
            context.tik_debug.force_interactive = False
            context.tik_debug.is_interactive = False

        # every core of multi-core as single core
        context.tik_debug.is_single_core = True
        context.tik_debug.block_end = 1
        context.tik_debug.cur_block_idx = cur_block_idx  # shared Value for multi-block
        # continue evaluate the stmt for debug
        if context.tik_debugger is not None and context.tik_debugger.last_cmd.startswith("continue_ide") and \
                not (self.set_break_point and block_idx == 0):
            # only when current line is breakpoint and block_idx is 0, allow print current line info
            self.block.evaluate(context, allow_print=False)
        elif context.tik_debugger is not None and context.tik_debugger.last_cmd.startswith("next_ide") \
                and not block_idx == 0:
            # only when block_idx is 0, allow print current line info
            self.block.evaluate(context, allow_print=False)
        else:
            self.block.evaluate(context)

        # may be for loop inner has for loop,
        # so after block.evaluate, update the for loop info
        context.cur_for_loop = self
        context.for_loop_times_map[self] += 1

    def _eval_multi_core(self, context, begin, end):
        """
        Eval function
        evaluate all of self.function

        Parameters
        ----------
        context:information of debugger, store all of debugger's information

        Returns
        ----------
        No returns
        """
        # into for loop, update the for loop info
        context.cur_for_loop = self
        context.for_loop_times_map[self] = 0

        gm_lock = multiprocessing.Lock()  # create a new shared lock
        blk_barrier_flag = multiprocessing.Manager().dict()
        blk_barrier_lock = multiprocessing.Lock()

        # get sys.stdin, sys.stdout fileno for child process
        stdin = sys.stdin.fileno()
        stdout = sys.stdout.fileno()

        cur_block_idx = None
        if len(context.tik_debug.block_idx_list) > 0:
            # shared Value for mulit child process
            cur_block_idx = multiprocessing.Value("i", context.tik_debug.block_idx_list[0])
            context.tik_debug.cur_block_idx = cur_block_idx

        # multi process for deal with multi-core debug
        for block_idx in range(begin, end):
            # marks the block_idx core as not executed.
            context.tik_debug.all_block_status.append(_BLOCK_NOT_RUN)
            msg_queue = multiprocessing.Queue()
            resp_msg_queue = multiprocessing.Queue()
            is_interactive = multiprocessing.Value('i', 1)
            process = multiprocessing.Process(target=self._multi_core_debug_function,
                                              args=(context, block_idx, gm_lock, stdin, stdout, msg_queue,
                                                    resp_msg_queue, is_interactive, cur_block_idx, blk_barrier_flag,
                                                    blk_barrier_lock))
            self.process_list[block_idx] = process
            if block_idx in context.tik_debug.block_idx_list:
                self.block_process_map[block_idx] = process
                self.queue_list[block_idx] = msg_queue
                self.response_queue_list[block_idx] = resp_msg_queue
                self.is_interactive_map[block_idx] = is_interactive

        # start all child process
        for process in self.process_list.values():
            process.start()

        # here wait for input commands
        self._wait_input_cmd(context)

        # wait all process finished
        for process in self.process_list.values():
            process.join()

    def _wait_input_cmd(self, context):
        """
        wait input commands
        """
        finished = False
        while not finished:
            finished, current_block_idx = self._get_cur_block_idx(context)
            if not finished and current_block_idx is not None and current_block_idx != -1:
                cmd = self._read_cmd(context)  # wait for input cmd
                if current_block_idx in self.queue_list:
                    self._run_command(context, cmd, current_block_idx)

                # update process status
                self._update_process_status(context)

    def _read_cmd(self, context):
        try:
            # if last cmd is "continue", run the cmd
            if context.tik_debugger.last_cmd.strip() in ["c", "continue", "continue_ide"] \
                    and self.set_break_point is False:
                if context.tik_debugger.last_cmd.strip() == "continue_ide":
                    line = context.tik_debugger.last_cmd.strip()
                else:
                    line = "%s -a" % context.tik_debugger.last_cmd.strip()
                context.tik_debugger.last_cmd = ""
            else:
                line = context.tik_debugger.get_cmd()
        except EOFError:
            line = 'EOF'
        return line


class IfScope(STMT):
    """
    Class IfScope inherits from STMT
    Represent IF code
    """

    def __init__(self, name, cond, source_info, tik_debugger):
        """
        Initialize class IfScope

        Parameters
        ----------
        cond:judgement conditions of IF code
        source_info:source code information, It represents the relationship of current node with source code

        Returns
        ----------
        No returns
        """
        super(IfScope, self).__init__(source_info, tik_debugger)
        self.cond = cond
        self.then_block = Block(source_info, tik_debugger)
        self.else_block = None
        self.trace_event = name

        if isinstance(self.cond, Expr):
            self.cond = self.cond.get()

    @property
    def block(self):
        """
        return to next block

        Returns
        ----------
        then_block:next block
        """
        return self.then_block

    def eval_(self, context):
        """
        Eval function
        evaluate all of self.function

        Parameters
        ----------
        context:information of debugger, store all of debugger's information

        Returns
        ----------
        No returns
        """
        cond_val = context.evaluate_expr(self.cond)
        cond_val = bool(cond_val)
        if cond_val:
            if self.then_block.stmts:
                self.then_block.evaluate(context)
        else:
            if self.else_block is not None:
                self.else_block.evaluate(context)

    def add_stmt(self, stmt):
        """
        Add stmt for next block

        Parameters
        ----------
        stmt:a list of STMT instance

        Returns
        ----------
        None
        """
        if self.frozen:
            return
        self.then_block.add_stmt(stmt)

    def add_else_block(self, block):
        """
        Add else block

        Parameters
        ----------
        block:Block instance, other Block

        Returns
        ----------
        No returns
        """
        self.else_block = block


class ElseScope(STMT):
    """
    The eval_ function of ElseScope is a fake one.
    The ElseScope attach its block to the last IfScope \
    in its scope and evaled by IfScope
    """

    def __init__(self, source_info, tik_debugger):
        """
        Initialize class ElseScope

        Parameters
        ----------
        source_info:source code information, It represents the relationship of current node with source code
        """
        super(ElseScope, self).__init__(source_info, tik_debugger)
        self.traceable = False
        self.block = Block(source_info, tik_debugger)
        self.trace_event = 'elsescope'

    @staticmethod
    def eval_(context):
        """
        Eval function
        Not implement
        """

    def add_stmt(self, stmt):
        """
        Add stmt for a block

        Parameters
        ----------
        stmt:a list of STMT instance
        """
        if self.frozen:
            return

        self.block.add_stmt(stmt)


class Break(STMT):
    """
    Class Break inherits from STMT
    """

    @staticmethod
    def eval_(context):
        """
        Eval function
        """
        context.is_debug_break = True


class Continue(STMT):
    """
    Class Continue inherits from STMT
    """

    @staticmethod
    def eval_(context):
        """
        Eval function
        """
        context.is_debug_continue = True


class BlockBarrier(STMT):
    """
    debug class for block_barrier
    """
    def __init__(self, source_info, tik_debugger, block_num):
        super(BlockBarrier, self).__init__(source_info, tik_debugger)
        self.block_num = block_num

    def eval_(self, context):
        """
        Eval function
        wait all the block_barrier() to be executed in block_ids
        multi-core sync is completed when current block_barrier_flag equals to block_num
        """
        self.block_num = context.evaluate_expr(self.block_num)
        if self.block_num <= 1:
            return
        # use self id as dict key, the same BlockBarrier shares the same flag
        cur_id = id(self)

        def set_block_barrier_flag(flag_dict):
            if flag_dict.get(cur_id) is not None:
                flag_dict[cur_id] += 1
            else:
                flag_dict[cur_id] = 1

        # acquire block barrier block and update block_barrier_flag
        context.blk_barrier_lock.acquire()
        set_block_barrier_flag(context.blk_barrier_flag)
        context.blk_barrier_lock.release()

        while True:
            context.blk_barrier_lock.acquire()
            flag_count = context.blk_barrier_flag[cur_id]
            context.blk_barrier_lock.release()
            # when all the processes are ready, flag count equals to block_num
            if flag_count == self.block_num:
                break
            time.sleep(0.1) # wait 0.1s, wait other processes
