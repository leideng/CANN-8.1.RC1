#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     decorators_common.py
DESC:     decorator common func
CREATED:  2021-12-29 15:33
MODIFIED: 2021-12-29 15:33
"""
from tbe.tik.tik_lib.tik_check_util import TIK_CONTROL
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.debug.statement import SetScalar
from tbe.tik.debug.tikdbg.codemapping import get_caller_context
from tbe.tik.debug.intrinsic import GetCtrlSPR


FRAME_INFO_IDX = 3

SCALAR_SET_AS_STACK_DEPTH = 3
SCALAR_INIT_STACK_DEPTH = 4


def scalar_array_set_as_fn(scalar_array, value, depth=SCALAR_SET_AS_STACK_DEPTH, init_flag=False):
    """
    set scalar_array's debug information
    Parameters
    ----------
    scalar_array: a variable of scalar_array
    value: the value to be set
    depth: stack depth
    init_flag: judgment scalar_array_set_as_fn from scalar_array init or set_as

    Returns
    -------
    no return
    """
    if isinstance(value, (list, tuple)):
        msg = "length of value(%d) should be equal to " \
              "length of ScalarArray(%d)." % (len(value), scalar_array.length)
        if init_flag:
            msg = "length of init_value(%d) should be equal to " \
                  "length of ScalarArray(%d)." % (len(value), scalar_array.length)
        TikCheckUtil.check_equality(len(value), scalar_array.length, msg)
        for i in range(scalar_array.length):
            scalar_set_as_fn(scalar_array[i], value[i], depth, init_flag)
    else:
        for i in range(scalar_array.length):
            scalar_set_as_fn(scalar_array[i], value, depth, init_flag)


def set_stmt_value(build_obj, ctx):
    """
    set stmt value

    Parameters
    ----------
    build_obj : build obj
    ctx: obj context
    Returns
    -------
    function
    """
    scalar_name_map = {}
    for i, j in build_obj.scalar_value_map.items():
        scalar_name_map[i.name] = j
    scalar_stmt_map = ctx.scalar_stmt_dict
    if scalar_stmt_map:
        for scalar_name in scalar_stmt_map.keys():
            if scalar_name in scalar_name_map:
                stmt = scalar_stmt_map.get(scalar_name)
                stmt.set_value(scalar_name_map.get(scalar_name))


def scalar_set_as_fn(scalar, value, depth=SCALAR_SET_AS_STACK_DEPTH, init_flag=False):
    """
    set scalar's debug information

    Parameters
    ----------
    scalar: a variable of scalar
    value: the value to be set
    depth: stack depth
    init_flag: judgment scalar_set_as_fn from scalar init or set_as

    Returns
    -------
    no return
    """
    ctx = scalar.ir_generator.context
    stmt = SetScalar(get_caller_context(depth=depth), scalar, value, ctx.tik_debugger)
    if scalar.name not in ctx.scalar_stmt_dict or init_flag is True:
        ctx.scalar_stmt_dict[scalar.name] = stmt
    stmt.traceable = False
    ctx.curr_scope().add_stmt(stmt)
    for var in scalar.debug_var:
        ctx.bind_var(var)
    ctx.set_scalar_var_mapping(scalar.reg_buffer, scalar.debug_var)


def change_crtl(tik_instance, scalar, begin, end):
    """
    CRTL is 64 bit, if it changed we must change as well
    Parameters
    ----------
    end: end
    begin: begin
    tik_instance: tik_instance
    scalar: scalar

    Returns
    -------

    """

    mask = 0
    if end is None:
        end = begin + 1
    for i in range(begin, end):
        mask |= (1 << i)
    stmt = GetCtrlSPR(get_caller_context(), (scalar, mask, begin), tik_instance.context.tik_debugger)
    tik_instance.context.curr_scope().add_stmt(stmt)


def set_ctx_value(ctx, build_obj):
    """
    set ctx value
    Parameters
    ----------
    ctx: ctx
    build_obj: build obj

    Returns
    -------

    """
    record_list = []
    for i in build_obj.inputs:
        if hasattr(i, "buffer"):
            record_list.append(i)
    for i in build_obj.flowtable_tmp:
        if hasattr(i, "buffer"):
            record_list.append(i)
    ctx.record_ins(record_list)
    for i in build_obj.inputs:
        if not hasattr(i, "buffer"):
            ctx.bind_feed_var(i.name, i.get())
    ctx.record_outs((i for i in build_obj.outputs if hasattr(i, "buffer")))
    for i in build_obj.flowtable_tmp:
        if not hasattr(i, "buffer"):
            ctx.bind_feed_var(i.name, i.get())
    if build_obj.scalar_value_map:
        set_stmt_value(build_obj, ctx)


class WrapCtxMgr:
    """
    wrap context
    """

    def __init__(self, ctx, tik_instance):
        self.ctx = ctx
        self.tik = tik_instance
        self.scope_num = 1 if ctx.debug_hint is None else len(ctx.debug_hint) + 1

    def __enter__(self):
        return self.ctx.__enter__()

    def __exit__(self, exc_type, exc_val, exc_tb):
        if TIK_CONTROL.is_user_call:
            self.tik.source_info.register_source_info(
                source_info=self.ctx.source_info)
            self.tik.source_info.set_not_user_call()
            if not self.tik.debug_disabled:
                for _ in range(self.scope_num):
                    self.tik.context.pop_scope()
            tmp_exit = self.ctx.__exit__(exc_type, exc_val, exc_tb)
            self.tik.source_info.set_is_user_call()
            self.tik.source_info.clear_source_info()
        else:
            if not self.tik.debug_disabled:
                for _ in range(self.scope_num):
                    self.tik.context.pop_scope()
            tmp_exit = self.ctx.__exit__(exc_type, exc_val, exc_tb)

        return tmp_exit
