#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     simd.py
DESC:     simd instrction
CREATED:  2019-7-04 20:12:13
MODIFIED: 2020-12-7 19:17:00
"""
import numpy as np
from tbe.tik.debug.sim.instr_encoder import Encoder
from tbe.tik.tik_lib.tik_params import MASK_MODE_MASK
from tbe.tik.tik_lib.tik_params import MASK_COUNTER_MODE_ENABLE_SHIFT_POS

_ENCODER = Encoder()

_VCSPLIT_N_ENCODING = {32: 0b00, 16: 0b01, 8: 0b10}

_VCSPLIT_TYPE_ENCODING = {'8': 0b0, '16': 0b1}

_VSHR_DTYPE_ENCODING_V200 = {
    "uint16": 0b100,
    "uint32": 0b110,
    "int16": 0b101,
    "int32": 0b111
}

_VECTOR_SCALAR_FN_ENCODER = {
    'vmuls': _ENCODER.gen_vmulsx,
    'vadds': _ENCODER.gen_vaddsx,
    'vaxpy': _ENCODER.gen_vaxpyx,
    'vmaxs': _ENCODER.gen_vmaxsx,
    'vmins': _ENCODER.gen_vminsx,
    'vshl': _ENCODER.gen_vshlx,
    'vshr': _ENCODER.gen_vshrx,
    'vlrelu': _ENCODER.gen_vlrelux
}

_ROUNDING = {
    'round': np.round,
    'floor': np.floor,
    'ceil': np.ceil,
    'ceiling': np.ceil
}

_VCONV_BLOCK_SIZE = {('float16', 'int32'): 8, ('float16', 'uint8'): 16}

_UINT8_INFO = np.iinfo(np.uint8)

VCONV_TYPE_ENCODING = {
    ('float32', 'float16'): 0b110000,
    ('float16', 'float32'): 0b110001,
    ('float16', 'int8'): 0b110010,
    ('float16', 'uint8'): 0b110011,
    ('DEQ',): 0b110100,
    ('float16', 'int32', 'floor'): 0b110101,
    ('float16', 'int32', 'ceil'): 0b110110,
    ('float16', 'int32', 'round'): 0b110111,
    ('uint8', 'float16'): 0b111000,
    ('int8', 'float16'): 0b111001,
    ('float16', 'int32', 'away-zero'): 0b111010,
    ('float16', 'int32', 'to-zero'): 0b111011,
    ('float16', 'int8', 'away-zero'): 0b111100,
    ('float16', 'int8', 'floor'): 0b111101,
    ('float16', 'int8', 'ceil'): 0b111110,
    ('float16', 'int8', 'to-zero'): 0b111111,
    ('float32', 'int32', 'away-zero'): 0b100000,
    ('float32', 'int32', 'floor'): 0b100001,
    ('float32', 'int32', 'ceil'): 0b100010,
    ('float32', 'int32', 'to-zero'): 0b100011,
    ('float32', 'int32', 'round'): 0b100100,
    ('float16', 'uint8', 'away-zero'): 0b100101,
    ('float16', 'uint8', 'floor'): 0b100110,
    ('float16', 'uint8', 'ceil'): 0b100111,
    ('float16', 'uint8', 'to-zero'): 0b101000,
    ('int32', 'float32'): 0b101001,
    ('float16', 'int4'): 0b101011,
    # DEQs162b8
    ('DEQs162b8',): 0b101100,
    ('float16', 'int16', 'round'): 0b101101,
    ('int16', 'float16'): 0b101110,
    ('float32', 'int16', 'round'): 0b101111,
    ('float32', 'int16', 'to-zero'): 0b010000,
    ('int16', 'float32'): 0b010001,
    # VDEQs162b8
    ('VDEQs162b8',): 0b010010,
    ('float32', 'float16', 'odd'): 0b101010
}

VCONV_RND_SRC_DST_ENCODING = {
    ('DEQ', '0'): 0b1111111111,
    ('DEQs162b8', '1'): 0b1111111110,
    ('DEQs162b8', '0'): 0b1111111101,
    ('VDEQs162b8', '1'): 0b1111111100,
    ('VDEQs162b8', '0'): 0b1111111011
}

VCONV_RND_ENCODING = {
    '': 0b000,
    'round': 0b000,
    'away-zero': 0b001,
    'floor': 0b010,
    'ceil': 0b011,
    'to-zero': 0b100,
    'odd': 0b101
}

VCONV_SRC_ENCODING = {
    'float32': 0b000,
    'float16': 0b001,
    'bfloat16': 0b010,
    'int64': 0b011,
    'int32': 0b100,
    'int16': 0b101,
    'int8': 0b110,
    'uint8': 0b111
}

VCONV_DST_ENCODING = {
    'float32': 0b0000,
    'float16': 0b0001,
    'bfloat16': 0b0010,
    'int64': 0b0011,
    'int32': 0b0100,
    'int16': 0b0101,
    'int8': 0b0110,
    'uint8': 0b0111,
    'int4': 0b1000
}

VEC_WHOLE_REDUCE_ENCODER = {
    'vcadd': _ENCODER.gen_vcadd,
    'vcmax': _ENCODER.gen_vcmax,
    'vcmin': _ENCODER.gen_vcmin,
    'vcgadd': _ENCODER.gen_vcgadd,
    'vcgmax': _ENCODER.gen_vcgmax,
    'vcgmin': _ENCODER.gen_vcgmin,
    'vcpadd': _ENCODER.gen_vcpadd
}

VEC_WHOLE_REDUCE_ENCODER_910B = {
    'vcadd': _ENCODER.gen_vcadd_910b,
    'vcmax': _ENCODER.gen_vcmax_910b,
    'vcmin': _ENCODER.gen_vcmin_910b
}

_VCI_DTYPE = {
    'int32': 0b000,
    'float16': 0b001,
    'int16': 0b010,
    'float32': 0b011
}

_VMULCONV_DTYPE_ENCODING = {'int8': 0b01, 'uint8': 0b10}

_SRC_BLK_STRIDE_SHIFT_POS = 8
_SRC1_BLK_STRIDE_SHIFT_POS = 16
_DST_REPEAT_STRIDE_SHIFT_POS = 24
_SRC_REPEAT_STRIDE_SHIFT_POS = 32
_SRC1_REPEAT_STRIDE_SHIFT_POS = 40
MODE_SHIFT_POS = 48

_INSTR_SHIFT_POS = 25
_DST_DTYPE_SHIFT_POS = 22
_PARAM_XD_SHIFT_POS = 17
_PARAM_XN_SHIFT_POS = 12
_PARAM_XT_SHIFT_POS = 2
_INSTR_OR_VALUE = 1
_MAX_PARAM_TYPE = 2

_CHANNELS_SHIFT_BIT_POS = 12
_TRANS_DIR_SHIFT_BIT_POS = 63
_PATTERN_SHIFT_POS = 16

_VPADD_DST_REP_SHIFT_POS = 32
_PAD_SIDE_SHIFT_BIT_POS = 50

_DEFAULT_STRIDE = 1
_DEFAULT_BLOCK_LEN = 1
_ROUND_TO_NEAREST_ENABLE = 0
_BLK_NUM_PER_REP = 8


def eval_mask(mask, context):
    """
    evaluate mask

    Parameters
    ----------
    mask: Effective operation on element
    context : the stack context

    Returns
    -------
    mask_value
    """
    if isinstance(mask, (list, tuple)):
        mask_value = [context.evaluate_expr(value) for value in mask]
    else:
        mask_value = context.evaluate_expr(mask)

    return mask_value


def set_mask_counter_mode(context):
    """
    set mask with counter mode
    """
    # save orig_ctrl_value
    orig_ctrl_value = context.model.read_spr('CTRL')
    # mask: counter_mode, set CTRL[56] as 1
    ctrl_value = orig_ctrl_value & MASK_MODE_MASK
    ctrl_value = ctrl_value | (1 << MASK_COUNTER_MODE_ENABLE_SHIFT_POS)
    context.model.write_spr('CTRL', ctrl_value)
    return orig_ctrl_value


_VSCATTER_TYPE = {
    2: 0b0,
    4: 0b1
}
