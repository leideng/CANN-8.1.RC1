#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     intrinsic_v210.py
DESC:     debug intrinsic_v210
CREATED:  2019-7-04 20:12:13
MODIFIED: 2019-7-24 10:54:23
"""
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.common_util import check_extent_overflow
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import PAT_MODE_INSTR_CODE
from tbe.tik.tik_lib.tik_params import VL_T_MAP
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.debug.intrinsic_v210_common import create_vloop_info
from tbe.tik.debug.intrinsic_v210_common import V300_INSTR_OP1_CODE
from tbe.tik.debug.intrinsic_v210_common import set_param_loop_vex_num_dtype
from tbe.tik.debug.intrinsic_v210_common import gen_vag_instr
from tbe.tik.debug.intrinsic_v210_common import get_and_write_share_spr
from tbe.tik.debug.intrinsic_v210_common import PARAMETERS
from tbe.tik.debug.intrinsic_v210_common import V300_INSTR_REGTYPE_CODE
from tbe.tik.debug.intrinsic_v210_common import VEC_TYPE_BITS
from tbe.tik.debug.intrinsic_v210_common import VLOOPN_TYPE
from tbe.tik.debug.intrinsic_v210_common import dst_register
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.debug.util import copy_tensor_to_model
from tbe.tik.debug.util import get_flatten_idx
from tbe.tik.debug.util import VecRegType

_PGE_TYPE = {
    'uint8': 0b010,
    'int8': 0b010,
    'uint16': 0b011,
    'int16': 0b011,
    'float16': 0b011,
    'uint32': 0b100,
    'int32': 0b100,
    'float32': 0b100
}

_DIST_PLD = {
    'NORM': 0,
    'US': 1,
    'DS': 2
}

_DIST_PLD_ALIGN = {
    'NORM': 32,
    'US': 16,
    'DS': 64,
}

_DIST_PST = {
    'NORM': 0,
    'PK': 1,
}

_DIST_PST_ALIGN = {
    'NORM': 32,
    'PK': 16,
}

_DST_REGISTER = {
    "vectorized_pand": 0b00000,
    "vectorized_por":  0b01000,
    "vectorized_pxor": 0b10000,
    "vectorized_pnand": 0b11000,
    "vectorized_psel": 0b00000,
    "vectorized_pintlv": 0b0000,
    "vectorized_pdintlv": 0b01000,
}


def execute_all_instr(context, instr_list, instr, dst, pd_idx):
    """
    execute all instr
    Parameters
    ----------
    context
    instr_list
    instr
    dst
    pd_idx

    Returns
    -------

    """
    instr_list.append(instr)
    context.model.step_all(context, instr_list, len(instr_list))

    value_buffer = context.get_vector_value(dst).buffer
    flatten_np = value_buffer.reshape(-1)
    if TikSocManager.is_v300_610l_soc():
        context.model.read_vec_register_by_idx(VecRegType.P_REG, pd_idx, flatten_np.ctypes.data,
                                               len(flatten_np) * DTYPE_SIZE[dst.dtype])
    else:
        pd_idx_rename = context.model.get_vec_register_index(
            pd_idx, VecRegType.P_REG)
        context.model.read_vec_register(
            pd_idx_rename, flatten_np.ctypes.data,
            len(flatten_np))

    context.set_vector_state(dst, is_valid=True)
    context.free_all_register()


class VectorPlt(STMT):
    """
    Vector Plt instruction
    """
    def __init__(self, source_info, plt_params, tik_debugger):
        super(VectorPlt, self).__init__(source_info, tik_debugger)
        self.mask, self.dtype, self.max_index = plt_params

    def set_params(self, context):
        """
        set params get instr list pd idx
        Parameters
        ----------
        context

        Returns
        -------

        """

        param = set_param_loop_vex_num_dtype(context, self.dtype, 0, 1)
        instr_list = create_vloop_info(context, param, 0, 1)

        # here needn't to check max_index value,
        # self.max_index can only be uint16, no matter input value is what,
        # evaluate result must be in [0, 65535]
        max_index = context.evaluate_expr(self.max_index)

        # according the dtype and loop times calculate LTN register value
        pd_ltn = context.get_cur_for_loop_times() * VL_T_MAP[self.dtype]
        max_index = 0 if max_index <= pd_ltn else max_index - pd_ltn
        # write max_index into sn register
        sn_idx = get_and_write_share_spr(context, max_index, "uint16")
        param.snIdx = sn_idx

        # set Pd index
        pd_idx = context.alloc_p_register(self.mask)
        param.pdIdx = pd_idx
        param.type = VEC_TYPE_BITS[self.dtype]
        return param, instr_list, pd_idx

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        param, instr_list, pd_idx = self.set_params(context)
        # execute instructions
        instr = context.encoder.gen_vector_plt(param)
        execute_all_instr(context, instr_list, instr, self.mask, pd_idx)


class VectorPge(STMT):
    """
    Vector Pge instruction
    """
    def __init__(self, source_info, pge_params, tik_debugger):
        super(VectorPge, self).__init__(source_info, tik_debugger)
        self.mask, self.dtype, self.part_mode = pge_params

    def set_params(self, context):
        """
        set params get instr list pd idx
        Parameters
        ----------
        context

        Returns
        -------

        """
        param = set_param_loop_vex_num_dtype(context, self.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)

        part_mode = PAT_MODE_INSTR_CODE.get(self.part_mode)
        param.pat = part_mode

        # set Pd index
        pd_idx = context.alloc_p_register(self.mask)
        param.pdIdx = pd_idx
        param.type = _PGE_TYPE.get(self.dtype)
        return param, instr_list, pd_idx

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        param, instr_list, pd_idx = self.set_params(context)

        # execute instructions
        instr = context.encoder.gen_vector_pge(param)
        execute_all_instr(context, instr_list, instr, self.mask, pd_idx)


class VectorPset(STMT):
    """
    Vector Pset instruction
    """
    def __init__(self, source_info, pset_debug_params, tik_debugger):
        super(VectorPset, self).__init__(source_info, tik_debugger)
        self.mask = pset_debug_params.mask
        self.dtype = pset_debug_params.dtype
        self.set_mode = pset_debug_params.set_mode

    def set_params(self, context):
        """
        set params get instr list pd idx
        Parameters
        ----------
        context

        Returns
        -------

        """
        param = set_param_loop_vex_num_dtype(context, self.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)

        part_mode = PAT_MODE_INSTR_CODE.get(self.set_mode)
        param.pat = part_mode

        # set Pd index
        pd_idx = context.alloc_p_register(self.mask)
        param.pdIdx = pd_idx
        if TikSocManager.is_v300_610l_soc():
            param.type = VEC_TYPE_BITS.get(self.dtype)
        else:
            param.type = VLOOPN_TYPE.get(self.dtype)
        return param, instr_list, pd_idx

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        param, instr_list, pd_idx = self.set_params(context)
        # execute instructions
        instr = context.encoder.gen_vector_pset(param)
        execute_all_instr(context, instr_list, instr, self.mask, pd_idx)


class VectorPslide(STMT):
    """
    Vector Pslide instruction
    """
    def __init__(self, source_info, pslide_params, tik_debugger):
        super(VectorPslide, self).__init__(source_info, tik_debugger)
        self.dst = pslide_params.dst
        self.src0 = pslide_params.src0
        self.src1 = pslide_params.src1
        self.dtype = pslide_params.dtype
        self.slide_size = pslide_params.slide_size

    def get_pd_idx(self, context, param, slide_size):
        """
        p_isg_vec_param->type
        p_isg_vec_param->smIdx
        p_isg_vec_param->pdIdx
        p_isg_vec_param->pnIdx;
        Parameters
        ----------
        context
        param
        slide_size

        Returns
        -------

        """

        param.type = VEC_TYPE_BITS.get(self.dtype)  # slide_size
        sm_idx = get_and_write_share_spr(context, slide_size, "int16")
        param.smIdx = sm_idx

        if self.src0 is self.dst:
            # pn must be even
            pn_idx = context.alloc_p_register(self.src0, dtype=self.src0.dtype,
                                              is_even_start=True)
            param.pnIdx = pn_idx
            # src1 must next preg of pn
            context.alloc_p_register(self.src1, dtype=self.src1.dtype)
            pd_idx = pn_idx
        elif self.dst is self.src1:
            # pn must be even
            pn_idx = context.alloc_p_register(self.src0, dtype=self.src0.dtype,
                                              is_even_start=True)
            param.pnIdx = pn_idx
            # src1 must next preg of pn
            pm_idx = context.alloc_p_register(self.src1, dtype=self.src1.dtype)
            pd_idx = pm_idx
        else:
            # set Pd index, Pd must before pn
            pd_idx = context.alloc_p_register(self.dst)

            # pn must be even
            pn_idx = context.alloc_p_register(self.src0, dtype=self.src0.dtype,
                                              is_even_start=True)
            param.pnIdx = pn_idx
            # src1 must next preg of pn
            context.alloc_p_register(self.src1, dtype=self.src1.dtype)

        param.pdIdx = pd_idx
        return pd_idx, param

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        param = set_param_loop_vex_num_dtype(context, self.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)

        # check part_mode value
        slide_size = context.evaluate_expr(self.slide_size)
        vl_t = VL_T_MAP.get(self.dtype)
        TikCheckUtil.check_in_range_by_dtype(
            slide_size, msg="Instruction vector_vslide's slide_size must be in [{}, {}]".format(
                0, vl_t), var_range=[0, vl_t])

        pd_idx, param = self.get_pd_idx(context, param, slide_size)

        # execute instructions
        instr = context.encoder.gen_vector_pslide(param)
        execute_all_instr(context, instr_list, instr, self.dst, pd_idx)


class VectorPld(STMT):
    """
    Predicate load instruction
    """
    def __init__(self, source_info, pld_params, tik_debugger=None):
        super(VectorPld, self).__init__(source_info, tik_debugger)
        self.dst = pld_params.dst  # mask is preg
        self.src = pld_params.src  # src is ub
        self.ld_mode = pld_params.ld_mode

    def get_instr_list(self, context):
        """
        get instr list and param
        Parameters
        ----------
        context

        Returns
        -------

        """
        param = set_param_loop_vex_num_dtype(context, self.src.dtype, 0, 1)
        # vex_num and vst_loop_num must be set to 1
        instr_list = create_vloop_info(context, param, vst_loop_num=1)
        param.dist = _DIST_PLD.get(self.ld_mode)
        return param, instr_list

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        temp_env = TempEnv(require_xt=False)
        param, instr_list = self.get_instr_list(context)
        # [sn] + Am is UB addr, it's need aligned according ld_mode
        align = _DIST_PLD_ALIGN.get(self.ld_mode)
        offset = get_flatten_idx(self.src, context)
        check_extent_overflow(self.src, _DIST_PLD_ALIGN.get(self.ld_mode), offset, 'src')
        _, src_addr, _, _ = copy_tensor_to_model(context, temp_env, self.src, align, access_mode='r')
        param.snIdx = get_and_write_share_spr(context, src_addr + offset*DTYPE_SIZE[self.src.dtype], "uint32")
        if TikSocManager.is_v300_610l_soc():
            param.smIdx = get_and_write_share_spr(context, 0, "uint32")
            param.pdIdx = context.alloc_p_register(self.dst)
            instr = context.encoder.gen_vector_mask_load_plds(param)
        else:
            # gen vag instr for vloop
            vag_instr = gen_vag_instr(context, self.src.dtype)
            instr_list.append(vag_instr)

            param.amIdx = context.alloc_a_register(self.dst)
            param.pdIdx = context.alloc_p_register(self.dst)
            instr = context.encoder.gen_vector_mask_load(param)
        instr_list.append(instr)
        context.model.step_all(context, instr_list, len(instr_list))

        value_buffer = context.get_vector_value(self.dst).buffer
        flatten_np = value_buffer.reshape(-1)
        if TikSocManager.is_v300_610l_soc():
            context.model.read_vec_register_by_idx(VecRegType.P_REG, param.pdIdx, flatten_np.ctypes.data,
                                                   len(flatten_np) * DTYPE_SIZE[self.dst.dtype])
        else:
            pd_idx_rename = context.model.get_vec_register_index(param.pdIdx, VecRegType.P_REG)
            context.model.read_vec_register(pd_idx_rename, flatten_np.ctypes.data,
                                            len(flatten_np) * DTYPE_SIZE[self.dst.dtype])

        context.set_vector_state(self.dst, is_valid=True)
        context.free_all_register()


class VectorPst(STMT):
    """
    Predicate load instruction
    """
    def __init__(self, source_info, pst_params, tik_debugger=None):
        super(VectorPst, self).__init__(source_info, tik_debugger)
        self.dst = pst_params.dst  # dst is ub
        self.src = pst_params.src  # mask is preg
        self.st_mode = pst_params.st_mode

    def get_instr_list(self, context):
        """
        get instr list and param
        Parameters
        ----------
        context

        Returns
        -------

        """
        param = set_param_loop_vex_num_dtype(context, self.dst.dtype, 0, 1)
        # vex_num and vst_loop_num must be set to 1
        instr_list = create_vloop_info(context, param, vst_loop_num=1)
        param.dist = _DIST_PST.get(self.st_mode)

        return param, instr_list

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        temp_env = TempEnv(require_xt=False)
        param, instr_list = self.get_instr_list(context)
        # [sn] + Am is UB addr, it's need aligned according ld_mode
        align = _DIST_PST_ALIGN.get(self.st_mode)
        offset = get_flatten_idx(self.dst, context)
        check_extent_overflow(self.dst, _DIST_PST_ALIGN.get(self.st_mode), offset, 'dst')
        _, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.dst, align, access_mode='w')

        if TikSocManager.is_v300_610l_soc():
            param.snIdx = get_and_write_share_spr(context, dst_addr, "uint32")
            offset = get_flatten_idx(self.dst, context)
            param.smIdx = get_and_write_share_spr(context, offset * DTYPE_SIZE.get(self.dst.dtype), "uint32")
            param.pdIdx = context.alloc_p_register(self.src)
            instr = context.encoder.gen_vector_mask_store_psts(param)
        else:
            # gen vag instr for vloop
            vag_instr = gen_vag_instr(context, self.dst.dtype)
            instr_list.append(vag_instr)

            param.snIdx = get_and_write_share_spr(context, dst_addr + offset * DTYPE_SIZE[self.dst.dtype], "uint32")
            param.amIdx = context.alloc_a_register(self.src)
            param.pdIdx = context.alloc_p_register(self.src)
            instr = context.encoder.gen_vector_mask_store(param)

        instr_list.append(instr)
        context.model.step_all(context, instr_list, len(instr_list))

        context.model.read_memory(dst_addr, self.dst.scope, dst_ptr, dst_alloc_size)
        context.free_all_register()


class VectorPregTenaryElewise(STMT):
    """
    Vector pand/por/pxor/pnand/psel/pmov instruction
    """
    def __init__(self, source_info, vec_preg_params, instr_name, tik_debugger):
        super(VectorPregTenaryElewise, self).__init__(source_info, tik_debugger)
        self.dst = vec_preg_params.dst  # Pd
        if instr_name == "vectorized_pmov":
            self.src0 = vec_preg_params.src  # Pn
            self.src1 = vec_preg_params.src
        else:
            self.src0 = vec_preg_params.src0  # Pn
            self.src1 = vec_preg_params.src1  # Pm
        self.mask = vec_preg_params.mask  # Pg
        self.instr_name = instr_name

    def set_params(self, context, param):
        """
        set param
        Parameters
        ----------
        param
        context

        Returns
        -------

        """
        if TikSocManager.is_v300_610l_soc():
            param.type = V300_INSTR_REGTYPE_CODE.get(self.instr_name)
            param.op1 = V300_INSTR_OP1_CODE.get(self.instr_name)
        else:
            param.type = PARAMETERS.get(self.instr_name)
        pg_idx = context.alloc_p_register(self.mask, dtype="uint8")
        param.pgIdx = pg_idx
        pn_idx = context.alloc_p_register(self.src0, dtype=self.src0.dtype)
        param.pnIdx = pn_idx
        pm_idx = context.alloc_p_register(self.src1, dtype=self.src1.dtype)
        param.pmIdx = pm_idx
        pd_idx = context.alloc_p_register(self.dst)
        param.pdIdx = pd_idx
        return param, pd_idx

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, "uint8", 0, 1)
        instr_list = create_vloop_info(context, param)
        param, pd_idx = self.set_params(context, param)
        instr = context.encoder.gen_vector_preg_tenary_elewise(param)
        execute_all_instr(context, instr_list, instr, self.dst, pd_idx)


class VectorPintlvPdintlv(STMT):
    """
    Vector pintlv/pdintlv instruction
    """
    def __init__(self, source_info, intlv_params, dtype, tik_debugger):
        super(VectorPintlvPdintlv, self).__init__(source_info, tik_debugger)
        self.dst0 = intlv_params.dst0  # Pd
        self.dst1 = intlv_params.dst1  # Pd+1
        self.src0 = intlv_params.src0  # Pn
        self.src1 = intlv_params.src1  # Pm
        self.dtype = dtype
        self.instr_name = intlv_params.name

    def set_param(self, context, param):
        """

        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        param.type = VEC_TYPE_BITS.get(self.dtype)
        param.pgIdx = 0

        pd0_idx, pd1_idx = context.alloc_p_register(
            self.dst0, dtype=self.dst0.dtype, is_even=True)
        context.init_preg_according_cache(self.dst1, pd1_idx)

        if TikSocManager.is_v210_vec_soc():
            param.pdIdx = pd0_idx | _DST_REGISTER.get(self.instr_name)
        else:
            param.pdIdx = pd0_idx

        param.pnIdx = context.alloc_p_register(self.src0, dtype=self.src0.dtype)
        param.pmIdx = context.alloc_p_register(self.src1, dtype=self.src1.dtype)
        return param, pd0_idx, pd1_idx

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, self.dtype, 0, 1)
        instr_list = create_vloop_info(context, param)

        param, pd0_idx, pd1_idx = self.set_param(context, param)
        if TikSocManager.is_v300_610l_soc() and self.instr_name == "vectorized_pintlv":
            param.op1 = 0x6D
        elif TikSocManager.is_v300_610l_soc() and self.instr_name == "vectorized_pdintlv":
            param.op1 = 0x6E
        instr = context.encoder.gen_vector_preg_intlv_dintlv(param)
        instr_list.append(instr)
        context.model.step_all(context, instr_list, len(instr_list))
        if TikSocManager.is_v300_610l_soc():
            dst_register(context, (self.dst0, pd0_idx, VecRegType.P_REG))
            dst_register(context, (self.dst1, pd1_idx, VecRegType.P_REG))
        else:
            value_buffer0 = context.get_vector_value(self.dst0).buffer
            flatten_np0 = value_buffer0.reshape(-1)
            pd0_idx_rename = context.model.get_vec_register_index(pd0_idx, VecRegType.P_REG)
            context.model.read_vec_register(pd0_idx_rename, flatten_np0.ctypes.data, len(flatten_np0))

            value_buffer1 = context.get_vector_value(self.dst1).buffer
            flatten_np1 = value_buffer1.reshape(-1)
            pd1_idx_rename = context.model.get_vec_register_index(pd1_idx, VecRegType.P_REG)
            context.model.read_vec_register(pd1_idx_rename, flatten_np1.ctypes.data, len(flatten_np1))

        context.set_vector_state(self.dst0, is_valid=True)
        context.set_vector_state(self.dst1, is_valid=True)
        context.free_all_register()


class VectorPpackPunpack(STMT):
    """
    Vector ppack/punpack instruction
    """
    def __init__(self, source_info, unpack_params, name, tik_debugger):
        super(VectorPpackPunpack, self).__init__(source_info, tik_debugger)
        self.dst = unpack_params.dst
        self.src = unpack_params.src
        self.part_mode = unpack_params.part_mode
        self.instr_name = name

    def set_param(self, context, param):
        """
        set param
        Parameters
        ----------
        context
        param

        Returns
        -------

        """
        if self.part_mode:
            param.part = PARAMETERS[self.instr_name] | 0b010
        else:
            param.part = PARAMETERS[self.instr_name] | 0b000

        if TikSocManager.is_v300_610l_soc():
            param.op1 = V300_INSTR_OP1_CODE.get(self.instr_name)

        param.pgIdx = 0

        pd_idx = context.alloc_p_register(self.dst, dtype=self.dst.dtype)
        param.pdIdx = pd_idx
        param.pnIdx = context.alloc_p_register(self.src, dtype=self.src.dtype)
        return param, pd_idx

    def eval_(self, context):
        """
        eval context
        Parameters
        ----------
        context

        Returns
        -------

        """
        TempEnv()
        param = set_param_loop_vex_num_dtype(context, "uint8", 0, 1)
        instr_list = create_vloop_info(context, param)
        param, pd_idx = self.set_param(context, param)
        if TikSocManager.is_v300_610l_soc():
            param.part = self.part_mode
        instr = context.encoder.gen_vector_preg_pack_unpack(param)
        execute_all_instr(context, instr_list, instr, self.dst, pd_idx)
