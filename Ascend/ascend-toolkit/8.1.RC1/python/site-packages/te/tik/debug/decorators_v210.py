#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     decorators.py
DESC:     this file contains many decorator
CREATED:  2019-7-04 20:12:13
MODIFIED: 2019-7-24 14:04:45
"""
from functools import wraps

from tbe.tik.debug.intrinsic_v210_dup_cmp import VectorVdups
from tbe.tik.debug.intrinsic_v210_data_move import VectorLoad
from tbe.tik.debug.intrinsic_v210_data_move import VectorLoadUnalign
from tbe.tik.debug.intrinsic_v210_data_move import VectorStore
from tbe.tik.debug.intrinsic_v210_data_move import VectorStoreUnalign
from tbe.tik.debug.intrinsic_v210_data_move import VectorStoreUnalignSqzn
from tbe.tik.debug.intrinsic_v210 import VectorVcbmaxVcbmin
from tbe.tik.debug.intrinsic_v210 import VectorElewiseScalar
from tbe.tik.debug.intrinsic_v210 import VectorElewise
from tbe.tik.debug.intrinsic_v210_dup_cmp import VectorVcmps
from tbe.tik.debug.intrinsic_v210_dup_cmp import VectorVcmp
from tbe.tik.debug.intrinsic_v210_dup_cmp import VectorVdup
from tbe.tik.debug.intrinsic_v210_dup_cmp import VectorVdupi
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorRegTenaryElewise
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorIntlvDintlv
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorWholeReduce
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorSingleElewise
from tbe.tik.debug.intrinsic_v210 import VectorInitial
from tbe.tik.debug.intrinsic_v210 import VectorVscatter
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorCvtScvt
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorFcvtSfcvt
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorVgather
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorVgatherV2
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorVpackVunpack
from tbe.tik.debug.intrinsic_v210 import VectorVpd
from tbe.tik.debug.intrinsic_v210 import VectorVslide
from tbe.tik.debug.intrinsic_v210 import Fifr1
from tbe.tik.debug.intrinsic_v210_data_move import MvfMove
from tbe.tik.debug.intrinsic_v210_data_move import MvfDci
from tbe.tik.debug.intrinsic_v210_data_move import VectorVmov
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorVselr
from tbe.tik.debug.intrinsic_v210 import FmaxFmin
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorVusqz
from tbe.tik.debug.intrinsic_v210_vector_compute import VectorTrc
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_cube_debug_ import WinogradConv
from tbe.tik.debug.tikdbg.codemapping import get_caller_context


def mvf_data_move_decorator(func):
    """
    bind this decorator with mvf_data_move instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, name, type_args):
        if not tik_instance.debug_disabled:
            stmt = MvfMove(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, name, type_args)
    return wrapper


def mvf_dci_decorator(func):
    """
    bind this decorator with mvf_dci instructions
    """
    @wraps(func)
    def wrapper(tik_instance):
        if not tik_instance.debug_disabled:
            stmt = MvfDci(get_caller_context(), tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance)
    return wrapper


def fifr1_decorator(func):
    """
    bind this decorator with vector_fifr1 instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_fifr1):
        if not tik_instance.debug_disabled:
            stmt = Fifr1(get_caller_context(), debug_fifr1, tik_instance)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_fifr1)
    return wrapper


def fmax_fmin_decorator(func):
    """
    bind this decorator with maxfilter/minfilter instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = FmaxFmin(get_caller_context(), debug_params, tik_instance)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_elewise_scalar_decorator(func):
    """
    bind this decorator with vector element wise with scalar instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, mode=None):
        if not tik_instance.debug_disabled:
            stmt = VectorElewiseScalar(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, mode)
    return wrapper


def vector_vfcvt_vsfcvt_decorator(func):
    """
    bind this decorator with vfcvt/vsfcvt instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, literal_value):
        if not tik_instance.debug_disabled:
            stmt = VectorFcvtSfcvt(get_caller_context(), debug_params, literal_value, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, literal_value)
    return wrapper


def vector_vtrc_decorator(func):
    """
    bind this decorator with vtrc instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, mode):
        if not tik_instance.debug_disabled:
            stmt = VectorTrc(get_caller_context(), debug_params, mode, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, mode)
    return wrapper


def vector_vcvt_vscvt_decorator(func):
    """
    bind this decorator with vcvt/vscvt instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorCvtScvt(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_vgather_decorator(func):
    """
    bind this decorator with vgather2/vgatherb instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorVgather(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_vgatherv2_decorator(func):
    """
    bind this decorator with vgather2/vgatherb instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorVgatherV2(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_elewise_decroator(func):
    """
    bind this decorator with vector element wise instructions
    """
    @wraps(func)
    def wrapper(tik_instance, instr_name, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorElewise(get_caller_context(), debug_params, instr_name, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, instr_name, debug_params)
    return wrapper


def vector_vslide_decorator(func):
    """
    bind this decorator with vslide instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorVslide(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_vcbmax_vcbmin_decroator(func):
    """
    bind this decorator with vector vcbmax vcbmin instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorVcbmaxVcbmin(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_vcmp_decorator(func):
    """
    bind this decorator with vector vcmp instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorVcmp(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_vcmps_decorator(func):
    """
    bind this decorator with vector cmps instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorVcmps(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_vpack_vunpack_decorator(func):
    """
    bind this decorator with vector cmps instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, merge_mode=None):
        if not tik_instance.debug_disabled:
            stmt = VectorVpackVunpack(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, merge_mode)
    return wrapper


def vector_vdup_decorator(func):
    """
    bind this decorator with vector vdup/vdupm instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, load_mode):
        if not tik_instance.debug_disabled:
            stmt = VectorVdup(get_caller_context(), debug_params, load_mode, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, load_mode)
    return wrapper


def vector_vdups_decorator(func):
    """
    bind this decorator with vector_vdups instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, load_mode):
        if not tik_instance.debug_disabled:
            stmt = VectorVdups(get_caller_context(), debug_params,
                               load_mode, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, load_mode)
    return wrapper


def vector_vdupi_b8_decorator(func):
    """
    bind this decorator with vector_vdupib8 instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            mode = 0
            stmt = VectorVdupi(get_caller_context(), debug_params, mode, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_vdupi_b16_decorator(func):
    """
    bind this decorator with vector_vdupib16 instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, mode):
        if not tik_instance.debug_disabled:
            new_mode = 0x2 | mode
            stmt = VectorVdupi(get_caller_context(), debug_params, new_mode, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, mode)
    return wrapper


def vector_reg_ele_wise_decorator(func):
    """
    bind this decorator with vand/vor/vxor/vnand/vsel/vrnd/vmadd/vavg/vprelu/vsadd/vssub instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, rnd_mode=None, mode=None):
        if not tik_instance.debug_disabled:
            stmt = VectorRegTenaryElewise(
                get_caller_context(), debug_params, rnd_mode, tik_instance.context.tik_debugger)

            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, rnd_mode, mode)
    return wrapper


def vector_intlv_dintlv_decorator(func):
    """
    bind this decorator with vintlv/vdintlv instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorIntlvDintlv(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_vselr_decorator(func):
    """
    bind this decorator with vselr instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorVselr(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_whole_reduce_decorator(func):
    """
    bind this decorator with vector vabs/vcls/vneg/vcadd/vcmax/vcmin instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, mode):
        if not tik_instance.debug_disabled:
            stmt = VectorWholeReduce(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, mode)
    return wrapper


def vector_single_elewise_decorator(func):
    """
    bind this decorator with vector vrsqrt/vsqrt/vrec/vln/vbcnt/vrelu/vexp/vnot/vsqz/pnot instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params, mode=None):
        if not tik_instance.debug_disabled:
            stmt = VectorSingleElewise(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params, mode)
    return wrapper


def vector_vusqz_decorator(func):
    """
    bind this decorator with vusqz instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorVusqz(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_vmov_decorator(func):
    """
    bind this decorator with vector vmov instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorVmov(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_initial_decorator(func):
    """
    bind this decorator with vbr.b8/vbr.b16/vbr.b32/vci.s8/vci.s16/vci.s32/vci.f16/vci.f32 instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            stmt = VectorInitial(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)
    return wrapper


def vector_vpd_mask_decorator(func):
    """
    bind this decorator with vpd instructions
    """
    @wraps(func)
    def wrapper(tik_instance, dst, dtype):
        if not tik_instance.debug_disabled:
            stmt = VectorVpd(get_caller_context(), dst, dtype, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, dst, dtype)
    return wrapper


def vector_vscatter_decorator(func):
    """
    bind this decorator with vector vscatter instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            ctx = tik_instance.context
            stmt = VectorVscatter(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            ctx.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)

    return wrapper


def vector_load_ld_decorator(func):
    """
    bind this decorator with vector register load instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            ctx = tik_instance.context
            stmt = VectorLoad(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            ctx.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)

    return wrapper


def vector_load_unalign_decorator(func):
    """
    bind this decorator with vector load lda/ldu instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            ctx = tik_instance.context
            stmt = VectorLoadUnalign(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            ctx.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)

    return wrapper


def vector_store_st_decorator(func):
    """
    bind this decorator with vector register store instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            ctx = tik_instance.context
            stmt = VectorStore(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            ctx.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)

    return wrapper


def vector_store_unalign_sqzn_decorator(func):
    """
    bind this decorator with vector register store stur/star instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            ctx = tik_instance.context
            stmt = VectorStoreUnalignSqzn(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            ctx.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)

    return wrapper


def vector_store_unalign_decorator(func):
    """
    bind this decorator with vector register store stu/sta instructions
    """
    @wraps(func)
    def wrapper(tik_instance, debug_params):
        if not tik_instance.debug_disabled:
            ctx = tik_instance.context
            stmt = VectorStoreUnalign(get_caller_context(), debug_params, tik_instance.context.tik_debugger)
            ctx.curr_scope().add_stmt(stmt)
        return func(tik_instance, debug_params)

    return wrapper


def winograd_conv_decorator(func):
    """
    bind this decorator with load_winograd_fm instructions
    """
    @wraps(func)
    def wrapper(tik_instance, winograd_conv_api):
        if not tik_instance.debug_disabled:
            stmt = WinogradConv(get_caller_context(), winograd_conv_api, tik_instance.context.tik_debugger)
            tik_instance.context.curr_scope().add_stmt(stmt)
        return func(tik_instance, winograd_conv_api)
    return wrapper
