#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_multi_api.py
DESC:
CREATED:  2021-11-03 10:05
MODIFIED: 2021-11-03 10:05
"""
from collections import namedtuple

from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_vdp import check_vdp_tensor_overflow
from tbe.tik.tik_lib.tik_vector_api.tik_params_check_vdp import check_vdp_overlap
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug_ import NewVectorVectorTemplate
from tbe.tik.debug.sim.instr_encoder import Encoder
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.util import copy_tensor_to_model
from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.tik_lib.tik_params import ALIGNED_ADDR
from tbe.tik.tik_lib.tik_params import INT16_MAX
from tbe.tik.tik_lib.tik_params import VDP_OFFSET_LIST
from tbe.tik.tik_lib.tik_params import PNT_COE_OFFSET_LIST

_ENCODER = Encoder()
_MIN_NUM_PIXEL = 1
_MAX_DYNAMIC_ADDR = 4095
_begin_pixel_range = [0, 1]
_path_reverse_range = [0, 1]
_path_mode_range = [0, 1]


class VDP(STMT):
    """
    VDP instruction
    """

    def __init__(self, source_info, vdp_api, tik_debugger):
        super(VDP, self).__init__(source_info, tik_debugger)
        self.name = "vdp"
        self.dst = vdp_api.dst
        self.src0 = vdp_api.src0
        self.src1 = vdp_api.src1
        self.num_pixel = vdp_api.num_pixel
        self.num_max_disparity = vdp_api.num_max_disparity
        self.p1 = vdp_api.p1
        self.p2 = vdp_api.p2
        self.is_begin_pixel = vdp_api.is_begin_pixel
        self.is_path_reverse = vdp_api.is_path_reverse
        self.path_mode = vdp_api.path_mode
        self.offset_pixel = vdp_api.offset_pixel
        self.dynamic_addr_range = vdp_api.dynamic_addr_range

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        tmp_env = TempEnv()

        xn_idx, _, _, _ = copy_tensor_to_model(
            context, tmp_env, self.src0, ALIGNED_ADDR, access_mode='r')
        xm_idx, _, _, _ = copy_tensor_to_model(
            context, tmp_env, self.src1, ALIGNED_ADDR, access_mode='r')
        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, tmp_env, self.dst, ALIGNED_ADDR, access_mode='w')

        self.set_spr_pnt_coe(context)

        param = _ENCODER.new_param()
        param.type = self.gen_param_type()
        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = xm_idx
        param.xt = self.create_gpr_x_t(context, tmp_env)

        self.check_debug_overflow_overlap(context)

        instr = NewVectorVectorTemplate.VECTOR_VECTOR_FN_ENCODER.get(self.name)(param)

        context.model.step(instr)
        tmp_env.check_mem_access(context.model, False)

        context.model.read_memory(dst_addr, self.dst.scope, dst_ptr, dst_alloc_size)

    def check_debug_overflow_overlap(self, context):
        """
        check overflow and overlap
        """
        num_pixel = context.evaluate_expr(self.num_pixel)
        num_max_disparity = context.evaluate_expr(self.num_max_disparity)
        path_mode = context.evaluate_expr(self.path_mode)
        dst_offset = context.evaluate_expr(self.dst.offset)
        src0_offset = context.evaluate_expr(self.src0.offset)
        src1_offset = context.evaluate_expr(self.src1.offset)

        vdp_params_api = namedtuple('VdpOverflowApi', ["dst", "src0", "src1", "num_pixel", "num_max_disparity",
                                                       "path_mode", "dst_offset", "src0_offset", "src1_offset"])

        vdp_params_api = vdp_params_api(self.dst, self.src0, self.src1, num_pixel, num_max_disparity,
                                        path_mode, dst_offset, src0_offset, src1_offset)

        # check overflow
        check_vdp_tensor_overflow(vdp_params_api)

        # check overlap
        check_vdp_overlap(vdp_params_api)

    def gen_param_type(self):
        """
        generate param type encoding
        """
        type_encoding = None
        if self.dst.dtype == "int16":
            type_encoding = 0
        else:
            TikCheckUtil.raise_error(
                "instruction vdp not support this dtype of dst")
        return type_encoding

    def create_gpr_x_t(self, context, temp_env):
        """
        create register x_t

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xt_idx
        """
        num_pixel = context.evaluate_expr(self.num_pixel)
        num_max_disparity = context.evaluate_expr(self.num_max_disparity)
        is_begin_pixel = context.evaluate_expr(self.is_begin_pixel)
        is_path_reverse = context.evaluate_expr(self.is_path_reverse)
        path_mode = context.evaluate_expr(self.path_mode)
        offset_pixel = context.evaluate_expr(self.offset_pixel)
        dynamic_addr_range = context.evaluate_expr(self.dynamic_addr_range)
        # check num_max_disparity param
        TikCheckUtil.check_var_in_list(
            num_max_disparity, [0, 1], "num_max_disparity should be 0 or 1, input value is %s" % num_max_disparity)
        # check num_pixel param
        TikCheckUtil.check_in_range_by_dtype(
            num_pixel, msg="num_pixel should be in the range of [%s, %s], input value is %s"
                           % (_MIN_NUM_PIXEL, INT16_MAX, num_pixel), var_range=[_MIN_NUM_PIXEL, INT16_MAX])
        if num_max_disparity == 1:
            TikCheckUtil.check_even(
                num_pixel,
                "num_pixel should be even, input value is %s" % num_pixel)
        # check offset_pixel param
        if num_max_disparity == 1 and path_mode == 1:
            num_disparity = 64
            # offset value is 2*num_disparity*num_pixel//32
            offset_value = 2 * num_disparity * num_pixel // 32
            TikCheckUtil.check_equality(
                offset_pixel, offset_value,
                "offset_pixel should be %s, input value is %s" % (offset_value, offset_pixel))
        else:
            TikCheckUtil.check_in_range_by_dtype(
                offset_pixel, msg="offset_pixel should be in the range of [%s, %s], input value is %s"
                                  % (0, INT16_MAX, offset_pixel), var_range=[0, INT16_MAX])
        # variable max_value is 0b111111111111
        # check dynamic_addr_range param
        TikCheckUtil.check_in_range_by_dtype(
            dynamic_addr_range, msg="dynamic_addr_range should be in the range of [%s, %s], input value is %s"
            % (0, _MAX_DYNAMIC_ADDR, dynamic_addr_range), var_range=[0, _MAX_DYNAMIC_ADDR])
        # check is_begin_pixel param

        TikCheckUtil.check_var_in_list(is_begin_pixel, _begin_pixel_range,
                                       "is_begin_pixel only support %s and %s, input value is %s"
                                       % (_begin_pixel_range[0], _begin_pixel_range[1], is_begin_pixel))
        # check is_path_reverse param
        TikCheckUtil.check_var_in_list(is_path_reverse, _path_reverse_range,
                                       "is_path_reverse only support %s and %s, input value is %s"
                                       % (_path_reverse_range[0], _path_reverse_range[1], is_path_reverse))
        # check path_mode param
        TikCheckUtil.check_var_in_list(
            path_mode, _path_mode_range, "path_mode only support %s and %s, input value is %s"
                                         % (_path_mode_range[0], _path_mode_range[1], path_mode))

        xt_idx = temp_env.alloc_register()

        x_t = num_pixel
        x_t |= num_max_disparity << VDP_OFFSET_LIST[1]
        x_t |= offset_pixel << VDP_OFFSET_LIST[2]
        x_t |= dynamic_addr_range << VDP_OFFSET_LIST[3]
        x_t |= is_begin_pixel << VDP_OFFSET_LIST[4]
        x_t |= is_path_reverse << VDP_OFFSET_LIST[5]
        x_t |= path_mode << VDP_OFFSET_LIST[6]

        context.model.write_gpr(xt_idx, x_t)

        return xt_idx

    def set_spr_pnt_coe(self, context):
        """
        set special register PNT_COE

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        p1 = context.evaluate_expr(self.p1)
        p2 = context.evaluate_expr(self.p2)

        # check p1,p2 param
        TikCheckUtil.check_in_range_by_dtype(
            p1, msg="p1 should be in the range of [%s, %s], input value is %s"
            % (0, INT16_MAX, p1), var_range=[0, INT16_MAX])
        TikCheckUtil.check_in_range_by_dtype(
            p2, msg="p2 should be in the range of [%s, %s], input value is %s"
            % (0, INT16_MAX, p2), var_range=[0, INT16_MAX])
        TikCheckUtil.check_le(
            p1, p2, "p1 should be less than p2, but p1 is more than p2")
        TikCheckUtil.check_not_equality(
            p1, p2, "p1 should be less than p2, but p1 is equal to p2")

        pnt_coe = p1
        pnt_coe |= p2 << PNT_COE_OFFSET_LIST[1]

        context.model.write_spr('PNT_COE', pnt_coe)
