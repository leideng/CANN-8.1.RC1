#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     simd.py
DESC:     simd instrction
CREATED:  2019-7-04 20:12:13
MODIFIED: 2020-12-7 19:17:00
"""

from tbe.tik.debug.simd import eval_mask
from tbe.tik.debug.tik_vector_ops_debug.tik_common_high_preci_debug import fp162fp32_high_preci_func
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_vector_api.tik_scalar_multis_api_ import ScalarMultisOps
from tbe.tik.tik_lib.tik_vector_api.tik_vector_single_api_ import SingleOpApi
from tbe.tik.tik_lib.tik_vector_api.tik_vector_compare_api_ import VselOpApi
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_compare_debug_ import NewVcmpv
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug_ import NewVectorVectorTemplate
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug_ import NewVectorOnlyTemplate
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug_ import NewVectorScalarTemplate
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_compare_debug_ import Vsel
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_fills_debug_ import NewVectorScalarEltwise
from tbe.tik.common.common_nametuple_util import VecDupApi
from tbe.tik.common.common_nametuple_util import Fp162Fp32HighPreciApi
from tbe.tik.common.common_nametuple_util import VecVcmpvApi
from tbe.tik.common.common_nametuple_util import VecMultiApi
from tbe.tik.common.common_nametuple_util import VecSingleApi
from tbe.tik.common.common_nametuple_util import VecScalarMultisApi
from tbe.tik.common.common_nametuple_util import VecVselApi
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import ceil_div
from tbe.tik.common.common_util import vector_max_offset_cal
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_spr_debug_ import MoveTensor2CMPMASK
from tbe.tik.debug.util import set_vector_mask
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_TIMES
from tbe.tik.tik_lib.tik_params import DEFAULT_STRIDE
from tbe.tik.tik_lib.tik_params import MAX_REP_STRIDE_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import ONE_REP_BYTE_SIZE
from tbe.tik.tik_lib.tik_vector_api.tik_vector_compare_api_ import VcmpvOpApi
from tbe.tik.tik_lib.tik_vector_api.tik_vector_fills_api_ import DupOpApi
from tbe.tik.tik_lib.tik_vector_api.tik_vector_multi_api_ import MultiOp


class Vexpm1HighPreci(STMT):
    """
    this stmt for vexpm1 high precision
    """

    def __init__(self, source_info, vexpm_high_params, tik_instance, tik_debugger):
        super(Vexpm1HighPreci, self).__init__(source_info, tik_debugger)
        self.name = "vec_expm1_high_preci"
        self.mask = vexpm_high_params.mask
        self.dst = vexpm_high_params.dst
        self.src = vexpm_high_params.src
        self.work_tensor = vexpm_high_params.work_tensor
        self.repeat_times = vexpm_high_params.repeat_times
        self.dst_rep_stride = vexpm_high_params.dst_rep_stride
        self.src_rep_stride = vexpm_high_params.src_rep_stride
        self.extent = 0
        self.tik_instance = tik_instance
        self.context = None

    def eval_(self, context):
        """
        Vexpm1HighPreci eval
        Parameters
        ----------
        context: tik context

        Returns
        -------
        no return
        """
        self.context = None
        repeat_times = context.evaluate_expr(self.repeat_times)
        src_rep_stride = context.evaluate_expr(self.src_rep_stride)
        dst_rep_stride = context.evaluate_expr(self.dst_rep_stride)
        set_vector_mask(self.mask, context,
                        tensor_bit_len=max(get_bit_len(self.src.dtype),
                                           get_bit_len(self.dst.dtype)))

        mask = eval_mask(self.mask, context)

        # check params
        TikCheckUtil.check_in_range_by_dtype(
            repeat_times, msg="repeat_times should be in the range of [%d, %d], but input repeat_times: %d"
            % (0, MAX_REPEAT_TIMES, repeat_times),
            var_range=[0, MAX_REPEAT_TIMES])
        TikCheckUtil.check_in_range_by_dtype(
            src_rep_stride, msg="src_rep_stride should be in the range of [%d, %d], but input src_rep_stride: %d"
            % (DEFAULT_STRIDE, MAX_REP_STRIDE_SINGLE_BYTE, src_rep_stride),
            var_range=[DEFAULT_STRIDE, MAX_REP_STRIDE_SINGLE_BYTE])
        TikCheckUtil.check_in_range_by_dtype(
            dst_rep_stride, msg="dst_rep_stride should be in the range of [%d, %d], but input dst_rep_stride: %d"
            % (DEFAULT_STRIDE, MAX_REP_STRIDE_SINGLE_BYTE, dst_rep_stride),
            var_range=[DEFAULT_STRIDE, MAX_REP_STRIDE_SINGLE_BYTE])
        block_len = ONE_REP_BYTE_SIZE // get_bit_len(self.src.dtype)
        default_mask = 128
        default_rep_stride = 8 if 0 < src_rep_stride <= 8 else src_rep_stride
        src_extend = vector_max_offset_cal(
            (default_mask, self.src.dtype, block_len,
             repeat_times, 1, default_rep_stride))
        extent = ceil_div(src_extend, block_len) * block_len
        self.extent = extent

        cmp_sel = self._gen_comparator(context)

        self._expm1(context, (self.work_tensor[extent:2 * extent],
                              self.work_tensor[2 * extent:3 * extent], self.src,
                              src_rep_stride, src_rep_stride, src_rep_stride))

        fp162fp32_high_preci_params = Fp162Fp32HighPreciApi(self.source_info, context, self._expm1_taylor, mask,
                                                            self.work_tensor[2 * extent:3 * extent], self.src,
                                                            self.work_tensor[3 * extent:], repeat_times,
                                                            src_rep_stride, src_rep_stride, 4, self.name)
        fp162fp32_high_preci_func(self.tik_instance, fp162fp32_high_preci_params)

        self._do_select(context, cmp_sel, extent, repeat_times)

    def _gen_comparator(self, context):
        cmp_repeat_times = self.repeat_times
        and_rep_stride = 8
        if context.evaluate_expr(self.src_rep_stride) == 0:
            cmp_repeat_times = 1
            and_rep_stride = 0

        vec_dup_obj = VecDupApi(self.name, self.mask, self.work_tensor[:self.extent], 1.7, self.repeat_times, 1,
                                self.src_rep_stride, 0, "normal", "vector_dup")
        vec_dup_obj = DupOpApi(self.tik_instance, vec_dup_obj)
        v_dup_stmt = NewVectorScalarEltwise(self.source_info, vec_dup_obj, context.tik_debugger)
        v_dup_stmt.eval_(context)

        lt_tensor = self.work_tensor[self.extent: 2 * self.extent].reinterpret_cast_to("uint16")

        vcmpv_lt_obj = VecVcmpvApi(self.name, self.mask, lt_tensor, self.src, self.work_tensor[:self.extent],
                                   cmp_repeat_times, 1, 1, self.src_rep_stride, self.src_rep_stride,
                                   "vcmpv_lt")
        vcmpv_lt_obj = VcmpvOpApi(self.tik_instance, vcmpv_lt_obj)
        v_lt_stmt = NewVcmpv(self.source_info, vcmpv_lt_obj, context.tik_debugger)
        v_lt_stmt.eval_(context)

        vec_dup_obj = VecDupApi(self.name, self.mask, self.work_tensor[:self.extent], -0.7, self.repeat_times, 1,
                                self.src_rep_stride, 0, "normal", "vector_dup")
        vec_dup_obj = DupOpApi(self.tik_instance, vec_dup_obj)
        v_dup_stmt = NewVectorScalarEltwise(self.source_info, vec_dup_obj, context.tik_debugger)
        v_dup_stmt.eval_(context)

        gt_tensor = self.work_tensor[2 * self.extent:3 * self.extent].reinterpret_cast_to("uint16")
        vcmpv_gt_obj = VecVcmpvApi(self.name, self.mask, gt_tensor, self.src, self.work_tensor[:self.extent],
                                   cmp_repeat_times, 1, 1, self.src_rep_stride, self.src_rep_stride,
                                   "vcmpv_gt")
        vcmpv_gt_obj = VcmpvOpApi(self.tik_instance, vcmpv_gt_obj)
        v_gt_stmt = NewVcmpv(self.source_info, vcmpv_gt_obj, context.tik_debugger)
        v_gt_stmt.eval_(context)

        and_tensor = self.work_tensor[:self.extent].reinterpret_cast_to("uint16")
        vec_vand_obj = VecMultiApi(self.name, 128, and_tensor, lt_tensor, gt_tensor, self.repeat_times, 1, 1, 1,
                                   and_rep_stride, and_rep_stride, and_rep_stride, 0, "vand")
        vec_vand_obj = MultiOp(self.tik_instance, vec_vand_obj)
        v_and_stmt = NewVectorVectorTemplate(self.source_info, vec_vand_obj, context.tik_debugger)
        v_and_stmt.eval_(context)

        return and_tensor

    def _expm1(self, context, params_list):
        dst, work_tensor, src, dst_rep_stride, wk_rep_stride, src_rep_stride = params_list
        vec_vexp_obj = VecSingleApi(self.name, self.mask, work_tensor, src, self.repeat_times, 1, 1,
                                    wk_rep_stride, src_rep_stride, 0, "vexp")
        vec_vexp_obj = SingleOpApi(self.tik_instance, vec_vexp_obj)
        v_exp_stmt = NewVectorOnlyTemplate(self.source_info, vec_vexp_obj, context.tik_debugger)
        v_exp_stmt.eval_(context)

        vec_vadds_obj = VecScalarMultisApi(self.name, self.mask, dst, work_tensor, -1, self.repeat_times, 1, 1,
                                           dst_rep_stride, src_rep_stride, 0, 0, "normal", "vadds")
        vec_vadds_obj = ScalarMultisOps(self.tik_instance, vec_vadds_obj)
        v_adds_stmt = NewVectorScalarTemplate(self.source_info, vec_vadds_obj, context.tik_debugger)
        v_adds_stmt.eval_(context)

    def _vmultis_h_api(self, context, params_list, api_name):
        mask, dst, src, scalar, repeat_times, dst_blk_stride, src_blk_stride, \
        dst_rep_stride, src_rep_stride = params_list
        vec_vmultis_obj = VecScalarMultisApi(self.name, mask, dst, src, scalar, repeat_times, dst_blk_stride,
                                             src_blk_stride, dst_rep_stride, src_rep_stride,
                                             0, 0, "normal", api_name)
        vec_vmultis_obj = ScalarMultisOps(self.tik_instance, vec_vmultis_obj)
        v_multis_stmt = NewVectorScalarTemplate(self.source_info, vec_vmultis_obj, context.tik_debugger)
        v_multis_stmt.eval_(context)

    def _vmulti_h_api(self, context, params_list, api_name):
        vec_vmult_obj = VecMultiApi(self.name, *params_list, 0, api_name)
        vec_vmult_obj = MultiOp(self.tik_instance, vec_vmult_obj)
        v_mult_stmt = NewVectorVectorTemplate(self.source_info, vec_vmult_obj, context.tik_debugger)
        v_mult_stmt.eval_(context)

    def _expm1_taylor(self, context, params):
        mask, dst, src, work_tensor, repeat_times, dst_rep_stride, src_rep_stride, tmp_tensor_size = params
        wk_tensor1 = work_tensor[:tmp_tensor_size]
        wk_tensor2 = work_tensor[tmp_tensor_size:2 * tmp_tensor_size]

        self._vmultis_h_api(context, (mask, dst, src, 0, repeat_times, 1, 1,
                                      dst_rep_stride, src_rep_stride), "vadds")

        taylor_param = 1 / 2
        self._vmultis_h_api(context, (mask, wk_tensor1, src, 0, repeat_times, 1, 1,
                                      src_rep_stride, src_rep_stride), "vadds")

        self._vmulti_h_api(context, (mask, wk_tensor2, wk_tensor1, src, repeat_times, 1, 1, 1,
                                     src_rep_stride, src_rep_stride, src_rep_stride), "vmul")

        self._vmultis_h_api(context, (mask, wk_tensor1, wk_tensor2, taylor_param, repeat_times, 1, 1,
                                      src_rep_stride, src_rep_stride), "vmuls")

        self._vmulti_h_api(context, (mask, wk_tensor2, wk_tensor1, dst, repeat_times, 1, 1, 1,
                                     src_rep_stride, src_rep_stride, dst_rep_stride), "vadd")

        for index in range(3, 8):
            taylor_param = 1 / index
            if index % 2 == 1:
                self._vmulti_h_api(context, (mask, dst, wk_tensor1, src, repeat_times, 1, 1, 1,
                                             dst_rep_stride, src_rep_stride, src_rep_stride), "vmul")

                self._vmultis_h_api(context, (mask, wk_tensor1, dst, taylor_param, repeat_times, 1, 1,
                                              src_rep_stride, dst_rep_stride), "vmuls")

                self._vmulti_h_api(context, (mask, dst, wk_tensor2, wk_tensor1, repeat_times, 1, 1, 1,
                                             dst_rep_stride, src_rep_stride, src_rep_stride), "vadd")
            else:
                self._vmulti_h_api(context, (mask, wk_tensor2, wk_tensor1, src, repeat_times, 1, 1, 1,
                                             src_rep_stride, src_rep_stride, src_rep_stride), "vmul")

                self._vmultis_h_api(context, (mask, wk_tensor1, wk_tensor2, taylor_param, repeat_times, 1, 1,
                                              src_rep_stride, src_rep_stride), "vmuls")

                self._vmulti_h_api(context, (mask, wk_tensor2, dst, wk_tensor1, repeat_times, 1, 1, 1,
                                             src_rep_stride, dst_rep_stride, src_rep_stride), "vadd")

    def _do_select(self, context, cmp_sel, extent, repeat_times):
        src_offset = self.src_rep_stride * 32 // DTYPE_SIZE[self.src.dtype]
        dst_offset = self.dst_rep_stride * 32 // DTYPE_SIZE[self.dst.dtype]
        if context.evaluate_expr(self.src_rep_stride) == 0:
            sel_offset = 0
        else:
            sel_offset = 8
        for index in range(repeat_times):
            cmpmask_stmt = MoveTensor2CMPMASK(self.source_info,
                                              cmp_sel[index * sel_offset], self.tik_instance)
            cmpmask_stmt.eval_(context)
            v_sel_api = VecVselApi(self.mask, 0, self.dst[index * dst_offset:], cmpmask_stmt,
                                   self.work_tensor[2 * extent + index * src_offset:],
                                   self.work_tensor[extent + index * src_offset:], 1,
                                   1, 1, 1, self.dst_rep_stride,
                                   self.src_rep_stride, self.src_rep_stride, self.name, None, "vsel")
            v_sel_stmt = Vsel(self.source_info, VselOpApi(self.tik_instance, v_sel_api), context.tik_debugger)
            v_sel_stmt.eval_(context)
