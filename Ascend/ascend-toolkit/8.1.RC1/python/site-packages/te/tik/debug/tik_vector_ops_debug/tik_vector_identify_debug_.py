#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_vector_identify_debug_.py
DESC:     provide params
CREATED:  2021-11-30 18:53:42
MODIFIED: 2021-11-30 19:17:00
"""
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.sim import Encoder
from tbe.tik.debug.util import copy_tensor_to_model
from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.tik_lib.tik_params import REPEAT_SHIFT_POS
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_TIMES
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import ALIGNED_ADDR
from tbe.tik.debug.util import VEC_DATA_TYPE_ENCODING
from tbe.tik.common.util import DTYPE_SIZE
_ENCODER = Encoder()


class IdentifyDebug(STMT):
    """
    Vconv instruction
    """
    gen_encoder_dict = {
        "viou": _ENCODER.gen_viou,
        "vrpac": _ENCODER.gen_vrpac,
        "vaadd": _ENCODER.gen_vaadd,
        "vbitsort": _ENCODER.gen_vbs16,
        "vmergech": _ENCODER.gen_vmergech,
    }

    def __init__(self, source_info, op_obj):
        super(IdentifyDebug, self).__init__(source_info, op_obj.tik_instance.context.tik_debugger)
        self.op_obj = op_obj

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        temp_env = TempEnv()
        xn_idx, _, src0_buf_size, _ = copy_tensor_to_model(
            context, temp_env, self.op_obj.src0_op.tensor_obj, ALIGNED_ADDR, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.op_obj.dst_op.tensor_obj, ALIGNED_ADDR, access_mode='w')

        repeat_time = context.evaluate_expr(self.op_obj.repeat_times)
        TikCheckUtil.check_in_range_by_dtype(
            repeat_time, msg="repeat_times should be in range of [%d, %d], input value is %s"
            % (0, MAX_REPEAT_TIMES, str(repeat_time)),
            var_range=[0, MAX_REPEAT_TIMES])

        xt_idx = temp_env.alloc_register()
        x_t = 0
        x_t |= repeat_time << REPEAT_SHIFT_POS
        context.model.write_gpr(xt_idx, x_t)

        param = self.gen_param(xd_idx, xn_idx, xt_idx)
        if self.op_obj.name in ("viou", "vaadd"):
            xm_idx = self.viou_vaadd_overflow(context, temp_env, src0_buf_size, repeat_time)
            param.xm = xm_idx

        context.model.step(IdentifyDebug.gen_encoder_dict.get(self.op_obj.name)(param))
        if self.op_obj.name in ("viou", "vaadd"):
            temp_env.check_mem_access(context.model, False)
        if self.op_obj.name in ("vrpac", "vbitsort"):
            temp_env.check_mem_access(context.model, True)
        context.model.read_memory(dst_addr, self.op_obj.dst_op.tensor_obj.scope, dst_ptr, dst_alloc_size)

    def gen_param(self, xd_idx, xn_idx, xt_idx):
        """
        gen param

        Parameters
        ----------
        xd_idx : dst alloc register
        xn_idx : src0 alloc register
        xt_idx : temp_env alloc register

        Returns
        -------
        param
        """
        param = _ENCODER.new_param()
        param.type = VEC_DATA_TYPE_ENCODING[self.op_obj.src0_op.tensor_obj.dtype]
        param.xd = xd_idx
        param.xn = xn_idx
        param.xt = xt_idx
        return param

    def viou_vaadd_overflow(self, context, temp_env, src0_buf_size, repeat_time):
        """
        gen param

        Parameters
        ----------
        context : debug context
        temp_env : temp_env
        src0_buf_size : size of src0's buffer
        repeat_time : repeat times

        Returns
        -------
        xm_idx
        """
        if self.op_obj.name == "viou":
            value_op = 8
        else:
            value_op = 1
        xm_idx, _, src1_buf_size, _ = copy_tensor_to_model(
            context, temp_env, self.op_obj.src1_op.tensor_obj, ALIGNED_ADDR, access_mode='r')
        self.check_src0_overflow(src0_buf_size, repeat_time, context, value_op)
        self.check_src1_overflow(src1_buf_size, context, value_op)
        return xm_idx

    def check_src0_overflow(self, src_buf_size, repeat_time_value, context, value_op):
        """
        check src0 overflow

        Parameters
        ----------
        src_buf_size : size of tensor's buffer
        repeat_time_value : context expr value of repeat times
        context : sdebug context
        value_op : a value that changes with the instruction

        Returns
        -------
        None
        """
        src_offset = context.get_tensor_offset(self.op_obj.src0_op.tensor_obj) *\
                     DTYPE_SIZE[self.op_obj.src0_op.tensor_obj.dtype]
        # one repeat need
        need_buf_size = repeat_time_value * value_op * 16 * DTYPE_SIZE[self.op_obj.src0_op.tensor_obj.dtype]
        if src_buf_size - src_offset < need_buf_size:
            TikCheckUtil.raise_error("src0 overflow, need %d Bytes, but only %d Bytes" %
                                     (need_buf_size, src_buf_size - src_offset))

    def check_src1_overflow(self, src_buf_size, context, value_op):
        """
        check src1 overflow

        Parameters
        ----------
        src_buf_size : size of tensor's buffer
        context : sdebug context
        value_op : a value that changes with the instruction

        Returns
        -------
        None
        """
        src_offset = context.get_tensor_offset(self.op_obj.src1_op.tensor_obj) *\
                     DTYPE_SIZE[self.op_obj.src1_op.tensor_obj.dtype]
        need_buf_size = value_op * 16 * DTYPE_SIZE[self.op_obj.src1_op.tensor_obj.dtype]
        if src_buf_size - src_offset < need_buf_size:
            TikCheckUtil.raise_error("src1 overflow, need %d Bytes, but only %d Bytes" %
                                     (need_buf_size, src_buf_size - src_offset))
