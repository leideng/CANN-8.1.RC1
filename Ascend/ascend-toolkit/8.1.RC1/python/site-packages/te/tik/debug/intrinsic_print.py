#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     intrinsic_print.py
DESC:     intrinsic_printf
CREATED:  2021-12-29 12:32 PM
MODIFIED: 2021-12-29 12:32 PM
"""
import copy
import ast

import numpy as np

from tbe.tik.common.util import reduce_mul
from tbe.tik.common.common_util import is_tensor
from tbe.tik.common.common_util import is_scalar_array
from tbe.tik.debug.statement import STMT
from tbe.tik.tik_lib.tik_params import CUR_FRAME_IDX
from tbe.tik.tik_lib.tik_expr import BasicExpr


class VarResolver(ast.NodeTransformer):
    """
    Class VarResolver inherits from ast.NodeVisitor for visit node info
    """

    def __init__(self, symtable, ctx):
        """
        Initialize class VarResolver

        Parameters
        ----------
        symtable:symbol table, Evaluates the range of each symbol in the code
        ctx:Class context instance

        Returns
        ----------
        No returns
        """
        super(VarResolver, self).__init__()
        self.symtable = symtable
        self.ctx = ctx
        self.obj_is_tensor = False

        def _replace_fn(value):
            """
            define to replace function
            Parameters
            ----------
            value:func value

            Returns
            ----------
            np_buff:numpy buffer value
            value:func value
            """
            npbuf = self.ctx.get_value(value)
            if npbuf is not None:
                # this is a tensor
                ret_buf = npbuf.buffer
                if value.dtype == "bool" and value.dtype != npbuf.buffer.dtype:
                    ret_buf = self._uint8_to_bool_np_buffer(value, npbuf.buffer)
                return ret_buf

            vectorbuf = self.ctx.get_vector_value(value)
            if vectorbuf is not None:
                # this is a vector
                return vectorbuf.buffer

            if isinstance(value, BasicExpr):
                return self.ctx.evaluate_expr(value, default_value=True)

            if is_scalar_array(value):
                return [self.ctx.evaluate_expr(value[i], default_value=True)
                        for i in range(value.length)]

            return value

        self.replace_fn = _replace_fn

    def visit_Name(self, node):
        """
        Visit name function

        Parameters
        ----------
        node:AST node

        Returns
        ----------
        node
        """
        name = node.id
        ret = node
        obj = self.symtable.get(name)
        if is_tensor(obj):
            self.obj_is_tensor = True
        if obj is None:
            return ret

        npbuf = self.ctx.get_value(obj)
        if npbuf is not None:
            # this is a tensor
            np_arr = npbuf.buffer
            self.symtable[name] = np_arr
            if obj.dtype == "bool" and obj.dtype != np_arr.dtype:
                self.symtable[name] = self._uint8_to_bool_np_buffer(obj, np_arr)
            return ret

        vectorbuf = self.ctx.get_vector_value(obj)
        if vectorbuf is not None:
            # this is a vector
            np_arr = vectorbuf.buffer
            if vectorbuf.is_wide_register is True:
                data_step = 3
                data_nums = 3
                if vectorbuf.dtype == "int64":
                    data_nums = 2  # for int64, real data bit len is 96, but high 32 bits is neglected
                np_arr = np.array([int.from_bytes(np_arr[i:i + data_nums], 'little', signed=True)
                                   for i in range(0, len(np_arr), data_step)])
            self.symtable[name] = np_arr
            return ret

        if isinstance(obj, BasicExpr):
            self.symtable[name] = self.ctx.evaluate_expr(obj, default_value=True)
            return ret

        if is_scalar_array(obj):
            self.symtable[name] = [self.ctx.evaluate_expr(obj[i], default_value=True)
                                   for i in range(obj.length)]
            return ret

        return ret

    def visit_Attribute(self, node):
        """
        transform a.b to _attr_sub(a, 'b') -> tensor or a.b

        Parameters
        ----------
        node:AST node

        Returns
        ----------
        ast node
        """

        def _attr_stub(value, attr):
            ret = getattr(value, attr)
            return self.replace_fn(ret)

        self.symtable['_attr_stub'] = _attr_stub

        value = node.value
        attr = node.attr
        fn_name = ast.Name(id='_attr_stub', ctx=ast.Load())
        fn_name = ast.copy_location(fn_name, node)
        arg_name = ast.Str(s=attr)
        arg_name = ast.copy_location(arg_name, node)

        return ast.copy_location(ast.Call(func=fn_name,
                                          args=[self.visit(value),
                                                arg_name],
                                          keywords=[],
                                          starargs=None,
                                          kwargs=None), node)

    def visit_Subscript(self, node):
        """
        transform a[b] to _subscript_sub(a, b) -> tensor or a[b]
        slice = Ellipsis | Slice(expr? lower, expr? upper, expr? step) ExtSlice(slice* dims) | Index(expr value)
        slice is not a expr!

        Parameters
        ----------
        node:AST node

        Returns
        ----------
        ast node
        """

        def _subscript_index_stub(value, index):
            """
            subscript index stub
            """
            # Tensor's getitem return new Tensor, the new Tensor dimension is 1.
            if self.obj_is_tensor:
                ret = value.reshape(-1)[index:index+1]
            else:
                ret = value[index]
            return self.replace_fn(ret)

        def _subscript_ellipsis_stub(value):
            """
            subscript ellipsis stub
            """
            ret = value[...]
            return self.replace_fn(ret)

        def _subscript_slice_stub(value, slice_obj):
            """
            subscript slice stub
            """
            # Tensor's getitem return new Tensor, the new Tensor dimension is 1.
            if self.obj_is_tensor:
                ret = value.reshape(-1)[slice_obj]
            else:
                ret = value[slice_obj]
            return self.replace_fn(ret)

        def _subscript_extslice_stub(value, ext_slice_list):
            """
            subscript extslice stub
            """
            ret = value.__getitem__(ext_slice_list)
            return self.replace_fn(ret)

        def _visit_if_not_none(expr):
            """
            if expr not none then visit
            """
            if expr is not None:
                return self.visit(expr)
            return ast.copy_location(ast.Name(id='None', ctx=ast.Load()), node)

        self.symtable['_subscript_index_stub'] = _subscript_index_stub
        self.symtable['_subscript_ellipsis_stub'] = _subscript_ellipsis_stub
        self.symtable['_subscript_slice_stub'] = _subscript_slice_stub
        self.symtable['_subscript_extslice_stub'] = _subscript_extslice_stub

        value, slice_expr = node.value, node.slice

        if isinstance(slice_expr, ast.Index):
            fn_name = ast.Name(id='_subscript_index_stub', ctx=ast.Load())
            fn_name = ast.copy_location(fn_name, node)

            return ast.copy_location(ast.Call(func=fn_name, args=[self.visit(value), self.visit(slice_expr.value)],
                                              keywords=[], starargs=None, kwargs=None), node)
        if isinstance(slice_expr, ast.Ellipsis):
            fn_name = ast.Name(id='_subscript_ellipsis_stub', ctx=ast.Load())
            fn_name = ast.copy_location(fn_name, node)

            return ast.copy_location(ast.Call(func=fn_name, args=[self.visit(value)],
                                              keywords=[], starargs=None, kwargs=None), node)
        if isinstance(slice_expr, ast.Slice):
            fn_name = ast.Name(id='_subscript_slice_stub', ctx=ast.Load())
            fn_name = ast.copy_location(fn_name, node)

            create_fn = ast.Call(func=ast.copy_location(ast.Name(id='slice', ctx=ast.Load()), node),
                                 args=[_visit_if_not_none(slice_expr.lower), _visit_if_not_none(slice_expr.upper),
                                       _visit_if_not_none(slice_expr.step)],
                                 keywords=[], starargs=None, kwargs=None)

            create_fn = ast.copy_location(create_fn, node)

            return ast.copy_location(ast.Call(func=fn_name, args=[self.visit(value), create_fn],
                                              keywords=[], starargs=None, kwargs=None), node)

        if isinstance(slice_expr, ast.ExtSlice):
            fn_name = ast.Name(id='_subscript_extslice_stub', ctx=ast.Load())
            fn_name = ast.copy_location(fn_name, node)

            slice_list = []

            for dim in slice_expr.dims:
                if isinstance(dim, ast.Ellipsis):
                    slice_list.append(ast.copy_location(ast.Name(id='Ellipsis', ctx=ast.Load()), node))
                elif isinstance(dim, ast.Slice):
                    create_fn = ast.Call(func=ast.copy_location(ast.Name(id='slice', ctx=ast.Load()), node),
                                         args=[_visit_if_not_none(dim.lower), _visit_if_not_none(dim.upper),
                                               _visit_if_not_none(dim.step)],
                                         keywords=[], starargs=None, kwargs=None)

                    create_fn = ast.copy_location(create_fn, node)
                    slice_list.append(create_fn)
                elif isinstance(dim, ast.Index):
                    slice_list.append(self.visit(dim.value))

            list_expr = ast.Tuple(elts=slice_list, ctx=ast.Load())
            list_expr = ast.copy_location(list_expr, node)

            return ast.copy_location(ast.Call(func=fn_name, args=[self.visit(value), list_expr],
                                              keywords=[], starargs=None, kwargs=None), node)

    def visit_Call(self, node):
        """
        transform a(b) to _call_sub(a(b)) -> tensor or a(b)

        Parameters
        ----------
        node:AST node

        Returns
        ----------
        node
        """

        def _call_stub(ret):
            return self.replace_fn(ret)

        _call_stub_name = '_call_stub'

        self.symtable[_call_stub_name] = _call_stub

        fn_name = ast.Name(id=_call_stub_name, ctx=ast.Load())
        fn_name = ast.copy_location(fn_name, node)

        return ast.copy_location(ast.Call(func=fn_name,
                                          args=[self.generic_visit(node)],
                                          keywords=[],
                                          starargs=None,
                                          kwargs=None), node)

    def _uint8_to_bool_np_buffer(self, tensor_obj, np_buffer):
        """
        for conv uint8 bits to bool value of numpy buffer
        Parameters
        ----------
        tensor_obj: input tensor obj
        np_buffer: numpy buffer of the tensor

        Returns
        -------
        bool numpy buffer of the tensor

        """
        static_shape = self.ctx.get_tensor_shape(tensor_obj)
        ori_size = reduce_mul(static_shape)
        bits_array = np.unpackbits(np_buffer)[:ori_size]
        np_arr = bits_array.reshape(static_shape)
        return np_arr


class PrintExpr(STMT):
    """
    Class PrintExpr inherits from STMT
    Print expression.
    """

    def __init__(self, source_info, expr, tik_debugger):
        """
        Initialize class PrintExpr

        Parameters
        ----------
        source_info:source code information. It represents the relationship of current node with source code

        expr:expression, A part of stmt.

        Returns
        ----------
        No returns
        """
        super(PrintExpr, self).__init__(source_info, tik_debugger)
        self.expr = expr

    @staticmethod
    def get_print_expr(expr, sym_table, context):
        """
        Print expression function

        Parameters
        ----------
        expr:expression, A part of stmt.

        sym_table:symbol table, Evaluates the range of each symbol in the code

        context:Class Context.

        Returns
        ----------
        expr for print or error msg
        """
        # waiting for security modification
        msg = "[ERROR]: variable <%s> is undefined or uninitialized!" % expr
        sym_table['SPR'] = context.spr_proxy
        expr_ast = ast.parse(expr, mode='eval')
        resolver = VarResolver(sym_table, context)
        expr_ast = resolver.visit(expr_ast)
        try:
            expr_result = eval(compile(expr_ast, '<string>', 'eval'), globals(), resolver.symtable)
        except (SyntaxError, TypeError, NameError, ValueError,
                RuntimeError, IndexError, ZeroDivisionError,
                AttributeError, EOFError, FloatingPointError,
                IOError, ImportError, KeyError, PermissionError,
                OverflowError, SystemError):
            return msg

        if expr_result is None or (isinstance(expr_result, list) and any(i is None for i in expr_result)) or \
                is_tensor(expr_result):
            return msg
        return expr_result

    def eval_(self, context):
        """
        Eval function
        evaluate all of self.function

        Parameters
        ----------
        context:information of debugger
        store all of debugger's information

        Returns
        ----------
        No returns
        """
        symtable = copy.copy(self.source_info[CUR_FRAME_IDX].get("sym_table"))
        ret = self.get_print_expr(self.expr, symtable, context)
        print(str(ret))


class Print(STMT):
    """
    Class Print inherits from Print
    """

    def __init__(self, tensor, reshape, source_info, tik_debugger):
        """
        Initialize class Print

        Parameters
        ----------
        tensor: a type of Tensor

        reshape:reshape the buffer
        source_info:source code information, It represents the relationship of current node with source code

        Returns
        ----------
        No returns
        """
        super(Print, self).__init__(source_info, tik_debugger)
        self.tensor = tensor
        self.reshape = reshape

    @staticmethod
    def get_tensor(context, np_buf, raw_indice, reshape=None):
        """
        Get Tensor

        Parameters
        ----------
        context:information of debugger, store all of debugger's information

        np_buf:NumpyBuffer

        raw_indice: index of raw
        reshape:None

        Returns
        ----------
        buf:NumpyBuffer
        """
        buf = np_buf
        min_slice_extent = 1

        t_indice = Print.get_t_indice(context, raw_indice)
        if len(t_indice) != len(buf.shape):
            buf = buf.reshape(-1)
            lenght = len(buf)
            # first slice equal to t_indice start element
            first_slice = t_indice[0]
            start_ = first_slice.start
            end_ = lenght
            if first_slice.stop - first_slice.start > min_slice_extent:
                end_ = first_slice.stop
            t_indice = (slice(start_, end_),)

        buf = buf.__getitem__(t_indice)
        if reshape is not None:
            print(t_indice)
            try:
                buf = buf.reshape(reshape)
            except ValueError as exc:
                print(exc)

        return buf

    @staticmethod
    def get_t_indice(context, raw_indice):
        """
        Get Tensor

        Parameters
        ----------
        context:context:information of debugger, store all of debugger's information

        raw_indice: index of raw

        Returns
        ----------
        t_indice
        """
        indice = []
        for rid in raw_indice:
            if isinstance(rid, slice):
                ri_start = context.evaluate_expr(rid.start)
                ri_step = context.evaluate_expr(rid.step)
                ri_stop = context.evaluate_expr(rid.stop)
                rid = slice(ri_start, ri_stop, ri_step)
            else:
                rid = context.evaluate_expr(rid)
            indice.append(rid)

        t_indice = tuple(indice)

        return t_indice

    @staticmethod
    def dump_tensor(context, tensor, reshape=None, source_info=None):
        """
        To dump the given tensor

        Parameters
        ---------
        context:context:information of debugger, store all of debugger's information
        tensor: a type of Tensor
        reshape:None
        source_info:None

        Returns
        ----------
        No returns
        """
        np_buf = context.tensor_buffer.get_npbuffer_by_tvmbuffer(
            tensor.buffer).buffer.view(tensor.dtype)
        raw_indice = tensor.dimensions
        buf = Print.get_tensor(context, np_buf, raw_indice, reshape)
        if source_info:
            print(source_info)

        print(tensor.name + '.data (id:%s):\n%s' % (id(buf), str(buf)))
        print(tensor.name + '.shape:' + str(buf.shape) + ' dtype=' +
              str(buf.dtype))

    def eval_(self, context):
        """
        Eval function
        evaluate all of self.function

        Parameters
        ----------
        context:information of debugger, store all of debugger's information

        Returns
        ----------
        None
        """
        # disable print statement in interactive mode, because we can inspect
        # a tensor precisely
        if context.tik_debugger:
            return

        self.dump_tensor(context, self.tensor, self.reshape, self.source_info)
