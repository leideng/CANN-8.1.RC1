#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     mmad_intrinsic.py
DESC:     mmad_intrinsic
CREATED:  2021-12-03 10:43 AM
MODIFIED: 2021-12-03 10:43 AM
"""
import numpy as np

from tbe.common.platform import scope_cbuf

from tbe.tik.common.util import TikUtil
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import DTYPE_SIZE
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.util import cvt_float_to_uint
from tbe.tik.debug.util import get_dtype_bit_width
from tbe.tik.debug.util import copy_tensor_to_model
from tbe.tik.debug.util import model_with_env
from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import INC_MODE
from tbe.tik.tik_lib.tik_params import FRAC_LEN
from tbe.tik.tik_lib.tik_params import UINT8_MAX
from tbe.tik.tik_lib.tik_params import UINT16_MAX
from tbe.tik.tik_lib.tik_params import UINT_MIN
from tbe.tik.tik_lib.tik_params import ALIGNED_ADDR
from tbe.tik.tik_lib.tik_params import PADDING_LEFT_IDX
from tbe.tik.tik_lib.tik_params import PADDING_RIGHT_IDX
from tbe.tik.tik_lib.tik_params import PADDING_TOP_IDX
from tbe.tik.tik_lib.tik_params import PADDING_BOT_IDX
from tbe.tik.tik_lib.tik_params import MIN_EXTENSION
from tbe.tik.tik_lib.tik_params import MAX_EXTENSION
from tbe.tik.tik_lib.tik_params import MAX_START_PT
from tbe.tik.tik_lib.tik_params import MAX_ADDR
from tbe.tik.tik_lib.tik_params import MAX_PADDING
from tbe.tik.tik_lib.tik_params import REPEAT_MODE_SHIFT_BIT
from tbe.tik.tik_lib.tik_params import REPEAT_SHIFT_POS
from tbe.tik.tik_lib.tik_params import MAX_C1_INDEX
from tbe.tik.tik_lib.tik_params import MAX_FETCH_POS
from tbe.tik.tik_lib.tik_params import MIN_START_POINT
from tbe.tik.tik_lib.tik_params import MAX_START_POINT
from tbe.tik.tik_lib.tik_params import MIN_STRIDE
from tbe.tik.tik_lib.tik_params import MAX_STRIDE
from tbe.tik.tik_lib.tik_params import MIN_DILATION
from tbe.tik.tik_lib.tik_params import MAX_DILATION
from tbe.tik.tik_lib.tik_params import MIN_FILTER_WIDTH
from tbe.tik.tik_lib.tik_params import MAX_FILTER_WIDTH
from tbe.tik.tik_lib.tik_params import MIN_JUMP_OFFSET
from tbe.tik.tik_lib.tik_params import MAX_JUMP_OFFSET
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_MODE
from tbe.tik.tik_lib.tik_params import MIN_FILTER_HEIGHT
from tbe.tik.tik_lib.tik_params import MAX_FILTER_HEIGHT
from tbe.tik.tik_lib.tik_params import MIN_TENSOR_WIDTH
from tbe.tik.tik_lib.tik_params import MAX_TENSOR_WIDTH
from tbe.tik.tik_lib.tik_params import MIN_TENSOR_HEIGHT
from tbe.tik.tik_lib.tik_params import MAX_TENSOR_HEIGHT
from tbe.tik.tik_lib.tik_params import DEC_MODE
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_TIMES
from tbe.tik.tik_lib.tik_params import MAX_BLK_STRIDE_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_params import MAX_START_INDEX
from tbe.tik.tik_lib.tik_params import MAX_DST_GAP_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import load2d_3d_align_fn
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_mmad_param_type_range
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_load3dv2_channel_size
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_load3dv2_k_extension
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_load3dv2_m_extension
from tbe.tik.tik_lib.tik_mmad_convert_api.tik_mmad_convert_common import check_dilation_filter_size

_LOAD2D_SRC_ID = {'L1': 0, 'OUT': 1}
_LOAD2D_DST_ID = {'L0A': 0, 'L0B': 1, 'L1': 2}
_LOAD2D_DTYPE_ID = {'int8': 1, 'uint8': 0, 'float16': 1}
_LOAD2D_DTYPE_ID_L0B = {'int8': 1, 'uint8': 1, 'float16': 0}
_LOAD2DV3_DST_ID = {'L0A': 0, 'L0B': 1, "L1": 2}
_LOAD2DV3_DTYPE_ID = {'int8': 0, 'uint8': 0, 'float16': 1, 'uint16': 1, 'int16': 1}

_REPEAT_SHIFT_BIT_POS = 16
_LOAD2D_SRC_STRIDE_SHIFT_POS = 24

_STRIDE_H_SHIFT_BIT_POS = 6
_FILTER_W_SHIFT_BIT_POS = 12
_FILTER_H_SHIFT_BIT_POS = 20
_DILATION_W_SHIFT_BIT_POS = 28
_DILATION_H_SHIFT_BIT_POS = 36
_CTRL_SHIFT_BIT_POS = 63
_JUMP_OFFSET_SHIFT_BIT_POS = 44
_LOAD3D_DST_ID = {'L0A': 0, 'L0B': 1, 'UB': 2}
_FETCH_W_SHIFT_BIT_POS = 16
_FETCH_H_SHIFT_BIT_POS = 24
_LEFT_TOP_W_SHIFT_BIT_POS = 32
_LEFT_TOP_H_SHIFT_BIT_POS = 48
_L1_H_SHIFT_BIT_POS = 16
_PAD_L_SHIFT_BIT_POS = 32
_PAD_R_SHIFT_BIT_POS = 40
_PAD_TOP_SHIFT_BIT_POS = 48
_PAD_BOT_SHIFT_BIT_POS = 56
_PAD_VALUE_SHIFT_BIT_POS = 8

_MIN_START = 0
_SHIFT_BIT_POS = 52

_M_EXTENSION_SHIFT_BIT_POS = 16
_K_START_POINT_SHIFT_BIT_POS = 32
_M_START_POINT_SHIFT_POS = 48
_EN_TRANSPOSE_SMALL_K_SHIFT_POS = 44
_EN_TRANSPOSE_SMALL_K_SHIFT_POS_V2 = 46
_CHANNEL_SIZE_SHIFT_BIT_POS = 48

_LOAD3DV2_DST_ID = {
    'L0A': 0b00,
    'L0B': 0b01,
    'UB': 0b10
}

_LOAD3DV2_TYPE_ID = {
    '8': 0b00,
    '16': 0b01,
    '4': 0b10,
    '32': 0b11,
}


def _check_pad_list(pad_list):
    """
    check range of elements in pad_list

    Parameters
    ----------
    pad_list: parameters of instruction load3dv1, load3dv2, col2img

    Returns
    -------
    None
    """
    for index, pad_ele in enumerate(pad_list):
        TikCheckUtil.check_in_range_by_dtype(
            pad_ele, msg="pad_list[%s] should be in the range of [%d, %d], input value: %s"
                         % (index, 0, MAX_PADDING, pad_ele), var_range=[0, MAX_PADDING])


def _load3dv1_col2img_param_check(fetch_filter_h, fetch_filter_w, left_top_h, left_top_w):
    """
    check params of load3dv1 or col2img
    """
    TikCheckUtil.check_in_range_by_dtype(
        fetch_filter_h, msg="fetch_filter_h should be in the range of [%d, %d], input value is %s"
        % (0, MAX_FETCH_POS, str(fetch_filter_h)), var_range=[0, MAX_FETCH_POS])
    TikCheckUtil.check_in_range_by_dtype(
        fetch_filter_w, msg="fetch_filter_w should be in the range of [%d, %d], input value is %s"
        % (0, MAX_FETCH_POS, str(fetch_filter_w)), var_range=[0, MAX_FETCH_POS])
    TikCheckUtil.check_in_range_by_dtype(
        left_top_h, msg="left_top_h should be in the range of [%d, %d], input value is %s"
        % (MIN_START_POINT, MAX_START_POINT, str(left_top_h)), var_range=[MIN_START_POINT, MAX_START_POINT])
    TikCheckUtil.check_in_range_by_dtype(
        left_top_w, msg="left_top_w should be in the range of [%d, %d], input value is %s"
        % (MIN_START_POINT, MAX_START_POINT, str(left_top_w)), var_range=[MIN_START_POINT, MAX_START_POINT])


def _load3d_v2_params_check(k_extension, m_extension, k_start_pt, m_start_pt, dtype):
    """
    check params of load3dv2
    """
    TikCheckUtil.check_in_range_by_dtype(
        k_extension, msg="k_extension should be in the range of [{}, {}], input k_extension: {}".format(
            MIN_EXTENSION, MAX_EXTENSION, k_extension), var_range=[MIN_EXTENSION, MAX_EXTENSION])
    TikCheckUtil.check_in_range_by_dtype(
        m_extension, msg="m_extension should be in the range of [{}, {}], input m_extension: {}".format(
            MIN_EXTENSION, MAX_EXTENSION, m_extension), var_range=[MIN_EXTENSION, MAX_EXTENSION])
    TikCheckUtil.check_in_range_by_dtype(
        k_start_pt, msg="k_start_pt should be in the range of [{}, {}], input k_start_pt: {}".format(
            _MIN_START, MAX_START_PT, k_start_pt), var_range=[_MIN_START, MAX_START_PT])
    k_start_pt_byte_align = 32
    if k_start_pt * DTYPE_SIZE[dtype] % k_start_pt_byte_align != 0:
        TikCheckUtil.raise_error(
            "k_start_pt in Byte should be multiple of 32B, "
            "input k_start_pt: {}, input src dtype: {}".format(k_start_pt, dtype))
    TikCheckUtil.check_in_range_by_dtype(
        m_start_pt, msg="m_start_pt should be in the range of [{}, {}], input m_start_pt: {}".format(
            _MIN_START, MAX_START_PT, m_start_pt), var_range=[_MIN_START, MAX_START_PT])
    if m_start_pt % 16 != 0:
        TikCheckUtil.raise_error(
            "m_start_ptshould be multiple of 16, input m_start_pt: {}".format(m_start_pt))


def _load3d_col2img_param_check(params_val):
    """
    check params of load3dv1, load3dv2 or col2img
    """
    stride_w, stride_h, filter_w, filter_h, dilation_filter_w, dilation_filter_h = params_val
    TikCheckUtil.check_in_range_by_dtype(
        stride_w, msg="stride_w should be in the range of [{}, {}], input stride_w: {}".format(
            MIN_STRIDE, MAX_STRIDE, stride_w), var_range=[MIN_STRIDE, MAX_STRIDE])
    TikCheckUtil.check_in_range_by_dtype(
        stride_h, msg="stride_h should be in the range of [{}, {}], input stride_h: {}".format(
            MIN_STRIDE, MAX_STRIDE, stride_h), var_range=[MIN_STRIDE, MAX_STRIDE])
    TikCheckUtil.check_in_range_by_dtype(
        filter_w, msg="filter_w should be in the range of [{}, {}], input filter_w: {}".format(
            MIN_FILTER_WIDTH, MAX_FILTER_WIDTH, filter_w), var_range=[MIN_FILTER_WIDTH, MAX_FILTER_WIDTH])
    TikCheckUtil.check_in_range_by_dtype(
        filter_h, msg="filter_h should be in the range of [{}, {}], input filter_h: {}".format(
            MIN_FILTER_HEIGHT, MAX_FILTER_HEIGHT, filter_h), var_range=[MIN_FILTER_HEIGHT, MAX_FILTER_HEIGHT])
    TikCheckUtil.check_in_range_by_dtype(
        dilation_filter_w, msg="dilation_filter_w should be in the range of [{}, {}], "
                               "input dilation_filter_w: {}".format(MIN_DILATION, MAX_DILATION, dilation_filter_w),
        var_range=[MIN_DILATION, MAX_DILATION])
    TikCheckUtil.check_in_range_by_dtype(
        dilation_filter_h, msg="dilation_filter_h should be in the range of [{}, {}], "
                               "input dilation_filter_h: {}".format(MIN_DILATION, MAX_DILATION, dilation_filter_h),
        var_range=[MIN_DILATION, MAX_DILATION])


class Load2D(STMT):
    """
    Load2D instruction
    """

    def __init__(self, source_info, load2d_obj):

        super(Load2D, self).__init__(source_info, load2d_obj.tik_instance.context.tik_debugger)
        self.obj = load2d_obj

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        temp_env = TempEnv(is_aic_api=True)

        src_align, dst_align = load2d_3d_align_fn(self.obj.dst, self.obj.src)

        xn_idx, _, _, _ = copy_tensor_to_model(context, temp_env, self.obj.src, src_align, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.obj.dst, dst_align, access_mode='w')

        param = context.encoder.new_param()
        param.srcMemId = _LOAD2D_SRC_ID.get(TikUtil.get_storage_scope(self.obj.src.scope))
        param.dstMemId = _LOAD2D_DST_ID.get(TikUtil.get_storage_scope(self.obj.dst.scope))
        # 1 enable transpose; 0 disable transpose
        param.trans = 1 if self.obj.en_transpose else 0
        # in the 910b/310b/610l, the bits 0 and 1 of instr must be set to dstId, the bits 3 of instr is reserved_0,
        # which is irrelevant to data_type.
        if not (TikSocManager.is_910b_soc() or TikSocManager.is_310b_610l_soc()):
            param.type = _LOAD2D_DTYPE_ID.get(self.obj.src.dtype)
        param.addrmode = 0

        if self.obj.addr_mode == 'inc':
            param.addrmode = INC_MODE
        elif self.obj.addr_mode == 'dec':
            param.addrmode = DEC_MODE

        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = self.create_gpr_x_m(context, temp_env)
        if TikSocManager.is_610l_soc():
            param.type = _LOAD2DV3_DTYPE_ID.get(self.obj.src.dtype)
            param.xt = self.create_gpr_x_t_610l(context, temp_env)
            instr = self.gen_dma_ld_2d_transpose(param, TikUtil.get_storage_scope(self.obj.dst.scope))
        elif TikSocManager.is_310b_soc() and self.obj.src.dtype in ("uint8", "int8") and self.obj.en_transpose:
            param.type = 0  # 310b b8->2'b00
            instr = self.gen_dma_ld_2d_transpose(param, TikUtil.get_storage_scope(self.obj.dst.scope))
        else:
            instr = context.encoder.gen_dma_ld_2d(param)

        model_with_env(context.model.step, temp_env, instr)

        temp_env.check_mem_access(context.model, True)

        model_with_env(context.model.read_memory, temp_env, dst_addr, self.obj.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_m(self, context, temp_env):
        """
        create register x_m

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """

        repeat = context.evaluate_expr(self.obj.repeat_times)
        # check repeat
        check_mmad_param_type_range('repeat_times', repeat, end=MAX_REPEAT_TIMES, is_debug=True)

        src_stride = context.evaluate_expr(self.obj.src_stride)
        # check src_stride
        check_mmad_param_type_range('src_stride', src_stride, end=MAX_BLK_STRIDE_DOUBLE_BYTE, is_debug=True)

        xm_idx = temp_env.alloc_register()

        index_ = context.evaluate_expr(self.obj.start_index)
        # check index
        check_mmad_param_type_range('start_index', index_, end=MAX_START_INDEX, is_debug=True)

        x_m = 0
        x_m |= index_
        x_m |= repeat << _REPEAT_SHIFT_BIT_POS
        x_m |= src_stride << _LOAD2D_SRC_STRIDE_SHIFT_POS
        if self.obj.dst_gap is not None:
            dst_gap = context.evaluate_expr(self.obj.dst_gap)
            # check dst_gap
            check_mmad_param_type_range('dst_gap', dst_gap, end=MAX_DST_GAP_DOUBLE_BYTE, is_debug=True)

            x_m |= context.evaluate_expr(self.obj.dst_gap) << 44

        x_m |= context.evaluate_expr(self.obj.sid) << 40

        model_with_env(context.model.write_gpr, temp_env, xm_idx, x_m)

        return xm_idx

    @staticmethod
    def create_gpr_x_t_610l(context, temp_env):
        """
        610l use load_cbuf_to_cb_transpose instruction
        """
        xt_idx = temp_env.alloc_register()
        # not developed for users. the value is 0 for continuous data.
        dst_frac_gap, src_frac_gap = 0, 0
        x_t = 0
        x_t |= dst_frac_gap  # (dst_frac_stride - 1)
        x_t |= src_frac_gap << FRAC_LEN  # (src_frac_stride - 1)
        context.model.write_gpr(xt_idx, x_t)

        return xt_idx

    @staticmethod
    def gen_dma_ld_2d_transpose(param, scope):
        """
        generator 610l load_cbuf_to_cb_transpose instruction
        """
        instr = 109  # 011 01 101
        instr = instr << 24  # [32, 24]
        instr += param.type << 22  # type[23, 22]
        instr += param.xd << 17  # xd[21, 17]
        instr += param.xn << 12  # xn[16, 12]
        instr += param.xm << 7  # xm[11, 7]
        instr += param.xt << 2  # xt[6, 2]
        instr += _LOAD2D_DST_ID.get(scope) # 01[1, 0]
        return instr


class Load2DV3(STMT):
    """
    Load2DV3 instruction
    """

    def __init__(self, source_info, load2d_obj):
        super(Load2DV3, self).__init__(source_info, load2d_obj.tik_instance.context.tik_debugger)
        self.obj = load2d_obj
        self.m_start_pt = None
        self.k_start_pt = None
        self.m_step = None
        self.k_step = None
        self.src_stride = None
        self.dst_stride = None

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        self.check_all_param(context)
        temp_env = TempEnv(is_aic_api=True)

        src_align, dst_align = load2d_3d_align_fn(self.obj.dst, self.obj.src)

        xn_idx, _, _, _ = copy_tensor_to_model(context, temp_env, self.obj.src, src_align, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.obj.dst, dst_align, access_mode='w')

        param = context.encoder.new_param()
        param.xd = xd_idx
        param.xn = xn_idx
        param.out = _LOAD2DV3_DST_ID.get(TikUtil.get_storage_scope(self.obj.dst.scope))
        if self.obj.src.scope == scope_cbuf:
            # 1 enable transpose; 0 disable transpose
            param.trans = 1 if self.obj.en_transpose else 0
            param.type = _LOAD2DV3_DTYPE_ID.get(self.obj.dst.dtype)
            param.xm = self.create_gpr_x_m_src_cbuf(context, temp_env)
            param.xt = self.create_gpr_x_t_src_cbuf(context, temp_env)
            instr = context.encoder.gen_dma_ld_2d_v3_cb(param)
        else:
            # irrelevant to data_type, transpose
            param.xm = self.create_gpr_x_m_src_gm(context, temp_env)
            param.xt = self.create_gpr_x_t_src_gm(context, temp_env)
            instr = context.encoder.gen_dma_ld_2d_v3_gm(param)

        model_with_env(context.model.step, temp_env, instr)

        temp_env.check_mem_access(context.model, True)

        model_with_env(context.model.read_memory, temp_env, dst_addr, self.obj.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_m_src_cbuf(self, context, temp_env):
        """
        create register x_m, src scope is cbuf

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        xm_idx = temp_env.alloc_register()

        x_m = 0
        x_m |= self.m_start_pt
        x_m |= self.k_start_pt << 16
        x_m |= self.m_step << 32
        x_m |= self.k_step << 40

        model_with_env(context.model.write_gpr, temp_env, xm_idx, x_m)

        return xm_idx

    def create_gpr_x_m_src_gm(self, context, temp_env):
        """
        create register x_m, src scope is gm

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        xm_idx = temp_env.alloc_register()
        x_m = 0
        x_m |= self.m_start_pt
        x_m |= self.k_start_pt << 32
        model_with_env(context.model.write_gpr, temp_env, xm_idx, x_m)

        return xm_idx

    def create_gpr_x_t_src_cbuf(self, context, temp_env):
        """
        create register x_t, src scope is cbuf

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xt_idx
        """

        xt_idx = temp_env.alloc_register()
        x_t = self.src_stride
        x_t |= self.dst_stride << 16
        context.model.write_gpr(xt_idx, x_t)

        return xt_idx

    def create_gpr_x_t_src_gm(self, context, temp_env):
        """
        create register x_t, src scope is gm

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xt_idx
        """
        xt_idx = temp_env.alloc_register()
        x_t = self.src_stride
        x_t |= self.dst_stride << 32
        x_t |= self.m_step << 40
        x_t |= self.k_step << 48
        context.model.write_gpr(xt_idx, x_t)

        return xt_idx

    def check_all_param(self, context):
        """
        check all param
        """
        # m_start_pt
        if isinstance(self.obj.m_start_pt, int):
            self.m_start_pt = self.obj.m_start_pt
        else:
            self.m_start_pt = context.evaluate_expr(self.obj.m_start_pt)
            TikCheckUtil.check_in_range_by_dtype(
                self.m_start_pt, var_range=[UINT_MIN, UINT16_MAX],
                msg=f"m_start_pt should be in range of [{UINT_MIN}, {UINT16_MAX}], input: {self.m_start_pt}"
            )
        # k_start_pt
        if isinstance(self.obj.k_start_pt, int):
            self.k_start_pt = self.obj.k_start_pt
        else:
            self.k_start_pt = context.evaluate_expr(self.obj.k_start_pt)
            TikCheckUtil.check_in_range_by_dtype(
                self.k_start_pt, var_range=[UINT_MIN, UINT16_MAX],
                msg=f"k_start_pt should be in range of [{UINT_MIN}, {UINT16_MAX}], input: {self.k_start_pt}"
            )
        # m_step
        if isinstance(self.obj.m_step, int):
            self.m_step = self.obj.m_step
        else:
            self.m_step = context.evaluate_expr(self.obj.m_step)
            TikCheckUtil.check_in_range_by_dtype(
                self.m_step, var_range=[UINT_MIN, UINT8_MAX],
                msg=f"m_step should be in range of [{UINT_MIN}, {UINT8_MAX}], input: {self.m_step}"
            )
        # k_step
        if isinstance(self.obj.k_step, int):
            self.k_step = self.obj.k_step
        else:
            self.k_step = context.evaluate_expr(self.obj.k_step)
            TikCheckUtil.check_in_range_by_dtype(
                self.k_step, var_range=[UINT_MIN, UINT8_MAX],
                msg=f"k_step should be in range of [{UINT_MIN}, {UINT8_MAX}], input: {self.k_step}"
            )
        # src_stride
        if isinstance(self.obj.src_stride, int):
            self.src_stride = self.obj.src_stride
        else:
            self.src_stride = context.evaluate_expr(self.obj.src_stride)
            TikCheckUtil.check_in_range_by_dtype(
                self.src_stride, var_range=[UINT_MIN, UINT16_MAX],
                msg=f"src_stride should be in range of [{UINT_MIN}, {UINT16_MAX}], input: {self.src_stride}"
            )
        # dst_stride
        if isinstance(self.obj.dst_stride, int):
            self.dst_stride = self.obj.dst_stride
        else:
            self.dst_stride = context.evaluate_expr(self.obj.dst_stride)
            TikCheckUtil.check_in_range_by_dtype(
                self.dst_stride, var_range=[UINT_MIN, UINT16_MAX],
                msg=f"dst_stride should be in range of [{UINT_MIN}, {UINT16_MAX}], input: {self.dst_stride}"
            )


class Load3DV1(STMT):
    """
    Load3DV1 instruction
    """

    def __init__(self, source_info, load3d_obj):
        super(Load3DV1, self).__init__(source_info, load3d_obj.tik_instance.context.tik_debugger)
        self.obj = load3d_obj

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        temp_env = TempEnv()

        dst_scope = TikUtil.get_storage_scope(self.obj.dst.scope)

        src_align, dst_align = load2d_3d_align_fn(self.obj.dst, self.obj.src)

        xn_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.obj.src, src_align, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.obj.dst, dst_align, access_mode='w')

        self.set_spr_padding(context)

        self.set_spr_fmatrix(context)

        if self.obj.csize:
            ctrl = context.model.read_spr('CTRL')
            ctrl |= 1 << _CTRL_SHIFT_BIT_POS
            context.model.write_spr('CTRL', ctrl)

        param = context.encoder.new_param()
        if dst_scope == 'L0B':
            param.type = _LOAD2D_DTYPE_ID_L0B.get(self.obj.src.dtype)
        else:
            param.type = _LOAD2D_DTYPE_ID.get(self.obj.src.dtype)
        param.dstMemId = _LOAD3D_DST_ID.get(dst_scope)
        param.csize = self.obj.csize
        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = self.create_gpr_x_m(context, temp_env)
        param.xt = self.create_gpr_x_t(context, temp_env)

        instr = context.encoder.gen_dma_ld_3d(param)

        context.model.step(instr)
        temp_env.check_mem_access(context.model, True)

        context.model.read_memory(dst_addr, self.obj.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_m(self, context, temp_env):
        """
        create register x_m

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        c1_index = context.evaluate_expr(self.obj.c1_index)
        fetch_filter_h = context.evaluate_expr(self.obj.fetch_filter_h)
        fetch_filter_w = context.evaluate_expr(self.obj.fetch_filter_w)
        left_top_w = context.evaluate_expr(self.obj.left_top_w)
        left_top_h = context.evaluate_expr(self.obj.left_top_h)
        # check params
        check_mmad_param_type_range('c1_index', c1_index, end=MAX_C1_INDEX, is_debug=True)
        _load3dv1_col2img_param_check(fetch_filter_h, fetch_filter_w, left_top_h, left_top_w)

        xm_idx = temp_env.alloc_register()

        x_m = c1_index
        x_m |= fetch_filter_w << _FETCH_W_SHIFT_BIT_POS
        x_m |= fetch_filter_h << _FETCH_H_SHIFT_BIT_POS
        x_m |= (left_top_w & MAX_ADDR) << _LEFT_TOP_W_SHIFT_BIT_POS
        x_m |= (left_top_h & MAX_ADDR) << _LEFT_TOP_H_SHIFT_BIT_POS

        context.model.write_gpr(xm_idx, x_m)

        return xm_idx

    def create_gpr_x_t(self, context, temp_env):
        """
        create register x_t

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xt_idx
        """
        stride_w = context.evaluate_expr(self.obj.stride_w)
        stride_h = context.evaluate_expr(self.obj.stride_h)
        dilation_filter_w = context.evaluate_expr(self.obj.dilation_filter_w)
        dilation_filter_h = context.evaluate_expr(self.obj.dilation_filter_h)
        filter_w = context.evaluate_expr(self.obj.filter_w)
        filter_h = context.evaluate_expr(self.obj.filter_h)
        repeat_time = context.evaluate_expr(self.obj.repeat_time)
        jump_offset = context.evaluate_expr(self.obj.jump_offset)
        repeat_mode = context.evaluate_expr(self.obj.repeat_mode)
        # check params

        _load3d_col2img_param_check([stride_w, stride_h, filter_w, filter_h, dilation_filter_w, dilation_filter_h])
        TikCheckUtil.check_in_range_by_dtype(
            repeat_time, msg="repeat_time should be in the range of [%s, %s], input repeat_time is %s"
            % (0, MAX_REPEAT_TIMES, str(repeat_time)), var_range=[0, MAX_REPEAT_TIMES])
        TikCheckUtil.check_in_range_by_dtype(
            jump_offset, msg="jump_offset should be in the range of [%s, %s], input jump_offset is %s"
            % (MIN_JUMP_OFFSET, MAX_JUMP_OFFSET, str(jump_offset)), var_range=[MIN_JUMP_OFFSET, MAX_JUMP_OFFSET])
        TikCheckUtil.check_var_in_list(
            repeat_mode, [_MIN_START, MAX_REPEAT_MODE], "repeat_mode should be %s or %s, input repeat_mode: %d"
                                                        % (_MIN_START, MAX_REPEAT_MODE, self.obj.repeat_mode))

        xt_idx = temp_env.alloc_register()

        x_t = stride_w
        x_t |= stride_h << _STRIDE_H_SHIFT_BIT_POS
        x_t |= filter_w << _FILTER_W_SHIFT_BIT_POS
        x_t |= filter_h << _FILTER_H_SHIFT_BIT_POS
        x_t |= dilation_filter_w << _DILATION_W_SHIFT_BIT_POS
        x_t |= dilation_filter_h << _DILATION_H_SHIFT_BIT_POS
        x_t |= jump_offset << _JUMP_OFFSET_SHIFT_BIT_POS
        x_t |= repeat_mode << REPEAT_MODE_SHIFT_BIT
        x_t |= repeat_time << REPEAT_SHIFT_POS

        context.model.write_gpr(xt_idx, x_t)

        return xt_idx

    def set_spr_fmatrix(self, context):
        """
        set special register FMATRIX

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        pad = [context.evaluate_expr(pad) for pad in self.obj.pad]
        pad_l, pad_r, pad_top, pad_bot = pad

        for index, pad_ele in enumerate(pad):
            TikCheckUtil.check_in_range_by_dtype(
                pad_ele, msg="pad_list[%s] should be in the range of [%s, %s], input value: %s"
                % (index, _MIN_START, MAX_PADDING, pad_ele), var_range=[_MIN_START, MAX_PADDING])

        l1_h = context.evaluate_expr(self.obj.l1_h)
        l1_w = context.evaluate_expr(self.obj.l1_w)
        TikCheckUtil.check_in_range_by_dtype(
            l1_w, msg="l1_w should be in the range of [%s, %s], input value is %s" % (
                MIN_TENSOR_WIDTH, MAX_TENSOR_WIDTH, str(l1_w)), var_range=[MIN_TENSOR_WIDTH, MAX_TENSOR_WIDTH])
        TikCheckUtil.check_in_range_by_dtype(
            l1_h, msg="l1_h should be in the range of [%s, %s], input value is %s" % (
                MIN_TENSOR_HEIGHT, MAX_TENSOR_HEIGHT, str(l1_h)), var_range=[MIN_TENSOR_HEIGHT, MAX_TENSOR_HEIGHT])

        fmatrix = l1_w
        fmatrix |= l1_h << _L1_H_SHIFT_BIT_POS
        fmatrix |= pad_l << _PAD_L_SHIFT_BIT_POS
        fmatrix |= pad_r << _PAD_R_SHIFT_BIT_POS
        fmatrix |= pad_top << _PAD_TOP_SHIFT_BIT_POS
        fmatrix |= pad_bot << _PAD_BOT_SHIFT_BIT_POS

        context.model.write_spr('FMATRIX', fmatrix)

    def set_spr_padding(self, context):
        """
        set special register PADDING

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        pad_value = context.evaluate_expr(self.obj.pad_value)

        if self.obj.dst.dtype == 'float16':
            spr_pad_value = cvt_float_to_uint('float16', pad_value)
        else:
            spr_pad_value = pad_value
            spr_pad_value |= pad_value << _PAD_VALUE_SHIFT_BIT_POS
        context.model.write_spr('PADDING', spr_pad_value)


class Load3DV2(STMT):
    """
    Load3DV2 instruction
    """

    def __init__(self, source_info, load3dv2_obj):
        super(Load3DV2, self).__init__(source_info, load3dv2_obj.tik_instance.context.tik_debugger)
        self.obj = load3dv2_obj
        self.pad_list_val = None
        self.l1_h_val = None
        self.l1_w_val = None
        self.channel_size_val = None
        self.k_extension_val = None
        self.m_extension_val = None
        self.k_start_val = None
        self.m_start_val = None
        self.stride_w_val = None
        self.stride_h_val = None
        self.filter_w_val = None
        self.filter_h_val = None
        self.dilation_filter_w_val = None
        self.dilation_filter_h_val = None
        self.pad_value_val = None

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        self._set_params_val(context)
        temp_env = TempEnv(is_aic_api=True)

        dst_align, src_align = load2d_3d_align_fn(self.obj.dst, self.obj.src)

        dst_scope = TikUtil.get_storage_scope(self.obj.dst.scope)

        # check channel size
        check_load3dv2_channel_size(self.channel_size_val, self.obj.src.dtype)

        xn_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.obj.src, src_align, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.obj.dst, dst_align, access_mode='w')

        # write fmatrix to spr
        model_with_env(context.model.write_spr, temp_env, 'FMATRIX', self.get_spr_fm())

        # write pad value to spr
        model_with_env(context.model.write_spr, temp_env, 'PADDING', self.get_spr_pad_value())

        # set l3d rpt in 610l soc, set dst stride
        if TikSocManager.is_610l_soc():
            model_with_env(context.model.write_spr, temp_env, 'L3D_RPT', self.get_spr_l3d_rpt_value())

        param = context.encoder.new_param()
        param.dstMemId = _LOAD3DV2_DST_ID.get(dst_scope)
        param.type = _LOAD3DV2_TYPE_ID.get(get_dtype_bit_width(self.obj.src.dtype))
        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = self.create_gpr_x_m(context, temp_env)
        param.xt = self.create_gpr_x_t(context, temp_env)

        # check dilation filter size and l1_h_w size
        check_dilation_filter_size(
            [self.filter_w_val, self.dilation_filter_w_val, self.l1_w_val,
             self.pad_list_val[PADDING_LEFT_IDX], self.pad_list_val[PADDING_RIGHT_IDX]], "W")
        check_dilation_filter_size(
            [self.filter_h_val, self.dilation_filter_h_val, self.l1_h_val,
             self.pad_list_val[PADDING_TOP_IDX], self.pad_list_val[PADDING_BOT_IDX]], "H")
        # check m_extension and k_extension
        check_load3dv2_m_extension(
            [self.filter_w_val, self.filter_h_val, self.dilation_filter_w_val, self.dilation_filter_h_val],
            [self.pad_list_val, self.m_extension_val, self.l1_w_val, self.l1_h_val,
             self.stride_w_val, self.stride_h_val, self.m_start_val])
        check_load3dv2_k_extension(
            [self.channel_size_val, self.k_extension_val,
             self.filter_h_val, self.filter_w_val, self.k_start_val], self.obj.src.dtype)

        instr = context.encoder.gen_dma_ld_3dv2(param)

        model_with_env(context.model.step, temp_env, instr)
        temp_env.check_mem_access(context.model, True)

        model_with_env(context.model.read_memory, temp_env, dst_addr, self.obj.dst.scope, dst_ptr, dst_alloc_size)

    def get_spr_fm(self):
        """
        get special purpose register fm

        Returns
        -------
        fmatrix : spr
        """
        pad_l, pad_r, pad_top, pad_bot = self.pad_list_val
        _check_pad_list(self.pad_list_val)

        TikCheckUtil.check_in_range_by_dtype(
            self.l1_w_val, msg="l1_w should be in the range of [%s, %s], input value is %s"
            % (MIN_TENSOR_WIDTH, MAX_TENSOR_WIDTH, str(self.l1_w_val)),
            var_range=[MIN_TENSOR_WIDTH, MAX_TENSOR_WIDTH])
        TikCheckUtil.check_in_range_by_dtype(
            self.l1_h_val, msg="l1_h should be in the range of [%s, %s], input value is %s"
            % (MIN_TENSOR_HEIGHT, MAX_TENSOR_HEIGHT, str(self.l1_h_val)),
            var_range=[MIN_TENSOR_HEIGHT, MAX_TENSOR_HEIGHT])

        fmatrix = self.l1_w_val
        fmatrix |= self.l1_h_val << _L1_H_SHIFT_BIT_POS
        fmatrix |= pad_l << _PAD_L_SHIFT_BIT_POS
        fmatrix |= pad_r << _PAD_R_SHIFT_BIT_POS
        fmatrix |= pad_top << _PAD_TOP_SHIFT_BIT_POS
        fmatrix |= pad_bot << _PAD_BOT_SHIFT_BIT_POS

        return fmatrix

    def get_spr_pad_value(self):
        """
        get special purpose register pad value

        Returns
        -------
        spr_pad_value : spr pad value
        """
        spr_pad_value = 0
        if self.obj.pad_value is not None:
            if self.obj.dst.dtype in ('float16', 'float32'):
                spr_pad_value = cvt_float_to_uint(self.obj.dst.dtype, self.pad_value_val)
            else:
                # padding spr of bit[15:8] must same with bit[7:0]
                # if pad value < 0, must trans to uint8, else will set padding failed
                np_b8_data = np.uint8(self.pad_value_val)
                spr_pad_value = np_b8_data << _PAD_VALUE_SHIFT_BIT_POS | np_b8_data
        return spr_pad_value

    def get_spr_l3d_rpt_value(self):
        l3d_rpt = 0  # Is the repeat stride, 0: means continuous
        l3d_rpt |= 1 << 16  # Is the repeat times in the M or K direction, 0: means no execution.
        l3d_rpt |= 0 << 24  # 0: repeat in the M direction, 1: repeat in the K direction
        # Is the dst stride of the output matrix in K in unit of fractals.
        l3d_rpt |= ceil_div(self.m_extension_val, 16) << 32
        l3d_rpt |= 0 << 48  # Is the destination start position of the output matrix in the M direction.
        return l3d_rpt

    def create_gpr_x_m(self, context, temp_env):
        """
        create general purpose register x_t

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        # check params
        _load3d_v2_params_check(self.k_extension_val, self.m_extension_val,
                                self.k_start_val, self.m_start_val, self.obj.src.dtype)

        xm_idx = temp_env.alloc_register()
        x_m = self.k_extension_val
        x_m |= self.m_extension_val << _M_EXTENSION_SHIFT_BIT_POS
        x_m |= self.k_start_val << _K_START_POINT_SHIFT_BIT_POS
        x_m |= self.m_start_val << _M_START_POINT_SHIFT_POS

        model_with_env(context.model.write_gpr, temp_env, xm_idx, x_m)

        return xm_idx

    def create_gpr_x_t(self, context, temp_env):
        """
        create general purpose register x_t

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xt_idx
        """
        # check params
        _load3d_col2img_param_check([self.stride_w_val, self.stride_h_val, self.filter_w_val, self.filter_h_val,
                                     self.dilation_filter_w_val, self.dilation_filter_h_val])

        xt_idx = temp_env.alloc_register()
        x_t = self.stride_w_val
        x_t |= self.stride_h_val << _STRIDE_H_SHIFT_BIT_POS
        x_t |= self.filter_w_val << _FILTER_W_SHIFT_BIT_POS
        x_t |= self.filter_h_val << _FILTER_H_SHIFT_BIT_POS
        x_t |= self.dilation_filter_w_val << _DILATION_W_SHIFT_BIT_POS
        x_t |= self.dilation_filter_h_val << _DILATION_H_SHIFT_BIT_POS
        if self.obj.en_transpose or self.obj.en_small_k:
            if TikSocManager.is_910b_soc() or TikSocManager.is_310b_610l_soc():
                x_t |= 1 << _EN_TRANSPOSE_SMALL_K_SHIFT_POS_V2
            else:
                x_t |= 1 << _EN_TRANSPOSE_SMALL_K_SHIFT_POS
        x_t |= self.channel_size_val << _CHANNEL_SIZE_SHIFT_BIT_POS

        model_with_env(context.model.write_gpr, temp_env, xt_idx, x_t)

        return xt_idx

    def _set_params_val(self, context):
        self.pad_list_val = [context.evaluate_expr(pad_v) for pad_v in self.obj.pad]
        self.l1_h_val = context.evaluate_expr(self.obj.l1_h)
        self.l1_w_val = context.evaluate_expr(self.obj.l1_w)
        self.channel_size_val = context.evaluate_expr(self.obj.channel_size)
        self.k_extension_val = context.evaluate_expr(self.obj.k_extension)
        self.m_extension_val = context.evaluate_expr(self.obj.m_extension)
        self.k_start_val = context.evaluate_expr(self.obj.k_start_pt)
        self.m_start_val = context.evaluate_expr(self.obj.m_start_pt)
        self.stride_w_val = context.evaluate_expr(self.obj.stride_w)
        self.stride_h_val = context.evaluate_expr(self.obj.stride_h)
        self.filter_w_val = context.evaluate_expr(self.obj.filter_w)
        self.filter_h_val = context.evaluate_expr(self.obj.filter_h)
        self.dilation_filter_w_val = context.evaluate_expr(self.obj.dilation_filter_w)
        self.dilation_filter_h_val = context.evaluate_expr(self.obj.dilation_filter_h)
        if self.obj.pad_value is not None:
            self.pad_value_val = context.evaluate_expr(self.obj.pad_value)


class Col2Img(STMT):
    """
    Col2Img instruction
    """

    def __init__(self, source_info, col2img_obj):
        super(Col2Img, self).__init__(source_info, col2img_obj.tik_instance.context.tik_debugger)
        self.dst = col2img_obj.dst
        self.src = col2img_obj.src
        self.pad = col2img_obj.pad
        self.l1_h = col2img_obj.l1_h
        self.l1_w = col2img_obj.l1_w
        self.fetch_filter_w = col2img_obj.fetch_filter_w
        self.fetch_filter_h = col2img_obj.fetch_filter_h
        self.left_top_w = col2img_obj.left_top_w
        self.left_top_h = col2img_obj.left_top_h
        self.stride_w = col2img_obj.stride_w
        self.stride_h = col2img_obj.stride_h
        self.filter_w = col2img_obj.filter_w
        self.filter_h = col2img_obj.filter_h
        self.dilation_filter_w = col2img_obj.dilation_filter_w
        self.dilation_filter_h = col2img_obj.dilation_filter_h
        self.repeat_time = col2img_obj.repeat_time

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        temp_env = TempEnv()

        xn_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.src, ALIGNED_ADDR, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.dst, ALIGNED_ADDR, access_mode='rw')

        self.set_spr_fcol2img(context)

        param = context.encoder.new_param()
        param.xd = xd_idx
        param.xn = xn_idx
        param.xm = self.create_gpr_x_m(context, temp_env)
        param.xt = self.create_gpr_x_t(context, temp_env)
        param.type = 1
        if self.dst.dtype == 'float32':
            param.type = 0

        instr = context.encoder.gen_dma_col2_img(param)

        context.model.step(instr)
        temp_env.check_mem_access(context.model, True)
        context.model.read_memory(dst_addr, self.dst.scope, dst_ptr,
                                  dst_alloc_size)

    def set_spr_fcol2img(self, context):
        """
        set special register fcol2img

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        padding = [context.evaluate_expr(pad) for pad in self.pad]
        pad_l, pad_r, pad_top, pad_bot = padding
        _check_pad_list(padding)
        l1_h = context.evaluate_expr(self.l1_h)
        l1_w = context.evaluate_expr(self.l1_w)

        fcol2img = l1_w
        fcol2img |= l1_h << _L1_H_SHIFT_BIT_POS
        fcol2img |= pad_l << _PAD_L_SHIFT_BIT_POS
        fcol2img |= pad_r << _PAD_R_SHIFT_BIT_POS
        fcol2img |= pad_top << _PAD_TOP_SHIFT_BIT_POS
        fcol2img |= pad_bot << _PAD_BOT_SHIFT_BIT_POS

        context.model.write_spr('FCOL2IMG', fcol2img)

    def create_gpr_x_m(self, context, temp_env):
        """
        create general purpose register x_m

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        fetch_w = context.evaluate_expr(self.fetch_filter_w)
        fetch_h = context.evaluate_expr(self.fetch_filter_h)
        left_top_w = context.evaluate_expr(self.left_top_w)
        left_top_h = context.evaluate_expr(self.left_top_h)
        _load3dv1_col2img_param_check(fetch_h, fetch_w, left_top_w, left_top_h)

        xm_idx = temp_env.alloc_register()
        x_m = 0
        x_m |= fetch_w << _FETCH_W_SHIFT_BIT_POS
        x_m |= fetch_h << _FETCH_H_SHIFT_BIT_POS
        x_m |= left_top_w << _LEFT_TOP_W_SHIFT_BIT_POS
        x_m |= left_top_h << _LEFT_TOP_H_SHIFT_BIT_POS

        context.model.write_gpr(xm_idx, x_m)

        return xm_idx

    def create_gpr_x_t(self, context, temp_env):
        """
        create general purpose register x_t

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xt_idx
        """
        stride_w = context.evaluate_expr(self.stride_w)
        stride_h = context.evaluate_expr(self.stride_h)
        filter_w = context.evaluate_expr(self.filter_w)
        filter_h = context.evaluate_expr(self.filter_h)
        dilation_filter_w = context.evaluate_expr(self.dilation_filter_w)
        dilation_filter_h = context.evaluate_expr(self.dilation_filter_h)
        repeats = context.evaluate_expr(self.repeat_time)
        # check repeat
        TikCheckUtil.check_in_range_by_dtype(
            repeats, msg="repeat_times should be in the range of [%s, %s], input value is %s"
            % (0, MAX_REPEAT_TIMES, str(repeats)), var_range=[0, MAX_REPEAT_TIMES])
        _load3d_col2img_param_check(
            [stride_w, stride_h, filter_w, filter_h, dilation_filter_w, dilation_filter_h])

        xt_idx = temp_env.alloc_register()
        x_t = stride_w
        x_t |= stride_h << _STRIDE_H_SHIFT_BIT_POS
        x_t |= filter_w << _FILTER_W_SHIFT_BIT_POS
        x_t |= filter_h << _FILTER_H_SHIFT_BIT_POS
        x_t |= dilation_filter_w << _DILATION_W_SHIFT_BIT_POS
        x_t |= dilation_filter_h << _DILATION_H_SHIFT_BIT_POS
        x_t |= 1 << _SHIFT_BIT_POS
        x_t |= repeats << REPEAT_SHIFT_POS

        context.model.write_gpr(xt_idx, x_t)

        return xt_idx
