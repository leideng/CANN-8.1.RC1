#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     load_image_intrinsic_.py
DESC:     load_image_intrinsic_
CREATED:  2021-11-20 9:46 AM
MODIFIED: 2021-11-20 9:46 AM
"""
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.util import check_scalar_dtype_float
from tbe.tik.common.common_util import check_dict_and_not_none
from tbe.tik.common.common_util import check_aipp_one_src_overflow
from tbe.tik.common.common_util import check_aipp_two_src_overflow
from tbe.tik.common.common_util import float16format2uint16
from tbe.tik.tik_lib.tik_params import BIT_16
from tbe.tik.tik_lib.tik_params import MIN_CSC_MATRIX
from tbe.tik.tik_lib.tik_params import MAX_CSC_MATRIX
from tbe.tik.tik_lib.tik_params import MAX_CSC_IN_BIAS
from tbe.tik.tik_lib.tik_params import MAX_CSC_OUT_BIAS
from tbe.tik.tik_lib.tik_params import MAX_PAD_MODE
from tbe.tik.tik_lib.tik_params import UINT_MIN
from tbe.tik.tik_lib.tik_params import UINT8_MAX
from tbe.tik.tik_lib.tik_params import INT8_MIN
from tbe.tik.tik_lib.tik_params import INT8_MAX
from tbe.tik.tik_lib.tik_params import MAX_CLIP_NUMBER
from tbe.tik.tik_lib.tik_params import MAX_BURST_LEN_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_expr import BasicExpr
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import is_610_610b_310p_aic
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import CROP_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import SWAP_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import CSC_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import DTC_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import YUYV
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AREA_PAD_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import CPAD_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import PRE_CLIP_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import SCF_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import SCF
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import POST_CLIP_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import FLIP_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import STRETCH
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW_BIT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import SWAP
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import YUV400
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import YUV420
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import YUV422
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW10
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW12
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW16
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RGB888
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AYUV444
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import ARGB8888
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import XRGB8888
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import NC1HWC0DI_INT8
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import NC1HWC0DI_FP16
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AIPP_INPUT_TYPE_SWAP_ALIGN
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import CSC
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AIPP_FORMAT_CONVERT
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import DTC
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import AERA_PADDING
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import PRE_CLIP
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import POST_CLIP
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import FLIP
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import RAW_TO_16_N
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import SCALE_COF
from tbe.tik.tik_lib.tik_data_move_api.tik_data_move_common import DEF_VALUE
from tbe.tik.tik_lib.tik_data_move_api.tik_load_image_check import check_crop_info_range

_PAD_VAL = 32
_SCF_START_SIZE = 16
_SH_SIZE_VAL = 1920
_SV_SIZE_VAL = 1080
_MAX_NUM_VAL = 1
_MAX_FLIP_MODE_VAL = 3
_MAX_CHANNEL_VAL = 3
_MAX_MODE_VAL = 1


def aipp_set_enable_bit(params_val):
    """
    set enable bit
    """
    function_switch = params_val.get('function_switch_val')
    params_val['crop_enable'] = function_switch & CROP_BIT
    params_val['swap_enable'] = (function_switch // SWAP_BIT) & 1
    params_val['csc_enable'] = (function_switch // CSC_BIT) & 1
    params_val['dtc_enable'] = (function_switch // DTC_BIT) & 1
    params_val['area_pad_enable'] = (function_switch // AREA_PAD_BIT) & 1
    params_val['channel_pad_enable'] = (function_switch // CPAD_BIT) & 1

    if TikSocManager.is_hisi_soc():
        params_val['pre_clip_enable'] = (function_switch // PRE_CLIP_BIT) & 1
        params_val['scf_enable'] = (function_switch // SCF_BIT) & 1
        params_val['post_clip_enable'] = (function_switch // POST_CLIP_BIT) & 1
        params_val['flip_enable'] = (function_switch // FLIP_BIT) & 1
        params_val['stretch_enable'] = (function_switch // STRETCH) & 1

    if is_610_610b_310p_aic():
        params_val['raw_enable'] = (function_switch // RAW_BIT) & 1


def check_src_info(params_val):
    """
    check src info
    """
    src_horizontal_size = params_val.get('src_horizontal_size_val')
    input_format = params_val.get('input_format_val', DEF_VALUE)
    src_vertical_size = params_val.get('src_vertical_size_val')
    horizontal_size_range = [8, 4096]
    TikCheckUtil.check_in_range_by_dtype(
        src_horizontal_size, msg="src_horizontal_size should in [%d, %d], input: %d"
        % (horizontal_size_range[0], horizontal_size_range[1], src_horizontal_size), var_range=horizontal_size_range)

    if input_format in [YUV420, YUYV, YUV422]:
        TikCheckUtil.check_equality(
            src_horizontal_size % 2, 0,
            'src_horizontal_size should be even, input: {}'.format(src_horizontal_size))

    if TikSocManager.is_hisi_soc():
        if input_format in [YUV420, YUV422, YUYV, YUV400, RAW10, RAW12, RAW16, RGB888]:
            TikCheckUtil.check_equality(
                src_horizontal_size % 16, 0,
                'src_horizontal_size should be 16*n, input: {}'.format(src_horizontal_size))
        elif input_format in [AYUV444, ARGB8888, XRGB8888]:
            TikCheckUtil.check_equality(
                src_horizontal_size % 4, 0,
                'src_horizontal_size should be 4*n, input: {}'.format(src_horizontal_size))

    TikCheckUtil.check_ge(src_vertical_size, 1, 'src_vertical_size should more than 0')


def _check_param_info(params_info):
    """
    check crop info
    """
    for key, value in params_info.items():
        TikCheckUtil.check_type_match(value, (int, BasicExpr),
                                      "%s should be int, Scalar, Expr, input type: %s" % (key, type(value)))
        check_scalar_dtype(value, "%s should be a scalar of int/uint" % key)


def _check_crop_info(params_val):
    """
    check crop info
    """
    dst_horizontal_size_val = params_val.get('dst_horizontal_size_val', DEF_VALUE)
    dst_vertical_size_val = params_val.get('dst_vertical_size_val', DEF_VALUE)
    crop_horizontal_start_val = params_val.get('crop_horizontal_start_val', DEF_VALUE)
    crop_vertical_start_val = params_val.get('crop_vertical_start_val', DEF_VALUE)
    single_line_enable_val = params_val.get('single_line_enable_val', DEF_VALUE)
    input_format_val = params_val.get('input_format_val', DEF_VALUE)
    src_horizontal_size_val = params_val.get('src_horizontal_size_val', DEF_VALUE)
    src_vertical_size_val = params_val.get('src_vertical_size_val', DEF_VALUE)

    if TikSocManager.is_hisi_soc() or TikSocManager.is_cloud_core() or TikSocManager.is_910b_soc():
        TikCheckUtil.check_equality(single_line_enable_val, 0, 'single_line_enable must be 0')
    else:
        TikCheckUtil.check_in_range_by_dtype(
            single_line_enable_val, msg='single_line_enable should in [0, 1], input: %s' % single_line_enable_val,
            var_range=[0, 1])
        if single_line_enable_val == 1:
            TikCheckUtil.check_equality(dst_vertical_size_val, 1, 'dst_vertical_size should be 1')

    check_crop_info_range('dst_horizontal_size', dst_horizontal_size_val, [YUV420, YUYV, YUV422],
                          (8, 4096), input_format_val)
    check_crop_info_range('crop_vertical_start', crop_vertical_start_val,
                          [YUV420, XRGB8888, NC1HWC0DI_INT8, NC1HWC0DI_FP16, RGB888, YUV400],
                          (0, 4095), input_format_val)
    if single_line_enable_val == 0:
        check_crop_info_range('dst_vertical_size', dst_vertical_size_val, [YUV420],
                              (8, 4096), input_format_val)
        check_crop_info_range('crop_horizontal_start', crop_horizontal_start_val,
                              [YUV420, YUYV, YUV422, XRGB8888, NC1HWC0DI_INT8, NC1HWC0DI_FP16, RGB888, YUV400],
                              (0, 4095), input_format_val)

    # range
    TikCheckUtil.check_in_range_by_dtype(
        crop_horizontal_start_val, msg='crop_horizontal_start should in src_horizontal_size, input: {}'.format(
            crop_horizontal_start_val), var_range=[0, src_horizontal_size_val])
    TikCheckUtil.check_in_range_by_dtype(
        crop_horizontal_start_val + dst_horizontal_size_val,
        msg='crop_horizontal_start + dst_horizontal_size should in src_horizontal_size, input: {}'.format(
            crop_horizontal_start_val + dst_horizontal_size_val), var_range=[0, src_horizontal_size_val])

    # range
    TikCheckUtil.check_in_range_by_dtype(
        crop_vertical_start_val, msg='crop_vertical_start should in src_vertical_size, input: {}'.format(
            crop_vertical_start_val), var_range=[0, src_vertical_size_val])
    TikCheckUtil.check_in_range_by_dtype(
        crop_vertical_start_val + dst_vertical_size_val,
        msg='crop_vertical_start + dst_vertical_size should in src_vertical_size, input: {}'.format(
            crop_vertical_start_val + dst_vertical_size_val), var_range=[0, src_vertical_size_val])


def cal_crop_info(crop_info, params_val, context):
    """
    crop info
    """
    if params_val.get('crop_enable') == 1:
        check_dict_and_not_none(crop_info, 'crop_info')
        dst_horizontal_size = crop_info.get('dst_horizontal_size')
        dst_vertical_size = crop_info.get('dst_vertical_size')
        crop_horizontal_start = crop_info.get('crop_horizontal_start')
        crop_vertical_start = crop_info.get('crop_vertical_start')
        single_line_enable = crop_info.get('single_line_enable')
        check_info = {
            'dst_horizontal_size': dst_horizontal_size,
            'dst_vertical_size': dst_vertical_size,
            'crop_horizontal_start': crop_horizontal_start,
            'crop_vertical_start': crop_vertical_start,
            'single_line_enable': single_line_enable
        }
        _check_param_info(check_info)

        params_val['dst_horizontal_size_val'] = context.evaluate_expr(dst_horizontal_size)
        params_val['dst_vertical_size_val'] = context.evaluate_expr(dst_vertical_size)
        params_val['crop_horizontal_start_val'] = context.evaluate_expr(crop_horizontal_start)
        params_val['crop_vertical_start_val'] = context.evaluate_expr(crop_vertical_start)
        params_val['single_line_enable_val'] = context.evaluate_expr(single_line_enable)

        if TikSocManager.is_mini_soc() or is_610_610b_310p_aic():
            if params_val.get('single_line_enable_val', DEF_VALUE) == 1:
                TikCheckUtil.check_equality(params_val.get('dst_vertical_size_val', DEF_VALUE),
                                            1, 'dst_vertical_size should be 1')
        _check_crop_info(params_val)
    else:
        params_val['dst_horizontal_size_val'] = params_val.get('src_horizontal_size_val', DEF_VALUE)
        params_val['dst_vertical_size_val'] = params_val.get('src_vertical_size_val', DEF_VALUE)


def _set_src_offset(src0, src1, params_val):
    if src0 is not None:
        params_val['src0_start'] = src0.offset
    if src1 is not None:
        params_val['src1_start'] = src1.offset
    else:
        params_val['src1_start'] = 0


def check_src_overflow(src0, src1, params_val):
    """
    check load_image debug src overflow
    """
    _set_src_offset(src0, src1, params_val)

    src0_start = params_val.get('src0_start', DEF_VALUE)
    src1_start = params_val.get('src1_start', DEF_VALUE)
    input_format_val = params_val.get('input_format_val', DEF_VALUE)
    src_horizontal_size_val = params_val.get('src_horizontal_size_val', DEF_VALUE)
    src_vertical_size_val = params_val.get('src_vertical_size_val', DEF_VALUE)

    if src1_start == 0:
        if input_format_val in [YUV420, YUV422]:
            params_val['src1_start'] = src0_start + src_horizontal_size_val * src_vertical_size_val
        elif input_format_val == NC1HWC0DI_INT8:
            params_val['src1_start'] = src0_start + src_horizontal_size_val * src_vertical_size_val * 4
        elif input_format_val == NC1HWC0DI_FP16:
            params_val['src1_start'] = src0_start + src_horizontal_size_val * src_vertical_size_val * 8

    if src1 is None:
        check_aipp_one_src_overflow(src0, input_format_val, src_horizontal_size_val, src_vertical_size_val)
    else:
        if input_format_val in [YUV420, NC1HWC0DI_INT8, NC1HWC0DI_FP16, YUV422]:
            check_aipp_two_src_overflow(src0, src1, input_format_val, src_horizontal_size_val, src_vertical_size_val)
        else:
            TikCheckUtil.check_equality(src1, None, "src1 should be None")


def cal_swap_info(context, functions, swap_list, params_val):
    """
    swap info
    """
    input_format_val = params_val.get('input_format_val', DEF_VALUE)
    if params_val.get('swap_enable') == 1:
        if SWAP not in functions:
            TikCheckUtil.raise_error('swap not support')

        _check_list_range(context, swap_list, (int, BasicExpr), None, 'swap_list')

        params_val['rb_swap_val'] = context.evaluate_expr(swap_list[0])
        params_val['uv_swap_val'] = context.evaluate_expr(swap_list[1])
        params_val['ax_swap_val'] = context.evaluate_expr(swap_list[2])

        rb_swap_val = params_val.get('rb_swap_val', DEF_VALUE)
        uv_swap_val = params_val.get('uv_swap_val', DEF_VALUE)
        ax_swap_val = params_val.get('ax_swap_val', DEF_VALUE)

        TikCheckUtil.check_var_in_list(rb_swap_val, AIPP_INPUT_TYPE_SWAP_ALIGN.get(
            input_format_val).get('swap')[0], 'swap rb out of range, input: {}'.format(rb_swap_val))
        TikCheckUtil.check_var_in_list(uv_swap_val, AIPP_INPUT_TYPE_SWAP_ALIGN.get(
            input_format_val).get('swap')[1], 'swap uv out of range, input: {}'.format(uv_swap_val))
        TikCheckUtil.check_var_in_list(ax_swap_val, AIPP_INPUT_TYPE_SWAP_ALIGN.get(
            input_format_val).get('swap')[2], 'swap ax out of range, input: {}'.format(ax_swap_val))


def _check_matrix_range(context, matrix, shape, in_type, input_range=None):
    """
    check matrix type and range
    """
    if matrix is None or shape is None:
        TikCheckUtil.raise_error("csc_matrix input error")

    # matrix
    if len(matrix) != shape[0] or len(matrix[0]) != shape[1]:
        TikCheckUtil.raise_error("csc_matrix shape error")

    for i in range(shape[0]):
        for j in range(shape[1]):
            TikCheckUtil.check_type_match(
                matrix[i][j], in_type,
                "csc_matrix type error, input: {}".format(matrix[i][j]))
            check_scalar_dtype(matrix[i][j],
                               "csc_matrix[{}][{}] should be a scalar of int/uint "
                               "".format(str(i), str(j)))
            one_matrix = context.evaluate_expr(matrix[i][j])
            if input_range:
                one_matrix_range = [input_range[0], input_range[1]]
                TikCheckUtil.check_in_range_by_dtype(
                    one_matrix, msg='csc_matrix out of range, input: {}'.format(one_matrix), var_range=one_matrix_range)


def _check_list_range(context, input_list, in_type, input_range=None, name=''):
    """
    check input type and range
    """
    one_input_range = []
    if input_list is None:
        TikCheckUtil.raise_error(name + " is None")

    if name == 'swap_list':
        TikCheckUtil.check_equality(len(input_list), 3, "swap_list length error, input: {}".format(len(input_list)))
    if input_range is not None:
        one_input_range = [input_range[0], input_range[1]]
    for idx, value in enumerate(input_list):
        if in_type is None:
            one_input = context.evaluate_expr(value)
            if input_range:
                TikCheckUtil.check_in_range_by_dtype(
                    one_input, msg=name + ' out of range, input: {}'.format(one_input), var_range=one_input_range)
            continue
        TikCheckUtil.check_type_match(
            value, in_type, "{}[{}] type error".format(name, str(idx)))
        one_input = context.evaluate_expr(value)
        if int in in_type:
            check_scalar_dtype(value, "{}[{}] should be a scalar of int/uint".format(name, str(idx)))
            if input_range:
                TikCheckUtil.check_in_range_by_dtype(
                    one_input, msg=name + ' out of range, input: {}'.format(one_input), var_range=one_input_range)
        elif float in in_type:
            check_scalar_dtype_float(value, "{}[{}] should be a scalar of float".format(name, str(idx)))


def _check_csc_format_convert(context, format_convert, csc_params, params_val):
    """
    check csc format convert
    """
    csc_matrix, csc_out_bias, csc_in_bias = csc_params
    TikCheckUtil.check_type_match(
        format_convert, (int,), "format_convert should be int, input: {}".format(type(format_convert)))

    params_val['format_convert_val'] = context.evaluate_expr(format_convert)
    format_convert_val = params_val.get('format_convert_val')

    if format_convert_val == 0:
        _check_matrix_range(context, csc_matrix, [3, 3], (int, BasicExpr), [MIN_CSC_MATRIX, MAX_CSC_MATRIX])
        _check_list_range(context, csc_in_bias, (int, BasicExpr), [0, MAX_CSC_IN_BIAS], 'csc_in_bias')
        _check_list_range(context, csc_out_bias, (int, BasicExpr), [0, MAX_CSC_OUT_BIAS], 'csc_out_bias')
    else:
        if TikSocManager.is_hisi_soc():
            # format_convert_list is CSC mode supported by the current SOC,
            # csc mode in data_move_common file's AIPP_FORMAT_CONVERT
            convert_val_range = [10, 17]
            TikCheckUtil.check_in_range_by_dtype(
                format_convert_val, msg='format_convert out of range, input: {}'.format(format_convert_val),
                var_range=convert_val_range)
        else:
            # format_convert_list is CSC mode supported by the current SOC,
            # csc mode in data_move_common file's AIPP_FORMAT_CONVERT
            format_convert_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 18]
            TikCheckUtil.check_var_in_list(
                format_convert, format_convert_list, msg='format_convert should in {} for arch_version not hs,'
                                                         ' input: {}'.format(format_convert_list, format_convert))


def cal_csc_info(context, functions, csc_info, params_val):
    """
    csc info
    """
    if params_val.get('csc_enable') == 1:
        if CSC not in functions:
            TikCheckUtil.raise_error('csc not support')

        check_dict_and_not_none(csc_info, 'csc_info')
        format_convert = csc_info.get('format_convert')
        csc_matrix = csc_info.get('csc_matrix')
        csc_out_bias = csc_info.get('csc_out_bias')
        csc_in_bias = csc_info.get('csc_in_bias')

        # check
        _check_csc_format_convert(context, format_convert, (csc_matrix, csc_out_bias, csc_in_bias), params_val)

        format_convert_val = params_val.get('format_convert_val', DEF_VALUE)
        if format_convert_val == 0:
            params_val['csc_matrix_r0_c0_val'] = context.evaluate_expr(csc_matrix[0][0])
            params_val['csc_matrix_r0_c1_val'] = context.evaluate_expr(csc_matrix[0][1])
            params_val['csc_matrix_r0_c2_val'] = context.evaluate_expr(csc_matrix[0][2])
            params_val['csc_matrix_r1_c0_val'] = context.evaluate_expr(csc_matrix[1][0])
            params_val['csc_matrix_r1_c1_val'] = context.evaluate_expr(csc_matrix[1][1])
            params_val['csc_matrix_r1_c2_val'] = context.evaluate_expr(csc_matrix[1][2])
            params_val['csc_matrix_r2_c0_val'] = context.evaluate_expr(csc_matrix[2][0])
            params_val['csc_matrix_r2_c1_val'] = context.evaluate_expr(csc_matrix[2][1])
            params_val['csc_matrix_r2_c2_val'] = context.evaluate_expr(csc_matrix[2][2])
            params_val['csc_out_bias_0_val'] = context.evaluate_expr(csc_out_bias[0])
            params_val['csc_out_bias_1_val'] = context.evaluate_expr(csc_out_bias[1])
            params_val['csc_out_bias_2_val'] = context.evaluate_expr(csc_out_bias[2])
            params_val['csc_in_bias_0_val'] = context.evaluate_expr(csc_in_bias[0])
            params_val['csc_in_bias_1_val'] = context.evaluate_expr(csc_in_bias[1])
            params_val['csc_in_bias_2_val'] = context.evaluate_expr(csc_in_bias[2])
        else:
            csc_matrix_param = AIPP_FORMAT_CONVERT.get(format_convert_val).get('csc_matrix')
            params_val['csc_matrix_r0_c0_val'] = csc_matrix_param[0][0]
            params_val['csc_matrix_r0_c1_val'] = csc_matrix_param[0][1]
            params_val['csc_matrix_r0_c2_val'] = csc_matrix_param[0][2]
            params_val['csc_matrix_r1_c0_val'] = csc_matrix_param[1][0]
            params_val['csc_matrix_r1_c1_val'] = csc_matrix_param[1][1]
            params_val['csc_matrix_r1_c2_val'] = csc_matrix_param[1][2]
            params_val['csc_matrix_r2_c0_val'] = csc_matrix_param[2][0]
            params_val['csc_matrix_r2_c1_val'] = csc_matrix_param[2][1]
            params_val['csc_matrix_r2_c2_val'] = csc_matrix_param[2][2]
            csc_out_bias_param = AIPP_FORMAT_CONVERT.get(format_convert_val).get('csc_out_bias')
            params_val['csc_out_bias_0_val'] = csc_out_bias_param[0]
            params_val['csc_out_bias_1_val'] = csc_out_bias_param[1]
            params_val['csc_out_bias_2_val'] = csc_out_bias_param[2]
            csc_in_bias_param = AIPP_FORMAT_CONVERT.get(format_convert_val).get('csc_in_bias')
            params_val['csc_in_bias_0_val'] = csc_in_bias_param[0]
            params_val['csc_in_bias_1_val'] = csc_in_bias_param[1]
            params_val['csc_in_bias_2_val'] = csc_in_bias_param[2]


def _cal_dtc_mean_by_type(context, dtc_mean, params_val):
    """
    calculate dtc mean
    """
    dtc_mean_type_val = params_val.get('dtc_mean_type_val', DEF_VALUE)

    if dtc_mean_type_val == 0:
        _check_list_range(context, dtc_mean, (int, BasicExpr), None, 'dtc_mean')
        dtc_pixel_mean_ch0 = context.evaluate_expr(dtc_mean[0])
        dtc_pixel_mean_ch1 = context.evaluate_expr(dtc_mean[1])
        dtc_pixel_mean_ch2 = context.evaluate_expr(dtc_mean[2])
        dtc_pixel_mean_ch3 = context.evaluate_expr(dtc_mean[3])
        params_val['sfr_dtc_pixel_mean_ch0_val'] = dtc_pixel_mean_ch0 // BIT_16
        params_val['sfr_dtc_pixel_mean_ch1_val'] = dtc_pixel_mean_ch1 // BIT_16
        params_val['sfr_dtc_pixel_mean_ch2_val'] = dtc_pixel_mean_ch2 // BIT_16
        params_val['sfr_dtc_pixel_mean_ch3_val'] = dtc_pixel_mean_ch3 // BIT_16
        params_val['dtc_pixel_mean_ch0_val'] = dtc_pixel_mean_ch0 % BIT_16
        params_val['dtc_pixel_mean_ch1_val'] = dtc_pixel_mean_ch1 % BIT_16
        params_val['dtc_pixel_mean_ch2_val'] = dtc_pixel_mean_ch2 % BIT_16
        params_val['dtc_pixel_mean_ch3_val'] = dtc_pixel_mean_ch3 % BIT_16
    else:
        _check_list_range(context, dtc_mean, (float, BasicExpr), None, 'dtc_mean')
        params_val['dtc_pixel_mean_ch0_val'] = float16format2uint16(context.evaluate_expr(dtc_mean[0]))
        params_val['dtc_pixel_mean_ch1_val'] = float16format2uint16(context.evaluate_expr(dtc_mean[1]))
        params_val['dtc_pixel_mean_ch2_val'] = float16format2uint16(context.evaluate_expr(dtc_mean[2]))
        params_val['dtc_pixel_mean_ch3_val'] = float16format2uint16(context.evaluate_expr(dtc_mean[3]))
        params_val['sfr_dtc_pixel_mean_ch0_val'] = 0
        params_val['sfr_dtc_pixel_mean_ch1_val'] = 0
        params_val['sfr_dtc_pixel_mean_ch2_val'] = 0
        params_val['sfr_dtc_pixel_mean_ch3_val'] = 0


def cal_dtc_info(context, functions, dtc_info, params_val):
    """
    dtc info
    """
    if params_val.get('dtc_enable') == 1:
        if DTC not in functions:
            TikCheckUtil.raise_error('dtc not support')

        check_dict_and_not_none(dtc_info, 'dtc_info')
        dtc_mean_type = dtc_info.get('dtc_mean_type')
        raw_to_f16_n = dtc_info.get('raw_to_f16_n')
        dtc_mean = dtc_info.get('dtc_mean')
        dtc_min = dtc_info.get('dtc_min')
        dtc_var = dtc_info.get('dtc_var')

        _check_param_info({'dtc_mean_type': dtc_mean_type})
        dtc_mean_type_val = context.evaluate_expr(dtc_mean_type)
        params_val['dtc_mean_type_val'] = dtc_mean_type_val
        dmt_val_range = [0, 1]
        TikCheckUtil.check_var_in_list(
            dtc_mean_type_val, dmt_val_range, 'dtc_mean_type value error, input: {}'.format(dtc_mean_type_val))

        _check_param_info({'raw_to_f16_n': raw_to_f16_n})
        raw_to_f16_n_val = context.evaluate_expr(raw_to_f16_n)
        params_val['raw_to_f16_n_val'] = raw_to_f16_n_val
        TikCheckUtil.check_var_in_list(raw_to_f16_n_val, RAW_TO_16_N,
                                       'raw_to_f16_n value error, input: {}'.format(raw_to_f16_n_val))

        _cal_dtc_mean_by_type(context, dtc_mean, params_val)

        _check_list_range(context, dtc_min, (float, BasicExpr), None, 'dtc_min')
        dtc_pixel_min_fp16 = [context.evaluate_expr(dtc_min[i]) for i in range(4)]

        params_val['dtc_pixel_min_ch0_val'] = float16format2uint16(dtc_pixel_min_fp16[0])
        params_val['dtc_pixel_min_ch1_val'] = float16format2uint16(dtc_pixel_min_fp16[1])
        params_val['dtc_pixel_min_ch2_val'] = float16format2uint16(dtc_pixel_min_fp16[2])
        params_val['dtc_pixel_min_ch3_val'] = float16format2uint16(dtc_pixel_min_fp16[3])

        _check_list_range(context, dtc_var, (float, BasicExpr), None, 'dtc_var')
        dtc_pixel_variance_fp16 = [context.evaluate_expr(dtc_var[i]) for i in range(4)]
        params_val['dtc_pixel_variance_ch0_val'] = float16format2uint16(dtc_pixel_variance_fp16[0])
        params_val['dtc_pixel_variance_ch1_val'] = float16format2uint16(dtc_pixel_variance_fp16[1])
        params_val['dtc_pixel_variance_ch2_val'] = float16format2uint16(dtc_pixel_variance_fp16[2])
        params_val['dtc_pixel_variance_ch3_val'] = float16format2uint16(dtc_pixel_variance_fp16[3])


def _check_area_pad_param_range(area_pad_mode_val, top_pad_rows_val, botton_pad_rows_val,
                                left_pad_cols_val, right_pad_cols_val):
    TikCheckUtil.check_in_range_by_dtype(area_pad_mode_val, msg='area_pad_mode value error, [{}, {}], input: {}'.format(
        0, MAX_PAD_MODE, area_pad_mode_val), var_range=[0, MAX_PAD_MODE])

    if TikSocManager.is_hisi_soc():
        TikCheckUtil.check_in_range_by_dtype(
            top_pad_rows_val, msg='top_pad_rows value error, [{}, {}], input: {}'.format(
                0, _PAD_VAL, top_pad_rows_val), var_range=[0, _PAD_VAL])
        TikCheckUtil.check_in_range_by_dtype(
            botton_pad_rows_val, msg='botton_pad_size value error, [{}, {}], input: {}'.format(
                0, _PAD_VAL, botton_pad_rows_val), var_range=[0, _PAD_VAL])
    elif area_pad_mode_val == 0:
        TikCheckUtil.check_equality(top_pad_rows_val, 0, 'top_pad_rows value should be 0')
        TikCheckUtil.check_equality(botton_pad_rows_val, 0, 'botton_pad_rows value should be 0')

    TikCheckUtil.check_in_range_by_dtype(
        left_pad_cols_val, msg='left_pad_cols value error, [{}, {}], input: {}'.format(
            0, _PAD_VAL, left_pad_cols_val), var_range=[0, _PAD_VAL])
    TikCheckUtil.check_in_range_by_dtype(
        right_pad_cols_val, msg='right_pad_cols value error, [{}, {}], input: {}'.format(
            0, _PAD_VAL, right_pad_cols_val), var_range=[0, _PAD_VAL])


def cal_area_pad_info(context, functions, area_pad_info, params_val):
    """
    area padding info
    """
    if params_val.get('area_pad_enable') == 1:
        if AERA_PADDING not in functions:
            TikCheckUtil.raise_error('area_pad not support')

        check_dict_and_not_none(area_pad_info, 'area_pad_info')
        area_pad_mode = area_pad_info.get('area_pad_mode')
        top_pad_rows = area_pad_info.get('top_pad_rows')
        botton_pad_rows = area_pad_info.get('botton_pad_rows')
        left_pad_cols = area_pad_info.get('left_pad_cols')
        right_pad_cols = area_pad_info.get('right_pad_cols')
        channel_pad_values = [area_pad_info.get('channel0_pad_value'), area_pad_info.get('channel1_pad_value'),
                              area_pad_info.get('channel2_pad_value'), area_pad_info.get('channel3_pad_value')]

        _check_param_info({'area_pad_mode': area_pad_mode,
                           'top_pad_rows': top_pad_rows, 'botton_pad_rows': botton_pad_rows,
                           'left_pad_cols': left_pad_cols, 'right_pad_cols': right_pad_cols})

        pad_rows_clos_val = [context.evaluate_expr(area_pad_mode),
                             context.evaluate_expr(top_pad_rows), context.evaluate_expr(botton_pad_rows),
                             context.evaluate_expr(left_pad_cols), context.evaluate_expr(right_pad_cols)]

        if params_val.get('dst_type') == 'float16':
            _check_list_range(context, channel_pad_values, (float, BasicExpr), None, 'filling_hblank')
            filling_hblank_ch_list = \
                [float16format2uint16(context.evaluate_expr(channel_pad_values[i])) for i in range(4)]
        else:
            _check_list_range(context, channel_pad_values, (int, BasicExpr), None, 'filling_hblank')
            filling_hblank_ch_list = [context.evaluate_expr(channel_pad_values[i]) for i in range(4)]

            if params_val.get('dst_type') == 'int8':
                _check_list_range(
                    context, filling_hblank_ch_list, None, (INT8_MIN, INT8_MAX), 'filling_hblank')
            else:
                _check_list_range(
                    context, filling_hblank_ch_list, None, (UINT_MIN, UINT8_MAX), 'filling_hblank')

        _check_area_pad_param_range(*pad_rows_clos_val)

        params_val['area_pad_mode_val'] = pad_rows_clos_val[0]
        params_val['top_pad_rows_val'] = pad_rows_clos_val[1]
        params_val['botton_pad_rows_val'] = pad_rows_clos_val[2]
        params_val['left_pad_cols_val'] = pad_rows_clos_val[3]
        params_val['right_pad_cols_val'] = pad_rows_clos_val[4]
        params_val['filling_hblank_ch0_val'] = filling_hblank_ch_list[0]
        params_val['filling_hblank_ch1_val'] = filling_hblank_ch_list[1]
        params_val['filling_hblank_ch2_val'] = filling_hblank_ch_list[2]
        params_val['filling_hblank_ch3_val'] = filling_hblank_ch_list[3]


def cal_cpad_info(context, channel_pad_info, params_val):
    """
    cpadding info
    """
    if params_val.get('channel_pad_enable') == 1:
        check_dict_and_not_none(channel_pad_info, 'channel_pad_info')
        channel_pad_mode = channel_pad_info.get('channel_pad_mode')
        channel_pad_value = channel_pad_info.get('channel_pad_value')

        _check_param_info({"channel_pad_mode": channel_pad_mode})

        channel_pad_mode_val = context.evaluate_expr(channel_pad_mode)
        _max_channel_pad_mode = 2
        TikCheckUtil.check_in_range_by_dtype(
            channel_pad_mode_val, msg='channel_pad_mode value error, [{}, {}], input: {}'.format(
                0, _max_channel_pad_mode, channel_pad_mode_val), var_range=[0, _max_channel_pad_mode])

        params_val['channel_pad_mode_val'] = channel_pad_mode_val
        params_val['no_padding_val'] = channel_pad_mode_val % 2
        params_val['padd_4channels_val'] = channel_pad_mode_val // 2

        if channel_pad_mode_val == 1:
            TikCheckUtil.check_equality(
                TikSocManager.is_hisi_soc(), True,
                'only v200hisi support no padding, now: {}'.format(params_val.get('arch_version')))

        if params_val.get('dst_type') == 'float16':
            TikCheckUtil.check_type_match(
                channel_pad_value, (float, BasicExpr),
                "channel_pad_value type error, input: {}".format(type(channel_pad_value)))
            check_scalar_dtype_float(channel_pad_value, "channel_pad_value should be a scalar of float")
            cpadding_spr = float16format2uint16(context.evaluate_expr(channel_pad_value))
        else:
            TikCheckUtil.check_type_match(
                channel_pad_value, (int, BasicExpr),
                "channel_pad_value type error, input: {}".format(type(channel_pad_value)))
            check_scalar_dtype(channel_pad_value, "channel_pad_value should be a scalar of int/uint")
            cpadding_spr = context.evaluate_expr(channel_pad_value)

            if params_val.get('dst_type') == 'uint8':
                TikCheckUtil.check_in_range_by_dtype(
                    cpadding_spr, "uint8", 'channel_pad_value out of range, [{}, {}], input: {}'.format(
                        UINT_MIN, UINT8_MAX, cpadding_spr))
            else:
                TikCheckUtil.check_in_range_by_dtype(
                    cpadding_spr, "int8", 'channel_pad_value out of range, [{}, {}], input: {}'.format(
                        INT8_MIN, INT8_MAX, cpadding_spr))
        params_val['cpadding_spr_val'] = cpadding_spr


def cal_pre_clip_info(context, functions, pre_clip_info, params_val):
    """
    pre_clip info operation
    """
    if params_val.get('pre_clip_enable') == 1:
        if PRE_CLIP not in functions:
            TikCheckUtil.raise_error('pre_clip not support')

        check_dict_and_not_none(pre_clip_info, 'pre_clip_info')
        pre_top_clip_number = pre_clip_info.get('pre_top_clip_number')
        pre_botton_clip_number = pre_clip_info.get('pre_botton_clip_number')

        _check_param_info({'pre_top_clip_number': pre_top_clip_number,
                           'pre_botton_clip_number': pre_botton_clip_number})

        pre_botton_clip_number_val = context.evaluate_expr(pre_botton_clip_number)
        pre_top_clip_number_val = context.evaluate_expr(pre_top_clip_number)
        params_val['pre_botton_clip_number_val'] = pre_botton_clip_number_val
        params_val['pre_top_clip_number_val'] = pre_top_clip_number_val

        dst_vertical_size_val = params_val.get('dst_vertical_size_val', DEF_VALUE)
        TikCheckUtil.check_in_range_by_dtype(
            pre_botton_clip_number_val, msg="pre_botton_clip_number out of range, [{}, {}], "
            "input: {}".format(0, _MAX_NUM_VAL, pre_botton_clip_number_val), var_range=[0, _MAX_NUM_VAL])
        TikCheckUtil.check_in_range_by_dtype(
            pre_top_clip_number_val, msg="pre_top_clip_number out of range, [{}, {}], "
            "input: {}".format(0, _MAX_NUM_VAL, pre_top_clip_number_val), var_range=[0, _MAX_NUM_VAL])
        TikCheckUtil.check_ge(
            dst_vertical_size_val, pre_top_clip_number_val + pre_botton_clip_number_val + 1,
            'pre_botton_clip_number + pre_top_clip_number bigger than vertical_size,'
            ' input: {}'.format(dst_vertical_size_val))


def _get_scf_info_val(scf_info, context):
    check_dict_and_not_none(scf_info, 'scf_info')
    scf_horizontal_size = scf_info.get('scf_horizontal_size')
    scf_vertical_size = scf_info.get('scf_vertical_size')
    scf_horizontal_start = scf_info.get('scf_horizontal_start')
    scf_vertical_start = scf_info.get('scf_vertical_start')
    scaling_mode = scf_info.get('scaling_mode')
    check_info = {
        'scf_horizontal_size': scf_horizontal_size, 'scf_vertical_size': scf_vertical_size,
        'scf_horizontal_start': scf_horizontal_start, 'scf_vertical_start': scf_vertical_start,
        'scaling_mode': scaling_mode,
    }
    _check_param_info(check_info)

    scf_horizontal_start_val = context.evaluate_expr(scf_horizontal_start)
    scf_vertical_start_val = context.evaluate_expr(scf_vertical_start)
    scf_horizontal_size_val = context.evaluate_expr(scf_horizontal_size)
    scf_vertical_size_val = context.evaluate_expr(scf_vertical_size)
    scaling_mode_val = context.evaluate_expr(scaling_mode)
    return [scf_horizontal_start_val, scf_vertical_start_val, scf_horizontal_size_val,
            scf_vertical_size_val, scaling_mode_val]


def cal_scf_info(context, functions, scf_info, params_val):
    """
    scf info operation
    """
    scf_vertical_start_def = params_val.get('dst_vertical_size_val', DEF_VALUE) - \
                             params_val.get('pre_botton_clip_number_val', DEF_VALUE) - \
                             params_val.get('pre_top_clip_number_val', DEF_VALUE)
    scf_horizontal_start_def = params_val.get('dst_horizontal_size_val', DEF_VALUE)
    if params_val.get('scf_enable') == 1:
        if SCF not in functions:
            TikCheckUtil.raise_error('scf not support')

        scf_horizontal_start_val, scf_vertical_start_val, scf_horizontal_size_val, \
        scf_vertical_size_val, scaling_mode_val = _get_scf_info_val(scf_info, context)
        TikCheckUtil.check_in_range_by_dtype(
            scf_horizontal_size_val, msg='scf_horizontal_size out of range, input: {}'.format(scf_horizontal_size_val),
            var_range=[_SCF_START_SIZE, _SH_SIZE_VAL])
        TikCheckUtil.check_in_range_by_dtype(
            scf_vertical_size_val, msg='scf_vertical_size out of range, input: {}'.format(scf_vertical_size_val),
            var_range=[_SCF_START_SIZE, _SV_SIZE_VAL])
        TikCheckUtil.check_var_in_list(
            scaling_mode_val, [0, _MAX_MODE_VAL], "scaling_mode out of range, [{}, {}], "
            "input: {}".format(0, _MAX_MODE_VAL, scaling_mode_val))
        params_val['scaling_mode_val'] = scaling_mode_val
        params_val['spr_scf_vertical_size_val'] = scf_vertical_size_val - 1
        params_val['spr_scf_horizontal_size_val'] = scf_horizontal_size_val - 1
        # spr 12
        if scf_horizontal_size_val > scf_horizontal_start_def:
            filter_order = 1
        else:
            filter_order = 0
        params_val['filter_order_val'] = filter_order

        # spr 14
        cal_hori_scaling = ((scf_horizontal_start_def - 1) * SCALE_COF // (scf_horizontal_size_val - 1)) // 4 * 4
        cal_vert_scaling = (scf_vertical_start_def - 1) * SCALE_COF // (scf_vertical_size_val - 1) // 4 * 4

        params_val['hori_scaling_val'] = context.evaluate_expr(scf_info.get('scf_horizontal_scale', cal_hori_scaling))
        params_val['vert_scaling_val'] = context.evaluate_expr(scf_info.get('scf_vertical_scale', cal_vert_scaling))
        params_val['init_vert_val'] = scf_vertical_start_val
        params_val['init_hori_val'] = scf_horizontal_start_val
    else:
        params_val['spr_scf_vertical_size_val'] = scf_vertical_start_def - 1
        params_val['spr_scf_horizontal_size_val'] = scf_horizontal_start_def - 1


def cal_post_clip_info(context, functions, post_clip_info, params_val):
    """
    post clip info
    """
    if params_val.get('post_clip_enable') == 1:
        if POST_CLIP not in functions:
            TikCheckUtil.raise_error('post clip not support')

        check_dict_and_not_none(post_clip_info, 'post_clip_info')
        post_botton_clip_number = post_clip_info.get('post_botton_clip_number')
        post_top_clip_number = post_clip_info.get('post_top_clip_number')
        post_right_clip_number = post_clip_info.get('post_right_clip_number')
        post_left_clip_number = post_clip_info.get('post_left_clip_number')

        check_info = {
            'post_botton_clip_number': post_botton_clip_number,
            'post_top_clip_number': post_top_clip_number,
            'post_right_clip_number': post_right_clip_number,
            'post_left_clip_number': post_left_clip_number
        }
        _check_param_info(check_info)

        post_botton_clip_number_val = context.evaluate_expr(post_botton_clip_number)
        post_top_clip_number_val = context.evaluate_expr(post_top_clip_number)
        post_right_clip_number_val = context.evaluate_expr(post_right_clip_number)
        post_left_clip_number_val = context.evaluate_expr(post_left_clip_number)

        params_val['post_botton_clip_number_val'] = post_botton_clip_number_val
        params_val['post_top_clip_number_val'] = post_top_clip_number_val
        params_val['post_right_clip_number_val'] = post_right_clip_number_val
        params_val['post_left_clip_number_val'] = post_left_clip_number_val

        TikCheckUtil.check_in_range_by_dtype(
            post_botton_clip_number_val, msg="post_botton_clip_number out of range, [{}, {}], input: {}".format(
                0, MAX_CLIP_NUMBER, post_botton_clip_number_val), var_range=[0, MAX_CLIP_NUMBER])
        TikCheckUtil.check_in_range_by_dtype(
            post_top_clip_number_val, msg="post_top_clip_number out of range, [{}, {}], input: {}".format(
                0, MAX_CLIP_NUMBER, post_top_clip_number_val), var_range=[0, MAX_CLIP_NUMBER])
        TikCheckUtil.check_in_range_by_dtype(
            post_right_clip_number_val, msg="post_right_clip_number out of range, [{}, {}], input: {}".format(
                0, MAX_CLIP_NUMBER, post_right_clip_number_val), var_range=[0, MAX_CLIP_NUMBER])
        TikCheckUtil.check_in_range_by_dtype(
            post_left_clip_number_val, msg="post_left_clip_number out of range, [{}, {}], input: {}".format(
                0, MAX_CLIP_NUMBER, post_left_clip_number_val), var_range=[0, MAX_CLIP_NUMBER])


def cal_stretch_info(context, functions, stretch_info, params_val):
    """
    stretch info
    """
    if params_val.get('stretch_enable') == 1:
        if STRETCH not in functions:
            TikCheckUtil.raise_error('stretch not support')
        check_dict_and_not_none(stretch_info, 'stretch_info')
        dst_stride_pixel = stretch_info.get('dst_stride_pixel')

        _check_param_info({'dst_stride_pixel': dst_stride_pixel})

        dst_stride_pixel_val = context.evaluate_expr(dst_stride_pixel)
        params_val['dst_stride_pixel_val'] = dst_stride_pixel_val
        TikCheckUtil.check_in_range_by_dtype(
            dst_stride_pixel_val, msg="dst_stride_pixel out of range, input: {}".format(dst_stride_pixel_val),
            var_range=[0, MAX_BURST_LEN_DOUBLE_BYTE])


def cal_flip_info(context, functions, flip_mode, params_val):
    """
    flip info
    """
    if params_val.get('flip_enable') == 1:
        if FLIP not in functions:
            TikCheckUtil.raise_error('flip not support')
        _check_param_info({'flip_mode': flip_mode})
        flip_mode_val = context.evaluate_expr(flip_mode)
        TikCheckUtil.check_in_range_by_dtype(
            flip_mode_val, msg="flip_mode value out of range, input: {}".format(flip_mode_val),
            var_range=[0, _MAX_FLIP_MODE_VAL])
        params_val['horizontal_flip_enable_val'] = flip_mode_val % 2
        params_val['vertical_flip_enable_val'] = flip_mode_val // 2


def cal_raw_info(context, functions, raw_info, params_val):
    """
    raw info
    """
    if params_val.get('raw_enable') == 1:
        if RAW not in functions:
            TikCheckUtil.raise_error('raw not support')
        check_dict_and_not_none(raw_info, 'raw_info')
        raw_start_channel = raw_info.get('raw_start_channel')
        raw_image_channel = raw_info.get('raw_image_channel')

        check_info = {
            'raw_start_channel': raw_start_channel,
            'raw_image_channel': raw_image_channel
        }
        _check_param_info(check_info)

        raw_image_channel_val = context.evaluate_expr(raw_image_channel)
        start_channel_number_val = context.evaluate_expr(raw_start_channel)
        TikCheckUtil.check_in_range_by_dtype(
            raw_image_channel_val, msg='raw_image_channel value error, [{}, {}], input: {}'.format(
                0, _MAX_CHANNEL_VAL, raw_image_channel_val), var_range=[0, _MAX_CHANNEL_VAL])
        TikCheckUtil.check_in_range_by_dtype(
            start_channel_number_val, msg='raw_start_channel value error, [{}, {}], input: {}'.format(
                0, _MAX_CHANNEL_VAL, start_channel_number_val), var_range=[0, _MAX_CHANNEL_VAL])

        params_val['raw_image_channel_val'] = raw_image_channel_val
        params_val['start_channel_number_val'] = start_channel_number_val
