#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     object_detect.py
DESC:     debug object detect
CREATED:  2019-7-04 20:12:13
MODIFIED: 2020-12-7 19:17:00
"""
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.util import copy_tensor_to_model
from tbe.tik.debug.util import VEC_DATA_TYPE_ENCODING
from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.debug.sim.instr_encoder import Encoder
from tbe.tik.debug.debug_encoder import VEC_DATA_TYPE_ENCODING_FP
from tbe.tik.common import DTYPE_SIZE
from tbe.tik.common.common_check_func import check_overlapping_vsort32
from tbe.tik.common.common_check_func import check_overlapping_vmrgsort4
from tbe.tik.common.common_check_func import check_overlapping_vmrgsort
from tbe.tik.common.common_check_func import check_vms4v2_repeat_times
from tbe.tik.common.common_check_func import check_vms4_repeat_times
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_params import ADDR_BIT_LEN
from tbe.tik.tik_lib.tik_params import MIN_MODE_NUMBER
from tbe.tik.tik_lib.tik_params import EXHAUSTED_SUSPENSION_POS
from tbe.tik.tik_lib.tik_params import SRC_LIST_BIT_POS
from tbe.tik.tik_lib.tik_params import LENGTH_BIT_LEN
from tbe.tik.tik_lib.tik_params import ALIGNED_ADDR
from tbe.tik.tik_lib.tik_params import LENGTH_BIAS
from tbe.tik.tik_lib.tik_params import REPEAT_SHIFT_POS
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_TIMES
from tbe.tik.tik_lib.tik_params import MAX_MODE_NUMBER_VEXTRACT_V100
from tbe.tik.tik_lib.tik_params import VALID_BIT_TUPLE
from tbe.tik.tik_lib.tik_params import VALID_BIT_TUPLE_V200
from tbe.tik.tik_lib.tik_params import MAX_REP_STRIDE_DOUBLE_BYTE
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_13
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_16
from tbe.tik.tik_lib.tik_params import MAX_ELEMENTS_LEN_V2
from tbe.tik.tik_lib.tik_params import EXHAUSTED_SUSPENSION_POS_V2
from tbe.tik.tik_lib.tik_params import SRC_LIST_BIT_POS_V2
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil

_ENCODER = Encoder()

_XN_STRIDE_SHIFT_BIT_POS = 16
_XM_STRIDE_SHIFT_BIT_POS = 32


class VMS4(STMT):
    """
    VMS4 instruction
    """
    value = 2 ** 13 - 1

    def __init__(self, source_info, op_obj, tik_debugger=None):
        super(VMS4, self).__init__(source_info, tik_debugger)
        self.dst = op_obj.dst
        self.src_list = op_obj.src_list
        self.element_lengths = op_obj.element_count_list
        self.exhausted_suspension = op_obj.if_exhausted_suspension
        self.valid_bit = op_obj.valid_bit
        self.repeat_times = op_obj.repeat_times
        self.scalar_list = op_obj.vms4_sr_scalar_array

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        TikCheckUtil.check_var_in_list(self.dst.dtype, ['float16', 'float32'])
        if not isinstance(self.element_lengths, (tuple, list)):
            self.element_lengths = [self.element_lengths] * 4
        TikCheckUtil.check_equality(
            len(self.src_list), len(self.element_lengths))

        # check repeat_times
        element_lengths = [context.evaluate_expr(value) for value in self.element_lengths]
        if isinstance(self.valid_bit, str):
            # binary dtype -> int dtype
            self.valid_bit = int(self.valid_bit, 2)

        valid_bit = context.evaluate_expr(self.valid_bit)
        repeat_times = context.evaluate_expr(self.repeat_times)
        check_vms4_repeat_times(repeat_times, element_lengths, valid_bit,
                                self.exhausted_suspension)

        for i in range(len(self.src_list)):
            if self.dst.buffer is self.src_list[i].buffer and (valid_bit & (1 << i)):
                check_overlapping_vmrgsort4(context.evaluate_expr(self.dst.offset),
                                            context.evaluate_expr(self.src_list[i].offset),
                                            element_lengths, repeat_times, i)

        temp_env = TempEnv()

        param, dst_addr, dst_ptr, dst_alloc_size = self.get_param(context, temp_env)

        instr = _ENCODER.gen_vms4(param)

        context.model.step(instr)

        temp_env.check_mem_access(context.model, True, src_tensor_nums=len(self.src_list))
        context.model.read_memory(
            dst_addr, self.dst.scope, dst_ptr, dst_alloc_size)
        if self.scalar_list is not None:
            sr_value = context.model.read_spr('VMS4_SR')
            # vms4 bit shift
            for i, scalar in enumerate(self.scalar_list):
                offset = context.evaluate_expr(scalar.offset)
                context.update_var(scalar.debug_var[offset], (sr_value >> (i * SHIFT_BIT_POS_13)) & VMS4.value)

    def get_param(self, context, temp_env):
        """
        get the gen_param and buffer information

        Parameters
        ----------
        context : the stack context
        temp_env : the temp environment

        Returns
        -------
        param : gen_param
        dst_addr, dst_ptr, dst_alloc_size : info of buffer
        """
        align = 16
        if self.dst.dtype == 'float16':
            proposal_size = 16
        else:
            proposal_size = 32
            align = 32
        xn_idx, xt_idx = self.set_register(context,
                                           temp_env, align, proposal_size)
        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.dst, align, access_mode='w')
        param = _ENCODER.new_param()
        param.type = VEC_DATA_TYPE_ENCODING[self.dst.dtype]
        param.xd = xd_idx
        param.xn = xn_idx
        param.xt = xt_idx

        return [param, dst_addr, dst_ptr, dst_alloc_size]

    def set_register(self, context, temp_env, align, proposal_size):
        """
        set register and get xn_idx and xt_idx

        Parameters
        ----------
        context : the stack context
        temp_env : the temp environment
        align : align addr
        proposal_size : dst's dtpe size, 16 or 32

        Returns
        -------
        xn_idx : the result code
        xt_idx : the result code
        """
        xn_idx = temp_env.alloc_register()
        x_n = 0

        # check repeat_times
        TikCheckUtil.check_in_range_by_dtype(
            context.evaluate_expr(
                self.repeat_times), msg="repeat_times should be in the range of [%d, %d], input value is %s" % (
                0, MAX_REPEAT_TIMES, str(context.evaluate_expr(self.repeat_times))), var_range=[0, MAX_REPEAT_TIMES])

        # check valid_bit
        if TikSocManager.is_v100_soc():
            TikCheckUtil.check_var_in_list(
                context.evaluate_expr(self.valid_bit), VALID_BIT_TUPLE,
                "valid bits only support 1111, 0111 or 0011 // binary, "
                "input valid bits: %s // "
                "decimal" % context.evaluate_expr(self.valid_bit))
        else:
            TikCheckUtil.check_var_in_list(
                context.evaluate_expr(self.valid_bit), VALID_BIT_TUPLE_V200,
                "valid bits only support 1111, 0111, 0011 or 0001 // binary, "
                "input valid_bit: %s // "
                "decimal" % context.evaluate_expr(self.valid_bit))

        xt_idx = temp_env.alloc_register()
        x_t = context.evaluate_expr(self.repeat_times)

        for i, src in enumerate(self.src_list):
            # this will waste some gpr, but don't worry
            copy_tensor_to_model(context, temp_env, src, align, access_mode='r')
            src_addr = temp_env.get_tensor_addr(
                context, src, access_mode='r') // proposal_size
            x_n |= src_addr << (i * ADDR_BIT_LEN)
            length = self.element_lengths[i]
            length = context.evaluate_expr(length)
            x_t |= length << (i * LENGTH_BIT_LEN + LENGTH_BIAS)
        context.model.write_gpr(xn_idx, x_n)
        x_t |= self.exhausted_suspension << EXHAUSTED_SUSPENSION_POS
        x_t |= context.evaluate_expr(self.valid_bit) << SRC_LIST_BIT_POS
        context.model.write_gpr(xt_idx, x_t)

        return xn_idx, xt_idx


class VEXTRACT(STMT):
    """
    Vector Region Proposal Coordination Extraction
    """

    def __init__(self, source_info, op_obj, tik_debugger):
        super(VEXTRACT, self).__init__(source_info, tik_debugger)
        self.dst = op_obj.dst
        self.src = op_obj.src
        self.repeat_times = op_obj.repeat_times
        self.mode = op_obj.mode_number

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        TikCheckUtil.check_equality(self.src.dtype, self.dst.dtype)
        TikCheckUtil.check_var_in_list(self.src.dtype, ['float16', 'float32'])
        temp_env = TempEnv()

        xn_idx, _, src_alloc_size, _ = copy_tensor_to_model(
            context, temp_env, self.src, ALIGNED_ADDR, access_mode='r')
        # check src overflow
        src_expected_ele = context.evaluate_expr(self.repeat_times * 16 * 8 + self.src.offset)

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.dst, ALIGNED_ADDR, access_mode='w')

        param = _ENCODER.new_param()
        param.type = VEC_DATA_TYPE_ENCODING[self.src.dtype]
        param.xn = xn_idx
        param.xd = xd_idx
        param.xt = self.create_gpr_x_t(context, temp_env)
        TikCheckUtil.check_ge(
            src_alloc_size // DTYPE_SIZE[self.src.dtype], src_expected_ele,
            "src tensor overflow, expected src shape: {src_shape}, actual src "
            "shape: {shape}".format(src_shape=src_expected_ele,
                                    shape=src_alloc_size // DTYPE_SIZE[self.src.dtype]))
        context.model.step(_ENCODER.gen_vextract(param))
        temp_env.check_mem_access(context.model, True)
        context.model.read_memory(
            dst_addr, self.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_t(self, context, temp_env):
        """
        create general purpose register x_t

        Parameters
        ----------
        context : the stack context
        temp_env : the temp environment

        Returns
        -------
        xt_idx
        """
        repeat_time = context.evaluate_expr(self.repeat_times)
        mode = context.evaluate_expr(self.mode)
        # check repeat_time and mode
        TikCheckUtil.check_in_range_by_dtype(
            repeat_time, msg="repeat_times should be in the range of [%d, %d],"
            " input value is %s" % (0, MAX_REPEAT_TIMES, str(repeat_time)), var_range=[0, MAX_REPEAT_TIMES])
        if TikSocManager.is_mini_soc():
            TikCheckUtil.check_in_range_by_dtype(
                mode, msg="mode_number should be in the range of [%d, %d],"
                " input value is %s" % (MIN_MODE_NUMBER, MAX_MODE_NUMBER_VEXTRACT_V100, str(mode)),
                var_range=[MIN_MODE_NUMBER, MAX_MODE_NUMBER_VEXTRACT_V100])
        else:
            _max_mode = 5
            TikCheckUtil.check_in_range_by_dtype(
                mode, msg="mode_number should be in the range of [%d, %d],"
                " input value is %s" % (MIN_MODE_NUMBER, _max_mode, str(mode)), var_range=[MIN_MODE_NUMBER, _max_mode])

        mode_bit_pos = 16

        xt_idx = temp_env.alloc_register()
        x_t = 0
        x_t |= repeat_time << REPEAT_SHIFT_POS
        x_t |= mode << mode_bit_pos

        context.model.write_gpr(xt_idx, x_t)
        return xt_idx


class VCONCAT(STMT):
    """
    Vector Region Proposal Coordination Concatenation
    """

    def __init__(self, source_info, vconcat_obj, tik_debugger):
        super(VCONCAT, self).__init__(source_info, tik_debugger)
        self.dst = vconcat_obj.dst
        self.src = vconcat_obj.src
        self.repeat_times = vconcat_obj.repeat_times
        self.mode = vconcat_obj.mode_number

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        TikCheckUtil.check_equality(self.src.dtype, self.dst.dtype)
        TikCheckUtil.check_var_in_list(self.src.dtype, ['float16', 'float32'])
        temp_env = TempEnv()
        xn_idx, _, src_alloc_size, _ = copy_tensor_to_model(context, temp_env, self.src, ALIGNED_ADDR, access_mode='r')

        self._check_src_overflow(src_alloc_size, context)

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.dst, ALIGNED_ADDR, access_mode='rw')

        param = _ENCODER.new_param()
        param.type = VEC_DATA_TYPE_ENCODING[self.src.dtype]
        param.xd = xd_idx
        param.xn = xn_idx
        param.xt = self.create_gpr_x_t(context, temp_env)

        context.model.step(_ENCODER.gen_vconcat(param))
        temp_env.check_mem_access(context.model)
        context.model.read_memory(
            dst_addr, self.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_t(self, context, temp_env):
        """
        create general purpose register x_t

        Parameters
        ----------
        context : the stack context
        temp_env : the temp environment

        Returns
        -------
        xt_idx
        """
        repeat_time = context.evaluate_expr(self.repeat_times)
        TikCheckUtil.check_in_range_by_dtype(
            repeat_time, msg="repeat_times should be in range of [%d, %d], input value is %s"
            % (0, MAX_REPEAT_TIMES, str(repeat_time)), var_range=[0, MAX_REPEAT_TIMES])
        mode = context.evaluate_expr(self.mode)
        if TikSocManager.is_mini_soc():
            _max_mode = 4
            TikCheckUtil.check_in_range_by_dtype(
                mode, msg="mode_number should be in the range of [%d, %d], "
                "input value is %s" % (MIN_MODE_NUMBER, _max_mode, str(mode)), var_range=[MIN_MODE_NUMBER, _max_mode])
        else:
            _max_mode = 5
            TikCheckUtil.check_in_range_by_dtype(
                mode, msg="mode_number should be in the range of [%d, %d], "
                "input value is %s" % (MIN_MODE_NUMBER, _max_mode, str(mode)), var_range=[MIN_MODE_NUMBER, _max_mode])

        mode_bit_pos = 16

        xt_idx = temp_env.alloc_register()
        x_t = 0
        x_t |= repeat_time << REPEAT_SHIFT_POS
        x_t |= mode << mode_bit_pos

        context.model.write_gpr(xt_idx, x_t)
        return xt_idx

    def _check_src_overflow(self, src_buf_size, context):
        src_offset = context.get_tensor_offset(self.src) * DTYPE_SIZE[self.src.dtype]
        repeat_time = context.evaluate_expr(self.repeat_times)
        # one repeat cost 16 elements
        need_buf_size = repeat_time * 16 * DTYPE_SIZE[self.src.dtype]
        if src_buf_size - src_offset < need_buf_size:
            TikCheckUtil.raise_error("src overflow, need %d Bytes, but only %d Bytes" %
                                     (need_buf_size, src_buf_size - src_offset))


class RpnCor(STMT):
    """
    rpn condition OR for non-diagonal suppression matrix
    """
    min_value = 0

    def __init__(self, source_info, rpn_cor_obj, tik_debugger):
        super(RpnCor, self).__init__(source_info, tik_debugger)
        self.src = rpn_cor_obj.src0
        self.src1 = rpn_cor_obj.src1
        self.src_stride = rpn_cor_obj.src0_rep_stride
        self.src1_stride = rpn_cor_obj.src1_rep_stride
        self.repeat_times = rpn_cor_obj.repeat_times

    @staticmethod
    def check_repeat_stride(repeat, xn_stride, xm_stride):
        """
        run the instruction

        Parameters
        ----------
        repeat : repeat times
        xn_stride : src rep stride
        xm_stride : src1 rep stride

        Returns
        -------
        None
        """
        # check repeat_times
        TikCheckUtil.check_in_range_by_dtype(
            repeat, msg="repeat_times should be in the range of [%d, %d], input value is %s"
            % (RpnCor.min_value, MAX_REPEAT_TIMES, str(repeat)), var_range=[RpnCor.min_value, MAX_REPEAT_TIMES])
        # check stride
        TikCheckUtil.check_in_range_by_dtype(
            xn_stride, msg="src0_rep_stride should be in the range of [%d, %d], input value is %s"
            % (RpnCor.min_value, MAX_REP_STRIDE_DOUBLE_BYTE, str(xn_stride)),
            var_range=[RpnCor.min_value, MAX_REP_STRIDE_DOUBLE_BYTE])
        TikCheckUtil.check_in_range_by_dtype(
            xm_stride, msg="src1_rep_stride should be in the range of [%d, %d], input value is %s"
            % (RpnCor.min_value, MAX_REP_STRIDE_DOUBLE_BYTE, str(xm_stride)),
            var_range=[RpnCor.min_value, MAX_REP_STRIDE_DOUBLE_BYTE])

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        temp_env = TempEnv()

        xn_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.src, ALIGNED_ADDR, access_mode='r')
        xm_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.src1, ALIGNED_ADDR, access_mode='r')

        xn_stride = context.evaluate_expr(self.src_stride)
        xm_stride = context.evaluate_expr(self.src1_stride)
        repeat = context.evaluate_expr(self.repeat_times)

        self.check_repeat_stride(repeat, xn_stride, xm_stride)

        xt_idx = temp_env.alloc_register()
        x_t = 0
        x_t |= xn_stride << _XN_STRIDE_SHIFT_BIT_POS
        x_t |= xm_stride << _XM_STRIDE_SHIFT_BIT_POS
        x_t |= repeat << REPEAT_SHIFT_POS

        context.model.write_gpr(xt_idx, x_t)

        param = _ENCODER.new_param()
        param.xn = xn_idx
        param.xm = xm_idx
        param.xt = xt_idx

        instr = _ENCODER.gen_rpn_cor(param)
        context.model.step(instr)
        temp_env.check_mem_access(context.model)


class RpnCorDiag(STMT):
    """
    rpn condition OR for diagnal suppression matrix
    """

    def __init__(self, source_info, dst, src, tik_debugger):
        super(RpnCorDiag, self).__init__(source_info, tik_debugger)
        self.dst = dst
        self.src = src

    def set_param(self, context, temp_env, xd_idx):
        """
        set param
        Parameters
        ----------
        context: context
        xd_idx: xd idx
        temp_env: temp env

        Returns
        -------

        """
        xn_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.src, ALIGNED_ADDR, access_mode='r')
        param = _ENCODER.new_param()
        param.xd = xd_idx
        param.xn = xn_idx
        return param

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        temp_env = TempEnv()
        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.dst, ALIGNED_ADDR, access_mode='w')

        param = self.set_param(context, temp_env, xd_idx)
        instr = _ENCODER.gen_rpn_cor_diag(param)
        context.model.step(instr)
        temp_env.check_mem_access(context.model, True)

        context.model.read_memory(
            dst_addr, self.dst.scope, dst_ptr, dst_alloc_size)


class VBS32(STMT):
    """
    VBS32 instruction"
    """
    min_value = 0

    def __init__(self, source_info, op_obj, tik_debugger):
        super(VBS32, self).__init__(source_info, tik_debugger)
        self.dst = op_obj.dst
        self.src0 = op_obj.src0
        self.src1 = op_obj.src1
        self.repeat_times = op_obj.repeat_times

    @staticmethod
    def check_vbs32_repeat(repeat_time):
        """
        check vbs32's repea times

        Parameters
        ----------
        repeat_time : repeat times

        Returns
        -------
        None
        """
        TikCheckUtil.check_in_range_by_dtype(
            repeat_time, msg="repeat_times should be in the range of [%d, %d], input value is %s"
            % (VBS32.min_value, MAX_REPEAT_TIMES, str(repeat_time)),
            var_range=[VBS32.min_value, MAX_REPEAT_TIMES])

    def eval_(self, context):
        """
        run the instruction
        """
        temp_env = TempEnv()
        xn_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.src0, ALIGNED_ADDR, access_mode='r')
        xm_idx, _, _, _ = copy_tensor_to_model(
            context, temp_env, self.src1, ALIGNED_ADDR, access_mode='r')
        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.dst, ALIGNED_ADDR, access_mode='w')

        repeat_time = context.evaluate_expr(self.repeat_times)
        self.check_vbs32_repeat(repeat_time)

        if self.dst.buffer is self.src0.buffer:
            check_overlapping_vsort32(context.evaluate_expr(self.dst.offset),
                                      context.evaluate_expr(self.src0.offset),
                                      repeat_time, self.dst.dtype)

        xt_idx = temp_env.alloc_register()
        x_t = 0
        x_t |= repeat_time << REPEAT_SHIFT_POS

        context.model.write_gpr(xt_idx, x_t)

        if TikSocManager.is_v300_610l_soc():
            param = _ENCODER.new_vec_param()
            param.type = VEC_DATA_TYPE_ENCODING_FP[self.dst.dtype]
            param.xdIdx = xd_idx
            param.xnIdx = xn_idx
            param.xmIdx = xm_idx
            param.xtIdx = xt_idx
            param.op1 = 0x15
            instr_list = [_ENCODER.gen_obj_detect_1v300(param), _ENCODER.gen_obj_detect_2v300(param)]
            context.model.step(instr_list)
        else:
            param = _ENCODER.new_param()
            param.type = VEC_DATA_TYPE_ENCODING[self.dst.dtype]
            param.xd = xd_idx
            param.xn = xn_idx
            param.xm = xm_idx
            param.xt = xt_idx
            instr = _ENCODER.gen_vbs32(param)
            context.model.step(instr)

        temp_env.check_mem_access(context.model)
        context.model.read_memory(
            dst_addr, self.dst.scope, dst_ptr, dst_alloc_size)


class VMS4V2(STMT):
    """
    VMS4V2 instruction
    """
    value = 2 ** 16 - 1
    align_src = 8

    def __init__(self, source_info, op_obj, tik_debugger=None):
        super(VMS4V2, self).__init__(source_info, tik_debugger)
        self.dst = op_obj.dst
        self.src_list = op_obj.src_list
        self.element_lengths = op_obj.element_count_list
        self.exhausted_suspension = op_obj.if_exhausted_suspension
        self.repeat_times = op_obj.repeat_times
        self.scalar_list = op_obj.vms4_sr_scalar_array

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        # check element_lengths
        element_lengths = self._check_elements_lengths(context)
        # check repeat_times
        repeat_times = context.evaluate_expr(self.repeat_times)
        TikCheckUtil.check_in_range_by_dtype(
            repeat_times, msg="repeat_times should be in the range of [%d, %d], input value is %s"
            % (0, MAX_REPEAT_TIMES, str(repeat_times)),
            var_range=[0, MAX_REPEAT_TIMES])
        check_vms4v2_repeat_times(repeat_times, element_lengths, self.exhausted_suspension)

        for i in range(len(self.src_list)):
            if self.dst.buffer is self.src_list[i].buffer:
                check_overlapping_vmrgsort((context.evaluate_expr(self.dst.offset),
                                            context.evaluate_expr(self.src_list[i].offset),
                                            element_lengths, repeat_times, self.dst.dtype, i))

        dst_addr, dst_ptr, dst_alloc_size = self.get_dst_info(context)
        context.model.read_memory(dst_addr, self.dst.scope, dst_ptr, dst_alloc_size)
        if self.scalar_list is not None:
            sr_value = context.model.read_spr('VMS4_SR')
            # vms4v2 bit shift
            for i, scalar in enumerate(self.scalar_list):
                offset = context.evaluate_expr(scalar.offset)
                context.update_var(scalar.debug_var[offset], (sr_value >> (i * SHIFT_BIT_POS_16)) & VMS4V2.value)

    def get_dst_info(self, context):
        """
        get the gen_param and buffer information

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        """
        align_dst = 32
        proposal_size = 8
        temp_env = TempEnv()

        xm_idx, xn_idx, xt_idx = self.set_register(context, temp_env, proposal_size)
        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.dst, align_dst, access_mode='w')
        if TikSocManager.is_v300_610l_soc():
            param = _ENCODER.new_vec_param()
            param.type = VEC_DATA_TYPE_ENCODING_FP[self.dst.dtype]
            param.xdIdx = xd_idx
            param.xnIdx = xn_idx
            param.xmIdx = xm_idx
            param.xtIdx = xt_idx
            param.op1 = 0x16
            instr_list = [_ENCODER.gen_obj_detect_1v300(param), _ENCODER.gen_obj_detect_2v300(param)]
            context.model.step(instr_list)
        else:
            param = _ENCODER.new_param()
            param.type = VEC_DATA_TYPE_ENCODING[self.dst.dtype]
            param.xd = xd_idx
            param.xm = xm_idx
            param.xn = xn_idx
            param.xt = xt_idx
            context.model.step(_ENCODER.gen_vms4v2(param))

        temp_env.check_mem_access(context.model)
        return dst_addr, dst_ptr, dst_alloc_size

    def set_register(self, context, temp_env, proposal_size):
        """
        set register and get xn_idx and xt_idx

        Parameters
        ----------
        context : the stack context
        temp_env : the temp environment
        align_src : align addr for src
        proposal_size : dst's dtpe size, 16 or 32

        Returns
        -------
        xm_idx : the result code
        xn_idx : the result code
        xt_idx : the result code
        """
        xm_idx = temp_env.alloc_register()
        x_m = 0

        xn_idx = temp_env.alloc_register()
        x_n = 0

        xt_idx = temp_env.alloc_register()
        x_t = context.evaluate_expr(self.repeat_times)

        for i, src in enumerate(self.src_list):
            # this will waste some gpr, but don't worry
            copy_tensor_to_model(context, temp_env, src, VMS4V2.align_src, access_mode='r')
            src_addr = temp_env.get_tensor_addr(
                context, src, access_mode='r') // proposal_size
            x_n |= src_addr << (i * ADDR_BIT_LEN)
            length = context.evaluate_expr(self.element_lengths[i])
            x_m |= length << (i * ADDR_BIT_LEN)
        context.model.write_gpr(xn_idx, x_n)
        context.model.write_gpr(xm_idx, x_m)
        x_t |= self.exhausted_suspension << EXHAUSTED_SUSPENSION_POS_V2
        valid_bit = [0, 1, 3, 7, 15]
        x_t |= valid_bit[len(self.src_list)] << SRC_LIST_BIT_POS_V2
        context.model.write_gpr(xt_idx, x_t)

        return xm_idx, xn_idx, xt_idx

    def _check_elements_lengths(self, context):
        element_lengths = []
        if not isinstance(self.element_lengths, (tuple, list)):
            self.element_lengths = [self.element_lengths] * 4
        for value in self.element_lengths:
            element_lengths.append(context.evaluate_expr(value))
        for index, ele_len in enumerate(element_lengths):
            TikCheckUtil.check_in_range_by_dtype(
                ele_len, msg="element_count[%s] should be in the range of [%d, %d]"
                % (index, 0, MAX_ELEMENTS_LEN_V2), var_range=[0, MAX_ELEMENTS_LEN_V2])

        return element_lengths
