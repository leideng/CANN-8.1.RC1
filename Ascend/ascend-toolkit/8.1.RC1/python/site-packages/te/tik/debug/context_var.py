#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     context_var.py
DESC:     debug context var
CREATED:  2021-11-26 15:00:23
MODIFIED: 2021-11-26 15:30:23
"""
from tbe import tvm
from tbe.tvm.tir import FloatImm
from tbe.tvm.tir import IntImm
from tbe.tvm.tir import StringImm
from tbe.tik.common.common_util import is_scalar
from tbe.tik.common.debug_api import DebugVm
from tbe.tik.common.debug_api import substitute_scalar
from tbe.tik.common.debug_api import substitute_scalar_check
from tbe.tik.common.debug_api import evaluate_expr_ex
from tbe.tik.debug.util import check_scalar_defined
from tbe.tik.debug.util import make_tvm_imm
from tbe.tik.debug.util import safe_get_value
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_expr import Expr


class ContextVar:
    """
    var variable correlation
    """
    def __init__(self):
        self.var_table = {}
        self.var_name_map = {}
        self.feed_var_table = {}
        self.scalar_mapping = {}
        self.scalar_location = {}
        # save scalar stmt; key is scalar.name; value is stmt
        self.scalar_stmt_dict = {}

    def set_scalar_var_mapping(self, scalar_buf_var, shadow_var):
        """
        set scalar by mapping

        Parameters
        ----------
        scalar_buf_var : key
        shadow_var : value

        Returns
        -------
        no return
        """
        self.scalar_mapping[scalar_buf_var.asobject()] = shadow_var

    def set_scalar_location(self, scalar, source_info):
        """
        set scalar source_info

        Parameters
        ----------
        scalar : key
        source_info : value

        Returns
        -------
        no return
        """
        self.scalar_location[scalar.reg_buffer.asobject()] = source_info

    def get_scalar_location(self, scalar):
        """
        get scalar source_info

        Parameters
        ----------
        scalar : key


        Returns
        -------
        source_info
        """
        return self.scalar_location.get(scalar.reg_buffer.asobject())

    def bind_var(self, var):
        """
        init the var in var_table with None

        Parameters
        ----------
        var : key
        """
        self.var_table[var] = None
        try:
            self.var_name_map[var.name] = var
        except AttributeError:
            pass
        finally:
            pass

    def get_feed_var_by_name(self, name):
        """
        find inputscalr in feed_var_table
        Parameters
        ----------
        name: inputscalr's name

        Returns
        -------
        no return
        """
        return self.feed_var_table.get(name)

    def bind_feed_var(self, name, var):
        """
        use to put inputscalar with value

        Parameters
        ----------
        name: inputscalar's name
        var: inputscalr's var

        Returns
        -------
        no return
        """
        self.feed_var_table[name] = var
        self.var_table[var] = None

    def check_var_exist_in_vm(self, var, offset=0):
        """
        check the var exist in debug vm. var may be simplified by pass, not in debug vm
        Parameters
        ----------
        var: the tvm var
        offset: index of var, default 0 for Scalar, non-zero value only for ScalarArray

        Returns
        -------
        None
        """
        if self.debug_vm_ctx is not None and self.actual_source_num > 0:
            return DebugVm.check_var_exist(self.debug_vm_ctx, var, offset)
        return False

    def update_var_to_vm(self, var, value, offset=0):
        """
        set the var value for debug vm
        Parameters
        ----------
        var: the tvm var
        value: the value to set
        offset: index of var, default 0 for Scalar, non-zero value only for ScalarArray

        Returns
        -------
        None
        """
        if self.debug_vm_ctx is not None and self.actual_source_num > 0:
            DebugVm.update_var(self.debug_vm_ctx, var, value, offset)

    def update_var_from_vm(self, var, debug_var, offset=0):
        """
        get the var value from debug vm
        Parameters
        ----------
        var: the tvm var
        debug_var: the debug var of tik python debug
        offset: index of var, default 0 for Scalar, non-zero value only for ScalarArray

        Returns
        -------
        None
        """
        if self.debug_vm_ctx is not None and self.actual_source_num > 0:
            value = DebugVm.get_var_value(self.debug_vm_ctx, var, offset)
            self.update_var(debug_var, value.value)

    def update_var(self, var, value):
        """
        update the var in var_table with value

        Parameters
        ----------
        var : key
        value : value

        Returns
        -------
        no return
        """
        # caused by using global long, so disable them
        if value is not None:
            err_msg = 'update_var got invalid value {} type {}'.format(value, type(value))
            if isinstance(value, tvm.tir.expr.Call):
                TikCheckUtil.check_equality(str(value.op.name), "tir.large_uint_imm", err_msg)
            else:
                TikCheckUtil.check_type_match(value, (float, int, bool, IntImm, FloatImm), err_msg)
        self.var_table[var] = value
        try:
            self.var_name_map[var.name] = var
        except AttributeError:
            pass
        finally:
            pass

    def get_var_by_name(self, name):
        """
        find var by name in var_name_map
        Parameters
        ----------
        name: inputscalr's name
        Returns
        -------
        var in var_name_map
        """
        return self.var_name_map.get(name)

    def evaluate_expr(self, original_expr, default_value=False):
        """
        run the expr

        Parameters
        ----------
        original_expr : the cmd string
        default_value : when cannot get the value of original_expr and default_value is True,return None

        Returns
        -------
        the result of original_expr
        """
        # caused by some interface of tbe.tvm such as tvm.tir.Evaluate, so disable them
        expr = original_expr
        if isinstance(expr, (int, float, bool, complex)):
            return expr
        expr = self._process_expr_scalar(expr)
        var_for_let = []
        value_for_let = []
        for var, var_value in self.var_table.items():
            # var may not be defined now, just skip it
            if var_value is not None:
                var_for_let.append(self._process_expr_scalar(var))
                if isinstance(var_value, (IntImm, FloatImm, StringImm)):
                    var_value = safe_get_value(var_value)
                value_for_let.append(make_tvm_imm(var.dtype, var_value))
        fail_arr = substitute_scalar_check(expr, self.scalar_mapping, var_for_let, value_for_let)
        if len(fail_arr) > 0:
            check_scalar_defined(fail_arr[0], self)
        expr = substitute_scalar(expr, self.scalar_mapping, var_for_let, value_for_let)
        prev_expr = tvm.tir.Evaluate(expr)
        let_ = prev_expr
        for i, var in enumerate(var_for_let):
            let_ = tvm.tir.LetStmt(var, value_for_let[i], prev_expr)
            prev_expr = let_
        result = tvm.tir.Simplify(let_)
        while 'value' in dir(result):
            result = safe_get_value(result)
        if not isinstance(result, (bool, int, float, str)):
            if default_value:
                result = None
            else:
                # evaluate expr with large uint
                result = evaluate_expr_ex(result)
                result = safe_get_value(result)
                if not isinstance(result, (bool, int, float, str)):
                    TikCheckUtil.raise_error("[Error]: found uninitialized Scalar!")
        return result

    def _process_expr_scalar(self, expr):
        """get expr scalar"""
        if is_scalar(expr):
            offset = self.evaluate_expr(expr.offset)
            return expr.debug_var[offset]
        if isinstance(expr, Expr):
            return expr.get()
        return expr
