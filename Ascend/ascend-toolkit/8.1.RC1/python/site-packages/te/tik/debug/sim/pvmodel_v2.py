#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     pvmodel.py
DESC:     import C APIs of PVModel
CREATED:  2019-7-04 20:12:13
MODIFIED: 2020-12-7 19:17:00
"""
# import C APIs of PVModel. Avoid using from ctypes import *
from ctypes import c_int
from ctypes import c_bool
from ctypes import c_uint64
from ctypes import POINTER
from ctypes import c_void_p
from ctypes import c_uint32
from ctypes import c_char_p
from ctypes import byref
from ctypes import c_uint8
from ctypes import cast

from tbe.common.platform import scope_cc
from tbe.common.platform import scope_cbuf
from tbe.common.platform import scope_cb
from tbe.common.platform import scope_ca
from tbe.common.platform import scope_ubuf
from tbe.common.platform import scope_gm
from tbe.common.platform.platform_info import scope_fb0
from tbe.common.platform.platform_info import scope_bt
from tbe.tik.debug.util import VecRegType
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import MAX_VA_ADDR_NUM
from tbe.tik.tik_lib.tik_params import VA_ADDR_BYTE_SIZE
from tbe.tik.tik_lib.tik_params import MAX_ADDR
from tbe.tik.tik_lib.tik_params import ONE_VA_ADDR_NUM
from tbe.tik.tik_lib.tik_params import VA_ADDR_BIT_LEN
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.debug.sim.pvmodel_common import PVModelBase
from tbe.tik.debug.sim.pvmodel_common import PVMemAccessList
_RETURN_CODE_ZERO = 0


_spr_map = {
    "PC": 0,
    "BLOCKID": 1,
    "STATUS": 2,
    "CTRL": 3,
    "PARA_BASE": 4,
    "BLOCKDIM": 9,
    "FMATRIX": 10,
    "DEQSCALE": 12,
    "PADDING": 13,
    "VMS4_SR": 17,
    "RPN_COR_IR": 19,
    "RSVD_CNT": 57,
    "L3D_RPT": 58,
    "MAX_MIN_CNT": 63,
    "FPC": 64,
    "QUANT_PRE": 65,
    "MOV_PAD_VAL": 70,
    "ACC_VAL": 87
}

_spr_mask_map = {
    "AR": 74,
    "MASK0": 100,
    "MASK1": 101,
    "CMPMASK0": 104,
    "CMPMASK1": 105
}

_spr_mask_map_v300 = {
    "AR": 74,
    "MASK0": 105,
    "MASK1": 106,
    "CMPMASK0": 109,
    "CMPMASK1": 110,
}


class PVModelV2(PVModelBase):
    """
    Encapsulation of pvmodel
    """

    _scope_mapping = {
        scope_gm: 0,
        scope_cbuf: 1,
        scope_ca: 2,
        scope_cb: 3,
        scope_cc: 4,
        scope_ubuf: 5,
        scope_fb0: 6,
        scope_bt: 10,
    }

    _version2subcore = {
        # True means is cubecore, else vec
        True: 0,
        False: 1

    }

    def __init__(self, core_id=0):
        super().__init__()
        self.model = None
        self.core_id = core_id
        self.sub_core_aiv =  0 if TikSocManager.is_610l_soc() else 1
        self._config_file = None
        self._load_pvmodel()

        self._pv_create = self._dll.pv_init

        self._pv_step = self._dll.pv_step
        self._pv_step.restype = c_uint32
        self._pv_step.argtypes = [c_uint32, c_uint32, c_uint32]

        self._pv_launch_sub_core = self._dll.pv_launch_sub_core
        self._pv_launch_sub_core.argtypes = [c_uint64, c_char_p, c_uint32, c_uint32]

        self._pv_mem_write = self._dll.pv_mem_write
        self._pv_mem_write.restype = c_bool
        self._pv_mem_write.argtypes = [c_uint32, c_uint64, c_uint64, POINTER(c_uint8), c_uint32, c_uint32]

        self._pv_reg_read = self._dll.pv_reg_read
        self._pv_reg_read.restype = c_bool
        self._pv_reg_read.argtypes = [c_uint32, c_uint32, POINTER(c_uint8), c_uint32, c_uint32]

        self._pv_reg_write = self._dll.pv_reg_write
        self._pv_reg_write.restype = c_bool
        self._pv_reg_write.argtypes = [c_uint32, c_uint32, POINTER(c_uint8), c_uint32, c_uint32]

        self._pv_read_memory = self._dll.pv_mem_read
        self._pv_read_memory.restype = c_int
        self._pv_read_memory.argtypes = [c_uint32, c_uint64, c_uint64, POINTER(c_uint8), c_uint32, c_uint32]

        self._pv_free = self._dll.pv_reset
        self._pv_free.argtypes = [c_void_p]

        self._set_read_record = self._dll.set_read_record
        self._set_read_record.argtypes = []

        self._pv_get_mem_acc_list = self._dll.pv_get_mem_access
        self._pv_get_mem_acc_list.restype = POINTER(PVMemAccessList)
        self._pv_get_mem_acc_list.argtypes = [c_uint32, c_uint32]

        if self._config_file:
            self._pv_set_config_path = self._dll.set_config_path
            self._pv_set_config_path.restype = c_void_p
            self._pv_set_config_path.argtypes = [c_char_p]

            # set the pvmodel config file by _config_file
            self._pv_set_config_path(self._config_file.encode("utf-8"))

        # c_void_p
        log_path = "kernel_meta/debug_log_core%s" % self.core_id
        self._pv_create(0, 0, 0, log_path.encode("utf-8"), self.core_id)

        self.instr_byte_size = 4
        if TikSocManager.is_910b_soc() or TikSocManager.is_v300_610l_soc():
            self.inst_max_addr = 0x1 << 32
            # v210 and v300 need more space to store instructions for VF
            self.inst_start_addr = self.inst_max_addr - 0x1000
        else:
            self.inst_max_addr = 0x1 << 16
            self.inst_start_addr = self.inst_max_addr - 8
        self.end_instr_encoding = (c_uint32)(0x2 << 29 | 0xB << 21)
        self.send_instr_encoding = (c_uint32)(0xC0000017)

    @staticmethod
    def _check_params(addr_list, va_id):
        """
        check addr list, val
        Parameters
        ----------
        addr_list: addr list
        va_id: val id

        Returns
        -------

        """
        TikCheckUtil.check_equality(
            len(addr_list), MAX_VA_ADDR_NUM,
            "Expecting 8 addresses in addr list, but get %d" % len(addr_list))
        if va_id < 0 or va_id >= MAX_VA_ADDR_NUM:
            TikCheckUtil.raise_error("Invalid VA-id: %d" % va_id)

        for i, addr in enumerate(addr_list):
            addr = (addr // VA_ADDR_BYTE_SIZE)
            TikCheckUtil.check_le(
                addr, MAX_ADDR,
                "Invalid adress setting to VA: 0x%x. Too large for 16bit" %
                addr*VA_ADDR_BYTE_SIZE)

    @staticmethod
    def _get_reg_type(reg_type):
        # reg index for v300: GPR:0, SPR:1, VA:2, VREG:3, PREG:4, WREG:5, SREG:6, ULDREG:7, USTREG:8, FSTREG:9, UNDEF:10
        reg_type_map = {VecRegType.P_REG: 4, VecRegType.V_REG: 3, VecRegType.W_REG: 5, VecRegType.S_REG: 6}
        if reg_type not in reg_type_map.keys():
            TikCheckUtil.raise_error("Unsupported reg type, reg type value:%s" % str(reg_type))
        return reg_type_map.get(reg_type)

    def create_vf_instr(self, instr_len):
        """
        for create vfi instr for single instr run
        """
        instr1 = 0x3  # first vector instr offset with VF instr, unit is 4Bytes
        instr1 += 0xAB << 21
        instr2 = 0x4
        instr2 += (instr_len + 1) << 5  # instr_len is valid instrs, 1 is SEND instr
        instr2 += 0xAF << 21
        vf_instr_nums = 0
        self._pv_mem_write(0, self.inst_start_addr,
                           self.instr_byte_size,
                           cast(byref((c_uint32)(instr1)), POINTER(c_uint8)), self.sub_core_aiv, self.core_id)
        vf_instr_nums += 1
        self._pv_mem_write(0, self.inst_start_addr + self.instr_byte_size * vf_instr_nums,
                           self.instr_byte_size,
                           cast(byref((c_uint32)(instr2)), POINTER(c_uint8)), self.sub_core_aiv, self.core_id)
        vf_instr_nums += 1
        self._pv_mem_write(0, self.inst_start_addr + self.instr_byte_size * vf_instr_nums,
                           self.instr_byte_size, cast(byref(self.end_instr_encoding), POINTER(c_uint8)),
                           self.sub_core_aiv, self.core_id)
        vf_instr_nums += 1
        return vf_instr_nums

    def step_all(self, context, instr_list, instr_len):
        """
        run a instruction
        """
        vf_instr_nums = self.create_vf_instr(instr_len)
        TikCheckUtil.check_lt(self.inst_start_addr + self.instr_byte_size * (instr_len + vf_instr_nums),
                              self.inst_max_addr, "Instruction number exceed the limit")
        for index, instr in enumerate(instr_list):
            inst = (c_uint32)(instr)
            self._pv_mem_write(0, self.inst_start_addr + self.instr_byte_size * (index + vf_instr_nums),
                               self.instr_byte_size, cast(byref(inst), POINTER(c_uint8)),
                               self.sub_core_aiv, self.core_id)
        # must send SEND instruction for vf end, if no, next vf cannot run
        self._pv_mem_write(0, self.inst_start_addr + self.instr_byte_size * (instr_len + vf_instr_nums),
                           self.instr_byte_size, cast(byref(self.send_instr_encoding), POINTER(c_uint8)),
                           self.sub_core_aiv, self.core_id)
        self._pv_launch_sub_core(self.inst_start_addr, c_char_p(bytes("", encoding="utf-8")),
                                 self.sub_core_aiv, self.core_id)
        self._set_read_record()

        # 11 vf_instr
        return_code = self._pv_step(11, self.sub_core_aiv, self.core_id)
        TikCheckUtil.check_equality(return_code, _RETURN_CODE_ZERO, "return_code not 0")

    def step(self, instr, sub_core_id=1):
        """
        run a instruction
        """
        instr_len = 1
        sub_core_id = 0 if TikSocManager.is_610l_soc() else sub_core_id
        if isinstance(instr, (list, tuple)):
            instr_len = len(instr)
        if instr_len == 1:
            self._pv_mem_write(0, self.inst_start_addr, self.instr_byte_size,
                               cast(byref((c_uint32)(instr)), POINTER(c_uint8)), sub_core_id, self.core_id)
        else:
            for index, ins in enumerate(instr):
                self._pv_mem_write(0, self.inst_start_addr + self.instr_byte_size * index, self.instr_byte_size,
                                   cast(byref((c_uint32)(ins)), POINTER(c_uint8)), sub_core_id, self.core_id)
        self._pv_mem_write(0, self.inst_start_addr + self.instr_byte_size * instr_len, self.instr_byte_size * instr_len,
                           cast(byref(self.end_instr_encoding), POINTER(c_uint8)), sub_core_id, self.core_id)

        self._pv_launch_sub_core(self.inst_start_addr, c_char_p(bytes("", encoding="utf-8")),
                                 sub_core_id, self.core_id)
        self._set_read_record()
        self._pv_step(0, sub_core_id, self.core_id)

    def write_gpr(self, x_i, value, sub_core_id=1):
        """
        write to general purpose register
        """
        sub_core_id = 0 if TikSocManager.is_610l_soc() else sub_core_id
        self._pv_reg_write(0, c_uint32(x_i), cast(byref(c_uint64(value)), POINTER(c_uint8)),
                           sub_core_id, self.core_id)

    def read_memory(self, addr, scope, buffer_addr, buffer_len, sub_core_id=1):
        """
        read a segment of memory
        """
        sub_core_id = 0 if TikSocManager.is_610l_soc() else sub_core_id
        self._pv_read_memory(self._scope2int(scope), c_uint64(addr),
                             c_uint64(buffer_len),
                             cast(buffer_addr, POINTER(c_uint8)),
                             sub_core_id, self.core_id)

    def read_gpr(self, x_i, sub_core_id=1):
        """
        read from general purpose register
        """
        sub_core_id = 0 if TikSocManager.is_610l_soc() else sub_core_id
        ret = c_uint64(0)
        self._pv_reg_read(0,  c_uint32(x_i), cast(byref(ret), POINTER(c_uint8)), sub_core_id, self.core_id)
        return ret.value

    def read_spr(self, name, sub_core_id=1):
        """
        read from special register
        """
        sub_core_id = 0 if TikSocManager.is_610l_soc() else sub_core_id
        ret = c_uint64(0)
        if name in _spr_map:
            self._pv_reg_read(1, c_uint32(_spr_map.get(name)), cast(byref(ret), POINTER(c_uint8)),
                              sub_core_id, self.core_id)

        elif name in _spr_mask_map:
            if TikSocManager.is_910b_soc():
                self._pv_reg_read(1, c_uint32(_spr_mask_map.get(name)), cast(byref(ret), POINTER(c_uint8)),
                                  sub_core_id, self.core_id)
            else:
                self._pv_reg_read(1, c_uint32(_spr_mask_map_v300.get(name)), cast(byref(ret), POINTER(c_uint8)),
                                  sub_core_id, self.core_id)

        return ret.value

    def write_spr(self, name, value, sub_core_id=1):
        """
        write to special register
        """
        sub_core_id = 0 if TikSocManager.is_610l_soc() else sub_core_id
        if name.startswith("VPR_SHARED_"):
            spr_id = int(name.split("VPR_SHARED_")[1])
            self._pv_reg_write(6, c_uint32(spr_id), cast(byref(c_uint64(value)), POINTER(c_uint8)),
                               sub_core_id, self.core_id)
        elif name in _spr_map:
            self._pv_reg_write(1, c_uint32(_spr_map.get(name)), cast(byref(c_uint64(value)), POINTER(c_uint8)),
                               sub_core_id, self.core_id)
        elif name in _spr_mask_map:
            if TikSocManager.is_910b_soc():
                self._pv_reg_write(1, c_uint32(_spr_mask_map.get(name)), cast(byref(c_uint64(value)), POINTER(c_uint8)),
                                   sub_core_id, self.core_id)
            else:
                self._pv_reg_write(1, c_uint32(_spr_mask_map_v300.get(name)),
                                   cast(byref(c_uint64(value)), POINTER(c_uint8)),
                                   sub_core_id, self.core_id)
        else:
            TikCheckUtil.raise_error("Unsupported SPR: %s" % str(name))

    def read_vec_register_by_idx(self, reg_type, reg_idx, data_buffer, data_len):
        """
        read register idx from vector
        """
        new_reg_type = self._get_reg_type(reg_type)
        self._pv_reg_read(new_reg_type, c_uint32(reg_idx), cast(data_buffer, POINTER(c_uint8)),
                          self.sub_core_aiv, self.core_id)

    def read_vec_spr(self, reg_type, reg_index, value, value_size):
        """
        read from special register
        """
        ret = c_uint64(0)
        self._pv_reg_read(reg_type, c_uint32(reg_index), cast(value, POINTER(c_uint8)),
                          self.sub_core_aiv, self.core_id)
        return ret.value

    def write_vec_spr(self, reg_type, reg_index, value, value_size):
        """
        write to special register
        """
        self._pv_reg_write(reg_type, c_uint32(reg_index), cast(value, POINTER(c_uint8)),
                           self.sub_core_aiv, self.core_id)

    def write_va(self, va_id, addr_list):
        """
        write to VA register
        """
        self._check_params(addr_list, va_id)
        val0 = 0
        val1 = 0
        for i, addr in enumerate(addr_list):
            addr = (addr // VA_ADDR_BYTE_SIZE)
            if i < ONE_VA_ADDR_NUM:
                val0 |= (addr << (i*VA_ADDR_BIT_LEN))
            else:
                val1 |= (addr << ((i - ONE_VA_ADDR_NUM)*VA_ADDR_BIT_LEN))
        val0_3 = val0 >> 48
        val0_2 = (val0 >> 32) - (val0_3 << 16)
        val0_1 = (val0 >> 16) - (val0_3 << 32) - (val0_2 << 16)
        val0_0 = val0 - ((val0 >> 16) << 16)

        val1_3 = val1 >> 48
        val1_2 = (val1 >> 32) - (val1_3 << 16)
        val1_1 = (val1 >> 16) - (val1_3 << 32) - (val1_2 << 16)
        val1_0 = val1 - ((val1 >> 16) << 16)

        for i in range(8):
            self._pv_reg_write(2, c_uint32(va_id*8 | i),
                               cast(byref([c_uint64(val0_0), c_uint64(val0_1), c_uint64(val0_2), c_uint64(val0_3),
                                           c_uint64(val1_0), c_uint64(val1_1), c_uint64(val1_2), c_uint64(val1_3)][i]),
                                    POINTER(c_uint8)),
                               self.sub_core_aiv, self.core_id)

    def write_memory(self, addr, scope, buffer_addr, buffer_len, sub_core_id=1):
        """
        write a segment of memory
        """
        sub_core_id = 0 if TikSocManager.is_610l_soc() else sub_core_id
        self._pv_mem_write(self._scope2int(scope), c_uint64(addr),
                           c_uint64(buffer_len),
                           cast(buffer_addr, POINTER(c_uint8)), sub_core_id, self.core_id)

    def get_memory_access(self, check_read, src_tensor_nums):
        """
        get the memory access of the previous instruction
        """
        sub_core_aiv = 0 if TikSocManager.is_610l_soc() else self.sub_core_aiv
        mem_access_list = self._pv_get_mem_acc_list(sub_core_aiv, self.core_id)
        return self.get_access_list(mem_access_list, check_read, src_tensor_nums)

    def get_memory_access_vnchwconv(self, tensor_nums_list):
        """
        get the memory access of the previous instruction
        """
        sub_core_aiv = 0 if TikSocManager.is_610l_soc() else self.sub_core_aiv
        mem_access_list = self._pv_get_mem_acc_list(sub_core_aiv, self.core_id)
        return self.get_access_list_vnchwconv(mem_access_list, tensor_nums_list)

    def get_dll(self):
        """
        get the dll of lib_pvmodel.so
        Returns
        -------
        the dll object
        """
        return self._dll

    def get_chip_version(self):
        """
        get the chip version encode value
        Returns
        -------
        encode value
        """
        return self._version2subcore.get(TikSocManager.is_aicore_core())

    def _load_pvmodel(self):
        """
        load pvmodel
        """
        config_file_name = "config_pem_model.toml"
        llt_pvmodel_name = 'libpem_davinci.so'

        self.load_pvmodel_capture(config_file_name, llt_pvmodel_name)

    def _scope2int(self, scope):
        """
        convert the scope name to the specified encoding
        """
        return c_uint32(self._scope_mapping.get(scope))
