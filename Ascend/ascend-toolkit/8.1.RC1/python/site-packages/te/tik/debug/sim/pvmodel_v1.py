#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     pvmodel.py
DESC:     import C APIs of PVModel
CREATED:  2019-7-04 20:12:13
MODIFIED: 2020-12-7 19:17:00
"""
# import C APIs of PVModel. Avoid using from ctypes import *
from ctypes import c_int
from ctypes import c_uint64
from ctypes import POINTER
from ctypes import c_void_p
from ctypes import c_uint32
from ctypes import c_char_p
from ctypes import c_int64
from ctypes import c_size_t
from ctypes import byref

from tbe.common.platform import VEC_610
from tbe.common.platform import AIC_610
from tbe.common.platform import ASCEND_910BAIC
from tbe.common.platform import ASCEND_910BVEC
from tbe.common.platform import ASCEND_SD_AIC
from tbe.common.platform import scope_cc
from tbe.common.platform import scope_cbuf
from tbe.common.platform import scope_cb
from tbe.common.platform import scope_ca
from tbe.common.platform import scope_ubuf
from tbe.common.platform import scope_gm
from tbe.common.platform import HI3796CV300ESAIC
from tbe.common.platform import HI3796CV300CSAIC
from tbe.tik.common.tik_api_map import ASCEND_310AIC
from tbe.tik.common.tik_api_map import ASCEND_910AIC
from tbe.tik.common.tik_api_map import VEC_310B
from tbe.tik.common.tik_api_map import VEC_310M
from tbe.tik.common.tik_api_map import AIC_310P
from tbe.tik.common.tik_api_map import VEC_310P
from tbe.tik.common.tik_api_map import AIC_BS9SX1A
from tbe.tik.common.tik_api_map import VEC_BS9SX1A
from tbe.tik.common.tik_api_map import BS9SX1A
from tbe.tik.common.tik_api_map import ASCEND_910_93AIC
from tbe.tik.common.tik_api_map import ASCEND_910_93VEC
from tbe.tik.common.tik_get_soc_name import get_soc_name
from tbe.tik.common.tik_get_soc_name import get_soc_core_type
from tbe.tik.debug.npbuffer import NumpyBuffer
from tbe.tik.debug.sim.pvmodel_common import PVModelBase
from tbe.tik.debug.sim.pvmodel_common import PVMemAccessList
from tbe.tik.tik_lib.tik_params import ONE_VA_ADDR_NUM
from tbe.tik.tik_lib.tik_params import VA_ADDR_BIT_LEN
from tbe.tik.tik_lib.tik_params import VA_ADDR_BYTE_SIZE
from tbe.tik.tik_lib.tik_params import MAX_ADDR
from tbe.tik.tik_lib.tik_params import MAX_ADDR_HEX
from tbe.tik.tik_lib.tik_params import MAX_VA_ADDR_NUM
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil

_RETURN_CODE_ZERO = 0


class PVModelV1(PVModelBase):
    """
    Encapsulation of pvmodel
    """

    _scope_mapping = {
        scope_gm: 0,
        scope_cbuf: 1,
        scope_ca: 2,
        scope_cb: 3,
        scope_cc: 4,
        scope_ubuf: 5,
    }

    _version2id = {
        AIC_610: 0,
        AIC_310P: 0,
        AIC_BS9SX1A: 0,
        ASCEND_310AIC: 0,
        ASCEND_910AIC: 0,
        ASCEND_910BAIC: 0,
        ASCEND_910BVEC: 0,
        ASCEND_910_93AIC: 0,
        ASCEND_910_93VEC: 0,
        VEC_610: 3,
        VEC_310P: 3,
        VEC_BS9SX1A: 3,
        VEC_310B: 3,
        VEC_310M: 3,
        HI3796CV300ESAIC: 4,
        HI3796CV300CSAIC: 4,
        ASCEND_SD_AIC: 4,
    }

    def __init__(self, dprofile):
        super().__init__()
        self.dprofile = dprofile
        self.model = None
        self._config_file = None
        self._load_pvmodel()

        self._pv_create = self._dll.pv_create
        self._pv_create.restype = c_void_p

        self._pv_destroy = self._dll.pv_destroy
        self._pv_destroy.argtypes = [c_void_p]

        self._pv_step = self._dll.pv_step
        self._pv_step.restype = c_int
        self._pv_step.argtypes = [c_void_p, c_uint32]

        self._pv_read_gpr_register = self._dll.pv_read_gpr_register
        self._pv_read_gpr_register.restype = c_int
        self._pv_read_gpr_register.argtypes = [c_void_p, c_uint64, POINTER(c_uint64)]

        self._pv_write_gpr_register = self._dll.pv_write_gpr_register
        self._pv_write_gpr_register.restype = c_int
        self._pv_write_gpr_register.argtypes = [c_void_p, c_uint64, c_uint64]

        self._pv_read_spr_register = self._dll.pv_read_spr_register
        self._pv_read_spr_register.restype = c_int
        self._pv_read_spr_register.argtypes = [c_void_p, c_char_p, POINTER(c_uint64)]

        self._pv_write_spr_register = self._dll.pv_write_spr_register
        self._pv_write_spr_register.restype = c_int
        self._pv_write_spr_register.argtypes = [c_void_p, c_char_p, c_uint64]

        if get_soc_name() == BS9SX1A:
            self._pv_read_vec_register = self._dll.pv_read_vec_register
            self._pv_read_vec_register.restype = c_int
            self._pv_read_vec_register.argtypes = [c_void_p, c_uint32, c_char_p, c_uint32, c_uint32]

            self._pv_write_vec_register = self._dll.pv_write_vec_register
            self._pv_write_vec_register.restype = c_int
            self._pv_write_vec_register.argtypes = [c_void_p, c_uint32, c_char_p, c_uint32, c_uint32]

            self._pv_step_all = self._dll.pv_step_all
            self._pv_step_all.restype = c_uint32
            self._pv_step_all.argtypes = [c_void_p, c_char_p, c_uint32]

            self._pv_get_vec_register_index = self._dll.pv_get_rename_p_index
            self._pv_get_vec_register_index.restype = c_uint32
            self._pv_get_vec_register_index.argtypes = [c_void_p, c_uint32, c_uint32]

        self._pv_read_va_register = self._dll.pv_read_va_register
        self._pv_read_va_register.restype = c_int
        self._pv_read_va_register.argtypes = [c_void_p, c_int, POINTER(c_uint64), POINTER(c_uint64)]

        self._pv_write_va_register = self._dll.pv_write_va_register
        self._pv_write_va_register.restype = c_int
        self._pv_write_va_register.argtypes = [c_void_p, c_int, POINTER(c_uint64), POINTER(c_uint64)]

        self._pv_read_memory = self._dll.pv_read_memory
        self._pv_read_memory.restype = c_int
        self._pv_read_memory.argtypes = [c_void_p, c_int64, c_int, c_void_p, c_int]

        self._pv_write_memory = self._dll.pv_write_memory
        self._pv_write_memory.restype = c_int
        self._pv_write_memory.argtypes = [c_void_p, c_int64, c_int, c_void_p, c_int]

        self._pv_get_memory_capacity = self._dll.pv_get_memory_capacity
        self._pv_get_memory_capacity.restype = c_int
        self._pv_get_memory_capacity.argtypes = [c_void_p, c_int, POINTER(c_int)]

        self._pv_malloc = self._dll.malloc
        self._pv_malloc.restype = c_void_p
        self._pv_malloc.argtypes = [c_size_t]

        self._pv_free = self._dll.free
        self._pv_free.argtypes = [c_void_p]

        self._pv_get_mem_acc_list = self._dll.pv_get_mem_access
        self._pv_get_mem_acc_list.restype = POINTER(PVMemAccessList)
        self._pv_get_mem_acc_list.argtypes = []

        if self._config_file:
            self._pv_set_config_path = self._dll.set_config_path
            self._pv_set_config_path.restype = c_void_p
            self._pv_set_config_path.argtypes = [c_char_p]

            # set the pvmodel config file by _config_file
            self._pv_set_config_path(self._config_file.encode("utf-8"))

        # c_void_p
        self.model = self._pv_create(self._version2id.get(get_soc_name() + get_soc_core_type()), '', 0)

    def __del__(self):
        if self.model:
            self._pv_destroy(self.model)

    def get_dll(self):
        """
        get the dll of lib_pvmodel.so
        Returns
        -------
        the dll object
        """
        return self._dll

    def get_chip_version(self):
        """
        get the chip version encode value
        Returns
        -------
        encode value
        """
        return self._version2id.get(get_soc_name() + get_soc_core_type())

    def step(self, inst):
        """
        run a instruction
        """
        return_code = self._pv_step(self.model, c_uint32(inst))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO, "return_code not 0")

    def step_all(self, context, inst_list, inst_len):
        """
        run a instruction
        """
        npbuf = NumpyBuffer((context, inst_len, "uint32", "random", None))
        for i in range(inst_len):
            npbuf.buffer[i] = inst_list[i]

        flatten_data = npbuf.buffer.reshape(-1)
        return_code = self._pv_step_all(self.model,
                                        c_char_p(flatten_data.ctypes.data),
                                        c_uint32(inst_len))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO, "return_code not 0")

    def read_gpr(self, x_i):
        """
        read from general purpose register
        """
        ret = c_uint64(0)
        return_code = self._pv_read_gpr_register(self.model,
                                                 c_uint64(x_i),
                                                 byref(ret))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO, "return_code not 0")
        return ret.value

    def write_gpr(self, x_i, value):
        """
        write to general purpose register
        """
        return_code = self._pv_write_gpr_register(self.model,
                                                  c_uint64(x_i),
                                                  c_uint64(value))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO, "return_code not 0")

    def read_spr(self, name):
        """
        read from special register
        """
        ret = c_uint64(0)
        return_code = self._pv_read_spr_register(self.model,
                                                 name.encode("utf-8"),
                                                 byref(ret))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO,
            "read spr %s failed, maybe spr name is wrong" % name)
        return ret.value

    def write_spr(self, name, value):
        """
        write to special register
        """
        return_code = self._pv_write_spr_register(self.model,
                                                  name.encode("utf-8"),
                                                  c_uint64(value))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO, "return_code not 0")

    def read_vec_register_by_idx(self, reg_type, reg_idx, data_buffer, data_len):
        """
        get the vector register by index
        Parameters
        ----------
        reg_type: register type
        reg_idx: register index
        data_buffer: data buffer of numpy
        data_len: data length

        Returns
        -------
        the vector register

        """
        vd_idx_rename = self.get_vec_register_index(reg_idx, reg_type)
        self.read_vec_register(vd_idx_rename, data_buffer, data_len)

    def read_vec_register(self, register_index, ret_buffer, data_len):
        """
        read from vec special register
        """
        data_buffer = c_char_p(ret_buffer)
        offset = 0
        return_code = self._pv_read_vec_register(self.model,
                                                 c_uint32(register_index),
                                                 data_buffer,
                                                 c_uint32(data_len),
                                                 c_uint32(offset))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO,
            "read vec register %d failed, maybe spr name is wrong" %
            register_index)
        return data_buffer.value

    def write_vec_register(self, register_index, src_buffer, data_len, offset=0):
        """
        write to vec special register
        """
        data_buffer = c_char_p(src_buffer)
        return_code = self._pv_write_vec_register(self.model,
                                                  c_uint32(register_index),
                                                  data_buffer,
                                                  c_uint32(data_len),
                                                  c_uint32(offset))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO,
            "write vec register %d return_code not 0" % register_index)

    def get_vec_register_index(self, register_index, register_type):
        """
        write to vec special register
        """
        return_code = self._pv_get_vec_register_index(self.model,
                                                      c_uint32(register_index),
                                                      c_uint32(register_type))
        return return_code

    def read_va(self, va_id):
        """
        read from VA register
        """
        val0 = c_uint64(0)
        val1 = c_uint64(0)
        return_code = self._pv_read_va_register(self.model, c_int(va_id),
                                                byref(val0), byref(val1))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO, "return_code not 0")
        val0 = val0.value
        val1 = val1.value
        addr_list = []
        for i in range(ONE_VA_ADDR_NUM):
            addr_list.append((val0 >> (i*VA_ADDR_BIT_LEN)) & MAX_ADDR_HEX)

        for i in range(ONE_VA_ADDR_NUM):
            addr_list.append((val1 >> (i*VA_ADDR_BIT_LEN)) & MAX_ADDR_HEX)

        return addr_list

    def write_va(self, va_id, addr_list):
        """
        write to VA register
        """
        val0 = 0
        val1 = 0
        TikCheckUtil.check_equality(
            len(addr_list), MAX_VA_ADDR_NUM,
            "Expecting 8 addresses in addr list, but get %d" % len(addr_list))
        if va_id < 0 or va_id >= MAX_VA_ADDR_NUM:
            TikCheckUtil.raise_error("Invalid VA-id: %d" % va_id)

        i = 0
        for addr in addr_list:
            addr = (addr // VA_ADDR_BYTE_SIZE)
            TikCheckUtil.check_le(
                addr, MAX_ADDR,
                "Invalid adress setting to VA: 0x%x. Too large for 16bit" %
                addr*VA_ADDR_BYTE_SIZE)
            if i < ONE_VA_ADDR_NUM:
                val0 |= (addr << (i*VA_ADDR_BIT_LEN))
            else:
                val1 |= (addr << ((i - ONE_VA_ADDR_NUM)*VA_ADDR_BIT_LEN))
            i += 1

        new_val0 = c_uint64(val0)
        new_val1 = c_uint64(val1)

        return_code = self._pv_write_va_register(self.model, c_int(va_id),
                                                 byref(new_val0), byref(new_val1))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO,
            'write va %s failed' % va_id)

    def read_memory(self, addr, scope, buffer_addr, buffer_len):
        """
        read a segment of memory
        """
        return_code = self._pv_read_memory(self.model, c_int64(addr),
                                           self._scope2int(scope),
                                           buffer_addr, c_int(buffer_len))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO, "return_code not 0")

    def write_memory(self, addr, scope, buffer_addr, buffer_len):
        """
        write a segment of memory
        """
        return_code = self._pv_write_memory(self.model, c_int64(addr),
                                            self._scope2int(scope),
                                            buffer_addr, c_int(buffer_len))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO, "return_code not 0")

    def get_memory_capacity(self, scope):
        """
        get the memory size of the specified scope
        """
        ret = c_int(0)
        return_code = self._pv_get_memory_capacity(
            self.model, self._scope2int(scope), byref(ret))
        TikCheckUtil.check_equality(
            return_code, _RETURN_CODE_ZERO, "return_code not 0")
        return ret

    def get_memory_access(self, check_read, src_tensor_nums):
        """
        get the memory access of the previous instruction
        """
        mem_access_list = self._pv_get_mem_acc_list()
        return self.get_access_list(mem_access_list, check_read, src_tensor_nums)

    def get_memory_access_depthwise_conv(self):
        """
        get the memory access of the previous instruction
        """
        mem_access_list = self._pv_get_mem_acc_list()
        return self.get_access_list_depthwise_conv(mem_access_list)

    def get_memory_access_vnchwconv(self, tensor_nums_list):
        """
        get the memory access of the previous instruction
        """
        mem_access_list = self._pv_get_mem_acc_list()
        return self.get_access_list_vnchwconv(mem_access_list, tensor_nums_list)

    def _load_pvmodel(self):
        """
        load pvmodel
        """
        config_file_name = "config_pv_aicore_model.toml"
        llt_pvmodel_name = 'lib_pvmodel.so'

        self.load_pvmodel_capture(config_file_name, llt_pvmodel_name)

    def _scope2int(self, scope):
        """
        convert the scope name to the specified encoding
        """
        return c_int(self._scope_mapping.get(scope))
