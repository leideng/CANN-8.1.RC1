#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     debugger_inner.py
DESC:     debugger_inner
CREATED:  2021-12-24 5:44 AM
MODIFIED: 2021-12-24 5:44 AM
"""
import os
import copy
from cmd import Cmd
import numpy as np

from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_check_util import read_context_from_file
from tbe.tik.tik_lib.tik_params import CUR_FRAME_IDX
from tbe.tik.debug.statement import TikDebug
from tbe.tik.debug.intrinsic_print import PrintExpr

_MIN_ID_EXPECTED = 0


def get_block_nums(breakpoint_id, block_nums_result, break_block_map_from, break_block_map_to, op_str):
    """
    get the valid block nums from block_nums_result
    """
    valid_block_list = []  # for collect the valid block nums
    block_num_list = []
    for i in block_nums_result:
        # if the block in from, add the valid block list, and delete from the break_block_map_from
        if i in break_block_map_from[breakpoint_id]:
            break_block_map_from[breakpoint_id].remove(i)
            valid_block_list.append(i)
        else:
            if breakpoint_id in break_block_map_to.keys() and i in break_block_map_to[breakpoint_id]:
                print("[WARNING]: No need %s again, breakpoint %d has been %sd on block %d" %
                      (op_str, breakpoint_id, op_str, i))
            else:
                print("[WARNING]: breakpoint %d not set on block %d, cannot %s it" % (breakpoint_id, i, op_str))

    # if the valid_block_list is None, no need to do enable/disable operator
    if len(valid_block_list) == 0:
        return []

    # do enable/disable according the valid_block_list
    for i in valid_block_list:
        if breakpoint_id in break_block_map_to.keys():
            if i not in break_block_map_to[breakpoint_id]:
                break_block_map_to[breakpoint_id].append(i)
            block_num_list.append(i)
            print("[Info]: %s breakpoint %d for block %d" % (op_str, breakpoint_id, i))
        else:
            break_block_map_to[breakpoint_id] = valid_block_list
            block_num_list = valid_block_list
            print("[Info]: %s breakpoint %d for block %s" % (op_str, breakpoint_id, str(block_num_list)))
            break
    return block_num_list


class TikQuitDebugLoop(BaseException):
    """
    The Exception Object used for quiting Interactive mode
    """

    def __init__(self, msg=""):
        """
        Initalize class TikQuitDebugLoop.

        Parameters
        ----------
        msg:The message of TikQuitDebugLoop exception.

        Returns
        ----------
        No returns
        """
        super(TikQuitDebugLoop, self).__init__(msg)
        self.msg = msg
        self.quit_tik = False


class TikDebuggerInner(Cmd):
    """
    Class TikDebugger Inner instance
    """
    def __init__(self):
        """
        Initialize class TikDebugger inner
        """
        super(TikDebuggerInner, self).__init__(completekey='tab', stdin=None, stdout=None)
        # cache of file name
        self.fncache = {}
        self.current_ast_node = None
        self.current_ast_context = None
        self.args = None

        self.break_block_map = {}  # bind breakpoint_id with block index
        self.debug_info = {}

        self.tik_debug = TikDebug()
        self.break_points = []

    def print_msg(self, msg, block_num_list=None):
        """
        used to print msg, if has block info, show block info
        """
        if self.tik_debug.is_single_core:
            if self.tik_debug.block_index is None:
                print(msg)
            else:
                print(msg + " of block %d" % self.tik_debug.block_index)
        else:
            if block_num_list is None:
                if self.tik_debug.block_index is not None:
                    print(msg + " of block %d" % self.tik_debug.block_index)
                else:
                    print(msg)
            else:
                print(msg + " of block %s" % block_num_list)

    def do_print(self, args):
        """
        Debug command to print variables

        Parameters
        ----------
        args:Argument of print, Input an argument of print on console, to print variable.

        Returns
        ----------
        no return
        """
        if not args:
            print("[ERROR]: Invalid syntax. Expected usage:")
            print("    print <variable_name> ")
            return

        if not self.current_ast_node:
            msg = "[ERROR]: Invalid current AST node"
            self.print_msg(msg)
            return

        ret = self._get_print_expr(args)
        print(str(ret))

    def do_p(self, args):
        """
        Debug command to print variables

        Parameters
        ----------
        args:Argument of print, Input an argument of print on console, to print variable.

        Returns
        ----------
        do_print
        """
        return self.do_print(args)

    def do_print_ide(self, args):
        """
        Debug command to print variables for IDE

        Parameters
        ----------
        args:Argument of print_ide, Input an argument of print_ide on console, to print variable.

        Returns
        ----------
        no return
        """
        if not args:
            print("[ERROR]: Invalid syntax. Expected usage:")
            print("    print <variable_name> ")
            return

        if not self.current_ast_node:
            msg = "[ERROR]: Invalid current AST node"
            self.print_msg(msg)
            return

        ret = self._get_print_expr(args)
        print("**<print_ide> start**")
        if isinstance(ret, (int, float)):
            print({str(args): {'value': str(ret), 'shape': 'None', 'type': 'Scalar'}})
        elif isinstance(ret, list) and all((isinstance(i, (int, float))) for i in ret):
            print({str(args): {'value': str(ret), 'shape': str(len(ret)), 'type': 'ScalarArray'}})
        elif isinstance(ret, np.ndarray):
            print({str(args): {'value': str(ret.tolist()), 'shape': str(list(ret.shape)), 'type': 'Tensor'}})
        else:
            print(str(ret))
        print("**<print_ide> end**", flush=True)

    def do_where(self, args):
        """
        Debug command to query call stack

        Parameters
        args:Argument of where, Input an argument of querying call stack.

        Returns
        ----------
        no return
        """
        self.args = args
        self.dump_cal_stack()

    def do_w(self, args):
        """
        Debug command to query call stack

        Parameters
        args:Argument of where, Input an argument of querying call stack.

        Returns
        ----------
        do_where
        """
        return self.do_where(args)

    def do_quit(self, args):
        """
        Debug command to quit tik

        Parameters
        ----------
        args:Argument of quit, Input an argument of quit on console.

        Returns
        ----------
        no return
        """
        self.args = args
        exception = TikQuitDebugLoop("User Quit")
        exception.quit_tik = True
        raise exception

    def do_q(self, args):
        """
        Debug command to quit tik

        Parameters
        ----------
        args:Argument of quit, Input an argument of quit on console.

        Returns
        ----------
        do_quit
        """
        return self.do_quit(args)

    def do_dump_debug_info(self, args):
        """
        Debug command to show debug info

        Parameters
        ----------
        args:Argument of show debug information

        Returns
        ----------
        None
        """
        self.args = args
        if not self.debug_info:
            msg = "No debug info registered"
            self.print_msg(msg)
            return

        msg = "Dumping debug info..."
        self.print_msg(msg)
        num_ast_node = 0
        num_user_file = 0
        for filename, debug_info_list in self.debug_info.items():
            print("  filename: %s" % filename)
            for source_info, ast_node in debug_info_list:
                print("    line:%d ast_node:%s" %
                      (source_info[CUR_FRAME_IDX].get("line_no"),
                       type(ast_node)))
                num_ast_node += 1
            num_user_file += 1
            print("")
        print("# of AST node  =  %d" % num_ast_node)
        print("# of AST files =  %d" % num_user_file)
        msg = "Dumping debug info... Completed"
        self.print_msg(msg)

    def manipulate_break_point(self, id_string, action):
        """
        Manipuate breakpoints

        Parameters
        ----------
        id_string:The break point's id.

        action:Argument of action, This is the action of manipulating break point.

        Returns
        ----------
        the breakpoint or None value
        """
        ret = None
        id_expected = self._get_id_expected(id_string)
        if id_expected is None:
            return ret
        if id_expected < _MIN_ID_EXPECTED:
            msg = "[ERROR]: Invalid break point id: %d" % id_expected
            self.print_msg(msg)

        supported_action = ("enable", "disable", "delete")
        if action not in supported_action:
            print("[INFO]:supported actions are:")
            for act in supported_action:
                print(act)
            print("[ERROR]: Unsupported action to break points: %s" % action)
            return ret

        has_valid_id = False
        bp = None
        # enable/disable/delete all breakpoints with the same id.
        for target_bp in self.break_points:
            if target_bp.id == id_expected:
                bp = target_bp
                has_valid_id = True
                if action == "enable":
                    target_bp.enabled = True
                elif action == "disable":
                    target_bp.enabled = False
                elif action == "delete":
                    TikCheckUtil.check_is(target_bp.ast_node.break_point, target_bp)
                    target_bp.ast_node.break_point = None
                    self.break_points.remove(target_bp)
        if not has_valid_id:
            msg = "[ERROR]: Failed to find breakpoint with id=%d" % id_expected
            self.print_msg(msg)
            return ret
        return bp

    def canonic(self, filename):
        """
        Return canonical form of filename.

        Parameters
        ----------
        filename:Name of file that you select. The expect form is "<filename>".

        Returns
        ----------
        filename:The expect filename.
        canonic:absolute path of real filenames, is not the expect filename.

        """
        if filename is None:
            canonic = None
        else:
            if filename == ("<" + filename[1:-1] + ">"):
                canonic = filename
            else:
                canonic = self.fncache.get(filename)
                if not canonic:
                    canonic = os.path.realpath(filename)
                    canonic = os.path.normcase(canonic)
                    self.fncache[filename] = canonic
        return canonic

    def dump_cal_stack(self):
        """
        Used as a utlity to dump call stack from other functionality code

        Parameters
        ----------
        No parameters

        Returns
        ----------
        No returns
        """
        # Called within the debugger session
        TikCheckUtil.check_not_is(self.current_ast_node, None)

        ast_node = self.current_ast_node
        while ast_node:
            source_info = ast_node.source_info
            if not source_info:
                break

            if isinstance(source_info, list):
                print(read_context_from_file(
                    source_info[CUR_FRAME_IDX].get("filename"),
                    source_info[CUR_FRAME_IDX].get("line_no")))
                return  # only print current stack now
            ast_node = ast_node.parent

    def _get_print_expr(self, args):
        """
        Get the value of Scalar/Expr/Tensor

        Parameters
        ----------
        args:Argument of print, Input an argument of print on console, to print variable.

        Returns
        ----------
        The value of Scalar/Expr/Tensor
        """
        TikCheckUtil.check_not_is(self.current_ast_node, None)
        TikCheckUtil.check_not_is(self.current_ast_context, None)
        TikCheckUtil.check_not_is(
            self.current_ast_node.source_info[CUR_FRAME_IDX].get("sym_table"),
            None)

        print_obj = args

        symtable = copy.copy(
            self.current_ast_node.source_info[CUR_FRAME_IDX].get("sym_table"))

        ret = PrintExpr.get_print_expr(print_obj, symtable, self.current_ast_context)
        return ret

    def _get_breakpoint_by_id(self, id_expected):
        target_bp = None
        for break_point in self.break_points:
            if break_point.id == id_expected:
                target_bp = break_point
                break
        return target_bp

    def _get_id_expected(self, id_string):
        """
        id_string from str to int
        :param id_string: The break point's id.
        :return: the id_expected or None value
        """
        try:
            id_expected = int(id_string)
        except ValueError as exception:
            self.print_msg(str(exception))
            id_expected = None
        return id_expected
