#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     intrinsuc.py
DESC:     debug intrinsic
CREATED:  2019-7-04 20:12:13
MODIFIED: 2021-12-09 10:53:13
"""
import numpy as np
from tbe.common.platform import scope_ubuf
from tbe.common.platform import scope_gm
from tbe.common.platform import scope_wreg
from tbe.common.platform import scope_preg
from tbe.tik.common.util import TikUtil
from tbe.tik.common.common_util import is_scalar
from tbe.tik.common.common_util import is_tensor
from tbe.tik.common.common_util import is_vector_register
from tbe.tik.common.common_util import is_expr
from tbe.tik.common.common_util import is_scalar_array
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.util import copy_tensor_to_model
from tbe.tik.debug.util import get_dtype_size
from tbe.tik.debug.util import reinterpret_type
from tbe.tik.debug.sim.util import TempEnv
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_TIMES
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_7
from tbe.tik.tik_lib.tik_params import SHIFT_BIT_POS_11
from tbe.tik.tik_lib.tik_expr import get_float16_range_value

_DMA_SRC_BIN_ID = {
    'L0C16': '0b0000',
    'UB': '0b0001',
    'OUT': '0b0010',
    'L0C32': '0b0011',
    'L1': '0b0100',
    'L0C16V': '0b0101',
    'L0C32V': '0b0110',
    'L0CSC16': '0b0111',
    'L0CSC32': '0b1000',
    'L0CDPF16': '0b1001',
    'L0CDPF32': '0b1010'
}

_DMA_DST_BIN_ID = {
    'L0C16': '0b0000',
    'UB': '0b0001',
    'L1': '0b010',
    'OUT': '0b0011',
    'L0C32': '0b0100',
    'L0C16V': '0b0101',
    'L0C32V': '0b0110',
    'L0CSC32': '0b1001'
}

_DMA_SRC_BIN_ID_910B = {
    'L0C16': '0b0000',
    'UB': '0b0001',
    'OUT': '0b0010',
    'L0C32': '0b0011',
    'L1': '0b0100'
}

_DMA_DST_BIN_ID_910B = {
    'L0C16': '0b0000',
    'UB': '0b0001',
    'OUT': '0b010',
    'L0C32': '0b0011',
    'L1': '0b0100',
    "BT": '0b0101'
}

_L0C_SRC_16B_SCOPE_NAME = {
    'v': 'L0C16V',
    'm': 'L0C16',
    'dp': 'L0CDPF16',
}

_L0C_SRC_32B_SCOPE_NAME = {
    'v': 'L0C32V',
    'm': 'L0C32',
    'dp': 'L0CDPF32',
    'sc': 'L0CSC32'
}

_L0C_DST_16B_SCOPE_NAME = {
    'v': 'L0C16V',
    'm': 'L0C16',
}

_L0C_DST_32B_SCOPE_NAME = {
    'v': 'L0C32V',
    'm': 'L0C32',
    'sc': 'L0CSC32'
}

_SET_2D_DST_ID = {
    'L0A': 0b00,
    'L0B': 0b01,
    'L1': 0b10
}

_MAX_L0C16_DTYPE_SIZE = 2

BURST_SHIFT_BIT_POS = 16


def get_src_mem_id(src, is_tensor_addr=False):
    """
    get src_mem_id

    Parameters
    ----------
    src : src tensor or tensoraddrlist

    Returns
    -------
    src_mem_id
    """
    src_scope = TikUtil.get_storage_scope(src.scope)
    if is_tensor_addr:
        src_scope = TikUtil.get_storage_scope(scope_gm)

    # binary dtype -> int dtype
    if TikSocManager.is_310b_610l_soc() or TikSocManager.is_910b_soc():
        src_mem_id = int(_DMA_SRC_BIN_ID_910B.get(src_scope), 2)
    else:
        src_mem_id = int(_DMA_SRC_BIN_ID.get(src_scope), 2)

    return src_mem_id


def get_dst_mem_id(dst, is_tensor_addr=False):
    """
    get dst_mem_id

    Parameters
    ----------
    dst : dst tensor or tensoraddrlist

    Returns
    -------
    dst_mem_id
    """
    dst_scope = TikUtil.get_storage_scope(dst.scope)
    if is_tensor_addr:
        dst_scope = TikUtil.get_storage_scope(scope_gm)

    # binary dtype -> int dtype
    if TikSocManager.is_310b_610l_soc() or TikSocManager.is_910b_soc():
        dst_mem_id = int(_DMA_DST_BIN_ID_910B.get(dst_scope), 2)
    else:
        dst_mem_id = int(_DMA_DST_BIN_ID.get(dst_scope), 2)

    return dst_mem_id


def get_src_dst_mem_id(src, dst, block_mode='m'):
    """
    get dst_mem_id and src_mem_id

    Parameters
    ----------
    block_mode: block mode
    src : src scope

    dst : dst scope

    Returns
    -------
    src_mem_id, dst_mem_id
    """
    src_scope = TikUtil.get_storage_scope(src.scope)
    dst_scope = TikUtil.get_storage_scope(dst.scope)

    src_dtype_size = get_dtype_size(src.dtype)
    dst_dtype_size = get_dtype_size(dst.dtype)

    src_scope_name = src_scope
    if src_scope_name == 'L0C':
        if src_dtype_size <= _MAX_L0C16_DTYPE_SIZE:
            src_scope_name = _L0C_SRC_16B_SCOPE_NAME.get(block_mode)
        else:
            src_scope_name = _L0C_SRC_32B_SCOPE_NAME.get(block_mode)

    dst_scope_name = dst_scope
    if dst_scope_name == 'L0C':
        if dst_dtype_size <= _MAX_L0C16_DTYPE_SIZE:
            dst_scope_name = _L0C_DST_16B_SCOPE_NAME.get(block_mode)
        else:
            dst_scope_name = _L0C_DST_32B_SCOPE_NAME.get(block_mode)

    # binary dtype -> int dtype
    if TikSocManager.is_310b_610l_soc() or TikSocManager.is_910b_soc():
        src_mem_id = int(_DMA_SRC_BIN_ID_910B.get(src_scope_name), 2)
        dst_mem_id = int(_DMA_DST_BIN_ID_910B.get(dst_scope_name), 2)
    else:
        src_mem_id = int(_DMA_SRC_BIN_ID.get(src_scope_name), 2)
        dst_mem_id = int(_DMA_DST_BIN_ID.get(dst_scope_name), 2)

    return src_mem_id, dst_mem_id, src_scope_name


class Printf(STMT):
    """
    Printf debug statment
    """

    def __init__(self, source_info, fmt, tik_debugger, *args):
        super(Printf, self).__init__(source_info, tik_debugger)
        self.fmt = fmt
        self.args = args

    def eval_(self, context):
        """
        eval the printf statement.
        Parameters
        ----------
        context: the stack context.

        Returns
        -------
        no return
        """

        prev_str = self.get_pre_str(context)
        print(prev_str, end="")

    def get_pre_str(self, context):
        """
        get pre_str
        Returns
        -------
        """
        prev_str = ""
        format_contrl = False
        arg_index = 0
        format_str = ""
        for char in self.fmt:
            if char != "%" and format_contrl is False:
                prev_str = prev_str + char
            elif format_contrl is True:
                if char in ('0', '#'):
                    format_str = format_str + char
                if char in ('.', '1', '2', '3', '4', '5', '6', '7', '8', '9'):
                    format_str = format_str + char
                if char in ('d', 'f', 'o', 'x', 's', 'c'):
                    format_str = format_str + char
                    _print_value_for_printf(self.args[arg_index], prev_str, '%{}'.format(format_str), context)
                    arg_index += 1
                    prev_str = ""
                    format_contrl = False
                elif char == '%':
                    prev_str = prev_str + char
                    format_contrl = False
                    continue
            elif char == "%":
                format_contrl = True
                format_str = ''
        return prev_str


def _cast_vector(data, dtype):
    """
    Cast a vector buffer to print value.

    :param data: numpy buffer to cast
    :param dtype: vector data type
    :return: vector print value
    """
    result = data
    if dtype == "bool":
        # reinterpret_cast for preg (32 * uint8) to (8 * uint32)
        result = data.view("uint32")
    elif dtype == "int24":
        # cast for wreg (3 * n * uint8) to (n * int32), bits 24 to 32 fill with 0/1
        data = data.reshape(data.size // 3, 3)
        low = data[:, 0:2].reshape(-1).view("uint16")
        high = data[:, 2].view("int8").astype("int16").view("uint16")
        result = np.array([low, high]).T.reshape(-1).view("int32")
    elif dtype == "int48":
        # cast for wreg (3 * n * uint16) to (n * int64), bits 48 to 64 fill with 0/1
        data = data.reshape(data.size // 3, 3)
        low = data[:, 0:2].reshape(-1).view("uint32")
        high = data[:, 2].view("int16").astype("int32").view("uint32")
        result = np.array([low, high]).T.reshape(-1).view("int64")
    elif dtype == "int64":
        # cast for wreg (3 * n * uint32) to (n * int64), remove bits 64 to 96
        data = data.reshape(data.size // 3, 3)
        result = np.array([data[:, 0], data[:, 1]]).T.reshape(-1).view("int64")
    return result


def _print_value_for_printf(value, prev_str, format_str, context):
    """
    print the value
    Parameters
    ----------
    value : the value it will be print
    prev_str : the string in print format string which not include %d and so on
    format_str : the string include %d and so on.
    context : the stack context

    Returns
    -------
    None
    """
    print(prev_str, end="")
    if is_tensor(value):
        npbuff = context.get_value(value)
        buffer = npbuff.buffer
        first = True
        for ele in buffer.flat:
            if first is False:
                print(" ", end="")
            print(format_str % ele, end="")
            first = False
    elif is_vector_register(value):
        npbuff = context.get_vector_value(value)
        if value.scope == scope_wreg or value.scope == scope_preg:
            buffer = _cast_vector(npbuff.buffer, value.dtype)
        else:
            buffer = npbuff.buffer
        first = True
        for ele in buffer.flat:
            if first is False:
                print(" ", end="")
            print(format_str % ele, end="")
            first = False
    elif is_scalar(value) or is_expr(value):
        print_value = context.evaluate_expr(value)
        if value.dtype == "float16":
            print_value = get_float16_range_value(print_value)
        print(format_str % print_value, end="")
    elif is_scalar_array(value):
        _get_first_scalar_array(value, format_str, context)


def _get_first_scalar_array(value, format_str, context):
    """
    get first value by scalar_array
    """
    print_value = (context.evaluate_expr(value[i]) for i in range(value.length))
    first = True
    for ele in print_value:
        if value.dtype == "float16":
            ele = get_float16_range_value(ele)
        if first is False:
            print(" ", end="")
        print(format_str % ele, end="")
        first = False


class GetCtrlSPR(STMT):
    """
    GetCtrlSPR instruction
    """

    def __init__(self, source_info, spr_params, tik_debugger):
        scalar_arr, mask, begin = spr_params
        super(GetCtrlSPR, self).__init__(source_info, tik_debugger)
        self.scalar_arr = scalar_arr
        self.mask = mask
        self.begin = begin

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        self.update_debug_var(context)

    def update_debug_var(self, context):
        """
        update debug var
        Parameters
        ----------
        context tik context

        Returns
        -------
        """
        spr_value = context.model.read_spr('CTRL')
        # clear the bits first
        spr_value &= self.mask
        spr_value = spr_value >> self.begin
        offset = context.evaluate_expr(self.scalar_arr.offset)
        context.update_var(self.scalar_arr.debug_var[offset], spr_value)


class GetStatusSPR(STMT):
    """
    GetStatusSPR instruction
    """

    def __init__(self, source_info, spr_params, tik_debugger):
        scalar_arr, mask, begin = spr_params
        super(GetStatusSPR, self).__init__(source_info, tik_debugger)
        self.scalar_arr = scalar_arr
        self.mask = mask
        self.begin = begin

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        self.update_debug_var(context)

    def update_debug_var(self, context):
        """
        update debug var
        Parameters
        ----------
        context: tik context

        Returns
        -------

        """
        spr_value = context.model.read_spr('STATUS')
        # clear the bits first
        spr_value &= self.mask
        spr_value = spr_value >> self.begin
        offset = context.evaluate_expr(self.scalar_arr.offset)
        context.update_var(self.scalar_arr.debug_var[offset], spr_value)


class Set2D(STMT):
    """
    Set2D instruction
    """

    def __init__(self, source_info, set_2d_params, value=None, tik_debugger=None):
        dst, repeat_times = set_2d_params
        super(Set2D, self).__init__(source_info, tik_debugger)
        self.dst = dst
        self.repeat_time = repeat_times
        self.value = value

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        scope_name = TikUtil.get_storage_scope(self.dst.scope)
        dtype_size_ = get_dtype_size(self.dst.dtype)

        temp_env = TempEnv()

        dst_align = 512
        if scope_name == 'L1':
            dst_align = dtype_size_

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.dst, dst_align, access_mode='rw')

        if self.value is not None:
            value = context.evaluate_expr(self.value)
            bin_value = reinterpret_type(self.dst.dtype, 'uint16', value)
            context.model.write_spr('L0_SET_VALUE', bin_value)

        param = context.encoder.new_param()
        param.dstMemId = _SET_2D_DST_ID.get(scope_name)
        param.xd = xd_idx
        param.xm = self.create_gpr_x_t(context, temp_env)

        instr = context.encoder.gen_dma_set_2d(param)

        context.model.step(instr)
        temp_env.check_mem_access(context.model, False)

        context.model.read_memory(
            dst_addr, self.dst.scope, dst_ptr, dst_alloc_size)

    def create_gpr_x_t(self, context, temp_env):
        """
        create general purpose register x_t

        Parameters
        ----------
        context : the stack context

        temp_env : the temp environment

        Returns
        -------
        xm_idx
        """
        repeat = context.evaluate_expr(self.repeat_time)
        # check repeat
        TikCheckUtil.check_in_range_by_dtype(
            repeat, msg="repeat_times should be in the range of [%d, %d],"
            " input value is %s" % (0, MAX_REPEAT_TIMES, str(repeat)),
            var_range=[0, MAX_REPEAT_TIMES])

        xm_idx = temp_env.alloc_register()
        x_m = repeat
        context.model.write_gpr(xm_idx, x_m)

        return xm_idx


class LoadSmask(STMT):
    """
    winograd_weight_transform instruction
    """

    def __init__(self, source_info, loads_mask_params, tik_debugger):
        dst, src, load_size, sid = loads_mask_params
        super(LoadSmask, self).__init__(source_info, tik_debugger)
        self.dst = dst
        self.src = src
        self.load_size = load_size
        self.sid = sid

    def set_param(self, context, temp_env, xd_idx, xn_idx):
        """
        set param
        Parameters
        ----------
        context: context
        temp_env: temp_env
        xd_idx: xd idx
        xn_idx: xn idx

        Returns
        -------

        """
        x_t_11 = 0
        x_t_0 = context.evaluate_expr(self.load_size) & 127
        xt_idx = temp_env.alloc_register()
        x_t = x_t_0
        x_t |= context.evaluate_expr(self.sid) << SHIFT_BIT_POS_7
        x_t |= x_t_11 << SHIFT_BIT_POS_11
        context.model.write_gpr(xt_idx, x_t)

        ld_smask_src_mem_id = {
            scope_ubuf: 1,
            scope_gm: 0
        }

        param = context.encoder.new_param()
        param.xd = xd_idx
        param.xn = xn_idx
        param.xt = xt_idx
        param.srcMemId = ld_smask_src_mem_id.get(self.src.scope)
        return param

    def eval_(self, context):
        """
        eval the printf statement.
        Parameters
        ----------
        context: the stack context.

        Returns
        -------
        no return
        """
        src_align = 32
        dst_align = 32

        temp_env = TempEnv()
        xn_idx, _, _, _ = copy_tensor_to_model(context, temp_env, self.src,
                                               src_align, access_mode='r')

        xd_idx, dst_addr, dst_alloc_size, dst_ptr = copy_tensor_to_model(
            context, temp_env, self.dst, dst_align, access_mode='w')
        param = self.set_param(context, temp_env, xd_idx, xn_idx)
        instr = context.encoder.gen_dma_ld_smask(param)

        context.model.step(instr)
        temp_env.check_mem_access(context.model, True)
        context.model.read_memory(
            dst_addr, self.dst.scope, dst_ptr, dst_alloc_size)
