#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
FILE:     tik_high_preci_debug_.py
DESC:     debug of high preci api
CREATED:  2021-12-18 11:02:42
MODIFIED: 2021-12-18 11:17:00
"""
from collections import namedtuple
from tbe.tik.common.common_nametuple_util import Fp162Fp32HighPreciApi
from tbe.tik.common.util import get_bit_len
from tbe.tik.common.util import ceil_div
from tbe.tik.common.util import check_scalar_dtype
from tbe.tik.common.check_over_high_preci_common import check_over_high_preci
from tbe.tik.common.common_util import vector_max_offset_cal
from tbe.tik.debug.simd import eval_mask
from tbe.tik.debug.tik_vector_ops_debug.tik_common_high_preci_debug import fp162fp32_high_preci_func
from tbe.tik.debug.statement import STMT
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_spr_debug_ import MoveTensor2CMPMASK
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_spr_debug_ import MoveCMPMASK2Tensor
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug_ import NewVectorOnlyTemplate
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug_ import NewVectorScalarTemplate
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_fills_debug_ import NewVectorScalarEltwise
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_compare_debug_ import NewVcmp
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_debug_ import NewVectorVectorTemplate
from tbe.tik.debug.tik_vector_ops_debug.tik_vector_compare_debug_ import Vsel
from tbe.tik.debug.util import set_vector_mask
from tbe.tik.common.common_nametuple_util import HighPreciDebug
from tbe.tik.common.common_nametuple_util import OverHighApi
from tbe.tik.common.common_nametuple_util import VlnComputePreci
from tbe.tik.common.common_nametuple_util import VlnComputeBlockPreci
from tbe.tik.common.common_nametuple_util import VecSingleApi
from tbe.tik.common.common_nametuple_util import VecDupApi
from tbe.tik.common.common_nametuple_util import VecScalarMultisApi
from tbe.tik.common.common_nametuple_util import VecVcmpApi
from tbe.tik.common.common_nametuple_util import VecMultiApi
from tbe.tik.common.common_nametuple_util import VecVselApi
from tbe.tik.tik_lib.tik_params import MIN_STRIDE
from tbe.tik.tik_lib.tik_params import DEFAULT_STRIDE
from tbe.tik.tik_lib.tik_params import MIN_STRIDE_UNIT
from tbe.tik.tik_lib.tik_params import MAX_REPEAT_TIMES
from tbe.tik.tik_lib.tik_params import MAX_REP_STRIDE_SINGLE_BYTE
from tbe.tik.tik_lib.tik_params import ONE_REP_BYTE_SIZE
from tbe.tik.tik_lib.tik_params import CONST_FIVE_THREE
from tbe.tik.tik_lib.tik_params import CONST_ONE_THREE
from tbe.tik.tik_lib.tik_params import CONST_NEG_FOUR_THREE
from tbe.tik.tik_lib.tik_params import LOG_FOUR_THREE
from tbe.tik.tik_lib.tik_params import CONST_NEG_ONE
from tbe.tik.tik_lib.tik_params import CONST_ONE
from tbe.tik.tik_lib.tik_params import CONST_HALF
from tbe.tik.tik_lib.tik_params import CONST_THREE_FOUR
from tbe.tik.tik_lib.tik_params import CONST_ONE_FIVE
from tbe.tik.tik_lib.tik_params import CONST_NEG_ONE_FOUR
from tbe.tik.tik_lib.tik_params import CONST_NEG_HALF
from tbe.tik.tik_lib.tik_params import CONST_ONE_NINE
from tbe.tik.tik_lib.tik_params import CONST_NEG_ONE_EIGHT
from tbe.tik.tik_lib.tik_params import CONST_ONE_SEVEN
from tbe.tik.tik_lib.tik_params import CONST_NEG_ONE_SIX
from tbe.tik.tik_lib.tik_check_util import TikCheckUtil
from tbe.tik.tik_lib.tik_expr import BasicExpr
from tbe.tik.tik_lib.tik_soc_manager import TikSocManager
from tbe.tik.tik_lib.tik_vector_api.tik_vector_fills_api_ import DupOpApi
from tbe.tik.tik_lib.tik_vector_api.tik_vector_compare_api_ import VcmpOpApi
from tbe.tik.tik_lib.tik_vector_api.tik_vector_compare_api_ import VselOpApi
from tbe.tik.tik_lib.tik_vector_api.tik_vector_single_api_ import SingleOpApi
from tbe.tik.tik_lib.tik_vector_api.tik_scalar_multis_api_ import ScalarMultisOps
from tbe.tik.tik_lib.tik_vector_api.tik_vector_multi_api_ import MultiOp


class VrsqrtHighPreci(STMT):
    """
    this stmt for vrsqrt high precision
    """

    def __init__(self, source_info, vrsqrt_high_params, tik_ins):
        super(VrsqrtHighPreci, self).__init__(source_info, tik_ins.context.tik_debugger)
        self.name = "vec_rsqrt_high_preci"
        self.mask = vrsqrt_high_params.mask
        self.dst = vrsqrt_high_params.dst
        self.src = vrsqrt_high_params.src
        self.work_tensor = vrsqrt_high_params.work_tensor
        self.repeat_times = vrsqrt_high_params.repeat_times
        self.dst_rep_stride = vrsqrt_high_params.dst_rep_stride
        self.src_rep_stride = vrsqrt_high_params.src_rep_stride
        self.context = None
        if TikSocManager.is_v300_610l_soc():
            self.source_id = tik_ins.context.debug_source_id

    def eval_(self, context):
        """
        exce instr
        """
        self.context = context

        set_vector_mask(self.mask, context, tensor_bit_len=max(get_bit_len(self.src.dtype),
                                                               get_bit_len(self.dst.dtype)))
        mask = eval_mask(self.mask, context)
        multi_factor = 3
        if TikSocManager.is_mini_soc():
            multi_factor = 4
        if self.src.dtype == "float16":
            # 4B of fp32, need keep 32B align
            multi_factor += 2
        # step for check params, overflow, overlap
        self._check_params(context, mask, multi_factor)
        if self.src.dtype == "float16":
            # vconv: fp16->fp32
            if TikSocManager.is_mini_soc():
                # debug mini
                # new mask, stride and repeat!!!!!!!!!!!
                fp162fp32_high_preci_params = Fp162Fp32HighPreciApi(
                    self.source_info, context, self._vrsqrt_hmini, mask, self.dst, self.src, self.work_tensor,
                    context.evaluate_expr(self.repeat_times), context.evaluate_expr(self.dst_rep_stride),
                    context.evaluate_expr(self.src_rep_stride), multi_factor, self.name)
                fp162fp32_high_preci_func(self, fp162fp32_high_preci_params)
            else:
                # debug cloud
                # new mask, stride and repeat!!!!!!!!!!!
                fp162fp32_high_preci_params = Fp162Fp32HighPreciApi(
                    self.source_info, context, self.vrsqrt_hcloud, mask, self.dst, self.src, self.work_tensor,
                    context.evaluate_expr(self.repeat_times), context.evaluate_expr(self.dst_rep_stride),
                    context.evaluate_expr(self.src_rep_stride), multi_factor, self.name)
                fp162fp32_high_preci_func(self, fp162fp32_high_preci_params)
            return

        block_len = ONE_REP_BYTE_SIZE // get_bit_len(self.src.dtype)
        src_extend = vector_max_offset_cal((mask, self.src.dtype, block_len, context.evaluate_expr(self.repeat_times),
                                            1, context.evaluate_expr(self.src_rep_stride)))
        tensor_split_size = ceil_div(src_extend, block_len) * block_len
        params = \
            mask, self.dst, self.src, self.work_tensor, context.evaluate_expr(self.repeat_times), \
            context.evaluate_expr(self.dst_rep_stride), context.evaluate_expr(self.src_rep_stride), \
            tensor_split_size
        if TikSocManager.is_mini_soc():
            # mini
            self._vrsqrt_hmini(context, params)
        else:
            # cloud and others
            self.vrsqrt_hcloud(context, params)

    def vrsqrt_hcloud(self, context, params):
        """
        high preci for cloud
        """
        mask, dst, src, work_tensor, repeat_times, dst_rep_stride, src_rep_stride, tensor_split_size = params

        # cloud
        vrsqrt_obj = VecSingleApi(self.name, mask, work_tensor[0:tensor_split_size], src, repeat_times, 1, 1,
                                  src_rep_stride, src_rep_stride, 0, 'vsqrt')

        vrsqrt_obj = SingleOpApi(self, vrsqrt_obj)
        vsqrt_stmt = NewVectorOnlyTemplate(self.source_info, vrsqrt_obj, context.tik_debugger)
        vsqrt_stmt.eval_(context)

        # vrec newton debug
        high_preci = HighPreciDebug(mask, dst, work_tensor[0:tensor_split_size], work_tensor[tensor_split_size:],
                                      repeat_times, dst_rep_stride, src_rep_stride, "vec_rsqrt_high_preci")
        hvrec_stmt_ = VrecHighPreci(self.source_info, high_preci, context.tik_debugger)
        hvrec_stmt_.eval_(context)

    def _check_params(self, context, mask, multi_factor):
        TikCheckUtil.check_in_range_by_dtype(
            context.evaluate_expr(self.repeat_times),
            msg="repeat_times should be in the range of [%d, %d], input repeat_times is %s"
            % (0, MAX_REPEAT_TIMES, context.evaluate_expr(self.repeat_times)), var_range=[0, MAX_REPEAT_TIMES])
        check_vector_stride({'dst_rep_stride': context.evaluate_expr(self.dst_rep_stride),
                             'src_rep_stride': context.evaluate_expr(self.src_rep_stride)})
        over_high_params = OverHighApi(
            mask, self.dst, self.src, self.work_tensor,
            context.evaluate_expr(self.repeat_times), context.evaluate_expr(self.dst_rep_stride),
            context.evaluate_expr(self.src_rep_stride), context.evaluate_expr(self.dst.offset),
            context.evaluate_expr(self.src.offset), context.evaluate_expr(self.work_tensor.offset),
            multi_factor, name="vec_rsqrt_high_preci")
        check_over_high_preci(over_high_params)

    def _vrsqrt_hmini_debug(self, context, params_list):
        """
        vrsqrt hmini debug
        Parameters
        ----------
        context: tik context
        params_list: params list

        Returns
        -------

        """
        mask, dst, src, repeat_times, dst_rep_stride, src_rep_stride = params_list
        vrsqrt_obj = VecSingleApi(self.name, mask, dst, src, repeat_times, 1,
                                  1, dst_rep_stride, src_rep_stride, 0, 'vrsqrt')

        vrsqrt_obj = SingleOpApi(self, vrsqrt_obj)
        vrsqrt_stmt = NewVectorOnlyTemplate(self.source_info, vrsqrt_obj, context.tik_debugger)
        vrsqrt_stmt.eval_(context)

    def _vmulti_hmini_debug(self, context, params_list, api_name):
        """
        vmulti hmini debug
        Parameters
        ----------
        context: tik context
        params_list：params list
        api_name: api name

        Returns
        -------

        """
        vec_vmulti_obj = VecMultiApi(self.name, *params_list, api_name)
        vec_vmulti_obj = MultiOp(self, vec_vmulti_obj)
        v_multi_stmt = NewVectorVectorTemplate(self.source_info, vec_vmulti_obj, context.tik_debugger)
        v_multi_stmt.eval_(context)

    def _vrsqrt_hmini(self, context, params):
        """
        high preci for mini
        """
        params_ins = \
            namedtuple("VrsqrtParams",
                       "mask dst src work_tensor repeat_times dst_rep_stride src_rep_stride tensor_split_size")(*params)
        # mini debug
        self._vrsqrt_hmini_debug(
            context, (params_ins.mask, params_ins.dst, params_ins.src,
                      params_ins.repeat_times, params_ins.dst_rep_stride,
                      params_ins.src_rep_stride))

        for _ in range(2):
            self._vmulti_hmini_debug(
                context, (params_ins.mask, params_ins.work_tensor[0:params_ins.tensor_split_size],
                          params_ins.src, params_ins.dst, params_ins.repeat_times, 1,
                          1, 1, params_ins.src_rep_stride, params_ins.src_rep_stride,
                          params_ins.dst_rep_stride, 0), "vmul")

            high_preci = HighPreciDebug(
                params_ins.mask,
                params_ins.work_tensor[params_ins.tensor_split_size:2 * params_ins.tensor_split_size],
                params_ins.work_tensor[0:params_ins.tensor_split_size],
                params_ins.work_tensor[2 * params_ins.tensor_split_size:],
                params_ins.repeat_times, params_ins.src_rep_stride, params_ins.src_rep_stride, self.name)
            hvrec_stmt_ = VrecHighPreci(self.source_info, high_preci, context.tik_debugger)
            hvrec_stmt_.eval_(context)
            self._vmulti_hmini_debug(
                context, (params_ins.mask, params_ins.work_tensor[0:params_ins.tensor_split_size], params_ins.dst,
                          params_ins.work_tensor[params_ins.tensor_split_size:2 * params_ins.tensor_split_size],
                          params_ins.repeat_times, 1, 1,
                          1, params_ins.src_rep_stride, params_ins.dst_rep_stride,
                          params_ins.src_rep_stride, 0), "vadd")

            vec_vmultis_obj = VecScalarMultisApi(self.name, params_ins.mask, params_ins.dst,
                                                 params_ins.work_tensor[0:params_ins.tensor_split_size],
                                                 0.5, params_ins.repeat_times, 1, 1, params_ins.dst_rep_stride,
                                                 params_ins.src_rep_stride,
                                                 0, 0, "normal", "vmuls")
            vec_vmultis_obj = ScalarMultisOps(self, vec_vmultis_obj)
            vmuls_stmt_ = NewVectorScalarTemplate(self.source_info, vec_vmultis_obj, context.tik_debugger)
            vmuls_stmt_.eval_(context)


class VlnHighPreci(STMT):
    """
    this stmt for vln high precision
    """

    def __init__(self, source_info, op_obj, tik_debugger):
        super(VlnHighPreci, self).__init__(source_info, tik_debugger)
        self.name = "vec_ln_high_preci"
        self.mask = op_obj.mask
        self.dst = op_obj.dst
        self.src = op_obj.src
        self.work_tensor = op_obj.work_tensor
        self.repeat_times = op_obj.repeat_times
        self.dst_rep_stride = op_obj.dst_rep_stride
        self.src_rep_stride = op_obj.src_rep_stride
        self.default_blk_stride = 1
        self.stride_unit = 0
        self.blk_data_nums = 16
        self.context = None

    def eval_(self, context):
        """
        instr eval
        """
        self.context = context
        repeat_times = context.evaluate_expr(self.repeat_times)
        src_rep_stride = context.evaluate_expr(self.src_rep_stride)
        dst_rep_stride = context.evaluate_expr(self.dst_rep_stride)
        set_vector_mask(self.mask, context, tensor_bit_len=max(get_bit_len(self.src.dtype),
                                                               get_bit_len(self.dst.dtype)))
        mask = eval_mask(self.mask, context)

        # check params
        TikCheckUtil.check_in_range_by_dtype(
            repeat_times, msg="repeat_times should be in the range of [%d, %d], but input repeat_times: %d"
            % (0, MAX_REPEAT_TIMES, repeat_times), var_range=[0, MAX_REPEAT_TIMES])
        TikCheckUtil.check_in_range_by_dtype(
            src_rep_stride, msg="src_rep_stride should be in the range of [%d, %d], but input src_rep_stride: %d"
            % (DEFAULT_STRIDE, MAX_REP_STRIDE_SINGLE_BYTE, src_rep_stride),
            var_range=[DEFAULT_STRIDE, MAX_REP_STRIDE_SINGLE_BYTE])
        TikCheckUtil.check_in_range_by_dtype(
            dst_rep_stride, msg="dst_rep_stride should be in the range of [%d, %d], but input dst_rep_stride: %d"
            % (DEFAULT_STRIDE, MAX_REP_STRIDE_SINGLE_BYTE, dst_rep_stride),
            var_range=[DEFAULT_STRIDE, MAX_REP_STRIDE_SINGLE_BYTE])

        src_offset = src_rep_stride * self.blk_data_nums
        src_data_size = ceil_div(vector_max_offset_cal((mask, self.src.dtype,
                                                        ONE_REP_BYTE_SIZE // get_bit_len(self.src.dtype),
                                                        repeat_times, 1,
                                                        src_rep_stride)), self.blk_data_nums) * self.blk_data_nums

        multi_factor = 10
        over_high_params = OverHighApi(mask, self.dst, self.src, self.work_tensor, repeat_times, dst_rep_stride,
                                       src_rep_stride, context.evaluate_expr(self.dst.offset),
                                       context.evaluate_expr(self.src.offset),
                                       context.evaluate_expr(self.work_tensor.offset), multi_factor, name=self.name)
        check_over_high_preci(over_high_params)

        vln_compute_tuple = VlnComputePreci(context, mask, self.work_tensor[:src_data_size], self.src,
                                            self.work_tensor[src_data_size:src_data_size * 5], repeat_times,
                                            src_rep_stride, src_data_size, src_offset)
        self._ln_compute_block_lt_5_3_gt_1(vln_compute_tuple)
        compute_block_tuple = VlnComputeBlockPreci(
            context, mask, self.work_tensor[src_data_size * 4:src_data_size * 5],
            self.work_tensor[:src_data_size], self.src, self.work_tensor[src_data_size:src_data_size * 3], repeat_times,
            src_rep_stride, src_data_size, src_offset)
        self._ln_compute_block_gt_5_3(compute_block_tuple)

        compute_block_tuple = VlnComputeBlockPreci(context, mask, self.work_tensor[0:src_data_size],
                                                   self.work_tensor[src_data_size * 4:src_data_size * 5], self.src,
                                                   self.work_tensor[src_data_size:src_data_size * 4], repeat_times,
                                                   src_rep_stride, src_data_size, src_offset)
        self.ln_compute_block_gt_half_lt_1(compute_block_tuple)
        vln_half_compute_tuple = VlnComputeBlockPreci(context, mask, self.dst, self.work_tensor[:src_data_size],
                                                      self.src, self.work_tensor[src_data_size:], repeat_times,
                                                      src_rep_stride, src_data_size, src_offset)
        self._ln_compute_block_lt_half(vln_half_compute_tuple)

    def ln_compute_block_gt_half_lt_1(self, compute_op):
        """
        calculate extent

        Parameters
        ----------
        compute_op : a params class

        Returns
        -------
        None
        """
        # vadds
        multis_api = VecScalarMultisApi(self.name, compute_op.mask, compute_op.tmp_work_tensor, compute_op.src_data,
                                        CONST_NEG_ONE, compute_op.repeat_times, self.default_blk_stride,
                                        self.default_blk_stride, compute_op.src_rep_stride,
                                        compute_op.src_rep_stride, self.stride_unit, 0, "normal", "vadds")
        vadds_stmt_ = NewVectorScalarTemplate(self.source_info,
                                              ScalarMultisOps(self, multis_api), compute_op.context.tik_debugger)
        vadds_stmt_.eval_(compute_op.context)

        self._taylor_compute_nine((
            compute_op.context, compute_op.mask,
            compute_op.tmp_work_tensor[compute_op.src_data_size:compute_op.src_data_size * 2],
            compute_op.tmp_work_tensor,
            compute_op.tmp_work_tensor[compute_op.src_data_size * 2:compute_op.src_data_size * 3],
            compute_op.repeat_times, compute_op.src_rep_stride))

        # vector_dup
        multis_api = VecDupApi(self.name, compute_op.mask, compute_op.tmp_work_tensor, CONST_ONE,
                               compute_op.repeat_times, self.default_blk_stride, compute_op.src_rep_stride,
                               self.stride_unit, "normal", "vector_dup")
        vector_dup_stmt = NewVectorScalarEltwise(self.source_info,
                                                 DupOpApi(self, multis_api), compute_op.context.tik_debugger)
        vector_dup_stmt.eval_(compute_op.context)

        for index in range(compute_op.repeat_times):
            # vcmp_le
            multis_api = VecVcmpApi(self.name, compute_op.mask, compute_op.src_data[index * compute_op.src_offset],
                                    compute_op.tmp_work_tensor[index * compute_op.src_offset],
                                    self.default_blk_stride, self.default_blk_stride, 'vcmp_le')
            vcmd_stmt = NewVcmp(self.source_info, VcmpOpApi(self, multis_api), compute_op.context.tik_debugger)
            vcmd_stmt.eval_(compute_op.context)
            # vsel
            multis_api = VecVselApi(
                compute_op.mask, 0, compute_op.dst_data[index * compute_op.src_offset], vcmd_stmt,
                compute_op.tmp_work_tensor[compute_op.src_data_size + index * compute_op.src_offset],
                compute_op.tmp_dst_data[index * compute_op.src_offset], 1, self.default_blk_stride,
                self.default_blk_stride, self.default_blk_stride, compute_op.src_rep_stride, compute_op.src_rep_stride,
                compute_op.src_rep_stride, self.name, None, "vsel")
            vsel_stmt = Vsel(self.source_info, VselOpApi(self, multis_api), compute_op.context.tik_debugger)
            vsel_stmt.eval_(compute_op.context)

    def _vadds_vmul(self, vadds_vmul_tuple):
        context, mask, dst_data, src_data, tmp_work_tensor, scalar_value, repeat_times, src_rep_stride = \
            vadds_vmul_tuple
        # vadds
        multis_api = VecScalarMultisApi(self.name, mask, tmp_work_tensor, dst_data, scalar_value,
                                        repeat_times, self.default_blk_stride, self.default_blk_stride,
                                        src_rep_stride, src_rep_stride, self.stride_unit, 0, "normal", "vadds")
        vadds_stmt_ = NewVectorScalarTemplate(self.source_info, ScalarMultisOps(self, multis_api), context.tik_debugger)
        vadds_stmt_.eval_(context)
        # vmul
        multis_api = VecMultiApi(self.name, mask, dst_data, src_data, tmp_work_tensor,
                                 repeat_times, self.default_blk_stride, self.default_blk_stride,
                                 self.default_blk_stride, src_rep_stride, src_rep_stride, src_rep_stride,
                                 self.stride_unit, "vmul")
        vmul_stmt0_ = NewVectorVectorTemplate(self.source_info, MultiOp(self, multis_api), context.tik_debugger)
        vmul_stmt0_.eval_(context)

    def _taylor_compute_five(self, taylor_compute_five_tuple):
        context, mask, dst_data, src_data, tmp_work_tensor, repeat_times, src_rep_stride = taylor_compute_five_tuple

        # vmuls
        multis_api = VecScalarMultisApi(self.name, mask, dst_data, src_data, CONST_ONE_FIVE,
                                        repeat_times, self.default_blk_stride, self.default_blk_stride,
                                        src_rep_stride, src_rep_stride, self.stride_unit, 0, "normal", "vmuls")
        vmuls_stmt_ = NewVectorScalarTemplate(self.source_info, ScalarMultisOps(self, multis_api), context.tik_debugger)
        vmuls_stmt_.eval_(context)

        self._vadds_vmul((context, mask, dst_data, src_data,
                          tmp_work_tensor, CONST_NEG_ONE_FOUR,
                          repeat_times, src_rep_stride))
        self._vadds_vmul((context, mask, dst_data, src_data,
                          tmp_work_tensor, CONST_ONE_THREE,
                          repeat_times, src_rep_stride))
        self._vadds_vmul((context, mask, dst_data, src_data,
                          tmp_work_tensor, CONST_NEG_HALF,
                          repeat_times, src_rep_stride))
        self._vadds_vmul((context, mask, dst_data, src_data,
                          tmp_work_tensor, CONST_ONE,
                          repeat_times, src_rep_stride))

    def _taylor_compute_nine(self, taylor_compute_nine_tuple):
        context, mask, dst_data, src_data, tmp_work_tensor, repeat_times, src_rep_stride = taylor_compute_nine_tuple

        # vmuls
        multis_api = VecScalarMultisApi(self.name, mask, dst_data, src_data, CONST_ONE_NINE,
                                        repeat_times, self.default_blk_stride, self.default_blk_stride,
                                        src_rep_stride, src_rep_stride, self.stride_unit, 0, "normal", "vmuls")
        vmuls_stmt_ = NewVectorScalarTemplate(self.source_info, ScalarMultisOps(self, multis_api), context.tik_debugger)
        vmuls_stmt_.eval_(context)

        self._vadds_vmul((context, mask, dst_data, src_data, tmp_work_tensor,
                          CONST_NEG_ONE_EIGHT, repeat_times, src_rep_stride))
        self._vadds_vmul((context, mask, dst_data, src_data, tmp_work_tensor, CONST_ONE_SEVEN,
                          repeat_times, src_rep_stride))
        self._vadds_vmul((context, mask, dst_data, src_data, tmp_work_tensor, CONST_NEG_ONE_SIX,
                          repeat_times, src_rep_stride))
        self._vadds_vmul((context, mask, dst_data, src_data, tmp_work_tensor, CONST_ONE_FIVE,
                          repeat_times, src_rep_stride))
        self._vadds_vmul((context, mask, dst_data, src_data, tmp_work_tensor, CONST_NEG_ONE_FOUR,
                          repeat_times, src_rep_stride))
        self._vadds_vmul((context, mask, dst_data, src_data, tmp_work_tensor, CONST_ONE_THREE,
                          repeat_times, src_rep_stride))
        self._vadds_vmul((context, mask, dst_data, src_data, tmp_work_tensor, CONST_NEG_HALF,
                          repeat_times, src_rep_stride))
        self._vadds_vmul((context, mask, dst_data, src_data, tmp_work_tensor, CONST_ONE,
                          repeat_times, src_rep_stride))

    def _compute_block_lt_5_3_gt_1_dup(self, compute_op):
        # const_neg_one + const_neg_one * const_log_threshold_2
        # vadds
        multis_api = VecScalarMultisApi(self.name, compute_op.mask,
                                        compute_op.tmp_work_tensor[0:compute_op.src_data_size], compute_op.src_data,
                                        CONST_NEG_FOUR_THREE, compute_op.repeat_times, self.default_blk_stride,
                                        self.default_blk_stride, compute_op.src_rep_stride,
                                        compute_op.src_rep_stride, self.stride_unit, 0, "normal", "vadds")
        vadds_stmt_ = NewVectorScalarTemplate(self.source_info,
                                              ScalarMultisOps(self, multis_api), compute_op.context.tik_debugger)
        vadds_stmt_.eval_(compute_op.context)
        # vmuls
        multis_api = VecScalarMultisApi(self.name, compute_op.mask,
                                        compute_op.tmp_work_tensor[
                                        compute_op.src_data_size:compute_op.src_data_size * 2],
                                        compute_op.tmp_work_tensor[0:compute_op.src_data_size], CONST_THREE_FOUR,
                                        compute_op.repeat_times, self.default_blk_stride, self.default_blk_stride,
                                        compute_op.src_rep_stride, compute_op.src_rep_stride, self.stride_unit, 0,
                                        "normal", "vmuls")
        vmuls_stmt_ = NewVectorScalarTemplate(self.source_info,
                                              ScalarMultisOps(self, multis_api), compute_op.context.tik_debugger)
        vmuls_stmt_.eval_(compute_op.context)
        # vector_dup
        multis_api = VecDupApi(self.name, compute_op.mask,
                               compute_op.tmp_work_tensor[compute_op.src_data_size * 2:compute_op.src_data_size * 3],
                               CONST_ONE_THREE, compute_op.repeat_times, self.default_blk_stride,
                               compute_op.src_rep_stride, self.stride_unit, "normal", "vector_dup")
        vector_dup_stmt = NewVectorScalarEltwise(self.source_info,
                                                 DupOpApi(self, multis_api), compute_op.context.tik_debugger)

        vector_dup_stmt.eval_(compute_op.context)

    def _compute_block_lt_5_3_gt_1_vadds(self, compute_op):
        # vadds
        multis_api = VecScalarMultisApi(
            self.name, compute_op.mask,
            compute_op.tmp_work_tensor[compute_op.src_data_size:compute_op.src_data_size * 2],
            compute_op.tmp_work_tensor[0:compute_op.src_data_size], LOG_FOUR_THREE, compute_op.repeat_times,
            self.default_blk_stride, self.default_blk_stride, compute_op.src_rep_stride,
            compute_op.src_rep_stride, self.stride_unit, 0, "normal", "vadds")
        vadds_stmt_ = NewVectorScalarTemplate(self.source_info,
                                              ScalarMultisOps(self, multis_api), compute_op.context.tik_debugger)
        vadds_stmt_.eval_(compute_op.context)

    def _ln_compute_block_lt_5_3_gt_1(self, compute_op):

        self._compute_block_lt_5_3_gt_1_dup(compute_op)

        tmp_mask_len, tmp_mask_offset = 0, 8
        if compute_op.src_rep_stride != 0:
            tmp_mask_len = 2
            tmp_mask_offset = compute_op.repeat_times * 8
        endindex = compute_op.src_data_size * 3 + tmp_mask_offset
        tmp_tensor = compute_op.tmp_work_tensor[compute_op.src_data_size * 3:endindex].reinterpret_cast_to("uint64")

        # vadds
        multis_api = VecScalarMultisApi(self.name, compute_op.mask,
                                        compute_op.tmp_work_tensor, compute_op.src_data,
                                        CONST_NEG_ONE, compute_op.repeat_times, self.default_blk_stride,
                                        self.default_blk_stride, compute_op.src_rep_stride,
                                        compute_op.src_rep_stride, self.stride_unit, 0, "normal", "vadds")
        vadds_stmt1 = NewVectorScalarTemplate(self.source_info,
                                              ScalarMultisOps(self, multis_api), compute_op.context.tik_debugger)
        vadds_stmt1.eval_(compute_op.context)

        for index in range(compute_op.repeat_times):
            # vcmp_ge
            multis_api = VecVcmpApi(self.name, compute_op.mask,
                                    compute_op.tmp_work_tensor[index * compute_op.src_offset],
                                    compute_op.tmp_work_tensor[
                                        compute_op.src_data_size * 2 + index * compute_op.src_offset],
                                    self.default_blk_stride, self.default_blk_stride, 'vcmp_ge')
            vcmd_stmt = NewVcmp(self.source_info, VcmpOpApi(self, multis_api), compute_op.context.tik_debugger)
            vcmd_stmt.eval_(compute_op.context)

            cmpmask_stmt = MoveCMPMASK2Tensor(self.source_info,
                                              tmp_tensor[index * tmp_mask_len], compute_op)
            cmpmask_stmt.eval_(compute_op.context)
            # vsel
            multis_api = VecVselApi(
                compute_op.mask, 0, compute_op.dst_data[index * compute_op.src_offset],
                vcmd_stmt, compute_op.tmp_work_tensor[compute_op.src_data_size + index * compute_op.src_offset],
                compute_op.tmp_work_tensor[index * compute_op.src_offset], 1, self.default_blk_stride,
                self.default_blk_stride, self.default_blk_stride, compute_op.src_rep_stride, compute_op.src_rep_stride,
                compute_op.src_rep_stride, self.name, None, "vsel")
            vsel_stmt = Vsel(self.source_info, VselOpApi(self, multis_api), compute_op.context.tik_debugger)
            vsel_stmt.eval_(compute_op.context)

        self._taylor_compute_five((
            compute_op.context, compute_op.mask, compute_op.tmp_work_tensor[0:compute_op.src_data_size],
            compute_op.dst_data, compute_op.tmp_work_tensor[compute_op.src_data_size * 2:compute_op.src_data_size * 3],
            compute_op.repeat_times, compute_op.src_rep_stride))

        # phase3: add log(4/3)
        self._ln_compute_block_lt_phase3(compute_op, tmp_tensor, tmp_mask_len)

    def _ln_compute_block_lt_phase3(self, compute_op, tmp_tensor, tmp_mask_len):
        """
        ln compute block lt phase3
        Parameters
        ----------
        compute_op: compute operator
        tmp_tensor: temp tensor
        tmp_mask_len: temp mask length

        Returns
        -------

        """
        self._compute_block_lt_5_3_gt_1_vadds(compute_op)

        for index in range(compute_op.repeat_times):
            cmpmask_stmt = MoveTensor2CMPMASK(self.source_info,
                                              tmp_tensor[index * tmp_mask_len], compute_op)
            cmpmask_stmt.eval_(compute_op.context)
            # vsel
            multis_api = VecVselApi(
                compute_op.mask, 0, compute_op.dst_data[index * compute_op.src_offset],
                cmpmask_stmt, compute_op.tmp_work_tensor[compute_op.src_data_size + index * compute_op.src_offset],
                compute_op.tmp_work_tensor[index * compute_op.src_offset], 1, self.default_blk_stride,
                self.default_blk_stride, self.default_blk_stride, compute_op.src_rep_stride, compute_op.src_rep_stride,
                compute_op.src_rep_stride, self.name, None, "vsel")
            vsel_stmt = Vsel(self.source_info, VselOpApi(self, multis_api), compute_op.context.tik_debugger)
            vsel_stmt.eval_(compute_op.context)

    def _ln_compute_block_gt_5_3(self, compute_op):
        """
        when src_data > 5/3, use vlog directly
        Parameters
        ----------
        src_data: input tensor that we want to calculate log

        Returns
        -------
        res : return of log

        """
        # if src_data > 5/3, use vlog
        # vln
        multis_api = VecSingleApi(
            self.name, compute_op.mask,
            compute_op.tmp_work_tensor[compute_op.src_data_size:compute_op.src_data_size * 2], compute_op.src_data,
            compute_op.repeat_times, self.default_blk_stride, self.default_blk_stride, compute_op.src_rep_stride,
            compute_op.src_rep_stride, 0, 'vln')
        vln_stmt = NewVectorOnlyTemplate(self.source_info,
                                         SingleOpApi(self, multis_api), tik_debugger=compute_op.context.tik_debugger)
        vln_stmt.eval_(compute_op.context)

        # vector_dup
        multis_api = VecDupApi(self.name, compute_op.mask, compute_op.tmp_work_tensor[0:compute_op.src_data_size],
                               CONST_FIVE_THREE, compute_op.repeat_times, self.default_blk_stride,
                               compute_op.src_rep_stride, self.stride_unit, "normal", "vector_dup")
        vector_dup_stmt = NewVectorScalarEltwise(self.source_info,
                                                 DupOpApi(self, multis_api), compute_op.context.tik_debugger)
        vector_dup_stmt.eval_(compute_op.context)

        for index in range(compute_op.repeat_times):
            # vcmp_ge
            multis_api = VecVcmpApi(self.name, compute_op.mask, compute_op.src_data[index * compute_op.src_offset],
                                    compute_op.tmp_work_tensor[index * compute_op.src_offset],
                                    self.default_blk_stride, self.default_blk_stride, 'vcmp_ge')
            vcmd_stmt = NewVcmp(self.source_info, VcmpOpApi(self, multis_api), compute_op.context.tik_debugger)
            vcmd_stmt.eval_(compute_op.context)
            # vsel
            multis_api = VecVselApi(
                compute_op.mask, 0, compute_op.dst_data[index * compute_op.src_offset], vcmd_stmt,
                compute_op.tmp_work_tensor[compute_op.src_data_size + index * compute_op.src_offset],
                compute_op.tmp_dst_data[index * compute_op.src_offset], 1, self.default_blk_stride,
                self.default_blk_stride, self.default_blk_stride, compute_op.src_rep_stride,
                compute_op.src_rep_stride, compute_op.src_rep_stride, self.name, None, "vsel")
            vsel_stmt = Vsel(self.source_info, VselOpApi(self, multis_api), compute_op.context.tik_debugger)
            vsel_stmt.eval_(compute_op.context)

    def _call_vrec_high_preci(self, context, params):
        mask, dst, src, work_tensor, repeat_times, dst_rep_stride, src_rep_stride, _ = params
        high_preci = HighPreciDebug(mask, dst, src, work_tensor, repeat_times,
                                      dst_rep_stride, src_rep_stride, 'vec_ln_high_preci')
        hvrec_stmt_ = VrecHighPreci(
            self.source_info, high_preci, context.tik_debugger)
        hvrec_stmt_.eval_(context)

    def _ln_compute_block_lt_half(self, half_op):
        fp162fp32_high_preci_params = Fp162Fp32HighPreciApi(
            self.source_info, half_op.context, self._call_vrec_high_preci,
            half_op.mask, half_op.tmp_work_tensor[0:half_op.src_data_size], half_op.src_data,
            half_op.tmp_work_tensor[half_op.src_data_size:], half_op.repeat_times,
            half_op.src_rep_stride, half_op.src_rep_stride, 4, self.name)

        fp162fp32_high_preci_func(self, fp162fp32_high_preci_params)
        compute_block_tuple = VlnComputeBlockPreci(
            half_op.context, half_op.mask, half_op.tmp_work_tensor[half_op.src_data_size * 3:half_op.src_data_size * 4],
            half_op.tmp_dst_data, half_op.tmp_work_tensor[0:half_op.src_data_size],
            half_op.tmp_work_tensor[half_op.src_data_size:half_op.src_data_size * 3], half_op.repeat_times,
            half_op.src_rep_stride, half_op.src_data_size, half_op.src_offset)
        self._ln_compute_block_gt_5_3(compute_block_tuple)
        # vmuls
        multis_api = VecScalarMultisApi(
            self.name, half_op.mask, half_op.tmp_work_tensor[half_op.src_data_size:half_op.src_data_size * 2],
            half_op.tmp_work_tensor[half_op.src_data_size * 3:half_op.src_data_size * 4], CONST_NEG_ONE,
            half_op.repeat_times, self.default_blk_stride, self.default_blk_stride,
            half_op.src_rep_stride, half_op.src_rep_stride, self.stride_unit, 0, "normal", "vmuls")
        vmuls_stmt_ = NewVectorScalarTemplate(self.source_info,
                                              ScalarMultisOps(self, multis_api), half_op.context.tik_debugger)
        vmuls_stmt_.eval_(half_op.context)

        # vector_dup
        multis_api = VecDupApi(self.name, half_op.mask, half_op.tmp_work_tensor, CONST_HALF,
                               half_op.repeat_times, self.default_blk_stride, half_op.src_rep_stride,
                               self.stride_unit, "normal", "vector_dup")
        vector_dup_stmt = NewVectorScalarEltwise(self.source_info,
                                                 DupOpApi(self, multis_api), half_op.context.tik_debugger)
        vector_dup_stmt.eval_(half_op.context)

        dst_offset = half_op.context.evaluate_expr(self.dst_rep_stride) * self.blk_data_nums
        for index in range(half_op.repeat_times):
            # vcmp_le
            multis_api = VecVcmpApi(self.name, half_op.mask, half_op.src_data[index * half_op.src_offset],
                                    half_op.tmp_work_tensor[index * half_op.src_offset], self.default_blk_stride,
                                    self.default_blk_stride, 'vcmp_le')
            vcmd_stmt = NewVcmp(self.source_info, VcmpOpApi(self, multis_api), half_op.context.tik_debugger)
            vcmd_stmt.eval_(half_op.context)
            # vsel
            multis_api = VecVselApi(
                half_op.mask, 0, half_op.dst_data[index * dst_offset], vcmd_stmt,
                half_op.tmp_work_tensor[half_op.src_data_size + index * half_op.src_offset],
                half_op.tmp_dst_data[index * half_op.src_offset], 1, self.default_blk_stride, self.default_blk_stride,
                self.default_blk_stride, half_op.src_rep_stride, half_op.src_rep_stride, half_op.src_rep_stride,
                self.name, None, "vsel")
            vsel_stmt = Vsel(self.source_info, VselOpApi(self, multis_api), half_op.context.tik_debugger)
            vsel_stmt.eval_(half_op.context)


def check_vector_stride(rep_stride_info):
    """
    check blk_stride and rep_stride params of vector instructions

    Parameters
    ----------
    rep_stride_info: dict of dst_rep_stride and src_rep_stride

    Returns
    -------
    None
    """
    for name, rep_stride in rep_stride_info.items():
        TikCheckUtil.check_type_match(rep_stride, (int, BasicExpr),
                                      "%s should be int, Expr or Scalar, input type is %s" % (name, type(rep_stride)))
        check_scalar_dtype(rep_stride, "scalar %s should be a scalar of int/uint" % name)
        TikCheckUtil.check_in_range_by_dtype(
            rep_stride, msg="%s should be in the range of [%s, %s], input value is %s"
            % (name, DEFAULT_STRIDE, MAX_REP_STRIDE_SINGLE_BYTE, rep_stride),
            var_range=[DEFAULT_STRIDE, MAX_REP_STRIDE_SINGLE_BYTE])


class VrecHighPreci(STMT):
    """
    this stmt for vrec high precision
    """

    def __init__(self, source_info, vrec_h_obj, tik_debugger):
        super(VrecHighPreci, self).__init__(source_info, tik_debugger)
        self.name = "vec_rec_high_preci"
        self.obj = vrec_h_obj
        self.context = None

    def vrec_high_preci(self, context, params):
        """
        high precision for vrec
        """
        mask, dst, src, work_tensor, repeat_times, dst_rep_stride, src_rep_stride, tensor_split_size = params

        vrec_api = VecSingleApi(self.obj.api_name, mask, dst, src, repeat_times, MIN_STRIDE,
                                MIN_STRIDE, dst_rep_stride, src_rep_stride, MIN_STRIDE_UNIT, 'vrec')
        vrec_obj = SingleOpApi(self, vrec_api)
        vrec_stmt = NewVectorOnlyTemplate(self.source_info, vrec_obj, tik_debugger=context.tik_debugger)
        vrec_stmt.eval_(context)

        # iteration 1
        self._vmul_h_api(mask, [work_tensor[0:tensor_split_size], src, dst,
                                src_rep_stride, src_rep_stride, dst_rep_stride], context)
        self._vmuls_h_api(mask, [work_tensor[tensor_split_size:], work_tensor[0:tensor_split_size], -1,
                                 src_rep_stride, src_rep_stride], context)
        self._vmuls_h_api(mask, [work_tensor[0:tensor_split_size], work_tensor[tensor_split_size:], 2,
                                 src_rep_stride, src_rep_stride], context, api_name="vadds")
        self._vmul_h_api(mask, [work_tensor[tensor_split_size:], work_tensor[0:tensor_split_size], dst,
                                src_rep_stride, src_rep_stride, dst_rep_stride], context)

        # iteration 2
        self._vmul_h_api(mask, [work_tensor[0:tensor_split_size], src, work_tensor[tensor_split_size:],
                                src_rep_stride, src_rep_stride, src_rep_stride], context)
        self._vmuls_h_api(mask, [dst, work_tensor[0:tensor_split_size], -1,
                                 dst_rep_stride, src_rep_stride], context)
        self._vmuls_h_api(mask, [work_tensor[0:tensor_split_size], dst, 2,
                                 src_rep_stride, dst_rep_stride], context, api_name="vadds")
        self._vmul_h_api(mask, [dst, work_tensor[0:tensor_split_size], work_tensor[tensor_split_size:],
                                dst_rep_stride, src_rep_stride, src_rep_stride], context)

    def eval_(self, context):
        """
        run the instruction

        Parameters
        ----------
        context : the stack context

        Returns
        -------
        None
        """
        self.context = context
        repeat_times = context.evaluate_expr(self.obj.repeat_times)
        src_rep_stride = context.evaluate_expr(self.obj.src_rep_stride)
        dst_rep_stride = context.evaluate_expr(self.obj.dst_rep_stride)
        dst_offset = context.evaluate_expr(self.obj.dst.offset)
        src_offset = context.evaluate_expr(self.obj.src.offset)
        work_tensor_offset = context.evaluate_expr(self.obj.work_tensor.offset)
        set_vector_mask(self.obj.mask, context,
                        tensor_bit_len=max(get_bit_len(self.obj.src.dtype), get_bit_len(self.obj.dst.dtype)))
        mask = eval_mask(self.obj.mask, context)

        multi_factor = 2
        if self.obj.src.dtype == "float16":
            # 4B of fp32, need keep 32B algin
            multi_factor += 2
        # step for check params, overflow, overlap
        TikCheckUtil.check_in_range_by_dtype(
            repeat_times, msg="repeat_times should be in the range of [%s, %s], input repeat_times is %s"
            % (0, MAX_REPEAT_TIMES, repeat_times),
            var_range=[0, MAX_REPEAT_TIMES])
        check_vector_stride({'src_rep_stride': src_rep_stride, 'dst_rep_stride': dst_rep_stride})
        over_high_params = OverHighApi(mask, self.obj.dst, self.obj.src, self.obj.work_tensor,
                                       repeat_times, dst_rep_stride, src_rep_stride,
                                       dst_offset, src_offset, work_tensor_offset,
                                       multi_factor, name=self.name)
        check_over_high_preci(over_high_params)

        if self.obj.src.dtype == "float16":
            fp162fp32_high_preci_params = Fp162Fp32HighPreciApi(
                self.source_info, context, self.vrec_high_preci, mask, self.obj.dst, self.obj.src, self.obj.work_tensor,
                repeat_times, dst_rep_stride, src_rep_stride, multi_factor, name=self.name)
            fp162fp32_high_preci_func(self, fp162fp32_high_preci_params)

            return

        block_len = ONE_REP_BYTE_SIZE // get_bit_len(self.obj.src.dtype)
        src_extend = vector_max_offset_cal((mask, self.obj.src.dtype, block_len, repeat_times, 1, src_rep_stride))
        tensor_split_size = ceil_div(src_extend, block_len) * block_len
        if self.obj.src.dtype == "float32":
            self.vrec_high_preci(context, [mask, self.obj.dst, self.obj.src, self.obj.work_tensor,
                                           repeat_times, dst_rep_stride, src_rep_stride, tensor_split_size])

    def _vmul_h_api(self, mask, tensors, context):
        vmul_api = VecMultiApi(self.obj.api_name, mask, *tensors[:3], self.obj.repeat_times, MIN_STRIDE,
                               MIN_STRIDE, MIN_STRIDE, *tensors[3:], MIN_STRIDE_UNIT, 'vmul')
        vmul_obj = MultiOp(self, vmul_api)

        vmul_stmt0_ = NewVectorVectorTemplate(self.source_info, vmul_obj, context.tik_debugger)
        vmul_stmt0_.eval_(context)

    def _vmuls_h_api(self, mask, tensors, context, api_name='vmuls'):
        scalar_multis_api = VecScalarMultisApi(
            self.obj.api_name, mask, *tensors[:3], self.obj.repeat_times, MIN_STRIDE, MIN_STRIDE,
            *tensors[3:], MIN_STRIDE_UNIT, 0, 'normal', api_name)
        vmuls_obj = ScalarMultisOps(self, scalar_multis_api)

        vmuls_stmt_ = NewVectorScalarTemplate(self.source_info, vmuls_obj, tik_debugger=context.tik_debugger)
        vmuls_stmt_.eval_(context)
