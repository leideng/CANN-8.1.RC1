#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
merge similar range rule
"""
import functools
from itertools import groupby
from typing import List

RANGE_CMP_SYMBOL_LIST = ["<=", ">=", "==", "!=", ">=&&<="]
_merge_expr_rules = []


def register_merge_expr_rule():
    """
    register merge_expr_rule
    :return:
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        _merge_expr_rules.append(wrapper)
        return wrapper

    return decorator


def get_merge_expr_rules():
    """
    get merge_expr_rules
    :return:
    """
    return _merge_expr_rules


@register_merge_expr_rule()
def eliminate_redundant_expr_rule(variant_range_info: List) -> List:
    """
    eleminate redundant expr
    1. Multiple groups of expressions of the same variable. If == exists, only == is retained.
    :param variant_range_info:
    :return:
    """
    new_range_info = []
    sorted_range_info = sorted(variant_range_info, key=lambda x: (x[0], x[1], x[2]))
    group_range_info = [list(g) for _, g in groupby(sorted_range_info, lambda x: (x[0], x[1]))]
    for every_group in group_range_info:
        eliminate_flag = False
        for expr in sorted(every_group, key=lambda x: x[2] != RANGE_CMP_SYMBOL_LIST.index("==")):
            if expr[2] == RANGE_CMP_SYMBOL_LIST.index("=="):
                eliminate_flag = True
                new_range_info.append(expr)
                break
        if not eliminate_flag:
            new_range_info.extend(every_group)

    return new_range_info


@register_merge_expr_rule()
def ge_and_le_to_gele_rule(variant_range_info: List) -> List:
    """
    Combine <= and >= of the same variable into >=&&<=.
    If the left and right values are the same, combine them into ==.
    :param variant_range_info:
    :return:
    """
    sorted_range_info = sorted(variant_range_info, key=lambda x: (x[0], x[2]))
    new_range_info = []
    s_p = 0
    f_p = 1
    while s_p < len(sorted_range_info):
        if f_p >= len(sorted_range_info) or \
                sorted_range_info[s_p][2] not in [0, 1] or \
                sorted_range_info[f_p][2] not in [0, 1] or \
                sorted_range_info[s_p][0] != sorted_range_info[f_p][0] or \
                sorted_range_info[s_p][1] != sorted_range_info[f_p][1]:
            new_range_info.append(sorted_range_info[s_p])
            s_p += 1
            f_p += 1
            continue
        right_val_ld = min(sorted_range_info[s_p][3][0], sorted_range_info[f_p][3][0])
        right_val_rd = max(sorted_range_info[s_p][3][1], sorted_range_info[f_p][3][1])
        cmp_symbol_new = RANGE_CMP_SYMBOL_LIST.index(">=&&<=")
        if right_val_ld == right_val_rd:
            cmp_symbol_new = RANGE_CMP_SYMBOL_LIST.index("==")
        new_range_info.append([
            sorted_range_info[s_p][0],
            max(sorted_range_info[s_p][1], sorted_range_info[f_p][1]),
            cmp_symbol_new,
            [right_val_ld, right_val_rd]
        ])
        s_p += 2
        f_p += 2

    return new_range_info


@register_merge_expr_rule()
def merge_ee_and_same_right_value_one_rule(variant_range_info: List) -> List:
    """
    x==1&&y==1&&... to x*y==1
    :param variant_range_info:
    :return:
    """
    new_range_info = []
    r_v_one_range_info = []
    for v_expr in variant_range_info:
        if v_expr[2] == RANGE_CMP_SYMBOL_LIST.index("==") and v_expr[3] == [1, 1]:
            r_v_one_range_info.append(v_expr)
        else:
            new_range_info.append(v_expr)
    # The combined range_info of r_v_one must be placed at the end because this condition is a general condition.
    if len(r_v_one_range_info) > 0:
        merge_range_info = r_v_one_range_info[0]
        for expr in r_v_one_range_info[1:]:
            merge_range_info[0].extend(expr[0])
            merge_range_info[1] = max(merge_range_info[1], expr[1])
        new_range_info.append(merge_range_info)

    return new_range_info
