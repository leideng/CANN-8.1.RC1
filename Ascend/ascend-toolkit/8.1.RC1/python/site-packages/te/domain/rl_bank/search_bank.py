#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# Copyright 2019-2020 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
dynamic rl bank, generate schedule from built-in bank or custom bank
"""
import ast
import os
from typing import Union
from typing import Any
from typing import Tuple
from typing import Dict
from typing import List

from tbe import tvm
from tbe.tvm.te.schedule import Schedule
from tbe.common.context import op_context
from tbe.common.repository_manager.interface import cann_kb_search
from tbe.common.platform import platform_info
from tbe.common.utils import log
from tbe.dsl.base import operation
from tbe.dsl.static_schedule.util import gen_dfs_tensor_map
from tbe.dsl.static_schedule.util import get_reduce_axis_num
from tbe.common.rl_bank.dynamic_op_filter import dynamic_op_filter
from tbe.common.rl_bank import dync_rl_bank
from tbe.common.rl_bank import static_rl_bank
from tbe.common.rl_bank.bank_cfg import DTYPE_INDEX
from tbe.common.rl_bank.bank_cfg import SPEC_ATTR_KEY
from tbe.common.rl_bank.bank_cfg import TAG_INDEX


def get_op_context_infos():
    """
    get infos from context
    :return:
    """
    op_name = ""
    kernel_name = ""
    op_type = []
    context_ori = op_context.get_context()
    if context_ori:
        op_name = context_ori.get_addition("op_name")
        if not op_name:
            log.warn("Auto search bank info: get invalid op_name: %s", op_name)
            op_name = ""
        op_info_obj_list = context_ori.get_op_info()
        if isinstance(op_info_obj_list, list) and len(op_info_obj_list) >= 1:
            kernel_name = op_info_obj_list[0].kernel_name
            for op in op_info_obj_list:
                op_type.append(op.op_type)

    context = operation.get_context()
    op_mode = context.get_mode() if context else ""
    op_infos = {"op_name": op_name, "kernel_name": kernel_name, "op_type": op_type, 'op_mode': op_mode}
    return context_ori, op_infos


def add_sch_additional_entry(sch: Schedule, k: str, v: Any):
    """
    add sch additional entry
    :param sch:
    :param k:
    :param v:
    :return:
    """
    if not hasattr(sch, "addition"):
        sch.addition = {}
    sch.addition[k] = v


def get_sch_additional_entry(sch: Schedule, k: str):
    """
    get sch additional entry
    :param sch:
    :param k:
    :return:
    """
    if not hasattr(sch, "addition"):
        return None
    return sch.addition.get(k)


def _get_rl_bank_key(output_tensors: list, op_info: dict = None) -> str:
    """
    get tmp rl bank key for final_bank_key
    :param output_tensors:
    :param op_info:
    :return: bank_key or ""
    """
    # try to get dfs_tensor_list from op_info by auto_schedule
    dfs_tensor_list = []
    if op_info and op_info.get("dfs_tensor_list", None):
        dfs_tensor_list = op_info["dfs_tensor_list"]

    if not dfs_tensor_list:
        dfs_tensor_list = get_dfs_tensor_list(output_tensors)
    try:
        bank_key = gen_tensor_feature(dfs_tensor_list)
    except Exception as excp:  # pylint: disable=broad-except
        log.warn("Auto search bank info: can not get bank_key: %s", str(excp))
        return ""
    finally:
        pass

    log.debug("Auto search bank info: get bank_key: %s", bank_key)
    return bank_key


def get_rl_bank_key(output_tensors_list: list, op_info: dict = None) -> str:
    """
    generate bank_key from tensor info
    tensor_info_list, one for one tensor:tag，output shape，
    output dtype，reduce_axis，depends
    :param output_tensors_list:
    :param op_info:
    :return: final_bank_key
    """
    final_bank_key = ""
    if isinstance(output_tensors_list, list) and isinstance(output_tensors_list[0], list):
        for output_tensors in output_tensors_list:
            curr_bank_key = _get_rl_bank_key(output_tensors, op_info=op_info)
            if not curr_bank_key:
                return ""
            final_bank_key += curr_bank_key
    else:
        return _get_rl_bank_key(output_tensors_list, op_info=op_info)
    return final_bank_key


def get_dfs_tensor_list(out_tensors: list) -> list:
    """
    get_dfs_tensor_list
    :param out_tensors:
    :return: dfs_tensor_list
    """
    if not isinstance(out_tensors, list):
        out_tensors = [out_tensors]

    dfs_tensor_list, _, _, _ = gen_dfs_tensor_map(out_tensors)

    return dfs_tensor_list


def gen_attr_feature(tensor: object, curr_tensor_info_list: list) -> None:
    """
    gen_attr_feature
    :param tensor:
    :param curr_tensor_info_list:
    :return:
    """
    if bool(tensor.op.attrs) and any((attr in tensor.op.attrs for attr in SPEC_ATTR_KEY)):
        curr_tensor_info_list.append([])
        for attr in SPEC_ATTR_KEY:
            if attr not in tensor.op.attrs:
                continue
            if attr == "L1_addr_offset":
                cheque_value = 0
            else:
                cheque_value = tensor.op.attrs[attr]
            curr_tensor_info_list[-1].append([SPEC_ATTR_KEY.index(attr), cheque_value])


def gen_axis_feature(tensor: object, curr_tensor_info_list: list, compute_var_list: list) -> None:
    """
    gen_axis_feature
    :param tensor:
    :param curr_tensor_info_list:
    :param compute_var_list:
    :return:
    """
    if isinstance(tensor.op, tvm.PlaceholderOp):
        axis_value_list = []
        for shape_val in tensor.op.shape:
            if isinstance(shape_val, tvm.Var):
                # if exist multiple vars, do it in the order of -1, -2, -3...
                if shape_val not in compute_var_list:
                    compute_var_list.append(shape_val)
                axis_value_list.append(-(compute_var_list.index(shape_val) + 1))
            else:
                axis_value_list.append(shape_val)
        # Placeholder has no axis, use shape
        curr_tensor_info_list.append(axis_value_list)
        curr_tensor_info_list.append([])
    else:
        # output shape
        axis_value_list = []
        for axis in tensor.op.axis:
            if hasattr(axis.dom.extent, "value"):
                axis_value_list.append(axis.dom.extent.value)
            else:
                # if exist multiple vars, do it in the order of -1, -2, -3...
                if axis.dom.extent not in compute_var_list:
                    compute_var_list.append(axis.dom.extent)
                axis_value_list.append(-(compute_var_list.index(axis.dom.extent) + 1))
        curr_tensor_info_list.append(axis_value_list)
        # reduce axis idx
        reduce_axis_idx_list = []
        try:
            if tensor.op.reduce_axis:
                reduce_axis_idx_list = get_reduce_axis_num(tensor)
        except (AttributeError, IndexError) as excp:
            log.warn("Auto search bank info: can not get reduce_axis_idx_list:%s", str(excp))
        finally:
            pass
        curr_tensor_info_list.append(reduce_axis_idx_list)


def gen_tensor_feature(dfs_tensor_list: list) -> str:
    """
    gen_tensor_feature
    :param dfs_tensor_list:
    :return: str(feature_list) or ""
    """
    feature_list = []
    depends_map = {}
    compute_var_list = []
    # get all tensor
    for tensor_idx, tensor in enumerate(dfs_tensor_list):
        if not isinstance(tensor, tvm.Tensor):
            log.debug("Auto search bank info: tensor is not instance of tvm.Tensor")
            return ""
        # olny support for PlaceholderOp and ComputeOp
        if not isinstance(tensor.op, (tvm.PlaceholderOp, tvm.ComputeOp)):
            log.debug("Auto search bank info: tensor.op is not instance of PlaceholderOp or ComputeOp")
            return ""
        curr_tensor_info_list = []
        # ===tag===
        op_tag = tensor.op.tag.split("|")[0] if tensor.op.tag else ""
        if op_tag not in TAG_INDEX:
            log.debug("Auto search bank info: op_tag %s not in TAG_INDEX", op_tag)
            return ""
        curr_tensor_info_list.append(TAG_INDEX[op_tag])

        # op attrs info
        gen_attr_feature(tensor, curr_tensor_info_list)

        # ===axis===
        gen_axis_feature(tensor, curr_tensor_info_list, compute_var_list)

        # elewise_binary_vcmpv_xx dsl ouput is bool
        # but while tvm.schedule pickle, bool will convert to uint1
        # Here, work around the problem.
        output_dtype = tensor.op.output(0).dtype
        if tensor.op.tag.startswith(
                "elewise_binary_vcmpv_") and output_dtype == "uint1":
            output_dtype = "bool"
        curr_tensor_info_list.append(DTYPE_INDEX[output_dtype])

        # ===depends===
        for input_tensor in tensor.op.input_tensors:
            depends_map.setdefault(input_tensor.op.name, []).append(tensor_idx)
        curr_tensor_info_list.append(depends_map.get(tensor.op.name, []))

        feature_list.append(curr_tensor_info_list)

    return str(feature_list)


def report_hit_status(hit_bank: bool, op_infos: Dict, context: object) -> None:
    """
    report op hit bank status
    :param hit_bank: True for hit bank, False for not hit bank
    :param op_name
    :param kernel_name
    :param context
    :return:
    """
    op_name = op_infos.get("op_name", "")
    kernel_name = op_infos.get("kernel_name", "")
    op_type = op_infos.get("op_type", None)

    if not context:
        log.info("Auto search bank info: report_hit_status: op_name: %s, context: %s.", op_name, str(context))
        return

    if not op_name:
        log.warn("Auto search bank info: report_hit_status: get invalid op_name: %s.", op_name)
        return

    if not op_type:
        log.warn("Auto search bank info: report_hit_status: op %s get invalid op_type.", op_name)
        return

    if not dynamic_op_filter.optype_check_support(op_type, kernel_name):
        log.debug("Auto search bank info: report_hit_status: op %s is not supported by rl tune", op_name)
        return

    context.add_build_json_result("KBHit", hit_bank)
    if hit_bank:
        log.info("Auto search bank info: op_name: %s hit bank result: %s report succ.", op_name, hit_bank)
    else:
        log.debug("Auto search bank info: op_name: %s hit bank result: %s report succ.", op_name, hit_bank)


def get_cheque_by_kb_search(rl_bank_key: str, config: dict = None) -> Tuple[List, str]:
    """
    get cheque by repository manager cann_kb_search interface
    :param rl_bank_key: rl bank key of op
    :param config: config info
    :return: cheque
    """
    info_dict_str = rl_bank_key
    kb_name_op_mode_suffix = config.get("op_mode", "static")
    kernel_name = config.get("kernel_name", "")
    search_config = {
        "op_type": f"vector_dsl_{kb_name_op_mode_suffix}",
        "core_type": platform_info.get_soc_spec(platform_info.AICORE_TYPE),
        "full_info": True
    }
    knowledge_info_list = cann_kb_search(info_dict_str, search_config)

    if not knowledge_info_list:
        log.warn("Auto search bank info: kernel_name: %s, "
                 "knowledge_info_list from knowledge bank is null.", kernel_name)
        return [], "unknown"

    if "cheque" not in knowledge_info_list[0].get("knowledge", {}).keys():
        log.warn("Auto search bank info: kernel_name: %s, "
                 "the cheque is not found in the knowledge_info from knowledge bank.", kernel_name)
        return [], "unknown"

    # cann_kb_search return knowledge_info_list, only choose first
    knowledge_info = knowledge_info_list[0].get("knowledge")
    cheque = knowledge_info.get("cheque", [])
    version = str(knowledge_info.get("version", "unknown"))
    return cheque, version


def check_bank_hit(res_tensor: List, kernel_name: str, op_mode: str = "static") -> bool:
    """
    check wether hit bank or not
    :param res_tensor: res_tensor of op
    :param kernel_name: kernel name
    :param op_mode: op_mode
    :return: hit_res
    """
    rl_bank_key = get_rl_bank_key(res_tensor, op_info=None)
    log.debug("Auto search bank info: start check_bank_hit, op: %s, rl_bank_key: %s", kernel_name, rl_bank_key)

    config = {"op_mode": op_mode, "kernel_name": kernel_name}
    cheque, _ = get_cheque_by_kb_search(rl_bank_key, config)

    hit_res = False
    if cheque:
        hit_res = True
        log.info("Auto search bank info: op %s hit built-in bank.", kernel_name)

    return hit_res


def satisfy_bank(base_tick: int, tick: int, check_type: str = 'in') -> bool:
    """
    join in bank:
    1. absolute value difference > 5us
    2. absolute value difference > 100us or ratio < 0.95
    still stay in bank:
    1. absolute value difference > 20us or ratio < 0.9
    :param base_tick:
    :param tick:
    :param check_type: in or stay。
    :return: T/F
    """
    if check_type == 'in':
        log.debug("Auto search bank info: check conditions for bank updating")
        if tick and \
                base_tick and \
                base_tick - tick >= 5 and \
                (base_tick - tick >= 100 or tick / base_tick <= 0.95):
            log.debug("Auto search bank info: satisfy bank update conditions, best_tick:%s, base_tick:%s",
                      tick, base_tick)
            return True
    else:
        if tick and \
                base_tick and \
                (base_tick - tick >= 20 or tick / base_tick <= 0.9):
            log.debug("Auto search bank info: satisfy bank update conditions, best_tick:%s, base_tick:%s",
                      tick, base_tick)
            return True

    log.debug("Auto search bank info: not satisfy bank update conditions.")
    return False


def get_cheque_from_bank_cache(rl_bank_key: str) -> Union[Tuple[bool, Any], Tuple[bool, list]]:
    """
    get_cheque_from_bank_cache
    :param rl_bank_key
    :return:
    """
    from tbe.common.tiling.get_tiling_cube import BANK_CACHE
    if BANK_CACHE:
        log.debug("Auto search bank info: get cheque from BANK_CACHE addr: %s, value: %s", id(BANK_CACHE), BANK_CACHE)
        spec_cheque = ast.literal_eval(BANK_CACHE)
        if isinstance(spec_cheque, dict) and spec_cheque.get("rl_cheque", {}).get(rl_bank_key, []):
            cheque = spec_cheque["rl_cheque"][rl_bank_key]
            if cheque:
                log.info("Auto search bank info: get cheque from BANK_CACHE %s", cheque)
                return True, cheque
    return False, []


def get_cheque(out_tensors: List, op_info: Dict, op_infos: Dict, context: object) -> List:
    """
    get_cheque
    :param out_tensors:op compute output tensors
    :param op_info:op info contain dfs tensor list
    :param op_infos: op_name, kernel_name, op_mode
    :param context object
    :return: cheque from bank
    """
    op_name = op_infos.get("op_name", "")
    kernel_name = op_infos.get("kernel_name", "")
    op_mode = op_infos.get("op_mode", "static")
    log.debug("Auto search bank info: op_mode: %s, op_name: %s, kernel_name: %s, begin to get cheque.",
              op_mode, op_name, kernel_name)

    # get_rl_bank_key
    rl_bank_key = get_rl_bank_key(out_tensors, op_info=op_info)
    if not rl_bank_key:
        log.info("Auto search bank info: op_name: %s, kernel_name: %s, rl_bank_key is empty.", op_name, kernel_name)
        return []

    # for aoe
    ret, cheque = get_cheque_from_bank_cache(rl_bank_key)
    if ret:
        log.debug("Auto search bank info: op_name: %s, kernel_name: %s, strategy from cache %s.",
                  op_name, kernel_name, cheque)
        return cheque

    config = {"op_mode": op_mode, "kernel_name": kernel_name}
    cheque, version = get_cheque_by_kb_search(rl_bank_key, config)

    hit_bank = True
    if not cheque:
        hit_bank = False
    log.info("Auto search bank info: hit bank status: %s, op_name: %s, kernel_name: %s.",
             hit_bank, op_name, kernel_name)
    log.debug("Auto search bank info: knowledge version: %s.", version)
    report_hit_status(hit_bank, op_infos, context)
    log.debug("Auto search bank info: %s strategy from bank: %s.", kernel_name, cheque)
    return cheque


def query_rl_bank(out_tensors: List, op_info: Dict = None,
                  sync_tensor: List = None, op_mode: str = "static") -> (bool, Union[object, None]):
    """
    query rl bank in static or dynamic mode, report hit status before return
    if op mode is pre-static, please call query_rl_bank in ../rl_bank.py
    :param out_tensors: op compute output tensors
    :param op_info: op info contain dfs tensor list
    :param sync_tensor: sync tensor
    :return:
    """
    if op_mode == "dynamic":
        dynamic_rl_bank = dync_rl_bank.DyncRLBank(out_tensors, op_info, sync_tensor)
        ret, rl_schedules = dynamic_rl_bank.query_dync_rl_bank()
    elif op_mode == "static":
        stc_rl_bank = static_rl_bank.StaticRLBank(out_tensors, op_info, sync_tensor)
        ret, rl_schedules = stc_rl_bank.query_static_rl_bank()
    else:
        ret = False
        rl_schedules = []
        log.warn("Auto search bank info: op_mode{%s} does not match the query interface, please check." % op_mode)

    return ret, rl_schedules
