#!/usr/bin/env python
# coding: utf-8
# Copyright 2021 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
cube_random_buff
"""
import math
import secrets
from te import tik
import te.platform as tbe_platform
from tbe.common.context import get_context


# available soc resources
L0A_SIZE = tbe_platform.get_soc_spec("L0A_SIZE")
L0B_SIZE = tbe_platform.get_soc_spec("L0B_SIZE")
L0C_SIZE = tbe_platform.get_soc_spec("L0C_SIZE")
UB_SIZE = tbe_platform.get_soc_spec(tbe_platform.UB_SIZE)
L1_SIZE = tbe_platform.get_soc_spec(tbe_platform.L1_SIZE)
# every number takes 2 bytes with dtype "float16"
DIV = 2
DIMS_A = math.sqrt(L0A_SIZE / DIV / 2)
DIMS_B = math.sqrt(L0B_SIZE / DIV / 2)
DIMS_C = math.sqrt(L0C_SIZE / DIV / 2)
LOOP_NUM = UB_SIZE / (2 * 128) / 128


def tik_instance_fun(kernel_name):
    # type:(str) -> str
    """
    zerolize the data in L0, randomize parts of UB data
    """
    tik_instance = tik.Tik()

    # define 3 tensors in L0A/L0B/L0C
    # the shapes of these tensors is [2a, a], [b, 2b] and [c, 2c]
    dst_l0a = tik_instance.Tensor("float16", (2*DIMS_A, DIMS_A), name="dst_l0a", scope=tik.scope_ca)
    dst_l0b = tik_instance.Tensor("float16", (DIMS_B, 2*DIMS_B), name="dst_l0b", scope=tik.scope_cb)
    dst_l0c = tik_instance.Tensor("float16", (DIMS_C, 2*DIMS_C), name="dst_l0c", scope=tik.scope_cc)

    # set data in L0A/L0B as 0
    tik_instance.set_l0_set_value(0.0, "float16")
    tik_instance.tensor_padding_with_matrix(dst_l0a, 128)
    tik_instance.tensor_padding_with_matrix(dst_l0b, 128)

    # overwrite the L0C data by 2 times mmad compute
    with tik_instance.for_range(0, 2) as idx:
        offset = idx*256
        tik_instance.mmad(dst_l0c[0, offset], dst_l0a[0], dst_l0b[0], 256, 128, 256, 0)

    src_ub = tik_instance.Tensor("int16", (UB_SIZE // DIV,), name="src_ub", scope=tik.scope_ubuf)
    dst_l1 = tik_instance.Tensor("float16", (L1_SIZE // DIV,), name="dst_l1", scope=tik.scope_cbuf)

    # define the data offset
    randscalar = tik_instance.Scalar(dtype="int16")
    randscalar.set_as(src_ub[0])

    # define the addr. offset
    block_offset = tik_instance.Scalar(dtype="uint16")
    src_ub_uint = src_ub.reinterpret_cast_to("uint16")
    block_offset.set_as(src_ub_uint[0])
    block_offset.set_as(block_offset % 8)

    # randomize every 1/8 blocks of data
    with tik_instance.for_range(0, LOOP_NUM) as idx:
        offset_compute = (idx*1024 + block_offset)*16
        tik_instance.vec_dup(16, src_ub[offset_compute], randscalar, 96, 8)

    # move L0 data to L1
    with tik_instance.for_range(0, L1_SIZE//UB_SIZE) as idx:
        offset = idx*UB_SIZE//DIV + block_offset*16
        tik_instance.data_move(dst_l1[offset], src_ub[block_offset*16], 0, 800, 1, 8, 8)

    _add_info_to_context()

    tik_instance.BuildCCE(kernel_name=kernel_name, inputs=(), outputs=(), enable_l2=False,
                          config={"build_sub_function": True, "dump_to_header_file": True})

    return tik_instance


def _add_info_to_context():
    # type:() -> None
    # add info to context
    context = get_context()
    if context:
        context.add_addition("compile_reset_op", "clear_cube")
    else:
        raise ValueError("Context does not exit")


def cube_random_buff(kernel_name=None):
    # type:(str) -> str
    """
    zerolize the data in L0, randomize parts of UB data
    """
    short_soc_version = tbe_platform.get_soc_spec("SHORT_SOC_VERSION")
    if short_soc_version == "Ascend910":
        if kernel_name is None:
            kernel_name = "cube_random_buff"
        return tik_instance_fun(kernel_name)
    return tik.Tik()
